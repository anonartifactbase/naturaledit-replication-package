[
    {
        "data": {},
        "source": "frontend",
        "timestamp": "2025-08-23 10:25:15.000",
        "event": "click_summarize_code",
        "id": "S8Ay9jddgD5C65gpliFC"
    },
    {
        "data": {
            "selected_code": "import pandas as pd\nimport os\n\n\ndef scrape_mvp_votes(start_year=2018, end_year=2025):\n    all_votes = []\n    for year in range(start_year, end_year + 1):\n        url = f\"https://www.basketball-reference.com/awards/awards_{year}.html\"\n        tables = pd.read_html(url, header=1)\n        try:\n            mvp_table = tables[0]  # MVP table is the first table\n            mvp_table[\"Year\"] = year\n            all_votes.append(mvp_table)\n        except:\n            print(f\"Could not parse year {year}\")\n\n    df = pd.concat(all_votes)\n    df = df.rename(columns={\"Player\": \"Name\", \"Pts Won\": \"MVP_Points\"})\n    return df[[\"Year\", \"Name\", \"MVP_Points\"]]\n\n\ndef scrape_season_stats(year):\n    base_url_reg = (\n        f\"https://www.basketball-reference.com/leagues/NBA_{year}_per_game.html\"\n    )\n    df_reg = pd.read_html(base_url_reg, header=0)[0]\n    df_reg = df_reg[df_reg[\"Player\"] != \"Player\"]  # remove repeated header rows\n    df_reg[\"Year\"] = year\n\n    df_reg = df_reg[\n        [\"Player\", \"Year\", \"PTS\", \"AST\", \"TRB\", \"FG%\"]\n    ]  # Keep only specified columns\n    df_reg = df_reg.dropna(\n        subset=[\"PTS\", \"AST\", \"TRB\", \"FG%\"]\n    )  # Ensure key stats aren't invalid\n    return df_reg\n\n\ndef scrape_multiple_seasons(start_year=2018, end_year=2025):\n    all_stats = []\n    for year in range(start_year, end_year + 1):\n        df = scrape_season_stats(year)\n        all_stats.append(df)\n    return pd.concat(all_stats)\n\n\nif __name__ == \"__main__\":\n    if not os.path.exists(\"data\"):\n        os.makedirs(\"data\")\n\n    print(\"Scraping MVP votes...\")\n    mvp_df = scrape_mvp_votes()\n    mvp_df.to_csv(\"data/mvp_votes.csv\", index=False)\n\n    print(\"Scraping player stats...\")\n    stats_df = scrape_multiple_seasons()\n    stats_df.to_csv(\"data/season_stats.csv\", index=False)\n",
            "summary": {
                "medium_unstructured": "The code collects NBA MVP voting results and player per-game statistics from Basketball Reference for seasons between 2018 and 2025. It processes and combines the data, then saves the results as CSV files in a local 'data' directory. The script handles missing data gracefully and ensures only relevant columns are kept.",
                "low_structured": "• Scrapes MVP votes and player stats from Basketball Reference\n• Saves the data as CSV files",
                "title": "Basketball Reference MVP Votes and Player Stats Scraper",
                "medium_structured": "• Scrapes MVP voting data and player per-game stats for NBA seasons 2018-2025\n• Processes and combines data from Basketball Reference tables\n• Saves MVP votes and player stats as separate CSV files in a 'data' directory\n• Handles missing or unparseable years by printing a message",
                "high_unstructured": "This script defines functions to scrape NBA MVP voting results and player per-game statistics from Basketball Reference for the years 2018 through 2025. The 'scrape_mvp_votes' function fetches MVP voting tables, renames columns, and consolidates the data, handling years that can't be parsed by printing a warning. The 'scrape_season_stats' function retrieves player stats, removes duplicate headers, filters for key statistics, and drops rows with missing values. The main block ensures a 'data' directory exists, then saves the compiled MVP votes and player stats as CSV files, providing progress updates via print statements.",
                "high_structured": "• Defines functions to scrape and process NBA data from Basketball Reference for 2018-2025\n  ◦ scrape_mvp_votes: Fetches MVP voting tables, renames columns, and consolidates data\n    ◦ Handles parsing errors by printing a warning for unparseable years\n  ◦ scrape_season_stats: Retrieves player per-game stats, removes duplicate headers, selects key columns (PTS, AST, TRB, FG%), and drops rows with missing values\n  ◦ scrape_multiple_seasons: Aggregates per-season stats across the specified year range\n• Main execution block:\n  ◦ Ensures a 'data' directory exists, creating it if necessary\n  ◦ Scrapes MVP votes and saves them as 'data/mvp_votes.csv'\n  ◦ Scrapes player stats for all seasons and saves them as 'data/season_stats.csv'\n  ◦ Provides progress updates with print statements",
                "low_unstructured": "This script scrapes NBA MVP voting data and player statistics from Basketball Reference and saves them as CSV files."
            }
        },
        "source": "backend",
        "timestamp": "2025-08-23 10:25:31.000",
        "event": "summarize_selected_code",
        "id": "GVsquK9L6fNFCfWmjAzO"
    },
    {
        "data": {
            "mapping": [
                {
                    "summaryComponent": "Scrapes MVP votes",
                    "codeSegments": [
                        {
                            "line": 5,
                            "code": "def scrape_mvp_votes(start_year=2018, end_year=2025):"
                        },
                        {
                            "line": 52,
                            "code": "mvp_df = scrape_mvp_votes()"
                        }
                    ]
                },
                {
                    "summaryComponent": "and player stats",
                    "codeSegments": [
                        {
                            "line": 22,
                            "code": "def scrape_season_stats(year):"
                        },
                        {
                            "line": 39,
                            "code": "def scrape_multiple_seasons(start_year=2018, end_year=2025):"
                        },
                        {
                            "line": 56,
                            "code": "stats_df = scrape_multiple_seasons()"
                        }
                    ]
                },
                {
                    "summaryComponent": "from Basketball Reference",
                    "codeSegments": [
                        {
                            "line": 8,
                            "code": "url = f\"https://www.basketball-reference.com/awards/awards_{year}.html\""
                        },
                        {
                            "line": 23,
                            "code": "base_url_reg = ("
                        },
                        {
                            "line": 24,
                            "code": "f\"https://www.basketball-reference.com/leagues/NBA_{year}_per_game.html\""
                        }
                    ]
                },
                {
                    "summaryComponent": "Saves the data as CSV files",
                    "codeSegments": [
                        {
                            "line": 53,
                            "code": "mvp_df.to_csv(\"data/mvp_votes.csv\", index=False)"
                        },
                        {
                            "line": 57,
                            "code": "stats_df.to_csv(\"data/season_stats.csv\", index=False)"
                        }
                    ]
                }
            ],
            "summary": "• Scrapes MVP votes and player stats from Basketball Reference\n• Saves the data as CSV files",
            "code": "1: import pandas as pd\n2: import os\n3: \n4: \n5: def scrape_mvp_votes(start_year=2018, end_year=2025):\n6:     all_votes = []\n7:     for year in range(start_year, end_year + 1):\n8:         url = f\"https://www.basketball-reference.com/awards/awards_{year}.html\"\n9:         tables = pd.read_html(url, header=1)\n10:         try:\n11:             mvp_table = tables[0]  # MVP table is the first table\n12:             mvp_table[\"Year\"] = year\n13:             all_votes.append(mvp_table)\n14:         except:\n15:             print(f\"Could not parse year {year}\")\n16: \n17:     df = pd.concat(all_votes)\n18:     df = df.rename(columns={\"Player\": \"Name\", \"Pts Won\": \"MVP_Points\"})\n19:     return df[[\"Year\", \"Name\", \"MVP_Points\"]]\n20: \n21: \n22: def scrape_season_stats(year):\n23:     base_url_reg = (\n24:         f\"https://www.basketball-reference.com/leagues/NBA_{year}_per_game.html\"\n25:     )\n26:     df_reg = pd.read_html(base_url_reg, header=0)[0]\n27:     df_reg = df_reg[df_reg[\"Player\"] != \"Player\"]  # remove repeated header rows\n28:     df_reg[\"Year\"] = year\n29: \n30:     df_reg = df_reg[\n31:         [\"Player\", \"Year\", \"PTS\", \"AST\", \"TRB\", \"FG%\"]\n32:     ]  # Keep only specified columns\n33:     df_reg = df_reg.dropna(\n34:         subset=[\"PTS\", \"AST\", \"TRB\", \"FG%\"]\n35:     )  # Ensure key stats aren't invalid\n36:     return df_reg\n37: \n38: \n39: def scrape_multiple_seasons(start_year=2018, end_year=2025):\n40:     all_stats = []\n41:     for year in range(start_year, end_year + 1):\n42:         df = scrape_season_stats(year)\n43:         all_stats.append(df)\n44:     return pd.concat(all_stats)\n45: \n46: \n47: if __name__ == \"__main__\":\n48:     if not os.path.exists(\"data\"):\n49:         os.makedirs(\"data\")\n50: \n51:     print(\"Scraping MVP votes...\")\n52:     mvp_df = scrape_mvp_votes()\n53:     mvp_df.to_csv(\"data/mvp_votes.csv\", index=False)\n54: \n55:     print(\"Scraping player stats...\")\n56:     stats_df = scrape_multiple_seasons()\n57:     stats_df.to_csv(\"data/season_stats.csv\", index=False)\n58: "
        },
        "source": "backend",
        "timestamp": "2025-08-23 10:25:33.000",
        "event": "map_summary_code",
        "id": "LlheZO2BUqqtOZgFpsQL"
    },
    {
        "data": {
            "mapping": [
                {
                    "summaryComponent": "scrapes NBA MVP voting data",
                    "codeSegments": [
                        {
                            "line": 5,
                            "code": "def scrape_mvp_votes(start_year=2018, end_year=2025):"
                        },
                        {
                            "line": 52,
                            "code": "mvp_df = scrape_mvp_votes()"
                        }
                    ]
                },
                {
                    "summaryComponent": "and player statistics",
                    "codeSegments": [
                        {
                            "line": 22,
                            "code": "def scrape_season_stats(year):"
                        },
                        {
                            "line": 39,
                            "code": "def scrape_multiple_seasons(start_year=2018, end_year=2025):"
                        },
                        {
                            "line": 56,
                            "code": "stats_df = scrape_multiple_seasons()"
                        }
                    ]
                },
                {
                    "summaryComponent": "from Basketball Reference",
                    "codeSegments": [
                        {
                            "line": 8,
                            "code": "url = f\"https://www.basketball-reference.com/awards/awards_{year}.html\""
                        },
                        {
                            "line": 23,
                            "code": "base_url_reg = (\n    f\"https://www.basketball-reference.com/leagues/NBA_{year}_per_game.html\"\n)"
                        }
                    ]
                },
                {
                    "summaryComponent": "and saves them as CSV files",
                    "codeSegments": [
                        {
                            "line": 53,
                            "code": "mvp_df.to_csv(\"data/mvp_votes.csv\", index=False)"
                        },
                        {
                            "line": 57,
                            "code": "stats_df.to_csv(\"data/season_stats.csv\", index=False)"
                        }
                    ]
                }
            ],
            "summary": "This script scrapes NBA MVP voting data and player statistics from Basketball Reference and saves them as CSV files.",
            "code": "1: import pandas as pd\n2: import os\n3: \n4: \n5: def scrape_mvp_votes(start_year=2018, end_year=2025):\n6:     all_votes = []\n7:     for year in range(start_year, end_year + 1):\n8:         url = f\"https://www.basketball-reference.com/awards/awards_{year}.html\"\n9:         tables = pd.read_html(url, header=1)\n10:         try:\n11:             mvp_table = tables[0]  # MVP table is the first table\n12:             mvp_table[\"Year\"] = year\n13:             all_votes.append(mvp_table)\n14:         except:\n15:             print(f\"Could not parse year {year}\")\n16: \n17:     df = pd.concat(all_votes)\n18:     df = df.rename(columns={\"Player\": \"Name\", \"Pts Won\": \"MVP_Points\"})\n19:     return df[[\"Year\", \"Name\", \"MVP_Points\"]]\n20: \n21: \n22: def scrape_season_stats(year):\n23:     base_url_reg = (\n24:         f\"https://www.basketball-reference.com/leagues/NBA_{year}_per_game.html\"\n25:     )\n26:     df_reg = pd.read_html(base_url_reg, header=0)[0]\n27:     df_reg = df_reg[df_reg[\"Player\"] != \"Player\"]  # remove repeated header rows\n28:     df_reg[\"Year\"] = year\n29: \n30:     df_reg = df_reg[\n31:         [\"Player\", \"Year\", \"PTS\", \"AST\", \"TRB\", \"FG%\"]\n32:     ]  # Keep only specified columns\n33:     df_reg = df_reg.dropna(\n34:         subset=[\"PTS\", \"AST\", \"TRB\", \"FG%\"]\n35:     )  # Ensure key stats aren't invalid\n36:     return df_reg\n37: \n38: \n39: def scrape_multiple_seasons(start_year=2018, end_year=2025):\n40:     all_stats = []\n41:     for year in range(start_year, end_year + 1):\n42:         df = scrape_season_stats(year)\n43:         all_stats.append(df)\n44:     return pd.concat(all_stats)\n45: \n46: \n47: if __name__ == \"__main__\":\n48:     if not os.path.exists(\"data\"):\n49:         os.makedirs(\"data\")\n50: \n51:     print(\"Scraping MVP votes...\")\n52:     mvp_df = scrape_mvp_votes()\n53:     mvp_df.to_csv(\"data/mvp_votes.csv\", index=False)\n54: \n55:     print(\"Scraping player stats...\")\n56:     stats_df = scrape_multiple_seasons()\n57:     stats_df.to_csv(\"data/season_stats.csv\", index=False)\n58: "
        },
        "source": "backend",
        "timestamp": "2025-08-23 10:25:33.000",
        "event": "map_summary_code",
        "id": "q3JQTaDAArLmriErK8qA"
    },
    {
        "data": {
            "mapping": [
                {
                    "summaryComponent": "Scrapes MVP voting data and player per-game stats for NBA seasons 2018-2025",
                    "codeSegments": [
                        {
                            "line": 5,
                            "code": "def scrape_mvp_votes(start_year=2018, end_year=2025):"
                        },
                        {
                            "line": 22,
                            "code": "def scrape_season_stats(year):"
                        },
                        {
                            "line": 39,
                            "code": "def scrape_multiple_seasons(start_year=2018, end_year=2025):"
                        }
                    ]
                },
                {
                    "summaryComponent": "Processes and combines data from Basketball Reference tables",
                    "codeSegments": [
                        {
                            "line": 9,
                            "code": "tables = pd.read_html(url, header=1)"
                        },
                        {
                            "line": 11,
                            "code": "mvp_table = tables[0]  # MVP table is the first table"
                        },
                        {
                            "line": 17,
                            "code": "df = pd.concat(all_votes)"
                        },
                        {
                            "line": 26,
                            "code": "df_reg = pd.read_html(base_url_reg, header=0)[0]"
                        },
                        {
                            "line": 42,
                            "code": "df = scrape_season_stats(year)"
                        },
                        {
                            "line": 44,
                            "code": "return pd.concat(all_stats)"
                        }
                    ]
                },
                {
                    "summaryComponent": "Saves MVP votes and player stats as separate CSV files in a 'data' directory",
                    "codeSegments": [
                        {
                            "line": 48,
                            "code": "if not os.path.exists(\"data\"):"
                        },
                        {
                            "line": 49,
                            "code": "os.makedirs(\"data\")"
                        },
                        {
                            "line": 53,
                            "code": "mvp_df.to_csv(\"data/mvp_votes.csv\", index=False)"
                        },
                        {
                            "line": 57,
                            "code": "stats_df.to_csv(\"data/season_stats.csv\", index=False)"
                        }
                    ]
                },
                {
                    "summaryComponent": "Handles missing or unparseable years by printing a message",
                    "codeSegments": [
                        {
                            "line": 14,
                            "code": "except:"
                        },
                        {
                            "line": 15,
                            "code": "print(f\"Could not parse year {year}\")"
                        }
                    ]
                }
            ],
            "summary": "• Scrapes MVP voting data and player per-game stats for NBA seasons 2018-2025\n• Processes and combines data from Basketball Reference tables\n• Saves MVP votes and player stats as separate CSV files in a 'data' directory\n• Handles missing or unparseable years by printing a message",
            "code": "1: import pandas as pd\n2: import os\n3: \n4: \n5: def scrape_mvp_votes(start_year=2018, end_year=2025):\n6:     all_votes = []\n7:     for year in range(start_year, end_year + 1):\n8:         url = f\"https://www.basketball-reference.com/awards/awards_{year}.html\"\n9:         tables = pd.read_html(url, header=1)\n10:         try:\n11:             mvp_table = tables[0]  # MVP table is the first table\n12:             mvp_table[\"Year\"] = year\n13:             all_votes.append(mvp_table)\n14:         except:\n15:             print(f\"Could not parse year {year}\")\n16: \n17:     df = pd.concat(all_votes)\n18:     df = df.rename(columns={\"Player\": \"Name\", \"Pts Won\": \"MVP_Points\"})\n19:     return df[[\"Year\", \"Name\", \"MVP_Points\"]]\n20: \n21: \n22: def scrape_season_stats(year):\n23:     base_url_reg = (\n24:         f\"https://www.basketball-reference.com/leagues/NBA_{year}_per_game.html\"\n25:     )\n26:     df_reg = pd.read_html(base_url_reg, header=0)[0]\n27:     df_reg = df_reg[df_reg[\"Player\"] != \"Player\"]  # remove repeated header rows\n28:     df_reg[\"Year\"] = year\n29: \n30:     df_reg = df_reg[\n31:         [\"Player\", \"Year\", \"PTS\", \"AST\", \"TRB\", \"FG%\"]\n32:     ]  # Keep only specified columns\n33:     df_reg = df_reg.dropna(\n34:         subset=[\"PTS\", \"AST\", \"TRB\", \"FG%\"]\n35:     )  # Ensure key stats aren't invalid\n36:     return df_reg\n37: \n38: \n39: def scrape_multiple_seasons(start_year=2018, end_year=2025):\n40:     all_stats = []\n41:     for year in range(start_year, end_year + 1):\n42:         df = scrape_season_stats(year)\n43:         all_stats.append(df)\n44:     return pd.concat(all_stats)\n45: \n46: \n47: if __name__ == \"__main__\":\n48:     if not os.path.exists(\"data\"):\n49:         os.makedirs(\"data\")\n50: \n51:     print(\"Scraping MVP votes...\")\n52:     mvp_df = scrape_mvp_votes()\n53:     mvp_df.to_csv(\"data/mvp_votes.csv\", index=False)\n54: \n55:     print(\"Scraping player stats...\")\n56:     stats_df = scrape_multiple_seasons()\n57:     stats_df.to_csv(\"data/season_stats.csv\", index=False)\n58: "
        },
        "source": "backend",
        "timestamp": "2025-08-23 10:25:34.000",
        "event": "map_summary_code",
        "id": "fXQlZKp86YOZRT2ZXNQ0"
    },
    {
        "data": {
            "mapping": [
                {
                    "summaryComponent": "collects NBA MVP voting results",
                    "codeSegments": [
                        {
                            "line": 5,
                            "code": "def scrape_mvp_votes(start_year=2018, end_year=2025):"
                        },
                        {
                            "line": 52,
                            "code": "mvp_df = scrape_mvp_votes()"
                        }
                    ]
                },
                {
                    "summaryComponent": "player per-game statistics",
                    "codeSegments": [
                        {
                            "line": 22,
                            "code": "def scrape_season_stats(year):"
                        },
                        {
                            "line": 39,
                            "code": "def scrape_multiple_seasons(start_year=2018, end_year=2025):"
                        },
                        {
                            "line": 56,
                            "code": "stats_df = scrape_multiple_seasons()"
                        }
                    ]
                },
                {
                    "summaryComponent": "from Basketball Reference",
                    "codeSegments": [
                        {
                            "line": 8,
                            "code": "url = f\"https://www.basketball-reference.com/awards/awards_{year}.html\""
                        },
                        {
                            "line": 23,
                            "code": "base_url_reg = ("
                        },
                        {
                            "line": 24,
                            "code": "f\"https://www.basketball-reference.com/leagues/NBA_{year}_per_game.html\""
                        }
                    ]
                },
                {
                    "summaryComponent": "for seasons between 2018 and 2025",
                    "codeSegments": [
                        {
                            "line": 5,
                            "code": "def scrape_mvp_votes(start_year=2018, end_year=2025):"
                        },
                        {
                            "line": 39,
                            "code": "def scrape_multiple_seasons(start_year=2018, end_year=2025):"
                        }
                    ]
                },
                {
                    "summaryComponent": "processes and combines the data",
                    "codeSegments": [
                        {
                            "line": 6,
                            "code": "all_votes = []"
                        },
                        {
                            "line": 40,
                            "code": "all_stats = []"
                        },
                        {
                            "line": 17,
                            "code": "df = pd.concat(all_votes)"
                        },
                        {
                            "line": 44,
                            "code": "return pd.concat(all_stats)"
                        }
                    ]
                },
                {
                    "summaryComponent": "saves the results as CSV files",
                    "codeSegments": [
                        {
                            "line": 53,
                            "code": "mvp_df.to_csv(\"data/mvp_votes.csv\", index=False)"
                        },
                        {
                            "line": 57,
                            "code": "stats_df.to_csv(\"data/season_stats.csv\", index=False)"
                        }
                    ]
                },
                {
                    "summaryComponent": "in a local 'data' directory",
                    "codeSegments": [
                        {
                            "line": 48,
                            "code": "if not os.path.exists(\"data\"):"
                        },
                        {
                            "line": 49,
                            "code": "os.makedirs(\"data\")"
                        },
                        {
                            "line": 53,
                            "code": "\"data/mvp_votes.csv\""
                        },
                        {
                            "line": 57,
                            "code": "\"data/season_stats.csv\""
                        }
                    ]
                },
                {
                    "summaryComponent": "handles missing data gracefully",
                    "codeSegments": [
                        {
                            "line": 14,
                            "code": "except:"
                        },
                        {
                            "line": 15,
                            "code": "print(f\"Could not parse year {year}\")"
                        }
                    ]
                },
                {
                    "summaryComponent": "ensures only relevant columns are kept",
                    "codeSegments": [
                        {
                            "line": 18,
                            "code": "df = df.rename(columns={\"Player\": \"Name\", \"Pts Won\": \"MVP_Points\"})"
                        },
                        {
                            "line": 19,
                            "code": "return df[[\"Year\", \"Name\", \"MVP_Points\"]]"
                        },
                        {
                            "line": 30,
                            "code": "df_reg = df_reg["
                        },
                        {
                            "line": 31,
                            "code": "[\"Player\", \"Year\", \"PTS\", \"AST\", \"TRB\", \"FG%\"]"
                        }
                    ]
                }
            ],
            "summary": "The code collects NBA MVP voting results and player per-game statistics from Basketball Reference for seasons between 2018 and 2025. It processes and combines the data, then saves the results as CSV files in a local 'data' directory. The script handles missing data gracefully and ensures only relevant columns are kept.",
            "code": "1: import pandas as pd\n2: import os\n3: \n4: \n5: def scrape_mvp_votes(start_year=2018, end_year=2025):\n6:     all_votes = []\n7:     for year in range(start_year, end_year + 1):\n8:         url = f\"https://www.basketball-reference.com/awards/awards_{year}.html\"\n9:         tables = pd.read_html(url, header=1)\n10:         try:\n11:             mvp_table = tables[0]  # MVP table is the first table\n12:             mvp_table[\"Year\"] = year\n13:             all_votes.append(mvp_table)\n14:         except:\n15:             print(f\"Could not parse year {year}\")\n16: \n17:     df = pd.concat(all_votes)\n18:     df = df.rename(columns={\"Player\": \"Name\", \"Pts Won\": \"MVP_Points\"})\n19:     return df[[\"Year\", \"Name\", \"MVP_Points\"]]\n20: \n21: \n22: def scrape_season_stats(year):\n23:     base_url_reg = (\n24:         f\"https://www.basketball-reference.com/leagues/NBA_{year}_per_game.html\"\n25:     )\n26:     df_reg = pd.read_html(base_url_reg, header=0)[0]\n27:     df_reg = df_reg[df_reg[\"Player\"] != \"Player\"]  # remove repeated header rows\n28:     df_reg[\"Year\"] = year\n29: \n30:     df_reg = df_reg[\n31:         [\"Player\", \"Year\", \"PTS\", \"AST\", \"TRB\", \"FG%\"]\n32:     ]  # Keep only specified columns\n33:     df_reg = df_reg.dropna(\n34:         subset=[\"PTS\", \"AST\", \"TRB\", \"FG%\"]\n35:     )  # Ensure key stats aren't invalid\n36:     return df_reg\n37: \n38: \n39: def scrape_multiple_seasons(start_year=2018, end_year=2025):\n40:     all_stats = []\n41:     for year in range(start_year, end_year + 1):\n42:         df = scrape_season_stats(year)\n43:         all_stats.append(df)\n44:     return pd.concat(all_stats)\n45: \n46: \n47: if __name__ == \"__main__\":\n48:     if not os.path.exists(\"data\"):\n49:         os.makedirs(\"data\")\n50: \n51:     print(\"Scraping MVP votes...\")\n52:     mvp_df = scrape_mvp_votes()\n53:     mvp_df.to_csv(\"data/mvp_votes.csv\", index=False)\n54: \n55:     print(\"Scraping player stats...\")\n56:     stats_df = scrape_multiple_seasons()\n57:     stats_df.to_csv(\"data/season_stats.csv\", index=False)\n58: "
        },
        "source": "backend",
        "timestamp": "2025-08-23 10:25:36.000",
        "event": "map_summary_code",
        "id": "ade65jCDJvsa5b68JUG8"
    },
    {
        "data": {
            "mapping": [
                {
                    "summaryComponent": "Defines functions to scrape and process NBA data from Basketball Reference for 2018-2025",
                    "codeSegments": [
                        {
                            "line": 5,
                            "code": "def scrape_mvp_votes(start_year=2018, end_year=2025):"
                        },
                        {
                            "line": 22,
                            "code": "def scrape_season_stats(year):"
                        },
                        {
                            "line": 39,
                            "code": "def scrape_multiple_seasons(start_year=2018, end_year=2025):"
                        }
                    ]
                },
                {
                    "summaryComponent": "scrape_mvp_votes: Fetches MVP voting tables, renames columns, and consolidates data",
                    "codeSegments": [
                        {
                            "line": 5,
                            "code": "def scrape_mvp_votes(start_year=2018, end_year=2025):"
                        },
                        {
                            "line": 9,
                            "code": "tables = pd.read_html(url, header=1)"
                        },
                        {
                            "line": 11,
                            "code": "mvp_table = tables[0]  # MVP table is the first table"
                        },
                        {
                            "line": 12,
                            "code": "mvp_table[\"Year\"] = year"
                        },
                        {
                            "line": 13,
                            "code": "all_votes.append(mvp_table)"
                        },
                        {
                            "line": 17,
                            "code": "df = pd.concat(all_votes)"
                        },
                        {
                            "line": 18,
                            "code": "df = df.rename(columns={\"Player\": \"Name\", \"Pts Won\": \"MVP_Points\"})"
                        }
                    ]
                },
                {
                    "summaryComponent": "Handles parsing errors by printing a warning for unparseable years",
                    "codeSegments": [
                        {
                            "line": 14,
                            "code": "except:"
                        },
                        {
                            "line": 15,
                            "code": "print(f\"Could not parse year {year}\")"
                        }
                    ]
                },
                {
                    "summaryComponent": "scrape_season_stats: Retrieves player per-game stats, removes duplicate headers, selects key columns (PTS, AST, TRB, FG%), and drops rows with missing values",
                    "codeSegments": [
                        {
                            "line": 22,
                            "code": "def scrape_season_stats(year):"
                        },
                        {
                            "line": 26,
                            "code": "df_reg = pd.read_html(base_url_reg, header=0)[0]"
                        },
                        {
                            "line": 27,
                            "code": "df_reg = df_reg[df_reg[\"Player\"] != \"Player\"]  # remove repeated header rows"
                        },
                        {
                            "line": 30,
                            "code": "df_reg = df_reg[\n    [\"Player\", \"Year\", \"PTS\", \"AST\", \"TRB\", \"FG%\"]\n]  # Keep only specified columns"
                        },
                        {
                            "line": 33,
                            "code": "df_reg = df_reg.dropna(\n    subset=[\"PTS\", \"AST\", \"TRB\", \"FG%\"]\n)  # Ensure key stats aren't invalid"
                        }
                    ]
                },
                {
                    "summaryComponent": "scrape_multiple_seasons: Aggregates per-season stats across the specified year range",
                    "codeSegments": [
                        {
                            "line": 39,
                            "code": "def scrape_multiple_seasons(start_year=2018, end_year=2025):"
                        },
                        {
                            "line": 41,
                            "code": "for year in range(start_year, end_year + 1):"
                        },
                        {
                            "line": 42,
                            "code": "df = scrape_season_stats(year)"
                        },
                        {
                            "line": 43,
                            "code": "all_stats.append(df)"
                        },
                        {
                            "line": 44,
                            "code": "return pd.concat(all_stats)"
                        }
                    ]
                },
                {
                    "summaryComponent": "Main execution block:",
                    "codeSegments": [
                        {
                            "line": 47,
                            "code": "if __name__ == \"__main__\":"
                        }
                    ]
                },
                {
                    "summaryComponent": "Ensures a 'data' directory exists, creating it if necessary",
                    "codeSegments": [
                        {
                            "line": 48,
                            "code": "if not os.path.exists(\"data\"):"
                        },
                        {
                            "line": 49,
                            "code": "os.makedirs(\"data\")"
                        }
                    ]
                },
                {
                    "summaryComponent": "Scrapes MVP votes and saves them as 'data/mvp_votes.csv'",
                    "codeSegments": [
                        {
                            "line": 52,
                            "code": "mvp_df = scrape_mvp_votes()"
                        },
                        {
                            "line": 53,
                            "code": "mvp_df.to_csv(\"data/mvp_votes.csv\", index=False)"
                        }
                    ]
                },
                {
                    "summaryComponent": "Scrapes player stats for all seasons and saves them as 'data/season_stats.csv'",
                    "codeSegments": [
                        {
                            "line": 56,
                            "code": "stats_df = scrape_multiple_seasons()"
                        },
                        {
                            "line": 57,
                            "code": "stats_df.to_csv(\"data/season_stats.csv\", index=False)"
                        }
                    ]
                },
                {
                    "summaryComponent": "Provides progress updates with print statements",
                    "codeSegments": [
                        {
                            "line": 51,
                            "code": "print(\"Scraping MVP votes...\")"
                        },
                        {
                            "line": 55,
                            "code": "print(\"Scraping player stats...\")"
                        }
                    ]
                }
            ],
            "summary": "• Defines functions to scrape and process NBA data from Basketball Reference for 2018-2025\n  ◦ scrape_mvp_votes: Fetches MVP voting tables, renames columns, and consolidates data\n    ◦ Handles parsing errors by printing a warning for unparseable years\n  ◦ scrape_season_stats: Retrieves player per-game stats, removes duplicate headers, selects key columns (PTS, AST, TRB, FG%), and drops rows with missing values\n  ◦ scrape_multiple_seasons: Aggregates per-season stats across the specified year range\n• Main execution block:\n  ◦ Ensures a 'data' directory exists, creating it if necessary\n  ◦ Scrapes MVP votes and saves them as 'data/mvp_votes.csv'\n  ◦ Scrapes player stats for all seasons and saves them as 'data/season_stats.csv'\n  ◦ Provides progress updates with print statements",
            "code": "1: import pandas as pd\n2: import os\n3: \n4: \n5: def scrape_mvp_votes(start_year=2018, end_year=2025):\n6:     all_votes = []\n7:     for year in range(start_year, end_year + 1):\n8:         url = f\"https://www.basketball-reference.com/awards/awards_{year}.html\"\n9:         tables = pd.read_html(url, header=1)\n10:         try:\n11:             mvp_table = tables[0]  # MVP table is the first table\n12:             mvp_table[\"Year\"] = year\n13:             all_votes.append(mvp_table)\n14:         except:\n15:             print(f\"Could not parse year {year}\")\n16: \n17:     df = pd.concat(all_votes)\n18:     df = df.rename(columns={\"Player\": \"Name\", \"Pts Won\": \"MVP_Points\"})\n19:     return df[[\"Year\", \"Name\", \"MVP_Points\"]]\n20: \n21: \n22: def scrape_season_stats(year):\n23:     base_url_reg = (\n24:         f\"https://www.basketball-reference.com/leagues/NBA_{year}_per_game.html\"\n25:     )\n26:     df_reg = pd.read_html(base_url_reg, header=0)[0]\n27:     df_reg = df_reg[df_reg[\"Player\"] != \"Player\"]  # remove repeated header rows\n28:     df_reg[\"Year\"] = year\n29: \n30:     df_reg = df_reg[\n31:         [\"Player\", \"Year\", \"PTS\", \"AST\", \"TRB\", \"FG%\"]\n32:     ]  # Keep only specified columns\n33:     df_reg = df_reg.dropna(\n34:         subset=[\"PTS\", \"AST\", \"TRB\", \"FG%\"]\n35:     )  # Ensure key stats aren't invalid\n36:     return df_reg\n37: \n38: \n39: def scrape_multiple_seasons(start_year=2018, end_year=2025):\n40:     all_stats = []\n41:     for year in range(start_year, end_year + 1):\n42:         df = scrape_season_stats(year)\n43:         all_stats.append(df)\n44:     return pd.concat(all_stats)\n45: \n46: \n47: if __name__ == \"__main__\":\n48:     if not os.path.exists(\"data\"):\n49:         os.makedirs(\"data\")\n50: \n51:     print(\"Scraping MVP votes...\")\n52:     mvp_df = scrape_mvp_votes()\n53:     mvp_df.to_csv(\"data/mvp_votes.csv\", index=False)\n54: \n55:     print(\"Scraping player stats...\")\n56:     stats_df = scrape_multiple_seasons()\n57:     stats_df.to_csv(\"data/season_stats.csv\", index=False)\n58: "
        },
        "source": "backend",
        "timestamp": "2025-08-23 10:25:37.000",
        "event": "map_summary_code",
        "id": "Yg8UbAYVwlNpwnq205h3"
    },
    {
        "data": {
            "mapping": [
                {
                    "summaryComponent": "defines functions to scrape NBA MVP voting results and player per-game statistics from Basketball Reference for the years 2018 through 2025",
                    "codeSegments": [
                        {
                            "line": 5,
                            "code": "def scrape_mvp_votes(start_year=2018, end_year=2025):"
                        },
                        {
                            "line": 22,
                            "code": "def scrape_season_stats(year):"
                        },
                        {
                            "line": 39,
                            "code": "def scrape_multiple_seasons(start_year=2018, end_year=2025):"
                        }
                    ]
                },
                {
                    "summaryComponent": "The 'scrape_mvp_votes' function fetches MVP voting tables",
                    "codeSegments": [
                        {
                            "line": 5,
                            "code": "def scrape_mvp_votes(start_year=2018, end_year=2025):"
                        },
                        {
                            "line": 9,
                            "code": "tables = pd.read_html(url, header=1)"
                        },
                        {
                            "line": 11,
                            "code": "mvp_table = tables[0]  # MVP table is the first table"
                        }
                    ]
                },
                {
                    "summaryComponent": "renames columns",
                    "codeSegments": [
                        {
                            "line": 18,
                            "code": "df = df.rename(columns={\"Player\": \"Name\", \"Pts Won\": \"MVP_Points\"})"
                        }
                    ]
                },
                {
                    "summaryComponent": "and consolidates the data",
                    "codeSegments": [
                        {
                            "line": 13,
                            "code": "all_votes.append(mvp_table)"
                        },
                        {
                            "line": 17,
                            "code": "df = pd.concat(all_votes)"
                        }
                    ]
                },
                {
                    "summaryComponent": "handling years that can't be parsed by printing a warning",
                    "codeSegments": [
                        {
                            "line": 14,
                            "code": "except:"
                        },
                        {
                            "line": 15,
                            "code": "print(f\"Could not parse year {year}\")"
                        }
                    ]
                },
                {
                    "summaryComponent": "The 'scrape_season_stats' function retrieves player stats",
                    "codeSegments": [
                        {
                            "line": 22,
                            "code": "def scrape_season_stats(year):"
                        },
                        {
                            "line": 26,
                            "code": "df_reg = pd.read_html(base_url_reg, header=0)[0]"
                        }
                    ]
                },
                {
                    "summaryComponent": "removes duplicate headers",
                    "codeSegments": [
                        {
                            "line": 27,
                            "code": "df_reg = df_reg[df_reg[\"Player\"] != \"Player\"]  # remove repeated header rows"
                        }
                    ]
                },
                {
                    "summaryComponent": "filters for key statistics",
                    "codeSegments": [
                        {
                            "line": 30,
                            "code": "df_reg = df_reg["
                        },
                        {
                            "line": 31,
                            "code": "[\"Player\", \"Year\", \"PTS\", \"AST\", \"TRB\", \"FG%\"]"
                        }
                    ]
                },
                {
                    "summaryComponent": "and drops rows with missing values",
                    "codeSegments": [
                        {
                            "line": 33,
                            "code": "df_reg = df_reg.dropna("
                        },
                        {
                            "line": 34,
                            "code": "subset=[\"PTS\", \"AST\", \"TRB\", \"FG%\"]"
                        }
                    ]
                },
                {
                    "summaryComponent": "The main block ensures a 'data' directory exists, then saves the compiled MVP votes and player stats as CSV files, providing progress updates via print statements",
                    "codeSegments": [
                        {
                            "line": 47,
                            "code": "if __name__ == \"__main__\":"
                        },
                        {
                            "line": 48,
                            "code": "if not os.path.exists(\"data\"):"
                        },
                        {
                            "line": 49,
                            "code": "os.makedirs(\"data\")"
                        },
                        {
                            "line": 51,
                            "code": "print(\"Scraping MVP votes...\")"
                        },
                        {
                            "line": 52,
                            "code": "mvp_df = scrape_mvp_votes()"
                        },
                        {
                            "line": 53,
                            "code": "mvp_df.to_csv(\"data/mvp_votes.csv\", index=False)"
                        },
                        {
                            "line": 55,
                            "code": "print(\"Scraping player stats...\")"
                        },
                        {
                            "line": 56,
                            "code": "stats_df = scrape_multiple_seasons()"
                        },
                        {
                            "line": 57,
                            "code": "stats_df.to_csv(\"data/season_stats.csv\", index=False)"
                        }
                    ]
                }
            ],
            "summary": "This script defines functions to scrape NBA MVP voting results and player per-game statistics from Basketball Reference for the years 2018 through 2025. The 'scrape_mvp_votes' function fetches MVP voting tables, renames columns, and consolidates the data, handling years that can't be parsed by printing a warning. The 'scrape_season_stats' function retrieves player stats, removes duplicate headers, filters for key statistics, and drops rows with missing values. The main block ensures a 'data' directory exists, then saves the compiled MVP votes and player stats as CSV files, providing progress updates via print statements.",
            "code": "1: import pandas as pd\n2: import os\n3: \n4: \n5: def scrape_mvp_votes(start_year=2018, end_year=2025):\n6:     all_votes = []\n7:     for year in range(start_year, end_year + 1):\n8:         url = f\"https://www.basketball-reference.com/awards/awards_{year}.html\"\n9:         tables = pd.read_html(url, header=1)\n10:         try:\n11:             mvp_table = tables[0]  # MVP table is the first table\n12:             mvp_table[\"Year\"] = year\n13:             all_votes.append(mvp_table)\n14:         except:\n15:             print(f\"Could not parse year {year}\")\n16: \n17:     df = pd.concat(all_votes)\n18:     df = df.rename(columns={\"Player\": \"Name\", \"Pts Won\": \"MVP_Points\"})\n19:     return df[[\"Year\", \"Name\", \"MVP_Points\"]]\n20: \n21: \n22: def scrape_season_stats(year):\n23:     base_url_reg = (\n24:         f\"https://www.basketball-reference.com/leagues/NBA_{year}_per_game.html\"\n25:     )\n26:     df_reg = pd.read_html(base_url_reg, header=0)[0]\n27:     df_reg = df_reg[df_reg[\"Player\"] != \"Player\"]  # remove repeated header rows\n28:     df_reg[\"Year\"] = year\n29: \n30:     df_reg = df_reg[\n31:         [\"Player\", \"Year\", \"PTS\", \"AST\", \"TRB\", \"FG%\"]\n32:     ]  # Keep only specified columns\n33:     df_reg = df_reg.dropna(\n34:         subset=[\"PTS\", \"AST\", \"TRB\", \"FG%\"]\n35:     )  # Ensure key stats aren't invalid\n36:     return df_reg\n37: \n38: \n39: def scrape_multiple_seasons(start_year=2018, end_year=2025):\n40:     all_stats = []\n41:     for year in range(start_year, end_year + 1):\n42:         df = scrape_season_stats(year)\n43:         all_stats.append(df)\n44:     return pd.concat(all_stats)\n45: \n46: \n47: if __name__ == \"__main__\":\n48:     if not os.path.exists(\"data\"):\n49:         os.makedirs(\"data\")\n50: \n51:     print(\"Scraping MVP votes...\")\n52:     mvp_df = scrape_mvp_votes()\n53:     mvp_df.to_csv(\"data/mvp_votes.csv\", index=False)\n54: \n55:     print(\"Scraping player stats...\")\n56:     stats_df = scrape_multiple_seasons()\n57:     stats_df.to_csv(\"data/season_stats.csv\", index=False)\n58: "
        },
        "source": "backend",
        "timestamp": "2025-08-23 10:25:38.000",
        "event": "map_summary_code",
        "id": "1o6lUkuN3JqPOwvvyfCI"
    },
    {
        "data": {
            "before_section_id": null,
            "after_section_id": "7b7cba0f-406c-4c39-a0a1-3c518d1de307"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:25:38.000",
        "event": "autotransit_section",
        "id": "5Pk02oBPvmgI4sAfXQWR"
    },
    {
        "data": {
            "section_data": {
                "lines": [
                    1,
                    58
                ],
                "summaryData": {
                    "medium_unstructured": "The code collects NBA MVP voting results and player per-game statistics from Basketball Reference for seasons between 2018 and 2025. It processes and combines the data, then saves the results as CSV files in a local 'data' directory. The script handles missing data gracefully and ensures only relevant columns are kept.",
                    "low_structured": "• Scrapes MVP votes and player stats from Basketball Reference\n• Saves the data as CSV files",
                    "title": "Basketball Reference MVP Votes and Player Stats Scraper",
                    "medium_structured": "• Scrapes MVP voting data and player per-game stats for NBA seasons 2018-2025\n• Processes and combines data from Basketball Reference tables\n• Saves MVP votes and player stats as separate CSV files in a 'data' directory\n• Handles missing or unparseable years by printing a message",
                    "high_unstructured": "This script defines functions to scrape NBA MVP voting results and player per-game statistics from Basketball Reference for the years 2018 through 2025. The 'scrape_mvp_votes' function fetches MVP voting tables, renames columns, and consolidates the data, handling years that can't be parsed by printing a warning. The 'scrape_season_stats' function retrieves player stats, removes duplicate headers, filters for key statistics, and drops rows with missing values. The main block ensures a 'data' directory exists, then saves the compiled MVP votes and player stats as CSV files, providing progress updates via print statements.",
                    "high_structured": "• Defines functions to scrape and process NBA data from Basketball Reference for 2018-2025\n  ◦ scrape_mvp_votes: Fetches MVP voting tables, renames columns, and consolidates data\n    ◦ Handles parsing errors by printing a warning for unparseable years\n  ◦ scrape_season_stats: Retrieves player per-game stats, removes duplicate headers, selects key columns (PTS, AST, TRB, FG%), and drops rows with missing values\n  ◦ scrape_multiple_seasons: Aggregates per-season stats across the specified year range\n• Main execution block:\n  ◦ Ensures a 'data' directory exists, creating it if necessary\n  ◦ Scrapes MVP votes and saves them as 'data/mvp_votes.csv'\n  ◦ Scrapes player stats for all seasons and saves them as 'data/season_stats.csv'\n  ◦ Provides progress updates with print statements",
                    "low_unstructured": "This script scrapes NBA MVP voting data and player statistics from Basketball Reference and saves them as CSV files."
                },
                "editPromptStructured": null,
                "createdAt": 1755973538000,
                "metadata": {
                    "filename": "scraper.py",
                    "id": "7b7cba0f-406c-4c39-a0a1-3c518d1de307",
                    "originalCode": "import pandas as pd\nimport os\n\n\ndef scrape_mvp_votes(start_year=2018, end_year=2025):\n    all_votes = []\n    for year in range(start_year, end_year + 1):\n        url = f\"https://www.basketball-reference.com/awards/awards_{year}.html\"\n        tables = pd.read_html(url, header=1)\n        try:\n            mvp_table = tables[0]  # MVP table is the first table\n            mvp_table[\"Year\"] = year\n            all_votes.append(mvp_table)\n        except:\n            print(f\"Could not parse year {year}\")\n\n    df = pd.concat(all_votes)\n    df = df.rename(columns={\"Player\": \"Name\", \"Pts Won\": \"MVP_Points\"})\n    return df[[\"Year\", \"Name\", \"MVP_Points\"]]\n\n\ndef scrape_season_stats(year):\n    base_url_reg = (\n        f\"https://www.basketball-reference.com/leagues/NBA_{year}_per_game.html\"\n    )\n    df_reg = pd.read_html(base_url_reg, header=0)[0]\n    df_reg = df_reg[df_reg[\"Player\"] != \"Player\"]  # remove repeated header rows\n    df_reg[\"Year\"] = year\n\n    df_reg = df_reg[\n        [\"Player\", \"Year\", \"PTS\", \"AST\", \"TRB\", \"FG%\"]\n    ]  # Keep only specified columns\n    df_reg = df_reg.dropna(\n        subset=[\"PTS\", \"AST\", \"TRB\", \"FG%\"]\n    )  # Ensure key stats aren't invalid\n    return df_reg\n\n\ndef scrape_multiple_seasons(start_year=2018, end_year=2025):\n    all_stats = []\n    for year in range(start_year, end_year + 1):\n        df = scrape_season_stats(year)\n        all_stats.append(df)\n    return pd.concat(all_stats)\n\n\nif __name__ == \"__main__\":\n    if not os.path.exists(\"data\"):\n        os.makedirs(\"data\")\n\n    print(\"Scraping MVP votes...\")\n    mvp_df = scrape_mvp_votes()\n    mvp_df.to_csv(\"data/mvp_votes.csv\", index=False)\n\n    print(\"Scraping player stats...\")\n    stats_df = scrape_multiple_seasons()\n    stats_df.to_csv(\"data/season_stats.csv\", index=False)\n",
                    "fullPath": "/project/workspace/scraper.py",
                    "offset": 0
                },
                "selectedStructured": "unstructured",
                "title": "Basketball Reference MVP Votes and Player Stats Scraper",
                "selectedDetailLevel": "medium",
                "summaryMappings": {
                    "medium_unstructured": [
                        {
                            "summaryComponent": "collects NBA MVP voting results",
                            "codeSegments": [
                                {
                                    "line": 5,
                                    "code": "def scrape_mvp_votes(start_year=2018, end_year=2025):"
                                },
                                {
                                    "line": 52,
                                    "code": "mvp_df = scrape_mvp_votes()"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "player per-game statistics",
                            "codeSegments": [
                                {
                                    "line": 22,
                                    "code": "def scrape_season_stats(year):"
                                },
                                {
                                    "line": 39,
                                    "code": "def scrape_multiple_seasons(start_year=2018, end_year=2025):"
                                },
                                {
                                    "line": 56,
                                    "code": "stats_df = scrape_multiple_seasons()"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "from Basketball Reference",
                            "codeSegments": [
                                {
                                    "line": 8,
                                    "code": "url = f\"https://www.basketball-reference.com/awards/awards_{year}.html\""
                                },
                                {
                                    "line": 23,
                                    "code": "base_url_reg = ("
                                },
                                {
                                    "line": 24,
                                    "code": "f\"https://www.basketball-reference.com/leagues/NBA_{year}_per_game.html\""
                                }
                            ]
                        },
                        {
                            "summaryComponent": "for seasons between 2018 and 2025",
                            "codeSegments": [
                                {
                                    "line": 5,
                                    "code": "def scrape_mvp_votes(start_year=2018, end_year=2025):"
                                },
                                {
                                    "line": 39,
                                    "code": "def scrape_multiple_seasons(start_year=2018, end_year=2025):"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "processes and combines the data",
                            "codeSegments": [
                                {
                                    "line": 6,
                                    "code": "all_votes = []"
                                },
                                {
                                    "line": 40,
                                    "code": "all_stats = []"
                                },
                                {
                                    "line": 17,
                                    "code": "df = pd.concat(all_votes)"
                                },
                                {
                                    "line": 44,
                                    "code": "return pd.concat(all_stats)"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "saves the results as CSV files",
                            "codeSegments": [
                                {
                                    "line": 53,
                                    "code": "mvp_df.to_csv(\"data/mvp_votes.csv\", index=False)"
                                },
                                {
                                    "line": 57,
                                    "code": "stats_df.to_csv(\"data/season_stats.csv\", index=False)"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "in a local 'data' directory",
                            "codeSegments": [
                                {
                                    "line": 48,
                                    "code": "if not os.path.exists(\"data\"):"
                                },
                                {
                                    "line": 49,
                                    "code": "os.makedirs(\"data\")"
                                },
                                {
                                    "line": 53,
                                    "code": "\"data/mvp_votes.csv\""
                                },
                                {
                                    "line": 57,
                                    "code": "\"data/season_stats.csv\""
                                }
                            ]
                        },
                        {
                            "summaryComponent": "handles missing data gracefully",
                            "codeSegments": [
                                {
                                    "line": 14,
                                    "code": "except:"
                                },
                                {
                                    "line": 15,
                                    "code": "print(f\"Could not parse year {year}\")"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "ensures only relevant columns are kept",
                            "codeSegments": [
                                {
                                    "line": 18,
                                    "code": "df = df.rename(columns={\"Player\": \"Name\", \"Pts Won\": \"MVP_Points\"})"
                                },
                                {
                                    "line": 19,
                                    "code": "return df[[\"Year\", \"Name\", \"MVP_Points\"]]"
                                },
                                {
                                    "line": 30,
                                    "code": "df_reg = df_reg["
                                },
                                {
                                    "line": 31,
                                    "code": "[\"Player\", \"Year\", \"PTS\", \"AST\", \"TRB\", \"FG%\"]"
                                }
                            ]
                        }
                    ],
                    "low_structured": [
                        {
                            "summaryComponent": "Scrapes MVP votes",
                            "codeSegments": [
                                {
                                    "line": 5,
                                    "code": "def scrape_mvp_votes(start_year=2018, end_year=2025):"
                                },
                                {
                                    "line": 52,
                                    "code": "mvp_df = scrape_mvp_votes()"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "and player stats",
                            "codeSegments": [
                                {
                                    "line": 22,
                                    "code": "def scrape_season_stats(year):"
                                },
                                {
                                    "line": 39,
                                    "code": "def scrape_multiple_seasons(start_year=2018, end_year=2025):"
                                },
                                {
                                    "line": 56,
                                    "code": "stats_df = scrape_multiple_seasons()"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "from Basketball Reference",
                            "codeSegments": [
                                {
                                    "line": 8,
                                    "code": "url = f\"https://www.basketball-reference.com/awards/awards_{year}.html\""
                                },
                                {
                                    "line": 23,
                                    "code": "base_url_reg = ("
                                },
                                {
                                    "line": 24,
                                    "code": "f\"https://www.basketball-reference.com/leagues/NBA_{year}_per_game.html\""
                                }
                            ]
                        },
                        {
                            "summaryComponent": "Saves the data as CSV files",
                            "codeSegments": [
                                {
                                    "line": 53,
                                    "code": "mvp_df.to_csv(\"data/mvp_votes.csv\", index=False)"
                                },
                                {
                                    "line": 57,
                                    "code": "stats_df.to_csv(\"data/season_stats.csv\", index=False)"
                                }
                            ]
                        }
                    ],
                    "low_unstructured": [
                        {
                            "summaryComponent": "scrapes NBA MVP voting data",
                            "codeSegments": [
                                {
                                    "line": 5,
                                    "code": "def scrape_mvp_votes(start_year=2018, end_year=2025):"
                                },
                                {
                                    "line": 52,
                                    "code": "mvp_df = scrape_mvp_votes()"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "and player statistics",
                            "codeSegments": [
                                {
                                    "line": 22,
                                    "code": "def scrape_season_stats(year):"
                                },
                                {
                                    "line": 39,
                                    "code": "def scrape_multiple_seasons(start_year=2018, end_year=2025):"
                                },
                                {
                                    "line": 56,
                                    "code": "stats_df = scrape_multiple_seasons()"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "from Basketball Reference",
                            "codeSegments": [
                                {
                                    "line": 8,
                                    "code": "url = f\"https://www.basketball-reference.com/awards/awards_{year}.html\""
                                },
                                {
                                    "line": 23,
                                    "code": "base_url_reg = (\n    f\"https://www.basketball-reference.com/leagues/NBA_{year}_per_game.html\"\n)"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "and saves them as CSV files",
                            "codeSegments": [
                                {
                                    "line": 53,
                                    "code": "mvp_df.to_csv(\"data/mvp_votes.csv\", index=False)"
                                },
                                {
                                    "line": 57,
                                    "code": "stats_df.to_csv(\"data/season_stats.csv\", index=False)"
                                }
                            ]
                        }
                    ],
                    "medium_structured": [
                        {
                            "summaryComponent": "Scrapes MVP voting data and player per-game stats for NBA seasons 2018-2025",
                            "codeSegments": [
                                {
                                    "line": 5,
                                    "code": "def scrape_mvp_votes(start_year=2018, end_year=2025):"
                                },
                                {
                                    "line": 22,
                                    "code": "def scrape_season_stats(year):"
                                },
                                {
                                    "line": 39,
                                    "code": "def scrape_multiple_seasons(start_year=2018, end_year=2025):"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "Processes and combines data from Basketball Reference tables",
                            "codeSegments": [
                                {
                                    "line": 9,
                                    "code": "tables = pd.read_html(url, header=1)"
                                },
                                {
                                    "line": 11,
                                    "code": "mvp_table = tables[0]  # MVP table is the first table"
                                },
                                {
                                    "line": 17,
                                    "code": "df = pd.concat(all_votes)"
                                },
                                {
                                    "line": 26,
                                    "code": "df_reg = pd.read_html(base_url_reg, header=0)[0]"
                                },
                                {
                                    "line": 42,
                                    "code": "df = scrape_season_stats(year)"
                                },
                                {
                                    "line": 44,
                                    "code": "return pd.concat(all_stats)"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "Saves MVP votes and player stats as separate CSV files in a 'data' directory",
                            "codeSegments": [
                                {
                                    "line": 48,
                                    "code": "if not os.path.exists(\"data\"):"
                                },
                                {
                                    "line": 49,
                                    "code": "os.makedirs(\"data\")"
                                },
                                {
                                    "line": 53,
                                    "code": "mvp_df.to_csv(\"data/mvp_votes.csv\", index=False)"
                                },
                                {
                                    "line": 57,
                                    "code": "stats_df.to_csv(\"data/season_stats.csv\", index=False)"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "Handles missing or unparseable years by printing a message",
                            "codeSegments": [
                                {
                                    "line": 14,
                                    "code": "except:"
                                },
                                {
                                    "line": 15,
                                    "code": "print(f\"Could not parse year {year}\")"
                                }
                            ]
                        }
                    ],
                    "high_unstructured": [
                        {
                            "summaryComponent": "defines functions to scrape NBA MVP voting results and player per-game statistics from Basketball Reference for the years 2018 through 2025",
                            "codeSegments": [
                                {
                                    "line": 5,
                                    "code": "def scrape_mvp_votes(start_year=2018, end_year=2025):"
                                },
                                {
                                    "line": 22,
                                    "code": "def scrape_season_stats(year):"
                                },
                                {
                                    "line": 39,
                                    "code": "def scrape_multiple_seasons(start_year=2018, end_year=2025):"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "The 'scrape_mvp_votes' function fetches MVP voting tables",
                            "codeSegments": [
                                {
                                    "line": 5,
                                    "code": "def scrape_mvp_votes(start_year=2018, end_year=2025):"
                                },
                                {
                                    "line": 9,
                                    "code": "tables = pd.read_html(url, header=1)"
                                },
                                {
                                    "line": 11,
                                    "code": "mvp_table = tables[0]  # MVP table is the first table"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "renames columns",
                            "codeSegments": [
                                {
                                    "line": 18,
                                    "code": "df = df.rename(columns={\"Player\": \"Name\", \"Pts Won\": \"MVP_Points\"})"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "and consolidates the data",
                            "codeSegments": [
                                {
                                    "line": 13,
                                    "code": "all_votes.append(mvp_table)"
                                },
                                {
                                    "line": 17,
                                    "code": "df = pd.concat(all_votes)"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "handling years that can't be parsed by printing a warning",
                            "codeSegments": [
                                {
                                    "line": 14,
                                    "code": "except:"
                                },
                                {
                                    "line": 15,
                                    "code": "print(f\"Could not parse year {year}\")"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "The 'scrape_season_stats' function retrieves player stats",
                            "codeSegments": [
                                {
                                    "line": 22,
                                    "code": "def scrape_season_stats(year):"
                                },
                                {
                                    "line": 26,
                                    "code": "df_reg = pd.read_html(base_url_reg, header=0)[0]"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "removes duplicate headers",
                            "codeSegments": [
                                {
                                    "line": 27,
                                    "code": "df_reg = df_reg[df_reg[\"Player\"] != \"Player\"]  # remove repeated header rows"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "filters for key statistics",
                            "codeSegments": [
                                {
                                    "line": 30,
                                    "code": "df_reg = df_reg["
                                },
                                {
                                    "line": 31,
                                    "code": "[\"Player\", \"Year\", \"PTS\", \"AST\", \"TRB\", \"FG%\"]"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "and drops rows with missing values",
                            "codeSegments": [
                                {
                                    "line": 33,
                                    "code": "df_reg = df_reg.dropna("
                                },
                                {
                                    "line": 34,
                                    "code": "subset=[\"PTS\", \"AST\", \"TRB\", \"FG%\"]"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "The main block ensures a 'data' directory exists, then saves the compiled MVP votes and player stats as CSV files, providing progress updates via print statements",
                            "codeSegments": [
                                {
                                    "line": 47,
                                    "code": "if __name__ == \"__main__\":"
                                },
                                {
                                    "line": 48,
                                    "code": "if not os.path.exists(\"data\"):"
                                },
                                {
                                    "line": 49,
                                    "code": "os.makedirs(\"data\")"
                                },
                                {
                                    "line": 51,
                                    "code": "print(\"Scraping MVP votes...\")"
                                },
                                {
                                    "line": 52,
                                    "code": "mvp_df = scrape_mvp_votes()"
                                },
                                {
                                    "line": 53,
                                    "code": "mvp_df.to_csv(\"data/mvp_votes.csv\", index=False)"
                                },
                                {
                                    "line": 55,
                                    "code": "print(\"Scraping player stats...\")"
                                },
                                {
                                    "line": 56,
                                    "code": "stats_df = scrape_multiple_seasons()"
                                },
                                {
                                    "line": 57,
                                    "code": "stats_df.to_csv(\"data/season_stats.csv\", index=False)"
                                }
                            ]
                        }
                    ],
                    "high_structured": [
                        {
                            "summaryComponent": "Defines functions to scrape and process NBA data from Basketball Reference for 2018-2025",
                            "codeSegments": [
                                {
                                    "line": 5,
                                    "code": "def scrape_mvp_votes(start_year=2018, end_year=2025):"
                                },
                                {
                                    "line": 22,
                                    "code": "def scrape_season_stats(year):"
                                },
                                {
                                    "line": 39,
                                    "code": "def scrape_multiple_seasons(start_year=2018, end_year=2025):"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "scrape_mvp_votes: Fetches MVP voting tables, renames columns, and consolidates data",
                            "codeSegments": [
                                {
                                    "line": 5,
                                    "code": "def scrape_mvp_votes(start_year=2018, end_year=2025):"
                                },
                                {
                                    "line": 9,
                                    "code": "tables = pd.read_html(url, header=1)"
                                },
                                {
                                    "line": 11,
                                    "code": "mvp_table = tables[0]  # MVP table is the first table"
                                },
                                {
                                    "line": 12,
                                    "code": "mvp_table[\"Year\"] = year"
                                },
                                {
                                    "line": 13,
                                    "code": "all_votes.append(mvp_table)"
                                },
                                {
                                    "line": 17,
                                    "code": "df = pd.concat(all_votes)"
                                },
                                {
                                    "line": 18,
                                    "code": "df = df.rename(columns={\"Player\": \"Name\", \"Pts Won\": \"MVP_Points\"})"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "Handles parsing errors by printing a warning for unparseable years",
                            "codeSegments": [
                                {
                                    "line": 14,
                                    "code": "except:"
                                },
                                {
                                    "line": 15,
                                    "code": "print(f\"Could not parse year {year}\")"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "scrape_season_stats: Retrieves player per-game stats, removes duplicate headers, selects key columns (PTS, AST, TRB, FG%), and drops rows with missing values",
                            "codeSegments": [
                                {
                                    "line": 22,
                                    "code": "def scrape_season_stats(year):"
                                },
                                {
                                    "line": 26,
                                    "code": "df_reg = pd.read_html(base_url_reg, header=0)[0]"
                                },
                                {
                                    "line": 27,
                                    "code": "df_reg = df_reg[df_reg[\"Player\"] != \"Player\"]  # remove repeated header rows"
                                },
                                {
                                    "line": 30,
                                    "code": "df_reg = df_reg[\n    [\"Player\", \"Year\", \"PTS\", \"AST\", \"TRB\", \"FG%\"]\n]  # Keep only specified columns"
                                },
                                {
                                    "line": 33,
                                    "code": "df_reg = df_reg.dropna(\n    subset=[\"PTS\", \"AST\", \"TRB\", \"FG%\"]\n)  # Ensure key stats aren't invalid"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "scrape_multiple_seasons: Aggregates per-season stats across the specified year range",
                            "codeSegments": [
                                {
                                    "line": 39,
                                    "code": "def scrape_multiple_seasons(start_year=2018, end_year=2025):"
                                },
                                {
                                    "line": 41,
                                    "code": "for year in range(start_year, end_year + 1):"
                                },
                                {
                                    "line": 42,
                                    "code": "df = scrape_season_stats(year)"
                                },
                                {
                                    "line": 43,
                                    "code": "all_stats.append(df)"
                                },
                                {
                                    "line": 44,
                                    "code": "return pd.concat(all_stats)"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "Main execution block:",
                            "codeSegments": [
                                {
                                    "line": 47,
                                    "code": "if __name__ == \"__main__\":"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "Ensures a 'data' directory exists, creating it if necessary",
                            "codeSegments": [
                                {
                                    "line": 48,
                                    "code": "if not os.path.exists(\"data\"):"
                                },
                                {
                                    "line": 49,
                                    "code": "os.makedirs(\"data\")"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "Scrapes MVP votes and saves them as 'data/mvp_votes.csv'",
                            "codeSegments": [
                                {
                                    "line": 52,
                                    "code": "mvp_df = scrape_mvp_votes()"
                                },
                                {
                                    "line": 53,
                                    "code": "mvp_df.to_csv(\"data/mvp_votes.csv\", index=False)"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "Scrapes player stats for all seasons and saves them as 'data/season_stats.csv'",
                            "codeSegments": [
                                {
                                    "line": 56,
                                    "code": "stats_df = scrape_multiple_seasons()"
                                },
                                {
                                    "line": 57,
                                    "code": "stats_df.to_csv(\"data/season_stats.csv\", index=False)"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "Provides progress updates with print statements",
                            "codeSegments": [
                                {
                                    "line": 51,
                                    "code": "print(\"Scraping MVP votes...\")"
                                },
                                {
                                    "line": 55,
                                    "code": "print(\"Scraping player stats...\")"
                                }
                            ]
                        }
                    ]
                },
                "editPromptValue": "",
                "editPromptDetailLevel": null
            },
            "section_id": "7b7cba0f-406c-4c39-a0a1-3c518d1de307"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:25:38.000",
        "event": "create_new_section",
        "id": "AF0WJGf3sbSuYhxuipae"
    },
    {
        "data": {
            "mapping_index": 0,
            "structured_type": "unstructured",
            "section_id": "7b7cba0f-406c-4c39-a0a1-3c518d1de307",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:25:41.000",
        "event": "mapping_hover",
        "id": "1Tc80PayIi6bj0jhomsB"
    },
    {
        "data": {
            "structured_type": "unstructured",
            "section_id": "7b7cba0f-406c-4c39-a0a1-3c518d1de307",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:25:41.000",
        "event": "mapping_unhover",
        "id": "3lfHr7kB9S1KtDJs5tzz"
    },
    {
        "data": {
            "mapping_index": 3,
            "structured_type": "unstructured",
            "section_id": "7b7cba0f-406c-4c39-a0a1-3c518d1de307",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:25:41.000",
        "event": "mapping_hover",
        "id": "JS9JtnnrkSvIntzOVSH2"
    },
    {
        "data": {
            "mapping_index": 4,
            "structured_type": "unstructured",
            "section_id": "7b7cba0f-406c-4c39-a0a1-3c518d1de307",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:25:41.000",
        "event": "mapping_hover",
        "id": "NjWtuCv8YYGrNypKLniF"
    },
    {
        "data": {
            "structured_type": "unstructured",
            "section_id": "7b7cba0f-406c-4c39-a0a1-3c518d1de307",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:25:41.000",
        "event": "mapping_unhover",
        "id": "Pkf4ARuDBRmOgcvWhHXE"
    },
    {
        "data": {
            "mapping_index": 3,
            "structured_type": "unstructured",
            "section_id": "7b7cba0f-406c-4c39-a0a1-3c518d1de307",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:25:41.000",
        "event": "mapping_hover",
        "id": "VY7YDduwBYoC5752ZCUh"
    },
    {
        "data": {
            "structured_type": "unstructured",
            "section_id": "7b7cba0f-406c-4c39-a0a1-3c518d1de307",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:25:41.000",
        "event": "mapping_unhover",
        "id": "bUfZZQxMOr2ew0I7P19E"
    },
    {
        "data": {
            "structured_type": "unstructured",
            "section_id": "7b7cba0f-406c-4c39-a0a1-3c518d1de307",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:25:41.000",
        "event": "mapping_unhover",
        "id": "fC8rzQyzQdypk26mNPna"
    },
    {
        "data": {
            "structured_type": "unstructured",
            "section_id": "7b7cba0f-406c-4c39-a0a1-3c518d1de307",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:25:41.000",
        "event": "mapping_unhover",
        "id": "fK5e6W2X35IETiw0vFef"
    },
    {
        "data": {
            "mapping_index": 1,
            "structured_type": "unstructured",
            "section_id": "7b7cba0f-406c-4c39-a0a1-3c518d1de307",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:25:41.000",
        "event": "mapping_hover",
        "id": "mI1c5aqU8dsvNTPPvU8m"
    },
    {
        "data": {
            "mapping_index": 0,
            "structured_type": "unstructured",
            "section_id": "7b7cba0f-406c-4c39-a0a1-3c518d1de307",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:25:42.000",
        "event": "mapping_hover",
        "id": "Yv8fJbpCSpfRFX4EimBg"
    },
    {
        "data": {
            "mapping_index": 2,
            "structured_type": "unstructured",
            "section_id": "7b7cba0f-406c-4c39-a0a1-3c518d1de307",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:25:43.000",
        "event": "mapping_hover",
        "id": "34VzUT2Vj2fp2rr81lXT"
    },
    {
        "data": {
            "structured_type": "unstructured",
            "section_id": "7b7cba0f-406c-4c39-a0a1-3c518d1de307",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:25:43.000",
        "event": "mapping_unhover",
        "id": "yGiADLGSsW58uNMErvoC"
    },
    {
        "data": {
            "structured_type": "unstructured",
            "section_id": "7b7cba0f-406c-4c39-a0a1-3c518d1de307",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:25:44.000",
        "event": "mapping_unhover",
        "id": "2M1ytZ469F5RPaOgysJq"
    },
    {
        "data": {
            "structured_type": "unstructured",
            "section_id": "7b7cba0f-406c-4c39-a0a1-3c518d1de307",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:25:44.000",
        "event": "mapping_unhover",
        "id": "HGiU6DBWtzMj6JHutCrh"
    },
    {
        "data": {
            "mapping_index": 1,
            "structured_type": "unstructured",
            "section_id": "7b7cba0f-406c-4c39-a0a1-3c518d1de307",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:25:44.000",
        "event": "mapping_hover",
        "id": "J9Mzy5eUSMh9qienRVoL"
    },
    {
        "data": {
            "mapping_index": 0,
            "structured_type": "unstructured",
            "section_id": "7b7cba0f-406c-4c39-a0a1-3c518d1de307",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:25:44.000",
        "event": "mapping_hover",
        "id": "Tl6FMdlmUFV0zLbx8uPu"
    },
    {
        "data": {
            "structured_type": "unstructured",
            "section_id": "7b7cba0f-406c-4c39-a0a1-3c518d1de307",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:25:44.000",
        "event": "mapping_unhover",
        "id": "efciMPBPi8dFLjdX7bVA"
    },
    {
        "data": {
            "before_detail_level": "medium",
            "after_detail_level": "medium",
            "before_structured": "unstructured",
            "section_id": "7b7cba0f-406c-4c39-a0a1-3c518d1de307",
            "after_structured": "structured"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:25:45.000",
        "event": "change_summary_level",
        "id": "YiRbqIxCttOh27A9BE8N"
    },
    {
        "data": {
            "mapping_index": 0,
            "structured_type": "structured",
            "section_id": "7b7cba0f-406c-4c39-a0a1-3c518d1de307",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:25:46.000",
        "event": "mapping_hover",
        "id": "UCnCuVH6BYekQ9Hdpsc9"
    },
    {
        "data": {
            "structured_type": "structured",
            "section_id": "7b7cba0f-406c-4c39-a0a1-3c518d1de307",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:25:47.000",
        "event": "mapping_unhover",
        "id": "p0gnSoIVhvdgpI7Arkal"
    },
    {
        "data": {
            "mapping_index": 0,
            "structured_type": "structured",
            "section_id": "7b7cba0f-406c-4c39-a0a1-3c518d1de307",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:25:48.000",
        "event": "mapping_hover",
        "id": "QvgFL4MdlaDdionAxQ6H"
    },
    {
        "data": {
            "structured_type": "structured",
            "section_id": "7b7cba0f-406c-4c39-a0a1-3c518d1de307",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:25:49.000",
        "event": "mapping_unhover",
        "id": "9OkJbmoFO6qriisZGzlv"
    },
    {
        "data": {
            "mapping_index": 1,
            "structured_type": "structured",
            "section_id": "7b7cba0f-406c-4c39-a0a1-3c518d1de307",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:25:50.000",
        "event": "mapping_hover",
        "id": "FLsbWnLbjjdsLvZ45IhQ"
    },
    {
        "data": {
            "mapping_index": 0,
            "structured_type": "structured",
            "section_id": "7b7cba0f-406c-4c39-a0a1-3c518d1de307",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:25:50.000",
        "event": "mapping_hover",
        "id": "LAbyeMLdUe20KkD32rEm"
    },
    {
        "data": {
            "mapping_index": 1,
            "structured_type": "structured",
            "section_id": "7b7cba0f-406c-4c39-a0a1-3c518d1de307",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:25:50.000",
        "event": "mapping_hover",
        "id": "MPau8a5MTlBB5hufixKb"
    },
    {
        "data": {
            "structured_type": "structured",
            "section_id": "7b7cba0f-406c-4c39-a0a1-3c518d1de307",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:25:50.000",
        "event": "mapping_unhover",
        "id": "kMLMBQh0xfpibSZdQwKr"
    },
    {
        "data": {
            "structured_type": "structured",
            "section_id": "7b7cba0f-406c-4c39-a0a1-3c518d1de307",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:25:50.000",
        "event": "mapping_unhover",
        "id": "zRTHiv8xlnrlkPxGT43t"
    },
    {
        "data": {
            "structured_type": "structured",
            "section_id": "7b7cba0f-406c-4c39-a0a1-3c518d1de307",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:25:52.000",
        "event": "mapping_unhover",
        "id": "pLZQBk5lw5vxFpPy452Y"
    },
    {
        "data": {
            "mapping_index": 2,
            "structured_type": "structured",
            "section_id": "7b7cba0f-406c-4c39-a0a1-3c518d1de307",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:25:52.000",
        "event": "mapping_hover",
        "id": "pq9H8qbaWhNYzQB0PwZT"
    },
    {
        "data": {
            "structured_type": "structured",
            "section_id": "7b7cba0f-406c-4c39-a0a1-3c518d1de307",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:25:53.000",
        "event": "mapping_unhover",
        "id": "CVXYGlccD6k1eOjLkEpo"
    },
    {
        "data": {
            "mapping_index": 3,
            "structured_type": "structured",
            "section_id": "7b7cba0f-406c-4c39-a0a1-3c518d1de307",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:25:54.000",
        "event": "mapping_hover",
        "id": "IixJ4dFgYZI6gT2aKRpb"
    },
    {
        "data": {
            "mapping_index": 2,
            "structured_type": "structured",
            "section_id": "7b7cba0f-406c-4c39-a0a1-3c518d1de307",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:25:54.000",
        "event": "mapping_hover",
        "id": "brng2tnm3aqsElwLXPMx"
    },
    {
        "data": {
            "structured_type": "structured",
            "section_id": "7b7cba0f-406c-4c39-a0a1-3c518d1de307",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:25:54.000",
        "event": "mapping_unhover",
        "id": "oh3cNRGuCm7iFoD2ozwQ"
    },
    {
        "data": {
            "structured_type": "structured",
            "section_id": "7b7cba0f-406c-4c39-a0a1-3c518d1de307",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:25:55.000",
        "event": "mapping_unhover",
        "id": "5p40hnYjD1Y47JOgpnbI"
    },
    {
        "data": {
            "mapping_index": 2,
            "structured_type": "structured",
            "section_id": "7b7cba0f-406c-4c39-a0a1-3c518d1de307",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:25:56.000",
        "event": "mapping_hover",
        "id": "AEw68fH9an7NrntKiw1n"
    },
    {
        "data": {
            "mapping_index": 3,
            "structured_type": "structured",
            "section_id": "7b7cba0f-406c-4c39-a0a1-3c518d1de307",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:25:56.000",
        "event": "mapping_hover",
        "id": "FwjQpGWWHrSmAW5GYkpl"
    },
    {
        "data": {
            "structured_type": "structured",
            "section_id": "7b7cba0f-406c-4c39-a0a1-3c518d1de307",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:25:56.000",
        "event": "mapping_unhover",
        "id": "JCo7IhMGhH2bjyf5uC8I"
    },
    {
        "data": {
            "mapping_index": 3,
            "structured_type": "structured",
            "section_id": "7b7cba0f-406c-4c39-a0a1-3c518d1de307",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:25:57.000",
        "event": "mapping_hover",
        "id": "91z7g9NI1Y8QcFinDhHD"
    },
    {
        "data": {
            "structured_type": "structured",
            "section_id": "7b7cba0f-406c-4c39-a0a1-3c518d1de307",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:25:57.000",
        "event": "mapping_unhover",
        "id": "uuLeqiE2IDJxPOdZdXMD"
    },
    {
        "data": {
            "structured_type": "structured",
            "section_id": "7b7cba0f-406c-4c39-a0a1-3c518d1de307",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:25:57.000",
        "event": "mapping_unhover",
        "id": "zWIDKZUvNjWMeVE5Api5"
    },
    {
        "data": {
            "structured_type": "structured",
            "section_id": "7b7cba0f-406c-4c39-a0a1-3c518d1de307",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:25:58.000",
        "event": "mapping_unhover",
        "id": "2JC35e5NcrF1tAIKyPMb"
    },
    {
        "data": {
            "mapping_index": 1,
            "structured_type": "structured",
            "section_id": "7b7cba0f-406c-4c39-a0a1-3c518d1de307",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:25:58.000",
        "event": "mapping_hover",
        "id": "JGwj3iTCErQTUyKdylXr"
    },
    {
        "data": {
            "mapping_index": 2,
            "structured_type": "structured",
            "section_id": "7b7cba0f-406c-4c39-a0a1-3c518d1de307",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:25:58.000",
        "event": "mapping_hover",
        "id": "UJZYY9VjYWJDJRJw7w01"
    },
    {
        "data": {
            "mapping_index": 2,
            "structured_type": "structured",
            "section_id": "7b7cba0f-406c-4c39-a0a1-3c518d1de307",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:25:58.000",
        "event": "mapping_hover",
        "id": "c7dP0HOdMFKekewP36GI"
    },
    {
        "data": {
            "structured_type": "structured",
            "section_id": "7b7cba0f-406c-4c39-a0a1-3c518d1de307",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:25:58.000",
        "event": "mapping_unhover",
        "id": "g7LJGKNbrqCx8WVeUsMT"
    },
    {
        "data": {
            "structured_type": "structured",
            "section_id": "7b7cba0f-406c-4c39-a0a1-3c518d1de307",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:25:59.000",
        "event": "mapping_unhover",
        "id": "3Capnlib94pHUCE0DOZZ"
    },
    {
        "data": {
            "structured_type": "structured",
            "section_id": "7b7cba0f-406c-4c39-a0a1-3c518d1de307",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:26:00.000",
        "event": "mapping_unhover",
        "id": "0LWVjVNNpXxx0J9QvrpB"
    },
    {
        "data": {
            "structured_type": "structured",
            "section_id": "7b7cba0f-406c-4c39-a0a1-3c518d1de307",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:26:00.000",
        "event": "mapping_unhover",
        "id": "BuYY7VRQFRVmBsPHPPoA"
    },
    {
        "data": {
            "mapping_index": 2,
            "structured_type": "structured",
            "section_id": "7b7cba0f-406c-4c39-a0a1-3c518d1de307",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:26:00.000",
        "event": "mapping_hover",
        "id": "QoVFfcZrtCn3vfLLtFKe"
    },
    {
        "data": {
            "mapping_index": 3,
            "structured_type": "structured",
            "section_id": "7b7cba0f-406c-4c39-a0a1-3c518d1de307",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:26:00.000",
        "event": "mapping_hover",
        "id": "mMooJlHRA7q5cxpc6lqd"
    },
    {
        "data": {
            "mapping_index": 3,
            "structured_type": "structured",
            "section_id": "7b7cba0f-406c-4c39-a0a1-3c518d1de307",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:26:00.000",
        "event": "mapping_hover",
        "id": "stGwOiFAFSuQStN570y3"
    },
    {
        "data": {
            "structured_type": "structured",
            "section_id": "7b7cba0f-406c-4c39-a0a1-3c518d1de307",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:26:02.000",
        "event": "mapping_unhover",
        "id": "8HEne0bnVin2XZDvu2n2"
    },
    {
        "data": {
            "mapping_index": 2,
            "structured_type": "structured",
            "section_id": "7b7cba0f-406c-4c39-a0a1-3c518d1de307",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:26:03.000",
        "event": "mapping_hover",
        "id": "1IBy7KaD6dfoMtOcm5JS"
    },
    {
        "data": {
            "mapping_index": 3,
            "structured_type": "structured",
            "section_id": "7b7cba0f-406c-4c39-a0a1-3c518d1de307",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:26:03.000",
        "event": "mapping_hover",
        "id": "ObYRlmaf7Sgz7CCBmQLm"
    },
    {
        "data": {
            "structured_type": "structured",
            "section_id": "7b7cba0f-406c-4c39-a0a1-3c518d1de307",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:26:03.000",
        "event": "mapping_unhover",
        "id": "UzuJQDspDVrWzBKs0II6"
    },
    {
        "data": {
            "structured_type": "structured",
            "section_id": "7b7cba0f-406c-4c39-a0a1-3c518d1de307",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:26:03.000",
        "event": "mapping_unhover",
        "id": "tTsvlPlZdDx2ICokS9q5"
    },
    {
        "data": {
            "mapping_index": 3,
            "structured_type": "structured",
            "section_id": "7b7cba0f-406c-4c39-a0a1-3c518d1de307",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:26:04.000",
        "event": "mapping_hover",
        "id": "mRkbvHg3083qJm4mohto"
    },
    {
        "data": {
            "structured_type": "structured",
            "section_id": "7b7cba0f-406c-4c39-a0a1-3c518d1de307",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:26:05.000",
        "event": "mapping_unhover",
        "id": "alLVqLfZE7B2J1uQ4sVp"
    },
    {
        "data": {
            "mapping_index": 3,
            "structured_type": "structured",
            "section_id": "7b7cba0f-406c-4c39-a0a1-3c518d1de307",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:26:06.000",
        "event": "mapping_hover",
        "id": "6RvnjPZfBJ7B3UvP8yaB"
    },
    {
        "data": {
            "structured_type": "structured",
            "section_id": "7b7cba0f-406c-4c39-a0a1-3c518d1de307",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:26:07.000",
        "event": "mapping_unhover",
        "id": "lyIhMeTca8HHw1bN2zoY"
    },
    {
        "data": {
            "mapping_index": 3,
            "structured_type": "structured",
            "section_id": "7b7cba0f-406c-4c39-a0a1-3c518d1de307",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:26:08.000",
        "event": "mapping_hover",
        "id": "v6LnnQb9aO4enCDDUwli"
    },
    {
        "data": {
            "structured_type": "structured",
            "section_id": "7b7cba0f-406c-4c39-a0a1-3c518d1de307",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:26:09.000",
        "event": "mapping_unhover",
        "id": "9gbujekC7NwTt6irTxoy"
    },
    {
        "data": {
            "structured_type": "structured",
            "section_id": "7b7cba0f-406c-4c39-a0a1-3c518d1de307",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:26:09.000",
        "event": "mapping_unhover",
        "id": "IhFUJm0EQyUl7sc1fjdZ"
    },
    {
        "data": {
            "structured_type": "structured",
            "section_id": "7b7cba0f-406c-4c39-a0a1-3c518d1de307",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:26:09.000",
        "event": "mapping_unhover",
        "id": "TubBkNALwIcxNeJgb4DM"
    },
    {
        "data": {
            "mapping_index": 0,
            "structured_type": "structured",
            "section_id": "7b7cba0f-406c-4c39-a0a1-3c518d1de307",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:26:09.000",
        "event": "mapping_hover",
        "id": "a5gPiB9aCDeqwLXKkuO1"
    },
    {
        "data": {
            "mapping_index": 1,
            "structured_type": "structured",
            "section_id": "7b7cba0f-406c-4c39-a0a1-3c518d1de307",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:26:09.000",
        "event": "mapping_hover",
        "id": "bwIavisw2srD5wVII9q5"
    },
    {
        "data": {
            "mapping_index": 2,
            "structured_type": "structured",
            "section_id": "7b7cba0f-406c-4c39-a0a1-3c518d1de307",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:26:09.000",
        "event": "mapping_hover",
        "id": "gPxK4Ctr6yuMBGDIuI5p"
    },
    {
        "data": {
            "structured_type": "structured",
            "section_id": "7b7cba0f-406c-4c39-a0a1-3c518d1de307",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:26:10.000",
        "event": "mapping_unhover",
        "id": "25gHGl0Xq3AoLhMvAQat"
    },
    {
        "data": {
            "mapping_index": 1,
            "structured_type": "structured",
            "section_id": "7b7cba0f-406c-4c39-a0a1-3c518d1de307",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:26:10.000",
        "event": "mapping_hover",
        "id": "BsaTIMcq7ogeRmewSlE9"
    },
    {
        "data": {
            "structured_type": "structured",
            "section_id": "7b7cba0f-406c-4c39-a0a1-3c518d1de307",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:26:11.000",
        "event": "mapping_unhover",
        "id": "vzAC53UndeJyJQFXDiCP"
    },
    {
        "data": {
            "mapping_index": 1,
            "structured_type": "structured",
            "section_id": "7b7cba0f-406c-4c39-a0a1-3c518d1de307",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:26:12.000",
        "event": "mapping_hover",
        "id": "4ENUWSe4qvriLN4P3dxl"
    },
    {
        "data": {
            "structured_type": "structured",
            "section_id": "7b7cba0f-406c-4c39-a0a1-3c518d1de307",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:26:12.000",
        "event": "mapping_unhover",
        "id": "YY4mCpnGJeYpPvJX8o40"
    },
    {
        "data": {
            "mapping_index": 2,
            "structured_type": "structured",
            "section_id": "7b7cba0f-406c-4c39-a0a1-3c518d1de307",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:26:12.000",
        "event": "mapping_hover",
        "id": "ZJwLR4gMsgf2V8QwP4Si"
    },
    {
        "data": {
            "structured_type": "structured",
            "section_id": "7b7cba0f-406c-4c39-a0a1-3c518d1de307",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:26:12.000",
        "event": "mapping_unhover",
        "id": "bVABeGFmhXqMor1eKj2C"
    },
    {
        "data": {
            "mapping_index": 3,
            "structured_type": "structured",
            "section_id": "7b7cba0f-406c-4c39-a0a1-3c518d1de307",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:26:12.000",
        "event": "mapping_hover",
        "id": "j9sGiTOb5CkwoCvVZeva"
    },
    {
        "data": {
            "structured_type": "structured",
            "section_id": "7b7cba0f-406c-4c39-a0a1-3c518d1de307",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:26:13.000",
        "event": "mapping_unhover",
        "id": "Xceq2e1ARBCCPUr59lZi"
    },
    {
        "data": {
            "mapping_index": 0,
            "structured_type": "structured",
            "section_id": "7b7cba0f-406c-4c39-a0a1-3c518d1de307",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:26:13.000",
        "event": "mapping_hover",
        "id": "e2qH4nZgBy8gE01xdAwQ"
    },
    {
        "data": {
            "mapping_index": 1,
            "structured_type": "structured",
            "section_id": "7b7cba0f-406c-4c39-a0a1-3c518d1de307",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:26:14.000",
        "event": "mapping_hover",
        "id": "GmMoiNLln65RaDfspm1m"
    },
    {
        "data": {
            "structured_type": "structured",
            "section_id": "7b7cba0f-406c-4c39-a0a1-3c518d1de307",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:26:14.000",
        "event": "mapping_unhover",
        "id": "YlE3vfBdSQk0LJFKFVS9"
    },
    {
        "data": {
            "mapping_index": 1,
            "structured_type": "structured",
            "section_id": "7b7cba0f-406c-4c39-a0a1-3c518d1de307",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:26:15.000",
        "event": "mapping_hover",
        "id": "ANkxISjZgNn82YnGkJIf"
    },
    {
        "data": {
            "mapping_index": 0,
            "structured_type": "structured",
            "section_id": "7b7cba0f-406c-4c39-a0a1-3c518d1de307",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:26:15.000",
        "event": "mapping_hover",
        "id": "Netxh00ZBH8vuXrKtejJ"
    },
    {
        "data": {
            "structured_type": "structured",
            "section_id": "7b7cba0f-406c-4c39-a0a1-3c518d1de307",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:26:15.000",
        "event": "mapping_unhover",
        "id": "ZQ5hTo003lFrRJqg4EqJ"
    },
    {
        "data": {
            "structured_type": "structured",
            "section_id": "7b7cba0f-406c-4c39-a0a1-3c518d1de307",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:26:15.000",
        "event": "mapping_unhover",
        "id": "k0x9iuIqY2577eDW2QG1"
    },
    {
        "data": {
            "mapping_index": 0,
            "structured_type": "structured",
            "section_id": "7b7cba0f-406c-4c39-a0a1-3c518d1de307",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:26:17.000",
        "event": "mapping_hover",
        "id": "0ODXYqvDQlL8sj98NOBj"
    },
    {
        "data": {
            "structured_type": "structured",
            "section_id": "7b7cba0f-406c-4c39-a0a1-3c518d1de307",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:26:17.000",
        "event": "mapping_unhover",
        "id": "rpMzEccjUFtc4hXsAHXE"
    },
    {
        "data": {
            "structured_type": "structured",
            "section_id": "7b7cba0f-406c-4c39-a0a1-3c518d1de307",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:26:20.000",
        "event": "mapping_unhover",
        "id": "Cx487FhXKwBVQ3w0N69N"
    },
    {
        "data": {
            "mapping_index": 1,
            "structured_type": "structured",
            "section_id": "7b7cba0f-406c-4c39-a0a1-3c518d1de307",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:26:20.000",
        "event": "mapping_hover",
        "id": "vcIO5LW2L5mte9v55Q4M"
    },
    {
        "data": {
            "structured_type": "structured",
            "section_id": "7b7cba0f-406c-4c39-a0a1-3c518d1de307",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:26:22.000",
        "event": "mapping_unhover",
        "id": "0Ariy0Nf2w3mVv1zXkHj"
    },
    {
        "data": {
            "mapping_index": 2,
            "structured_type": "structured",
            "section_id": "7b7cba0f-406c-4c39-a0a1-3c518d1de307",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:26:23.000",
        "event": "mapping_hover",
        "id": "qQBLGsS9SnAvwhNVxhUQ"
    },
    {
        "data": {
            "mapping_index": 2,
            "structured_type": "structured",
            "section_id": "7b7cba0f-406c-4c39-a0a1-3c518d1de307",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:26:26.000",
        "event": "mapping_hover",
        "id": "BIYQGsCFh5fJY7FIiSyY"
    },
    {
        "data": {
            "mapping_index": 3,
            "structured_type": "structured",
            "section_id": "7b7cba0f-406c-4c39-a0a1-3c518d1de307",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:26:26.000",
        "event": "mapping_hover",
        "id": "ENtb6dRTQTkXFoeks0HE"
    },
    {
        "data": {
            "structured_type": "structured",
            "section_id": "7b7cba0f-406c-4c39-a0a1-3c518d1de307",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:26:26.000",
        "event": "mapping_unhover",
        "id": "LoJUPBFDpnpoG9DHqskX"
    },
    {
        "data": {
            "structured_type": "structured",
            "section_id": "7b7cba0f-406c-4c39-a0a1-3c518d1de307",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:26:26.000",
        "event": "mapping_unhover",
        "id": "p66DlWk0aZdrqUql7Hyk"
    },
    {
        "data": {
            "structured_type": "structured",
            "section_id": "7b7cba0f-406c-4c39-a0a1-3c518d1de307",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:26:26.000",
        "event": "mapping_unhover",
        "id": "xL5DIGw2NdDCn7CR5L5e"
    },
    {
        "data": {
            "mapping_index": 0,
            "structured_type": "structured",
            "section_id": "7b7cba0f-406c-4c39-a0a1-3c518d1de307",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:26:58.000",
        "event": "mapping_hover",
        "id": "ysbbX0uFeX1GPAhMVfQ4"
    },
    {
        "data": {
            "structured_type": "structured",
            "section_id": "7b7cba0f-406c-4c39-a0a1-3c518d1de307",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:26:59.000",
        "event": "mapping_unhover",
        "id": "5PnekXCpiPfmeXZWrqnY"
    },
    {
        "data": {
            "mapping_index": 1,
            "structured_type": "structured",
            "section_id": "7b7cba0f-406c-4c39-a0a1-3c518d1de307",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:26:59.000",
        "event": "mapping_hover",
        "id": "gtqwjELoIQkE4C4v40Rs"
    },
    {
        "data": {
            "structured_type": "structured",
            "section_id": "7b7cba0f-406c-4c39-a0a1-3c518d1de307",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:27:02.000",
        "event": "mapping_unhover",
        "id": "1fclETk4T4Pz7eM078Y6"
    },
    {
        "data": {
            "mapping_index": 2,
            "structured_type": "structured",
            "section_id": "7b7cba0f-406c-4c39-a0a1-3c518d1de307",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:27:02.000",
        "event": "mapping_hover",
        "id": "e72TZQwrb0Av7KnB2okG"
    },
    {
        "data": {
            "structured_type": "structured",
            "section_id": "7b7cba0f-406c-4c39-a0a1-3c518d1de307",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:27:03.000",
        "event": "mapping_unhover",
        "id": "NyH2pwr9kgBTccoXaAst"
    },
    {
        "data": {
            "structured_type": "structured",
            "section_id": "7b7cba0f-406c-4c39-a0a1-3c518d1de307",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:27:03.000",
        "event": "mapping_unhover",
        "id": "bvETa2ZeyTytCYxeaJ1R"
    },
    {
        "data": {
            "mapping_index": 3,
            "structured_type": "structured",
            "section_id": "7b7cba0f-406c-4c39-a0a1-3c518d1de307",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:27:03.000",
        "event": "mapping_hover",
        "id": "qGzxlQm22LOo0aFG6oBQ"
    },
    {
        "data": {
            "mapping_index": 3,
            "structured_type": "structured",
            "section_id": "7b7cba0f-406c-4c39-a0a1-3c518d1de307",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:27:04.000",
        "event": "mapping_hover",
        "id": "1SeZ2jWYgaj8hVrfC4kb"
    },
    {
        "data": {
            "structured_type": "structured",
            "section_id": "7b7cba0f-406c-4c39-a0a1-3c518d1de307",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:27:04.000",
        "event": "mapping_unhover",
        "id": "MlfyuXJ1NH9O5gVQnffK"
    },
    {
        "data": {
            "structured_type": "structured",
            "section_id": "7b7cba0f-406c-4c39-a0a1-3c518d1de307",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:28:08.000",
        "event": "mapping_unhover",
        "id": "77fF1TfESMMKn2ESL4tP"
    },
    {
        "data": {
            "mapping_index": 1,
            "structured_type": "structured",
            "section_id": "7b7cba0f-406c-4c39-a0a1-3c518d1de307",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:28:08.000",
        "event": "mapping_hover",
        "id": "BbJWhlAUKPCJ1uNEnUup"
    },
    {
        "data": {
            "structured_type": "structured",
            "section_id": "7b7cba0f-406c-4c39-a0a1-3c518d1de307",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:28:08.000",
        "event": "mapping_unhover",
        "id": "K94Yy6Qh9K9uFWTkX92M"
    },
    {
        "data": {
            "structured_type": "structured",
            "section_id": "7b7cba0f-406c-4c39-a0a1-3c518d1de307",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:28:08.000",
        "event": "mapping_unhover",
        "id": "LTmI2NcOrVACMAvQbvfN"
    },
    {
        "data": {
            "mapping_index": 0,
            "structured_type": "structured",
            "section_id": "7b7cba0f-406c-4c39-a0a1-3c518d1de307",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:28:08.000",
        "event": "mapping_hover",
        "id": "TLXUKzLMcXgl4Ij6wzPR"
    },
    {
        "data": {
            "mapping_index": 3,
            "structured_type": "structured",
            "section_id": "7b7cba0f-406c-4c39-a0a1-3c518d1de307",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:28:08.000",
        "event": "mapping_hover",
        "id": "h4rPaVKR9gTJjbTxchCM"
    },
    {
        "data": {
            "mapping_index": 2,
            "structured_type": "structured",
            "section_id": "7b7cba0f-406c-4c39-a0a1-3c518d1de307",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:28:08.000",
        "event": "mapping_hover",
        "id": "jDi8POAB1oYW4p9P6kcT"
    },
    {
        "data": {
            "structured_type": "structured",
            "section_id": "7b7cba0f-406c-4c39-a0a1-3c518d1de307",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:28:08.000",
        "event": "mapping_unhover",
        "id": "x8oca5m0tm7UohFtS2fR"
    },
    {
        "data": {
            "structured_type": "structured",
            "section_id": "7b7cba0f-406c-4c39-a0a1-3c518d1de307",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:28:09.000",
        "event": "mapping_unhover",
        "id": "6mXjYElplJQGjUNUHbdc"
    },
    {
        "data": {
            "structured_type": "structured",
            "section_id": "7b7cba0f-406c-4c39-a0a1-3c518d1de307",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:28:09.000",
        "event": "mapping_unhover",
        "id": "Dr8bhPbOmLcX7V5ogYxt"
    },
    {
        "data": {
            "mapping_index": 0,
            "structured_type": "structured",
            "section_id": "7b7cba0f-406c-4c39-a0a1-3c518d1de307",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:28:09.000",
        "event": "mapping_hover",
        "id": "GD20SjyZlBz2wvH7lufM"
    },
    {
        "data": {
            "mapping_index": 1,
            "structured_type": "structured",
            "section_id": "7b7cba0f-406c-4c39-a0a1-3c518d1de307",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:28:09.000",
        "event": "mapping_hover",
        "id": "yoLaOlVkhEM9oHyZKVD6"
    },
    {
        "data": {
            "mapping_index": 0,
            "structured_type": "structured",
            "section_id": "7b7cba0f-406c-4c39-a0a1-3c518d1de307",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:28:10.000",
        "event": "mapping_hover",
        "id": "4qwbCYs2J4m0rLQojb8Z"
    },
    {
        "data": {},
        "source": "frontend",
        "timestamp": "2025-08-23 10:28:10.000",
        "event": "click_summarize_code",
        "id": "7arhjAxcw9w27oIfzQmv"
    },
    {
        "data": {
            "structured_type": "structured",
            "section_id": "7b7cba0f-406c-4c39-a0a1-3c518d1de307",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:28:10.000",
        "event": "mapping_unhover",
        "id": "IfTaKAWtBn9YDjvMVw7M"
    },
    {
        "data": {
            "structured_type": "structured",
            "section_id": "7b7cba0f-406c-4c39-a0a1-3c518d1de307",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:28:10.000",
        "event": "mapping_unhover",
        "id": "lxK5hpXkTUsxdyZbnBYR"
    },
    {
        "data": {
            "mapping_index": 1,
            "structured_type": "structured",
            "section_id": "7b7cba0f-406c-4c39-a0a1-3c518d1de307",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:28:10.000",
        "event": "mapping_hover",
        "id": "zzO84G6ZIhjf6MhWQ0EQ"
    },
    {
        "data": {
            "selected_code": "import pandas as pd\n\n\ndef load_and_merge(mvp_path=\"data/mvp_votes.csv\", stats_path=\"data/season_stats.csv\"):\n    mvp_df = pd.read_csv(mvp_path)\n    stats_df = pd.read_csv(stats_path)\n\n    # Normalize names\n    mvp_df[\"Name\"] = mvp_df[\"Name\"].str.strip()\n    stats_df[\"Player\"] = stats_df[\"Player\"].str.strip()\n\n    # Merge on name + year\n    merged = pd.merge(\n        mvp_df,\n        stats_df,\n        left_on=[\"Name\", \"Year\"],\n        right_on=[\"Player\", \"Year\"],\n        how=\"left\",\n    )\n\n    # Drop unnecessary columns\n    drop_cols = [\"Rk\", \"Player\", \"Pos\", \"Tm_y\"]\n    merged.drop(\n        columns=[col for col in drop_cols if col in merged.columns], inplace=True\n    )\n\n    # Clean numeric columns\n    for col in merged.columns:\n        if merged[col].dtype == \"object\":\n            try:\n                merged[col] = merged[col].astype(float)\n            except:\n                pass\n\n    # Assign ordinal MVP rank (1 = MVP)\n    merged[\"Rank\"] = merged.groupby(\"Year\")[\"MVP_Points\"].rank(\n        ascending=False, method=\"first\"\n    )\n\n    return merged\n\n\nif __name__ == \"__main__\":\n    df = load_and_merge()\n    df.to_csv(\"data/merged_data.csv\", index=False)\n    print(\"Merged data saved to data/merged_data.csv\")\n",
            "summary": {
                "medium_unstructured": "The code defines a function to load MVP votes and season statistics from CSV files, normalize and merge them, clean up columns, and assign MVP ranks. The processed data is then saved to a new CSV file when the script is run directly.",
                "low_structured": "• Loads MVP and season stats data from CSV files\n• Merges and cleans the data\n• Saves the processed data to a new CSV file",
                "title": "Summary of load_and_merge Function and Main Block",
                "medium_structured": "• Loads MVP and season stats data from specified CSV files\n• Normalizes player names for consistency\n• Merges datasets on player name and year\n• Cleans data by dropping unnecessary columns and converting numeric columns\n• Assigns ordinal MVP ranks and saves the merged data to a CSV file",
                "high_unstructured": "This code defines a function that reads MVP votes and season statistics from separate CSV files, normalizes player names, and merges the datasets based on player name and year. It then removes unnecessary columns, attempts to convert object-type columns to numeric types where possible, and assigns an ordinal MVP rank within each year based on MVP points. When executed as a script, it saves the cleaned and merged dataset to a new CSV file and prints a confirmation message.",
                "high_structured": "• Defines a function to process MVP and season stats data\n  ◦ Reads MVP votes and season statistics from CSV files\n  ◦ Normalizes player names by stripping whitespace\n• Merges the two datasets on player name and year\n• Cleans the merged data\n  ◦ Drops unnecessary columns like 'Rk', 'Player', 'Pos', and 'Tm_y' if present\n  ◦ Attempts to convert object-type columns to floats where possible\n• Assigns an ordinal MVP rank within each year based on MVP points\n• When run as a script:\n  ◦ Calls the data processing function\n  ◦ Saves the merged and cleaned data to 'data/merged_data.csv'\n  ◦ Prints a confirmation message upon successful save",
                "low_unstructured": "This code loads, merges, cleans, and processes MVP and season stats data, then saves the result to a CSV file."
            }
        },
        "source": "backend",
        "timestamp": "2025-08-23 10:28:16.000",
        "event": "summarize_selected_code",
        "id": "a6CwXqmHAallGdI53EvS"
    },
    {
        "data": {
            "mapping": [
                {
                    "summaryComponent": "Loads MVP and season stats data from CSV files",
                    "codeSegments": [
                        {
                            "line": 5,
                            "code": "mvp_df = pd.read_csv(mvp_path)"
                        },
                        {
                            "line": 6,
                            "code": "stats_df = pd.read_csv(stats_path)"
                        }
                    ]
                },
                {
                    "summaryComponent": "Merges and cleans the data",
                    "codeSegments": [
                        {
                            "line": 13,
                            "code": "merged = pd.merge("
                        },
                        {
                            "line": 22,
                            "code": "drop_cols = [\"Rk\", \"Player\", \"Pos\", \"Tm_y\"]"
                        },
                        {
                            "line": 23,
                            "code": "merged.drop("
                        },
                        {
                            "line": 28,
                            "code": "for col in merged.columns:"
                        }
                    ]
                },
                {
                    "summaryComponent": "Saves the processed data to a new CSV file",
                    "codeSegments": [
                        {
                            "line": 45,
                            "code": "df.to_csv(\"data/merged_data.csv\", index=False)"
                        }
                    ]
                }
            ],
            "summary": "• Loads MVP and season stats data from CSV files\n• Merges and cleans the data\n• Saves the processed data to a new CSV file",
            "code": "1: import pandas as pd\n2: \n3: \n4: def load_and_merge(mvp_path=\"data/mvp_votes.csv\", stats_path=\"data/season_stats.csv\"):\n5:     mvp_df = pd.read_csv(mvp_path)\n6:     stats_df = pd.read_csv(stats_path)\n7: \n8:     # Normalize names\n9:     mvp_df[\"Name\"] = mvp_df[\"Name\"].str.strip()\n10:     stats_df[\"Player\"] = stats_df[\"Player\"].str.strip()\n11: \n12:     # Merge on name + year\n13:     merged = pd.merge(\n14:         mvp_df,\n15:         stats_df,\n16:         left_on=[\"Name\", \"Year\"],\n17:         right_on=[\"Player\", \"Year\"],\n18:         how=\"left\",\n19:     )\n20: \n21:     # Drop unnecessary columns\n22:     drop_cols = [\"Rk\", \"Player\", \"Pos\", \"Tm_y\"]\n23:     merged.drop(\n24:         columns=[col for col in drop_cols if col in merged.columns], inplace=True\n25:     )\n26: \n27:     # Clean numeric columns\n28:     for col in merged.columns:\n29:         if merged[col].dtype == \"object\":\n30:             try:\n31:                 merged[col] = merged[col].astype(float)\n32:             except:\n33:                 pass\n34: \n35:     # Assign ordinal MVP rank (1 = MVP)\n36:     merged[\"Rank\"] = merged.groupby(\"Year\")[\"MVP_Points\"].rank(\n37:         ascending=False, method=\"first\"\n38:     )\n39: \n40:     return merged\n41: \n42: \n43: if __name__ == \"__main__\":\n44:     df = load_and_merge()\n45:     df.to_csv(\"data/merged_data.csv\", index=False)\n46:     print(\"Merged data saved to data/merged_data.csv\")\n47: "
        },
        "source": "backend",
        "timestamp": "2025-08-23 10:28:17.000",
        "event": "map_summary_code",
        "id": "WYqT5GExHlO5KunLNDzd"
    },
    {
        "data": {
            "mapping": [
                {
                    "summaryComponent": "defines a function that reads MVP votes and season statistics from separate CSV files",
                    "codeSegments": [
                        {
                            "line": 4,
                            "code": "def load_and_merge(mvp_path=\"data/mvp_votes.csv\", stats_path=\"data/season_stats.csv\"):"
                        },
                        {
                            "line": 5,
                            "code": "mvp_df = pd.read_csv(mvp_path)"
                        },
                        {
                            "line": 6,
                            "code": "stats_df = pd.read_csv(stats_path)"
                        }
                    ]
                },
                {
                    "summaryComponent": "normalizes player names",
                    "codeSegments": [
                        {
                            "line": 9,
                            "code": "mvp_df[\"Name\"] = mvp_df[\"Name\"].str.strip()"
                        },
                        {
                            "line": 10,
                            "code": "stats_df[\"Player\"] = stats_df[\"Player\"].str.strip()"
                        }
                    ]
                },
                {
                    "summaryComponent": "merges the datasets based on player name and year",
                    "codeSegments": [
                        {
                            "line": 13,
                            "code": "merged = pd.merge("
                        },
                        {
                            "line": 16,
                            "code": "left_on=[\"Name\", \"Year\"],"
                        },
                        {
                            "line": 17,
                            "code": "right_on=[\"Player\", \"Year\"],"
                        }
                    ]
                },
                {
                    "summaryComponent": "removes unnecessary columns",
                    "codeSegments": [
                        {
                            "line": 22,
                            "code": "drop_cols = [\"Rk\", \"Player\", \"Pos\", \"Tm_y\"]"
                        },
                        {
                            "line": 23,
                            "code": "merged.drop("
                        }
                    ]
                },
                {
                    "summaryComponent": "attempts to convert object-type columns to numeric types where possible",
                    "codeSegments": [
                        {
                            "line": 28,
                            "code": "for col in merged.columns:"
                        },
                        {
                            "line": 29,
                            "code": "if merged[col].dtype == \"object\":"
                        },
                        {
                            "line": 31,
                            "code": "merged[col] = merged[col].astype(float)"
                        }
                    ]
                },
                {
                    "summaryComponent": "assigns an ordinal MVP rank within each year based on MVP points",
                    "codeSegments": [
                        {
                            "line": 36,
                            "code": "merged[\"Rank\"] = merged.groupby(\"Year\")[\"MVP_Points\"].rank("
                        }
                    ]
                },
                {
                    "summaryComponent": "When executed as a script",
                    "codeSegments": [
                        {
                            "line": 43,
                            "code": "if __name__ == \"__main__\":"
                        }
                    ]
                },
                {
                    "summaryComponent": "saves the cleaned and merged dataset to a new CSV file",
                    "codeSegments": [
                        {
                            "line": 45,
                            "code": "df.to_csv(\"data/merged_data.csv\", index=False)"
                        }
                    ]
                },
                {
                    "summaryComponent": "prints a confirmation message",
                    "codeSegments": [
                        {
                            "line": 46,
                            "code": "print(\"Merged data saved to data/merged_data.csv\")"
                        }
                    ]
                }
            ],
            "summary": "This code defines a function that reads MVP votes and season statistics from separate CSV files, normalizes player names, and merges the datasets based on player name and year. It then removes unnecessary columns, attempts to convert object-type columns to numeric types where possible, and assigns an ordinal MVP rank within each year based on MVP points. When executed as a script, it saves the cleaned and merged dataset to a new CSV file and prints a confirmation message.",
            "code": "1: import pandas as pd\n2: \n3: \n4: def load_and_merge(mvp_path=\"data/mvp_votes.csv\", stats_path=\"data/season_stats.csv\"):\n5:     mvp_df = pd.read_csv(mvp_path)\n6:     stats_df = pd.read_csv(stats_path)\n7: \n8:     # Normalize names\n9:     mvp_df[\"Name\"] = mvp_df[\"Name\"].str.strip()\n10:     stats_df[\"Player\"] = stats_df[\"Player\"].str.strip()\n11: \n12:     # Merge on name + year\n13:     merged = pd.merge(\n14:         mvp_df,\n15:         stats_df,\n16:         left_on=[\"Name\", \"Year\"],\n17:         right_on=[\"Player\", \"Year\"],\n18:         how=\"left\",\n19:     )\n20: \n21:     # Drop unnecessary columns\n22:     drop_cols = [\"Rk\", \"Player\", \"Pos\", \"Tm_y\"]\n23:     merged.drop(\n24:         columns=[col for col in drop_cols if col in merged.columns], inplace=True\n25:     )\n26: \n27:     # Clean numeric columns\n28:     for col in merged.columns:\n29:         if merged[col].dtype == \"object\":\n30:             try:\n31:                 merged[col] = merged[col].astype(float)\n32:             except:\n33:                 pass\n34: \n35:     # Assign ordinal MVP rank (1 = MVP)\n36:     merged[\"Rank\"] = merged.groupby(\"Year\")[\"MVP_Points\"].rank(\n37:         ascending=False, method=\"first\"\n38:     )\n39: \n40:     return merged\n41: \n42: \n43: if __name__ == \"__main__\":\n44:     df = load_and_merge()\n45:     df.to_csv(\"data/merged_data.csv\", index=False)\n46:     print(\"Merged data saved to data/merged_data.csv\")\n47: "
        },
        "source": "backend",
        "timestamp": "2025-08-23 10:28:19.000",
        "event": "map_summary_code",
        "id": "NKgNu536spS6ORRTnlCX"
    },
    {
        "data": {
            "mapping": [
                {
                    "summaryComponent": "Loads MVP and season stats data from specified CSV files",
                    "codeSegments": [
                        {
                            "line": 5,
                            "code": "mvp_df = pd.read_csv(mvp_path)"
                        },
                        {
                            "line": 6,
                            "code": "stats_df = pd.read_csv(stats_path)"
                        }
                    ]
                },
                {
                    "summaryComponent": "Normalizes player names for consistency",
                    "codeSegments": [
                        {
                            "line": 9,
                            "code": "mvp_df[\"Name\"] = mvp_df[\"Name\"].str.strip()"
                        },
                        {
                            "line": 10,
                            "code": "stats_df[\"Player\"] = stats_df[\"Player\"].str.strip()"
                        }
                    ]
                },
                {
                    "summaryComponent": "Merges datasets on player name and year",
                    "codeSegments": [
                        {
                            "line": 13,
                            "code": "merged = pd.merge("
                        },
                        {
                            "line": 16,
                            "code": "left_on=[\"Name\", \"Year\"],"
                        },
                        {
                            "line": 17,
                            "code": "right_on=[\"Player\", \"Year\"],"
                        }
                    ]
                },
                {
                    "summaryComponent": "Cleans data by dropping unnecessary columns and converting numeric columns",
                    "codeSegments": [
                        {
                            "line": 22,
                            "code": "drop_cols = [\"Rk\", \"Player\", \"Pos\", \"Tm_y\"]"
                        },
                        {
                            "line": 23,
                            "code": "merged.drop("
                        },
                        {
                            "line": 28,
                            "code": "for col in merged.columns:"
                        },
                        {
                            "line": 29,
                            "code": "if merged[col].dtype == \"object\":"
                        },
                        {
                            "line": 31,
                            "code": "merged[col] = merged[col].astype(float)"
                        }
                    ]
                },
                {
                    "summaryComponent": "Assigns ordinal MVP ranks and saves the merged data to a CSV file",
                    "codeSegments": [
                        {
                            "line": 36,
                            "code": "merged[\"Rank\"] = merged.groupby(\"Year\")[\"MVP_Points\"].rank("
                        },
                        {
                            "line": 44,
                            "code": "df = load_and_merge()"
                        },
                        {
                            "line": 45,
                            "code": "df.to_csv(\"data/merged_data.csv\", index=False)"
                        }
                    ]
                }
            ],
            "summary": "• Loads MVP and season stats data from specified CSV files\n• Normalizes player names for consistency\n• Merges datasets on player name and year\n• Cleans data by dropping unnecessary columns and converting numeric columns\n• Assigns ordinal MVP ranks and saves the merged data to a CSV file",
            "code": "1: import pandas as pd\n2: \n3: \n4: def load_and_merge(mvp_path=\"data/mvp_votes.csv\", stats_path=\"data/season_stats.csv\"):\n5:     mvp_df = pd.read_csv(mvp_path)\n6:     stats_df = pd.read_csv(stats_path)\n7: \n8:     # Normalize names\n9:     mvp_df[\"Name\"] = mvp_df[\"Name\"].str.strip()\n10:     stats_df[\"Player\"] = stats_df[\"Player\"].str.strip()\n11: \n12:     # Merge on name + year\n13:     merged = pd.merge(\n14:         mvp_df,\n15:         stats_df,\n16:         left_on=[\"Name\", \"Year\"],\n17:         right_on=[\"Player\", \"Year\"],\n18:         how=\"left\",\n19:     )\n20: \n21:     # Drop unnecessary columns\n22:     drop_cols = [\"Rk\", \"Player\", \"Pos\", \"Tm_y\"]\n23:     merged.drop(\n24:         columns=[col for col in drop_cols if col in merged.columns], inplace=True\n25:     )\n26: \n27:     # Clean numeric columns\n28:     for col in merged.columns:\n29:         if merged[col].dtype == \"object\":\n30:             try:\n31:                 merged[col] = merged[col].astype(float)\n32:             except:\n33:                 pass\n34: \n35:     # Assign ordinal MVP rank (1 = MVP)\n36:     merged[\"Rank\"] = merged.groupby(\"Year\")[\"MVP_Points\"].rank(\n37:         ascending=False, method=\"first\"\n38:     )\n39: \n40:     return merged\n41: \n42: \n43: if __name__ == \"__main__\":\n44:     df = load_and_merge()\n45:     df.to_csv(\"data/merged_data.csv\", index=False)\n46:     print(\"Merged data saved to data/merged_data.csv\")\n47: "
        },
        "source": "backend",
        "timestamp": "2025-08-23 10:28:19.000",
        "event": "map_summary_code",
        "id": "poI1T2DUVFzw1hDHV6aT"
    },
    {
        "data": {
            "mapping": [
                {
                    "summaryComponent": "defines a function to load MVP votes and season statistics from CSV files",
                    "codeSegments": [
                        {
                            "line": 4,
                            "code": "def load_and_merge(mvp_path=\"data/mvp_votes.csv\", stats_path=\"data/season_stats.csv\"):"
                        },
                        {
                            "line": 5,
                            "code": "mvp_df = pd.read_csv(mvp_path)"
                        },
                        {
                            "line": 6,
                            "code": "stats_df = pd.read_csv(stats_path)"
                        }
                    ]
                },
                {
                    "summaryComponent": "normalize and merge them",
                    "codeSegments": [
                        {
                            "line": 9,
                            "code": "mvp_df[\"Name\"] = mvp_df[\"Name\"].str.strip()"
                        },
                        {
                            "line": 10,
                            "code": "stats_df[\"Player\"] = stats_df[\"Player\"].str.strip()"
                        },
                        {
                            "line": 13,
                            "code": "merged = pd.merge("
                        },
                        {
                            "line": 14,
                            "code": "    mvp_df,"
                        },
                        {
                            "line": 15,
                            "code": "    stats_df,"
                        },
                        {
                            "line": 16,
                            "code": "    left_on=[\"Name\", \"Year\"],"
                        },
                        {
                            "line": 17,
                            "code": "    right_on=[\"Player\", \"Year\"],"
                        },
                        {
                            "line": 18,
                            "code": "    how=\"left\","
                        },
                        {
                            "line": 19,
                            "code": ")"
                        }
                    ]
                },
                {
                    "summaryComponent": "clean up columns",
                    "codeSegments": [
                        {
                            "line": 22,
                            "code": "drop_cols = [\"Rk\", \"Player\", \"Pos\", \"Tm_y\"]"
                        },
                        {
                            "line": 23,
                            "code": "merged.drop("
                        },
                        {
                            "line": 24,
                            "code": "    columns=[col for col in drop_cols if col in merged.columns], inplace=True"
                        },
                        {
                            "line": 25,
                            "code": ")"
                        }
                    ]
                },
                {
                    "summaryComponent": "assign MVP ranks",
                    "codeSegments": [
                        {
                            "line": 36,
                            "code": "merged[\"Rank\"] = merged.groupby(\"Year\")[\"MVP_Points\"].rank("
                        },
                        {
                            "line": 37,
                            "code": "    ascending=False, method=\"first\""
                        },
                        {
                            "line": 38,
                            "code": ")"
                        }
                    ]
                },
                {
                    "summaryComponent": "The processed data is then saved to a new CSV file when the script is run directly.",
                    "codeSegments": [
                        {
                            "line": 43,
                            "code": "if __name__ == \"__main__\":"
                        },
                        {
                            "line": 44,
                            "code": "df = load_and_merge()"
                        },
                        {
                            "line": 45,
                            "code": "df.to_csv(\"data/merged_data.csv\", index=False)"
                        }
                    ]
                }
            ],
            "summary": "The code defines a function to load MVP votes and season statistics from CSV files, normalize and merge them, clean up columns, and assign MVP ranks. The processed data is then saved to a new CSV file when the script is run directly.",
            "code": "1: import pandas as pd\n2: \n3: \n4: def load_and_merge(mvp_path=\"data/mvp_votes.csv\", stats_path=\"data/season_stats.csv\"):\n5:     mvp_df = pd.read_csv(mvp_path)\n6:     stats_df = pd.read_csv(stats_path)\n7: \n8:     # Normalize names\n9:     mvp_df[\"Name\"] = mvp_df[\"Name\"].str.strip()\n10:     stats_df[\"Player\"] = stats_df[\"Player\"].str.strip()\n11: \n12:     # Merge on name + year\n13:     merged = pd.merge(\n14:         mvp_df,\n15:         stats_df,\n16:         left_on=[\"Name\", \"Year\"],\n17:         right_on=[\"Player\", \"Year\"],\n18:         how=\"left\",\n19:     )\n20: \n21:     # Drop unnecessary columns\n22:     drop_cols = [\"Rk\", \"Player\", \"Pos\", \"Tm_y\"]\n23:     merged.drop(\n24:         columns=[col for col in drop_cols if col in merged.columns], inplace=True\n25:     )\n26: \n27:     # Clean numeric columns\n28:     for col in merged.columns:\n29:         if merged[col].dtype == \"object\":\n30:             try:\n31:                 merged[col] = merged[col].astype(float)\n32:             except:\n33:                 pass\n34: \n35:     # Assign ordinal MVP rank (1 = MVP)\n36:     merged[\"Rank\"] = merged.groupby(\"Year\")[\"MVP_Points\"].rank(\n37:         ascending=False, method=\"first\"\n38:     )\n39: \n40:     return merged\n41: \n42: \n43: if __name__ == \"__main__\":\n44:     df = load_and_merge()\n45:     df.to_csv(\"data/merged_data.csv\", index=False)\n46:     print(\"Merged data saved to data/merged_data.csv\")\n47: "
        },
        "source": "backend",
        "timestamp": "2025-08-23 10:28:20.000",
        "event": "map_summary_code",
        "id": "qbMYxuhmz8D9qb4qzrZK"
    },
    {
        "data": {
            "mapping": [
                {
                    "summaryComponent": "Defines a function to process MVP and season stats data",
                    "codeSegments": [
                        {
                            "line": 4,
                            "code": "def load_and_merge(mvp_path=\"data/mvp_votes.csv\", stats_path=\"data/season_stats.csv\"):"
                        }
                    ]
                },
                {
                    "summaryComponent": "Reads MVP votes and season statistics from CSV files",
                    "codeSegments": [
                        {
                            "line": 5,
                            "code": "mvp_df = pd.read_csv(mvp_path)"
                        },
                        {
                            "line": 6,
                            "code": "stats_df = pd.read_csv(stats_path)"
                        }
                    ]
                },
                {
                    "summaryComponent": "Normalizes player names by stripping whitespace",
                    "codeSegments": [
                        {
                            "line": 9,
                            "code": "mvp_df[\"Name\"] = mvp_df[\"Name\"].str.strip()"
                        },
                        {
                            "line": 10,
                            "code": "stats_df[\"Player\"] = stats_df[\"Player\"].str.strip()"
                        }
                    ]
                },
                {
                    "summaryComponent": "Merges the two datasets on player name and year",
                    "codeSegments": [
                        {
                            "line": 13,
                            "code": "merged = pd.merge("
                        },
                        {
                            "line": 16,
                            "code": "left_on=[\"Name\", \"Year\"],"
                        },
                        {
                            "line": 17,
                            "code": "right_on=[\"Player\", \"Year\"],"
                        }
                    ]
                },
                {
                    "summaryComponent": "Cleans the merged data",
                    "codeSegments": [
                        {
                            "line": 21,
                            "code": "# Drop unnecessary columns"
                        },
                        {
                            "line": 27,
                            "code": "# Clean numeric columns"
                        }
                    ]
                },
                {
                    "summaryComponent": "Drops unnecessary columns like 'Rk', 'Player', 'Pos', and 'Tm_y' if present",
                    "codeSegments": [
                        {
                            "line": 22,
                            "code": "drop_cols = [\"Rk\", \"Player\", \"Pos\", \"Tm_y\"]"
                        },
                        {
                            "line": 23,
                            "code": "merged.drop("
                        }
                    ]
                },
                {
                    "summaryComponent": "Attempts to convert object-type columns to floats where possible",
                    "codeSegments": [
                        {
                            "line": 28,
                            "code": "for col in merged.columns:"
                        },
                        {
                            "line": 29,
                            "code": "if merged[col].dtype == \"object\":"
                        },
                        {
                            "line": 31,
                            "code": "merged[col] = merged[col].astype(float)"
                        }
                    ]
                },
                {
                    "summaryComponent": "Assigns an ordinal MVP rank within each year based on MVP points",
                    "codeSegments": [
                        {
                            "line": 36,
                            "code": "merged[\"Rank\"] = merged.groupby(\"Year\")[\"MVP_Points\"].rank("
                        }
                    ]
                },
                {
                    "summaryComponent": "Calls the data processing function",
                    "codeSegments": [
                        {
                            "line": 44,
                            "code": "df = load_and_merge()"
                        }
                    ]
                },
                {
                    "summaryComponent": "Saves the merged and cleaned data to 'data/merged_data.csv'",
                    "codeSegments": [
                        {
                            "line": 45,
                            "code": "df.to_csv(\"data/merged_data.csv\", index=False)"
                        }
                    ]
                },
                {
                    "summaryComponent": "Prints a confirmation message upon successful save",
                    "codeSegments": [
                        {
                            "line": 46,
                            "code": "print(\"Merged data saved to data/merged_data.csv\")"
                        }
                    ]
                }
            ],
            "summary": "• Defines a function to process MVP and season stats data\n  ◦ Reads MVP votes and season statistics from CSV files\n  ◦ Normalizes player names by stripping whitespace\n• Merges the two datasets on player name and year\n• Cleans the merged data\n  ◦ Drops unnecessary columns like 'Rk', 'Player', 'Pos', and 'Tm_y' if present\n  ◦ Attempts to convert object-type columns to floats where possible\n• Assigns an ordinal MVP rank within each year based on MVP points\n• When run as a script:\n  ◦ Calls the data processing function\n  ◦ Saves the merged and cleaned data to 'data/merged_data.csv'\n  ◦ Prints a confirmation message upon successful save",
            "code": "1: import pandas as pd\n2: \n3: \n4: def load_and_merge(mvp_path=\"data/mvp_votes.csv\", stats_path=\"data/season_stats.csv\"):\n5:     mvp_df = pd.read_csv(mvp_path)\n6:     stats_df = pd.read_csv(stats_path)\n7: \n8:     # Normalize names\n9:     mvp_df[\"Name\"] = mvp_df[\"Name\"].str.strip()\n10:     stats_df[\"Player\"] = stats_df[\"Player\"].str.strip()\n11: \n12:     # Merge on name + year\n13:     merged = pd.merge(\n14:         mvp_df,\n15:         stats_df,\n16:         left_on=[\"Name\", \"Year\"],\n17:         right_on=[\"Player\", \"Year\"],\n18:         how=\"left\",\n19:     )\n20: \n21:     # Drop unnecessary columns\n22:     drop_cols = [\"Rk\", \"Player\", \"Pos\", \"Tm_y\"]\n23:     merged.drop(\n24:         columns=[col for col in drop_cols if col in merged.columns], inplace=True\n25:     )\n26: \n27:     # Clean numeric columns\n28:     for col in merged.columns:\n29:         if merged[col].dtype == \"object\":\n30:             try:\n31:                 merged[col] = merged[col].astype(float)\n32:             except:\n33:                 pass\n34: \n35:     # Assign ordinal MVP rank (1 = MVP)\n36:     merged[\"Rank\"] = merged.groupby(\"Year\")[\"MVP_Points\"].rank(\n37:         ascending=False, method=\"first\"\n38:     )\n39: \n40:     return merged\n41: \n42: \n43: if __name__ == \"__main__\":\n44:     df = load_and_merge()\n45:     df.to_csv(\"data/merged_data.csv\", index=False)\n46:     print(\"Merged data saved to data/merged_data.csv\")\n47: "
        },
        "source": "backend",
        "timestamp": "2025-08-23 10:28:21.000",
        "event": "map_summary_code",
        "id": "3ohjPZ28t8vJb0HH0w12"
    },
    {
        "data": {
            "mapping": [
                {
                    "summaryComponent": "loads",
                    "codeSegments": [
                        {
                            "line": 5,
                            "code": "mvp_df = pd.read_csv(mvp_path)"
                        },
                        {
                            "line": 6,
                            "code": "stats_df = pd.read_csv(stats_path)"
                        }
                    ]
                },
                {
                    "summaryComponent": "merges",
                    "codeSegments": [
                        {
                            "line": 13,
                            "code": "merged = pd.merge("
                        },
                        {
                            "line": 14,
                            "code": "    mvp_df,"
                        },
                        {
                            "line": 15,
                            "code": "    stats_df,"
                        },
                        {
                            "line": 16,
                            "code": "    left_on=[\"Name\", \"Year\"],"
                        },
                        {
                            "line": 17,
                            "code": "    right_on=[\"Player\", \"Year\"],"
                        },
                        {
                            "line": 18,
                            "code": "    how=\"left\","
                        },
                        {
                            "line": 19,
                            "code": ")"
                        }
                    ]
                },
                {
                    "summaryComponent": "cleans",
                    "codeSegments": [
                        {
                            "line": 9,
                            "code": "mvp_df[\"Name\"] = mvp_df[\"Name\"].str.strip()"
                        },
                        {
                            "line": 10,
                            "code": "stats_df[\"Player\"] = stats_df[\"Player\"].str.strip()"
                        },
                        {
                            "line": 22,
                            "code": "drop_cols = [\"Rk\", \"Player\", \"Pos\", \"Tm_y\"]"
                        },
                        {
                            "line": 23,
                            "code": "merged.drop("
                        },
                        {
                            "line": 24,
                            "code": "    columns=[col for col in drop_cols if col in merged.columns], inplace=True"
                        },
                        {
                            "line": 25,
                            "code": ")"
                        },
                        {
                            "line": 28,
                            "code": "for col in merged.columns:"
                        },
                        {
                            "line": 29,
                            "code": "    if merged[col].dtype == \"object\":"
                        },
                        {
                            "line": 30,
                            "code": "        try:"
                        },
                        {
                            "line": 31,
                            "code": "            merged[col] = merged[col].astype(float)"
                        },
                        {
                            "line": 32,
                            "code": "        except:"
                        },
                        {
                            "line": 33,
                            "code": "            pass"
                        }
                    ]
                },
                {
                    "summaryComponent": "processes",
                    "codeSegments": [
                        {
                            "line": 36,
                            "code": "merged[\"Rank\"] = merged.groupby(\"Year\")[\"MVP_Points\"].rank("
                        },
                        {
                            "line": 37,
                            "code": "    ascending=False, method=\"first\""
                        },
                        {
                            "line": 38,
                            "code": ")"
                        }
                    ]
                },
                {
                    "summaryComponent": "MVP and season stats data",
                    "codeSegments": [
                        {
                            "line": 5,
                            "code": "mvp_df = pd.read_csv(mvp_path)"
                        },
                        {
                            "line": 6,
                            "code": "stats_df = pd.read_csv(stats_path)"
                        }
                    ]
                },
                {
                    "summaryComponent": "saves the result to a CSV file",
                    "codeSegments": [
                        {
                            "line": 45,
                            "code": "df.to_csv(\"data/merged_data.csv\", index=False)"
                        }
                    ]
                }
            ],
            "summary": "This code loads, merges, cleans, and processes MVP and season stats data, then saves the result to a CSV file.",
            "code": "1: import pandas as pd\n2: \n3: \n4: def load_and_merge(mvp_path=\"data/mvp_votes.csv\", stats_path=\"data/season_stats.csv\"):\n5:     mvp_df = pd.read_csv(mvp_path)\n6:     stats_df = pd.read_csv(stats_path)\n7: \n8:     # Normalize names\n9:     mvp_df[\"Name\"] = mvp_df[\"Name\"].str.strip()\n10:     stats_df[\"Player\"] = stats_df[\"Player\"].str.strip()\n11: \n12:     # Merge on name + year\n13:     merged = pd.merge(\n14:         mvp_df,\n15:         stats_df,\n16:         left_on=[\"Name\", \"Year\"],\n17:         right_on=[\"Player\", \"Year\"],\n18:         how=\"left\",\n19:     )\n20: \n21:     # Drop unnecessary columns\n22:     drop_cols = [\"Rk\", \"Player\", \"Pos\", \"Tm_y\"]\n23:     merged.drop(\n24:         columns=[col for col in drop_cols if col in merged.columns], inplace=True\n25:     )\n26: \n27:     # Clean numeric columns\n28:     for col in merged.columns:\n29:         if merged[col].dtype == \"object\":\n30:             try:\n31:                 merged[col] = merged[col].astype(float)\n32:             except:\n33:                 pass\n34: \n35:     # Assign ordinal MVP rank (1 = MVP)\n36:     merged[\"Rank\"] = merged.groupby(\"Year\")[\"MVP_Points\"].rank(\n37:         ascending=False, method=\"first\"\n38:     )\n39: \n40:     return merged\n41: \n42: \n43: if __name__ == \"__main__\":\n44:     df = load_and_merge()\n45:     df.to_csv(\"data/merged_data.csv\", index=False)\n46:     print(\"Merged data saved to data/merged_data.csv\")\n47: "
        },
        "source": "backend",
        "timestamp": "2025-08-23 10:28:21.000",
        "event": "map_summary_code",
        "id": "8f0ITw4LTmR3ON0VkDwZ"
    },
    {
        "data": {
            "before_section_id": "7b7cba0f-406c-4c39-a0a1-3c518d1de307",
            "after_section_id": "8db82967-cfa0-4d1a-a525-e4d0af3d7867"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:28:21.000",
        "event": "autotransit_section",
        "id": "sZrEW3V9GACN2LpCLxFv"
    },
    {
        "data": {
            "section_data": {
                "lines": [
                    1,
                    47
                ],
                "summaryData": {
                    "medium_unstructured": "The code defines a function to load MVP votes and season statistics from CSV files, normalize and merge them, clean up columns, and assign MVP ranks. The processed data is then saved to a new CSV file when the script is run directly.",
                    "low_structured": "• Loads MVP and season stats data from CSV files\n• Merges and cleans the data\n• Saves the processed data to a new CSV file",
                    "title": "Summary of load_and_merge Function and Main Block",
                    "medium_structured": "• Loads MVP and season stats data from specified CSV files\n• Normalizes player names for consistency\n• Merges datasets on player name and year\n• Cleans data by dropping unnecessary columns and converting numeric columns\n• Assigns ordinal MVP ranks and saves the merged data to a CSV file",
                    "high_unstructured": "This code defines a function that reads MVP votes and season statistics from separate CSV files, normalizes player names, and merges the datasets based on player name and year. It then removes unnecessary columns, attempts to convert object-type columns to numeric types where possible, and assigns an ordinal MVP rank within each year based on MVP points. When executed as a script, it saves the cleaned and merged dataset to a new CSV file and prints a confirmation message.",
                    "high_structured": "• Defines a function to process MVP and season stats data\n  ◦ Reads MVP votes and season statistics from CSV files\n  ◦ Normalizes player names by stripping whitespace\n• Merges the two datasets on player name and year\n• Cleans the merged data\n  ◦ Drops unnecessary columns like 'Rk', 'Player', 'Pos', and 'Tm_y' if present\n  ◦ Attempts to convert object-type columns to floats where possible\n• Assigns an ordinal MVP rank within each year based on MVP points\n• When run as a script:\n  ◦ Calls the data processing function\n  ◦ Saves the merged and cleaned data to 'data/merged_data.csv'\n  ◦ Prints a confirmation message upon successful save",
                    "low_unstructured": "This code loads, merges, cleans, and processes MVP and season stats data, then saves the result to a CSV file."
                },
                "editPromptStructured": null,
                "createdAt": 1755973701000,
                "metadata": {
                    "filename": "preprocess.py",
                    "id": "8db82967-cfa0-4d1a-a525-e4d0af3d7867",
                    "originalCode": "import pandas as pd\n\n\ndef load_and_merge(mvp_path=\"data/mvp_votes.csv\", stats_path=\"data/season_stats.csv\"):\n    mvp_df = pd.read_csv(mvp_path)\n    stats_df = pd.read_csv(stats_path)\n\n    # Normalize names\n    mvp_df[\"Name\"] = mvp_df[\"Name\"].str.strip()\n    stats_df[\"Player\"] = stats_df[\"Player\"].str.strip()\n\n    # Merge on name + year\n    merged = pd.merge(\n        mvp_df,\n        stats_df,\n        left_on=[\"Name\", \"Year\"],\n        right_on=[\"Player\", \"Year\"],\n        how=\"left\",\n    )\n\n    # Drop unnecessary columns\n    drop_cols = [\"Rk\", \"Player\", \"Pos\", \"Tm_y\"]\n    merged.drop(\n        columns=[col for col in drop_cols if col in merged.columns], inplace=True\n    )\n\n    # Clean numeric columns\n    for col in merged.columns:\n        if merged[col].dtype == \"object\":\n            try:\n                merged[col] = merged[col].astype(float)\n            except:\n                pass\n\n    # Assign ordinal MVP rank (1 = MVP)\n    merged[\"Rank\"] = merged.groupby(\"Year\")[\"MVP_Points\"].rank(\n        ascending=False, method=\"first\"\n    )\n\n    return merged\n\n\nif __name__ == \"__main__\":\n    df = load_and_merge()\n    df.to_csv(\"data/merged_data.csv\", index=False)\n    print(\"Merged data saved to data/merged_data.csv\")\n",
                    "fullPath": "/project/workspace/preprocess.py",
                    "offset": 0
                },
                "selectedStructured": "unstructured",
                "title": "Summary of load_and_merge Function and Main Block",
                "selectedDetailLevel": "medium",
                "summaryMappings": {
                    "medium_unstructured": [
                        {
                            "summaryComponent": "defines a function to load MVP votes and season statistics from CSV files",
                            "codeSegments": [
                                {
                                    "line": 4,
                                    "code": "def load_and_merge(mvp_path=\"data/mvp_votes.csv\", stats_path=\"data/season_stats.csv\"):"
                                },
                                {
                                    "line": 5,
                                    "code": "mvp_df = pd.read_csv(mvp_path)"
                                },
                                {
                                    "line": 6,
                                    "code": "stats_df = pd.read_csv(stats_path)"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "normalize and merge them",
                            "codeSegments": [
                                {
                                    "line": 9,
                                    "code": "mvp_df[\"Name\"] = mvp_df[\"Name\"].str.strip()"
                                },
                                {
                                    "line": 10,
                                    "code": "stats_df[\"Player\"] = stats_df[\"Player\"].str.strip()"
                                },
                                {
                                    "line": 13,
                                    "code": "merged = pd.merge("
                                },
                                {
                                    "line": 14,
                                    "code": "    mvp_df,"
                                },
                                {
                                    "line": 15,
                                    "code": "    stats_df,"
                                },
                                {
                                    "line": 16,
                                    "code": "    left_on=[\"Name\", \"Year\"],"
                                },
                                {
                                    "line": 17,
                                    "code": "    right_on=[\"Player\", \"Year\"],"
                                },
                                {
                                    "line": 18,
                                    "code": "    how=\"left\","
                                },
                                {
                                    "line": 19,
                                    "code": ")"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "clean up columns",
                            "codeSegments": [
                                {
                                    "line": 22,
                                    "code": "drop_cols = [\"Rk\", \"Player\", \"Pos\", \"Tm_y\"]"
                                },
                                {
                                    "line": 23,
                                    "code": "merged.drop("
                                },
                                {
                                    "line": 24,
                                    "code": "    columns=[col for col in drop_cols if col in merged.columns], inplace=True"
                                },
                                {
                                    "line": 25,
                                    "code": ")"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "assign MVP ranks",
                            "codeSegments": [
                                {
                                    "line": 36,
                                    "code": "merged[\"Rank\"] = merged.groupby(\"Year\")[\"MVP_Points\"].rank("
                                },
                                {
                                    "line": 37,
                                    "code": "    ascending=False, method=\"first\""
                                },
                                {
                                    "line": 38,
                                    "code": ")"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "The processed data is then saved to a new CSV file when the script is run directly.",
                            "codeSegments": [
                                {
                                    "line": 43,
                                    "code": "if __name__ == \"__main__\":"
                                },
                                {
                                    "line": 44,
                                    "code": "df = load_and_merge()"
                                },
                                {
                                    "line": 45,
                                    "code": "df.to_csv(\"data/merged_data.csv\", index=False)"
                                }
                            ]
                        }
                    ],
                    "low_structured": [
                        {
                            "summaryComponent": "Loads MVP and season stats data from CSV files",
                            "codeSegments": [
                                {
                                    "line": 5,
                                    "code": "mvp_df = pd.read_csv(mvp_path)"
                                },
                                {
                                    "line": 6,
                                    "code": "stats_df = pd.read_csv(stats_path)"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "Merges and cleans the data",
                            "codeSegments": [
                                {
                                    "line": 13,
                                    "code": "merged = pd.merge("
                                },
                                {
                                    "line": 22,
                                    "code": "drop_cols = [\"Rk\", \"Player\", \"Pos\", \"Tm_y\"]"
                                },
                                {
                                    "line": 23,
                                    "code": "merged.drop("
                                },
                                {
                                    "line": 28,
                                    "code": "for col in merged.columns:"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "Saves the processed data to a new CSV file",
                            "codeSegments": [
                                {
                                    "line": 45,
                                    "code": "df.to_csv(\"data/merged_data.csv\", index=False)"
                                }
                            ]
                        }
                    ],
                    "low_unstructured": [
                        {
                            "summaryComponent": "loads",
                            "codeSegments": [
                                {
                                    "line": 5,
                                    "code": "mvp_df = pd.read_csv(mvp_path)"
                                },
                                {
                                    "line": 6,
                                    "code": "stats_df = pd.read_csv(stats_path)"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "merges",
                            "codeSegments": [
                                {
                                    "line": 13,
                                    "code": "merged = pd.merge("
                                },
                                {
                                    "line": 14,
                                    "code": "    mvp_df,"
                                },
                                {
                                    "line": 15,
                                    "code": "    stats_df,"
                                },
                                {
                                    "line": 16,
                                    "code": "    left_on=[\"Name\", \"Year\"],"
                                },
                                {
                                    "line": 17,
                                    "code": "    right_on=[\"Player\", \"Year\"],"
                                },
                                {
                                    "line": 18,
                                    "code": "    how=\"left\","
                                },
                                {
                                    "line": 19,
                                    "code": ")"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "cleans",
                            "codeSegments": [
                                {
                                    "line": 9,
                                    "code": "mvp_df[\"Name\"] = mvp_df[\"Name\"].str.strip()"
                                },
                                {
                                    "line": 10,
                                    "code": "stats_df[\"Player\"] = stats_df[\"Player\"].str.strip()"
                                },
                                {
                                    "line": 22,
                                    "code": "drop_cols = [\"Rk\", \"Player\", \"Pos\", \"Tm_y\"]"
                                },
                                {
                                    "line": 23,
                                    "code": "merged.drop("
                                },
                                {
                                    "line": 24,
                                    "code": "    columns=[col for col in drop_cols if col in merged.columns], inplace=True"
                                },
                                {
                                    "line": 25,
                                    "code": ")"
                                },
                                {
                                    "line": 28,
                                    "code": "for col in merged.columns:"
                                },
                                {
                                    "line": 29,
                                    "code": "    if merged[col].dtype == \"object\":"
                                },
                                {
                                    "line": 30,
                                    "code": "        try:"
                                },
                                {
                                    "line": 31,
                                    "code": "            merged[col] = merged[col].astype(float)"
                                },
                                {
                                    "line": 32,
                                    "code": "        except:"
                                },
                                {
                                    "line": 33,
                                    "code": "            pass"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "processes",
                            "codeSegments": [
                                {
                                    "line": 36,
                                    "code": "merged[\"Rank\"] = merged.groupby(\"Year\")[\"MVP_Points\"].rank("
                                },
                                {
                                    "line": 37,
                                    "code": "    ascending=False, method=\"first\""
                                },
                                {
                                    "line": 38,
                                    "code": ")"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "MVP and season stats data",
                            "codeSegments": [
                                {
                                    "line": 5,
                                    "code": "mvp_df = pd.read_csv(mvp_path)"
                                },
                                {
                                    "line": 6,
                                    "code": "stats_df = pd.read_csv(stats_path)"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "saves the result to a CSV file",
                            "codeSegments": [
                                {
                                    "line": 45,
                                    "code": "df.to_csv(\"data/merged_data.csv\", index=False)"
                                }
                            ]
                        }
                    ],
                    "medium_structured": [
                        {
                            "summaryComponent": "Loads MVP and season stats data from specified CSV files",
                            "codeSegments": [
                                {
                                    "line": 5,
                                    "code": "mvp_df = pd.read_csv(mvp_path)"
                                },
                                {
                                    "line": 6,
                                    "code": "stats_df = pd.read_csv(stats_path)"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "Normalizes player names for consistency",
                            "codeSegments": [
                                {
                                    "line": 9,
                                    "code": "mvp_df[\"Name\"] = mvp_df[\"Name\"].str.strip()"
                                },
                                {
                                    "line": 10,
                                    "code": "stats_df[\"Player\"] = stats_df[\"Player\"].str.strip()"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "Merges datasets on player name and year",
                            "codeSegments": [
                                {
                                    "line": 13,
                                    "code": "merged = pd.merge("
                                },
                                {
                                    "line": 16,
                                    "code": "left_on=[\"Name\", \"Year\"],"
                                },
                                {
                                    "line": 17,
                                    "code": "right_on=[\"Player\", \"Year\"],"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "Cleans data by dropping unnecessary columns and converting numeric columns",
                            "codeSegments": [
                                {
                                    "line": 22,
                                    "code": "drop_cols = [\"Rk\", \"Player\", \"Pos\", \"Tm_y\"]"
                                },
                                {
                                    "line": 23,
                                    "code": "merged.drop("
                                },
                                {
                                    "line": 28,
                                    "code": "for col in merged.columns:"
                                },
                                {
                                    "line": 29,
                                    "code": "if merged[col].dtype == \"object\":"
                                },
                                {
                                    "line": 31,
                                    "code": "merged[col] = merged[col].astype(float)"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "Assigns ordinal MVP ranks and saves the merged data to a CSV file",
                            "codeSegments": [
                                {
                                    "line": 36,
                                    "code": "merged[\"Rank\"] = merged.groupby(\"Year\")[\"MVP_Points\"].rank("
                                },
                                {
                                    "line": 44,
                                    "code": "df = load_and_merge()"
                                },
                                {
                                    "line": 45,
                                    "code": "df.to_csv(\"data/merged_data.csv\", index=False)"
                                }
                            ]
                        }
                    ],
                    "high_unstructured": [
                        {
                            "summaryComponent": "defines a function that reads MVP votes and season statistics from separate CSV files",
                            "codeSegments": [
                                {
                                    "line": 4,
                                    "code": "def load_and_merge(mvp_path=\"data/mvp_votes.csv\", stats_path=\"data/season_stats.csv\"):"
                                },
                                {
                                    "line": 5,
                                    "code": "mvp_df = pd.read_csv(mvp_path)"
                                },
                                {
                                    "line": 6,
                                    "code": "stats_df = pd.read_csv(stats_path)"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "normalizes player names",
                            "codeSegments": [
                                {
                                    "line": 9,
                                    "code": "mvp_df[\"Name\"] = mvp_df[\"Name\"].str.strip()"
                                },
                                {
                                    "line": 10,
                                    "code": "stats_df[\"Player\"] = stats_df[\"Player\"].str.strip()"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "merges the datasets based on player name and year",
                            "codeSegments": [
                                {
                                    "line": 13,
                                    "code": "merged = pd.merge("
                                },
                                {
                                    "line": 16,
                                    "code": "left_on=[\"Name\", \"Year\"],"
                                },
                                {
                                    "line": 17,
                                    "code": "right_on=[\"Player\", \"Year\"],"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "removes unnecessary columns",
                            "codeSegments": [
                                {
                                    "line": 22,
                                    "code": "drop_cols = [\"Rk\", \"Player\", \"Pos\", \"Tm_y\"]"
                                },
                                {
                                    "line": 23,
                                    "code": "merged.drop("
                                }
                            ]
                        },
                        {
                            "summaryComponent": "attempts to convert object-type columns to numeric types where possible",
                            "codeSegments": [
                                {
                                    "line": 28,
                                    "code": "for col in merged.columns:"
                                },
                                {
                                    "line": 29,
                                    "code": "if merged[col].dtype == \"object\":"
                                },
                                {
                                    "line": 31,
                                    "code": "merged[col] = merged[col].astype(float)"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "assigns an ordinal MVP rank within each year based on MVP points",
                            "codeSegments": [
                                {
                                    "line": 36,
                                    "code": "merged[\"Rank\"] = merged.groupby(\"Year\")[\"MVP_Points\"].rank("
                                }
                            ]
                        },
                        {
                            "summaryComponent": "When executed as a script",
                            "codeSegments": [
                                {
                                    "line": 43,
                                    "code": "if __name__ == \"__main__\":"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "saves the cleaned and merged dataset to a new CSV file",
                            "codeSegments": [
                                {
                                    "line": 45,
                                    "code": "df.to_csv(\"data/merged_data.csv\", index=False)"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "prints a confirmation message",
                            "codeSegments": [
                                {
                                    "line": 46,
                                    "code": "print(\"Merged data saved to data/merged_data.csv\")"
                                }
                            ]
                        }
                    ],
                    "high_structured": [
                        {
                            "summaryComponent": "Defines a function to process MVP and season stats data",
                            "codeSegments": [
                                {
                                    "line": 4,
                                    "code": "def load_and_merge(mvp_path=\"data/mvp_votes.csv\", stats_path=\"data/season_stats.csv\"):"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "Reads MVP votes and season statistics from CSV files",
                            "codeSegments": [
                                {
                                    "line": 5,
                                    "code": "mvp_df = pd.read_csv(mvp_path)"
                                },
                                {
                                    "line": 6,
                                    "code": "stats_df = pd.read_csv(stats_path)"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "Normalizes player names by stripping whitespace",
                            "codeSegments": [
                                {
                                    "line": 9,
                                    "code": "mvp_df[\"Name\"] = mvp_df[\"Name\"].str.strip()"
                                },
                                {
                                    "line": 10,
                                    "code": "stats_df[\"Player\"] = stats_df[\"Player\"].str.strip()"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "Merges the two datasets on player name and year",
                            "codeSegments": [
                                {
                                    "line": 13,
                                    "code": "merged = pd.merge("
                                },
                                {
                                    "line": 16,
                                    "code": "left_on=[\"Name\", \"Year\"],"
                                },
                                {
                                    "line": 17,
                                    "code": "right_on=[\"Player\", \"Year\"],"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "Cleans the merged data",
                            "codeSegments": [
                                {
                                    "line": 21,
                                    "code": "# Drop unnecessary columns"
                                },
                                {
                                    "line": 27,
                                    "code": "# Clean numeric columns"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "Drops unnecessary columns like 'Rk', 'Player', 'Pos', and 'Tm_y' if present",
                            "codeSegments": [
                                {
                                    "line": 22,
                                    "code": "drop_cols = [\"Rk\", \"Player\", \"Pos\", \"Tm_y\"]"
                                },
                                {
                                    "line": 23,
                                    "code": "merged.drop("
                                }
                            ]
                        },
                        {
                            "summaryComponent": "Attempts to convert object-type columns to floats where possible",
                            "codeSegments": [
                                {
                                    "line": 28,
                                    "code": "for col in merged.columns:"
                                },
                                {
                                    "line": 29,
                                    "code": "if merged[col].dtype == \"object\":"
                                },
                                {
                                    "line": 31,
                                    "code": "merged[col] = merged[col].astype(float)"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "Assigns an ordinal MVP rank within each year based on MVP points",
                            "codeSegments": [
                                {
                                    "line": 36,
                                    "code": "merged[\"Rank\"] = merged.groupby(\"Year\")[\"MVP_Points\"].rank("
                                }
                            ]
                        },
                        {
                            "summaryComponent": "Calls the data processing function",
                            "codeSegments": [
                                {
                                    "line": 44,
                                    "code": "df = load_and_merge()"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "Saves the merged and cleaned data to 'data/merged_data.csv'",
                            "codeSegments": [
                                {
                                    "line": 45,
                                    "code": "df.to_csv(\"data/merged_data.csv\", index=False)"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "Prints a confirmation message upon successful save",
                            "codeSegments": [
                                {
                                    "line": 46,
                                    "code": "print(\"Merged data saved to data/merged_data.csv\")"
                                }
                            ]
                        }
                    ]
                },
                "editPromptValue": "",
                "editPromptDetailLevel": null
            },
            "section_id": "8db82967-cfa0-4d1a-a525-e4d0af3d7867"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:28:21.000",
        "event": "create_new_section",
        "id": "zwW12JRu6s0kQOf1qD3u"
    },
    {
        "data": {
            "mapping_index": 1,
            "structured_type": "unstructured",
            "section_id": "8db82967-cfa0-4d1a-a525-e4d0af3d7867",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:28:57.000",
        "event": "mapping_hover",
        "id": "ooKhJUhll0pi46ywKYEo"
    },
    {
        "data": {
            "structured_type": "unstructured",
            "section_id": "8db82967-cfa0-4d1a-a525-e4d0af3d7867",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:28:58.000",
        "event": "mapping_unhover",
        "id": "K6uP0OiEWsHvNhCE0xcr"
    },
    {
        "data": {
            "mapping_index": 2,
            "structured_type": "unstructured",
            "section_id": "8db82967-cfa0-4d1a-a525-e4d0af3d7867",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:28:58.000",
        "event": "mapping_hover",
        "id": "Z4fE9a7oVRz6HK8KANtw"
    },
    {
        "data": {
            "structured_type": "unstructured",
            "section_id": "8db82967-cfa0-4d1a-a525-e4d0af3d7867",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:28:58.000",
        "event": "mapping_unhover",
        "id": "wtK76LZAl0O4nBEctsoB"
    },
    {
        "data": {
            "structured_type": "unstructured",
            "section_id": "8db82967-cfa0-4d1a-a525-e4d0af3d7867",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:28:59.000",
        "event": "mapping_unhover",
        "id": "KioRuHCj64M7am3obgS0"
    },
    {
        "data": {
            "mapping_index": 0,
            "structured_type": "unstructured",
            "section_id": "8db82967-cfa0-4d1a-a525-e4d0af3d7867",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:28:59.000",
        "event": "mapping_hover",
        "id": "XywPNgv1eQJmA14IkLjw"
    },
    {
        "data": {
            "mapping_index": 0,
            "structured_type": "unstructured",
            "section_id": "8db82967-cfa0-4d1a-a525-e4d0af3d7867",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:29:12.000",
        "event": "mapping_hover",
        "id": "DzPD2n1s8LWRBPthWGTz"
    },
    {
        "data": {
            "structured_type": "unstructured",
            "section_id": "8db82967-cfa0-4d1a-a525-e4d0af3d7867",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:29:13.000",
        "event": "mapping_unhover",
        "id": "1uqYhQyjPaipgvSOLsI3"
    },
    {
        "data": {
            "mapping_index": 3,
            "structured_type": "unstructured",
            "section_id": "8db82967-cfa0-4d1a-a525-e4d0af3d7867",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:29:13.000",
        "event": "mapping_hover",
        "id": "DhT5l3YFzWW7WBFXGEwG"
    },
    {
        "data": {
            "mapping_index": 1,
            "structured_type": "unstructured",
            "section_id": "8db82967-cfa0-4d1a-a525-e4d0af3d7867",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:29:13.000",
        "event": "mapping_hover",
        "id": "v4cFcHS5wpCogZZ2bjw6"
    },
    {
        "data": {
            "structured_type": "unstructured",
            "section_id": "8db82967-cfa0-4d1a-a525-e4d0af3d7867",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:29:13.000",
        "event": "mapping_unhover",
        "id": "zDtBfxLsuB79II94ZVyb"
    },
    {
        "data": {
            "structured_type": "unstructured",
            "section_id": "8db82967-cfa0-4d1a-a525-e4d0af3d7867",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:29:15.000",
        "event": "mapping_unhover",
        "id": "2hmqIBniAUSki3OMYalw"
    },
    {
        "data": {
            "mapping_index": 1,
            "structured_type": "unstructured",
            "section_id": "8db82967-cfa0-4d1a-a525-e4d0af3d7867",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:29:15.000",
        "event": "mapping_hover",
        "id": "E2zTPiES9jiPDB8LFl9i"
    },
    {
        "data": {
            "structured_type": "unstructured",
            "section_id": "8db82967-cfa0-4d1a-a525-e4d0af3d7867",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:29:15.000",
        "event": "mapping_unhover",
        "id": "PeMkuGrAZZYMq2DxyLoD"
    },
    {
        "data": {
            "mapping_index": 3,
            "structured_type": "unstructured",
            "section_id": "8db82967-cfa0-4d1a-a525-e4d0af3d7867",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:29:15.000",
        "event": "mapping_hover",
        "id": "QRtjCKtG2rFv4NdNbDWx"
    },
    {
        "data": {
            "mapping_index": 2,
            "structured_type": "unstructured",
            "section_id": "8db82967-cfa0-4d1a-a525-e4d0af3d7867",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:29:15.000",
        "event": "mapping_hover",
        "id": "mPmFvX61EFsk3LzeuqFC"
    },
    {
        "data": {
            "structured_type": "unstructured",
            "section_id": "8db82967-cfa0-4d1a-a525-e4d0af3d7867",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:29:15.000",
        "event": "mapping_unhover",
        "id": "y46eXHz8mQ64YyeYffTe"
    },
    {
        "data": {
            "structured_type": "unstructured",
            "section_id": "8db82967-cfa0-4d1a-a525-e4d0af3d7867",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:29:16.000",
        "event": "mapping_unhover",
        "id": "AR28VqRC0FCwYt9VuaDi"
    },
    {
        "data": {
            "structured_type": "unstructured",
            "section_id": "8db82967-cfa0-4d1a-a525-e4d0af3d7867",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:29:16.000",
        "event": "mapping_unhover",
        "id": "DCDAUua0l2ISFpwWUZTZ"
    },
    {
        "data": {
            "structured_type": "unstructured",
            "section_id": "8db82967-cfa0-4d1a-a525-e4d0af3d7867",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:29:16.000",
        "event": "mapping_unhover",
        "id": "YDIN7ytqD3fiMsttZhlj"
    },
    {
        "data": {
            "mapping_index": 3,
            "structured_type": "unstructured",
            "section_id": "8db82967-cfa0-4d1a-a525-e4d0af3d7867",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:29:16.000",
        "event": "mapping_hover",
        "id": "axDvP5cbOnZnc3aRgsml"
    },
    {
        "data": {
            "mapping_index": 2,
            "structured_type": "unstructured",
            "section_id": "8db82967-cfa0-4d1a-a525-e4d0af3d7867",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:29:16.000",
        "event": "mapping_hover",
        "id": "rOtlCynud8bMQCMh9QdA"
    },
    {
        "data": {
            "mapping_index": 1,
            "structured_type": "unstructured",
            "section_id": "8db82967-cfa0-4d1a-a525-e4d0af3d7867",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:29:17.000",
        "event": "mapping_hover",
        "id": "uSSaO09yvSxQzFE6SNs4"
    },
    {
        "data": {
            "mapping_index": 3,
            "structured_type": "unstructured",
            "section_id": "8db82967-cfa0-4d1a-a525-e4d0af3d7867",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:29:18.000",
        "event": "mapping_hover",
        "id": "5Ohrryzzo2VeJYXMmu1s"
    },
    {
        "data": {
            "structured_type": "unstructured",
            "section_id": "8db82967-cfa0-4d1a-a525-e4d0af3d7867",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:29:18.000",
        "event": "mapping_unhover",
        "id": "FfFismE6lIjAIJvR4CO8"
    },
    {
        "data": {
            "structured_type": "unstructured",
            "section_id": "8db82967-cfa0-4d1a-a525-e4d0af3d7867",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:29:18.000",
        "event": "mapping_unhover",
        "id": "kL8XqvV8SabCbPLvGAPm"
    },
    {
        "data": {
            "mapping_index": 2,
            "structured_type": "unstructured",
            "section_id": "8db82967-cfa0-4d1a-a525-e4d0af3d7867",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:29:18.000",
        "event": "mapping_hover",
        "id": "oe5Sdkfj6lddSVFGxu37"
    },
    {
        "data": {
            "structured_type": "unstructured",
            "section_id": "8db82967-cfa0-4d1a-a525-e4d0af3d7867",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:29:18.000",
        "event": "mapping_unhover",
        "id": "qAgngrWUvFDgG4jwvIzd"
    },
    {
        "data": {
            "mapping_index": 2,
            "structured_type": "unstructured",
            "section_id": "8db82967-cfa0-4d1a-a525-e4d0af3d7867",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:29:18.000",
        "event": "mapping_hover",
        "id": "z5oWRR739hNPADBpHwxK"
    },
    {
        "data": {
            "structured_type": "unstructured",
            "section_id": "8db82967-cfa0-4d1a-a525-e4d0af3d7867",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:29:19.000",
        "event": "mapping_unhover",
        "id": "3nueADY14US8n3zWFr0m"
    },
    {
        "data": {
            "mapping_index": 1,
            "structured_type": "unstructured",
            "section_id": "8db82967-cfa0-4d1a-a525-e4d0af3d7867",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:29:19.000",
        "event": "mapping_hover",
        "id": "IJgOsQHT67L2R4fCcS3B"
    },
    {
        "data": {
            "structured_type": "unstructured",
            "section_id": "8db82967-cfa0-4d1a-a525-e4d0af3d7867",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:29:19.000",
        "event": "mapping_unhover",
        "id": "L24etZm6RJlCaKOi9PtI"
    },
    {
        "data": {
            "mapping_index": 0,
            "structured_type": "unstructured",
            "section_id": "8db82967-cfa0-4d1a-a525-e4d0af3d7867",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:29:19.000",
        "event": "mapping_hover",
        "id": "k93MksoRqI9WEswqY8Ca"
    },
    {
        "data": {
            "mapping_index": 4,
            "structured_type": "unstructured",
            "section_id": "8db82967-cfa0-4d1a-a525-e4d0af3d7867",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:29:20.000",
        "event": "mapping_hover",
        "id": "8B3qHCOBCXcJf4ixNoiO"
    },
    {
        "data": {
            "mapping_index": 2,
            "structured_type": "unstructured",
            "section_id": "8db82967-cfa0-4d1a-a525-e4d0af3d7867",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:29:20.000",
        "event": "mapping_hover",
        "id": "AULtCCEIvvhtOUZGyYhu"
    },
    {
        "data": {
            "structured_type": "unstructured",
            "section_id": "8db82967-cfa0-4d1a-a525-e4d0af3d7867",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:29:20.000",
        "event": "mapping_unhover",
        "id": "Pa56MWNiFQlqDCxvGIvg"
    },
    {
        "data": {
            "structured_type": "unstructured",
            "section_id": "8db82967-cfa0-4d1a-a525-e4d0af3d7867",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:29:20.000",
        "event": "mapping_unhover",
        "id": "TMnsRwLWqu0nJDhyib38"
    },
    {
        "data": {
            "structured_type": "unstructured",
            "section_id": "8db82967-cfa0-4d1a-a525-e4d0af3d7867",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:29:20.000",
        "event": "mapping_unhover",
        "id": "cKPBEVEdcU56Q15jDxOh"
    },
    {
        "data": {
            "mapping_index": 3,
            "structured_type": "unstructured",
            "section_id": "8db82967-cfa0-4d1a-a525-e4d0af3d7867",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:29:20.000",
        "event": "mapping_hover",
        "id": "jmlufiz7WZJXjIaD7b8I"
    },
    {
        "data": {
            "mapping_index": 2,
            "structured_type": "unstructured",
            "section_id": "8db82967-cfa0-4d1a-a525-e4d0af3d7867",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:29:22.000",
        "event": "mapping_hover",
        "id": "yElQfH5bwzoc2jcN4wxF"
    },
    {
        "data": {
            "structured_type": "unstructured",
            "section_id": "8db82967-cfa0-4d1a-a525-e4d0af3d7867",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:29:22.000",
        "event": "mapping_unhover",
        "id": "yfF9QA2OIf7rkvkQsuTi"
    },
    {
        "data": {
            "structured_type": "unstructured",
            "section_id": "8db82967-cfa0-4d1a-a525-e4d0af3d7867",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:29:22.000",
        "event": "mapping_unhover",
        "id": "zyo5iMXuRj1N4UPzfGj6"
    },
    {
        "data": {
            "mapping_index": 1,
            "structured_type": "unstructured",
            "section_id": "8db82967-cfa0-4d1a-a525-e4d0af3d7867",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:29:23.000",
        "event": "mapping_hover",
        "id": "13TegqiCYETlWWZ8uFU1"
    },
    {
        "data": {
            "structured_type": "unstructured",
            "section_id": "8db82967-cfa0-4d1a-a525-e4d0af3d7867",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:29:24.000",
        "event": "mapping_unhover",
        "id": "5gYxFlffAspgYzrAC6Og"
    },
    {
        "data": {
            "before_detail_level": "medium",
            "after_detail_level": "medium",
            "before_structured": "unstructured",
            "section_id": "8db82967-cfa0-4d1a-a525-e4d0af3d7867",
            "after_structured": "structured"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:29:26.000",
        "event": "change_summary_level",
        "id": "2tlrbdSOpc42nE7o5Enk"
    },
    {
        "data": {
            "mapping_index": 2,
            "structured_type": "structured",
            "section_id": "8db82967-cfa0-4d1a-a525-e4d0af3d7867",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:29:27.000",
        "event": "mapping_hover",
        "id": "03aAOFzrfbhXH32YSAiQ"
    },
    {
        "data": {
            "mapping_index": 1,
            "structured_type": "structured",
            "section_id": "8db82967-cfa0-4d1a-a525-e4d0af3d7867",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:29:27.000",
        "event": "mapping_hover",
        "id": "HCPcAjPcgzqRBLpG7QzZ"
    },
    {
        "data": {
            "mapping_index": 3,
            "structured_type": "structured",
            "section_id": "8db82967-cfa0-4d1a-a525-e4d0af3d7867",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:29:27.000",
        "event": "mapping_hover",
        "id": "JuwYKoinjjdprQhidVb2"
    },
    {
        "data": {
            "structured_type": "structured",
            "section_id": "8db82967-cfa0-4d1a-a525-e4d0af3d7867",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:29:27.000",
        "event": "mapping_unhover",
        "id": "PVqOeT35vWuhsAZGTmrw"
    },
    {
        "data": {
            "structured_type": "structured",
            "section_id": "8db82967-cfa0-4d1a-a525-e4d0af3d7867",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:29:27.000",
        "event": "mapping_unhover",
        "id": "UV7zZPqK8e170aXuoQRa"
    },
    {
        "data": {
            "structured_type": "structured",
            "section_id": "8db82967-cfa0-4d1a-a525-e4d0af3d7867",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:29:27.000",
        "event": "mapping_unhover",
        "id": "WdVorHUxWpbDciGAiZAU"
    },
    {
        "data": {
            "mapping_index": 1,
            "structured_type": "structured",
            "section_id": "8db82967-cfa0-4d1a-a525-e4d0af3d7867",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:29:29.000",
        "event": "mapping_hover",
        "id": "0C5ZpF74se2cmKgCcSRn"
    },
    {
        "data": {
            "mapping_index": 1,
            "structured_type": "structured",
            "section_id": "8db82967-cfa0-4d1a-a525-e4d0af3d7867",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:29:30.000",
        "event": "mapping_hover",
        "id": "0rE9IiCgWWlb8u2AfMWr"
    },
    {
        "data": {
            "mapping_index": 0,
            "structured_type": "structured",
            "section_id": "8db82967-cfa0-4d1a-a525-e4d0af3d7867",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:29:30.000",
        "event": "mapping_hover",
        "id": "HiQeghsciibrNyQXQEn9"
    },
    {
        "data": {
            "structured_type": "structured",
            "section_id": "8db82967-cfa0-4d1a-a525-e4d0af3d7867",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:29:30.000",
        "event": "mapping_unhover",
        "id": "Rzi8jIKzZurTRPWluQ5J"
    },
    {
        "data": {
            "structured_type": "structured",
            "section_id": "8db82967-cfa0-4d1a-a525-e4d0af3d7867",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:29:30.000",
        "event": "mapping_unhover",
        "id": "cxxc3UUzxJaz717as2Nn"
    },
    {
        "data": {
            "structured_type": "structured",
            "section_id": "8db82967-cfa0-4d1a-a525-e4d0af3d7867",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:29:30.000",
        "event": "mapping_unhover",
        "id": "flDTCTkVN9hdN942JxKY"
    },
    {
        "data": {
            "mapping_index": 2,
            "structured_type": "structured",
            "section_id": "8db82967-cfa0-4d1a-a525-e4d0af3d7867",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:29:30.000",
        "event": "mapping_hover",
        "id": "oXdpNTo2RxQvsnNx9F9w"
    },
    {
        "data": {
            "structured_type": "structured",
            "section_id": "8db82967-cfa0-4d1a-a525-e4d0af3d7867",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:29:30.000",
        "event": "mapping_unhover",
        "id": "wA4I4J59pN9wFKsp118L"
    },
    {
        "data": {
            "mapping_index": 0,
            "structured_type": "structured",
            "section_id": "8db82967-cfa0-4d1a-a525-e4d0af3d7867",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:29:31.000",
        "event": "mapping_hover",
        "id": "vKKKr4zAIWy8wQj4NZ3q"
    },
    {
        "data": {
            "structured_type": "structured",
            "section_id": "8db82967-cfa0-4d1a-a525-e4d0af3d7867",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:29:32.000",
        "event": "mapping_unhover",
        "id": "MVWmD0e8o5sRseZt6F6Q"
    },
    {
        "data": {
            "mapping_index": 0,
            "structured_type": "structured",
            "section_id": "8db82967-cfa0-4d1a-a525-e4d0af3d7867",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:29:33.000",
        "event": "mapping_hover",
        "id": "NSce8QAy5gVaYtmfPrIU"
    },
    {
        "data": {
            "mapping_index": 1,
            "structured_type": "structured",
            "section_id": "8db82967-cfa0-4d1a-a525-e4d0af3d7867",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:29:33.000",
        "event": "mapping_hover",
        "id": "a9oszOHkAih1jziTQHde"
    },
    {
        "data": {
            "structured_type": "structured",
            "section_id": "8db82967-cfa0-4d1a-a525-e4d0af3d7867",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:29:33.000",
        "event": "mapping_unhover",
        "id": "hveEDqdYm3qL98RZaoU8"
    },
    {
        "data": {
            "structured_type": "structured",
            "section_id": "8db82967-cfa0-4d1a-a525-e4d0af3d7867",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:29:34.000",
        "event": "mapping_unhover",
        "id": "5MwOQBT6P5KWhjrWb2Tj"
    },
    {
        "data": {
            "mapping_index": 2,
            "structured_type": "structured",
            "section_id": "8db82967-cfa0-4d1a-a525-e4d0af3d7867",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:29:34.000",
        "event": "mapping_hover",
        "id": "8sMWr0pTxUYPflV2mV3W"
    },
    {
        "data": {
            "structured_type": "structured",
            "section_id": "8db82967-cfa0-4d1a-a525-e4d0af3d7867",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:29:35.000",
        "event": "mapping_unhover",
        "id": "DZEazuLu0NG6djnwYZ4G"
    },
    {
        "data": {
            "mapping_index": 3,
            "structured_type": "structured",
            "section_id": "8db82967-cfa0-4d1a-a525-e4d0af3d7867",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:29:36.000",
        "event": "mapping_hover",
        "id": "iaoKxiZxOa3Ku2KVaXKl"
    },
    {
        "data": {
            "mapping_index": 2,
            "structured_type": "structured",
            "section_id": "8db82967-cfa0-4d1a-a525-e4d0af3d7867",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:29:36.000",
        "event": "mapping_hover",
        "id": "rDtr7BGS9JmJMPruhVZO"
    },
    {
        "data": {
            "structured_type": "structured",
            "section_id": "8db82967-cfa0-4d1a-a525-e4d0af3d7867",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:29:36.000",
        "event": "mapping_unhover",
        "id": "vTHS98HkWB4mb8tilypU"
    },
    {
        "data": {
            "structured_type": "structured",
            "section_id": "8db82967-cfa0-4d1a-a525-e4d0af3d7867",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:29:38.000",
        "event": "mapping_unhover",
        "id": "hQhRtUOwNoCTeWdBydld"
    },
    {
        "data": {
            "structured_type": "structured",
            "section_id": "8db82967-cfa0-4d1a-a525-e4d0af3d7867",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:29:39.000",
        "event": "mapping_unhover",
        "id": "Ei48Rm6KCJ9KRsdx4Frs"
    },
    {
        "data": {
            "mapping_index": 4,
            "structured_type": "structured",
            "section_id": "8db82967-cfa0-4d1a-a525-e4d0af3d7867",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:29:39.000",
        "event": "mapping_hover",
        "id": "d89ejfwiGfUjLzXtbls4"
    },
    {
        "data": {
            "mapping_index": 3,
            "structured_type": "structured",
            "section_id": "8db82967-cfa0-4d1a-a525-e4d0af3d7867",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:29:39.000",
        "event": "mapping_hover",
        "id": "rc8Ew0zQfZ6z8PFJylKm"
    },
    {
        "data": {
            "structured_type": "structured",
            "section_id": "8db82967-cfa0-4d1a-a525-e4d0af3d7867",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:29:40.000",
        "event": "mapping_unhover",
        "id": "XxSoffbP5XMLEIMEwTD9"
    },
    {
        "data": {
            "mapping_index": 4,
            "structured_type": "structured",
            "section_id": "8db82967-cfa0-4d1a-a525-e4d0af3d7867",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:29:41.000",
        "event": "mapping_hover",
        "id": "Bif3vpJ7IEISTAGJaxmL"
    },
    {
        "data": {
            "mapping_index": 3,
            "structured_type": "structured",
            "section_id": "8db82967-cfa0-4d1a-a525-e4d0af3d7867",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:29:41.000",
        "event": "mapping_hover",
        "id": "eVUViqQ3rRKb3G41rYWW"
    },
    {
        "data": {
            "structured_type": "structured",
            "section_id": "8db82967-cfa0-4d1a-a525-e4d0af3d7867",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:29:41.000",
        "event": "mapping_unhover",
        "id": "li52AIjebXbrKHYtHMH1"
    },
    {
        "data": {
            "structured_type": "structured",
            "section_id": "8db82967-cfa0-4d1a-a525-e4d0af3d7867",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:29:42.000",
        "event": "mapping_unhover",
        "id": "lNcT1zeiEu3myRlNcMuz"
    },
    {
        "data": {
            "structured_type": "structured",
            "section_id": "8db82967-cfa0-4d1a-a525-e4d0af3d7867",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:29:43.000",
        "event": "mapping_unhover",
        "id": "NQlbnl71v9pIkUDITZ4C"
    },
    {
        "data": {
            "mapping_index": 4,
            "structured_type": "structured",
            "section_id": "8db82967-cfa0-4d1a-a525-e4d0af3d7867",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:29:43.000",
        "event": "mapping_hover",
        "id": "QIgrDQZcVNeXEBRNL4WT"
    },
    {
        "data": {
            "mapping_index": 3,
            "structured_type": "structured",
            "section_id": "8db82967-cfa0-4d1a-a525-e4d0af3d7867",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:29:43.000",
        "event": "mapping_hover",
        "id": "mr6imutP7JknVjxxEnFM"
    },
    {
        "data": {
            "structured_type": "structured",
            "section_id": "8db82967-cfa0-4d1a-a525-e4d0af3d7867",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:29:43.000",
        "event": "mapping_unhover",
        "id": "us1I7C34UkAVUKPnCTpU"
    },
    {
        "data": {
            "structured_type": "structured",
            "section_id": "8db82967-cfa0-4d1a-a525-e4d0af3d7867",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:29:51.000",
        "event": "mapping_unhover",
        "id": "5yJ27BBhBsJHw2ME6y8O"
    },
    {
        "data": {
            "structured_type": "structured",
            "section_id": "8db82967-cfa0-4d1a-a525-e4d0af3d7867",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:29:51.000",
        "event": "mapping_unhover",
        "id": "DEdUBYmOc25uKjHz9SqU"
    },
    {
        "data": {
            "structured_type": "structured",
            "section_id": "8db82967-cfa0-4d1a-a525-e4d0af3d7867",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:29:51.000",
        "event": "mapping_unhover",
        "id": "HNeOAgnRFIMHHScXX4t8"
    },
    {
        "data": {
            "mapping_index": 2,
            "structured_type": "structured",
            "section_id": "8db82967-cfa0-4d1a-a525-e4d0af3d7867",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:29:51.000",
        "event": "mapping_hover",
        "id": "SeHFF1XetP6mEFizGxIg"
    },
    {
        "data": {
            "mapping_index": 1,
            "structured_type": "structured",
            "section_id": "8db82967-cfa0-4d1a-a525-e4d0af3d7867",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:29:51.000",
        "event": "mapping_hover",
        "id": "lAhkHLN8GUKTGa7haUQT"
    },
    {
        "data": {
            "mapping_index": 0,
            "structured_type": "structured",
            "section_id": "8db82967-cfa0-4d1a-a525-e4d0af3d7867",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:29:51.000",
        "event": "mapping_hover",
        "id": "zfo95iAiSCL4PilqmVCC"
    },
    {
        "data": {},
        "source": "frontend",
        "timestamp": "2025-08-23 10:30:13.000",
        "event": "click_summarize_code",
        "id": "2XdIaoFmbTneC04wcdqP"
    },
    {
        "data": {
            "structured_type": "structured",
            "section_id": "8db82967-cfa0-4d1a-a525-e4d0af3d7867",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:30:13.000",
        "event": "mapping_unhover",
        "id": "KUp3LSGfyT7cHWSp1RBC"
    },
    {
        "data": {
            "mapping_index": 0,
            "structured_type": "structured",
            "section_id": "8db82967-cfa0-4d1a-a525-e4d0af3d7867",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:30:13.000",
        "event": "mapping_hover",
        "id": "ndc4c2Rn10n09RIT11It"
    },
    {
        "data": {
            "mapping_index": 0,
            "structured_type": "structured",
            "section_id": "8db82967-cfa0-4d1a-a525-e4d0af3d7867",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:30:15.000",
        "event": "mapping_hover",
        "id": "Auz5ZS9vjG9GmdO7P3tx"
    },
    {
        "data": {
            "structured_type": "structured",
            "section_id": "8db82967-cfa0-4d1a-a525-e4d0af3d7867",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:30:15.000",
        "event": "mapping_unhover",
        "id": "HhcEg1QJzihzyPF2Lh2b"
    },
    {
        "data": {
            "mapping_index": 1,
            "structured_type": "structured",
            "section_id": "8db82967-cfa0-4d1a-a525-e4d0af3d7867",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:30:15.000",
        "event": "mapping_hover",
        "id": "PBd92NGciWpnWT1eFyJE"
    },
    {
        "data": {
            "mapping_index": 0,
            "structured_type": "structured",
            "section_id": "8db82967-cfa0-4d1a-a525-e4d0af3d7867",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:30:15.000",
        "event": "mapping_hover",
        "id": "SS9lLNj81tNYsnQzWKON"
    },
    {
        "data": {
            "structured_type": "structured",
            "section_id": "8db82967-cfa0-4d1a-a525-e4d0af3d7867",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:30:15.000",
        "event": "mapping_unhover",
        "id": "o2JYr5oN7m95aQhvbnar"
    },
    {
        "data": {
            "structured_type": "structured",
            "section_id": "8db82967-cfa0-4d1a-a525-e4d0af3d7867",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:30:16.000",
        "event": "mapping_unhover",
        "id": "NH0itaZ10wzRGGDhs63x"
    },
    {
        "data": {
            "selected_code": "def scrape_season_stats(year):\n    base_url_reg = (\n        f\"https://www.basketball-reference.com/leagues/NBA_{year}_per_game.html\"\n    )\n    df_reg = pd.read_html(base_url_reg, header=0)[0]\n    df_reg = df_reg[df_reg[\"Player\"] != \"Player\"]  # remove repeated header rows\n    df_reg[\"Year\"] = year\n\n    df_reg = df_reg[\n        [\"Player\", \"Year\", \"PTS\", \"AST\", \"TRB\", \"FG%\"]\n    ]  # Keep only specified columns\n    df_reg = df_reg.dropna(\n        subset=[\"PTS\", \"AST\", \"TRB\", \"FG%\"]\n    )  # Ensure key stats aren't invalid\n    return df_reg",
            "summary": {
                "medium_unstructured": "The scrape_season_stats function downloads per-game NBA player statistics for a specified year from Basketball Reference. It removes duplicate header rows, adds the year column, selects key statistical columns, and filters out rows with missing values. The function returns a cleaned DataFrame containing player names, year, and their points, assists, rebounds, and field goal percentage.",
                "low_structured": "• Fetches NBA per-game stats for a specified year\n• Cleans and filters the data\n• Returns selected player statistics",
                "title": "Summary of scrape_season_stats Function",
                "medium_structured": "• Downloads NBA per-game stats for a given year from a specific URL\n• Cleans the data by removing repeated header rows\n• Adds the year as a column to the data\n• Selects only the Player, Year, PTS, AST, TRB, and FG% columns\n• Filters out rows with missing values in key statistical columns",
                "high_unstructured": "The scrape_season_stats function fetches NBA per-game player statistics for a given year from Basketball Reference by constructing the appropriate URL and reading the first HTML table. It cleans the resulting DataFrame by removing any repeated header rows, adds a 'Year' column, and selects only the columns for player name, year, points, assists, rebounds, and field goal percentage. The function further ensures data integrity by dropping any rows with missing values in the key statistical columns. Finally, it returns the cleaned and filtered DataFrame for further analysis or storage.",
                "high_structured": "• Constructs the URL for NBA per-game stats for the specified year\n• Reads the first table from the web page using pandas\n• Cleans the DataFrame:\n  ◦ Removes rows where the 'Player' column is a repeated header\n  ◦ Adds a 'Year' column with the specified year\n• Selects only relevant columns:\n  ◦ 'Player', 'Year', 'PTS', 'AST', 'TRB', and 'FG%'\n• Drops rows with missing values in the key statistical columns to ensure data quality\n• Returns the cleaned DataFrame containing per-game stats for each player in the given year",
                "low_unstructured": "This function retrieves and processes NBA per-game player statistics for a given year."
            }
        },
        "source": "backend",
        "timestamp": "2025-08-23 10:30:24.000",
        "event": "summarize_selected_code",
        "id": "TmIRVcBLdVvNg1My3Vdq"
    },
    {
        "data": {
            "mapping": [
                {
                    "summaryComponent": "Fetches NBA per-game stats for a specified year",
                    "codeSegments": [
                        {
                            "line": 22,
                            "code": "def scrape_season_stats(year):"
                        },
                        {
                            "line": 23,
                            "code": "base_url_reg = ("
                        },
                        {
                            "line": 24,
                            "code": "f\"https://www.basketball-reference.com/leagues/NBA_{year}_per_game.html\""
                        },
                        {
                            "line": 26,
                            "code": "df_reg = pd.read_html(base_url_reg, header=0)[0]"
                        }
                    ]
                },
                {
                    "summaryComponent": "Cleans and filters the data",
                    "codeSegments": [
                        {
                            "line": 27,
                            "code": "df_reg = df_reg[df_reg[\"Player\"] != \"Player\"]  # remove repeated header rows"
                        },
                        {
                            "line": 30,
                            "code": "df_reg = df_reg["
                        },
                        {
                            "line": 31,
                            "code": "[\"Player\", \"Year\", \"PTS\", \"AST\", \"TRB\", \"FG%\"]"
                        },
                        {
                            "line": 33,
                            "code": "df_reg = df_reg.dropna("
                        },
                        {
                            "line": 34,
                            "code": "subset=[\"PTS\", \"AST\", \"TRB\", \"FG%\"]"
                        }
                    ]
                },
                {
                    "summaryComponent": "Returns selected player statistics",
                    "codeSegments": [
                        {
                            "line": 36,
                            "code": "return df_reg"
                        }
                    ]
                }
            ],
            "summary": "• Fetches NBA per-game stats for a specified year\n• Cleans and filters the data\n• Returns selected player statistics",
            "code": "22: def scrape_season_stats(year):\n23:     base_url_reg = (\n24:         f\"https://www.basketball-reference.com/leagues/NBA_{year}_per_game.html\"\n25:     )\n26:     df_reg = pd.read_html(base_url_reg, header=0)[0]\n27:     df_reg = df_reg[df_reg[\"Player\"] != \"Player\"]  # remove repeated header rows\n28:     df_reg[\"Year\"] = year\n29: \n30:     df_reg = df_reg[\n31:         [\"Player\", \"Year\", \"PTS\", \"AST\", \"TRB\", \"FG%\"]\n32:     ]  # Keep only specified columns\n33:     df_reg = df_reg.dropna(\n34:         subset=[\"PTS\", \"AST\", \"TRB\", \"FG%\"]\n35:     )  # Ensure key stats aren't invalid\n36:     return df_reg"
        },
        "source": "backend",
        "timestamp": "2025-08-23 10:30:26.000",
        "event": "map_summary_code",
        "id": "9s9ZwA4olzwBK1PNDs2Y"
    },
    {
        "data": {
            "mapping": [
                {
                    "summaryComponent": "Constructs the URL for NBA per-game stats for the specified year",
                    "codeSegments": [
                        {
                            "line": 23,
                            "code": "base_url_reg = ("
                        },
                        {
                            "line": 24,
                            "code": "f\"https://www.basketball-reference.com/leagues/NBA_{year}_per_game.html\""
                        }
                    ]
                },
                {
                    "summaryComponent": "Reads the first table from the web page using pandas",
                    "codeSegments": [
                        {
                            "line": 26,
                            "code": "df_reg = pd.read_html(base_url_reg, header=0)[0]"
                        }
                    ]
                },
                {
                    "summaryComponent": "Cleans the DataFrame:",
                    "codeSegments": []
                },
                {
                    "summaryComponent": "Removes rows where the 'Player' column is a repeated header",
                    "codeSegments": [
                        {
                            "line": 27,
                            "code": "df_reg = df_reg[df_reg[\"Player\"] != \"Player\"]  # remove repeated header rows"
                        }
                    ]
                },
                {
                    "summaryComponent": "Adds a 'Year' column with the specified year",
                    "codeSegments": [
                        {
                            "line": 28,
                            "code": "df_reg[\"Year\"] = year"
                        }
                    ]
                },
                {
                    "summaryComponent": "Selects only relevant columns:",
                    "codeSegments": []
                },
                {
                    "summaryComponent": "'Player', 'Year', 'PTS', 'AST', 'TRB', and 'FG%'",
                    "codeSegments": [
                        {
                            "line": 30,
                            "code": "df_reg = df_reg["
                        },
                        {
                            "line": 31,
                            "code": "[\"Player\", \"Year\", \"PTS\", \"AST\", \"TRB\", \"FG%\"]"
                        }
                    ]
                },
                {
                    "summaryComponent": "Drops rows with missing values in the key statistical columns to ensure data quality",
                    "codeSegments": [
                        {
                            "line": 33,
                            "code": "df_reg = df_reg.dropna("
                        },
                        {
                            "line": 34,
                            "code": "subset=[\"PTS\", \"AST\", \"TRB\", \"FG%\"]"
                        }
                    ]
                },
                {
                    "summaryComponent": "Returns the cleaned DataFrame containing per-game stats for each player in the given year",
                    "codeSegments": [
                        {
                            "line": 36,
                            "code": "return df_reg"
                        }
                    ]
                }
            ],
            "summary": "• Constructs the URL for NBA per-game stats for the specified year\n• Reads the first table from the web page using pandas\n• Cleans the DataFrame:\n  ◦ Removes rows where the 'Player' column is a repeated header\n  ◦ Adds a 'Year' column with the specified year\n• Selects only relevant columns:\n  ◦ 'Player', 'Year', 'PTS', 'AST', 'TRB', and 'FG%'\n• Drops rows with missing values in the key statistical columns to ensure data quality\n• Returns the cleaned DataFrame containing per-game stats for each player in the given year",
            "code": "22: def scrape_season_stats(year):\n23:     base_url_reg = (\n24:         f\"https://www.basketball-reference.com/leagues/NBA_{year}_per_game.html\"\n25:     )\n26:     df_reg = pd.read_html(base_url_reg, header=0)[0]\n27:     df_reg = df_reg[df_reg[\"Player\"] != \"Player\"]  # remove repeated header rows\n28:     df_reg[\"Year\"] = year\n29: \n30:     df_reg = df_reg[\n31:         [\"Player\", \"Year\", \"PTS\", \"AST\", \"TRB\", \"FG%\"]\n32:     ]  # Keep only specified columns\n33:     df_reg = df_reg.dropna(\n34:         subset=[\"PTS\", \"AST\", \"TRB\", \"FG%\"]\n35:     )  # Ensure key stats aren't invalid\n36:     return df_reg"
        },
        "source": "backend",
        "timestamp": "2025-08-23 10:30:28.000",
        "event": "map_summary_code",
        "id": "EIaHjbjMA1jQtRlXxrzK"
    },
    {
        "data": {
            "mapping": [
                {
                    "summaryComponent": "Downloads NBA per-game stats for a given year from a specific URL",
                    "codeSegments": [
                        {
                            "line": 23,
                            "code": "base_url_reg = (\n    f\"https://www.basketball-reference.com/leagues/NBA_{year}_per_game.html\"\n)"
                        },
                        {
                            "line": 26,
                            "code": "df_reg = pd.read_html(base_url_reg, header=0)[0]"
                        }
                    ]
                },
                {
                    "summaryComponent": "Cleans the data by removing repeated header rows",
                    "codeSegments": [
                        {
                            "line": 27,
                            "code": "df_reg = df_reg[df_reg[\"Player\"] != \"Player\"]  # remove repeated header rows"
                        }
                    ]
                },
                {
                    "summaryComponent": "Adds the year as a column to the data",
                    "codeSegments": [
                        {
                            "line": 28,
                            "code": "df_reg[\"Year\"] = year"
                        }
                    ]
                },
                {
                    "summaryComponent": "Selects only the Player, Year, PTS, AST, TRB, and FG% columns",
                    "codeSegments": [
                        {
                            "line": 30,
                            "code": "df_reg = df_reg[\n    [\"Player\", \"Year\", \"PTS\", \"AST\", \"TRB\", \"FG%\"]\n]"
                        }
                    ]
                },
                {
                    "summaryComponent": "Filters out rows with missing values in key statistical columns",
                    "codeSegments": [
                        {
                            "line": 33,
                            "code": "df_reg = df_reg.dropna(\n    subset=[\"PTS\", \"AST\", \"TRB\", \"FG%\"]\n)"
                        }
                    ]
                }
            ],
            "summary": "• Downloads NBA per-game stats for a given year from a specific URL\n• Cleans the data by removing repeated header rows\n• Adds the year as a column to the data\n• Selects only the Player, Year, PTS, AST, TRB, and FG% columns\n• Filters out rows with missing values in key statistical columns",
            "code": "22: def scrape_season_stats(year):\n23:     base_url_reg = (\n24:         f\"https://www.basketball-reference.com/leagues/NBA_{year}_per_game.html\"\n25:     )\n26:     df_reg = pd.read_html(base_url_reg, header=0)[0]\n27:     df_reg = df_reg[df_reg[\"Player\"] != \"Player\"]  # remove repeated header rows\n28:     df_reg[\"Year\"] = year\n29: \n30:     df_reg = df_reg[\n31:         [\"Player\", \"Year\", \"PTS\", \"AST\", \"TRB\", \"FG%\"]\n32:     ]  # Keep only specified columns\n33:     df_reg = df_reg.dropna(\n34:         subset=[\"PTS\", \"AST\", \"TRB\", \"FG%\"]\n35:     )  # Ensure key stats aren't invalid\n36:     return df_reg"
        },
        "source": "backend",
        "timestamp": "2025-08-23 10:30:28.000",
        "event": "map_summary_code",
        "id": "Rh4bhftn27izJza6WDMN"
    },
    {
        "data": {
            "mapping": [
                {
                    "summaryComponent": "retrieves",
                    "codeSegments": [
                        {
                            "line": 26,
                            "code": "df_reg = pd.read_html(base_url_reg, header=0)[0]"
                        }
                    ]
                },
                {
                    "summaryComponent": "processes",
                    "codeSegments": [
                        {
                            "line": 27,
                            "code": "df_reg = df_reg[df_reg[\"Player\"] != \"Player\"]  # remove repeated header rows"
                        },
                        {
                            "line": 28,
                            "code": "df_reg[\"Year\"] = year"
                        },
                        {
                            "line": 30,
                            "code": "df_reg = df_reg[\n    [\"Player\", \"Year\", \"PTS\", \"AST\", \"TRB\", \"FG%\"]\n]"
                        },
                        {
                            "line": 33,
                            "code": "df_reg = df_reg.dropna(\n    subset=[\"PTS\", \"AST\", \"TRB\", \"FG%\"]\n)"
                        }
                    ]
                },
                {
                    "summaryComponent": "NBA per-game player statistics",
                    "codeSegments": [
                        {
                            "line": 24,
                            "code": "f\"https://www.basketball-reference.com/leagues/NBA_{year}_per_game.html\""
                        }
                    ]
                },
                {
                    "summaryComponent": "for a given year",
                    "codeSegments": [
                        {
                            "line": 22,
                            "code": "def scrape_season_stats(year):"
                        },
                        {
                            "line": 28,
                            "code": "df_reg[\"Year\"] = year"
                        }
                    ]
                }
            ],
            "summary": "This function retrieves and processes NBA per-game player statistics for a given year.",
            "code": "22: def scrape_season_stats(year):\n23:     base_url_reg = (\n24:         f\"https://www.basketball-reference.com/leagues/NBA_{year}_per_game.html\"\n25:     )\n26:     df_reg = pd.read_html(base_url_reg, header=0)[0]\n27:     df_reg = df_reg[df_reg[\"Player\"] != \"Player\"]  # remove repeated header rows\n28:     df_reg[\"Year\"] = year\n29: \n30:     df_reg = df_reg[\n31:         [\"Player\", \"Year\", \"PTS\", \"AST\", \"TRB\", \"FG%\"]\n32:     ]  # Keep only specified columns\n33:     df_reg = df_reg.dropna(\n34:         subset=[\"PTS\", \"AST\", \"TRB\", \"FG%\"]\n35:     )  # Ensure key stats aren't invalid\n36:     return df_reg"
        },
        "source": "backend",
        "timestamp": "2025-08-23 10:30:28.000",
        "event": "map_summary_code",
        "id": "Ui2zaCaaj5BG8wKWFeBW"
    },
    {
        "data": {
            "mapping": [
                {
                    "summaryComponent": "The scrape_season_stats function",
                    "codeSegments": [
                        {
                            "line": 22,
                            "code": "def scrape_season_stats(year):"
                        }
                    ]
                },
                {
                    "summaryComponent": "downloads per-game NBA player statistics for a specified year from Basketball Reference",
                    "codeSegments": [
                        {
                            "line": 23,
                            "code": "base_url_reg = ("
                        },
                        {
                            "line": 24,
                            "code": "f\"https://www.basketball-reference.com/leagues/NBA_{year}_per_game.html\""
                        },
                        {
                            "line": 26,
                            "code": "df_reg = pd.read_html(base_url_reg, header=0)[0]"
                        }
                    ]
                },
                {
                    "summaryComponent": "It removes duplicate header rows",
                    "codeSegments": [
                        {
                            "line": 27,
                            "code": "df_reg = df_reg[df_reg[\"Player\"] != \"Player\"]  # remove repeated header rows"
                        }
                    ]
                },
                {
                    "summaryComponent": "adds the year column",
                    "codeSegments": [
                        {
                            "line": 28,
                            "code": "df_reg[\"Year\"] = year"
                        }
                    ]
                },
                {
                    "summaryComponent": "selects key statistical columns",
                    "codeSegments": [
                        {
                            "line": 30,
                            "code": "df_reg = df_reg["
                        },
                        {
                            "line": 31,
                            "code": "[\"Player\", \"Year\", \"PTS\", \"AST\", \"TRB\", \"FG%\"]"
                        }
                    ]
                },
                {
                    "summaryComponent": "filters out rows with missing values",
                    "codeSegments": [
                        {
                            "line": 33,
                            "code": "df_reg = df_reg.dropna("
                        },
                        {
                            "line": 34,
                            "code": "subset=[\"PTS\", \"AST\", \"TRB\", \"FG%\"]"
                        }
                    ]
                },
                {
                    "summaryComponent": "The function returns a cleaned DataFrame",
                    "codeSegments": [
                        {
                            "line": 36,
                            "code": "return df_reg"
                        }
                    ]
                },
                {
                    "summaryComponent": "containing player names, year, and their points, assists, rebounds, and field goal percentage",
                    "codeSegments": [
                        {
                            "line": 31,
                            "code": "[\"Player\", \"Year\", \"PTS\", \"AST\", \"TRB\", \"FG%\"]"
                        }
                    ]
                }
            ],
            "summary": "The scrape_season_stats function downloads per-game NBA player statistics for a specified year from Basketball Reference. It removes duplicate header rows, adds the year column, selects key statistical columns, and filters out rows with missing values. The function returns a cleaned DataFrame containing player names, year, and their points, assists, rebounds, and field goal percentage.",
            "code": "22: def scrape_season_stats(year):\n23:     base_url_reg = (\n24:         f\"https://www.basketball-reference.com/leagues/NBA_{year}_per_game.html\"\n25:     )\n26:     df_reg = pd.read_html(base_url_reg, header=0)[0]\n27:     df_reg = df_reg[df_reg[\"Player\"] != \"Player\"]  # remove repeated header rows\n28:     df_reg[\"Year\"] = year\n29: \n30:     df_reg = df_reg[\n31:         [\"Player\", \"Year\", \"PTS\", \"AST\", \"TRB\", \"FG%\"]\n32:     ]  # Keep only specified columns\n33:     df_reg = df_reg.dropna(\n34:         subset=[\"PTS\", \"AST\", \"TRB\", \"FG%\"]\n35:     )  # Ensure key stats aren't invalid\n36:     return df_reg"
        },
        "source": "backend",
        "timestamp": "2025-08-23 10:30:28.000",
        "event": "map_summary_code",
        "id": "xrqd3kAZbtrtMjPyCez6"
    },
    {
        "data": {
            "section_data": {
                "lines": [
                    22,
                    36
                ],
                "summaryData": {
                    "medium_unstructured": "The scrape_season_stats function downloads per-game NBA player statistics for a specified year from Basketball Reference. It removes duplicate header rows, adds the year column, selects key statistical columns, and filters out rows with missing values. The function returns a cleaned DataFrame containing player names, year, and their points, assists, rebounds, and field goal percentage.",
                    "low_structured": "• Fetches NBA per-game stats for a specified year\n• Cleans and filters the data\n• Returns selected player statistics",
                    "title": "Summary of scrape_season_stats Function",
                    "medium_structured": "• Downloads NBA per-game stats for a given year from a specific URL\n• Cleans the data by removing repeated header rows\n• Adds the year as a column to the data\n• Selects only the Player, Year, PTS, AST, TRB, and FG% columns\n• Filters out rows with missing values in key statistical columns",
                    "high_unstructured": "The scrape_season_stats function fetches NBA per-game player statistics for a given year from Basketball Reference by constructing the appropriate URL and reading the first HTML table. It cleans the resulting DataFrame by removing any repeated header rows, adds a 'Year' column, and selects only the columns for player name, year, points, assists, rebounds, and field goal percentage. The function further ensures data integrity by dropping any rows with missing values in the key statistical columns. Finally, it returns the cleaned and filtered DataFrame for further analysis or storage.",
                    "high_structured": "• Constructs the URL for NBA per-game stats for the specified year\n• Reads the first table from the web page using pandas\n• Cleans the DataFrame:\n  ◦ Removes rows where the 'Player' column is a repeated header\n  ◦ Adds a 'Year' column with the specified year\n• Selects only relevant columns:\n  ◦ 'Player', 'Year', 'PTS', 'AST', 'TRB', and 'FG%'\n• Drops rows with missing values in the key statistical columns to ensure data quality\n• Returns the cleaned DataFrame containing per-game stats for each player in the given year",
                    "low_unstructured": "This function retrieves and processes NBA per-game player statistics for a given year."
                },
                "editPromptStructured": null,
                "createdAt": 1755973829000,
                "metadata": {
                    "filename": "scraper.py",
                    "id": "dd26b82f-3ef9-4a96-b23d-4bd763ed4331",
                    "originalCode": "def scrape_season_stats(year):\n    base_url_reg = (\n        f\"https://www.basketball-reference.com/leagues/NBA_{year}_per_game.html\"\n    )\n    df_reg = pd.read_html(base_url_reg, header=0)[0]\n    df_reg = df_reg[df_reg[\"Player\"] != \"Player\"]  # remove repeated header rows\n    df_reg[\"Year\"] = year\n\n    df_reg = df_reg[\n        [\"Player\", \"Year\", \"PTS\", \"AST\", \"TRB\", \"FG%\"]\n    ]  # Keep only specified columns\n    df_reg = df_reg.dropna(\n        subset=[\"PTS\", \"AST\", \"TRB\", \"FG%\"]\n    )  # Ensure key stats aren't invalid\n    return df_reg",
                    "fullPath": "/project/workspace/scraper.py",
                    "offset": 652
                },
                "selectedStructured": "unstructured",
                "title": "Summary of scrape_season_stats Function",
                "selectedDetailLevel": "medium",
                "summaryMappings": {
                    "medium_unstructured": [
                        {
                            "summaryComponent": "The scrape_season_stats function",
                            "codeSegments": [
                                {
                                    "line": 22,
                                    "code": "def scrape_season_stats(year):"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "downloads per-game NBA player statistics for a specified year from Basketball Reference",
                            "codeSegments": [
                                {
                                    "line": 23,
                                    "code": "base_url_reg = ("
                                },
                                {
                                    "line": 24,
                                    "code": "f\"https://www.basketball-reference.com/leagues/NBA_{year}_per_game.html\""
                                },
                                {
                                    "line": 26,
                                    "code": "df_reg = pd.read_html(base_url_reg, header=0)[0]"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "It removes duplicate header rows",
                            "codeSegments": [
                                {
                                    "line": 27,
                                    "code": "df_reg = df_reg[df_reg[\"Player\"] != \"Player\"]  # remove repeated header rows"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "adds the year column",
                            "codeSegments": [
                                {
                                    "line": 28,
                                    "code": "df_reg[\"Year\"] = year"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "selects key statistical columns",
                            "codeSegments": [
                                {
                                    "line": 30,
                                    "code": "df_reg = df_reg["
                                },
                                {
                                    "line": 31,
                                    "code": "[\"Player\", \"Year\", \"PTS\", \"AST\", \"TRB\", \"FG%\"]"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "filters out rows with missing values",
                            "codeSegments": [
                                {
                                    "line": 33,
                                    "code": "df_reg = df_reg.dropna("
                                },
                                {
                                    "line": 34,
                                    "code": "subset=[\"PTS\", \"AST\", \"TRB\", \"FG%\"]"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "The function returns a cleaned DataFrame",
                            "codeSegments": [
                                {
                                    "line": 36,
                                    "code": "return df_reg"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "containing player names, year, and their points, assists, rebounds, and field goal percentage",
                            "codeSegments": [
                                {
                                    "line": 31,
                                    "code": "[\"Player\", \"Year\", \"PTS\", \"AST\", \"TRB\", \"FG%\"]"
                                }
                            ]
                        }
                    ],
                    "low_structured": [
                        {
                            "summaryComponent": "Fetches NBA per-game stats for a specified year",
                            "codeSegments": [
                                {
                                    "line": 22,
                                    "code": "def scrape_season_stats(year):"
                                },
                                {
                                    "line": 23,
                                    "code": "base_url_reg = ("
                                },
                                {
                                    "line": 24,
                                    "code": "f\"https://www.basketball-reference.com/leagues/NBA_{year}_per_game.html\""
                                },
                                {
                                    "line": 26,
                                    "code": "df_reg = pd.read_html(base_url_reg, header=0)[0]"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "Cleans and filters the data",
                            "codeSegments": [
                                {
                                    "line": 27,
                                    "code": "df_reg = df_reg[df_reg[\"Player\"] != \"Player\"]  # remove repeated header rows"
                                },
                                {
                                    "line": 30,
                                    "code": "df_reg = df_reg["
                                },
                                {
                                    "line": 31,
                                    "code": "[\"Player\", \"Year\", \"PTS\", \"AST\", \"TRB\", \"FG%\"]"
                                },
                                {
                                    "line": 33,
                                    "code": "df_reg = df_reg.dropna("
                                },
                                {
                                    "line": 34,
                                    "code": "subset=[\"PTS\", \"AST\", \"TRB\", \"FG%\"]"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "Returns selected player statistics",
                            "codeSegments": [
                                {
                                    "line": 36,
                                    "code": "return df_reg"
                                }
                            ]
                        }
                    ],
                    "low_unstructured": [
                        {
                            "summaryComponent": "retrieves",
                            "codeSegments": [
                                {
                                    "line": 26,
                                    "code": "df_reg = pd.read_html(base_url_reg, header=0)[0]"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "processes",
                            "codeSegments": [
                                {
                                    "line": 27,
                                    "code": "df_reg = df_reg[df_reg[\"Player\"] != \"Player\"]  # remove repeated header rows"
                                },
                                {
                                    "line": 28,
                                    "code": "df_reg[\"Year\"] = year"
                                },
                                {
                                    "line": 30,
                                    "code": "df_reg = df_reg[\n    [\"Player\", \"Year\", \"PTS\", \"AST\", \"TRB\", \"FG%\"]\n]"
                                },
                                {
                                    "line": 33,
                                    "code": "df_reg = df_reg.dropna(\n    subset=[\"PTS\", \"AST\", \"TRB\", \"FG%\"]\n)"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "NBA per-game player statistics",
                            "codeSegments": [
                                {
                                    "line": 24,
                                    "code": "f\"https://www.basketball-reference.com/leagues/NBA_{year}_per_game.html\""
                                }
                            ]
                        },
                        {
                            "summaryComponent": "for a given year",
                            "codeSegments": [
                                {
                                    "line": 22,
                                    "code": "def scrape_season_stats(year):"
                                },
                                {
                                    "line": 28,
                                    "code": "df_reg[\"Year\"] = year"
                                }
                            ]
                        }
                    ],
                    "medium_structured": [
                        {
                            "summaryComponent": "Downloads NBA per-game stats for a given year from a specific URL",
                            "codeSegments": [
                                {
                                    "line": 23,
                                    "code": "base_url_reg = (\n    f\"https://www.basketball-reference.com/leagues/NBA_{year}_per_game.html\"\n)"
                                },
                                {
                                    "line": 26,
                                    "code": "df_reg = pd.read_html(base_url_reg, header=0)[0]"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "Cleans the data by removing repeated header rows",
                            "codeSegments": [
                                {
                                    "line": 27,
                                    "code": "df_reg = df_reg[df_reg[\"Player\"] != \"Player\"]  # remove repeated header rows"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "Adds the year as a column to the data",
                            "codeSegments": [
                                {
                                    "line": 28,
                                    "code": "df_reg[\"Year\"] = year"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "Selects only the Player, Year, PTS, AST, TRB, and FG% columns",
                            "codeSegments": [
                                {
                                    "line": 30,
                                    "code": "df_reg = df_reg[\n    [\"Player\", \"Year\", \"PTS\", \"AST\", \"TRB\", \"FG%\"]\n]"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "Filters out rows with missing values in key statistical columns",
                            "codeSegments": [
                                {
                                    "line": 33,
                                    "code": "df_reg = df_reg.dropna(\n    subset=[\"PTS\", \"AST\", \"TRB\", \"FG%\"]\n)"
                                }
                            ]
                        }
                    ],
                    "high_unstructured": [
                        {
                            "summaryComponent": "The scrape_season_stats function",
                            "codeSegments": [
                                {
                                    "line": 22,
                                    "code": "def scrape_season_stats(year):"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "fetches NBA per-game player statistics for a given year from Basketball Reference",
                            "codeSegments": [
                                {
                                    "line": 23,
                                    "code": "base_url_reg = ("
                                },
                                {
                                    "line": 24,
                                    "code": "f\"https://www.basketball-reference.com/leagues/NBA_{year}_per_game.html\""
                                },
                                {
                                    "line": 26,
                                    "code": "df_reg = pd.read_html(base_url_reg, header=0)[0]"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "by constructing the appropriate URL",
                            "codeSegments": [
                                {
                                    "line": 23,
                                    "code": "base_url_reg = ("
                                },
                                {
                                    "line": 24,
                                    "code": "f\"https://www.basketball-reference.com/leagues/NBA_{year}_per_game.html\""
                                }
                            ]
                        },
                        {
                            "summaryComponent": "and reading the first HTML table",
                            "codeSegments": [
                                {
                                    "line": 26,
                                    "code": "df_reg = pd.read_html(base_url_reg, header=0)[0]"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "It cleans the resulting DataFrame by removing any repeated header rows",
                            "codeSegments": [
                                {
                                    "line": 27,
                                    "code": "df_reg = df_reg[df_reg[\"Player\"] != \"Player\"]  # remove repeated header rows"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "adds a 'Year' column",
                            "codeSegments": [
                                {
                                    "line": 28,
                                    "code": "df_reg[\"Year\"] = year"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "and selects only the columns for player name, year, points, assists, rebounds, and field goal percentage",
                            "codeSegments": [
                                {
                                    "line": 30,
                                    "code": "df_reg = df_reg["
                                },
                                {
                                    "line": 31,
                                    "code": "[\"Player\", \"Year\", \"PTS\", \"AST\", \"TRB\", \"FG%\"]"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "The function further ensures data integrity by dropping any rows with missing values in the key statistical columns",
                            "codeSegments": [
                                {
                                    "line": 33,
                                    "code": "df_reg = df_reg.dropna("
                                },
                                {
                                    "line": 34,
                                    "code": "subset=[\"PTS\", \"AST\", \"TRB\", \"FG%\"]"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "Finally, it returns the cleaned and filtered DataFrame",
                            "codeSegments": [
                                {
                                    "line": 36,
                                    "code": "return df_reg"
                                }
                            ]
                        }
                    ],
                    "high_structured": [
                        {
                            "summaryComponent": "Constructs the URL for NBA per-game stats for the specified year",
                            "codeSegments": [
                                {
                                    "line": 23,
                                    "code": "base_url_reg = ("
                                },
                                {
                                    "line": 24,
                                    "code": "f\"https://www.basketball-reference.com/leagues/NBA_{year}_per_game.html\""
                                }
                            ]
                        },
                        {
                            "summaryComponent": "Reads the first table from the web page using pandas",
                            "codeSegments": [
                                {
                                    "line": 26,
                                    "code": "df_reg = pd.read_html(base_url_reg, header=0)[0]"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "Cleans the DataFrame:",
                            "codeSegments": []
                        },
                        {
                            "summaryComponent": "Removes rows where the 'Player' column is a repeated header",
                            "codeSegments": [
                                {
                                    "line": 27,
                                    "code": "df_reg = df_reg[df_reg[\"Player\"] != \"Player\"]  # remove repeated header rows"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "Adds a 'Year' column with the specified year",
                            "codeSegments": [
                                {
                                    "line": 28,
                                    "code": "df_reg[\"Year\"] = year"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "Selects only relevant columns:",
                            "codeSegments": []
                        },
                        {
                            "summaryComponent": "'Player', 'Year', 'PTS', 'AST', 'TRB', and 'FG%'",
                            "codeSegments": [
                                {
                                    "line": 30,
                                    "code": "df_reg = df_reg["
                                },
                                {
                                    "line": 31,
                                    "code": "[\"Player\", \"Year\", \"PTS\", \"AST\", \"TRB\", \"FG%\"]"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "Drops rows with missing values in the key statistical columns to ensure data quality",
                            "codeSegments": [
                                {
                                    "line": 33,
                                    "code": "df_reg = df_reg.dropna("
                                },
                                {
                                    "line": 34,
                                    "code": "subset=[\"PTS\", \"AST\", \"TRB\", \"FG%\"]"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "Returns the cleaned DataFrame containing per-game stats for each player in the given year",
                            "codeSegments": [
                                {
                                    "line": 36,
                                    "code": "return df_reg"
                                }
                            ]
                        }
                    ]
                },
                "editPromptValue": "",
                "editPromptDetailLevel": null
            },
            "section_id": "dd26b82f-3ef9-4a96-b23d-4bd763ed4331"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:30:29.000",
        "event": "create_new_section",
        "id": "MdRDbBAH3Yj73rdeQAUM"
    },
    {
        "data": {
            "before_section_id": "8db82967-cfa0-4d1a-a525-e4d0af3d7867",
            "after_section_id": "dd26b82f-3ef9-4a96-b23d-4bd763ed4331"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:30:29.000",
        "event": "autotransit_section",
        "id": "ghQFKV0NKAzJONvd0A8l"
    },
    {
        "data": {
            "mapping": [
                {
                    "summaryComponent": "The scrape_season_stats function",
                    "codeSegments": [
                        {
                            "line": 22,
                            "code": "def scrape_season_stats(year):"
                        }
                    ]
                },
                {
                    "summaryComponent": "fetches NBA per-game player statistics for a given year from Basketball Reference",
                    "codeSegments": [
                        {
                            "line": 23,
                            "code": "base_url_reg = ("
                        },
                        {
                            "line": 24,
                            "code": "f\"https://www.basketball-reference.com/leagues/NBA_{year}_per_game.html\""
                        },
                        {
                            "line": 26,
                            "code": "df_reg = pd.read_html(base_url_reg, header=0)[0]"
                        }
                    ]
                },
                {
                    "summaryComponent": "by constructing the appropriate URL",
                    "codeSegments": [
                        {
                            "line": 23,
                            "code": "base_url_reg = ("
                        },
                        {
                            "line": 24,
                            "code": "f\"https://www.basketball-reference.com/leagues/NBA_{year}_per_game.html\""
                        }
                    ]
                },
                {
                    "summaryComponent": "and reading the first HTML table",
                    "codeSegments": [
                        {
                            "line": 26,
                            "code": "df_reg = pd.read_html(base_url_reg, header=0)[0]"
                        }
                    ]
                },
                {
                    "summaryComponent": "It cleans the resulting DataFrame by removing any repeated header rows",
                    "codeSegments": [
                        {
                            "line": 27,
                            "code": "df_reg = df_reg[df_reg[\"Player\"] != \"Player\"]  # remove repeated header rows"
                        }
                    ]
                },
                {
                    "summaryComponent": "adds a 'Year' column",
                    "codeSegments": [
                        {
                            "line": 28,
                            "code": "df_reg[\"Year\"] = year"
                        }
                    ]
                },
                {
                    "summaryComponent": "and selects only the columns for player name, year, points, assists, rebounds, and field goal percentage",
                    "codeSegments": [
                        {
                            "line": 30,
                            "code": "df_reg = df_reg["
                        },
                        {
                            "line": 31,
                            "code": "[\"Player\", \"Year\", \"PTS\", \"AST\", \"TRB\", \"FG%\"]"
                        }
                    ]
                },
                {
                    "summaryComponent": "The function further ensures data integrity by dropping any rows with missing values in the key statistical columns",
                    "codeSegments": [
                        {
                            "line": 33,
                            "code": "df_reg = df_reg.dropna("
                        },
                        {
                            "line": 34,
                            "code": "subset=[\"PTS\", \"AST\", \"TRB\", \"FG%\"]"
                        }
                    ]
                },
                {
                    "summaryComponent": "Finally, it returns the cleaned and filtered DataFrame",
                    "codeSegments": [
                        {
                            "line": 36,
                            "code": "return df_reg"
                        }
                    ]
                }
            ],
            "summary": "The scrape_season_stats function fetches NBA per-game player statistics for a given year from Basketball Reference by constructing the appropriate URL and reading the first HTML table. It cleans the resulting DataFrame by removing any repeated header rows, adds a 'Year' column, and selects only the columns for player name, year, points, assists, rebounds, and field goal percentage. The function further ensures data integrity by dropping any rows with missing values in the key statistical columns. Finally, it returns the cleaned and filtered DataFrame for further analysis or storage.",
            "code": "22: def scrape_season_stats(year):\n23:     base_url_reg = (\n24:         f\"https://www.basketball-reference.com/leagues/NBA_{year}_per_game.html\"\n25:     )\n26:     df_reg = pd.read_html(base_url_reg, header=0)[0]\n27:     df_reg = df_reg[df_reg[\"Player\"] != \"Player\"]  # remove repeated header rows\n28:     df_reg[\"Year\"] = year\n29: \n30:     df_reg = df_reg[\n31:         [\"Player\", \"Year\", \"PTS\", \"AST\", \"TRB\", \"FG%\"]\n32:     ]  # Keep only specified columns\n33:     df_reg = df_reg.dropna(\n34:         subset=[\"PTS\", \"AST\", \"TRB\", \"FG%\"]\n35:     )  # Ensure key stats aren't invalid\n36:     return df_reg"
        },
        "source": "backend",
        "timestamp": "2025-08-23 10:30:29.000",
        "event": "map_summary_code",
        "id": "zNNc7aE3sf0fr2XOWvxq"
    },
    {
        "data": {
            "mapping_index": 0,
            "structured_type": "unstructured",
            "section_id": "dd26b82f-3ef9-4a96-b23d-4bd763ed4331",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:30:32.000",
        "event": "mapping_hover",
        "id": "JKrMjnt9gcgJ35wtuuzv"
    },
    {
        "data": {
            "structured_type": "unstructured",
            "section_id": "dd26b82f-3ef9-4a96-b23d-4bd763ed4331",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:30:32.000",
        "event": "mapping_unhover",
        "id": "UM4XWstFaTP0xGyA1AU9"
    },
    {
        "data": {
            "mapping_index": 0,
            "structured_type": "unstructured",
            "section_id": "dd26b82f-3ef9-4a96-b23d-4bd763ed4331",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:30:32.000",
        "event": "mapping_hover",
        "id": "kesb4bRCU86QrowZbfKc"
    },
    {
        "data": {
            "mapping_index": 1,
            "structured_type": "unstructured",
            "section_id": "dd26b82f-3ef9-4a96-b23d-4bd763ed4331",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:30:32.000",
        "event": "mapping_hover",
        "id": "oisGvqCiAPpEYhDblYEN"
    },
    {
        "data": {
            "structured_type": "unstructured",
            "section_id": "dd26b82f-3ef9-4a96-b23d-4bd763ed4331",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:30:32.000",
        "event": "mapping_unhover",
        "id": "vJ8kuucOYYIxXUsGtax4"
    },
    {
        "data": {
            "structured_type": "unstructured",
            "section_id": "dd26b82f-3ef9-4a96-b23d-4bd763ed4331",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:30:33.000",
        "event": "mapping_unhover",
        "id": "EeEeXr6XmDLPdJCiVAk4"
    },
    {
        "data": {
            "mapping_index": 1,
            "structured_type": "unstructured",
            "section_id": "dd26b82f-3ef9-4a96-b23d-4bd763ed4331",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:30:33.000",
        "event": "mapping_hover",
        "id": "kqks01Cpvugmy0b9OrJg"
    },
    {
        "data": {
            "structured_type": "unstructured",
            "section_id": "dd26b82f-3ef9-4a96-b23d-4bd763ed4331",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:30:34.000",
        "event": "mapping_unhover",
        "id": "0PKxaoRWtAvfLed81NIT"
    },
    {
        "data": {
            "mapping_index": 2,
            "structured_type": "unstructured",
            "section_id": "dd26b82f-3ef9-4a96-b23d-4bd763ed4331",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:30:34.000",
        "event": "mapping_hover",
        "id": "7KDWog7o36dKvp7DeAYN"
    },
    {
        "data": {
            "mapping_index": 1,
            "structured_type": "unstructured",
            "section_id": "dd26b82f-3ef9-4a96-b23d-4bd763ed4331",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:30:34.000",
        "event": "mapping_hover",
        "id": "CCP6OOhPNV7CZYoZzECf"
    },
    {
        "data": {
            "mapping_index": 2,
            "structured_type": "unstructured",
            "section_id": "dd26b82f-3ef9-4a96-b23d-4bd763ed4331",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:30:34.000",
        "event": "mapping_hover",
        "id": "FclFeaAkAclPxykcanXD"
    },
    {
        "data": {
            "structured_type": "unstructured",
            "section_id": "dd26b82f-3ef9-4a96-b23d-4bd763ed4331",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:30:34.000",
        "event": "mapping_unhover",
        "id": "IAT29GZSlBGRWJvGY1ij"
    },
    {
        "data": {
            "structured_type": "unstructured",
            "section_id": "dd26b82f-3ef9-4a96-b23d-4bd763ed4331",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:30:34.000",
        "event": "mapping_unhover",
        "id": "mh5DrQ8LZdFg8NrlDses"
    },
    {
        "data": {
            "structured_type": "unstructured",
            "section_id": "dd26b82f-3ef9-4a96-b23d-4bd763ed4331",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:30:35.000",
        "event": "mapping_unhover",
        "id": "EMEuQJfEU0yBM2oDNLaH"
    },
    {
        "data": {
            "mapping_index": 4,
            "structured_type": "unstructured",
            "section_id": "dd26b82f-3ef9-4a96-b23d-4bd763ed4331",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:30:35.000",
        "event": "mapping_hover",
        "id": "r1lbpsKhMxg0GOSqgb5A"
    },
    {
        "data": {
            "mapping_index": 3,
            "structured_type": "unstructured",
            "section_id": "dd26b82f-3ef9-4a96-b23d-4bd763ed4331",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:30:36.000",
        "event": "mapping_hover",
        "id": "7YKJu7EdpFyWPOdSsrxL"
    },
    {
        "data": {
            "structured_type": "unstructured",
            "section_id": "dd26b82f-3ef9-4a96-b23d-4bd763ed4331",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:30:36.000",
        "event": "mapping_unhover",
        "id": "7elljTvJR0KwPtVEtSoI"
    },
    {
        "data": {
            "structured_type": "unstructured",
            "section_id": "dd26b82f-3ef9-4a96-b23d-4bd763ed4331",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:30:36.000",
        "event": "mapping_unhover",
        "id": "CgSoZXW8jIXI8ISaKfEX"
    },
    {
        "data": {
            "mapping_index": 4,
            "structured_type": "unstructured",
            "section_id": "dd26b82f-3ef9-4a96-b23d-4bd763ed4331",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:30:36.000",
        "event": "mapping_hover",
        "id": "aKswCyHhGdO9jtDJ1jJE"
    },
    {
        "data": {
            "structured_type": "unstructured",
            "section_id": "dd26b82f-3ef9-4a96-b23d-4bd763ed4331",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:30:36.000",
        "event": "mapping_unhover",
        "id": "ipenyrzlsyqYeT2J9VAZ"
    },
    {
        "data": {
            "mapping_index": 2,
            "structured_type": "unstructured",
            "section_id": "dd26b82f-3ef9-4a96-b23d-4bd763ed4331",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:30:36.000",
        "event": "mapping_hover",
        "id": "sySzE6HeQZDRCtjcFFaL"
    },
    {
        "data": {
            "mapping_index": 5,
            "structured_type": "unstructured",
            "section_id": "dd26b82f-3ef9-4a96-b23d-4bd763ed4331",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:30:37.000",
        "event": "mapping_hover",
        "id": "52RncgxqO0GJpRKTAxK5"
    },
    {
        "data": {
            "structured_type": "unstructured",
            "section_id": "dd26b82f-3ef9-4a96-b23d-4bd763ed4331",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:30:37.000",
        "event": "mapping_unhover",
        "id": "5eZf3HxD5PoeJVZC1w0j"
    },
    {
        "data": {
            "structured_type": "unstructured",
            "section_id": "dd26b82f-3ef9-4a96-b23d-4bd763ed4331",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:30:38.000",
        "event": "mapping_unhover",
        "id": "8ONr8Z9a6ft5XbPPJtz3"
    },
    {
        "data": {
            "structured_type": "unstructured",
            "section_id": "dd26b82f-3ef9-4a96-b23d-4bd763ed4331",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:30:38.000",
        "event": "mapping_unhover",
        "id": "WO9ZM45zdyHlFWxNTOdc"
    },
    {
        "data": {
            "mapping_index": 6,
            "structured_type": "unstructured",
            "section_id": "dd26b82f-3ef9-4a96-b23d-4bd763ed4331",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:30:38.000",
        "event": "mapping_hover",
        "id": "hH7dV9v8q7PpzoLU7w3f"
    },
    {
        "data": {
            "mapping_index": 7,
            "structured_type": "unstructured",
            "section_id": "dd26b82f-3ef9-4a96-b23d-4bd763ed4331",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:30:38.000",
        "event": "mapping_hover",
        "id": "ugdiqkeQlCobNVUVeT2R"
    },
    {
        "data": {
            "structured_type": "unstructured",
            "section_id": "dd26b82f-3ef9-4a96-b23d-4bd763ed4331",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:30:39.000",
        "event": "mapping_unhover",
        "id": "rdPRDrKP8cVuPy32jEkA"
    },
    {
        "data": {
            "mapping_index": 6,
            "structured_type": "unstructured",
            "section_id": "dd26b82f-3ef9-4a96-b23d-4bd763ed4331",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:30:40.000",
        "event": "mapping_hover",
        "id": "BvClrkvkyrCXxBJSLYpi"
    },
    {
        "data": {
            "mapping_index": 7,
            "structured_type": "unstructured",
            "section_id": "dd26b82f-3ef9-4a96-b23d-4bd763ed4331",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:30:40.000",
        "event": "mapping_hover",
        "id": "FE4DtGcSCVzFUQDbJHOr"
    },
    {
        "data": {
            "structured_type": "unstructured",
            "section_id": "dd26b82f-3ef9-4a96-b23d-4bd763ed4331",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:30:40.000",
        "event": "mapping_unhover",
        "id": "gQ16Wqazc0qAMbCAhSY5"
    },
    {
        "data": {
            "structured_type": "unstructured",
            "section_id": "dd26b82f-3ef9-4a96-b23d-4bd763ed4331",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:30:41.000",
        "event": "mapping_unhover",
        "id": "1Cdqgnlf1a4WKJeAfXDv"
    },
    {
        "data": {
            "mapping_index": 6,
            "structured_type": "unstructured",
            "section_id": "dd26b82f-3ef9-4a96-b23d-4bd763ed4331",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:30:41.000",
        "event": "mapping_hover",
        "id": "jYqq6EFQg31WnUc5fhF9"
    },
    {
        "data": {
            "structured_type": "unstructured",
            "section_id": "dd26b82f-3ef9-4a96-b23d-4bd763ed4331",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:30:41.000",
        "event": "mapping_unhover",
        "id": "yCTW6t5Mn5ZidhGiEzjb"
    },
    {
        "data": {
            "structured_type": "unstructured",
            "section_id": "dd26b82f-3ef9-4a96-b23d-4bd763ed4331",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:30:42.000",
        "event": "mapping_unhover",
        "id": "67GDqIjbyTXPmT57V7Dh"
    },
    {
        "data": {
            "structured_type": "unstructured",
            "section_id": "dd26b82f-3ef9-4a96-b23d-4bd763ed4331",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:30:42.000",
        "event": "mapping_unhover",
        "id": "8dxD6xoG4pWNFhFqqbsz"
    },
    {
        "data": {
            "mapping_index": 6,
            "structured_type": "unstructured",
            "section_id": "dd26b82f-3ef9-4a96-b23d-4bd763ed4331",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:30:42.000",
        "event": "mapping_hover",
        "id": "EVkoQCP88zU70ZG9UbmL"
    },
    {
        "data": {
            "structured_type": "unstructured",
            "section_id": "dd26b82f-3ef9-4a96-b23d-4bd763ed4331",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:30:42.000",
        "event": "mapping_unhover",
        "id": "LApEORnoGWNBMPI37iw2"
    },
    {
        "data": {
            "mapping_index": 2,
            "structured_type": "unstructured",
            "section_id": "dd26b82f-3ef9-4a96-b23d-4bd763ed4331",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:30:42.000",
        "event": "mapping_hover",
        "id": "X8MEDgMoF4paBxQ3xCiO"
    },
    {
        "data": {
            "mapping_index": 4,
            "structured_type": "unstructured",
            "section_id": "dd26b82f-3ef9-4a96-b23d-4bd763ed4331",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:30:42.000",
        "event": "mapping_hover",
        "id": "c8vbdAQAUDUdhOwFRQHe"
    },
    {
        "data": {
            "mapping_index": 1,
            "structured_type": "unstructured",
            "section_id": "dd26b82f-3ef9-4a96-b23d-4bd763ed4331",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:30:42.000",
        "event": "mapping_hover",
        "id": "dA1dvCqBAjH7X9FgufvQ"
    },
    {
        "data": {
            "mapping_index": 7,
            "structured_type": "unstructured",
            "section_id": "dd26b82f-3ef9-4a96-b23d-4bd763ed4331",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:30:42.000",
        "event": "mapping_hover",
        "id": "h8xHGZdWwEQQI45iw7S0"
    },
    {
        "data": {
            "mapping_index": 5,
            "structured_type": "unstructured",
            "section_id": "dd26b82f-3ef9-4a96-b23d-4bd763ed4331",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:30:42.000",
        "event": "mapping_hover",
        "id": "jkpZKsKLPjyky6l9XlFc"
    },
    {
        "data": {
            "structured_type": "unstructured",
            "section_id": "dd26b82f-3ef9-4a96-b23d-4bd763ed4331",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:30:42.000",
        "event": "mapping_unhover",
        "id": "kaNV3EJRouoilkcnMtvF"
    },
    {
        "data": {
            "structured_type": "unstructured",
            "section_id": "dd26b82f-3ef9-4a96-b23d-4bd763ed4331",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:30:42.000",
        "event": "mapping_unhover",
        "id": "wdGTTZMsseyE4nAwzn04"
    },
    {
        "data": {
            "structured_type": "unstructured",
            "section_id": "dd26b82f-3ef9-4a96-b23d-4bd763ed4331",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:30:43.000",
        "event": "mapping_unhover",
        "id": "kvn9qBRWTqa1Bi9gyCkB"
    },
    {
        "data": {
            "mapping_index": 6,
            "structured_type": "unstructured",
            "section_id": "dd26b82f-3ef9-4a96-b23d-4bd763ed4331",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:30:45.000",
        "event": "mapping_hover",
        "id": "3dpRhZ5tCN6qY38GayED"
    },
    {
        "data": {
            "mapping_index": 5,
            "structured_type": "unstructured",
            "section_id": "dd26b82f-3ef9-4a96-b23d-4bd763ed4331",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:30:45.000",
        "event": "mapping_hover",
        "id": "8CKCwlRHg4dvsdIJ9epe"
    },
    {
        "data": {
            "mapping_index": 5,
            "structured_type": "unstructured",
            "section_id": "dd26b82f-3ef9-4a96-b23d-4bd763ed4331",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:30:45.000",
        "event": "mapping_hover",
        "id": "Epm1xUqEZr6pYcWT4D43"
    },
    {
        "data": {
            "structured_type": "unstructured",
            "section_id": "dd26b82f-3ef9-4a96-b23d-4bd763ed4331",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:30:45.000",
        "event": "mapping_unhover",
        "id": "I7KhA8fMEmUpTZtZA0Rm"
    },
    {
        "data": {
            "mapping_index": 6,
            "structured_type": "unstructured",
            "section_id": "dd26b82f-3ef9-4a96-b23d-4bd763ed4331",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:30:45.000",
        "event": "mapping_hover",
        "id": "WYcwvag4SUOPVdRdkx5c"
    },
    {
        "data": {
            "structured_type": "unstructured",
            "section_id": "dd26b82f-3ef9-4a96-b23d-4bd763ed4331",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:30:45.000",
        "event": "mapping_unhover",
        "id": "ZtXaKLozeWJ3Ug7k18hr"
    },
    {
        "data": {
            "mapping_index": 7,
            "structured_type": "unstructured",
            "section_id": "dd26b82f-3ef9-4a96-b23d-4bd763ed4331",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:30:45.000",
        "event": "mapping_hover",
        "id": "aCK9fhsLcKNhhj6A0lGA"
    },
    {
        "data": {
            "structured_type": "unstructured",
            "section_id": "dd26b82f-3ef9-4a96-b23d-4bd763ed4331",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:30:45.000",
        "event": "mapping_unhover",
        "id": "cid5wvTqhXt4I4nootQw"
    },
    {
        "data": {
            "structured_type": "unstructured",
            "section_id": "dd26b82f-3ef9-4a96-b23d-4bd763ed4331",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:30:45.000",
        "event": "mapping_unhover",
        "id": "vLpHJAKukkly18NKQth5"
    },
    {
        "data": {
            "mapping_index": 6,
            "structured_type": "unstructured",
            "section_id": "dd26b82f-3ef9-4a96-b23d-4bd763ed4331",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:30:46.000",
        "event": "mapping_hover",
        "id": "4thrzgIYNb3wDEcD1viM"
    },
    {
        "data": {
            "structured_type": "unstructured",
            "section_id": "dd26b82f-3ef9-4a96-b23d-4bd763ed4331",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:30:46.000",
        "event": "mapping_unhover",
        "id": "zxyL0NxhHcVCkhbKRrxT"
    },
    {
        "data": {
            "structured_type": "unstructured",
            "section_id": "dd26b82f-3ef9-4a96-b23d-4bd763ed4331",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:30:48.000",
        "event": "mapping_unhover",
        "id": "aJ74vFYqZ10dIEHI0e42"
    },
    {
        "data": {
            "mapping_index": 5,
            "structured_type": "unstructured",
            "section_id": "dd26b82f-3ef9-4a96-b23d-4bd763ed4331",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:30:48.000",
        "event": "mapping_hover",
        "id": "fVcypObxtH1RArTVGES7"
    },
    {
        "data": {
            "mapping_index": 1,
            "structured_type": "unstructured",
            "section_id": "dd26b82f-3ef9-4a96-b23d-4bd763ed4331",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:30:50.000",
        "event": "mapping_hover",
        "id": "3zrwCpOwecqu2Qo1YO0R"
    },
    {
        "data": {
            "mapping_index": 4,
            "structured_type": "unstructured",
            "section_id": "dd26b82f-3ef9-4a96-b23d-4bd763ed4331",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:30:50.000",
        "event": "mapping_hover",
        "id": "5GBh72JOEnOmLiJUaKKp"
    },
    {
        "data": {
            "mapping_index": 2,
            "structured_type": "unstructured",
            "section_id": "dd26b82f-3ef9-4a96-b23d-4bd763ed4331",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:30:50.000",
        "event": "mapping_hover",
        "id": "Mr5Man258DBlVgo43P3H"
    },
    {
        "data": {
            "structured_type": "unstructured",
            "section_id": "dd26b82f-3ef9-4a96-b23d-4bd763ed4331",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:30:50.000",
        "event": "mapping_unhover",
        "id": "UDOF3NECAJtNRoBGqLzH"
    },
    {
        "data": {
            "structured_type": "unstructured",
            "section_id": "dd26b82f-3ef9-4a96-b23d-4bd763ed4331",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:30:50.000",
        "event": "mapping_unhover",
        "id": "UoLYD3xn8HdTcH3ePBWV"
    },
    {
        "data": {
            "structured_type": "unstructured",
            "section_id": "dd26b82f-3ef9-4a96-b23d-4bd763ed4331",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:30:50.000",
        "event": "mapping_unhover",
        "id": "mLguQC64HkvOWIZobZME"
    },
    {
        "data": {
            "structured_type": "unstructured",
            "section_id": "dd26b82f-3ef9-4a96-b23d-4bd763ed4331",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:30:51.000",
        "event": "mapping_unhover",
        "id": "4EoXbw3HdgW9RW0yDqXV"
    },
    {
        "data": {
            "mapping_index": 2,
            "structured_type": "unstructured",
            "section_id": "dd26b82f-3ef9-4a96-b23d-4bd763ed4331",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:30:51.000",
        "event": "mapping_hover",
        "id": "4p5F8IVLrCmsENpVqbpg"
    },
    {
        "data": {
            "structured_type": "unstructured",
            "section_id": "dd26b82f-3ef9-4a96-b23d-4bd763ed4331",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:30:51.000",
        "event": "mapping_unhover",
        "id": "lM7z7sC6SmJZZd0PIyWB"
    },
    {
        "data": {
            "mapping_index": 1,
            "structured_type": "unstructured",
            "section_id": "dd26b82f-3ef9-4a96-b23d-4bd763ed4331",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:30:52.000",
        "event": "mapping_hover",
        "id": "10qEURU0CjPbyFBuovlT"
    },
    {
        "data": {
            "structured_type": "unstructured",
            "section_id": "dd26b82f-3ef9-4a96-b23d-4bd763ed4331",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:30:52.000",
        "event": "mapping_unhover",
        "id": "DzeewSLMbDR0LlkKJtH0"
    },
    {
        "data": {
            "mapping_index": 2,
            "structured_type": "unstructured",
            "section_id": "dd26b82f-3ef9-4a96-b23d-4bd763ed4331",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:30:52.000",
        "event": "mapping_hover",
        "id": "GOsD9gfKJjOU0qsK45lS"
    },
    {
        "data": {
            "mapping_index": 0,
            "structured_type": "unstructured",
            "section_id": "dd26b82f-3ef9-4a96-b23d-4bd763ed4331",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:30:52.000",
        "event": "mapping_hover",
        "id": "SAA8M2KbWqUkp5aEuYja"
    },
    {
        "data": {
            "structured_type": "unstructured",
            "section_id": "dd26b82f-3ef9-4a96-b23d-4bd763ed4331",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:30:52.000",
        "event": "mapping_unhover",
        "id": "wKJbDGCydtiNABYc99Db"
    },
    {
        "data": {
            "mapping_index": 1,
            "structured_type": "unstructured",
            "section_id": "dd26b82f-3ef9-4a96-b23d-4bd763ed4331",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:30:53.000",
        "event": "mapping_hover",
        "id": "THQom6Lxy1wRXDFfj8jT"
    },
    {
        "data": {
            "structured_type": "unstructured",
            "section_id": "dd26b82f-3ef9-4a96-b23d-4bd763ed4331",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:30:53.000",
        "event": "mapping_unhover",
        "id": "iR9JY42p6Rb4bkEop7zL"
    },
    {
        "data": {
            "mapping_index": 2,
            "structured_type": "unstructured",
            "section_id": "dd26b82f-3ef9-4a96-b23d-4bd763ed4331",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:30:57.000",
        "event": "mapping_hover",
        "id": "BBtiGUcMQnqyItRKxwHW"
    },
    {
        "data": {
            "structured_type": "unstructured",
            "section_id": "dd26b82f-3ef9-4a96-b23d-4bd763ed4331",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:30:57.000",
        "event": "mapping_unhover",
        "id": "L6foPVaskbnXbwtj4Rhg"
    },
    {
        "data": {
            "structured_type": "unstructured",
            "section_id": "dd26b82f-3ef9-4a96-b23d-4bd763ed4331",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:30:59.000",
        "event": "mapping_unhover",
        "id": "KsnWwL7WmgmkjCuUo0zS"
    },
    {
        "data": {
            "mapping_index": 4,
            "structured_type": "unstructured",
            "section_id": "dd26b82f-3ef9-4a96-b23d-4bd763ed4331",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:30:59.000",
        "event": "mapping_hover",
        "id": "Qwsc8aWOHNlejTHIvnK8"
    },
    {
        "data": {
            "mapping_index": 5,
            "structured_type": "unstructured",
            "section_id": "dd26b82f-3ef9-4a96-b23d-4bd763ed4331",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:30:59.000",
        "event": "mapping_hover",
        "id": "SutB6dhJQeUAI2XclwhU"
    },
    {
        "data": {
            "structured_type": "unstructured",
            "section_id": "dd26b82f-3ef9-4a96-b23d-4bd763ed4331",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:30:59.000",
        "event": "mapping_unhover",
        "id": "lji8BCPT3nTXe6siKiwd"
    },
    {
        "data": {
            "structured_type": "unstructured",
            "section_id": "dd26b82f-3ef9-4a96-b23d-4bd763ed4331",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:30:59.000",
        "event": "mapping_unhover",
        "id": "vU6JoyMAvRGI3t7depnt"
    },
    {
        "data": {
            "structured_type": "unstructured",
            "section_id": "dd26b82f-3ef9-4a96-b23d-4bd763ed4331",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:31:07.000",
        "event": "mapping_unhover",
        "id": "CGpXNygbwsOVcXHk0bk9"
    },
    {
        "data": {
            "mapping_index": 3,
            "structured_type": "unstructured",
            "section_id": "dd26b82f-3ef9-4a96-b23d-4bd763ed4331",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:31:07.000",
        "event": "mapping_hover",
        "id": "T6ps3AVHY5yHI5SPmGbp"
    },
    {
        "data": {
            "mapping_index": 4,
            "structured_type": "unstructured",
            "section_id": "dd26b82f-3ef9-4a96-b23d-4bd763ed4331",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:31:07.000",
        "event": "mapping_hover",
        "id": "n1B1oOm6weFiyNkNYkJb"
    },
    {
        "data": {
            "structured_type": "unstructured",
            "section_id": "dd26b82f-3ef9-4a96-b23d-4bd763ed4331",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:31:08.000",
        "event": "mapping_unhover",
        "id": "W5JXrKEteFDbMzCLgatD"
    },
    {
        "data": {
            "structured_type": "unstructured",
            "section_id": "dd26b82f-3ef9-4a96-b23d-4bd763ed4331",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:31:08.000",
        "event": "mapping_unhover",
        "id": "jSWJiSy6Ws17Eojkob7n"
    },
    {
        "data": {
            "mapping_index": 7,
            "structured_type": "unstructured",
            "section_id": "dd26b82f-3ef9-4a96-b23d-4bd763ed4331",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:31:08.000",
        "event": "mapping_hover",
        "id": "p5i3XX1RJVCBaaeMHkTz"
    },
    {
        "data": {
            "mapping_index": 1,
            "structured_type": "unstructured",
            "section_id": "dd26b82f-3ef9-4a96-b23d-4bd763ed4331",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:31:54.000",
        "event": "mapping_hover",
        "id": "9rcwMln9BbLT2sFGNjaM"
    },
    {
        "data": {
            "structured_type": "unstructured",
            "section_id": "dd26b82f-3ef9-4a96-b23d-4bd763ed4331",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:31:54.000",
        "event": "mapping_unhover",
        "id": "Al5utDS6HqSe5hmVHJeJ"
    },
    {
        "data": {
            "mapping_index": 2,
            "structured_type": "unstructured",
            "section_id": "dd26b82f-3ef9-4a96-b23d-4bd763ed4331",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:31:54.000",
        "event": "mapping_hover",
        "id": "nOtgQCoS58qlXOJF7crf"
    },
    {
        "data": {
            "structured_type": "unstructured",
            "section_id": "dd26b82f-3ef9-4a96-b23d-4bd763ed4331",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:31:55.000",
        "event": "mapping_unhover",
        "id": "Abq6VFnUtP4HtbR5NVtD"
    },
    {
        "data": {
            "mapping_index": 4,
            "structured_type": "unstructured",
            "section_id": "dd26b82f-3ef9-4a96-b23d-4bd763ed4331",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:31:55.000",
        "event": "mapping_hover",
        "id": "gHPyvtu1iiqJNIJx234z"
    },
    {
        "data": {
            "structured_type": "unstructured",
            "section_id": "dd26b82f-3ef9-4a96-b23d-4bd763ed4331",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:31:56.000",
        "event": "mapping_unhover",
        "id": "8CSHdyzjxMxViKdhikOt"
    },
    {
        "data": {
            "structured_type": "unstructured",
            "section_id": "dd26b82f-3ef9-4a96-b23d-4bd763ed4331",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:31:56.000",
        "event": "mapping_unhover",
        "id": "UB2iqsQboI0gJFb6ITwM"
    },
    {
        "data": {
            "mapping_index": 1,
            "structured_type": "unstructured",
            "section_id": "dd26b82f-3ef9-4a96-b23d-4bd763ed4331",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:31:56.000",
        "event": "mapping_hover",
        "id": "WQpFBlgGZ0uo0O0Lp3Rp"
    },
    {
        "data": {
            "mapping_index": 3,
            "structured_type": "unstructured",
            "section_id": "dd26b82f-3ef9-4a96-b23d-4bd763ed4331",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:31:56.000",
        "event": "mapping_hover",
        "id": "sgQfDOTWKhqm7MUBxGKT"
    },
    {
        "data": {
            "structured_type": "unstructured",
            "section_id": "dd26b82f-3ef9-4a96-b23d-4bd763ed4331",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:31:57.000",
        "event": "mapping_unhover",
        "id": "CxmjLEuddidZZI6O1rTp"
    },
    {
        "data": {
            "structured_type": "unstructured",
            "section_id": "dd26b82f-3ef9-4a96-b23d-4bd763ed4331",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:31:57.000",
        "event": "mapping_unhover",
        "id": "MB2Sejf74LC9Z40GaFnb"
    },
    {
        "data": {
            "mapping_index": 2,
            "structured_type": "unstructured",
            "section_id": "dd26b82f-3ef9-4a96-b23d-4bd763ed4331",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:31:57.000",
        "event": "mapping_hover",
        "id": "wIYXLNzYjX7jZ5iE6N8T"
    },
    {
        "data": {
            "mapping_index": 7,
            "structured_type": "unstructured",
            "section_id": "dd26b82f-3ef9-4a96-b23d-4bd763ed4331",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:31:59.000",
        "event": "mapping_hover",
        "id": "5qfyqUcba76448RnZ5dC"
    },
    {
        "data": {
            "mapping_index": 5,
            "structured_type": "unstructured",
            "section_id": "dd26b82f-3ef9-4a96-b23d-4bd763ed4331",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:31:59.000",
        "event": "mapping_hover",
        "id": "C68I6ngOMC4NsYvVN7ok"
    },
    {
        "data": {
            "structured_type": "unstructured",
            "section_id": "dd26b82f-3ef9-4a96-b23d-4bd763ed4331",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:31:59.000",
        "event": "mapping_unhover",
        "id": "Nu0QLjZXHk1To8FQ70tb"
    },
    {
        "data": {
            "structured_type": "unstructured",
            "section_id": "dd26b82f-3ef9-4a96-b23d-4bd763ed4331",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:31:59.000",
        "event": "mapping_unhover",
        "id": "R7JOr7nIdVEzdm3ktzeo"
    },
    {
        "data": {
            "mapping_index": 6,
            "structured_type": "unstructured",
            "section_id": "dd26b82f-3ef9-4a96-b23d-4bd763ed4331",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:31:59.000",
        "event": "mapping_hover",
        "id": "RUzD22d5TtL5Vqu6VBef"
    },
    {
        "data": {
            "mapping_index": 4,
            "structured_type": "unstructured",
            "section_id": "dd26b82f-3ef9-4a96-b23d-4bd763ed4331",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:31:59.000",
        "event": "mapping_hover",
        "id": "Y50CCkFrckKQ8tCJ2pft"
    },
    {
        "data": {
            "structured_type": "unstructured",
            "section_id": "dd26b82f-3ef9-4a96-b23d-4bd763ed4331",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:31:59.000",
        "event": "mapping_unhover",
        "id": "iWhUC71GqwEIwhyWmCaZ"
    },
    {
        "data": {
            "structured_type": "unstructured",
            "section_id": "dd26b82f-3ef9-4a96-b23d-4bd763ed4331",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:31:59.000",
        "event": "mapping_unhover",
        "id": "lTubdaIi3aSqdo90jfYs"
    },
    {
        "data": {
            "structured_type": "unstructured",
            "section_id": "dd26b82f-3ef9-4a96-b23d-4bd763ed4331",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:32:01.000",
        "event": "mapping_unhover",
        "id": "OdUCiRQOqnUnfdzOWNPL"
    },
    {
        "data": {
            "mapping_index": 5,
            "structured_type": "unstructured",
            "section_id": "dd26b82f-3ef9-4a96-b23d-4bd763ed4331",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:32:01.000",
        "event": "mapping_hover",
        "id": "OukUaiiuSGSwxyCVu3n0"
    },
    {
        "data": {
            "mapping_index": 2,
            "structured_type": "unstructured",
            "section_id": "dd26b82f-3ef9-4a96-b23d-4bd763ed4331",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:32:01.000",
        "event": "mapping_hover",
        "id": "RTZasiUpYiZ37uUwUExR"
    },
    {
        "data": {
            "structured_type": "unstructured",
            "section_id": "dd26b82f-3ef9-4a96-b23d-4bd763ed4331",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:32:01.000",
        "event": "mapping_unhover",
        "id": "RlqAH0acJMElXlsmmSq2"
    },
    {
        "data": {
            "mapping_index": 7,
            "structured_type": "unstructured",
            "section_id": "dd26b82f-3ef9-4a96-b23d-4bd763ed4331",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:32:01.000",
        "event": "mapping_hover",
        "id": "g7NArjhjc1CHKlq5ptw0"
    },
    {
        "data": {
            "structured_type": "unstructured",
            "section_id": "dd26b82f-3ef9-4a96-b23d-4bd763ed4331",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:32:01.000",
        "event": "mapping_unhover",
        "id": "gHqpxQVCHGAk4Xsa80ba"
    },
    {
        "data": {
            "mapping_index": 1,
            "structured_type": "unstructured",
            "section_id": "dd26b82f-3ef9-4a96-b23d-4bd763ed4331",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:32:01.000",
        "event": "mapping_hover",
        "id": "qFZhGVA7BJP8sqeuAE5d"
    },
    {
        "data": {
            "structured_type": "unstructured",
            "section_id": "dd26b82f-3ef9-4a96-b23d-4bd763ed4331",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:32:02.000",
        "event": "mapping_unhover",
        "id": "Ekz0q1gNtQHDemTMeOfx"
    },
    {
        "data": {
            "structured_type": "unstructured",
            "section_id": "dd26b82f-3ef9-4a96-b23d-4bd763ed4331",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:32:02.000",
        "event": "mapping_unhover",
        "id": "acbPGqYWiQWrbcW6vwMb"
    },
    {
        "data": {
            "mapping_index": 0,
            "structured_type": "unstructured",
            "section_id": "dd26b82f-3ef9-4a96-b23d-4bd763ed4331",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:32:02.000",
        "event": "mapping_hover",
        "id": "eXdcryO6btiGrKUhHdLN"
    },
    {
        "data": {
            "structured_type": "unstructured",
            "section_id": "dd26b82f-3ef9-4a96-b23d-4bd763ed4331",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:32:03.000",
        "event": "mapping_unhover",
        "id": "4ZUXEy3xoXdf61r065Ko"
    },
    {
        "data": {
            "mapping_index": 0,
            "structured_type": "unstructured",
            "section_id": "dd26b82f-3ef9-4a96-b23d-4bd763ed4331",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:32:03.000",
        "event": "mapping_hover",
        "id": "ExGvl2NgBFN1kFv3SVWM"
    },
    {
        "data": {
            "before_detail_level": "medium",
            "after_detail_level": "high",
            "before_structured": "unstructured",
            "section_id": "dd26b82f-3ef9-4a96-b23d-4bd763ed4331",
            "after_structured": "unstructured"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:32:06.000",
        "event": "change_summary_level",
        "id": "lCyKsh7z56QT4POlgNQ4"
    },
    {
        "data": {
            "before_detail_level": "medium",
            "after_detail_level": "low",
            "before_structured": "unstructured",
            "section_id": "dd26b82f-3ef9-4a96-b23d-4bd763ed4331",
            "after_structured": "unstructured"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:32:07.000",
        "event": "change_summary_level",
        "id": "ECCKhg4LzBMLx84kWcXr"
    },
    {
        "data": {
            "before_detail_level": "high",
            "after_detail_level": "medium",
            "before_structured": "unstructured",
            "section_id": "dd26b82f-3ef9-4a96-b23d-4bd763ed4331",
            "after_structured": "unstructured"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:32:07.000",
        "event": "change_summary_level",
        "id": "o1EZXqHuAS76FgI6bAaL"
    },
    {
        "data": {
            "before_detail_level": "low",
            "after_detail_level": "medium",
            "before_structured": "unstructured",
            "section_id": "dd26b82f-3ef9-4a96-b23d-4bd763ed4331",
            "after_structured": "unstructured"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:32:09.000",
        "event": "change_summary_level",
        "id": "NzFHpUlMVWquOhHtao3A"
    },
    {
        "data": {
            "before_detail_level": "medium",
            "after_detail_level": "high",
            "before_structured": "unstructured",
            "section_id": "dd26b82f-3ef9-4a96-b23d-4bd763ed4331",
            "after_structured": "unstructured"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:32:09.000",
        "event": "change_summary_level",
        "id": "SnIR8GsgFPOEUYcnrx38"
    },
    {
        "data": {
            "before_detail_level": "high",
            "after_detail_level": "high",
            "before_structured": "unstructured",
            "section_id": "dd26b82f-3ef9-4a96-b23d-4bd763ed4331",
            "after_structured": "structured"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:32:11.000",
        "event": "change_summary_level",
        "id": "JXOfYLswd2T3Qs6GEVx8"
    },
    {
        "data": {
            "mapping_index": 1,
            "structured_type": "structured",
            "section_id": "dd26b82f-3ef9-4a96-b23d-4bd763ed4331",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:32:12.000",
        "event": "mapping_hover",
        "id": "2aA6hdCI1rkorLILq2ZS"
    },
    {
        "data": {
            "structured_type": "structured",
            "section_id": "dd26b82f-3ef9-4a96-b23d-4bd763ed4331",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:32:12.000",
        "event": "mapping_unhover",
        "id": "RvKp5xxEVyOpvKrKqLWp"
    },
    {
        "data": {
            "mapping_index": 2,
            "structured_type": "structured",
            "section_id": "dd26b82f-3ef9-4a96-b23d-4bd763ed4331",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:32:12.000",
        "event": "mapping_hover",
        "id": "g68neH1MgVzByFlIItCA"
    },
    {
        "data": {
            "mapping_index": 0,
            "structured_type": "structured",
            "section_id": "dd26b82f-3ef9-4a96-b23d-4bd763ed4331",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:32:12.000",
        "event": "mapping_hover",
        "id": "qPTVEPXJnTsUzFXR3DQg"
    },
    {
        "data": {
            "structured_type": "structured",
            "section_id": "dd26b82f-3ef9-4a96-b23d-4bd763ed4331",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:32:12.000",
        "event": "mapping_unhover",
        "id": "r92lSN6Lbqx629Dorl78"
    },
    {
        "data": {
            "structured_type": "structured",
            "section_id": "dd26b82f-3ef9-4a96-b23d-4bd763ed4331",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:32:13.000",
        "event": "mapping_unhover",
        "id": "M9scRlt2jGqeWncSdqv5"
    },
    {
        "data": {
            "mapping_index": 3,
            "structured_type": "structured",
            "section_id": "dd26b82f-3ef9-4a96-b23d-4bd763ed4331",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:32:13.000",
        "event": "mapping_hover",
        "id": "UtX74DG1ii5Pnlzmg1JY"
    },
    {
        "data": {
            "mapping_index": 6,
            "structured_type": "structured",
            "section_id": "dd26b82f-3ef9-4a96-b23d-4bd763ed4331",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:32:14.000",
        "event": "mapping_hover",
        "id": "Ya9n0VNvn4J4zy9UHTJv"
    },
    {
        "data": {
            "mapping_index": 5,
            "structured_type": "structured",
            "section_id": "dd26b82f-3ef9-4a96-b23d-4bd763ed4331",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:32:14.000",
        "event": "mapping_hover",
        "id": "lGrzg8IkJYfrEj0Rzz4o"
    },
    {
        "data": {
            "structured_type": "structured",
            "section_id": "dd26b82f-3ef9-4a96-b23d-4bd763ed4331",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:32:14.000",
        "event": "mapping_unhover",
        "id": "o08rkKEgSqhpYPTrWHG9"
    },
    {
        "data": {
            "structured_type": "structured",
            "section_id": "dd26b82f-3ef9-4a96-b23d-4bd763ed4331",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:32:14.000",
        "event": "mapping_unhover",
        "id": "o4RpKm59mbdHSjgZ2Bpi"
    },
    {
        "data": {
            "mapping_index": 6,
            "structured_type": "structured",
            "section_id": "dd26b82f-3ef9-4a96-b23d-4bd763ed4331",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:32:16.000",
        "event": "mapping_hover",
        "id": "cuWji6ZLW24rOSn6dDci"
    },
    {
        "data": {
            "structured_type": "structured",
            "section_id": "dd26b82f-3ef9-4a96-b23d-4bd763ed4331",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:32:16.000",
        "event": "mapping_unhover",
        "id": "sHXMXZ7Sw2Q53W6uvrKa"
    },
    {
        "data": {
            "mapping_index": 1,
            "structured_type": "structured",
            "section_id": "dd26b82f-3ef9-4a96-b23d-4bd763ed4331",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:32:18.000",
        "event": "mapping_hover",
        "id": "NYCUO4nF32LvQqiA0ewf"
    },
    {
        "data": {
            "mapping_index": 4,
            "structured_type": "structured",
            "section_id": "dd26b82f-3ef9-4a96-b23d-4bd763ed4331",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:32:18.000",
        "event": "mapping_hover",
        "id": "P8A8quC8VCjC1Cuwe4Bk"
    },
    {
        "data": {
            "structured_type": "structured",
            "section_id": "dd26b82f-3ef9-4a96-b23d-4bd763ed4331",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:32:18.000",
        "event": "mapping_unhover",
        "id": "aUd8rUoq09CHJR6BLHaJ"
    },
    {
        "data": {
            "structured_type": "structured",
            "section_id": "dd26b82f-3ef9-4a96-b23d-4bd763ed4331",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:32:18.000",
        "event": "mapping_unhover",
        "id": "chI23RgnlSbbeRVZqf1O"
    },
    {
        "data": {
            "structured_type": "structured",
            "section_id": "dd26b82f-3ef9-4a96-b23d-4bd763ed4331",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:32:18.000",
        "event": "mapping_unhover",
        "id": "som3oFxLdRlJ74isTHPj"
    },
    {
        "data": {
            "structured_type": "structured",
            "section_id": "dd26b82f-3ef9-4a96-b23d-4bd763ed4331",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:32:27.000",
        "event": "mapping_unhover",
        "id": "10OXf6ZXPPsvk8yr7jDG"
    },
    {
        "data": {
            "mapping_index": 7,
            "structured_type": "structured",
            "section_id": "dd26b82f-3ef9-4a96-b23d-4bd763ed4331",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:32:27.000",
        "event": "mapping_hover",
        "id": "15RT8V4bMBkb5L418qdH"
    },
    {
        "data": {
            "structured_type": "structured",
            "section_id": "dd26b82f-3ef9-4a96-b23d-4bd763ed4331",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:32:27.000",
        "event": "mapping_unhover",
        "id": "nrA4plj1NLb0GN99qPy0"
    },
    {
        "data": {
            "mapping_index": 8,
            "structured_type": "structured",
            "section_id": "dd26b82f-3ef9-4a96-b23d-4bd763ed4331",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:32:27.000",
        "event": "mapping_hover",
        "id": "vA5msT1XtrP1XW0cJUy9"
    },
    {
        "data": {
            "mapping_index": 6,
            "structured_type": "structured",
            "section_id": "dd26b82f-3ef9-4a96-b23d-4bd763ed4331",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:32:31.000",
        "event": "mapping_hover",
        "id": "7rT9zYPee0rVAJaz4dmg"
    },
    {
        "data": {
            "structured_type": "structured",
            "section_id": "dd26b82f-3ef9-4a96-b23d-4bd763ed4331",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:32:31.000",
        "event": "mapping_unhover",
        "id": "qGOomIj8kArBKFGQqOK5"
    },
    {
        "data": {
            "mapping_index": 8,
            "structured_type": "structured",
            "section_id": "dd26b82f-3ef9-4a96-b23d-4bd763ed4331",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:32:32.000",
        "event": "mapping_hover",
        "id": "4CKrBRcyNO1kkmnEr4PB"
    },
    {
        "data": {
            "structured_type": "structured",
            "section_id": "dd26b82f-3ef9-4a96-b23d-4bd763ed4331",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:32:32.000",
        "event": "mapping_unhover",
        "id": "6LZLllwS5wGL7mKg1WST"
    },
    {
        "data": {
            "mapping_index": 8,
            "structured_type": "structured",
            "section_id": "dd26b82f-3ef9-4a96-b23d-4bd763ed4331",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:32:35.000",
        "event": "mapping_hover",
        "id": "Pt0BAISfHq3p7tOPWNlk"
    },
    {
        "data": {
            "structured_type": "structured",
            "section_id": "dd26b82f-3ef9-4a96-b23d-4bd763ed4331",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:32:35.000",
        "event": "mapping_unhover",
        "id": "XN0McloPsTl5Tjb1L40a"
    },
    {
        "data": {
            "mapping_index": 5,
            "structured_type": "structured",
            "section_id": "dd26b82f-3ef9-4a96-b23d-4bd763ed4331",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:32:46.000",
        "event": "mapping_hover",
        "id": "2QCWg6iMfPTjbkEusOTE"
    },
    {
        "data": {
            "structured_type": "structured",
            "section_id": "dd26b82f-3ef9-4a96-b23d-4bd763ed4331",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:32:46.000",
        "event": "mapping_unhover",
        "id": "2RBprzuE1SOS5n7dvY8B"
    },
    {
        "data": {
            "structured_type": "structured",
            "section_id": "dd26b82f-3ef9-4a96-b23d-4bd763ed4331",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:32:46.000",
        "event": "mapping_unhover",
        "id": "4Tw9GkhjA7n1FxVQcuSa"
    },
    {
        "data": {
            "mapping_index": 6,
            "structured_type": "structured",
            "section_id": "dd26b82f-3ef9-4a96-b23d-4bd763ed4331",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:32:46.000",
        "event": "mapping_hover",
        "id": "8XOTMQPjLTVlgJmTGWoS"
    },
    {
        "data": {
            "mapping_index": 7,
            "structured_type": "structured",
            "section_id": "dd26b82f-3ef9-4a96-b23d-4bd763ed4331",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:32:46.000",
        "event": "mapping_hover",
        "id": "A0TSxg6t5qFb1cqmpWWR"
    },
    {
        "data": {
            "structured_type": "structured",
            "section_id": "dd26b82f-3ef9-4a96-b23d-4bd763ed4331",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:32:46.000",
        "event": "mapping_unhover",
        "id": "Ord9S2u3qjAkfkluPyHk"
    },
    {
        "data": {
            "structured_type": "structured",
            "section_id": "dd26b82f-3ef9-4a96-b23d-4bd763ed4331",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:32:46.000",
        "event": "mapping_unhover",
        "id": "TIUHOjToT4y6nlaynqFn"
    },
    {
        "data": {
            "structured_type": "structured",
            "section_id": "dd26b82f-3ef9-4a96-b23d-4bd763ed4331",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:32:46.000",
        "event": "mapping_unhover",
        "id": "cpuZhKMGHVcYQmtFNzF0"
    },
    {
        "data": {
            "mapping_index": 8,
            "structured_type": "structured",
            "section_id": "dd26b82f-3ef9-4a96-b23d-4bd763ed4331",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:32:46.000",
        "event": "mapping_hover",
        "id": "jfdI3Tz9PqQIKondEcUU"
    },
    {
        "data": {
            "mapping_index": 3,
            "structured_type": "structured",
            "section_id": "dd26b82f-3ef9-4a96-b23d-4bd763ed4331",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:32:46.000",
        "event": "mapping_hover",
        "id": "qFtE9ZtYlmmmahkK8sHj"
    },
    {
        "data": {
            "mapping_index": 4,
            "structured_type": "structured",
            "section_id": "dd26b82f-3ef9-4a96-b23d-4bd763ed4331",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:32:46.000",
        "event": "mapping_hover",
        "id": "sNyhsaDVV0ui4Amou66u"
    },
    {
        "data": {
            "structured_type": "structured",
            "section_id": "dd26b82f-3ef9-4a96-b23d-4bd763ed4331",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:32:47.000",
        "event": "mapping_unhover",
        "id": "95PTcVgL4qdnmjzleqw2"
    },
    {
        "data": {
            "mapping_index": 0,
            "structured_type": "structured",
            "section_id": "dd26b82f-3ef9-4a96-b23d-4bd763ed4331",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:32:47.000",
        "event": "mapping_hover",
        "id": "CXp6uQRZXh5bueGBdf9f"
    },
    {
        "data": {
            "mapping_index": 2,
            "structured_type": "structured",
            "section_id": "dd26b82f-3ef9-4a96-b23d-4bd763ed4331",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:32:47.000",
        "event": "mapping_hover",
        "id": "ImHXtWasTRlC9rITaEH6"
    },
    {
        "data": {
            "structured_type": "structured",
            "section_id": "dd26b82f-3ef9-4a96-b23d-4bd763ed4331",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:32:47.000",
        "event": "mapping_unhover",
        "id": "ms9h3seyapqFDU44pqTR"
    },
    {
        "data": {
            "structured_type": "structured",
            "section_id": "dd26b82f-3ef9-4a96-b23d-4bd763ed4331",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:32:47.000",
        "event": "mapping_unhover",
        "id": "nfvXThaQujsRGEzKeYgX"
    },
    {
        "data": {
            "mapping_index": 1,
            "structured_type": "structured",
            "section_id": "dd26b82f-3ef9-4a96-b23d-4bd763ed4331",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:32:47.000",
        "event": "mapping_hover",
        "id": "x8u8HoekhnnCPsaBedf4"
    },
    {
        "data": {
            "structured_type": "structured",
            "section_id": "dd26b82f-3ef9-4a96-b23d-4bd763ed4331",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:32:58.000",
        "event": "mapping_unhover",
        "id": "EvCFn4YbArJBt5jSHr9t"
    },
    {
        "data": {
            "mapping_index": 5,
            "structured_type": "structured",
            "section_id": "dd26b82f-3ef9-4a96-b23d-4bd763ed4331",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:33:05.000",
        "event": "mapping_hover",
        "id": "66d9MF45rwOIgQWTR1NS"
    },
    {
        "data": {
            "structured_type": "structured",
            "section_id": "dd26b82f-3ef9-4a96-b23d-4bd763ed4331",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:33:05.000",
        "event": "mapping_unhover",
        "id": "cPyda4BjUEgqCiDUeoL5"
    },
    {
        "data": {
            "structured_type": "structured",
            "section_id": "dd26b82f-3ef9-4a96-b23d-4bd763ed4331",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:33:05.000",
        "event": "mapping_unhover",
        "id": "eFq1OiRr9yBUDgEBVOUs"
    },
    {
        "data": {
            "mapping_index": 7,
            "structured_type": "structured",
            "section_id": "dd26b82f-3ef9-4a96-b23d-4bd763ed4331",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:33:05.000",
        "event": "mapping_hover",
        "id": "kZyZiUZ1uU9NyDZbe95r"
    },
    {
        "data": {
            "mapping_index": 0,
            "structured_type": "structured",
            "section_id": "dd26b82f-3ef9-4a96-b23d-4bd763ed4331",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:33:05.000",
        "event": "mapping_hover",
        "id": "tYExaeFzsxVc1nVyA8k9"
    },
    {
        "data": {
            "structured_type": "structured",
            "section_id": "dd26b82f-3ef9-4a96-b23d-4bd763ed4331",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:33:05.000",
        "event": "mapping_unhover",
        "id": "vb3eUlvQDe6dRpueUL3A"
    },
    {
        "data": {
            "mapping_index": 3,
            "structured_type": "structured",
            "section_id": "dd26b82f-3ef9-4a96-b23d-4bd763ed4331",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:33:32.000",
        "event": "mapping_hover",
        "id": "CuPaZzH5blBFMpqrqnz8"
    },
    {
        "data": {
            "mapping_index": 7,
            "structured_type": "structured",
            "section_id": "dd26b82f-3ef9-4a96-b23d-4bd763ed4331",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:33:32.000",
        "event": "mapping_hover",
        "id": "HvqwRWXTQKnq2pnAhyZW"
    },
    {
        "data": {
            "structured_type": "structured",
            "section_id": "dd26b82f-3ef9-4a96-b23d-4bd763ed4331",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:33:32.000",
        "event": "mapping_unhover",
        "id": "MtrcqvWtSjnaYXITHC1J"
    },
    {
        "data": {
            "structured_type": "structured",
            "section_id": "dd26b82f-3ef9-4a96-b23d-4bd763ed4331",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:33:32.000",
        "event": "mapping_unhover",
        "id": "ZxpWnYQbkhLhQcrMr1J2"
    },
    {
        "data": {
            "structured_type": "structured",
            "section_id": "dd26b82f-3ef9-4a96-b23d-4bd763ed4331",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:33:41.000",
        "event": "mapping_unhover",
        "id": "2wXKt06AfVTSJpqkCy98"
    },
    {
        "data": {
            "structured_type": "structured",
            "section_id": "dd26b82f-3ef9-4a96-b23d-4bd763ed4331",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:33:41.000",
        "event": "mapping_unhover",
        "id": "3BeDFaFkDmJOSfOH5zRO"
    },
    {
        "data": {
            "structured_type": "structured",
            "section_id": "dd26b82f-3ef9-4a96-b23d-4bd763ed4331",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:33:41.000",
        "event": "mapping_unhover",
        "id": "ALyrFajEdEm0PZlogs70"
    },
    {
        "data": {
            "mapping_index": 0,
            "structured_type": "structured",
            "section_id": "dd26b82f-3ef9-4a96-b23d-4bd763ed4331",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:33:41.000",
        "event": "mapping_hover",
        "id": "BcOPm1S2993FE5ake6Io"
    },
    {
        "data": {
            "mapping_index": 8,
            "structured_type": "structured",
            "section_id": "dd26b82f-3ef9-4a96-b23d-4bd763ed4331",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:33:41.000",
        "event": "mapping_hover",
        "id": "JqdaNC0tbpkHyiCg0Hov"
    },
    {
        "data": {
            "mapping_index": 7,
            "structured_type": "structured",
            "section_id": "dd26b82f-3ef9-4a96-b23d-4bd763ed4331",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:33:41.000",
        "event": "mapping_hover",
        "id": "SJi9o6frhmaqxnca6vdV"
    },
    {
        "data": {
            "mapping_index": 3,
            "structured_type": "structured",
            "section_id": "dd26b82f-3ef9-4a96-b23d-4bd763ed4331",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:33:41.000",
        "event": "mapping_hover",
        "id": "SXNwT9JSrjmveLKCWib8"
    },
    {
        "data": {
            "mapping_index": 4,
            "structured_type": "structured",
            "section_id": "dd26b82f-3ef9-4a96-b23d-4bd763ed4331",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:33:41.000",
        "event": "mapping_hover",
        "id": "V4j0mwnv82h7eL55YZuS"
    },
    {
        "data": {
            "structured_type": "structured",
            "section_id": "dd26b82f-3ef9-4a96-b23d-4bd763ed4331",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:33:41.000",
        "event": "mapping_unhover",
        "id": "oLG8ocUDvcGZwwTjzghQ"
    },
    {
        "data": {
            "structured_type": "structured",
            "section_id": "dd26b82f-3ef9-4a96-b23d-4bd763ed4331",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:33:41.000",
        "event": "mapping_unhover",
        "id": "yv4CaNstw0ZAY4RzJoqB"
    },
    {
        "data": {
            "structured_type": "structured",
            "section_id": "dd26b82f-3ef9-4a96-b23d-4bd763ed4331",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:33:44.000",
        "event": "mapping_unhover",
        "id": "5BpuTm4pMXJHu3Kn7pHv"
    },
    {
        "data": {
            "structured_type": "structured",
            "section_id": "dd26b82f-3ef9-4a96-b23d-4bd763ed4331",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:33:44.000",
        "event": "mapping_unhover",
        "id": "fvOOCwSGqKsvavkVDWkv"
    },
    {
        "data": {
            "mapping_index": 2,
            "structured_type": "structured",
            "section_id": "dd26b82f-3ef9-4a96-b23d-4bd763ed4331",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:33:44.000",
        "event": "mapping_hover",
        "id": "l5doYZnWA9fIz02l1at3"
    },
    {
        "data": {
            "mapping_index": 8,
            "structured_type": "structured",
            "section_id": "dd26b82f-3ef9-4a96-b23d-4bd763ed4331",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:33:44.000",
        "event": "mapping_hover",
        "id": "yaxUoX817fUygEP3NLtd"
    },
    {
        "data": {
            "structured_type": "structured",
            "section_id": "dd26b82f-3ef9-4a96-b23d-4bd763ed4331",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:34:03.000",
        "event": "mapping_unhover",
        "id": "1CkFQRAlBi6OWjBRpASL"
    },
    {
        "data": {
            "mapping_index": 8,
            "structured_type": "structured",
            "section_id": "dd26b82f-3ef9-4a96-b23d-4bd763ed4331",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:34:03.000",
        "event": "mapping_hover",
        "id": "c7VriPQO83ttGpTZ1P7s"
    },
    {
        "data": {
            "structured_type": "structured",
            "section_id": "dd26b82f-3ef9-4a96-b23d-4bd763ed4331",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:34:10.000",
        "event": "mapping_unhover",
        "id": "G4cRIhRTWHrhBPUxrWZa"
    },
    {
        "data": {
            "structured_type": "structured",
            "section_id": "dd26b82f-3ef9-4a96-b23d-4bd763ed4331",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:34:10.000",
        "event": "mapping_unhover",
        "id": "OzqAGpQtev8eTE3qvbft"
    },
    {
        "data": {
            "mapping_index": 3,
            "structured_type": "structured",
            "section_id": "dd26b82f-3ef9-4a96-b23d-4bd763ed4331",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:34:10.000",
        "event": "mapping_hover",
        "id": "T1pksYQUcCLDdcBlIrQ3"
    },
    {
        "data": {
            "mapping_index": 7,
            "structured_type": "structured",
            "section_id": "dd26b82f-3ef9-4a96-b23d-4bd763ed4331",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:34:10.000",
        "event": "mapping_hover",
        "id": "kxA1m4YmlKS8fcQXjUiF"
    },
    {
        "data": {
            "mapping_index": 8,
            "structured_type": "structured",
            "section_id": "dd26b82f-3ef9-4a96-b23d-4bd763ed4331",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:34:10.000",
        "event": "mapping_hover",
        "id": "lYxYe9I5LhtAUycYPIYc"
    },
    {
        "data": {
            "structured_type": "structured",
            "section_id": "dd26b82f-3ef9-4a96-b23d-4bd763ed4331",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:34:10.000",
        "event": "mapping_unhover",
        "id": "siaXv6MaJtZZmLyhWZi7"
    },
    {
        "data": {
            "mapping_index": 7,
            "structured_type": "structured",
            "section_id": "dd26b82f-3ef9-4a96-b23d-4bd763ed4331",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:34:13.000",
        "event": "mapping_hover",
        "id": "9rACb1aXnuEvK1WuuAxi"
    },
    {
        "data": {
            "structured_type": "structured",
            "section_id": "dd26b82f-3ef9-4a96-b23d-4bd763ed4331",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:34:13.000",
        "event": "mapping_unhover",
        "id": "dNrqfOzHf6RiSL8OksXw"
    },
    {
        "data": {
            "structured": "structured",
            "section_id": "dd26b82f-3ef9-4a96-b23d-4bd763ed4331",
            "summary": "• Constructs the URL for NBA per-game stats for the specified year\n• Reads the first table from the web page using pandas\n• Cleans the DataFrame:\n  ◦ Removes rows where the 'Player' column is a repeated header\n  ◦ Adds a 'Year' column with the specified year\n• Selects only relevant columns:\n  ◦ 'Player', 'Year', 'PTS', 'AST', 'TRB', and 'FG%'\n• Drops rows with missing values in the key statistical columns to ensure data quality\n• Returns the cleaned DataFrame containing per-game stats for each player in the given year",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:34:13.000",
        "event": "click_edit_in_prompt",
        "id": "wr6RTSUJIDWNIkhcVKB6"
    },
    {
        "data": {
            "mapping_index": 7,
            "structured_type": "structured",
            "section_id": "dd26b82f-3ef9-4a96-b23d-4bd763ed4331",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:34:14.000",
        "event": "mapping_hover",
        "id": "6mvhIXgEr3iQMbqX3lZE"
    },
    {
        "data": {
            "mapping_index": 8,
            "structured_type": "structured",
            "section_id": "dd26b82f-3ef9-4a96-b23d-4bd763ed4331",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:34:14.000",
        "event": "mapping_hover",
        "id": "KGCXSVpn0UA3CGTeVUWU"
    },
    {
        "data": {
            "structured_type": "structured",
            "section_id": "dd26b82f-3ef9-4a96-b23d-4bd763ed4331",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:34:14.000",
        "event": "mapping_unhover",
        "id": "NPip2k1s9Q6fJ6zO0uYu"
    },
    {
        "data": {
            "structured_type": "structured",
            "section_id": "dd26b82f-3ef9-4a96-b23d-4bd763ed4331",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:34:14.000",
        "event": "mapping_unhover",
        "id": "WiqGdMyoSRNPxmMgaxV7"
    },
    {
        "data": {
            "mapping_index": 6,
            "structured_type": "structured",
            "section_id": "dd26b82f-3ef9-4a96-b23d-4bd763ed4331",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:34:14.000",
        "event": "mapping_hover",
        "id": "Zv6ndVQNhPe8sAYT4RJi"
    },
    {
        "data": {
            "structured_type": "structured",
            "section_id": "dd26b82f-3ef9-4a96-b23d-4bd763ed4331",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:34:14.000",
        "event": "mapping_unhover",
        "id": "dCgrenzJHt5z4kStp3Df"
    },
    {
        "data": {
            "mapping_index": 0,
            "structured_type": "structured",
            "section_id": "dd26b82f-3ef9-4a96-b23d-4bd763ed4331",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:34:14.000",
        "event": "mapping_hover",
        "id": "eRrJNj7hxIii4qIuQ3Ru"
    },
    {
        "data": {
            "structured_type": "structured",
            "section_id": "dd26b82f-3ef9-4a96-b23d-4bd763ed4331",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:34:14.000",
        "event": "mapping_unhover",
        "id": "kNPyeullzyPBFacim9mb"
    },
    {
        "data": {
            "instruction": "In addition to the base stats for the specified year, get the advances stats from https://www.basketball-reference.com/leagues/NBA_2025_advanced.html and read the columns BPM and VORP.",
            "structured": "structured",
            "section_id": "dd26b82f-3ef9-4a96-b23d-4bd763ed4331",
            "original_summary": "• Constructs the URL for NBA per-game stats for the specified year\n• Reads the first table from the web page using pandas\n• Cleans the DataFrame:\n  ◦ Removes rows where the 'Player' column is a repeated header\n  ◦ Adds a 'Year' column with the specified year\n• Selects only relevant columns:\n  ◦ 'Player', 'Year', 'PTS', 'AST', 'TRB', and 'FG%'\n• Drops rows with missing values in the key statistical columns to ensure data quality\n• Returns the cleaned DataFrame containing per-game stats for each player in the given year",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:34:17.000",
        "event": "apply_instruction_summary",
        "id": "PwI9ozTdrJbUhw3mUh8M"
    },
    {
        "data": {
            "instruction": "In addition to the base stats for the specified year, get the advances stats from https://www.basketball-reference.com/leagues/NBA_2025_advanced.html and read the columns BPM and VORP.",
            "original_summary": "• Constructs the URL for NBA per-game stats for the specified year\n• Reads the first table from the web page using pandas\n• Cleans the DataFrame:\n  ◦ Removes rows where the 'Player' column is a repeated header\n  ◦ Adds a 'Year' column with the specified year\n• Selects only relevant columns:\n  ◦ 'Player', 'Year', 'PTS', 'AST', 'TRB', and 'FG%'\n• Drops rows with missing values in the key statistical columns to ensure data quality\n• Returns the cleaned DataFrame containing per-game stats for each player in the given year",
            "original_code": "def scrape_season_stats(year):\n    base_url_reg = (\n        f\"https://www.basketball-reference.com/leagues/NBA_{year}_per_game.html\"\n    )\n    df_reg = pd.read_html(base_url_reg, header=0)[0]\n    df_reg = df_reg[df_reg[\"Player\"] != \"Player\"]  # remove repeated header rows\n    df_reg[\"Year\"] = year\n\n    df_reg = df_reg[\n        [\"Player\", \"Year\", \"PTS\", \"AST\", \"TRB\", \"FG%\"]\n    ]  # Keep only specified columns\n    df_reg = df_reg.dropna(\n        subset=[\"PTS\", \"AST\", \"TRB\", \"FG%\"]\n    )  # Ensure key stats aren't invalid\n    return df_reg",
            "updated_summary": "• Constructs the URL for NBA per-game stats for the specified year  \n• Reads the first table from the per-game stats web page using pandas  \n• Cleans the per-game DataFrame:  \n  ◦ Removes rows where the 'Player' column is a repeated header  \n  ◦ Adds a 'Year' column with the specified year  \n• Selects only relevant columns from the per-game stats:  \n  ◦ 'Player', 'Year', 'PTS', 'AST', 'TRB', and 'FG%'  \n• Drops rows with missing values in the key statistical columns to ensure data quality  \n• Additionally, constructs the URL for NBA advanced stats for the specified year  \n• Reads the first table from the advanced stats web page and selects the 'BPM' and 'VORP' columns  \n• Merges the advanced stats ('BPM' and 'VORP') with the per-game stats DataFrame based on the 'Player' and 'Year' columns  \n• Returns the cleaned DataFrame containing per-game stats plus 'BPM' and 'VORP' for each player in the given year"
        },
        "source": "backend",
        "timestamp": "2025-08-23 10:34:20.000",
        "event": "apply_instruction_summary",
        "id": "m3CvUUwYETBoKKuEpuMB"
    },
    {
        "data": {
            "instruction": "In addition to the base stats for the specified year, get the advances stats from https://www.basketball-reference.com/leagues/NBA_2025_advanced.html and read the columns BPM and VORP.",
            "structured": "structured",
            "section_id": "dd26b82f-3ef9-4a96-b23d-4bd763ed4331",
            "original_summary": "• Constructs the URL for NBA per-game stats for the specified year\n• Reads the first table from the web page using pandas\n• Cleans the DataFrame:\n  ◦ Removes rows where the 'Player' column is a repeated header\n  ◦ Adds a 'Year' column with the specified year\n• Selects only relevant columns:\n  ◦ 'Player', 'Year', 'PTS', 'AST', 'TRB', and 'FG%'\n• Drops rows with missing values in the key statistical columns to ensure data quality\n• Returns the cleaned DataFrame containing per-game stats for each player in the given year",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:35:22.000",
        "event": "apply_instruction_summary",
        "id": "XsUpOh1Ce9VxanZds6ia"
    },
    {
        "data": {
            "instruction": "In addition to the base stats for the specified year, get the advances stats from https://www.basketball-reference.com/leagues/NBA_2025_advanced.html and read the columns BPM and VORP.",
            "original_summary": "• Constructs the URL for NBA per-game stats for the specified year\n• Reads the first table from the web page using pandas\n• Cleans the DataFrame:\n  ◦ Removes rows where the 'Player' column is a repeated header\n  ◦ Adds a 'Year' column with the specified year\n• Selects only relevant columns:\n  ◦ 'Player', 'Year', 'PTS', 'AST', 'TRB', and 'FG%'\n• Drops rows with missing values in the key statistical columns to ensure data quality\n• Returns the cleaned DataFrame containing per-game stats for each player in the given year",
            "original_code": "def scrape_season_stats(year):\n    base_url_reg = (\n        f\"https://www.basketball-reference.com/leagues/NBA_{year}_per_game.html\"\n    )\n    df_reg = pd.read_html(base_url_reg, header=0)[0]\n    df_reg = df_reg[df_reg[\"Player\"] != \"Player\"]  # remove repeated header rows\n    df_reg[\"Year\"] = year\n\n    df_reg = df_reg[\n        [\"Player\", \"Year\", \"PTS\", \"AST\", \"TRB\", \"FG%\"]\n    ]  # Keep only specified columns\n    df_reg = df_reg.dropna(\n        subset=[\"PTS\", \"AST\", \"TRB\", \"FG%\"]\n    )  # Ensure key stats aren't invalid\n    return df_reg",
            "updated_summary": "• Constructs the URL for NBA per-game stats for the specified year  \n• Reads the first table from the per-game stats web page using pandas  \n• Also constructs the URL for NBA advanced stats for the specified year and reads the first table from that page  \n• Cleans the per-game DataFrame:  \n  ◦ Removes rows where the 'Player' column is a repeated header  \n  ◦ Adds a 'Year' column with the specified year  \n• Selects only relevant columns from the per-game stats:  \n  ◦ 'Player', 'Year', 'PTS', 'AST', 'TRB', and 'FG%'  \n• Selects the 'BPM' and 'VORP' columns from the advanced stats table  \n• Merges the per-game and advanced stats DataFrames on the 'Player' column  \n• Drops rows with missing values in the key statistical columns to ensure data quality  \n• Returns the cleaned DataFrame containing per-game stats and advanced stats ('BPM', 'VORP') for each player in the given year"
        },
        "source": "backend",
        "timestamp": "2025-08-23 10:35:24.000",
        "event": "apply_instruction_summary",
        "id": "L4lPV83rll7EJcJYchaY"
    },
    {
        "data": {
            "structured": "structured",
            "section_id": "dd26b82f-3ef9-4a96-b23d-4bd763ed4331",
            "original_summary": "• Constructs the URL for NBA per-game stats for the specified year\n• Reads the first table from the web page using pandas\n• Cleans the DataFrame:\n  ◦ Removes rows where the 'Player' column is a repeated header\n  ◦ Adds a 'Year' column with the specified year\n• Selects only relevant columns:\n  ◦ 'Player', 'Year', 'PTS', 'AST', 'TRB', and 'FG%'\n• Drops rows with missing values in the key statistical columns to ensure data quality\n• Returns the cleaned DataFrame containing per-game stats for each player in the given year",
            "edited_summary": "• Constructs the URL for NBA per-game stats for the specified year  \n• Reads the first table from the per-game stats web page using pandas  \n• Also constructs the URL for NBA advanced stats for the specified year and reads the first table from that page  \n• Cleans the per-game DataFrame:  \n  ◦ Removes rows where the 'Player' column is a repeated header  \n  ◦ Adds a 'Year' column with the specified year  \n• Selects only relevant columns from the per-game stats:  \n  ◦ 'Player', 'Year', 'PTS', 'AST', 'TRB', and 'FG%'  \n• Selects the 'BPM' and 'VORP' columns from the advanced stats table  \n• Merges the per-game and advanced stats DataFrames on the 'Player' column  \n• Drops rows with missing values in the key statistical columns to ensure data quality  \n• Returns the cleaned DataFrame containing per-game stats and advanced stats ('BPM', 'VORP') for each player in the given year",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:35:29.000",
        "event": "commit_modified_summary",
        "id": "JK5ay3Nv6AKAazDl16iq"
    },
    {
        "data": {
            "detail_level": "high",
            "structured_type": "structured",
            "updated_code": "def scrape_season_stats(year):\n    base_url_reg = (\n        f\"https://www.basketball-reference.com/leagues/NBA_{year}_per_game.html\"\n    )\n    base_url_adv = (\n        f\"https://www.basketball-reference.com/leagues/NBA_{year}_advanced.html\"\n    )\n    df_reg = pd.read_html(base_url_reg, header=0)[0]\n    df_adv = pd.read_html(base_url_adv, header=0)[0]\n\n    df_reg = df_reg[df_reg[\"Player\"] != \"Player\"]  # remove repeated header rows\n    df_reg[\"Year\"] = year\n\n    df_reg = df_reg[\n        [\"Player\", \"Year\", \"PTS\", \"AST\", \"TRB\", \"FG%\"]\n    ]  # Keep only specified columns\n\n    df_adv = df_adv[df_adv[\"Player\"] != \"Player\"]  # remove repeated header rows\n    df_adv = df_adv[[\"Player\", \"BPM\", \"VORP\"]]\n\n    df_merged = pd.merge(df_reg, df_adv, on=\"Player\", how=\"inner\")\n\n    df_merged = df_merged.dropna(\n        subset=[\"PTS\", \"AST\", \"TRB\", \"FG%\", \"BPM\", \"VORP\"]\n    )  # Ensure key stats aren't invalid\n    return df_merged",
            "original_summary": "• Constructs the URL for NBA per-game stats for the specified year\n• Reads the first table from the web page using pandas\n• Cleans the DataFrame:\n  ◦ Removes rows where the 'Player' column is a repeated header\n  ◦ Adds a 'Year' column with the specified year\n• Selects only relevant columns:\n  ◦ 'Player', 'Year', 'PTS', 'AST', 'TRB', and 'FG%'\n• Drops rows with missing values in the key statistical columns to ensure data quality\n• Returns the cleaned DataFrame containing per-game stats for each player in the given year",
            "original_code": "def scrape_season_stats(year):\n    base_url_reg = (\n        f\"https://www.basketball-reference.com/leagues/NBA_{year}_per_game.html\"\n    )\n    df_reg = pd.read_html(base_url_reg, header=0)[0]\n    df_reg = df_reg[df_reg[\"Player\"] != \"Player\"]  # remove repeated header rows\n    df_reg[\"Year\"] = year\n\n    df_reg = df_reg[\n        [\"Player\", \"Year\", \"PTS\", \"AST\", \"TRB\", \"FG%\"]\n    ]  # Keep only specified columns\n    df_reg = df_reg.dropna(\n        subset=[\"PTS\", \"AST\", \"TRB\", \"FG%\"]\n    )  # Ensure key stats aren't invalid\n    return df_reg",
            "edited_summary": "• Constructs the URL for NBA per-game stats for the specified year  \n• Reads the first table from the per-game stats web page using pandas  \n• Also constructs the URL for NBA advanced stats for the specified year and reads the first table from that page  \n• Cleans the per-game DataFrame:  \n  ◦ Removes rows where the 'Player' column is a repeated header  \n  ◦ Adds a 'Year' column with the specified year  \n• Selects only relevant columns from the per-game stats:  \n  ◦ 'Player', 'Year', 'PTS', 'AST', 'TRB', and 'FG%'  \n• Selects the 'BPM' and 'VORP' columns from the advanced stats table  \n• Merges the per-game and advanced stats DataFrames on the 'Player' column  \n• Drops rows with missing values in the key statistical columns to ensure data quality  \n• Returns the cleaned DataFrame containing per-game stats and advanced stats ('BPM', 'VORP') for each player in the given year"
        },
        "source": "backend",
        "timestamp": "2025-08-23 10:35:33.000",
        "event": "modify_summary_mediation",
        "id": "J0R51WaKAqNqJ9LgtWi6"
    },
    {
        "data": {
            "new_code": "def scrape_season_stats(year):\n    base_url_reg = (\n        f\"https://www.basketball-reference.com/leagues/NBA_{year}_per_game.html\"\n    )\n    base_url_adv = (\n        f\"https://www.basketball-reference.com/leagues/NBA_{year}_advanced.html\"\n    )\n    df_reg = pd.read_html(base_url_reg, header=0)[0]\n    df_adv = pd.read_html(base_url_adv, header=0)[0]\n\n    df_reg = df_reg[df_reg[\"Player\"] != \"Player\"]  # remove repeated header rows\n    df_reg[\"Year\"] = year\n\n    df_reg = df_reg[\n        [\"Player\", \"Year\", \"PTS\", \"AST\", \"TRB\", \"FG%\"]\n    ]  # Keep only specified columns\n\n    df_adv = df_adv[df_adv[\"Player\"] != \"Player\"]  # remove repeated header rows\n    df_adv = df_adv[[\"Player\", \"BPM\", \"VORP\"]]\n\n    df_merged = pd.merge(df_reg, df_adv, on=\"Player\", how=\"inner\")\n\n    df_merged = df_merged.dropna(\n        subset=[\"PTS\", \"AST\", \"TRB\", \"FG%\", \"BPM\", \"VORP\"]\n    )  # Ensure key stats aren't invalid\n    return df_merged",
            "old_summary": {
                "medium_unstructured": "The scrape_season_stats function downloads per-game NBA player statistics for a specified year from Basketball Reference. It removes duplicate header rows, adds the year column, selects key statistical columns, and filters out rows with missing values. The function returns a cleaned DataFrame containing player names, year, and their points, assists, rebounds, and field goal percentage.",
                "low_structured": "• Fetches NBA per-game stats for a specified year\n• Cleans and filters the data\n• Returns selected player statistics",
                "title": "Summary of scrape_season_stats Function",
                "medium_structured": "• Downloads NBA per-game stats for a given year from a specific URL\n• Cleans the data by removing repeated header rows\n• Adds the year as a column to the data\n• Selects only the Player, Year, PTS, AST, TRB, and FG% columns\n• Filters out rows with missing values in key statistical columns",
                "high_unstructured": "The scrape_season_stats function fetches NBA per-game player statistics for a given year from Basketball Reference by constructing the appropriate URL and reading the first HTML table. It cleans the resulting DataFrame by removing any repeated header rows, adds a 'Year' column, and selects only the columns for player name, year, points, assists, rebounds, and field goal percentage. The function further ensures data integrity by dropping any rows with missing values in the key statistical columns. Finally, it returns the cleaned and filtered DataFrame for further analysis or storage.",
                "high_structured": "• Constructs the URL for NBA per-game stats for the specified year\n• Reads the first table from the web page using pandas\n• Cleans the DataFrame:\n  ◦ Removes rows where the 'Player' column is a repeated header\n  ◦ Adds a 'Year' column with the specified year\n• Selects only relevant columns:\n  ◦ 'Player', 'Year', 'PTS', 'AST', 'TRB', and 'FG%'\n• Drops rows with missing values in the key statistical columns to ensure data quality\n• Returns the cleaned DataFrame containing per-game stats for each player in the given year",
                "low_unstructured": "This function retrieves and processes NBA per-game player statistics for a given year."
            },
            "original_code": "def scrape_season_stats(year):\n    base_url_reg = (\n        f\"https://www.basketball-reference.com/leagues/NBA_{year}_per_game.html\"\n    )\n    base_url_adv = (\n        f\"https://www.basketball-reference.com/leagues/NBA_{year}_advanced.html\"\n    )\n    df_reg = pd.read_html(base_url_reg, header=0)[0]\n    df_adv = pd.read_html(base_url_adv, header=0)[0]\n\n    df_reg = df_reg[df_reg[\"Player\"] != \"Player\"]  # remove repeated header rows\n    df_reg[\"Year\"] = year\n\n    df_reg = df_reg[\n        [\"Player\", \"Year\", \"PTS\", \"AST\", \"TRB\", \"FG%\"]\n    ]  # Keep only specified columns\n\n    df_adv = df_adv[df_adv[\"Player\"] != \"Player\"]  # remove repeated header rows\n    df_adv = df_adv[[\"Player\", \"BPM\", \"VORP\"]]\n\n    df_merged = pd.merge(df_reg, df_adv, on=\"Player\", how=\"inner\")\n\n    df_merged = df_merged.dropna(\n        subset=[\"PTS\", \"AST\", \"TRB\", \"FG%\", \"BPM\", \"VORP\"]\n    )  # Ensure key stats aren't invalid\n    return df_merged",
            "new_summary": {
                "medium_unstructured": "The scrape_season_stats function downloads both per-game and advanced NBA player statistics for a specified year from Basketball Reference. In addition to removing duplicate header rows, adding the year column, selecting key statistical columns, and filtering out rows with missing values, the function now also merges the per-game stats with advanced stats (BPM and VORP) for each player and ensures all returned rows have valid values for these advanced metrics.",
                "low_structured": "• Fetches NBA per-game stats and advanced stats for a specified year\n• Cleans and filters both datasets\n• Merges per-game and advanced stats on player name\n• Returns selected player statistics including BPM and VORP",
                "title": "Summary of scrape_season_stats Function (with Advanced Stats Merge)",
                "medium_structured": "• Downloads NBA per-game and advanced stats for a given year from specific URLs\n• Cleans both datasets by removing repeated header rows\n• Adds the year as a column to the per-game data\n• Selects only the Player, Year, PTS, AST, TRB, and FG% columns from per-game stats\n• Selects only the Player, BPM, and VORP columns from advanced stats\n• Merges per-game and advanced stats on player name\n• Filters out rows with missing values in key statistical columns, including BPM and VORP",
                "high_unstructured": "The scrape_season_stats function fetches NBA per-game and advanced player statistics for a given year from Basketball Reference by constructing the appropriate URLs and reading the first HTML tables from both pages. It cleans both resulting DataFrames by removing any repeated header rows, adds a 'Year' column to the per-game stats, and selects only the columns for player name, year, points, assists, rebounds, and field goal percentage from the per-game stats, and player name, BPM, and VORP from the advanced stats. The function then merges the two DataFrames on player name, ensuring that each player has both per-game and advanced statistics, and further ensures data integrity by dropping any rows with missing values in the key statistical columns, including BPM and VORP. Finally, it returns the cleaned and merged DataFrame for further analysis or storage.",
                "high_structured": "• Constructs the URLs for NBA per-game and advanced stats for the specified year\n• Reads the first table from each web page using pandas\n• Cleans both DataFrames:\n  ◦ Removes rows where the 'Player' column is a repeated header\n  ◦ Adds a 'Year' column with the specified year to per-game stats\n• Selects only relevant columns:\n  ◦ Per-game: 'Player', 'Year', 'PTS', 'AST', 'TRB', and 'FG%'\n  ◦ Advanced: 'Player', 'BPM', and 'VORP'\n• Merges per-game and advanced stats on player name (inner join)\n• Drops rows with missing values in all key statistical columns, including 'BPM' and 'VORP', to ensure data quality\n• Returns the cleaned and merged DataFrame containing per-game and advanced stats for each player in the given year",
                "low_unstructured": "This function retrieves and processes NBA per-game player statistics for a given year, and now also merges in advanced stats (BPM and VORP) for each player."
            }
        },
        "source": "backend",
        "timestamp": "2025-08-23 10:35:41.000",
        "event": "summarize_modified_code",
        "id": "ow76Va0c1y7BKW2Gc2or"
    },
    {
        "data": {
            "mapping": [
                {
                    "summaryComponent": "retrieves and processes NBA per-game player statistics for a given year",
                    "codeSegments": [
                        {
                            "line": 22,
                            "code": "def scrape_season_stats(year):"
                        },
                        {
                            "line": 23,
                            "code": "base_url_reg = ("
                        },
                        {
                            "line": 24,
                            "code": "f\"https://www.basketball-reference.com/leagues/NBA_{year}_per_game.html\""
                        },
                        {
                            "line": 29,
                            "code": "df_reg = pd.read_html(base_url_reg, header=0)[0]"
                        },
                        {
                            "line": 32,
                            "code": "df_reg = df_reg[df_reg[\"Player\"] != \"Player\"]  # remove repeated header rows"
                        },
                        {
                            "line": 33,
                            "code": "df_reg[\"Year\"] = year"
                        },
                        {
                            "line": 35,
                            "code": "df_reg = df_reg["
                        },
                        {
                            "line": 36,
                            "code": "[\"Player\", \"Year\", \"PTS\", \"AST\", \"TRB\", \"FG%\"]"
                        }
                    ]
                },
                {
                    "summaryComponent": "now also merges in advanced stats (BPM and VORP) for each player",
                    "codeSegments": [
                        {
                            "line": 26,
                            "code": "base_url_adv = ("
                        },
                        {
                            "line": 27,
                            "code": "f\"https://www.basketball-reference.com/leagues/NBA_{year}_advanced.html\""
                        },
                        {
                            "line": 30,
                            "code": "df_adv = pd.read_html(base_url_adv, header=0)[0]"
                        },
                        {
                            "line": 39,
                            "code": "df_adv = df_adv[df_adv[\"Player\"] != \"Player\"]  # remove repeated header rows"
                        },
                        {
                            "line": 40,
                            "code": "df_adv = df_adv[[\"Player\", \"BPM\", \"VORP\"]]"
                        },
                        {
                            "line": 42,
                            "code": "df_merged = pd.merge(df_reg, df_adv, on=\"Player\", how=\"inner\")"
                        }
                    ]
                }
            ],
            "summary": "This function retrieves and processes NBA per-game player statistics for a given year, and now also merges in advanced stats (BPM and VORP) for each player.",
            "code": "22: def scrape_season_stats(year):\n23:     base_url_reg = (\n24:         f\"https://www.basketball-reference.com/leagues/NBA_{year}_per_game.html\"\n25:     )\n26:     base_url_adv = (\n27:         f\"https://www.basketball-reference.com/leagues/NBA_{year}_advanced.html\"\n28:     )\n29:     df_reg = pd.read_html(base_url_reg, header=0)[0]\n30:     df_adv = pd.read_html(base_url_adv, header=0)[0]\n31: \n32:     df_reg = df_reg[df_reg[\"Player\"] != \"Player\"]  # remove repeated header rows\n33:     df_reg[\"Year\"] = year\n34: \n35:     df_reg = df_reg[\n36:         [\"Player\", \"Year\", \"PTS\", \"AST\", \"TRB\", \"FG%\"]\n37:     ]  # Keep only specified columns\n38: \n39:     df_adv = df_adv[df_adv[\"Player\"] != \"Player\"]  # remove repeated header rows\n40:     df_adv = df_adv[[\"Player\", \"BPM\", \"VORP\"]]\n41: \n42:     df_merged = pd.merge(df_reg, df_adv, on=\"Player\", how=\"inner\")\n43: \n44:     df_merged = df_merged.dropna(\n45:         subset=[\"PTS\", \"AST\", \"TRB\", \"FG%\", \"BPM\", \"VORP\"]\n46:     )  # Ensure key stats aren't invalid\n47:     return df_merged"
        },
        "source": "backend",
        "timestamp": "2025-08-23 10:35:44.000",
        "event": "map_summary_code",
        "id": "DO0lfVDWnJuCnvprsABh"
    },
    {
        "data": {
            "mapping": [
                {
                    "summaryComponent": "Fetches NBA per-game stats and advanced stats for a specified year",
                    "codeSegments": [
                        {
                            "line": 23,
                            "code": "base_url_reg = (\n    f\"https://www.basketball-reference.com/leagues/NBA_{year}_per_game.html\"\n)"
                        },
                        {
                            "line": 26,
                            "code": "base_url_adv = (\n    f\"https://www.basketball-reference.com/leagues/NBA_{year}_advanced.html\"\n)"
                        },
                        {
                            "line": 29,
                            "code": "df_reg = pd.read_html(base_url_reg, header=0)[0]"
                        },
                        {
                            "line": 30,
                            "code": "df_adv = pd.read_html(base_url_adv, header=0)[0]"
                        }
                    ]
                },
                {
                    "summaryComponent": "Cleans and filters both datasets",
                    "codeSegments": [
                        {
                            "line": 32,
                            "code": "df_reg = df_reg[df_reg[\"Player\"] != \"Player\"]  # remove repeated header rows"
                        },
                        {
                            "line": 33,
                            "code": "df_reg[\"Year\"] = year"
                        },
                        {
                            "line": 35,
                            "code": "df_reg = df_reg[\n    [\"Player\", \"Year\", \"PTS\", \"AST\", \"TRB\", \"FG%\"]\n]"
                        },
                        {
                            "line": 39,
                            "code": "df_adv = df_adv[df_adv[\"Player\"] != \"Player\"]  # remove repeated header rows"
                        },
                        {
                            "line": 40,
                            "code": "df_adv = df_adv[[\"Player\", \"BPM\", \"VORP\"]]"
                        }
                    ]
                },
                {
                    "summaryComponent": "Merges per-game and advanced stats on player name",
                    "codeSegments": [
                        {
                            "line": 42,
                            "code": "df_merged = pd.merge(df_reg, df_adv, on=\"Player\", how=\"inner\")"
                        }
                    ]
                },
                {
                    "summaryComponent": "Returns selected player statistics including BPM and VORP",
                    "codeSegments": [
                        {
                            "line": 44,
                            "code": "df_merged = df_merged.dropna(\n    subset=[\"PTS\", \"AST\", \"TRB\", \"FG%\", \"BPM\", \"VORP\"]\n)"
                        },
                        {
                            "line": 47,
                            "code": "return df_merged"
                        }
                    ]
                }
            ],
            "summary": "• Fetches NBA per-game stats and advanced stats for a specified year\n• Cleans and filters both datasets\n• Merges per-game and advanced stats on player name\n• Returns selected player statistics including BPM and VORP",
            "code": "22: def scrape_season_stats(year):\n23:     base_url_reg = (\n24:         f\"https://www.basketball-reference.com/leagues/NBA_{year}_per_game.html\"\n25:     )\n26:     base_url_adv = (\n27:         f\"https://www.basketball-reference.com/leagues/NBA_{year}_advanced.html\"\n28:     )\n29:     df_reg = pd.read_html(base_url_reg, header=0)[0]\n30:     df_adv = pd.read_html(base_url_adv, header=0)[0]\n31: \n32:     df_reg = df_reg[df_reg[\"Player\"] != \"Player\"]  # remove repeated header rows\n33:     df_reg[\"Year\"] = year\n34: \n35:     df_reg = df_reg[\n36:         [\"Player\", \"Year\", \"PTS\", \"AST\", \"TRB\", \"FG%\"]\n37:     ]  # Keep only specified columns\n38: \n39:     df_adv = df_adv[df_adv[\"Player\"] != \"Player\"]  # remove repeated header rows\n40:     df_adv = df_adv[[\"Player\", \"BPM\", \"VORP\"]]\n41: \n42:     df_merged = pd.merge(df_reg, df_adv, on=\"Player\", how=\"inner\")\n43: \n44:     df_merged = df_merged.dropna(\n45:         subset=[\"PTS\", \"AST\", \"TRB\", \"FG%\", \"BPM\", \"VORP\"]\n46:     )  # Ensure key stats aren't invalid\n47:     return df_merged"
        },
        "source": "backend",
        "timestamp": "2025-08-23 10:35:44.000",
        "event": "map_summary_code",
        "id": "RcUZIfCNEDGpzx7pHSxl"
    },
    {
        "data": {
            "mapping": [
                {
                    "summaryComponent": "Downloads NBA per-game and advanced stats for a given year from specific URLs",
                    "codeSegments": [
                        {
                            "line": 23,
                            "code": "base_url_reg = (\n    f\"https://www.basketball-reference.com/leagues/NBA_{year}_per_game.html\""
                        },
                        {
                            "line": 26,
                            "code": "base_url_adv = (\n    f\"https://www.basketball-reference.com/leagues/NBA_{year}_advanced.html\""
                        },
                        {
                            "line": 29,
                            "code": "df_reg = pd.read_html(base_url_reg, header=0)[0]"
                        },
                        {
                            "line": 30,
                            "code": "df_adv = pd.read_html(base_url_adv, header=0)[0]"
                        }
                    ]
                },
                {
                    "summaryComponent": "Cleans both datasets by removing repeated header rows",
                    "codeSegments": [
                        {
                            "line": 32,
                            "code": "df_reg = df_reg[df_reg[\"Player\"] != \"Player\"]  # remove repeated header rows"
                        },
                        {
                            "line": 39,
                            "code": "df_adv = df_adv[df_adv[\"Player\"] != \"Player\"]  # remove repeated header rows"
                        }
                    ]
                },
                {
                    "summaryComponent": "Adds the year as a column to the per-game data",
                    "codeSegments": [
                        {
                            "line": 33,
                            "code": "df_reg[\"Year\"] = year"
                        }
                    ]
                },
                {
                    "summaryComponent": "Selects only the Player, Year, PTS, AST, TRB, and FG% columns from per-game stats",
                    "codeSegments": [
                        {
                            "line": 35,
                            "code": "df_reg = df_reg[\n    [\"Player\", \"Year\", \"PTS\", \"AST\", \"TRB\", \"FG%\"]\n]"
                        }
                    ]
                },
                {
                    "summaryComponent": "Selects only the Player, BPM, and VORP columns from advanced stats",
                    "codeSegments": [
                        {
                            "line": 40,
                            "code": "df_adv = df_adv[[\"Player\", \"BPM\", \"VORP\"]]"
                        }
                    ]
                },
                {
                    "summaryComponent": "Merges per-game and advanced stats on player name",
                    "codeSegments": [
                        {
                            "line": 42,
                            "code": "df_merged = pd.merge(df_reg, df_adv, on=\"Player\", how=\"inner\")"
                        }
                    ]
                },
                {
                    "summaryComponent": "Filters out rows with missing values in key statistical columns, including BPM and VORP",
                    "codeSegments": [
                        {
                            "line": 44,
                            "code": "df_merged = df_merged.dropna(\n    subset=[\"PTS\", \"AST\", \"TRB\", \"FG%\", \"BPM\", \"VORP\"]\n)"
                        }
                    ]
                }
            ],
            "summary": "• Downloads NBA per-game and advanced stats for a given year from specific URLs\n• Cleans both datasets by removing repeated header rows\n• Adds the year as a column to the per-game data\n• Selects only the Player, Year, PTS, AST, TRB, and FG% columns from per-game stats\n• Selects only the Player, BPM, and VORP columns from advanced stats\n• Merges per-game and advanced stats on player name\n• Filters out rows with missing values in key statistical columns, including BPM and VORP",
            "code": "22: def scrape_season_stats(year):\n23:     base_url_reg = (\n24:         f\"https://www.basketball-reference.com/leagues/NBA_{year}_per_game.html\"\n25:     )\n26:     base_url_adv = (\n27:         f\"https://www.basketball-reference.com/leagues/NBA_{year}_advanced.html\"\n28:     )\n29:     df_reg = pd.read_html(base_url_reg, header=0)[0]\n30:     df_adv = pd.read_html(base_url_adv, header=0)[0]\n31: \n32:     df_reg = df_reg[df_reg[\"Player\"] != \"Player\"]  # remove repeated header rows\n33:     df_reg[\"Year\"] = year\n34: \n35:     df_reg = df_reg[\n36:         [\"Player\", \"Year\", \"PTS\", \"AST\", \"TRB\", \"FG%\"]\n37:     ]  # Keep only specified columns\n38: \n39:     df_adv = df_adv[df_adv[\"Player\"] != \"Player\"]  # remove repeated header rows\n40:     df_adv = df_adv[[\"Player\", \"BPM\", \"VORP\"]]\n41: \n42:     df_merged = pd.merge(df_reg, df_adv, on=\"Player\", how=\"inner\")\n43: \n44:     df_merged = df_merged.dropna(\n45:         subset=[\"PTS\", \"AST\", \"TRB\", \"FG%\", \"BPM\", \"VORP\"]\n46:     )  # Ensure key stats aren't invalid\n47:     return df_merged"
        },
        "source": "backend",
        "timestamp": "2025-08-23 10:35:44.000",
        "event": "map_summary_code",
        "id": "lTnBCiP23XmtZ9XWFGe8"
    },
    {
        "data": {
            "mapping": [
                {
                    "summaryComponent": "The scrape_season_stats function",
                    "codeSegments": [
                        {
                            "line": 22,
                            "code": "def scrape_season_stats(year):"
                        }
                    ]
                },
                {
                    "summaryComponent": "downloads both per-game and advanced NBA player statistics for a specified year from Basketball Reference",
                    "codeSegments": [
                        {
                            "line": 23,
                            "code": "base_url_reg = (\n    f\"https://www.basketball-reference.com/leagues/NBA_{year}_per_game.html\"\n)"
                        },
                        {
                            "line": 26,
                            "code": "base_url_adv = (\n    f\"https://www.basketball-reference.com/leagues/NBA_{year}_advanced.html\"\n)"
                        },
                        {
                            "line": 29,
                            "code": "df_reg = pd.read_html(base_url_reg, header=0)[0]"
                        },
                        {
                            "line": 30,
                            "code": "df_adv = pd.read_html(base_url_adv, header=0)[0]"
                        }
                    ]
                },
                {
                    "summaryComponent": "removing duplicate header rows",
                    "codeSegments": [
                        {
                            "line": 32,
                            "code": "df_reg = df_reg[df_reg[\"Player\"] != \"Player\"]  # remove repeated header rows"
                        },
                        {
                            "line": 39,
                            "code": "df_adv = df_adv[df_adv[\"Player\"] != \"Player\"]  # remove repeated header rows"
                        }
                    ]
                },
                {
                    "summaryComponent": "adding the year column",
                    "codeSegments": [
                        {
                            "line": 33,
                            "code": "df_reg[\"Year\"] = year"
                        }
                    ]
                },
                {
                    "summaryComponent": "selecting key statistical columns",
                    "codeSegments": [
                        {
                            "line": 35,
                            "code": "df_reg = df_reg[\n    [\"Player\", \"Year\", \"PTS\", \"AST\", \"TRB\", \"FG%\"]\n]"
                        },
                        {
                            "line": 40,
                            "code": "df_adv = df_adv[[\"Player\", \"BPM\", \"VORP\"]]"
                        }
                    ]
                },
                {
                    "summaryComponent": "filtering out rows with missing values",
                    "codeSegments": [
                        {
                            "line": 44,
                            "code": "df_merged = df_merged.dropna(\n    subset=[\"PTS\", \"AST\", \"TRB\", \"FG%\", \"BPM\", \"VORP\"]\n)"
                        }
                    ]
                },
                {
                    "summaryComponent": "merges the per-game stats with advanced stats (BPM and VORP) for each player",
                    "codeSegments": [
                        {
                            "line": 42,
                            "code": "df_merged = pd.merge(df_reg, df_adv, on=\"Player\", how=\"inner\")"
                        }
                    ]
                },
                {
                    "summaryComponent": "ensures all returned rows have valid values for these advanced metrics",
                    "codeSegments": [
                        {
                            "line": 44,
                            "code": "df_merged = df_merged.dropna(\n    subset=[\"PTS\", \"AST\", \"TRB\", \"FG%\", \"BPM\", \"VORP\"]\n)"
                        }
                    ]
                }
            ],
            "summary": "The scrape_season_stats function downloads both per-game and advanced NBA player statistics for a specified year from Basketball Reference. In addition to removing duplicate header rows, adding the year column, selecting key statistical columns, and filtering out rows with missing values, the function now also merges the per-game stats with advanced stats (BPM and VORP) for each player and ensures all returned rows have valid values for these advanced metrics.",
            "code": "22: def scrape_season_stats(year):\n23:     base_url_reg = (\n24:         f\"https://www.basketball-reference.com/leagues/NBA_{year}_per_game.html\"\n25:     )\n26:     base_url_adv = (\n27:         f\"https://www.basketball-reference.com/leagues/NBA_{year}_advanced.html\"\n28:     )\n29:     df_reg = pd.read_html(base_url_reg, header=0)[0]\n30:     df_adv = pd.read_html(base_url_adv, header=0)[0]\n31: \n32:     df_reg = df_reg[df_reg[\"Player\"] != \"Player\"]  # remove repeated header rows\n33:     df_reg[\"Year\"] = year\n34: \n35:     df_reg = df_reg[\n36:         [\"Player\", \"Year\", \"PTS\", \"AST\", \"TRB\", \"FG%\"]\n37:     ]  # Keep only specified columns\n38: \n39:     df_adv = df_adv[df_adv[\"Player\"] != \"Player\"]  # remove repeated header rows\n40:     df_adv = df_adv[[\"Player\", \"BPM\", \"VORP\"]]\n41: \n42:     df_merged = pd.merge(df_reg, df_adv, on=\"Player\", how=\"inner\")\n43: \n44:     df_merged = df_merged.dropna(\n45:         subset=[\"PTS\", \"AST\", \"TRB\", \"FG%\", \"BPM\", \"VORP\"]\n46:     )  # Ensure key stats aren't invalid\n47:     return df_merged"
        },
        "source": "backend",
        "timestamp": "2025-08-23 10:35:46.000",
        "event": "map_summary_code",
        "id": "3TPg30Q2ej092z0uY8tU"
    },
    {
        "data": {
            "mapping": [
                {
                    "summaryComponent": "Constructs the URLs for NBA per-game and advanced stats for the specified year",
                    "codeSegments": [
                        {
                            "line": 23,
                            "code": "base_url_reg = ("
                        },
                        {
                            "line": 24,
                            "code": "f\"https://www.basketball-reference.com/leagues/NBA_{year}_per_game.html\""
                        },
                        {
                            "line": 26,
                            "code": "base_url_adv = ("
                        },
                        {
                            "line": 27,
                            "code": "f\"https://www.basketball-reference.com/leagues/NBA_{year}_advanced.html\""
                        }
                    ]
                },
                {
                    "summaryComponent": "Reads the first table from each web page using pandas",
                    "codeSegments": [
                        {
                            "line": 29,
                            "code": "df_reg = pd.read_html(base_url_reg, header=0)[0]"
                        },
                        {
                            "line": 30,
                            "code": "df_adv = pd.read_html(base_url_adv, header=0)[0]"
                        }
                    ]
                },
                {
                    "summaryComponent": "Removes rows where the 'Player' column is a repeated header",
                    "codeSegments": [
                        {
                            "line": 32,
                            "code": "df_reg = df_reg[df_reg[\"Player\"] != \"Player\"]  # remove repeated header rows"
                        },
                        {
                            "line": 39,
                            "code": "df_adv = df_adv[df_adv[\"Player\"] != \"Player\"]  # remove repeated header rows"
                        }
                    ]
                },
                {
                    "summaryComponent": "Adds a 'Year' column with the specified year to per-game stats",
                    "codeSegments": [
                        {
                            "line": 33,
                            "code": "df_reg[\"Year\"] = year"
                        }
                    ]
                },
                {
                    "summaryComponent": "Selects only relevant columns",
                    "codeSegments": [
                        {
                            "line": 35,
                            "code": "df_reg = df_reg["
                        },
                        {
                            "line": 36,
                            "code": "[\"Player\", \"Year\", \"PTS\", \"AST\", \"TRB\", \"FG%\"]"
                        },
                        {
                            "line": 40,
                            "code": "df_adv = df_adv[[\"Player\", \"BPM\", \"VORP\"]]"
                        }
                    ]
                },
                {
                    "summaryComponent": "Per-game: 'Player', 'Year', 'PTS', 'AST', 'TRB', and 'FG%'",
                    "codeSegments": [
                        {
                            "line": 36,
                            "code": "[\"Player\", \"Year\", \"PTS\", \"AST\", \"TRB\", \"FG%\"]"
                        }
                    ]
                },
                {
                    "summaryComponent": "Advanced: 'Player', 'BPM', and 'VORP'",
                    "codeSegments": [
                        {
                            "line": 40,
                            "code": "[\"Player\", \"BPM\", \"VORP\"]"
                        }
                    ]
                },
                {
                    "summaryComponent": "Merges per-game and advanced stats on player name (inner join)",
                    "codeSegments": [
                        {
                            "line": 42,
                            "code": "df_merged = pd.merge(df_reg, df_adv, on=\"Player\", how=\"inner\")"
                        }
                    ]
                },
                {
                    "summaryComponent": "Drops rows with missing values in all key statistical columns, including 'BPM' and 'VORP', to ensure data quality",
                    "codeSegments": [
                        {
                            "line": 44,
                            "code": "df_merged = df_merged.dropna("
                        },
                        {
                            "line": 45,
                            "code": "subset=[\"PTS\", \"AST\", \"TRB\", \"FG%\", \"BPM\", \"VORP\"]"
                        }
                    ]
                },
                {
                    "summaryComponent": "Returns the cleaned and merged DataFrame containing per-game and advanced stats for each player in the given year",
                    "codeSegments": [
                        {
                            "line": 47,
                            "code": "return df_merged"
                        }
                    ]
                }
            ],
            "summary": "• Constructs the URLs for NBA per-game and advanced stats for the specified year\n• Reads the first table from each web page using pandas\n• Cleans both DataFrames:\n  ◦ Removes rows where the 'Player' column is a repeated header\n  ◦ Adds a 'Year' column with the specified year to per-game stats\n• Selects only relevant columns:\n  ◦ Per-game: 'Player', 'Year', 'PTS', 'AST', 'TRB', and 'FG%'\n  ◦ Advanced: 'Player', 'BPM', and 'VORP'\n• Merges per-game and advanced stats on player name (inner join)\n• Drops rows with missing values in all key statistical columns, including 'BPM' and 'VORP', to ensure data quality\n• Returns the cleaned and merged DataFrame containing per-game and advanced stats for each player in the given year",
            "code": "22: def scrape_season_stats(year):\n23:     base_url_reg = (\n24:         f\"https://www.basketball-reference.com/leagues/NBA_{year}_per_game.html\"\n25:     )\n26:     base_url_adv = (\n27:         f\"https://www.basketball-reference.com/leagues/NBA_{year}_advanced.html\"\n28:     )\n29:     df_reg = pd.read_html(base_url_reg, header=0)[0]\n30:     df_adv = pd.read_html(base_url_adv, header=0)[0]\n31: \n32:     df_reg = df_reg[df_reg[\"Player\"] != \"Player\"]  # remove repeated header rows\n33:     df_reg[\"Year\"] = year\n34: \n35:     df_reg = df_reg[\n36:         [\"Player\", \"Year\", \"PTS\", \"AST\", \"TRB\", \"FG%\"]\n37:     ]  # Keep only specified columns\n38: \n39:     df_adv = df_adv[df_adv[\"Player\"] != \"Player\"]  # remove repeated header rows\n40:     df_adv = df_adv[[\"Player\", \"BPM\", \"VORP\"]]\n41: \n42:     df_merged = pd.merge(df_reg, df_adv, on=\"Player\", how=\"inner\")\n43: \n44:     df_merged = df_merged.dropna(\n45:         subset=[\"PTS\", \"AST\", \"TRB\", \"FG%\", \"BPM\", \"VORP\"]\n46:     )  # Ensure key stats aren't invalid\n47:     return df_merged"
        },
        "source": "backend",
        "timestamp": "2025-08-23 10:35:46.000",
        "event": "map_summary_code",
        "id": "GbVIc9sSe4ahfhQgEe9P"
    },
    {
        "data": {
            "before_section_id": "dd26b82f-3ef9-4a96-b23d-4bd763ed4331",
            "after_section_id": "a2c3c4f9-25de-4beb-b4d5-c348b1c29d5e"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:35:47.000",
        "event": "autotransit_section",
        "id": "ROc0Scq74ecSXz7FS2oR"
    },
    {
        "data": {
            "mapping": [
                {
                    "summaryComponent": "The scrape_season_stats function",
                    "codeSegments": [
                        {
                            "line": 22,
                            "code": "def scrape_season_stats(year):"
                        }
                    ]
                },
                {
                    "summaryComponent": "fetches NBA per-game and advanced player statistics for a given year from Basketball Reference",
                    "codeSegments": [
                        {
                            "line": 23,
                            "code": "base_url_reg = (\n    f\"https://www.basketball-reference.com/leagues/NBA_{year}_per_game.html\"\n)"
                        },
                        {
                            "line": 26,
                            "code": "base_url_adv = (\n    f\"https://www.basketball-reference.com/leagues/NBA_{year}_advanced.html\"\n)"
                        }
                    ]
                },
                {
                    "summaryComponent": "by constructing the appropriate URLs",
                    "codeSegments": [
                        {
                            "line": 23,
                            "code": "base_url_reg = (\n    f\"https://www.basketball-reference.com/leagues/NBA_{year}_per_game.html\"\n)"
                        },
                        {
                            "line": 26,
                            "code": "base_url_adv = (\n    f\"https://www.basketball-reference.com/leagues/NBA_{year}_advanced.html\"\n)"
                        }
                    ]
                },
                {
                    "summaryComponent": "and reading the first HTML tables from both pages.",
                    "codeSegments": [
                        {
                            "line": 29,
                            "code": "df_reg = pd.read_html(base_url_reg, header=0)[0]"
                        },
                        {
                            "line": 30,
                            "code": "df_adv = pd.read_html(base_url_adv, header=0)[0]"
                        }
                    ]
                },
                {
                    "summaryComponent": "It cleans both resulting DataFrames by removing any repeated header rows",
                    "codeSegments": [
                        {
                            "line": 32,
                            "code": "df_reg = df_reg[df_reg[\"Player\"] != \"Player\"]  # remove repeated header rows"
                        },
                        {
                            "line": 39,
                            "code": "df_adv = df_adv[df_adv[\"Player\"] != \"Player\"]  # remove repeated header rows"
                        }
                    ]
                },
                {
                    "summaryComponent": "adds a 'Year' column to the per-game stats",
                    "codeSegments": [
                        {
                            "line": 33,
                            "code": "df_reg[\"Year\"] = year"
                        }
                    ]
                },
                {
                    "summaryComponent": "and selects only the columns for player name, year, points, assists, rebounds, and field goal percentage from the per-game stats",
                    "codeSegments": [
                        {
                            "line": 35,
                            "code": "df_reg = df_reg[\n    [\"Player\", \"Year\", \"PTS\", \"AST\", \"TRB\", \"FG%\"]\n]"
                        }
                    ]
                },
                {
                    "summaryComponent": "and player name, BPM, and VORP from the advanced stats.",
                    "codeSegments": [
                        {
                            "line": 40,
                            "code": "df_adv = df_adv[[\"Player\", \"BPM\", \"VORP\"]]"
                        }
                    ]
                },
                {
                    "summaryComponent": "The function then merges the two DataFrames on player name, ensuring that each player has both per-game and advanced statistics",
                    "codeSegments": [
                        {
                            "line": 42,
                            "code": "df_merged = pd.merge(df_reg, df_adv, on=\"Player\", how=\"inner\")"
                        }
                    ]
                },
                {
                    "summaryComponent": "and further ensures data integrity by dropping any rows with missing values in the key statistical columns, including BPM and VORP.",
                    "codeSegments": [
                        {
                            "line": 44,
                            "code": "df_merged = df_merged.dropna(\n    subset=[\"PTS\", \"AST\", \"TRB\", \"FG%\", \"BPM\", \"VORP\"]\n)"
                        }
                    ]
                },
                {
                    "summaryComponent": "Finally, it returns the cleaned and merged DataFrame for further analysis or storage.",
                    "codeSegments": [
                        {
                            "line": 47,
                            "code": "return df_merged"
                        }
                    ]
                }
            ],
            "summary": "The scrape_season_stats function fetches NBA per-game and advanced player statistics for a given year from Basketball Reference by constructing the appropriate URLs and reading the first HTML tables from both pages. It cleans both resulting DataFrames by removing any repeated header rows, adds a 'Year' column to the per-game stats, and selects only the columns for player name, year, points, assists, rebounds, and field goal percentage from the per-game stats, and player name, BPM, and VORP from the advanced stats. The function then merges the two DataFrames on player name, ensuring that each player has both per-game and advanced statistics, and further ensures data integrity by dropping any rows with missing values in the key statistical columns, including BPM and VORP. Finally, it returns the cleaned and merged DataFrame for further analysis or storage.",
            "code": "22: def scrape_season_stats(year):\n23:     base_url_reg = (\n24:         f\"https://www.basketball-reference.com/leagues/NBA_{year}_per_game.html\"\n25:     )\n26:     base_url_adv = (\n27:         f\"https://www.basketball-reference.com/leagues/NBA_{year}_advanced.html\"\n28:     )\n29:     df_reg = pd.read_html(base_url_reg, header=0)[0]\n30:     df_adv = pd.read_html(base_url_adv, header=0)[0]\n31: \n32:     df_reg = df_reg[df_reg[\"Player\"] != \"Player\"]  # remove repeated header rows\n33:     df_reg[\"Year\"] = year\n34: \n35:     df_reg = df_reg[\n36:         [\"Player\", \"Year\", \"PTS\", \"AST\", \"TRB\", \"FG%\"]\n37:     ]  # Keep only specified columns\n38: \n39:     df_adv = df_adv[df_adv[\"Player\"] != \"Player\"]  # remove repeated header rows\n40:     df_adv = df_adv[[\"Player\", \"BPM\", \"VORP\"]]\n41: \n42:     df_merged = pd.merge(df_reg, df_adv, on=\"Player\", how=\"inner\")\n43: \n44:     df_merged = df_merged.dropna(\n45:         subset=[\"PTS\", \"AST\", \"TRB\", \"FG%\", \"BPM\", \"VORP\"]\n46:     )  # Ensure key stats aren't invalid\n47:     return df_merged"
        },
        "source": "backend",
        "timestamp": "2025-08-23 10:35:47.000",
        "event": "map_summary_code",
        "id": "XJLihAMsDRhB10APmqlH"
    },
    {
        "data": {
            "section_data": {
                "lines": [
                    22,
                    47
                ],
                "summaryMappings": {
                    "medium_unstructured": [
                        {
                            "summaryComponent": "The scrape_season_stats function",
                            "codeSegments": [
                                {
                                    "line": 22,
                                    "code": "def scrape_season_stats(year):"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "downloads both per-game and advanced NBA player statistics for a specified year from Basketball Reference",
                            "codeSegments": [
                                {
                                    "line": 23,
                                    "code": "base_url_reg = (\n    f\"https://www.basketball-reference.com/leagues/NBA_{year}_per_game.html\"\n)"
                                },
                                {
                                    "line": 26,
                                    "code": "base_url_adv = (\n    f\"https://www.basketball-reference.com/leagues/NBA_{year}_advanced.html\"\n)"
                                },
                                {
                                    "line": 29,
                                    "code": "df_reg = pd.read_html(base_url_reg, header=0)[0]"
                                },
                                {
                                    "line": 30,
                                    "code": "df_adv = pd.read_html(base_url_adv, header=0)[0]"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "removing duplicate header rows",
                            "codeSegments": [
                                {
                                    "line": 32,
                                    "code": "df_reg = df_reg[df_reg[\"Player\"] != \"Player\"]  # remove repeated header rows"
                                },
                                {
                                    "line": 39,
                                    "code": "df_adv = df_adv[df_adv[\"Player\"] != \"Player\"]  # remove repeated header rows"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "adding the year column",
                            "codeSegments": [
                                {
                                    "line": 33,
                                    "code": "df_reg[\"Year\"] = year"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "selecting key statistical columns",
                            "codeSegments": [
                                {
                                    "line": 35,
                                    "code": "df_reg = df_reg[\n    [\"Player\", \"Year\", \"PTS\", \"AST\", \"TRB\", \"FG%\"]\n]"
                                },
                                {
                                    "line": 40,
                                    "code": "df_adv = df_adv[[\"Player\", \"BPM\", \"VORP\"]]"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "filtering out rows with missing values",
                            "codeSegments": [
                                {
                                    "line": 44,
                                    "code": "df_merged = df_merged.dropna(\n    subset=[\"PTS\", \"AST\", \"TRB\", \"FG%\", \"BPM\", \"VORP\"]\n)"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "merges the per-game stats with advanced stats (BPM and VORP) for each player",
                            "codeSegments": [
                                {
                                    "line": 42,
                                    "code": "df_merged = pd.merge(df_reg, df_adv, on=\"Player\", how=\"inner\")"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "ensures all returned rows have valid values for these advanced metrics",
                            "codeSegments": [
                                {
                                    "line": 44,
                                    "code": "df_merged = df_merged.dropna(\n    subset=[\"PTS\", \"AST\", \"TRB\", \"FG%\", \"BPM\", \"VORP\"]\n)"
                                }
                            ]
                        }
                    ],
                    "low_structured": [
                        {
                            "summaryComponent": "Fetches NBA per-game stats and advanced stats for a specified year",
                            "codeSegments": [
                                {
                                    "line": 23,
                                    "code": "base_url_reg = (\n    f\"https://www.basketball-reference.com/leagues/NBA_{year}_per_game.html\"\n)"
                                },
                                {
                                    "line": 26,
                                    "code": "base_url_adv = (\n    f\"https://www.basketball-reference.com/leagues/NBA_{year}_advanced.html\"\n)"
                                },
                                {
                                    "line": 29,
                                    "code": "df_reg = pd.read_html(base_url_reg, header=0)[0]"
                                },
                                {
                                    "line": 30,
                                    "code": "df_adv = pd.read_html(base_url_adv, header=0)[0]"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "Cleans and filters both datasets",
                            "codeSegments": [
                                {
                                    "line": 32,
                                    "code": "df_reg = df_reg[df_reg[\"Player\"] != \"Player\"]  # remove repeated header rows"
                                },
                                {
                                    "line": 33,
                                    "code": "df_reg[\"Year\"] = year"
                                },
                                {
                                    "line": 35,
                                    "code": "df_reg = df_reg[\n    [\"Player\", \"Year\", \"PTS\", \"AST\", \"TRB\", \"FG%\"]\n]"
                                },
                                {
                                    "line": 39,
                                    "code": "df_adv = df_adv[df_adv[\"Player\"] != \"Player\"]  # remove repeated header rows"
                                },
                                {
                                    "line": 40,
                                    "code": "df_adv = df_adv[[\"Player\", \"BPM\", \"VORP\"]]"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "Merges per-game and advanced stats on player name",
                            "codeSegments": [
                                {
                                    "line": 42,
                                    "code": "df_merged = pd.merge(df_reg, df_adv, on=\"Player\", how=\"inner\")"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "Returns selected player statistics including BPM and VORP",
                            "codeSegments": [
                                {
                                    "line": 44,
                                    "code": "df_merged = df_merged.dropna(\n    subset=[\"PTS\", \"AST\", \"TRB\", \"FG%\", \"BPM\", \"VORP\"]\n)"
                                },
                                {
                                    "line": 47,
                                    "code": "return df_merged"
                                }
                            ]
                        }
                    ],
                    "low_unstructured": [
                        {
                            "summaryComponent": "retrieves and processes NBA per-game player statistics for a given year",
                            "codeSegments": [
                                {
                                    "line": 22,
                                    "code": "def scrape_season_stats(year):"
                                },
                                {
                                    "line": 23,
                                    "code": "base_url_reg = ("
                                },
                                {
                                    "line": 24,
                                    "code": "f\"https://www.basketball-reference.com/leagues/NBA_{year}_per_game.html\""
                                },
                                {
                                    "line": 29,
                                    "code": "df_reg = pd.read_html(base_url_reg, header=0)[0]"
                                },
                                {
                                    "line": 32,
                                    "code": "df_reg = df_reg[df_reg[\"Player\"] != \"Player\"]  # remove repeated header rows"
                                },
                                {
                                    "line": 33,
                                    "code": "df_reg[\"Year\"] = year"
                                },
                                {
                                    "line": 35,
                                    "code": "df_reg = df_reg["
                                },
                                {
                                    "line": 36,
                                    "code": "[\"Player\", \"Year\", \"PTS\", \"AST\", \"TRB\", \"FG%\"]"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "now also merges in advanced stats (BPM and VORP) for each player",
                            "codeSegments": [
                                {
                                    "line": 26,
                                    "code": "base_url_adv = ("
                                },
                                {
                                    "line": 27,
                                    "code": "f\"https://www.basketball-reference.com/leagues/NBA_{year}_advanced.html\""
                                },
                                {
                                    "line": 30,
                                    "code": "df_adv = pd.read_html(base_url_adv, header=0)[0]"
                                },
                                {
                                    "line": 39,
                                    "code": "df_adv = df_adv[df_adv[\"Player\"] != \"Player\"]  # remove repeated header rows"
                                },
                                {
                                    "line": 40,
                                    "code": "df_adv = df_adv[[\"Player\", \"BPM\", \"VORP\"]]"
                                },
                                {
                                    "line": 42,
                                    "code": "df_merged = pd.merge(df_reg, df_adv, on=\"Player\", how=\"inner\")"
                                }
                            ]
                        }
                    ],
                    "medium_structured": [
                        {
                            "summaryComponent": "Downloads NBA per-game and advanced stats for a given year from specific URLs",
                            "codeSegments": [
                                {
                                    "line": 23,
                                    "code": "base_url_reg = (\n    f\"https://www.basketball-reference.com/leagues/NBA_{year}_per_game.html\""
                                },
                                {
                                    "line": 26,
                                    "code": "base_url_adv = (\n    f\"https://www.basketball-reference.com/leagues/NBA_{year}_advanced.html\""
                                },
                                {
                                    "line": 29,
                                    "code": "df_reg = pd.read_html(base_url_reg, header=0)[0]"
                                },
                                {
                                    "line": 30,
                                    "code": "df_adv = pd.read_html(base_url_adv, header=0)[0]"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "Cleans both datasets by removing repeated header rows",
                            "codeSegments": [
                                {
                                    "line": 32,
                                    "code": "df_reg = df_reg[df_reg[\"Player\"] != \"Player\"]  # remove repeated header rows"
                                },
                                {
                                    "line": 39,
                                    "code": "df_adv = df_adv[df_adv[\"Player\"] != \"Player\"]  # remove repeated header rows"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "Adds the year as a column to the per-game data",
                            "codeSegments": [
                                {
                                    "line": 33,
                                    "code": "df_reg[\"Year\"] = year"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "Selects only the Player, Year, PTS, AST, TRB, and FG% columns from per-game stats",
                            "codeSegments": [
                                {
                                    "line": 35,
                                    "code": "df_reg = df_reg[\n    [\"Player\", \"Year\", \"PTS\", \"AST\", \"TRB\", \"FG%\"]\n]"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "Selects only the Player, BPM, and VORP columns from advanced stats",
                            "codeSegments": [
                                {
                                    "line": 40,
                                    "code": "df_adv = df_adv[[\"Player\", \"BPM\", \"VORP\"]]"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "Merges per-game and advanced stats on player name",
                            "codeSegments": [
                                {
                                    "line": 42,
                                    "code": "df_merged = pd.merge(df_reg, df_adv, on=\"Player\", how=\"inner\")"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "Filters out rows with missing values in key statistical columns, including BPM and VORP",
                            "codeSegments": [
                                {
                                    "line": 44,
                                    "code": "df_merged = df_merged.dropna(\n    subset=[\"PTS\", \"AST\", \"TRB\", \"FG%\", \"BPM\", \"VORP\"]\n)"
                                }
                            ]
                        }
                    ],
                    "high_unstructured": [
                        {
                            "summaryComponent": "The scrape_season_stats function",
                            "codeSegments": [
                                {
                                    "line": 22,
                                    "code": "def scrape_season_stats(year):"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "fetches NBA per-game and advanced player statistics for a given year from Basketball Reference",
                            "codeSegments": [
                                {
                                    "line": 23,
                                    "code": "base_url_reg = (\n    f\"https://www.basketball-reference.com/leagues/NBA_{year}_per_game.html\"\n)"
                                },
                                {
                                    "line": 26,
                                    "code": "base_url_adv = (\n    f\"https://www.basketball-reference.com/leagues/NBA_{year}_advanced.html\"\n)"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "by constructing the appropriate URLs",
                            "codeSegments": [
                                {
                                    "line": 23,
                                    "code": "base_url_reg = (\n    f\"https://www.basketball-reference.com/leagues/NBA_{year}_per_game.html\"\n)"
                                },
                                {
                                    "line": 26,
                                    "code": "base_url_adv = (\n    f\"https://www.basketball-reference.com/leagues/NBA_{year}_advanced.html\"\n)"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "and reading the first HTML tables from both pages.",
                            "codeSegments": [
                                {
                                    "line": 29,
                                    "code": "df_reg = pd.read_html(base_url_reg, header=0)[0]"
                                },
                                {
                                    "line": 30,
                                    "code": "df_adv = pd.read_html(base_url_adv, header=0)[0]"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "It cleans both resulting DataFrames by removing any repeated header rows",
                            "codeSegments": [
                                {
                                    "line": 32,
                                    "code": "df_reg = df_reg[df_reg[\"Player\"] != \"Player\"]  # remove repeated header rows"
                                },
                                {
                                    "line": 39,
                                    "code": "df_adv = df_adv[df_adv[\"Player\"] != \"Player\"]  # remove repeated header rows"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "adds a 'Year' column to the per-game stats",
                            "codeSegments": [
                                {
                                    "line": 33,
                                    "code": "df_reg[\"Year\"] = year"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "and selects only the columns for player name, year, points, assists, rebounds, and field goal percentage from the per-game stats",
                            "codeSegments": [
                                {
                                    "line": 35,
                                    "code": "df_reg = df_reg[\n    [\"Player\", \"Year\", \"PTS\", \"AST\", \"TRB\", \"FG%\"]\n]"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "and player name, BPM, and VORP from the advanced stats.",
                            "codeSegments": [
                                {
                                    "line": 40,
                                    "code": "df_adv = df_adv[[\"Player\", \"BPM\", \"VORP\"]]"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "The function then merges the two DataFrames on player name, ensuring that each player has both per-game and advanced statistics",
                            "codeSegments": [
                                {
                                    "line": 42,
                                    "code": "df_merged = pd.merge(df_reg, df_adv, on=\"Player\", how=\"inner\")"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "and further ensures data integrity by dropping any rows with missing values in the key statistical columns, including BPM and VORP.",
                            "codeSegments": [
                                {
                                    "line": 44,
                                    "code": "df_merged = df_merged.dropna(\n    subset=[\"PTS\", \"AST\", \"TRB\", \"FG%\", \"BPM\", \"VORP\"]\n)"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "Finally, it returns the cleaned and merged DataFrame for further analysis or storage.",
                            "codeSegments": [
                                {
                                    "line": 47,
                                    "code": "return df_merged"
                                }
                            ]
                        }
                    ],
                    "high_structured": [
                        {
                            "summaryComponent": "Constructs the URLs for NBA per-game and advanced stats for the specified year",
                            "codeSegments": [
                                {
                                    "line": 23,
                                    "code": "base_url_reg = ("
                                },
                                {
                                    "line": 24,
                                    "code": "f\"https://www.basketball-reference.com/leagues/NBA_{year}_per_game.html\""
                                },
                                {
                                    "line": 26,
                                    "code": "base_url_adv = ("
                                },
                                {
                                    "line": 27,
                                    "code": "f\"https://www.basketball-reference.com/leagues/NBA_{year}_advanced.html\""
                                }
                            ]
                        },
                        {
                            "summaryComponent": "Reads the first table from each web page using pandas",
                            "codeSegments": [
                                {
                                    "line": 29,
                                    "code": "df_reg = pd.read_html(base_url_reg, header=0)[0]"
                                },
                                {
                                    "line": 30,
                                    "code": "df_adv = pd.read_html(base_url_adv, header=0)[0]"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "Removes rows where the 'Player' column is a repeated header",
                            "codeSegments": [
                                {
                                    "line": 32,
                                    "code": "df_reg = df_reg[df_reg[\"Player\"] != \"Player\"]  # remove repeated header rows"
                                },
                                {
                                    "line": 39,
                                    "code": "df_adv = df_adv[df_adv[\"Player\"] != \"Player\"]  # remove repeated header rows"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "Adds a 'Year' column with the specified year to per-game stats",
                            "codeSegments": [
                                {
                                    "line": 33,
                                    "code": "df_reg[\"Year\"] = year"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "Selects only relevant columns",
                            "codeSegments": [
                                {
                                    "line": 35,
                                    "code": "df_reg = df_reg["
                                },
                                {
                                    "line": 36,
                                    "code": "[\"Player\", \"Year\", \"PTS\", \"AST\", \"TRB\", \"FG%\"]"
                                },
                                {
                                    "line": 40,
                                    "code": "df_adv = df_adv[[\"Player\", \"BPM\", \"VORP\"]]"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "Per-game: 'Player', 'Year', 'PTS', 'AST', 'TRB', and 'FG%'",
                            "codeSegments": [
                                {
                                    "line": 36,
                                    "code": "[\"Player\", \"Year\", \"PTS\", \"AST\", \"TRB\", \"FG%\"]"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "Advanced: 'Player', 'BPM', and 'VORP'",
                            "codeSegments": [
                                {
                                    "line": 40,
                                    "code": "[\"Player\", \"BPM\", \"VORP\"]"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "Merges per-game and advanced stats on player name (inner join)",
                            "codeSegments": [
                                {
                                    "line": 42,
                                    "code": "df_merged = pd.merge(df_reg, df_adv, on=\"Player\", how=\"inner\")"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "Drops rows with missing values in all key statistical columns, including 'BPM' and 'VORP', to ensure data quality",
                            "codeSegments": [
                                {
                                    "line": 44,
                                    "code": "df_merged = df_merged.dropna("
                                },
                                {
                                    "line": 45,
                                    "code": "subset=[\"PTS\", \"AST\", \"TRB\", \"FG%\", \"BPM\", \"VORP\"]"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "Returns the cleaned and merged DataFrame containing per-game and advanced stats for each player in the given year",
                            "codeSegments": [
                                {
                                    "line": 47,
                                    "code": "return df_merged"
                                }
                            ]
                        }
                    ]
                },
                "summaryData": {
                    "medium_unstructured": "The scrape_season_stats function downloads both per-game and advanced NBA player statistics for a specified year from Basketball Reference. In addition to removing duplicate header rows, adding the year column, selecting key statistical columns, and filtering out rows with missing values, the function now also merges the per-game stats with advanced stats (BPM and VORP) for each player and ensures all returned rows have valid values for these advanced metrics.",
                    "low_structured": "• Fetches NBA per-game stats and advanced stats for a specified year\n• Cleans and filters both datasets\n• Merges per-game and advanced stats on player name\n• Returns selected player statistics including BPM and VORP",
                    "title": "Summary of scrape_season_stats Function (with Advanced Stats Merge)",
                    "medium_structured": "• Downloads NBA per-game and advanced stats for a given year from specific URLs\n• Cleans both datasets by removing repeated header rows\n• Adds the year as a column to the per-game data\n• Selects only the Player, Year, PTS, AST, TRB, and FG% columns from per-game stats\n• Selects only the Player, BPM, and VORP columns from advanced stats\n• Merges per-game and advanced stats on player name\n• Filters out rows with missing values in key statistical columns, including BPM and VORP",
                    "high_unstructured": "The scrape_season_stats function fetches NBA per-game and advanced player statistics for a given year from Basketball Reference by constructing the appropriate URLs and reading the first HTML tables from both pages. It cleans both resulting DataFrames by removing any repeated header rows, adds a 'Year' column to the per-game stats, and selects only the columns for player name, year, points, assists, rebounds, and field goal percentage from the per-game stats, and player name, BPM, and VORP from the advanced stats. The function then merges the two DataFrames on player name, ensuring that each player has both per-game and advanced statistics, and further ensures data integrity by dropping any rows with missing values in the key statistical columns, including BPM and VORP. Finally, it returns the cleaned and merged DataFrame for further analysis or storage.",
                    "high_structured": "• Constructs the URLs for NBA per-game and advanced stats for the specified year\n• Reads the first table from each web page using pandas\n• Cleans both DataFrames:\n  ◦ Removes rows where the 'Player' column is a repeated header\n  ◦ Adds a 'Year' column with the specified year to per-game stats\n• Selects only relevant columns:\n  ◦ Per-game: 'Player', 'Year', 'PTS', 'AST', 'TRB', and 'FG%'\n  ◦ Advanced: 'Player', 'BPM', and 'VORP'\n• Merges per-game and advanced stats on player name (inner join)\n• Drops rows with missing values in all key statistical columns, including 'BPM' and 'VORP', to ensure data quality\n• Returns the cleaned and merged DataFrame containing per-game and advanced stats for each player in the given year",
                    "low_unstructured": "This function retrieves and processes NBA per-game player statistics for a given year, and now also merges in advanced stats (BPM and VORP) for each player."
                },
                "editPromptStructured": null,
                "createdAt": 1755974147000,
                "metadata": {
                    "filename": "scraper.py",
                    "id": "a2c3c4f9-25de-4beb-b4d5-c348b1c29d5e",
                    "originalCode": "def scrape_season_stats(year):\n    base_url_reg = (\n        f\"https://www.basketball-reference.com/leagues/NBA_{year}_per_game.html\"\n    )\n    base_url_adv = (\n        f\"https://www.basketball-reference.com/leagues/NBA_{year}_advanced.html\"\n    )\n    df_reg = pd.read_html(base_url_reg, header=0)[0]\n    df_adv = pd.read_html(base_url_adv, header=0)[0]\n\n    df_reg = df_reg[df_reg[\"Player\"] != \"Player\"]  # remove repeated header rows\n    df_reg[\"Year\"] = year\n\n    df_reg = df_reg[\n        [\"Player\", \"Year\", \"PTS\", \"AST\", \"TRB\", \"FG%\"]\n    ]  # Keep only specified columns\n\n    df_adv = df_adv[df_adv[\"Player\"] != \"Player\"]  # remove repeated header rows\n    df_adv = df_adv[[\"Player\", \"BPM\", \"VORP\"]]\n\n    df_merged = pd.merge(df_reg, df_adv, on=\"Player\", how=\"inner\")\n\n    df_merged = df_merged.dropna(\n        subset=[\"PTS\", \"AST\", \"TRB\", \"FG%\", \"BPM\", \"VORP\"]\n    )  # Ensure key stats aren't invalid\n    return df_merged",
                    "fullPath": "/project/workspace/scraper.py",
                    "offset": 652
                },
                "selectedStructured": "unstructured",
                "title": "Summary of scrape_season_stats Function (with Advanced Stats Merge)",
                "selectedDetailLevel": "medium",
                "oldSummaryData": {
                    "medium_unstructured": "The scrape_season_stats function downloads per-game NBA player statistics for a specified year from Basketball Reference. It removes duplicate header rows, adds the year column, selects key statistical columns, and filters out rows with missing values. The function returns a cleaned DataFrame containing player names, year, and their points, assists, rebounds, and field goal percentage.",
                    "low_structured": "• Fetches NBA per-game stats for a specified year\n• Cleans and filters the data\n• Returns selected player statistics",
                    "title": "Summary of scrape_season_stats Function",
                    "medium_structured": "• Downloads NBA per-game stats for a given year from a specific URL\n• Cleans the data by removing repeated header rows\n• Adds the year as a column to the data\n• Selects only the Player, Year, PTS, AST, TRB, and FG% columns\n• Filters out rows with missing values in key statistical columns",
                    "high_unstructured": "The scrape_season_stats function fetches NBA per-game player statistics for a given year from Basketball Reference by constructing the appropriate URL and reading the first HTML table. It cleans the resulting DataFrame by removing any repeated header rows, adds a 'Year' column, and selects only the columns for player name, year, points, assists, rebounds, and field goal percentage. The function further ensures data integrity by dropping any rows with missing values in the key statistical columns. Finally, it returns the cleaned and filtered DataFrame for further analysis or storage.",
                    "high_structured": "• Constructs the URL for NBA per-game stats for the specified year\n• Reads the first table from the web page using pandas\n• Cleans the DataFrame:\n  ◦ Removes rows where the 'Player' column is a repeated header\n  ◦ Adds a 'Year' column with the specified year\n• Selects only relevant columns:\n  ◦ 'Player', 'Year', 'PTS', 'AST', 'TRB', and 'FG%'\n• Drops rows with missing values in the key statistical columns to ensure data quality\n• Returns the cleaned DataFrame containing per-game stats for each player in the given year",
                    "low_unstructured": "This function retrieves and processes NBA per-game player statistics for a given year."
                },
                "editPromptValue": "",
                "editPromptDetailLevel": null
            },
            "section_id": "a2c3c4f9-25de-4beb-b4d5-c348b1c29d5e"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:35:47.000",
        "event": "create_new_section",
        "id": "p9pXiwew0yGaPySlfRa7"
    },
    {
        "data": {
            "before_section_id": "a2c3c4f9-25de-4beb-b4d5-c348b1c29d5e",
            "after_section_id": "7b7cba0f-406c-4c39-a0a1-3c518d1de307"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:36:00.000",
        "event": "toggle_section",
        "id": "VwFrGcKUpoHjAN59k0A3"
    },
    {
        "data": {
            "mapping_index": 3,
            "structured_type": "structured",
            "section_id": "7b7cba0f-406c-4c39-a0a1-3c518d1de307",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:36:02.000",
        "event": "mapping_hover",
        "id": "MG9MV88NFM9W7JS3xRYx"
    },
    {
        "data": {
            "structured_type": "structured",
            "section_id": "7b7cba0f-406c-4c39-a0a1-3c518d1de307",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:36:02.000",
        "event": "mapping_unhover",
        "id": "lqqaKuhlGRiZgor0BPlm"
    },
    {
        "data": {
            "mapping_index": 1,
            "structured_type": "structured",
            "section_id": "7b7cba0f-406c-4c39-a0a1-3c518d1de307",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:36:03.000",
        "event": "mapping_hover",
        "id": "EmblyMk2NMqS5M8suUOk"
    },
    {
        "data": {
            "mapping_index": 0,
            "structured_type": "structured",
            "section_id": "7b7cba0f-406c-4c39-a0a1-3c518d1de307",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:36:03.000",
        "event": "mapping_hover",
        "id": "ErHkZDEV1Lq7hZmHQ8OP"
    },
    {
        "data": {
            "structured_type": "structured",
            "section_id": "7b7cba0f-406c-4c39-a0a1-3c518d1de307",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:36:03.000",
        "event": "mapping_unhover",
        "id": "aJtg5pRi21gSO6KsZ5bo"
    },
    {
        "data": {
            "structured_type": "structured",
            "section_id": "7b7cba0f-406c-4c39-a0a1-3c518d1de307",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:36:03.000",
        "event": "mapping_unhover",
        "id": "fNOTWH1a8IDoufGeWyZE"
    },
    {
        "data": {
            "before_section_id": "7b7cba0f-406c-4c39-a0a1-3c518d1de307",
            "after_section_id": "8db82967-cfa0-4d1a-a525-e4d0af3d7867"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:36:05.000",
        "event": "toggle_section",
        "id": "VnlwbqBDXZj7UgM9Tr54"
    },
    {
        "data": {
            "before_section_id": "8db82967-cfa0-4d1a-a525-e4d0af3d7867",
            "after_section_id": "dd26b82f-3ef9-4a96-b23d-4bd763ed4331"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:36:07.000",
        "event": "toggle_section",
        "id": "S710kpyZsL9DzZxIEwem"
    },
    {
        "data": {
            "mapping_index": 0,
            "structured_type": "structured",
            "section_id": "dd26b82f-3ef9-4a96-b23d-4bd763ed4331",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:36:21.000",
        "event": "mapping_hover",
        "id": "IIZ7ZLEuJDTZDfeMO6Lp"
    },
    {
        "data": {
            "structured_type": "structured",
            "section_id": "dd26b82f-3ef9-4a96-b23d-4bd763ed4331",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:36:22.000",
        "event": "mapping_unhover",
        "id": "F6gadcN6eNA7oV1JzLRf"
    },
    {
        "data": {
            "before_section_id": "dd26b82f-3ef9-4a96-b23d-4bd763ed4331",
            "after_section_id": null
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:36:22.000",
        "event": "toggle_section",
        "id": "UIwr6dTcyKIY6W0317M6"
    },
    {
        "data": {
            "before_section_id": null,
            "after_section_id": "a2c3c4f9-25de-4beb-b4d5-c348b1c29d5e"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:36:33.000",
        "event": "toggle_section",
        "id": "KDjvt7l6BtoNuN1FlB3B"
    },
    {
        "data": {
            "mapping_index": 1,
            "structured_type": "unstructured",
            "section_id": "a2c3c4f9-25de-4beb-b4d5-c348b1c29d5e",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:37:26.000",
        "event": "mapping_hover",
        "id": "2uGQPrcCB3U41OM9Et8y"
    },
    {
        "data": {
            "structured_type": "unstructured",
            "section_id": "a2c3c4f9-25de-4beb-b4d5-c348b1c29d5e",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:37:27.000",
        "event": "mapping_unhover",
        "id": "L0b1JdJI32LtsQYDGDt9"
    },
    {
        "data": {},
        "source": "frontend",
        "timestamp": "2025-08-23 10:38:59.000",
        "event": "click_summarize_code",
        "id": "E4prxsZoX0wpdx82KKMk"
    },
    {
        "data": {
            "selected_code": "import pandas as pd\nfrom xgboost import XGBRanker\nfrom sklearn.metrics import ndcg_score\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport seaborn as sns\n\n\ndef load_data(path=\"data/merged_data.csv\"):\n    df = pd.read_csv(path)\n\n    # Features to use\n    feature_cols = [\n        \"PTS\",\n        \"AST\",\n        \"TRB\",\n        \"FG%\",\n        \"BPM\",\n        \"WS/48\",\n        \"TS%\",\n        \"VORP\",\n        \"WS\",\n        \"PER\",\n    ]\n    feature_cols = [\n        col for col in feature_cols if col in df.columns\n    ]  # only keep existing features\n    df = df.dropna(subset=feature_cols + [\"Rank\"])\n\n    # Sort by Year and Rank for consistency\n    df = df.sort_values(by=[\"Year\", \"Rank\"])\n\n    X = df[feature_cols]\n    y = df[\"Rank\"]\n    groups = df.groupby(\"Year\").size().to_numpy()\n\n    return X, y, groups, df\n\n\ndef evaluate_ndcg(y_true, y_pred, group_sizes):\n    scores = []\n    start = 0\n    for size in group_sizes:\n        true_ranks = y_true[start : start + size]\n        true_relevance = (max(true_ranks) + 1) - true_ranks\n        pred_scores = y_pred[start : start + size]\n        scores.append(ndcg_score([true_relevance], [pred_scores]))\n        start += size\n    return np.mean(scores)\n\n\ndef plot_ranking_predictions(df, year):\n    \"\"\"\n    Plot prediction error for a specific year.\n\n    Args:\n        df: DataFrame containing prediction results\n        year: Year to plot prediction errors for\n    \"\"\"\n    df[\"RankError\"] = df[\"PredictedRank\"] - df[\"Rank\"]\n    year_df = df[df[\"Year\"] == year].copy()\n    year_df.sort_values(\"Rank\", inplace=True)\n\n    plt.figure(figsize=(12, 6))\n    sns.barplot(x=\"Name\", y=\"RankError\", data=year_df, hue=\"Name\", palette=\"coolwarm\")\n    plt.axhline(0, color=\"black\", linestyle=\"--\")\n    plt.xticks(rotation=45, ha=\"right\")\n    plt.ylabel(\"Predicted Rank - True Rank\")\n    plt.title(f\"MVP Ranking Predictions ({year})\")\n    plt.tight_layout()\n    plt.savefig(f\"data/ranking_predictions_{year}.png\")\n\n\ndef main():\n    X, y, group, df = load_data()\n\n    # Train-test split on years\n    unique_years = df[\"Year\"].unique()\n    train_years, test_years = (\n        unique_years[:-2],  # train: 2015-2023\n        unique_years[-2:],  # test: 2024-2025\n    )\n\n    train_idx = df[\"Year\"].isin(train_years)\n    test_idx = df[\"Year\"].isin(test_years)\n\n    X_train, X_test = X[train_idx], X[test_idx]\n    y_train, y_test = y[train_idx], y[test_idx]\n\n    # Group sizes\n    train_groups = df[train_idx].groupby(\"Year\").size().to_numpy()\n    test_groups = df[test_idx].groupby(\"Year\").size().to_numpy()\n\n    # Model\n    model = XGBRanker(\n        objective=\"rank:pairwise\",\n        learning_rate=0.1,\n        n_estimators=100,\n        max_depth=4,\n        random_state=42,\n    )\n\n    print(\"Training XGBoostRanker...\")\n    model.fit(X_train, y_train, group=train_groups)\n\n    # Predict, sort, and evaluate\n    y_pred = model.predict(X_test)\n    df.loc[test_idx, \"PredictedScore\"] = y_pred\n    df.loc[test_idx, \"PredictedRank\"] = (\n        df.loc[test_idx]\n        .groupby(\"Year\")[\"PredictedScore\"]\n        .rank(ascending=False, method=\"first\")\n    )\n\n    ndcg = evaluate_ndcg(y_test.to_numpy(), y_pred, test_groups)\n    print(f\"NDCG Score on test years {test_years.tolist()}: {ndcg:.4f}\")\n\n    # Show results\n    print(df[test_idx][[\"Year\", \"Name\", \"Rank\", \"PredictedScore\", \"PredictedRank\"]])\n    plot_ranking_predictions(df, 2024)\n    plot_ranking_predictions(df, 2025)\n\n\nif __name__ == \"__main__\":\n    main()\n",
            "summary": {
                "medium_unstructured": "The script loads and preprocesses basketball player data, selecting relevant features and handling missing values. It trains an XGBoostRanker model to predict MVP rankings, evaluates its performance using the NDCG metric, and visualizes prediction errors for recent years. Results and plots are saved for further analysis.",
                "low_structured": "• Loads and preprocesses basketball data\n• Trains and evaluates an XGBoost ranking model\n• Visualizes prediction errors for MVP rankings",
                "title": "MVP Ranking Prediction Using XGBoostRanker",
                "medium_structured": "• Loads and cleans basketball player data from a CSV file\n• Selects relevant statistical features and removes incomplete rows\n• Trains an XGBoostRanker model to predict player rankings\n• Evaluates the model using the NDCG score\n• Visualizes and saves prediction error plots for the most recent years",
                "high_unstructured": "This code imports and preprocesses basketball player data, selecting a set of statistical features and ensuring completeness by dropping rows with missing values. It sorts the data by year and rank, splits it into training and testing sets based on years, and groups data for ranking tasks. An XGBoostRanker model is trained to predict MVP rankings, and its performance is evaluated using the NDCG score, which measures ranking quality. The script also generates and saves bar plots visualizing the prediction errors for each player in the most recent years, providing insights into the model's accuracy.",
                "high_structured": "• Loads basketball player data from a CSV file\n  ◦ Selects statistical features (e.g., PTS, AST, TRB, etc.) present in the data\n  ◦ Drops rows with missing values in selected features or rank\n  ◦ Sorts data by year and rank for consistency\n• Splits the data into training (all but last two years) and testing sets (last two years)\n  ◦ Determines group sizes for each year for ranking purposes\n• Trains an XGBoostRanker model with specified hyperparameters (pairwise ranking objective, learning rate, etc.)\n• Predicts MVP rankings for the test years and assigns predicted scores and ranks\n• Evaluates model performance using the NDCG metric, averaged across test years\n• Visualizes prediction errors by generating and saving bar plots for each player in the test years, highlighting differences between predicted and true ranks",
                "low_unstructured": "This code loads basketball data, trains an XGBoost ranking model, evaluates its performance, and visualizes prediction errors for MVP rankings."
            }
        },
        "source": "backend",
        "timestamp": "2025-08-23 10:39:14.000",
        "event": "summarize_selected_code",
        "id": "gd16WcfFf7qwx4RpgGq3"
    },
    {
        "data": {
            "mapping": [
                {
                    "summaryComponent": "Loads and preprocesses basketball data",
                    "codeSegments": [
                        {
                            "line": 9,
                            "code": "def load_data(path=\"data/merged_data.csv\"):"
                        },
                        {
                            "line": 10,
                            "code": "df = pd.read_csv(path)"
                        },
                        {
                            "line": 13,
                            "code": "feature_cols = ["
                        },
                        {
                            "line": 25,
                            "code": "feature_cols = ["
                        },
                        {
                            "line": 28,
                            "code": "df = df.dropna(subset=feature_cols + [\"Rank\"])"
                        },
                        {
                            "line": 31,
                            "code": "df = df.sort_values(by=[\"Year\", \"Rank\"])"
                        }
                    ]
                },
                {
                    "summaryComponent": "Trains and evaluates an XGBoost ranking model",
                    "codeSegments": [
                        {
                            "line": 95,
                            "code": "model = XGBRanker("
                        },
                        {
                            "line": 104,
                            "code": "model.fit(X_train, y_train, group=train_groups)"
                        },
                        {
                            "line": 107,
                            "code": "y_pred = model.predict(X_test)"
                        },
                        {
                            "line": 115,
                            "code": "ndcg = evaluate_ndcg(y_test.to_numpy(), y_pred, test_groups)"
                        }
                    ]
                },
                {
                    "summaryComponent": "Visualizes prediction errors for MVP rankings",
                    "codeSegments": [
                        {
                            "line": 52,
                            "code": "def plot_ranking_predictions(df, year):"
                        },
                        {
                            "line": 120,
                            "code": "plot_ranking_predictions(df, 2024)"
                        },
                        {
                            "line": 121,
                            "code": "plot_ranking_predictions(df, 2025)"
                        }
                    ]
                }
            ],
            "summary": "• Loads and preprocesses basketball data\n• Trains and evaluates an XGBoost ranking model\n• Visualizes prediction errors for MVP rankings",
            "code": "1: import pandas as pd\n2: from xgboost import XGBRanker\n3: from sklearn.metrics import ndcg_score\n4: import numpy as np\n5: import matplotlib.pyplot as plt\n6: import seaborn as sns\n7: \n8: \n9: def load_data(path=\"data/merged_data.csv\"):\n10:     df = pd.read_csv(path)\n11: \n12:     # Features to use\n13:     feature_cols = [\n14:         \"PTS\",\n15:         \"AST\",\n16:         \"TRB\",\n17:         \"FG%\",\n18:         \"BPM\",\n19:         \"WS/48\",\n20:         \"TS%\",\n21:         \"VORP\",\n22:         \"WS\",\n23:         \"PER\",\n24:     ]\n25:     feature_cols = [\n26:         col for col in feature_cols if col in df.columns\n27:     ]  # only keep existing features\n28:     df = df.dropna(subset=feature_cols + [\"Rank\"])\n29: \n30:     # Sort by Year and Rank for consistency\n31:     df = df.sort_values(by=[\"Year\", \"Rank\"])\n32: \n33:     X = df[feature_cols]\n34:     y = df[\"Rank\"]\n35:     groups = df.groupby(\"Year\").size().to_numpy()\n36: \n37:     return X, y, groups, df\n38: \n39: \n40: def evaluate_ndcg(y_true, y_pred, group_sizes):\n41:     scores = []\n42:     start = 0\n43:     for size in group_sizes:\n44:         true_ranks = y_true[start : start + size]\n45:         true_relevance = (max(true_ranks) + 1) - true_ranks\n46:         pred_scores = y_pred[start : start + size]\n47:         scores.append(ndcg_score([true_relevance], [pred_scores]))\n48:         start += size\n49:     return np.mean(scores)\n50: \n51: \n52: def plot_ranking_predictions(df, year):\n53:     \"\"\"\n54:     Plot prediction error for a specific year.\n55: \n56:     Args:\n57:         df: DataFrame containing prediction results\n58:         year: Year to plot prediction errors for\n59:     \"\"\"\n60:     df[\"RankError\"] = df[\"PredictedRank\"] - df[\"Rank\"]\n61:     year_df = df[df[\"Year\"] == year].copy()\n62:     year_df.sort_values(\"Rank\", inplace=True)\n63: \n64:     plt.figure(figsize=(12, 6))\n65:     sns.barplot(x=\"Name\", y=\"RankError\", data=year_df, hue=\"Name\", palette=\"coolwarm\")\n66:     plt.axhline(0, color=\"black\", linestyle=\"--\")\n67:     plt.xticks(rotation=45, ha=\"right\")\n68:     plt.ylabel(\"Predicted Rank - True Rank\")\n69:     plt.title(f\"MVP Ranking Predictions ({year})\")\n70:     plt.tight_layout()\n71:     plt.savefig(f\"data/ranking_predictions_{year}.png\")\n72: \n73: \n74: def main():\n75:     X, y, group, df = load_data()\n76: \n77:     # Train-test split on years\n78:     unique_years = df[\"Year\"].unique()\n79:     train_years, test_years = (\n80:         unique_years[:-2],  # train: 2015-2023\n81:         unique_years[-2:],  # test: 2024-2025\n82:     )\n83: \n84:     train_idx = df[\"Year\"].isin(train_years)\n85:     test_idx = df[\"Year\"].isin(test_years)\n86: \n87:     X_train, X_test = X[train_idx], X[test_idx]\n88:     y_train, y_test = y[train_idx], y[test_idx]\n89: \n90:     # Group sizes\n91:     train_groups = df[train_idx].groupby(\"Year\").size().to_numpy()\n92:     test_groups = df[test_idx].groupby(\"Year\").size().to_numpy()\n93: \n94:     # Model\n95:     model = XGBRanker(\n96:         objective=\"rank:pairwise\",\n97:         learning_rate=0.1,\n98:         n_estimators=100,\n99:         max_depth=4,\n100:         random_state=42,\n101:     )\n102: \n103:     print(\"Training XGBoostRanker...\")\n104:     model.fit(X_train, y_train, group=train_groups)\n105: \n106:     # Predict, sort, and evaluate\n107:     y_pred = model.predict(X_test)\n108:     df.loc[test_idx, \"PredictedScore\"] = y_pred\n109:     df.loc[test_idx, \"PredictedRank\"] = (\n110:         df.loc[test_idx]\n111:         .groupby(\"Year\")[\"PredictedScore\"]\n112:         .rank(ascending=False, method=\"first\")\n113:     )\n114: \n115:     ndcg = evaluate_ndcg(y_test.to_numpy(), y_pred, test_groups)\n116:     print(f\"NDCG Score on test years {test_years.tolist()}: {ndcg:.4f}\")\n117: \n118:     # Show results\n119:     print(df[test_idx][[\"Year\", \"Name\", \"Rank\", \"PredictedScore\", \"PredictedRank\"]])\n120:     plot_ranking_predictions(df, 2024)\n121:     plot_ranking_predictions(df, 2025)\n122: \n123: \n124: if __name__ == \"__main__\":\n125:     main()\n126: "
        },
        "source": "backend",
        "timestamp": "2025-08-23 10:39:16.000",
        "event": "map_summary_code",
        "id": "VT3qXmTx8YBhRqawSfwr"
    },
    {
        "data": {
            "mapping": [
                {
                    "summaryComponent": "loads and preprocesses basketball player data",
                    "codeSegments": [
                        {
                            "line": 9,
                            "code": "def load_data(path=\"data/merged_data.csv\"):"
                        },
                        {
                            "line": 10,
                            "code": "df = pd.read_csv(path)"
                        }
                    ]
                },
                {
                    "summaryComponent": "selecting relevant features",
                    "codeSegments": [
                        {
                            "line": 13,
                            "code": "feature_cols = ["
                        },
                        {
                            "line": 25,
                            "code": "feature_cols = ["
                        }
                    ]
                },
                {
                    "summaryComponent": "handling missing values",
                    "codeSegments": [
                        {
                            "line": 28,
                            "code": "df = df.dropna(subset=feature_cols + [\"Rank\"])"
                        }
                    ]
                },
                {
                    "summaryComponent": "trains an XGBoostRanker model",
                    "codeSegments": [
                        {
                            "line": 95,
                            "code": "model = XGBRanker("
                        },
                        {
                            "line": 104,
                            "code": "model.fit(X_train, y_train, group=train_groups)"
                        }
                    ]
                },
                {
                    "summaryComponent": "to predict MVP rankings",
                    "codeSegments": [
                        {
                            "line": 107,
                            "code": "y_pred = model.predict(X_test)"
                        },
                        {
                            "line": 109,
                            "code": "df.loc[test_idx, \"PredictedRank\"] = ("
                        }
                    ]
                },
                {
                    "summaryComponent": "evaluates its performance using the NDCG metric",
                    "codeSegments": [
                        {
                            "line": 115,
                            "code": "ndcg = evaluate_ndcg(y_test.to_numpy(), y_pred, test_groups)"
                        }
                    ]
                },
                {
                    "summaryComponent": "visualizes prediction errors for recent years",
                    "codeSegments": [
                        {
                            "line": 120,
                            "code": "plot_ranking_predictions(df, 2024)"
                        },
                        {
                            "line": 121,
                            "code": "plot_ranking_predictions(df, 2025)"
                        }
                    ]
                },
                {
                    "summaryComponent": "Results and plots are saved for further analysis",
                    "codeSegments": [
                        {
                            "line": 71,
                            "code": "plt.savefig(f\"data/ranking_predictions_{year}.png\")"
                        }
                    ]
                }
            ],
            "summary": "The script loads and preprocesses basketball player data, selecting relevant features and handling missing values. It trains an XGBoostRanker model to predict MVP rankings, evaluates its performance using the NDCG metric, and visualizes prediction errors for recent years. Results and plots are saved for further analysis.",
            "code": "1: import pandas as pd\n2: from xgboost import XGBRanker\n3: from sklearn.metrics import ndcg_score\n4: import numpy as np\n5: import matplotlib.pyplot as plt\n6: import seaborn as sns\n7: \n8: \n9: def load_data(path=\"data/merged_data.csv\"):\n10:     df = pd.read_csv(path)\n11: \n12:     # Features to use\n13:     feature_cols = [\n14:         \"PTS\",\n15:         \"AST\",\n16:         \"TRB\",\n17:         \"FG%\",\n18:         \"BPM\",\n19:         \"WS/48\",\n20:         \"TS%\",\n21:         \"VORP\",\n22:         \"WS\",\n23:         \"PER\",\n24:     ]\n25:     feature_cols = [\n26:         col for col in feature_cols if col in df.columns\n27:     ]  # only keep existing features\n28:     df = df.dropna(subset=feature_cols + [\"Rank\"])\n29: \n30:     # Sort by Year and Rank for consistency\n31:     df = df.sort_values(by=[\"Year\", \"Rank\"])\n32: \n33:     X = df[feature_cols]\n34:     y = df[\"Rank\"]\n35:     groups = df.groupby(\"Year\").size().to_numpy()\n36: \n37:     return X, y, groups, df\n38: \n39: \n40: def evaluate_ndcg(y_true, y_pred, group_sizes):\n41:     scores = []\n42:     start = 0\n43:     for size in group_sizes:\n44:         true_ranks = y_true[start : start + size]\n45:         true_relevance = (max(true_ranks) + 1) - true_ranks\n46:         pred_scores = y_pred[start : start + size]\n47:         scores.append(ndcg_score([true_relevance], [pred_scores]))\n48:         start += size\n49:     return np.mean(scores)\n50: \n51: \n52: def plot_ranking_predictions(df, year):\n53:     \"\"\"\n54:     Plot prediction error for a specific year.\n55: \n56:     Args:\n57:         df: DataFrame containing prediction results\n58:         year: Year to plot prediction errors for\n59:     \"\"\"\n60:     df[\"RankError\"] = df[\"PredictedRank\"] - df[\"Rank\"]\n61:     year_df = df[df[\"Year\"] == year].copy()\n62:     year_df.sort_values(\"Rank\", inplace=True)\n63: \n64:     plt.figure(figsize=(12, 6))\n65:     sns.barplot(x=\"Name\", y=\"RankError\", data=year_df, hue=\"Name\", palette=\"coolwarm\")\n66:     plt.axhline(0, color=\"black\", linestyle=\"--\")\n67:     plt.xticks(rotation=45, ha=\"right\")\n68:     plt.ylabel(\"Predicted Rank - True Rank\")\n69:     plt.title(f\"MVP Ranking Predictions ({year})\")\n70:     plt.tight_layout()\n71:     plt.savefig(f\"data/ranking_predictions_{year}.png\")\n72: \n73: \n74: def main():\n75:     X, y, group, df = load_data()\n76: \n77:     # Train-test split on years\n78:     unique_years = df[\"Year\"].unique()\n79:     train_years, test_years = (\n80:         unique_years[:-2],  # train: 2015-2023\n81:         unique_years[-2:],  # test: 2024-2025\n82:     )\n83: \n84:     train_idx = df[\"Year\"].isin(train_years)\n85:     test_idx = df[\"Year\"].isin(test_years)\n86: \n87:     X_train, X_test = X[train_idx], X[test_idx]\n88:     y_train, y_test = y[train_idx], y[test_idx]\n89: \n90:     # Group sizes\n91:     train_groups = df[train_idx].groupby(\"Year\").size().to_numpy()\n92:     test_groups = df[test_idx].groupby(\"Year\").size().to_numpy()\n93: \n94:     # Model\n95:     model = XGBRanker(\n96:         objective=\"rank:pairwise\",\n97:         learning_rate=0.1,\n98:         n_estimators=100,\n99:         max_depth=4,\n100:         random_state=42,\n101:     )\n102: \n103:     print(\"Training XGBoostRanker...\")\n104:     model.fit(X_train, y_train, group=train_groups)\n105: \n106:     # Predict, sort, and evaluate\n107:     y_pred = model.predict(X_test)\n108:     df.loc[test_idx, \"PredictedScore\"] = y_pred\n109:     df.loc[test_idx, \"PredictedRank\"] = (\n110:         df.loc[test_idx]\n111:         .groupby(\"Year\")[\"PredictedScore\"]\n112:         .rank(ascending=False, method=\"first\")\n113:     )\n114: \n115:     ndcg = evaluate_ndcg(y_test.to_numpy(), y_pred, test_groups)\n116:     print(f\"NDCG Score on test years {test_years.tolist()}: {ndcg:.4f}\")\n117: \n118:     # Show results\n119:     print(df[test_idx][[\"Year\", \"Name\", \"Rank\", \"PredictedScore\", \"PredictedRank\"]])\n120:     plot_ranking_predictions(df, 2024)\n121:     plot_ranking_predictions(df, 2025)\n122: \n123: \n124: if __name__ == \"__main__\":\n125:     main()\n126: "
        },
        "source": "backend",
        "timestamp": "2025-08-23 10:39:17.000",
        "event": "map_summary_code",
        "id": "Mo8esFZvGu48llyPXPD9"
    },
    {
        "data": {
            "mapping": [
                {
                    "summaryComponent": "Loads and cleans basketball player data from a CSV file",
                    "codeSegments": [
                        {
                            "line": 9,
                            "code": "def load_data(path=\"data/merged_data.csv\"):"
                        },
                        {
                            "line": 10,
                            "code": "df = pd.read_csv(path)"
                        },
                        {
                            "line": 28,
                            "code": "df = df.dropna(subset=feature_cols + [\"Rank\"])"
                        }
                    ]
                },
                {
                    "summaryComponent": "Selects relevant statistical features and removes incomplete rows",
                    "codeSegments": [
                        {
                            "line": 13,
                            "code": "feature_cols = ["
                        },
                        {
                            "line": 25,
                            "code": "feature_cols = ["
                        },
                        {
                            "line": 26,
                            "code": "col for col in feature_cols if col in df.columns"
                        },
                        {
                            "line": 28,
                            "code": "df = df.dropna(subset=feature_cols + [\"Rank\"])"
                        }
                    ]
                },
                {
                    "summaryComponent": "Trains an XGBoostRanker model to predict player rankings",
                    "codeSegments": [
                        {
                            "line": 95,
                            "code": "model = XGBRanker("
                        },
                        {
                            "line": 104,
                            "code": "model.fit(X_train, y_train, group=train_groups)"
                        }
                    ]
                },
                {
                    "summaryComponent": "Evaluates the model using the NDCG score",
                    "codeSegments": [
                        {
                            "line": 40,
                            "code": "def evaluate_ndcg(y_true, y_pred, group_sizes):"
                        },
                        {
                            "line": 115,
                            "code": "ndcg = evaluate_ndcg(y_test.to_numpy(), y_pred, test_groups)"
                        }
                    ]
                },
                {
                    "summaryComponent": "Visualizes and saves prediction error plots for the most recent years",
                    "codeSegments": [
                        {
                            "line": 52,
                            "code": "def plot_ranking_predictions(df, year):"
                        },
                        {
                            "line": 71,
                            "code": "plt.savefig(f\"data/ranking_predictions_{year}.png\")"
                        },
                        {
                            "line": 120,
                            "code": "plot_ranking_predictions(df, 2024)"
                        },
                        {
                            "line": 121,
                            "code": "plot_ranking_predictions(df, 2025)"
                        }
                    ]
                }
            ],
            "summary": "• Loads and cleans basketball player data from a CSV file\n• Selects relevant statistical features and removes incomplete rows\n• Trains an XGBoostRanker model to predict player rankings\n• Evaluates the model using the NDCG score\n• Visualizes and saves prediction error plots for the most recent years",
            "code": "1: import pandas as pd\n2: from xgboost import XGBRanker\n3: from sklearn.metrics import ndcg_score\n4: import numpy as np\n5: import matplotlib.pyplot as plt\n6: import seaborn as sns\n7: \n8: \n9: def load_data(path=\"data/merged_data.csv\"):\n10:     df = pd.read_csv(path)\n11: \n12:     # Features to use\n13:     feature_cols = [\n14:         \"PTS\",\n15:         \"AST\",\n16:         \"TRB\",\n17:         \"FG%\",\n18:         \"BPM\",\n19:         \"WS/48\",\n20:         \"TS%\",\n21:         \"VORP\",\n22:         \"WS\",\n23:         \"PER\",\n24:     ]\n25:     feature_cols = [\n26:         col for col in feature_cols if col in df.columns\n27:     ]  # only keep existing features\n28:     df = df.dropna(subset=feature_cols + [\"Rank\"])\n29: \n30:     # Sort by Year and Rank for consistency\n31:     df = df.sort_values(by=[\"Year\", \"Rank\"])\n32: \n33:     X = df[feature_cols]\n34:     y = df[\"Rank\"]\n35:     groups = df.groupby(\"Year\").size().to_numpy()\n36: \n37:     return X, y, groups, df\n38: \n39: \n40: def evaluate_ndcg(y_true, y_pred, group_sizes):\n41:     scores = []\n42:     start = 0\n43:     for size in group_sizes:\n44:         true_ranks = y_true[start : start + size]\n45:         true_relevance = (max(true_ranks) + 1) - true_ranks\n46:         pred_scores = y_pred[start : start + size]\n47:         scores.append(ndcg_score([true_relevance], [pred_scores]))\n48:         start += size\n49:     return np.mean(scores)\n50: \n51: \n52: def plot_ranking_predictions(df, year):\n53:     \"\"\"\n54:     Plot prediction error for a specific year.\n55: \n56:     Args:\n57:         df: DataFrame containing prediction results\n58:         year: Year to plot prediction errors for\n59:     \"\"\"\n60:     df[\"RankError\"] = df[\"PredictedRank\"] - df[\"Rank\"]\n61:     year_df = df[df[\"Year\"] == year].copy()\n62:     year_df.sort_values(\"Rank\", inplace=True)\n63: \n64:     plt.figure(figsize=(12, 6))\n65:     sns.barplot(x=\"Name\", y=\"RankError\", data=year_df, hue=\"Name\", palette=\"coolwarm\")\n66:     plt.axhline(0, color=\"black\", linestyle=\"--\")\n67:     plt.xticks(rotation=45, ha=\"right\")\n68:     plt.ylabel(\"Predicted Rank - True Rank\")\n69:     plt.title(f\"MVP Ranking Predictions ({year})\")\n70:     plt.tight_layout()\n71:     plt.savefig(f\"data/ranking_predictions_{year}.png\")\n72: \n73: \n74: def main():\n75:     X, y, group, df = load_data()\n76: \n77:     # Train-test split on years\n78:     unique_years = df[\"Year\"].unique()\n79:     train_years, test_years = (\n80:         unique_years[:-2],  # train: 2015-2023\n81:         unique_years[-2:],  # test: 2024-2025\n82:     )\n83: \n84:     train_idx = df[\"Year\"].isin(train_years)\n85:     test_idx = df[\"Year\"].isin(test_years)\n86: \n87:     X_train, X_test = X[train_idx], X[test_idx]\n88:     y_train, y_test = y[train_idx], y[test_idx]\n89: \n90:     # Group sizes\n91:     train_groups = df[train_idx].groupby(\"Year\").size().to_numpy()\n92:     test_groups = df[test_idx].groupby(\"Year\").size().to_numpy()\n93: \n94:     # Model\n95:     model = XGBRanker(\n96:         objective=\"rank:pairwise\",\n97:         learning_rate=0.1,\n98:         n_estimators=100,\n99:         max_depth=4,\n100:         random_state=42,\n101:     )\n102: \n103:     print(\"Training XGBoostRanker...\")\n104:     model.fit(X_train, y_train, group=train_groups)\n105: \n106:     # Predict, sort, and evaluate\n107:     y_pred = model.predict(X_test)\n108:     df.loc[test_idx, \"PredictedScore\"] = y_pred\n109:     df.loc[test_idx, \"PredictedRank\"] = (\n110:         df.loc[test_idx]\n111:         .groupby(\"Year\")[\"PredictedScore\"]\n112:         .rank(ascending=False, method=\"first\")\n113:     )\n114: \n115:     ndcg = evaluate_ndcg(y_test.to_numpy(), y_pred, test_groups)\n116:     print(f\"NDCG Score on test years {test_years.tolist()}: {ndcg:.4f}\")\n117: \n118:     # Show results\n119:     print(df[test_idx][[\"Year\", \"Name\", \"Rank\", \"PredictedScore\", \"PredictedRank\"]])\n120:     plot_ranking_predictions(df, 2024)\n121:     plot_ranking_predictions(df, 2025)\n122: \n123: \n124: if __name__ == \"__main__\":\n125:     main()\n126: "
        },
        "source": "backend",
        "timestamp": "2025-08-23 10:39:18.000",
        "event": "map_summary_code",
        "id": "mKXCysWQLqMMgg7fWX5g"
    },
    {
        "data": {
            "mapping": [
                {
                    "summaryComponent": "loads basketball data",
                    "codeSegments": [
                        {
                            "line": 9,
                            "code": "def load_data(path=\"data/merged_data.csv\"):"
                        },
                        {
                            "line": 10,
                            "code": "df = pd.read_csv(path)"
                        },
                        {
                            "line": 75,
                            "code": "X, y, groups, df = load_data()"
                        }
                    ]
                },
                {
                    "summaryComponent": "trains an XGBoost ranking model",
                    "codeSegments": [
                        {
                            "line": 95,
                            "code": "model = XGBRanker("
                        },
                        {
                            "line": 104,
                            "code": "model.fit(X_train, y_train, group=train_groups)"
                        }
                    ]
                },
                {
                    "summaryComponent": "evaluates its performance",
                    "codeSegments": [
                        {
                            "line": 115,
                            "code": "ndcg = evaluate_ndcg(y_test.to_numpy(), y_pred, test_groups)"
                        },
                        {
                            "line": 116,
                            "code": "print(f\"NDCG Score on test years {test_years.tolist()}: {ndcg:.4f}\")"
                        }
                    ]
                },
                {
                    "summaryComponent": "visualizes prediction errors for MVP rankings",
                    "codeSegments": [
                        {
                            "line": 120,
                            "code": "plot_ranking_predictions(df, 2024)"
                        },
                        {
                            "line": 121,
                            "code": "plot_ranking_predictions(df, 2025)"
                        }
                    ]
                }
            ],
            "summary": "This code loads basketball data, trains an XGBoost ranking model, evaluates its performance, and visualizes prediction errors for MVP rankings.",
            "code": "1: import pandas as pd\n2: from xgboost import XGBRanker\n3: from sklearn.metrics import ndcg_score\n4: import numpy as np\n5: import matplotlib.pyplot as plt\n6: import seaborn as sns\n7: \n8: \n9: def load_data(path=\"data/merged_data.csv\"):\n10:     df = pd.read_csv(path)\n11: \n12:     # Features to use\n13:     feature_cols = [\n14:         \"PTS\",\n15:         \"AST\",\n16:         \"TRB\",\n17:         \"FG%\",\n18:         \"BPM\",\n19:         \"WS/48\",\n20:         \"TS%\",\n21:         \"VORP\",\n22:         \"WS\",\n23:         \"PER\",\n24:     ]\n25:     feature_cols = [\n26:         col for col in feature_cols if col in df.columns\n27:     ]  # only keep existing features\n28:     df = df.dropna(subset=feature_cols + [\"Rank\"])\n29: \n30:     # Sort by Year and Rank for consistency\n31:     df = df.sort_values(by=[\"Year\", \"Rank\"])\n32: \n33:     X = df[feature_cols]\n34:     y = df[\"Rank\"]\n35:     groups = df.groupby(\"Year\").size().to_numpy()\n36: \n37:     return X, y, groups, df\n38: \n39: \n40: def evaluate_ndcg(y_true, y_pred, group_sizes):\n41:     scores = []\n42:     start = 0\n43:     for size in group_sizes:\n44:         true_ranks = y_true[start : start + size]\n45:         true_relevance = (max(true_ranks) + 1) - true_ranks\n46:         pred_scores = y_pred[start : start + size]\n47:         scores.append(ndcg_score([true_relevance], [pred_scores]))\n48:         start += size\n49:     return np.mean(scores)\n50: \n51: \n52: def plot_ranking_predictions(df, year):\n53:     \"\"\"\n54:     Plot prediction error for a specific year.\n55: \n56:     Args:\n57:         df: DataFrame containing prediction results\n58:         year: Year to plot prediction errors for\n59:     \"\"\"\n60:     df[\"RankError\"] = df[\"PredictedRank\"] - df[\"Rank\"]\n61:     year_df = df[df[\"Year\"] == year].copy()\n62:     year_df.sort_values(\"Rank\", inplace=True)\n63: \n64:     plt.figure(figsize=(12, 6))\n65:     sns.barplot(x=\"Name\", y=\"RankError\", data=year_df, hue=\"Name\", palette=\"coolwarm\")\n66:     plt.axhline(0, color=\"black\", linestyle=\"--\")\n67:     plt.xticks(rotation=45, ha=\"right\")\n68:     plt.ylabel(\"Predicted Rank - True Rank\")\n69:     plt.title(f\"MVP Ranking Predictions ({year})\")\n70:     plt.tight_layout()\n71:     plt.savefig(f\"data/ranking_predictions_{year}.png\")\n72: \n73: \n74: def main():\n75:     X, y, group, df = load_data()\n76: \n77:     # Train-test split on years\n78:     unique_years = df[\"Year\"].unique()\n79:     train_years, test_years = (\n80:         unique_years[:-2],  # train: 2015-2023\n81:         unique_years[-2:],  # test: 2024-2025\n82:     )\n83: \n84:     train_idx = df[\"Year\"].isin(train_years)\n85:     test_idx = df[\"Year\"].isin(test_years)\n86: \n87:     X_train, X_test = X[train_idx], X[test_idx]\n88:     y_train, y_test = y[train_idx], y[test_idx]\n89: \n90:     # Group sizes\n91:     train_groups = df[train_idx].groupby(\"Year\").size().to_numpy()\n92:     test_groups = df[test_idx].groupby(\"Year\").size().to_numpy()\n93: \n94:     # Model\n95:     model = XGBRanker(\n96:         objective=\"rank:pairwise\",\n97:         learning_rate=0.1,\n98:         n_estimators=100,\n99:         max_depth=4,\n100:         random_state=42,\n101:     )\n102: \n103:     print(\"Training XGBoostRanker...\")\n104:     model.fit(X_train, y_train, group=train_groups)\n105: \n106:     # Predict, sort, and evaluate\n107:     y_pred = model.predict(X_test)\n108:     df.loc[test_idx, \"PredictedScore\"] = y_pred\n109:     df.loc[test_idx, \"PredictedRank\"] = (\n110:         df.loc[test_idx]\n111:         .groupby(\"Year\")[\"PredictedScore\"]\n112:         .rank(ascending=False, method=\"first\")\n113:     )\n114: \n115:     ndcg = evaluate_ndcg(y_test.to_numpy(), y_pred, test_groups)\n116:     print(f\"NDCG Score on test years {test_years.tolist()}: {ndcg:.4f}\")\n117: \n118:     # Show results\n119:     print(df[test_idx][[\"Year\", \"Name\", \"Rank\", \"PredictedScore\", \"PredictedRank\"]])\n120:     plot_ranking_predictions(df, 2024)\n121:     plot_ranking_predictions(df, 2025)\n122: \n123: \n124: if __name__ == \"__main__\":\n125:     main()\n126: "
        },
        "source": "backend",
        "timestamp": "2025-08-23 10:39:19.000",
        "event": "map_summary_code",
        "id": "e3uFYolxSgu2uamywMkJ"
    },
    {
        "data": {
            "mapping": [
                {
                    "summaryComponent": "Loads basketball player data from a CSV file",
                    "codeSegments": [
                        {
                            "line": 9,
                            "code": "def load_data(path=\"data/merged_data.csv\"):"
                        },
                        {
                            "line": 10,
                            "code": "df = pd.read_csv(path)"
                        }
                    ]
                },
                {
                    "summaryComponent": "Selects statistical features (e.g., PTS, AST, TRB, etc.) present in the data",
                    "codeSegments": [
                        {
                            "line": 13,
                            "code": "feature_cols = ["
                        },
                        {
                            "line": 26,
                            "code": "col for col in feature_cols if col in df.columns"
                        }
                    ]
                },
                {
                    "summaryComponent": "Drops rows with missing values in selected features or rank",
                    "codeSegments": [
                        {
                            "line": 28,
                            "code": "df = df.dropna(subset=feature_cols + [\"Rank\"])"
                        }
                    ]
                },
                {
                    "summaryComponent": "Sorts data by year and rank for consistency",
                    "codeSegments": [
                        {
                            "line": 31,
                            "code": "df = df.sort_values(by=[\"Year\", \"Rank\"])"
                        }
                    ]
                },
                {
                    "summaryComponent": "Splits the data into training (all but last two years) and testing sets (last two years)",
                    "codeSegments": [
                        {
                            "line": 78,
                            "code": "unique_years = df[\"Year\"].unique()"
                        },
                        {
                            "line": 79,
                            "code": "train_years, test_years = ("
                        },
                        {
                            "line": 84,
                            "code": "train_idx = df[\"Year\"].isin(train_years)"
                        },
                        {
                            "line": 85,
                            "code": "test_idx = df[\"Year\"].isin(test_years)"
                        },
                        {
                            "line": 87,
                            "code": "X_train, X_test = X[train_idx], X[test_idx]"
                        },
                        {
                            "line": 88,
                            "code": "y_train, y_test = y[train_idx], y[test_idx]"
                        }
                    ]
                },
                {
                    "summaryComponent": "Determines group sizes for each year for ranking purposes",
                    "codeSegments": [
                        {
                            "line": 91,
                            "code": "train_groups = df[train_idx].groupby(\"Year\").size().to_numpy()"
                        },
                        {
                            "line": 92,
                            "code": "test_groups = df[test_idx].groupby(\"Year\").size().to_numpy()"
                        }
                    ]
                },
                {
                    "summaryComponent": "Trains an XGBoostRanker model with specified hyperparameters (pairwise ranking objective, learning rate, etc.)",
                    "codeSegments": [
                        {
                            "line": 95,
                            "code": "model = XGBRanker("
                        },
                        {
                            "line": 96,
                            "code": "objective=\"rank:pairwise\","
                        },
                        {
                            "line": 97,
                            "code": "learning_rate=0.1,"
                        },
                        {
                            "line": 98,
                            "code": "n_estimators=100,"
                        },
                        {
                            "line": 99,
                            "code": "max_depth=4,"
                        },
                        {
                            "line": 100,
                            "code": "random_state=42,"
                        },
                        {
                            "line": 104,
                            "code": "model.fit(X_train, y_train, group=train_groups)"
                        }
                    ]
                },
                {
                    "summaryComponent": "Predicts MVP rankings for the test years and assigns predicted scores and ranks",
                    "codeSegments": [
                        {
                            "line": 107,
                            "code": "y_pred = model.predict(X_test)"
                        },
                        {
                            "line": 108,
                            "code": "df.loc[test_idx, \"PredictedScore\"] = y_pred"
                        },
                        {
                            "line": 109,
                            "code": "df.loc[test_idx, \"PredictedRank\"] = ("
                        }
                    ]
                },
                {
                    "summaryComponent": "Evaluates model performance using the NDCG metric, averaged across test years",
                    "codeSegments": [
                        {
                            "line": 115,
                            "code": "ndcg = evaluate_ndcg(y_test.to_numpy(), y_pred, test_groups)"
                        }
                    ]
                },
                {
                    "summaryComponent": "Visualizes prediction errors by generating and saving bar plots for each player in the test years, highlighting differences between predicted and true ranks",
                    "codeSegments": [
                        {
                            "line": 120,
                            "code": "plot_ranking_predictions(df, 2024)"
                        },
                        {
                            "line": 121,
                            "code": "plot_ranking_predictions(df, 2025)"
                        },
                        {
                            "line": 52,
                            "code": "def plot_ranking_predictions(df, year):"
                        },
                        {
                            "line": 60,
                            "code": "df[\"RankError\"] = df[\"PredictedRank\"] - df[\"Rank\"]"
                        },
                        {
                            "line": 65,
                            "code": "sns.barplot(x=\"Name\", y=\"RankError\", data=year_df, hue=\"Name\", palette=\"coolwarm\")"
                        },
                        {
                            "line": 71,
                            "code": "plt.savefig(f\"data/ranking_predictions_{year}.png\")"
                        }
                    ]
                }
            ],
            "summary": "• Loads basketball player data from a CSV file\n  ◦ Selects statistical features (e.g., PTS, AST, TRB, etc.) present in the data\n  ◦ Drops rows with missing values in selected features or rank\n  ◦ Sorts data by year and rank for consistency\n• Splits the data into training (all but last two years) and testing sets (last two years)\n  ◦ Determines group sizes for each year for ranking purposes\n• Trains an XGBoostRanker model with specified hyperparameters (pairwise ranking objective, learning rate, etc.)\n• Predicts MVP rankings for the test years and assigns predicted scores and ranks\n• Evaluates model performance using the NDCG metric, averaged across test years\n• Visualizes prediction errors by generating and saving bar plots for each player in the test years, highlighting differences between predicted and true ranks",
            "code": "1: import pandas as pd\n2: from xgboost import XGBRanker\n3: from sklearn.metrics import ndcg_score\n4: import numpy as np\n5: import matplotlib.pyplot as plt\n6: import seaborn as sns\n7: \n8: \n9: def load_data(path=\"data/merged_data.csv\"):\n10:     df = pd.read_csv(path)\n11: \n12:     # Features to use\n13:     feature_cols = [\n14:         \"PTS\",\n15:         \"AST\",\n16:         \"TRB\",\n17:         \"FG%\",\n18:         \"BPM\",\n19:         \"WS/48\",\n20:         \"TS%\",\n21:         \"VORP\",\n22:         \"WS\",\n23:         \"PER\",\n24:     ]\n25:     feature_cols = [\n26:         col for col in feature_cols if col in df.columns\n27:     ]  # only keep existing features\n28:     df = df.dropna(subset=feature_cols + [\"Rank\"])\n29: \n30:     # Sort by Year and Rank for consistency\n31:     df = df.sort_values(by=[\"Year\", \"Rank\"])\n32: \n33:     X = df[feature_cols]\n34:     y = df[\"Rank\"]\n35:     groups = df.groupby(\"Year\").size().to_numpy()\n36: \n37:     return X, y, groups, df\n38: \n39: \n40: def evaluate_ndcg(y_true, y_pred, group_sizes):\n41:     scores = []\n42:     start = 0\n43:     for size in group_sizes:\n44:         true_ranks = y_true[start : start + size]\n45:         true_relevance = (max(true_ranks) + 1) - true_ranks\n46:         pred_scores = y_pred[start : start + size]\n47:         scores.append(ndcg_score([true_relevance], [pred_scores]))\n48:         start += size\n49:     return np.mean(scores)\n50: \n51: \n52: def plot_ranking_predictions(df, year):\n53:     \"\"\"\n54:     Plot prediction error for a specific year.\n55: \n56:     Args:\n57:         df: DataFrame containing prediction results\n58:         year: Year to plot prediction errors for\n59:     \"\"\"\n60:     df[\"RankError\"] = df[\"PredictedRank\"] - df[\"Rank\"]\n61:     year_df = df[df[\"Year\"] == year].copy()\n62:     year_df.sort_values(\"Rank\", inplace=True)\n63: \n64:     plt.figure(figsize=(12, 6))\n65:     sns.barplot(x=\"Name\", y=\"RankError\", data=year_df, hue=\"Name\", palette=\"coolwarm\")\n66:     plt.axhline(0, color=\"black\", linestyle=\"--\")\n67:     plt.xticks(rotation=45, ha=\"right\")\n68:     plt.ylabel(\"Predicted Rank - True Rank\")\n69:     plt.title(f\"MVP Ranking Predictions ({year})\")\n70:     plt.tight_layout()\n71:     plt.savefig(f\"data/ranking_predictions_{year}.png\")\n72: \n73: \n74: def main():\n75:     X, y, group, df = load_data()\n76: \n77:     # Train-test split on years\n78:     unique_years = df[\"Year\"].unique()\n79:     train_years, test_years = (\n80:         unique_years[:-2],  # train: 2015-2023\n81:         unique_years[-2:],  # test: 2024-2025\n82:     )\n83: \n84:     train_idx = df[\"Year\"].isin(train_years)\n85:     test_idx = df[\"Year\"].isin(test_years)\n86: \n87:     X_train, X_test = X[train_idx], X[test_idx]\n88:     y_train, y_test = y[train_idx], y[test_idx]\n89: \n90:     # Group sizes\n91:     train_groups = df[train_idx].groupby(\"Year\").size().to_numpy()\n92:     test_groups = df[test_idx].groupby(\"Year\").size().to_numpy()\n93: \n94:     # Model\n95:     model = XGBRanker(\n96:         objective=\"rank:pairwise\",\n97:         learning_rate=0.1,\n98:         n_estimators=100,\n99:         max_depth=4,\n100:         random_state=42,\n101:     )\n102: \n103:     print(\"Training XGBoostRanker...\")\n104:     model.fit(X_train, y_train, group=train_groups)\n105: \n106:     # Predict, sort, and evaluate\n107:     y_pred = model.predict(X_test)\n108:     df.loc[test_idx, \"PredictedScore\"] = y_pred\n109:     df.loc[test_idx, \"PredictedRank\"] = (\n110:         df.loc[test_idx]\n111:         .groupby(\"Year\")[\"PredictedScore\"]\n112:         .rank(ascending=False, method=\"first\")\n113:     )\n114: \n115:     ndcg = evaluate_ndcg(y_test.to_numpy(), y_pred, test_groups)\n116:     print(f\"NDCG Score on test years {test_years.tolist()}: {ndcg:.4f}\")\n117: \n118:     # Show results\n119:     print(df[test_idx][[\"Year\", \"Name\", \"Rank\", \"PredictedScore\", \"PredictedRank\"]])\n120:     plot_ranking_predictions(df, 2024)\n121:     plot_ranking_predictions(df, 2025)\n122: \n123: \n124: if __name__ == \"__main__\":\n125:     main()\n126: "
        },
        "source": "backend",
        "timestamp": "2025-08-23 10:39:20.000",
        "event": "map_summary_code",
        "id": "EFOLunkPQp2xEypIkFYd"
    },
    {
        "data": {
            "mapping": [
                {
                    "summaryComponent": "imports and preprocesses basketball player data",
                    "codeSegments": [
                        {
                            "line": 1,
                            "code": "import pandas as pd"
                        },
                        {
                            "line": 9,
                            "code": "def load_data(path=\"data/merged_data.csv\"):"
                        }
                    ]
                },
                {
                    "summaryComponent": "selecting a set of statistical features",
                    "codeSegments": [
                        {
                            "line": 13,
                            "code": "feature_cols = ["
                        },
                        {
                            "line": 14,
                            "code": "\"PTS\","
                        },
                        {
                            "line": 15,
                            "code": "\"AST\","
                        },
                        {
                            "line": 16,
                            "code": "\"TRB\","
                        },
                        {
                            "line": 17,
                            "code": "\"FG%\","
                        },
                        {
                            "line": 18,
                            "code": "\"BPM\","
                        },
                        {
                            "line": 19,
                            "code": "\"WS/48\","
                        },
                        {
                            "line": 20,
                            "code": "\"TS%\","
                        },
                        {
                            "line": 21,
                            "code": "\"VORP\","
                        },
                        {
                            "line": 22,
                            "code": "\"WS\","
                        },
                        {
                            "line": 23,
                            "code": "\"PER\","
                        }
                    ]
                },
                {
                    "summaryComponent": "ensuring completeness by dropping rows with missing values",
                    "codeSegments": [
                        {
                            "line": 28,
                            "code": "df = df.dropna(subset=feature_cols + [\"Rank\"])"
                        }
                    ]
                },
                {
                    "summaryComponent": "sorts the data by year and rank",
                    "codeSegments": [
                        {
                            "line": 31,
                            "code": "df = df.sort_values(by=[\"Year\", \"Rank\"])"
                        }
                    ]
                },
                {
                    "summaryComponent": "splits it into training and testing sets based on years",
                    "codeSegments": [
                        {
                            "line": 78,
                            "code": "unique_years = df[\"Year\"].unique()"
                        },
                        {
                            "line": 79,
                            "code": "train_years, test_years = ("
                        },
                        {
                            "line": 84,
                            "code": "train_idx = df[\"Year\"].isin(train_years)"
                        },
                        {
                            "line": 85,
                            "code": "test_idx = df[\"Year\"].isin(test_years)"
                        },
                        {
                            "line": 87,
                            "code": "X_train, X_test = X[train_idx], X[test_idx]"
                        },
                        {
                            "line": 88,
                            "code": "y_train, y_test = y[train_idx], y[test_idx]"
                        }
                    ]
                },
                {
                    "summaryComponent": "groups data for ranking tasks",
                    "codeSegments": [
                        {
                            "line": 35,
                            "code": "groups = df.groupby(\"Year\").size().to_numpy()"
                        },
                        {
                            "line": 91,
                            "code": "train_groups = df[train_idx].groupby(\"Year\").size().to_numpy()"
                        },
                        {
                            "line": 92,
                            "code": "test_groups = df[test_idx].groupby(\"Year\").size().to_numpy()"
                        }
                    ]
                },
                {
                    "summaryComponent": "An XGBoostRanker model is trained to predict MVP rankings",
                    "codeSegments": [
                        {
                            "line": 95,
                            "code": "model = XGBRanker("
                        },
                        {
                            "line": 104,
                            "code": "model.fit(X_train, y_train, group=train_groups)"
                        }
                    ]
                },
                {
                    "summaryComponent": "its performance is evaluated using the NDCG score, which measures ranking quality",
                    "codeSegments": [
                        {
                            "line": 115,
                            "code": "ndcg = evaluate_ndcg(y_test.to_numpy(), y_pred, test_groups)"
                        },
                        {
                            "line": 40,
                            "code": "def evaluate_ndcg(y_true, y_pred, group_sizes):"
                        }
                    ]
                },
                {
                    "summaryComponent": "generates and saves bar plots visualizing the prediction errors for each player in the most recent years",
                    "codeSegments": [
                        {
                            "line": 52,
                            "code": "def plot_ranking_predictions(df, year):"
                        },
                        {
                            "line": 71,
                            "code": "plt.savefig(f\"data/ranking_predictions_{year}.png\")"
                        },
                        {
                            "line": 120,
                            "code": "plot_ranking_predictions(df, 2024)"
                        },
                        {
                            "line": 121,
                            "code": "plot_ranking_predictions(df, 2025)"
                        }
                    ]
                },
                {
                    "summaryComponent": "providing insights into the model's accuracy",
                    "codeSegments": [
                        {
                            "line": 116,
                            "code": "print(f\"NDCG Score on test years {test_years.tolist()}: {ndcg:.4f}\")"
                        }
                    ]
                }
            ],
            "summary": "This code imports and preprocesses basketball player data, selecting a set of statistical features and ensuring completeness by dropping rows with missing values. It sorts the data by year and rank, splits it into training and testing sets based on years, and groups data for ranking tasks. An XGBoostRanker model is trained to predict MVP rankings, and its performance is evaluated using the NDCG score, which measures ranking quality. The script also generates and saves bar plots visualizing the prediction errors for each player in the most recent years, providing insights into the model's accuracy.",
            "code": "1: import pandas as pd\n2: from xgboost import XGBRanker\n3: from sklearn.metrics import ndcg_score\n4: import numpy as np\n5: import matplotlib.pyplot as plt\n6: import seaborn as sns\n7: \n8: \n9: def load_data(path=\"data/merged_data.csv\"):\n10:     df = pd.read_csv(path)\n11: \n12:     # Features to use\n13:     feature_cols = [\n14:         \"PTS\",\n15:         \"AST\",\n16:         \"TRB\",\n17:         \"FG%\",\n18:         \"BPM\",\n19:         \"WS/48\",\n20:         \"TS%\",\n21:         \"VORP\",\n22:         \"WS\",\n23:         \"PER\",\n24:     ]\n25:     feature_cols = [\n26:         col for col in feature_cols if col in df.columns\n27:     ]  # only keep existing features\n28:     df = df.dropna(subset=feature_cols + [\"Rank\"])\n29: \n30:     # Sort by Year and Rank for consistency\n31:     df = df.sort_values(by=[\"Year\", \"Rank\"])\n32: \n33:     X = df[feature_cols]\n34:     y = df[\"Rank\"]\n35:     groups = df.groupby(\"Year\").size().to_numpy()\n36: \n37:     return X, y, groups, df\n38: \n39: \n40: def evaluate_ndcg(y_true, y_pred, group_sizes):\n41:     scores = []\n42:     start = 0\n43:     for size in group_sizes:\n44:         true_ranks = y_true[start : start + size]\n45:         true_relevance = (max(true_ranks) + 1) - true_ranks\n46:         pred_scores = y_pred[start : start + size]\n47:         scores.append(ndcg_score([true_relevance], [pred_scores]))\n48:         start += size\n49:     return np.mean(scores)\n50: \n51: \n52: def plot_ranking_predictions(df, year):\n53:     \"\"\"\n54:     Plot prediction error for a specific year.\n55: \n56:     Args:\n57:         df: DataFrame containing prediction results\n58:         year: Year to plot prediction errors for\n59:     \"\"\"\n60:     df[\"RankError\"] = df[\"PredictedRank\"] - df[\"Rank\"]\n61:     year_df = df[df[\"Year\"] == year].copy()\n62:     year_df.sort_values(\"Rank\", inplace=True)\n63: \n64:     plt.figure(figsize=(12, 6))\n65:     sns.barplot(x=\"Name\", y=\"RankError\", data=year_df, hue=\"Name\", palette=\"coolwarm\")\n66:     plt.axhline(0, color=\"black\", linestyle=\"--\")\n67:     plt.xticks(rotation=45, ha=\"right\")\n68:     plt.ylabel(\"Predicted Rank - True Rank\")\n69:     plt.title(f\"MVP Ranking Predictions ({year})\")\n70:     plt.tight_layout()\n71:     plt.savefig(f\"data/ranking_predictions_{year}.png\")\n72: \n73: \n74: def main():\n75:     X, y, group, df = load_data()\n76: \n77:     # Train-test split on years\n78:     unique_years = df[\"Year\"].unique()\n79:     train_years, test_years = (\n80:         unique_years[:-2],  # train: 2015-2023\n81:         unique_years[-2:],  # test: 2024-2025\n82:     )\n83: \n84:     train_idx = df[\"Year\"].isin(train_years)\n85:     test_idx = df[\"Year\"].isin(test_years)\n86: \n87:     X_train, X_test = X[train_idx], X[test_idx]\n88:     y_train, y_test = y[train_idx], y[test_idx]\n89: \n90:     # Group sizes\n91:     train_groups = df[train_idx].groupby(\"Year\").size().to_numpy()\n92:     test_groups = df[test_idx].groupby(\"Year\").size().to_numpy()\n93: \n94:     # Model\n95:     model = XGBRanker(\n96:         objective=\"rank:pairwise\",\n97:         learning_rate=0.1,\n98:         n_estimators=100,\n99:         max_depth=4,\n100:         random_state=42,\n101:     )\n102: \n103:     print(\"Training XGBoostRanker...\")\n104:     model.fit(X_train, y_train, group=train_groups)\n105: \n106:     # Predict, sort, and evaluate\n107:     y_pred = model.predict(X_test)\n108:     df.loc[test_idx, \"PredictedScore\"] = y_pred\n109:     df.loc[test_idx, \"PredictedRank\"] = (\n110:         df.loc[test_idx]\n111:         .groupby(\"Year\")[\"PredictedScore\"]\n112:         .rank(ascending=False, method=\"first\")\n113:     )\n114: \n115:     ndcg = evaluate_ndcg(y_test.to_numpy(), y_pred, test_groups)\n116:     print(f\"NDCG Score on test years {test_years.tolist()}: {ndcg:.4f}\")\n117: \n118:     # Show results\n119:     print(df[test_idx][[\"Year\", \"Name\", \"Rank\", \"PredictedScore\", \"PredictedRank\"]])\n120:     plot_ranking_predictions(df, 2024)\n121:     plot_ranking_predictions(df, 2025)\n122: \n123: \n124: if __name__ == \"__main__\":\n125:     main()\n126: "
        },
        "source": "backend",
        "timestamp": "2025-08-23 10:39:21.000",
        "event": "map_summary_code",
        "id": "xwmfwN0inmKmNL7OGke1"
    },
    {
        "data": {
            "before_section_id": "a2c3c4f9-25de-4beb-b4d5-c348b1c29d5e",
            "after_section_id": "b8ebaadc-fc99-48e5-882d-fad26e99fc33"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:39:22.000",
        "event": "autotransit_section",
        "id": "4QGgYgoUnXKmoJ6VILf6"
    },
    {
        "data": {
            "section_data": {
                "lines": [
                    1,
                    126
                ],
                "summaryData": {
                    "medium_unstructured": "The script loads and preprocesses basketball player data, selecting relevant features and handling missing values. It trains an XGBoostRanker model to predict MVP rankings, evaluates its performance using the NDCG metric, and visualizes prediction errors for recent years. Results and plots are saved for further analysis.",
                    "low_structured": "• Loads and preprocesses basketball data\n• Trains and evaluates an XGBoost ranking model\n• Visualizes prediction errors for MVP rankings",
                    "title": "MVP Ranking Prediction Using XGBoostRanker",
                    "medium_structured": "• Loads and cleans basketball player data from a CSV file\n• Selects relevant statistical features and removes incomplete rows\n• Trains an XGBoostRanker model to predict player rankings\n• Evaluates the model using the NDCG score\n• Visualizes and saves prediction error plots for the most recent years",
                    "high_unstructured": "This code imports and preprocesses basketball player data, selecting a set of statistical features and ensuring completeness by dropping rows with missing values. It sorts the data by year and rank, splits it into training and testing sets based on years, and groups data for ranking tasks. An XGBoostRanker model is trained to predict MVP rankings, and its performance is evaluated using the NDCG score, which measures ranking quality. The script also generates and saves bar plots visualizing the prediction errors for each player in the most recent years, providing insights into the model's accuracy.",
                    "high_structured": "• Loads basketball player data from a CSV file\n  ◦ Selects statistical features (e.g., PTS, AST, TRB, etc.) present in the data\n  ◦ Drops rows with missing values in selected features or rank\n  ◦ Sorts data by year and rank for consistency\n• Splits the data into training (all but last two years) and testing sets (last two years)\n  ◦ Determines group sizes for each year for ranking purposes\n• Trains an XGBoostRanker model with specified hyperparameters (pairwise ranking objective, learning rate, etc.)\n• Predicts MVP rankings for the test years and assigns predicted scores and ranks\n• Evaluates model performance using the NDCG metric, averaged across test years\n• Visualizes prediction errors by generating and saving bar plots for each player in the test years, highlighting differences between predicted and true ranks",
                    "low_unstructured": "This code loads basketball data, trains an XGBoost ranking model, evaluates its performance, and visualizes prediction errors for MVP rankings."
                },
                "editPromptStructured": null,
                "createdAt": 1755974361000,
                "metadata": {
                    "filename": "rank_model.py",
                    "id": "b8ebaadc-fc99-48e5-882d-fad26e99fc33",
                    "originalCode": "import pandas as pd\nfrom xgboost import XGBRanker\nfrom sklearn.metrics import ndcg_score\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport seaborn as sns\n\n\ndef load_data(path=\"data/merged_data.csv\"):\n    df = pd.read_csv(path)\n\n    # Features to use\n    feature_cols = [\n        \"PTS\",\n        \"AST\",\n        \"TRB\",\n        \"FG%\",\n        \"BPM\",\n        \"WS/48\",\n        \"TS%\",\n        \"VORP\",\n        \"WS\",\n        \"PER\",\n    ]\n    feature_cols = [\n        col for col in feature_cols if col in df.columns\n    ]  # only keep existing features\n    df = df.dropna(subset=feature_cols + [\"Rank\"])\n\n    # Sort by Year and Rank for consistency\n    df = df.sort_values(by=[\"Year\", \"Rank\"])\n\n    X = df[feature_cols]\n    y = df[\"Rank\"]\n    groups = df.groupby(\"Year\").size().to_numpy()\n\n    return X, y, groups, df\n\n\ndef evaluate_ndcg(y_true, y_pred, group_sizes):\n    scores = []\n    start = 0\n    for size in group_sizes:\n        true_ranks = y_true[start : start + size]\n        true_relevance = (max(true_ranks) + 1) - true_ranks\n        pred_scores = y_pred[start : start + size]\n        scores.append(ndcg_score([true_relevance], [pred_scores]))\n        start += size\n    return np.mean(scores)\n\n\ndef plot_ranking_predictions(df, year):\n    \"\"\"\n    Plot prediction error for a specific year.\n\n    Args:\n        df: DataFrame containing prediction results\n        year: Year to plot prediction errors for\n    \"\"\"\n    df[\"RankError\"] = df[\"PredictedRank\"] - df[\"Rank\"]\n    year_df = df[df[\"Year\"] == year].copy()\n    year_df.sort_values(\"Rank\", inplace=True)\n\n    plt.figure(figsize=(12, 6))\n    sns.barplot(x=\"Name\", y=\"RankError\", data=year_df, hue=\"Name\", palette=\"coolwarm\")\n    plt.axhline(0, color=\"black\", linestyle=\"--\")\n    plt.xticks(rotation=45, ha=\"right\")\n    plt.ylabel(\"Predicted Rank - True Rank\")\n    plt.title(f\"MVP Ranking Predictions ({year})\")\n    plt.tight_layout()\n    plt.savefig(f\"data/ranking_predictions_{year}.png\")\n\n\ndef main():\n    X, y, group, df = load_data()\n\n    # Train-test split on years\n    unique_years = df[\"Year\"].unique()\n    train_years, test_years = (\n        unique_years[:-2],  # train: 2015-2023\n        unique_years[-2:],  # test: 2024-2025\n    )\n\n    train_idx = df[\"Year\"].isin(train_years)\n    test_idx = df[\"Year\"].isin(test_years)\n\n    X_train, X_test = X[train_idx], X[test_idx]\n    y_train, y_test = y[train_idx], y[test_idx]\n\n    # Group sizes\n    train_groups = df[train_idx].groupby(\"Year\").size().to_numpy()\n    test_groups = df[test_idx].groupby(\"Year\").size().to_numpy()\n\n    # Model\n    model = XGBRanker(\n        objective=\"rank:pairwise\",\n        learning_rate=0.1,\n        n_estimators=100,\n        max_depth=4,\n        random_state=42,\n    )\n\n    print(\"Training XGBoostRanker...\")\n    model.fit(X_train, y_train, group=train_groups)\n\n    # Predict, sort, and evaluate\n    y_pred = model.predict(X_test)\n    df.loc[test_idx, \"PredictedScore\"] = y_pred\n    df.loc[test_idx, \"PredictedRank\"] = (\n        df.loc[test_idx]\n        .groupby(\"Year\")[\"PredictedScore\"]\n        .rank(ascending=False, method=\"first\")\n    )\n\n    ndcg = evaluate_ndcg(y_test.to_numpy(), y_pred, test_groups)\n    print(f\"NDCG Score on test years {test_years.tolist()}: {ndcg:.4f}\")\n\n    # Show results\n    print(df[test_idx][[\"Year\", \"Name\", \"Rank\", \"PredictedScore\", \"PredictedRank\"]])\n    plot_ranking_predictions(df, 2024)\n    plot_ranking_predictions(df, 2025)\n\n\nif __name__ == \"__main__\":\n    main()\n",
                    "fullPath": "/project/workspace/rank_model.py",
                    "offset": 0
                },
                "selectedStructured": "unstructured",
                "title": "MVP Ranking Prediction Using XGBoostRanker",
                "selectedDetailLevel": "medium",
                "summaryMappings": {
                    "medium_unstructured": [
                        {
                            "summaryComponent": "loads and preprocesses basketball player data",
                            "codeSegments": [
                                {
                                    "line": 9,
                                    "code": "def load_data(path=\"data/merged_data.csv\"):"
                                },
                                {
                                    "line": 10,
                                    "code": "df = pd.read_csv(path)"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "selecting relevant features",
                            "codeSegments": [
                                {
                                    "line": 13,
                                    "code": "feature_cols = ["
                                },
                                {
                                    "line": 25,
                                    "code": "feature_cols = ["
                                }
                            ]
                        },
                        {
                            "summaryComponent": "handling missing values",
                            "codeSegments": [
                                {
                                    "line": 28,
                                    "code": "df = df.dropna(subset=feature_cols + [\"Rank\"])"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "trains an XGBoostRanker model",
                            "codeSegments": [
                                {
                                    "line": 95,
                                    "code": "model = XGBRanker("
                                },
                                {
                                    "line": 104,
                                    "code": "model.fit(X_train, y_train, group=train_groups)"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "to predict MVP rankings",
                            "codeSegments": [
                                {
                                    "line": 107,
                                    "code": "y_pred = model.predict(X_test)"
                                },
                                {
                                    "line": 109,
                                    "code": "df.loc[test_idx, \"PredictedRank\"] = ("
                                }
                            ]
                        },
                        {
                            "summaryComponent": "evaluates its performance using the NDCG metric",
                            "codeSegments": [
                                {
                                    "line": 115,
                                    "code": "ndcg = evaluate_ndcg(y_test.to_numpy(), y_pred, test_groups)"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "visualizes prediction errors for recent years",
                            "codeSegments": [
                                {
                                    "line": 120,
                                    "code": "plot_ranking_predictions(df, 2024)"
                                },
                                {
                                    "line": 121,
                                    "code": "plot_ranking_predictions(df, 2025)"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "Results and plots are saved for further analysis",
                            "codeSegments": [
                                {
                                    "line": 71,
                                    "code": "plt.savefig(f\"data/ranking_predictions_{year}.png\")"
                                }
                            ]
                        }
                    ],
                    "low_structured": [
                        {
                            "summaryComponent": "Loads and preprocesses basketball data",
                            "codeSegments": [
                                {
                                    "line": 9,
                                    "code": "def load_data(path=\"data/merged_data.csv\"):"
                                },
                                {
                                    "line": 10,
                                    "code": "df = pd.read_csv(path)"
                                },
                                {
                                    "line": 13,
                                    "code": "feature_cols = ["
                                },
                                {
                                    "line": 25,
                                    "code": "feature_cols = ["
                                },
                                {
                                    "line": 28,
                                    "code": "df = df.dropna(subset=feature_cols + [\"Rank\"])"
                                },
                                {
                                    "line": 31,
                                    "code": "df = df.sort_values(by=[\"Year\", \"Rank\"])"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "Trains and evaluates an XGBoost ranking model",
                            "codeSegments": [
                                {
                                    "line": 95,
                                    "code": "model = XGBRanker("
                                },
                                {
                                    "line": 104,
                                    "code": "model.fit(X_train, y_train, group=train_groups)"
                                },
                                {
                                    "line": 107,
                                    "code": "y_pred = model.predict(X_test)"
                                },
                                {
                                    "line": 115,
                                    "code": "ndcg = evaluate_ndcg(y_test.to_numpy(), y_pred, test_groups)"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "Visualizes prediction errors for MVP rankings",
                            "codeSegments": [
                                {
                                    "line": 52,
                                    "code": "def plot_ranking_predictions(df, year):"
                                },
                                {
                                    "line": 120,
                                    "code": "plot_ranking_predictions(df, 2024)"
                                },
                                {
                                    "line": 121,
                                    "code": "plot_ranking_predictions(df, 2025)"
                                }
                            ]
                        }
                    ],
                    "low_unstructured": [
                        {
                            "summaryComponent": "loads basketball data",
                            "codeSegments": [
                                {
                                    "line": 9,
                                    "code": "def load_data(path=\"data/merged_data.csv\"):"
                                },
                                {
                                    "line": 10,
                                    "code": "df = pd.read_csv(path)"
                                },
                                {
                                    "line": 75,
                                    "code": "X, y, groups, df = load_data()"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "trains an XGBoost ranking model",
                            "codeSegments": [
                                {
                                    "line": 95,
                                    "code": "model = XGBRanker("
                                },
                                {
                                    "line": 104,
                                    "code": "model.fit(X_train, y_train, group=train_groups)"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "evaluates its performance",
                            "codeSegments": [
                                {
                                    "line": 115,
                                    "code": "ndcg = evaluate_ndcg(y_test.to_numpy(), y_pred, test_groups)"
                                },
                                {
                                    "line": 116,
                                    "code": "print(f\"NDCG Score on test years {test_years.tolist()}: {ndcg:.4f}\")"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "visualizes prediction errors for MVP rankings",
                            "codeSegments": [
                                {
                                    "line": 120,
                                    "code": "plot_ranking_predictions(df, 2024)"
                                },
                                {
                                    "line": 121,
                                    "code": "plot_ranking_predictions(df, 2025)"
                                }
                            ]
                        }
                    ],
                    "medium_structured": [
                        {
                            "summaryComponent": "Loads and cleans basketball player data from a CSV file",
                            "codeSegments": [
                                {
                                    "line": 9,
                                    "code": "def load_data(path=\"data/merged_data.csv\"):"
                                },
                                {
                                    "line": 10,
                                    "code": "df = pd.read_csv(path)"
                                },
                                {
                                    "line": 28,
                                    "code": "df = df.dropna(subset=feature_cols + [\"Rank\"])"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "Selects relevant statistical features and removes incomplete rows",
                            "codeSegments": [
                                {
                                    "line": 13,
                                    "code": "feature_cols = ["
                                },
                                {
                                    "line": 25,
                                    "code": "feature_cols = ["
                                },
                                {
                                    "line": 26,
                                    "code": "col for col in feature_cols if col in df.columns"
                                },
                                {
                                    "line": 28,
                                    "code": "df = df.dropna(subset=feature_cols + [\"Rank\"])"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "Trains an XGBoostRanker model to predict player rankings",
                            "codeSegments": [
                                {
                                    "line": 95,
                                    "code": "model = XGBRanker("
                                },
                                {
                                    "line": 104,
                                    "code": "model.fit(X_train, y_train, group=train_groups)"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "Evaluates the model using the NDCG score",
                            "codeSegments": [
                                {
                                    "line": 40,
                                    "code": "def evaluate_ndcg(y_true, y_pred, group_sizes):"
                                },
                                {
                                    "line": 115,
                                    "code": "ndcg = evaluate_ndcg(y_test.to_numpy(), y_pred, test_groups)"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "Visualizes and saves prediction error plots for the most recent years",
                            "codeSegments": [
                                {
                                    "line": 52,
                                    "code": "def plot_ranking_predictions(df, year):"
                                },
                                {
                                    "line": 71,
                                    "code": "plt.savefig(f\"data/ranking_predictions_{year}.png\")"
                                },
                                {
                                    "line": 120,
                                    "code": "plot_ranking_predictions(df, 2024)"
                                },
                                {
                                    "line": 121,
                                    "code": "plot_ranking_predictions(df, 2025)"
                                }
                            ]
                        }
                    ],
                    "high_unstructured": [
                        {
                            "summaryComponent": "imports and preprocesses basketball player data",
                            "codeSegments": [
                                {
                                    "line": 1,
                                    "code": "import pandas as pd"
                                },
                                {
                                    "line": 9,
                                    "code": "def load_data(path=\"data/merged_data.csv\"):"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "selecting a set of statistical features",
                            "codeSegments": [
                                {
                                    "line": 13,
                                    "code": "feature_cols = ["
                                },
                                {
                                    "line": 14,
                                    "code": "\"PTS\","
                                },
                                {
                                    "line": 15,
                                    "code": "\"AST\","
                                },
                                {
                                    "line": 16,
                                    "code": "\"TRB\","
                                },
                                {
                                    "line": 17,
                                    "code": "\"FG%\","
                                },
                                {
                                    "line": 18,
                                    "code": "\"BPM\","
                                },
                                {
                                    "line": 19,
                                    "code": "\"WS/48\","
                                },
                                {
                                    "line": 20,
                                    "code": "\"TS%\","
                                },
                                {
                                    "line": 21,
                                    "code": "\"VORP\","
                                },
                                {
                                    "line": 22,
                                    "code": "\"WS\","
                                },
                                {
                                    "line": 23,
                                    "code": "\"PER\","
                                }
                            ]
                        },
                        {
                            "summaryComponent": "ensuring completeness by dropping rows with missing values",
                            "codeSegments": [
                                {
                                    "line": 28,
                                    "code": "df = df.dropna(subset=feature_cols + [\"Rank\"])"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "sorts the data by year and rank",
                            "codeSegments": [
                                {
                                    "line": 31,
                                    "code": "df = df.sort_values(by=[\"Year\", \"Rank\"])"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "splits it into training and testing sets based on years",
                            "codeSegments": [
                                {
                                    "line": 78,
                                    "code": "unique_years = df[\"Year\"].unique()"
                                },
                                {
                                    "line": 79,
                                    "code": "train_years, test_years = ("
                                },
                                {
                                    "line": 84,
                                    "code": "train_idx = df[\"Year\"].isin(train_years)"
                                },
                                {
                                    "line": 85,
                                    "code": "test_idx = df[\"Year\"].isin(test_years)"
                                },
                                {
                                    "line": 87,
                                    "code": "X_train, X_test = X[train_idx], X[test_idx]"
                                },
                                {
                                    "line": 88,
                                    "code": "y_train, y_test = y[train_idx], y[test_idx]"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "groups data for ranking tasks",
                            "codeSegments": [
                                {
                                    "line": 35,
                                    "code": "groups = df.groupby(\"Year\").size().to_numpy()"
                                },
                                {
                                    "line": 91,
                                    "code": "train_groups = df[train_idx].groupby(\"Year\").size().to_numpy()"
                                },
                                {
                                    "line": 92,
                                    "code": "test_groups = df[test_idx].groupby(\"Year\").size().to_numpy()"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "An XGBoostRanker model is trained to predict MVP rankings",
                            "codeSegments": [
                                {
                                    "line": 95,
                                    "code": "model = XGBRanker("
                                },
                                {
                                    "line": 104,
                                    "code": "model.fit(X_train, y_train, group=train_groups)"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "its performance is evaluated using the NDCG score, which measures ranking quality",
                            "codeSegments": [
                                {
                                    "line": 115,
                                    "code": "ndcg = evaluate_ndcg(y_test.to_numpy(), y_pred, test_groups)"
                                },
                                {
                                    "line": 40,
                                    "code": "def evaluate_ndcg(y_true, y_pred, group_sizes):"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "generates and saves bar plots visualizing the prediction errors for each player in the most recent years",
                            "codeSegments": [
                                {
                                    "line": 52,
                                    "code": "def plot_ranking_predictions(df, year):"
                                },
                                {
                                    "line": 71,
                                    "code": "plt.savefig(f\"data/ranking_predictions_{year}.png\")"
                                },
                                {
                                    "line": 120,
                                    "code": "plot_ranking_predictions(df, 2024)"
                                },
                                {
                                    "line": 121,
                                    "code": "plot_ranking_predictions(df, 2025)"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "providing insights into the model's accuracy",
                            "codeSegments": [
                                {
                                    "line": 116,
                                    "code": "print(f\"NDCG Score on test years {test_years.tolist()}: {ndcg:.4f}\")"
                                }
                            ]
                        }
                    ],
                    "high_structured": [
                        {
                            "summaryComponent": "Loads basketball player data from a CSV file",
                            "codeSegments": [
                                {
                                    "line": 9,
                                    "code": "def load_data(path=\"data/merged_data.csv\"):"
                                },
                                {
                                    "line": 10,
                                    "code": "df = pd.read_csv(path)"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "Selects statistical features (e.g., PTS, AST, TRB, etc.) present in the data",
                            "codeSegments": [
                                {
                                    "line": 13,
                                    "code": "feature_cols = ["
                                },
                                {
                                    "line": 26,
                                    "code": "col for col in feature_cols if col in df.columns"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "Drops rows with missing values in selected features or rank",
                            "codeSegments": [
                                {
                                    "line": 28,
                                    "code": "df = df.dropna(subset=feature_cols + [\"Rank\"])"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "Sorts data by year and rank for consistency",
                            "codeSegments": [
                                {
                                    "line": 31,
                                    "code": "df = df.sort_values(by=[\"Year\", \"Rank\"])"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "Splits the data into training (all but last two years) and testing sets (last two years)",
                            "codeSegments": [
                                {
                                    "line": 78,
                                    "code": "unique_years = df[\"Year\"].unique()"
                                },
                                {
                                    "line": 79,
                                    "code": "train_years, test_years = ("
                                },
                                {
                                    "line": 84,
                                    "code": "train_idx = df[\"Year\"].isin(train_years)"
                                },
                                {
                                    "line": 85,
                                    "code": "test_idx = df[\"Year\"].isin(test_years)"
                                },
                                {
                                    "line": 87,
                                    "code": "X_train, X_test = X[train_idx], X[test_idx]"
                                },
                                {
                                    "line": 88,
                                    "code": "y_train, y_test = y[train_idx], y[test_idx]"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "Determines group sizes for each year for ranking purposes",
                            "codeSegments": [
                                {
                                    "line": 91,
                                    "code": "train_groups = df[train_idx].groupby(\"Year\").size().to_numpy()"
                                },
                                {
                                    "line": 92,
                                    "code": "test_groups = df[test_idx].groupby(\"Year\").size().to_numpy()"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "Trains an XGBoostRanker model with specified hyperparameters (pairwise ranking objective, learning rate, etc.)",
                            "codeSegments": [
                                {
                                    "line": 95,
                                    "code": "model = XGBRanker("
                                },
                                {
                                    "line": 96,
                                    "code": "objective=\"rank:pairwise\","
                                },
                                {
                                    "line": 97,
                                    "code": "learning_rate=0.1,"
                                },
                                {
                                    "line": 98,
                                    "code": "n_estimators=100,"
                                },
                                {
                                    "line": 99,
                                    "code": "max_depth=4,"
                                },
                                {
                                    "line": 100,
                                    "code": "random_state=42,"
                                },
                                {
                                    "line": 104,
                                    "code": "model.fit(X_train, y_train, group=train_groups)"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "Predicts MVP rankings for the test years and assigns predicted scores and ranks",
                            "codeSegments": [
                                {
                                    "line": 107,
                                    "code": "y_pred = model.predict(X_test)"
                                },
                                {
                                    "line": 108,
                                    "code": "df.loc[test_idx, \"PredictedScore\"] = y_pred"
                                },
                                {
                                    "line": 109,
                                    "code": "df.loc[test_idx, \"PredictedRank\"] = ("
                                }
                            ]
                        },
                        {
                            "summaryComponent": "Evaluates model performance using the NDCG metric, averaged across test years",
                            "codeSegments": [
                                {
                                    "line": 115,
                                    "code": "ndcg = evaluate_ndcg(y_test.to_numpy(), y_pred, test_groups)"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "Visualizes prediction errors by generating and saving bar plots for each player in the test years, highlighting differences between predicted and true ranks",
                            "codeSegments": [
                                {
                                    "line": 120,
                                    "code": "plot_ranking_predictions(df, 2024)"
                                },
                                {
                                    "line": 121,
                                    "code": "plot_ranking_predictions(df, 2025)"
                                },
                                {
                                    "line": 52,
                                    "code": "def plot_ranking_predictions(df, year):"
                                },
                                {
                                    "line": 60,
                                    "code": "df[\"RankError\"] = df[\"PredictedRank\"] - df[\"Rank\"]"
                                },
                                {
                                    "line": 65,
                                    "code": "sns.barplot(x=\"Name\", y=\"RankError\", data=year_df, hue=\"Name\", palette=\"coolwarm\")"
                                },
                                {
                                    "line": 71,
                                    "code": "plt.savefig(f\"data/ranking_predictions_{year}.png\")"
                                }
                            ]
                        }
                    ]
                },
                "editPromptValue": "",
                "editPromptDetailLevel": null
            },
            "section_id": "b8ebaadc-fc99-48e5-882d-fad26e99fc33"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:39:22.000",
        "event": "create_new_section",
        "id": "OG3lJpbOZ83zpMEq0P6A"
    },
    {
        "data": {
            "mapping_index": 1,
            "structured_type": "unstructured",
            "section_id": "b8ebaadc-fc99-48e5-882d-fad26e99fc33",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:39:30.000",
        "event": "mapping_hover",
        "id": "368quVT3vOKN4c7eLlIH"
    },
    {
        "data": {
            "mapping_index": 3,
            "structured_type": "unstructured",
            "section_id": "b8ebaadc-fc99-48e5-882d-fad26e99fc33",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:39:30.000",
        "event": "mapping_hover",
        "id": "9nSDGS6AtRWXnBCuzwVq"
    },
    {
        "data": {
            "mapping_index": 2,
            "structured_type": "unstructured",
            "section_id": "b8ebaadc-fc99-48e5-882d-fad26e99fc33",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:39:30.000",
        "event": "mapping_hover",
        "id": "E57bIePW0c6CJWsiKjpK"
    },
    {
        "data": {
            "structured_type": "unstructured",
            "section_id": "b8ebaadc-fc99-48e5-882d-fad26e99fc33",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:39:30.000",
        "event": "mapping_unhover",
        "id": "FUHzKzdAzMvn5QOz82jR"
    },
    {
        "data": {
            "structured_type": "unstructured",
            "section_id": "b8ebaadc-fc99-48e5-882d-fad26e99fc33",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:39:30.000",
        "event": "mapping_unhover",
        "id": "KFqG70SWCCaUsDFZem6S"
    },
    {
        "data": {
            "mapping_index": 0,
            "structured_type": "unstructured",
            "section_id": "b8ebaadc-fc99-48e5-882d-fad26e99fc33",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:39:30.000",
        "event": "mapping_hover",
        "id": "PsGNq0oFkPeM5CHtonxF"
    },
    {
        "data": {
            "mapping_index": 2,
            "structured_type": "unstructured",
            "section_id": "b8ebaadc-fc99-48e5-882d-fad26e99fc33",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:39:30.000",
        "event": "mapping_hover",
        "id": "S5xiQPw7bePcs7t5xhhJ"
    },
    {
        "data": {
            "structured_type": "unstructured",
            "section_id": "b8ebaadc-fc99-48e5-882d-fad26e99fc33",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:39:30.000",
        "event": "mapping_unhover",
        "id": "WJbVouGQrNVpcwuepwES"
    },
    {
        "data": {
            "structured_type": "unstructured",
            "section_id": "b8ebaadc-fc99-48e5-882d-fad26e99fc33",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:39:30.000",
        "event": "mapping_unhover",
        "id": "rntl6mrEDRIcoEHSJWdi"
    },
    {
        "data": {
            "mapping_index": 1,
            "structured_type": "unstructured",
            "section_id": "b8ebaadc-fc99-48e5-882d-fad26e99fc33",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:39:31.000",
        "event": "mapping_hover",
        "id": "MMpwc9bYK68q2TtJ6gwh"
    },
    {
        "data": {
            "mapping_index": 0,
            "structured_type": "unstructured",
            "section_id": "b8ebaadc-fc99-48e5-882d-fad26e99fc33",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:39:31.000",
        "event": "mapping_hover",
        "id": "THJSCHx7Oqku6XmYgzgw"
    },
    {
        "data": {
            "structured_type": "unstructured",
            "section_id": "b8ebaadc-fc99-48e5-882d-fad26e99fc33",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:39:31.000",
        "event": "mapping_unhover",
        "id": "bGpEU3xQ27gYQyV3f5Vs"
    },
    {
        "data": {
            "structured_type": "unstructured",
            "section_id": "b8ebaadc-fc99-48e5-882d-fad26e99fc33",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:39:31.000",
        "event": "mapping_unhover",
        "id": "t9f537VTtRPd8utZopgY"
    },
    {
        "data": {
            "before_detail_level": "medium",
            "after_detail_level": "medium",
            "before_structured": "unstructured",
            "section_id": "b8ebaadc-fc99-48e5-882d-fad26e99fc33",
            "after_structured": "structured"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:39:32.000",
        "event": "change_summary_level",
        "id": "ZQbOfrcCt0EGEhbbKtui"
    },
    {
        "data": {
            "structured_type": "unstructured",
            "section_id": "b8ebaadc-fc99-48e5-882d-fad26e99fc33",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:39:32.000",
        "event": "mapping_unhover",
        "id": "iSJMadRPYl4ktH5Y3bWs"
    },
    {
        "data": {
            "mapping_index": 0,
            "structured_type": "structured",
            "section_id": "b8ebaadc-fc99-48e5-882d-fad26e99fc33",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:39:34.000",
        "event": "mapping_hover",
        "id": "tCmOxikhRpX2md368Bs7"
    },
    {
        "data": {
            "structured_type": "structured",
            "section_id": "b8ebaadc-fc99-48e5-882d-fad26e99fc33",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:39:35.000",
        "event": "mapping_unhover",
        "id": "6yboFYxeVj7F4LsWUIDn"
    },
    {
        "data": {
            "mapping_index": 1,
            "structured_type": "structured",
            "section_id": "b8ebaadc-fc99-48e5-882d-fad26e99fc33",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:39:35.000",
        "event": "mapping_hover",
        "id": "Ti3ivnhUZce2FE2Ls1qs"
    },
    {
        "data": {
            "structured_type": "structured",
            "section_id": "b8ebaadc-fc99-48e5-882d-fad26e99fc33",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:39:36.000",
        "event": "mapping_unhover",
        "id": "6ENsi0Ct394Ba8qnqGkr"
    },
    {
        "data": {
            "mapping_index": 2,
            "structured_type": "structured",
            "section_id": "b8ebaadc-fc99-48e5-882d-fad26e99fc33",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:39:37.000",
        "event": "mapping_hover",
        "id": "UN4eO3xeApmsqIeFCJWb"
    },
    {
        "data": {
            "structured_type": "structured",
            "section_id": "b8ebaadc-fc99-48e5-882d-fad26e99fc33",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:39:37.000",
        "event": "mapping_unhover",
        "id": "a8sJ1ecKzO8TDTfOJySC"
    },
    {
        "data": {
            "mapping_index": 1,
            "structured_type": "structured",
            "section_id": "b8ebaadc-fc99-48e5-882d-fad26e99fc33",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:39:38.000",
        "event": "mapping_hover",
        "id": "XUjFE3Zj8tunYir3h6os"
    },
    {
        "data": {
            "structured_type": "structured",
            "section_id": "b8ebaadc-fc99-48e5-882d-fad26e99fc33",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:39:39.000",
        "event": "mapping_unhover",
        "id": "7Zimg9clR5gxZTdi91tk"
    },
    {
        "data": {
            "mapping_index": 2,
            "structured_type": "structured",
            "section_id": "b8ebaadc-fc99-48e5-882d-fad26e99fc33",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:39:39.000",
        "event": "mapping_hover",
        "id": "CqwqowjlmCcOLtkkM2qx"
    },
    {
        "data": {
            "mapping_index": 2,
            "structured_type": "structured",
            "section_id": "b8ebaadc-fc99-48e5-882d-fad26e99fc33",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:39:42.000",
        "event": "mapping_hover",
        "id": "J84i0t6YRILHHVGkKwlY"
    },
    {
        "data": {
            "structured_type": "structured",
            "section_id": "b8ebaadc-fc99-48e5-882d-fad26e99fc33",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:39:42.000",
        "event": "mapping_unhover",
        "id": "rmVhAu5mFcd3Fc0cf90c"
    },
    {
        "data": {
            "structured_type": "structured",
            "section_id": "b8ebaadc-fc99-48e5-882d-fad26e99fc33",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:39:43.000",
        "event": "mapping_unhover",
        "id": "2UqpsFmhhFRAAtx6a5l7"
    },
    {
        "data": {
            "mapping_index": 2,
            "structured_type": "structured",
            "section_id": "b8ebaadc-fc99-48e5-882d-fad26e99fc33",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:39:44.000",
        "event": "mapping_hover",
        "id": "xf3RvAp8SKVHjwNmL7ck"
    },
    {
        "data": {
            "structured_type": "structured",
            "section_id": "b8ebaadc-fc99-48e5-882d-fad26e99fc33",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:39:45.000",
        "event": "mapping_unhover",
        "id": "1myw8INoqdDVkB437AYI"
    },
    {
        "data": {
            "structured_type": "structured",
            "section_id": "b8ebaadc-fc99-48e5-882d-fad26e99fc33",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:39:45.000",
        "event": "mapping_unhover",
        "id": "B7GiHnhnWTIxfoJLoNjj"
    },
    {
        "data": {
            "mapping_index": 2,
            "structured_type": "structured",
            "section_id": "b8ebaadc-fc99-48e5-882d-fad26e99fc33",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:39:45.000",
        "event": "mapping_hover",
        "id": "Mshx6ieHYZsGh6N4s40a"
    },
    {
        "data": {
            "mapping_index": 3,
            "structured_type": "structured",
            "section_id": "b8ebaadc-fc99-48e5-882d-fad26e99fc33",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:39:45.000",
        "event": "mapping_hover",
        "id": "Vvh5RgsPhV0JNUcbCJJG"
    },
    {
        "data": {
            "mapping_index": 3,
            "structured_type": "structured",
            "section_id": "b8ebaadc-fc99-48e5-882d-fad26e99fc33",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:39:45.000",
        "event": "mapping_hover",
        "id": "dGZRB6j1RvI2LItUSGTp"
    },
    {
        "data": {
            "structured_type": "structured",
            "section_id": "b8ebaadc-fc99-48e5-882d-fad26e99fc33",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:39:45.000",
        "event": "mapping_unhover",
        "id": "fnk5OVwqQE5mhyQDFhzX"
    },
    {
        "data": {
            "structured_type": "structured",
            "section_id": "b8ebaadc-fc99-48e5-882d-fad26e99fc33",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:39:45.000",
        "event": "mapping_unhover",
        "id": "iZUdHMrmzXeMPk15VRqG"
    },
    {
        "data": {
            "structured_type": "structured",
            "section_id": "b8ebaadc-fc99-48e5-882d-fad26e99fc33",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:39:45.000",
        "event": "mapping_unhover",
        "id": "lQzTsD4sO3MCzG5qBq9e"
    },
    {
        "data": {
            "mapping_index": 4,
            "structured_type": "structured",
            "section_id": "b8ebaadc-fc99-48e5-882d-fad26e99fc33",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:39:45.000",
        "event": "mapping_hover",
        "id": "o4QPA9qhgOJeorvM5oT6"
    },
    {
        "data": {
            "mapping_index": 3,
            "structured_type": "structured",
            "section_id": "b8ebaadc-fc99-48e5-882d-fad26e99fc33",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:39:45.000",
        "event": "mapping_hover",
        "id": "pnzkVqjxpTgpUkGxtXIQ"
    },
    {
        "data": {
            "mapping_index": 2,
            "structured_type": "structured",
            "section_id": "b8ebaadc-fc99-48e5-882d-fad26e99fc33",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:39:46.000",
        "event": "mapping_hover",
        "id": "R7gaDFqe6sVmInBnReMf"
    },
    {
        "data": {
            "structured_type": "structured",
            "section_id": "b8ebaadc-fc99-48e5-882d-fad26e99fc33",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:39:46.000",
        "event": "mapping_unhover",
        "id": "e350LAMUIeC49YSVDYfG"
    },
    {
        "data": {
            "structured_type": "structured",
            "section_id": "b8ebaadc-fc99-48e5-882d-fad26e99fc33",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:39:50.000",
        "event": "mapping_unhover",
        "id": "zTmWtdV9N02di071OY6C"
    },
    {
        "data": {
            "mapping_index": 4,
            "structured_type": "structured",
            "section_id": "b8ebaadc-fc99-48e5-882d-fad26e99fc33",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:39:53.000",
        "event": "mapping_hover",
        "id": "rVOXmX5uXdQrU7EfaqMf"
    },
    {
        "data": {
            "mapping_index": 2,
            "structured_type": "structured",
            "section_id": "b8ebaadc-fc99-48e5-882d-fad26e99fc33",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:39:54.000",
        "event": "mapping_hover",
        "id": "7DVGQNWQyfS5paIrsKDS"
    },
    {
        "data": {
            "structured_type": "structured",
            "section_id": "b8ebaadc-fc99-48e5-882d-fad26e99fc33",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:39:54.000",
        "event": "mapping_unhover",
        "id": "sSAofpz1rud7EVhVzAWh"
    },
    {
        "data": {
            "mapping_index": 1,
            "structured_type": "structured",
            "section_id": "b8ebaadc-fc99-48e5-882d-fad26e99fc33",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:39:55.000",
        "event": "mapping_hover",
        "id": "9fk9C9srayKnJaVJFHwP"
    },
    {
        "data": {
            "mapping_index": 2,
            "structured_type": "structured",
            "section_id": "b8ebaadc-fc99-48e5-882d-fad26e99fc33",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:39:55.000",
        "event": "mapping_hover",
        "id": "AaaW5hT6XqdL3Lw4jXxZ"
    },
    {
        "data": {
            "mapping_index": 4,
            "structured_type": "structured",
            "section_id": "b8ebaadc-fc99-48e5-882d-fad26e99fc33",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:39:55.000",
        "event": "mapping_hover",
        "id": "DCwwW6W4bXqoTcRLdrSk"
    },
    {
        "data": {
            "structured_type": "structured",
            "section_id": "b8ebaadc-fc99-48e5-882d-fad26e99fc33",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:39:55.000",
        "event": "mapping_unhover",
        "id": "H0Dsas5tE3JWOAeRbASO"
    },
    {
        "data": {
            "structured_type": "structured",
            "section_id": "b8ebaadc-fc99-48e5-882d-fad26e99fc33",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:39:55.000",
        "event": "mapping_unhover",
        "id": "HqfxLx5284P3lrPfkwep"
    },
    {
        "data": {
            "structured_type": "structured",
            "section_id": "b8ebaadc-fc99-48e5-882d-fad26e99fc33",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:39:55.000",
        "event": "mapping_unhover",
        "id": "PyC6zNnC3JRTyfeelQD7"
    },
    {
        "data": {
            "structured_type": "structured",
            "section_id": "b8ebaadc-fc99-48e5-882d-fad26e99fc33",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:39:55.000",
        "event": "mapping_unhover",
        "id": "a0D6kjhew9VhJna9aiPj"
    },
    {
        "data": {
            "structured_type": "structured",
            "section_id": "b8ebaadc-fc99-48e5-882d-fad26e99fc33",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:39:55.000",
        "event": "mapping_unhover",
        "id": "bfMmcCx3eQX6FoSIAv01"
    },
    {
        "data": {
            "mapping_index": 1,
            "structured_type": "structured",
            "section_id": "b8ebaadc-fc99-48e5-882d-fad26e99fc33",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:39:55.000",
        "event": "mapping_hover",
        "id": "cGiuZ9VR8kohktRSnYxS"
    },
    {
        "data": {
            "mapping_index": 3,
            "structured_type": "structured",
            "section_id": "b8ebaadc-fc99-48e5-882d-fad26e99fc33",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:39:55.000",
        "event": "mapping_hover",
        "id": "dPCLEUYipMNtbGYn2KH7"
    },
    {
        "data": {
            "structured_type": "structured",
            "section_id": "b8ebaadc-fc99-48e5-882d-fad26e99fc33",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:39:55.000",
        "event": "mapping_unhover",
        "id": "im79uMqJ9WtnU3zBYUo0"
    },
    {
        "data": {
            "structured_type": "structured",
            "section_id": "b8ebaadc-fc99-48e5-882d-fad26e99fc33",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:39:55.000",
        "event": "mapping_unhover",
        "id": "sRsDMA3DbrfdGgsIYDWf"
    },
    {
        "data": {
            "mapping_index": 0,
            "structured_type": "structured",
            "section_id": "b8ebaadc-fc99-48e5-882d-fad26e99fc33",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:39:55.000",
        "event": "mapping_hover",
        "id": "tL7nrbIDRIChoZ7bm9fW"
    },
    {
        "data": {
            "mapping_index": 4,
            "structured_type": "structured",
            "section_id": "b8ebaadc-fc99-48e5-882d-fad26e99fc33",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:39:56.000",
        "event": "mapping_hover",
        "id": "QBi3HmpOl5tiSdS68o7G"
    },
    {
        "data": {
            "structured_type": "structured",
            "section_id": "b8ebaadc-fc99-48e5-882d-fad26e99fc33",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:39:56.000",
        "event": "mapping_unhover",
        "id": "XaV1aP7HWQHqVNDtcrII"
    },
    {
        "data": {
            "mapping_index": 4,
            "structured_type": "structured",
            "section_id": "b8ebaadc-fc99-48e5-882d-fad26e99fc33",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:39:57.000",
        "event": "mapping_hover",
        "id": "UxNVKKPZ7VWb0YH1sI0z"
    },
    {
        "data": {
            "mapping_index": 3,
            "structured_type": "structured",
            "section_id": "b8ebaadc-fc99-48e5-882d-fad26e99fc33",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:39:58.000",
        "event": "mapping_hover",
        "id": "1Ue3dDDhme07aDuSZ3pG"
    },
    {
        "data": {
            "structured_type": "structured",
            "section_id": "b8ebaadc-fc99-48e5-882d-fad26e99fc33",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:39:58.000",
        "event": "mapping_unhover",
        "id": "3Puorer9K2R77NQwBkwO"
    },
    {
        "data": {
            "structured_type": "structured",
            "section_id": "b8ebaadc-fc99-48e5-882d-fad26e99fc33",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:39:58.000",
        "event": "mapping_unhover",
        "id": "GCbatTZfLgSyaSRlkx0b"
    },
    {
        "data": {
            "structured_type": "structured",
            "section_id": "b8ebaadc-fc99-48e5-882d-fad26e99fc33",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:39:58.000",
        "event": "mapping_unhover",
        "id": "HNBnjE9J3m9sVhmUBtkI"
    },
    {
        "data": {
            "mapping_index": 1,
            "structured_type": "structured",
            "section_id": "b8ebaadc-fc99-48e5-882d-fad26e99fc33",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:39:58.000",
        "event": "mapping_hover",
        "id": "yXRVYr8yaQq05CfZbVH7"
    },
    {
        "data": {
            "structured_type": "structured",
            "section_id": "b8ebaadc-fc99-48e5-882d-fad26e99fc33",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:39:59.000",
        "event": "mapping_unhover",
        "id": "CIm8qJJ5GkzgEJPikCLS"
    },
    {
        "data": {
            "before_detail_level": "medium",
            "after_detail_level": "high",
            "before_structured": "structured",
            "section_id": "b8ebaadc-fc99-48e5-882d-fad26e99fc33",
            "after_structured": "structured"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:39:59.000",
        "event": "change_summary_level",
        "id": "EjucloPtfdEykQvV58Ah"
    },
    {
        "data": {
            "mapping_index": 0,
            "structured_type": "structured",
            "section_id": "b8ebaadc-fc99-48e5-882d-fad26e99fc33",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:39:59.000",
        "event": "mapping_hover",
        "id": "kOv7FrUXNGpQ84ful9sg"
    },
    {
        "data": {
            "mapping_index": 0,
            "structured_type": "structured",
            "section_id": "b8ebaadc-fc99-48e5-882d-fad26e99fc33",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:40:00.000",
        "event": "mapping_hover",
        "id": "6vF1wDAfXv129qvjvhpS"
    },
    {
        "data": {
            "structured_type": "structured",
            "section_id": "b8ebaadc-fc99-48e5-882d-fad26e99fc33",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:40:00.000",
        "event": "mapping_unhover",
        "id": "iqFfBCLX42PYr4y4gTsf"
    },
    {
        "data": {
            "mapping_index": 0,
            "structured_type": "structured",
            "section_id": "b8ebaadc-fc99-48e5-882d-fad26e99fc33",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:40:01.000",
        "event": "mapping_hover",
        "id": "IMUNM0BmVWPBFJ07bU8f"
    },
    {
        "data": {
            "structured_type": "structured",
            "section_id": "b8ebaadc-fc99-48e5-882d-fad26e99fc33",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:40:01.000",
        "event": "mapping_unhover",
        "id": "xGfywBnpGme5pdA9TXCZ"
    },
    {
        "data": {
            "mapping_index": 0,
            "structured_type": "structured",
            "section_id": "b8ebaadc-fc99-48e5-882d-fad26e99fc33",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:40:02.000",
        "event": "mapping_hover",
        "id": "1SXelov6v0LncgzmPsHq"
    },
    {
        "data": {
            "structured_type": "structured",
            "section_id": "b8ebaadc-fc99-48e5-882d-fad26e99fc33",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:40:03.000",
        "event": "mapping_unhover",
        "id": "EEMwuwYaABmxdICVaZIi"
    },
    {
        "data": {
            "mapping_index": 1,
            "structured_type": "structured",
            "section_id": "b8ebaadc-fc99-48e5-882d-fad26e99fc33",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:40:03.000",
        "event": "mapping_hover",
        "id": "T3THSinww1KoOYfWg5as"
    },
    {
        "data": {
            "structured_type": "structured",
            "section_id": "b8ebaadc-fc99-48e5-882d-fad26e99fc33",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:40:03.000",
        "event": "mapping_unhover",
        "id": "iRoxRLOaMcJjui0AgWDT"
    },
    {
        "data": {
            "mapping_index": 1,
            "structured_type": "structured",
            "section_id": "b8ebaadc-fc99-48e5-882d-fad26e99fc33",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:40:04.000",
        "event": "mapping_hover",
        "id": "Bp9D7ktHQs2i1VwKySf7"
    },
    {
        "data": {
            "mapping_index": 2,
            "structured_type": "structured",
            "section_id": "b8ebaadc-fc99-48e5-882d-fad26e99fc33",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:40:04.000",
        "event": "mapping_hover",
        "id": "foZ4J8oi64IEZ0rCTJnb"
    },
    {
        "data": {
            "structured_type": "structured",
            "section_id": "b8ebaadc-fc99-48e5-882d-fad26e99fc33",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:40:04.000",
        "event": "mapping_unhover",
        "id": "g1PfayDbNaDMYSi3b7yj"
    },
    {
        "data": {
            "mapping_index": 2,
            "structured_type": "structured",
            "section_id": "b8ebaadc-fc99-48e5-882d-fad26e99fc33",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:40:05.000",
        "event": "mapping_hover",
        "id": "Inm5m3Dbhtp6yRkatolu"
    },
    {
        "data": {
            "structured_type": "structured",
            "section_id": "b8ebaadc-fc99-48e5-882d-fad26e99fc33",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:40:05.000",
        "event": "mapping_unhover",
        "id": "U2GPFCwKww7YxoalZiPI"
    },
    {
        "data": {
            "structured_type": "structured",
            "section_id": "b8ebaadc-fc99-48e5-882d-fad26e99fc33",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:40:05.000",
        "event": "mapping_unhover",
        "id": "YATzs4rS2for83RdysIC"
    },
    {
        "data": {
            "structured_type": "structured",
            "section_id": "b8ebaadc-fc99-48e5-882d-fad26e99fc33",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:40:06.000",
        "event": "mapping_unhover",
        "id": "0lBkFl3wGYYTq4QZInab"
    },
    {
        "data": {
            "structured_type": "structured",
            "section_id": "b8ebaadc-fc99-48e5-882d-fad26e99fc33",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:40:06.000",
        "event": "mapping_unhover",
        "id": "1kjGr8j5gGdxieCVMHzJ"
    },
    {
        "data": {
            "structured_type": "structured",
            "section_id": "b8ebaadc-fc99-48e5-882d-fad26e99fc33",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:40:06.000",
        "event": "mapping_unhover",
        "id": "EpQErkePfQezD6D6aFL9"
    },
    {
        "data": {
            "mapping_index": 2,
            "structured_type": "structured",
            "section_id": "b8ebaadc-fc99-48e5-882d-fad26e99fc33",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:40:06.000",
        "event": "mapping_hover",
        "id": "PzptHmwPqY62rwKJnclu"
    },
    {
        "data": {
            "mapping_index": 1,
            "structured_type": "structured",
            "section_id": "b8ebaadc-fc99-48e5-882d-fad26e99fc33",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:40:06.000",
        "event": "mapping_hover",
        "id": "QM8QSFnHD0uvRnThCNO2"
    },
    {
        "data": {
            "mapping_index": 2,
            "structured_type": "structured",
            "section_id": "b8ebaadc-fc99-48e5-882d-fad26e99fc33",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:40:06.000",
        "event": "mapping_hover",
        "id": "eod4zxFD5ed4eZFF9F37"
    },
    {
        "data": {
            "mapping_index": 1,
            "structured_type": "structured",
            "section_id": "b8ebaadc-fc99-48e5-882d-fad26e99fc33",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:40:06.000",
        "event": "mapping_hover",
        "id": "tg8lLHlkFIoCJC8klLvH"
    },
    {
        "data": {
            "mapping_index": 3,
            "structured_type": "structured",
            "section_id": "b8ebaadc-fc99-48e5-882d-fad26e99fc33",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:40:07.000",
        "event": "mapping_hover",
        "id": "X9iazscgSN8L8vFkxrYK"
    },
    {
        "data": {
            "structured_type": "structured",
            "section_id": "b8ebaadc-fc99-48e5-882d-fad26e99fc33",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:40:07.000",
        "event": "mapping_unhover",
        "id": "ocSMFrrwwlKe8rFL2cH9"
    },
    {
        "data": {
            "structured_type": "structured",
            "section_id": "b8ebaadc-fc99-48e5-882d-fad26e99fc33",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:40:07.000",
        "event": "mapping_unhover",
        "id": "zGg4qP0PnEXuv6RwHuZZ"
    },
    {
        "data": {
            "structured_type": "structured",
            "section_id": "b8ebaadc-fc99-48e5-882d-fad26e99fc33",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:40:08.000",
        "event": "mapping_unhover",
        "id": "dIkyfuFsrAcust2xe6Zk"
    },
    {
        "data": {
            "mapping_index": 3,
            "structured_type": "structured",
            "section_id": "b8ebaadc-fc99-48e5-882d-fad26e99fc33",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:40:08.000",
        "event": "mapping_hover",
        "id": "fZXDvvJ4VXlOFnSi7j81"
    },
    {
        "data": {
            "mapping_index": 2,
            "structured_type": "structured",
            "section_id": "b8ebaadc-fc99-48e5-882d-fad26e99fc33",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:40:08.000",
        "event": "mapping_hover",
        "id": "kTj2s66JPC3LWm5FAWhr"
    },
    {
        "data": {
            "structured_type": "structured",
            "section_id": "b8ebaadc-fc99-48e5-882d-fad26e99fc33",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:40:10.000",
        "event": "mapping_unhover",
        "id": "iOTotNnqReas0re56PXG"
    },
    {
        "data": {
            "mapping_index": 4,
            "structured_type": "structured",
            "section_id": "b8ebaadc-fc99-48e5-882d-fad26e99fc33",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:40:10.000",
        "event": "mapping_hover",
        "id": "nkpC7AmZX2ucjj10aD4r"
    },
    {
        "data": {
            "structured_type": "structured",
            "section_id": "b8ebaadc-fc99-48e5-882d-fad26e99fc33",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:40:11.000",
        "event": "mapping_unhover",
        "id": "W7Ha94yCVL01lASTIjDn"
    },
    {
        "data": {
            "structured_type": "structured",
            "section_id": "b8ebaadc-fc99-48e5-882d-fad26e99fc33",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:40:13.000",
        "event": "mapping_unhover",
        "id": "3fApIBxlK5i3aXypIXMP"
    },
    {
        "data": {
            "structured_type": "structured",
            "section_id": "b8ebaadc-fc99-48e5-882d-fad26e99fc33",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:40:13.000",
        "event": "mapping_unhover",
        "id": "84JCm1fkhGo5HQ2HPFub"
    },
    {
        "data": {
            "mapping_index": 4,
            "structured_type": "structured",
            "section_id": "b8ebaadc-fc99-48e5-882d-fad26e99fc33",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:40:13.000",
        "event": "mapping_hover",
        "id": "a52UB6pJooWYWzxkJH5j"
    },
    {
        "data": {
            "mapping_index": 4,
            "structured_type": "structured",
            "section_id": "b8ebaadc-fc99-48e5-882d-fad26e99fc33",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:40:13.000",
        "event": "mapping_hover",
        "id": "azKGfc7ejLg0yNCqOj8V"
    },
    {
        "data": {
            "mapping_index": 5,
            "structured_type": "structured",
            "section_id": "b8ebaadc-fc99-48e5-882d-fad26e99fc33",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:40:13.000",
        "event": "mapping_hover",
        "id": "yTX3T5RqWtx8s5wHBe4J"
    },
    {
        "data": {
            "structured_type": "structured",
            "section_id": "b8ebaadc-fc99-48e5-882d-fad26e99fc33",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:40:14.000",
        "event": "mapping_unhover",
        "id": "6voswouYmey9sXP1LIwQ"
    },
    {
        "data": {
            "mapping_index": 3,
            "structured_type": "structured",
            "section_id": "b8ebaadc-fc99-48e5-882d-fad26e99fc33",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:40:14.000",
        "event": "mapping_hover",
        "id": "LApzzw9HBjAI0dSwZwBt"
    },
    {
        "data": {
            "structured_type": "structured",
            "section_id": "b8ebaadc-fc99-48e5-882d-fad26e99fc33",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:40:14.000",
        "event": "mapping_unhover",
        "id": "qXKVl25CzULY7QDtGYbB"
    },
    {
        "data": {
            "mapping_index": 4,
            "structured_type": "structured",
            "section_id": "b8ebaadc-fc99-48e5-882d-fad26e99fc33",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:40:15.000",
        "event": "mapping_hover",
        "id": "0jsyc3857rG5SH9JgchQ"
    },
    {
        "data": {
            "structured_type": "structured",
            "section_id": "b8ebaadc-fc99-48e5-882d-fad26e99fc33",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:40:15.000",
        "event": "mapping_unhover",
        "id": "3temoGIvEYBOi462JwMY"
    },
    {
        "data": {
            "structured_type": "structured",
            "section_id": "b8ebaadc-fc99-48e5-882d-fad26e99fc33",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:40:16.000",
        "event": "mapping_unhover",
        "id": "7f7xhn5152DZEicwAW6b"
    },
    {
        "data": {
            "mapping_index": 3,
            "structured_type": "structured",
            "section_id": "b8ebaadc-fc99-48e5-882d-fad26e99fc33",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:40:16.000",
        "event": "mapping_hover",
        "id": "JxEHWmLWkFEPpyEAOrcb"
    },
    {
        "data": {
            "mapping_index": 4,
            "structured_type": "structured",
            "section_id": "b8ebaadc-fc99-48e5-882d-fad26e99fc33",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:40:16.000",
        "event": "mapping_hover",
        "id": "tvmvkPZ1bL78pKdxrcuG"
    },
    {
        "data": {
            "structured_type": "structured",
            "section_id": "b8ebaadc-fc99-48e5-882d-fad26e99fc33",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:40:18.000",
        "event": "mapping_unhover",
        "id": "ZoFJAxzbrOa14L0llxCN"
    },
    {
        "data": {
            "mapping_index": 5,
            "structured_type": "structured",
            "section_id": "b8ebaadc-fc99-48e5-882d-fad26e99fc33",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:40:18.000",
        "event": "mapping_hover",
        "id": "wQwuvCsKZv8hsenOgBSO"
    },
    {
        "data": {
            "structured_type": "structured",
            "section_id": "b8ebaadc-fc99-48e5-882d-fad26e99fc33",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:40:19.000",
        "event": "mapping_unhover",
        "id": "hzSKyzKG6WGrXv310FQp"
    },
    {
        "data": {
            "mapping_index": 6,
            "structured_type": "structured",
            "section_id": "b8ebaadc-fc99-48e5-882d-fad26e99fc33",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:40:20.000",
        "event": "mapping_hover",
        "id": "3dSWCjnliMyr1Fxtlh6p"
    },
    {
        "data": {
            "structured_type": "structured",
            "section_id": "b8ebaadc-fc99-48e5-882d-fad26e99fc33",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:40:24.000",
        "event": "mapping_unhover",
        "id": "Ihhs30jyspp6uTJPfLip"
    },
    {
        "data": {
            "mapping_index": 6,
            "structured_type": "structured",
            "section_id": "b8ebaadc-fc99-48e5-882d-fad26e99fc33",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:40:25.000",
        "event": "mapping_hover",
        "id": "63TFG7YdloT0pJXJASW1"
    },
    {
        "data": {
            "structured_type": "structured",
            "section_id": "b8ebaadc-fc99-48e5-882d-fad26e99fc33",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:40:25.000",
        "event": "mapping_unhover",
        "id": "NTgckpVcB0Z4a26c7RFM"
    },
    {
        "data": {
            "mapping_index": 7,
            "structured_type": "structured",
            "section_id": "b8ebaadc-fc99-48e5-882d-fad26e99fc33",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:40:25.000",
        "event": "mapping_hover",
        "id": "YQSXZl4m0H1HbbeQjNr9"
    },
    {
        "data": {
            "mapping_index": 5,
            "structured_type": "structured",
            "section_id": "b8ebaadc-fc99-48e5-882d-fad26e99fc33",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:40:25.000",
        "event": "mapping_hover",
        "id": "aHyxt7OYL88O26Yy8e13"
    },
    {
        "data": {
            "structured_type": "structured",
            "section_id": "b8ebaadc-fc99-48e5-882d-fad26e99fc33",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:40:25.000",
        "event": "mapping_unhover",
        "id": "uSyzjRe7PwpPFD40wyKS"
    },
    {
        "data": {
            "structured_type": "structured",
            "section_id": "b8ebaadc-fc99-48e5-882d-fad26e99fc33",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:40:26.000",
        "event": "mapping_unhover",
        "id": "mRRuaPm98PRJGL89dthd"
    },
    {
        "data": {
            "structured_type": "structured",
            "section_id": "b8ebaadc-fc99-48e5-882d-fad26e99fc33",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:40:27.000",
        "event": "mapping_unhover",
        "id": "4Wy1Btcnhx1FBaAbkKGD"
    },
    {
        "data": {
            "mapping_index": 7,
            "structured_type": "structured",
            "section_id": "b8ebaadc-fc99-48e5-882d-fad26e99fc33",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:40:27.000",
        "event": "mapping_hover",
        "id": "5nsiOwoACRZDGAztNvwG"
    },
    {
        "data": {
            "mapping_index": 6,
            "structured_type": "structured",
            "section_id": "b8ebaadc-fc99-48e5-882d-fad26e99fc33",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:40:27.000",
        "event": "mapping_hover",
        "id": "cRDEmgO1iMEsnBJBwtyN"
    },
    {
        "data": {
            "structured_type": "structured",
            "section_id": "b8ebaadc-fc99-48e5-882d-fad26e99fc33",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:40:30.000",
        "event": "mapping_unhover",
        "id": "YKXFNCt4pAGvEybTWKaS"
    },
    {
        "data": {
            "mapping_index": 7,
            "structured_type": "structured",
            "section_id": "b8ebaadc-fc99-48e5-882d-fad26e99fc33",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:40:31.000",
        "event": "mapping_hover",
        "id": "2kZHXQCto7H1bxHLbgb1"
    },
    {
        "data": {
            "mapping_index": 6,
            "structured_type": "structured",
            "section_id": "b8ebaadc-fc99-48e5-882d-fad26e99fc33",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:40:31.000",
        "event": "mapping_hover",
        "id": "LERfJwHgxiTIfBoR7d20"
    },
    {
        "data": {
            "structured_type": "structured",
            "section_id": "b8ebaadc-fc99-48e5-882d-fad26e99fc33",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:40:31.000",
        "event": "mapping_unhover",
        "id": "XbG8UeVpx9UlO7Mgjflq"
    },
    {
        "data": {
            "structured_type": "structured",
            "section_id": "b8ebaadc-fc99-48e5-882d-fad26e99fc33",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:40:32.000",
        "event": "mapping_unhover",
        "id": "39qqqaBvs7kiQWgek8gv"
    },
    {
        "data": {
            "mapping_index": 8,
            "structured_type": "structured",
            "section_id": "b8ebaadc-fc99-48e5-882d-fad26e99fc33",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:40:32.000",
        "event": "mapping_hover",
        "id": "sRKKEUofam6HbwHzAKNW"
    },
    {
        "data": {
            "mapping_index": 7,
            "structured_type": "structured",
            "section_id": "b8ebaadc-fc99-48e5-882d-fad26e99fc33",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:40:35.000",
        "event": "mapping_hover",
        "id": "gVBrSshM6MreoIxJASgh"
    },
    {
        "data": {
            "structured_type": "structured",
            "section_id": "b8ebaadc-fc99-48e5-882d-fad26e99fc33",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:40:35.000",
        "event": "mapping_unhover",
        "id": "lX4scacNQaBv3bKPfM4H"
    },
    {
        "data": {
            "structured_type": "structured",
            "section_id": "b8ebaadc-fc99-48e5-882d-fad26e99fc33",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:40:39.000",
        "event": "mapping_unhover",
        "id": "eTbZTqB44ufKWfRwXQ18"
    },
    {
        "data": {
            "mapping_index": 8,
            "structured_type": "structured",
            "section_id": "b8ebaadc-fc99-48e5-882d-fad26e99fc33",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:40:39.000",
        "event": "mapping_hover",
        "id": "o4HGWKzRxYMhF8oBvNJ1"
    },
    {
        "data": {
            "mapping_index": 9,
            "structured_type": "structured",
            "section_id": "b8ebaadc-fc99-48e5-882d-fad26e99fc33",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:40:40.000",
        "event": "mapping_hover",
        "id": "ArZg5iUuNWEu4ShHcDR9"
    },
    {
        "data": {
            "structured_type": "structured",
            "section_id": "b8ebaadc-fc99-48e5-882d-fad26e99fc33",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:40:40.000",
        "event": "mapping_unhover",
        "id": "NSR4xDqiGpkpNLdWEMas"
    },
    {
        "data": {
            "mapping_index": 8,
            "structured_type": "structured",
            "section_id": "b8ebaadc-fc99-48e5-882d-fad26e99fc33",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:40:40.000",
        "event": "mapping_hover",
        "id": "mnENct8hTf1s7F001NoE"
    },
    {
        "data": {
            "structured_type": "structured",
            "section_id": "b8ebaadc-fc99-48e5-882d-fad26e99fc33",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:40:40.000",
        "event": "mapping_unhover",
        "id": "nj5EER0UBHFgBoCMnA5W"
    },
    {
        "data": {
            "structured_type": "structured",
            "section_id": "b8ebaadc-fc99-48e5-882d-fad26e99fc33",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:40:41.000",
        "event": "mapping_unhover",
        "id": "Do0bmbomBe4MQM2D5wER"
    },
    {
        "data": {
            "mapping_index": 9,
            "structured_type": "structured",
            "section_id": "b8ebaadc-fc99-48e5-882d-fad26e99fc33",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:40:41.000",
        "event": "mapping_hover",
        "id": "DqZErqWbZiAYx8uKdUJz"
    },
    {
        "data": {
            "structured_type": "structured",
            "section_id": "b8ebaadc-fc99-48e5-882d-fad26e99fc33",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:40:42.000",
        "event": "mapping_unhover",
        "id": "RPDkcJXINs2Z85x8EZZB"
    },
    {
        "data": {
            "structured_type": "structured",
            "section_id": "b8ebaadc-fc99-48e5-882d-fad26e99fc33",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:40:42.000",
        "event": "mapping_unhover",
        "id": "WdwSqdW0aaY7LcHYCdMf"
    },
    {
        "data": {
            "mapping_index": 8,
            "structured_type": "structured",
            "section_id": "b8ebaadc-fc99-48e5-882d-fad26e99fc33",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:40:42.000",
        "event": "mapping_hover",
        "id": "vKI8fzrKiRI0mMldrGyk"
    },
    {
        "data": {
            "structured_type": "structured",
            "section_id": "b8ebaadc-fc99-48e5-882d-fad26e99fc33",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:40:43.000",
        "event": "mapping_unhover",
        "id": "C1Xpz4mTFlAPsC2kJcyK"
    },
    {
        "data": {
            "mapping_index": 9,
            "structured_type": "structured",
            "section_id": "b8ebaadc-fc99-48e5-882d-fad26e99fc33",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:40:43.000",
        "event": "mapping_hover",
        "id": "dHPgl3aVbQQkqdjSmCkz"
    },
    {
        "data": {
            "mapping_index": 8,
            "structured_type": "structured",
            "section_id": "b8ebaadc-fc99-48e5-882d-fad26e99fc33",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:40:43.000",
        "event": "mapping_hover",
        "id": "gIAbpmMte89zrt6YKvdM"
    },
    {
        "data": {
            "structured_type": "structured",
            "section_id": "b8ebaadc-fc99-48e5-882d-fad26e99fc33",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:40:45.000",
        "event": "mapping_unhover",
        "id": "75n8KOUh3wDAyzY7H0p3"
    },
    {
        "data": {
            "structured_type": "structured",
            "section_id": "b8ebaadc-fc99-48e5-882d-fad26e99fc33",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:40:45.000",
        "event": "mapping_unhover",
        "id": "COQcLWb4695B6f5l2inF"
    },
    {
        "data": {
            "structured_type": "structured",
            "section_id": "b8ebaadc-fc99-48e5-882d-fad26e99fc33",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:40:45.000",
        "event": "mapping_unhover",
        "id": "LlaenZMLpc9doeyQSsXG"
    },
    {
        "data": {
            "mapping_index": 2,
            "structured_type": "structured",
            "section_id": "b8ebaadc-fc99-48e5-882d-fad26e99fc33",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:40:45.000",
        "event": "mapping_hover",
        "id": "T9InibpKKtbWNbmQGO10"
    },
    {
        "data": {
            "mapping_index": 4,
            "structured_type": "structured",
            "section_id": "b8ebaadc-fc99-48e5-882d-fad26e99fc33",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:40:45.000",
        "event": "mapping_hover",
        "id": "YSvEwHDf1gH0UkPSfVFu"
    },
    {
        "data": {
            "mapping_index": 1,
            "structured_type": "structured",
            "section_id": "b8ebaadc-fc99-48e5-882d-fad26e99fc33",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:40:45.000",
        "event": "mapping_hover",
        "id": "ZyDb277yF2r627xMZM81"
    },
    {
        "data": {
            "structured_type": "structured",
            "section_id": "b8ebaadc-fc99-48e5-882d-fad26e99fc33",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:40:45.000",
        "event": "mapping_unhover",
        "id": "i3j32SsMpk88IMwZIpFL"
    },
    {
        "data": {
            "structured_type": "structured",
            "section_id": "b8ebaadc-fc99-48e5-882d-fad26e99fc33",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:40:45.000",
        "event": "mapping_unhover",
        "id": "v0WI5H3fy3B1KUPgwndU"
    },
    {
        "data": {
            "mapping_index": 0,
            "structured_type": "structured",
            "section_id": "b8ebaadc-fc99-48e5-882d-fad26e99fc33",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:40:45.000",
        "event": "mapping_hover",
        "id": "y3e8QHS3RJXIY2bjMFr1"
    },
    {
        "data": {
            "before_detail_level": "high",
            "after_detail_level": "medium",
            "before_structured": "structured",
            "section_id": "b8ebaadc-fc99-48e5-882d-fad26e99fc33",
            "after_structured": "structured"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:40:46.000",
        "event": "change_summary_level",
        "id": "tqFAAN8PYA8BtWYAS1hj"
    },
    {
        "data": {
            "mapping_index": 2,
            "structured_type": "structured",
            "section_id": "b8ebaadc-fc99-48e5-882d-fad26e99fc33",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:40:47.000",
        "event": "mapping_hover",
        "id": "5rNDckfuDko3OP2LPjox"
    },
    {
        "data": {
            "mapping_index": 1,
            "structured_type": "structured",
            "section_id": "b8ebaadc-fc99-48e5-882d-fad26e99fc33",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:40:47.000",
        "event": "mapping_hover",
        "id": "IGW6BsVenJMqoyvAHOB8"
    },
    {
        "data": {
            "structured_type": "structured",
            "section_id": "b8ebaadc-fc99-48e5-882d-fad26e99fc33",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:40:47.000",
        "event": "mapping_unhover",
        "id": "MDgY04Mga4Nn1m6LyQQD"
    },
    {
        "data": {
            "structured_type": "structured",
            "section_id": "b8ebaadc-fc99-48e5-882d-fad26e99fc33",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:40:47.000",
        "event": "mapping_unhover",
        "id": "NqxF99ZQePDv5zyLeYix"
    },
    {
        "data": {
            "structured_type": "structured",
            "section_id": "b8ebaadc-fc99-48e5-882d-fad26e99fc33",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:40:47.000",
        "event": "mapping_unhover",
        "id": "NwaBIFLoVAFJC9dtit0t"
    },
    {
        "data": {
            "structured_type": "structured",
            "section_id": "b8ebaadc-fc99-48e5-882d-fad26e99fc33",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:40:47.000",
        "event": "mapping_unhover",
        "id": "RiN0vhSSM8dyWO7FR63F"
    },
    {
        "data": {
            "mapping_index": 3,
            "structured_type": "structured",
            "section_id": "b8ebaadc-fc99-48e5-882d-fad26e99fc33",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:40:47.000",
        "event": "mapping_hover",
        "id": "ZQ0dxlsIq8zLaORmqijW"
    },
    {
        "data": {
            "mapping_index": 0,
            "structured_type": "structured",
            "section_id": "b8ebaadc-fc99-48e5-882d-fad26e99fc33",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:40:47.000",
        "event": "mapping_hover",
        "id": "e0PKIaw4O6IHs3uQbHU9"
    },
    {
        "data": {
            "mapping_index": 2,
            "structured_type": "structured",
            "section_id": "b8ebaadc-fc99-48e5-882d-fad26e99fc33",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:40:47.000",
        "event": "mapping_hover",
        "id": "kz5BSLw35gzm1GUUyixg"
    },
    {
        "data": {
            "mapping_index": 2,
            "structured_type": "structured",
            "section_id": "b8ebaadc-fc99-48e5-882d-fad26e99fc33",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:40:47.000",
        "event": "mapping_hover",
        "id": "rN7umIxLu8R82UsKTfhT"
    },
    {
        "data": {
            "structured_type": "structured",
            "section_id": "b8ebaadc-fc99-48e5-882d-fad26e99fc33",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:40:47.000",
        "event": "mapping_unhover",
        "id": "wFPkumQIm6yhcRsDAvwt"
    },
    {
        "data": {
            "structured_type": "structured",
            "section_id": "b8ebaadc-fc99-48e5-882d-fad26e99fc33",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:40:48.000",
        "event": "mapping_unhover",
        "id": "6LXEv0nJcx6wYrQDJOW8"
    },
    {
        "data": {
            "structured_type": "structured",
            "section_id": "b8ebaadc-fc99-48e5-882d-fad26e99fc33",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:40:48.000",
        "event": "mapping_unhover",
        "id": "MTQGyj8qRPBS5ftcVOzC"
    },
    {
        "data": {
            "mapping_index": 1,
            "structured_type": "structured",
            "section_id": "b8ebaadc-fc99-48e5-882d-fad26e99fc33",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:40:48.000",
        "event": "mapping_hover",
        "id": "xCscNSLqsCGFZ3Wp7DLl"
    },
    {
        "data": {
            "structured_type": "structured",
            "section_id": "b8ebaadc-fc99-48e5-882d-fad26e99fc33",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:40:50.000",
        "event": "mapping_unhover",
        "id": "8z6IfHzGiVNmsxCV4cBS"
    },
    {
        "data": {
            "mapping_index": 0,
            "structured_type": "structured",
            "section_id": "b8ebaadc-fc99-48e5-882d-fad26e99fc33",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:40:50.000",
        "event": "mapping_hover",
        "id": "9iZDbIwWl9vLXQ4mHSNr"
    },
    {
        "data": {
            "structured_type": "structured",
            "section_id": "b8ebaadc-fc99-48e5-882d-fad26e99fc33",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:40:50.000",
        "event": "mapping_unhover",
        "id": "LPxvYpJu1BK71TzkNJlk"
    },
    {
        "data": {
            "mapping_index": 3,
            "structured_type": "structured",
            "section_id": "b8ebaadc-fc99-48e5-882d-fad26e99fc33",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:40:50.000",
        "event": "mapping_hover",
        "id": "LVkyQAj8sRndTV5q1yPF"
    },
    {
        "data": {
            "structured_type": "structured",
            "section_id": "b8ebaadc-fc99-48e5-882d-fad26e99fc33",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:40:50.000",
        "event": "mapping_unhover",
        "id": "XULo89DaIWW0MeFkXpj7"
    },
    {
        "data": {
            "mapping_index": 2,
            "structured_type": "structured",
            "section_id": "b8ebaadc-fc99-48e5-882d-fad26e99fc33",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:40:50.000",
        "event": "mapping_hover",
        "id": "bHT3dfsyUVGF02ZPY1uW"
    },
    {
        "data": {
            "mapping_index": 1,
            "structured_type": "structured",
            "section_id": "b8ebaadc-fc99-48e5-882d-fad26e99fc33",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:40:50.000",
        "event": "mapping_hover",
        "id": "tPTM6OcwZgPRqTd0gHig"
    },
    {
        "data": {
            "mapping_index": 2,
            "structured_type": "structured",
            "section_id": "b8ebaadc-fc99-48e5-882d-fad26e99fc33",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:40:51.000",
        "event": "mapping_hover",
        "id": "7N5hArDe5msVw4i63K2p"
    },
    {
        "data": {
            "structured_type": "structured",
            "section_id": "b8ebaadc-fc99-48e5-882d-fad26e99fc33",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:40:51.000",
        "event": "mapping_unhover",
        "id": "r5GjjqmO8PvDn2HUeJuC"
    },
    {
        "data": {
            "structured_type": "structured",
            "section_id": "b8ebaadc-fc99-48e5-882d-fad26e99fc33",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:40:51.000",
        "event": "mapping_unhover",
        "id": "unQjYfmwNy0R0HQqeOoB"
    },
    {
        "data": {
            "structured_type": "structured",
            "section_id": "b8ebaadc-fc99-48e5-882d-fad26e99fc33",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:40:52.000",
        "event": "mapping_unhover",
        "id": "4V11gb29XCoDGLyrcOM1"
    },
    {
        "data": {
            "mapping_index": 2,
            "structured_type": "structured",
            "section_id": "b8ebaadc-fc99-48e5-882d-fad26e99fc33",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:40:52.000",
        "event": "mapping_hover",
        "id": "8XAQDbdjX347LlRylSdX"
    },
    {
        "data": {
            "mapping_index": 0,
            "structured_type": "structured",
            "section_id": "b8ebaadc-fc99-48e5-882d-fad26e99fc33",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:40:52.000",
        "event": "mapping_hover",
        "id": "HUxp7O1xJMiXl1Voj07i"
    },
    {
        "data": {
            "structured_type": "structured",
            "section_id": "b8ebaadc-fc99-48e5-882d-fad26e99fc33",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:40:52.000",
        "event": "mapping_unhover",
        "id": "JqCmp01eyRhWSptY6a0x"
    },
    {
        "data": {
            "mapping_index": 1,
            "structured_type": "structured",
            "section_id": "b8ebaadc-fc99-48e5-882d-fad26e99fc33",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:40:52.000",
        "event": "mapping_hover",
        "id": "OkWeJ00NZFXaPI8FWZxM"
    },
    {
        "data": {
            "mapping_index": 2,
            "structured_type": "structured",
            "section_id": "b8ebaadc-fc99-48e5-882d-fad26e99fc33",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:40:52.000",
        "event": "mapping_hover",
        "id": "XZwTVk8EdN2gBPUAZ4uV"
    },
    {
        "data": {
            "structured_type": "structured",
            "section_id": "b8ebaadc-fc99-48e5-882d-fad26e99fc33",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:40:52.000",
        "event": "mapping_unhover",
        "id": "cKMEZS6PEYeWefOdfteG"
    },
    {
        "data": {
            "structured_type": "structured",
            "section_id": "b8ebaadc-fc99-48e5-882d-fad26e99fc33",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:40:52.000",
        "event": "mapping_unhover",
        "id": "rnlUjQ5a5hiveIPEIDhe"
    },
    {
        "data": {
            "structured_type": "structured",
            "section_id": "b8ebaadc-fc99-48e5-882d-fad26e99fc33",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:40:53.000",
        "event": "mapping_unhover",
        "id": "gqyKcO7vJmc19AESmDQE"
    },
    {
        "data": {
            "mapping_index": 1,
            "structured_type": "structured",
            "section_id": "b8ebaadc-fc99-48e5-882d-fad26e99fc33",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:40:53.000",
        "event": "mapping_hover",
        "id": "oDX7Lqqp9ucFmMe1hQAC"
    },
    {
        "data": {
            "mapping_index": 2,
            "structured_type": "structured",
            "section_id": "b8ebaadc-fc99-48e5-882d-fad26e99fc33",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:40:53.000",
        "event": "mapping_hover",
        "id": "vxuEPUzHraTCF8dzOKAY"
    },
    {
        "data": {
            "structured_type": "structured",
            "section_id": "b8ebaadc-fc99-48e5-882d-fad26e99fc33",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:40:55.000",
        "event": "mapping_unhover",
        "id": "MyHUEM1ZAJgaHVU7MYTS"
    },
    {
        "data": {
            "structured_type": "structured",
            "section_id": "b8ebaadc-fc99-48e5-882d-fad26e99fc33",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:40:55.000",
        "event": "mapping_unhover",
        "id": "NNFtB5RkYrdHFnOE92dF"
    },
    {
        "data": {
            "structured_type": "structured",
            "section_id": "b8ebaadc-fc99-48e5-882d-fad26e99fc33",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:40:55.000",
        "event": "mapping_unhover",
        "id": "OHNqESQ0MJtLlKXW1Itx"
    },
    {
        "data": {
            "mapping_index": 1,
            "structured_type": "structured",
            "section_id": "b8ebaadc-fc99-48e5-882d-fad26e99fc33",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:40:55.000",
        "event": "mapping_hover",
        "id": "t8YmVnWLvdcXVu3WsFQa"
    },
    {
        "data": {
            "mapping_index": 0,
            "structured_type": "structured",
            "section_id": "b8ebaadc-fc99-48e5-882d-fad26e99fc33",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:40:55.000",
        "event": "mapping_hover",
        "id": "vrS6dFxQM3yLjeB83XAo"
    },
    {
        "data": {
            "structured_type": "structured",
            "section_id": "b8ebaadc-fc99-48e5-882d-fad26e99fc33",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:40:56.000",
        "event": "mapping_unhover",
        "id": "9VxIrjPFvP0ewUKPpMsC"
    },
    {
        "data": {
            "mapping_index": 1,
            "structured_type": "structured",
            "section_id": "b8ebaadc-fc99-48e5-882d-fad26e99fc33",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:40:56.000",
        "event": "mapping_hover",
        "id": "LTwY30dJBgd6u9g377lh"
    },
    {
        "data": {
            "mapping_index": 0,
            "structured_type": "structured",
            "section_id": "b8ebaadc-fc99-48e5-882d-fad26e99fc33",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:40:56.000",
        "event": "mapping_hover",
        "id": "XqothutXd3MyL9Xf4vPi"
    },
    {
        "data": {
            "structured_type": "structured",
            "section_id": "b8ebaadc-fc99-48e5-882d-fad26e99fc33",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:40:56.000",
        "event": "mapping_unhover",
        "id": "gZpLjdZBUzwF6ie0kFXS"
    },
    {
        "data": {
            "mapping_index": 2,
            "structured_type": "structured",
            "section_id": "b8ebaadc-fc99-48e5-882d-fad26e99fc33",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:40:56.000",
        "event": "mapping_hover",
        "id": "vPfGvfYBikzjBMUJt4Lb"
    },
    {
        "data": {
            "mapping_index": 0,
            "structured_type": "structured",
            "section_id": "b8ebaadc-fc99-48e5-882d-fad26e99fc33",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:40:58.000",
        "event": "mapping_hover",
        "id": "5pDNBL2br9ib9vUacYtn"
    },
    {
        "data": {
            "structured_type": "structured",
            "section_id": "b8ebaadc-fc99-48e5-882d-fad26e99fc33",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:40:58.000",
        "event": "mapping_unhover",
        "id": "6ZLw9gteJST293WbBRmS"
    },
    {
        "data": {
            "mapping_index": 1,
            "structured_type": "structured",
            "section_id": "b8ebaadc-fc99-48e5-882d-fad26e99fc33",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:40:58.000",
        "event": "mapping_hover",
        "id": "K6K9Wi0ikLMbXBgHpCJg"
    },
    {
        "data": {
            "structured_type": "structured",
            "section_id": "b8ebaadc-fc99-48e5-882d-fad26e99fc33",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:40:58.000",
        "event": "mapping_unhover",
        "id": "Rc0LmggiRsMYxUjUChbK"
    },
    {
        "data": {
            "structured_type": "structured",
            "section_id": "b8ebaadc-fc99-48e5-882d-fad26e99fc33",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:40:58.000",
        "event": "mapping_unhover",
        "id": "f4SXPdHTNt1oC5n9TZck"
    },
    {
        "data": {
            "before_detail_level": "medium",
            "after_detail_level": "low",
            "before_structured": "structured",
            "section_id": "b8ebaadc-fc99-48e5-882d-fad26e99fc33",
            "after_structured": "structured"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:41:02.000",
        "event": "change_summary_level",
        "id": "EaneyBtQyYwEfhsCzmZB"
    },
    {
        "data": {
            "structured_type": "structured",
            "section_id": "b8ebaadc-fc99-48e5-882d-fad26e99fc33",
            "detail_level": "low"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:41:03.000",
        "event": "mapping_unhover",
        "id": "4QFCM0zn0X6aqm8QVJHn"
    },
    {
        "data": {
            "structured_type": "structured",
            "section_id": "b8ebaadc-fc99-48e5-882d-fad26e99fc33",
            "detail_level": "low"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:41:03.000",
        "event": "mapping_unhover",
        "id": "4otC20CP2O8fxtlkmrW2"
    },
    {
        "data": {
            "mapping_index": 2,
            "structured_type": "structured",
            "section_id": "b8ebaadc-fc99-48e5-882d-fad26e99fc33",
            "detail_level": "low"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:41:03.000",
        "event": "mapping_hover",
        "id": "Bdo6apTMIzIswC85h4Zx"
    },
    {
        "data": {
            "mapping_index": 1,
            "structured_type": "structured",
            "section_id": "b8ebaadc-fc99-48e5-882d-fad26e99fc33",
            "detail_level": "low"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:41:03.000",
        "event": "mapping_hover",
        "id": "G1k9PccnQd1gaESzq1Sx"
    },
    {
        "data": {
            "mapping_index": 0,
            "structured_type": "structured",
            "section_id": "b8ebaadc-fc99-48e5-882d-fad26e99fc33",
            "detail_level": "low"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:41:03.000",
        "event": "mapping_hover",
        "id": "T1gQW6U50YEp5E9Ycx34"
    },
    {
        "data": {
            "structured_type": "structured",
            "section_id": "b8ebaadc-fc99-48e5-882d-fad26e99fc33",
            "detail_level": "low"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:41:03.000",
        "event": "mapping_unhover",
        "id": "VlOKmI8qHBKFupoAEqRs"
    },
    {
        "data": {
            "mapping_index": 1,
            "structured_type": "structured",
            "section_id": "b8ebaadc-fc99-48e5-882d-fad26e99fc33",
            "detail_level": "low"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:41:03.000",
        "event": "mapping_hover",
        "id": "b5f1ajFk5S87f4FtLZf5"
    },
    {
        "data": {
            "structured_type": "structured",
            "section_id": "b8ebaadc-fc99-48e5-882d-fad26e99fc33",
            "detail_level": "low"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:41:03.000",
        "event": "mapping_unhover",
        "id": "hoAcYvWoaRBweJJ20pxG"
    },
    {
        "data": {
            "mapping_index": 0,
            "structured_type": "structured",
            "section_id": "b8ebaadc-fc99-48e5-882d-fad26e99fc33",
            "detail_level": "low"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:41:03.000",
        "event": "mapping_hover",
        "id": "n4vbdfna7gCtGNEC3r9j"
    },
    {
        "data": {
            "structured_type": "structured",
            "section_id": "b8ebaadc-fc99-48e5-882d-fad26e99fc33",
            "detail_level": "low"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:41:03.000",
        "event": "mapping_unhover",
        "id": "znz4GAJrap0PZDrD36OL"
    },
    {
        "data": {
            "before_detail_level": "low",
            "after_detail_level": "medium",
            "before_structured": "structured",
            "section_id": "b8ebaadc-fc99-48e5-882d-fad26e99fc33",
            "after_structured": "structured"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:41:04.000",
        "event": "change_summary_level",
        "id": "Z1yn9rw2Wau4m9mPPvj3"
    },
    {
        "data": {
            "before_detail_level": "medium",
            "after_detail_level": "high",
            "before_structured": "structured",
            "section_id": "b8ebaadc-fc99-48e5-882d-fad26e99fc33",
            "after_structured": "structured"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:41:04.000",
        "event": "change_summary_level",
        "id": "ftgomi6U5RgEDOYyWXrj"
    },
    {
        "data": {},
        "source": "frontend",
        "timestamp": "2025-08-23 10:41:32.000",
        "event": "click_summarize_code",
        "id": "URHF0w1cnZAZdT5k3GMc"
    },
    {
        "data": {
            "selected_code": "def main():\n    X, y, group, df = load_data()\n\n    # Train-test split on years\n    unique_years = df[\"Year\"].unique()\n    train_years, test_years = (\n        unique_years[:-2],  # train: 2015-2023\n        unique_years[-2:],  # test: 2024-2025\n    )\n\n    train_idx = df[\"Year\"].isin(train_years)\n    test_idx = df[\"Year\"].isin(test_years)\n\n    X_train, X_test = X[train_idx], X[test_idx]\n    y_train, y_test = y[train_idx], y[test_idx]\n\n    # Group sizes\n    train_groups = df[train_idx].groupby(\"Year\").size().to_numpy()\n    test_groups = df[test_idx].groupby(\"Year\").size().to_numpy()\n\n    # Model\n    model = XGBRanker(\n        objective=\"rank:pairwise\",\n        learning_rate=0.1,\n        n_estimators=100,\n        max_depth=4,\n        random_state=42,\n    )\n\n    print(\"Training XGBoostRanker...\")\n    model.fit(X_train, y_train, group=train_groups)\n\n    # Predict, sort, and evaluate\n    y_pred = model.predict(X_test)\n    df.loc[test_idx, \"PredictedScore\"] = y_pred\n    df.loc[test_idx, \"PredictedRank\"] = (\n        df.loc[test_idx]\n        .groupby(\"Year\")[\"PredictedScore\"]\n        .rank(ascending=False, method=\"first\")\n    )\n\n    ndcg = evaluate_ndcg(y_test.to_numpy(), y_pred, test_groups)\n    print(f\"NDCG Score on test years {test_years.tolist()}: {ndcg:.4f}\")\n\n    # Show results\n    print(df[test_idx][[\"Year\", \"Name\", \"Rank\", \"PredictedScore\", \"PredictedRank\"]])\n    plot_ranking_predictions(df, 2024)\n    plot_ranking_predictions(df, 2025)",
            "summary": {
                "medium_unstructured": "The main() function loads data, splits it into training and test sets based on years, and trains an XGBoost ranking model. It predicts MVP rankings for the test years, evaluates the model's performance using the NDCG metric, and prints the results. Finally, it generates plots to visualize prediction errors for the test years.",
                "low_structured": "• Loads data and splits it into training and testing sets by year\n• Trains an XGBoost ranking model\n• Predicts and evaluates MVP rankings for test years",
                "title": "Summary of the main() Function for MVP Ranking with XGBoostRanker",
                "medium_structured": "• Loads data and separates it into features, labels, groups, and the full DataFrame\n• Splits data into training (all but last two years) and testing (last two years) sets\n• Trains an XGBoostRanker model on the training data\n• Predicts and ranks MVPs for the test years\n  ◦ Evaluates performance using NDCG\n  ◦ Prints and visualizes results for the test years",
                "high_unstructured": "The main() function orchestrates the process of training and evaluating an XGBoostRanker for MVP prediction. It first loads the dataset and splits it into training and testing sets based on years, ensuring that the most recent two years are reserved for testing. The model is trained on the training set using group information to respect the ranking structure within each year. After making predictions for the test years, it assigns predicted ranks, evaluates the model's performance using the NDCG metric, prints detailed results, and generates bar plots visualizing prediction errors for each test year.",
                "high_structured": "• Loads data and extracts features (X), labels (y), group sizes, and the full DataFrame\n• Splits data by year:\n  ◦ Training: all years except the last two\n  ◦ Testing: the last two years\n• Creates boolean indices to separate training and test data\n• Prepares group sizes for both training and testing sets\n• Initializes and trains an XGBoostRanker model with specified hyperparameters\n  ◦ Uses group information to handle ranking within each year\n• Predicts scores for the test set and assigns predicted ranks within each year\n  ◦ Stores predicted scores and ranks in the DataFrame\n• Evaluates model performance using the NDCG metric and prints the result\n• Displays detailed prediction results for the test years\n• Generates and saves bar plots of prediction errors for each test year",
                "low_unstructured": "This function trains and evaluates an XGBoost ranking model to predict MVP rankings for recent years."
            }
        },
        "source": "backend",
        "timestamp": "2025-08-23 10:41:39.000",
        "event": "summarize_selected_code",
        "id": "xIZjZ8fNiFGKjtQf2mPm"
    },
    {
        "data": {
            "mapping": [
                {
                    "summaryComponent": "Loads data and splits it into training and testing sets by year",
                    "codeSegments": [
                        {
                            "line": 75,
                            "code": "X, y, group, df = load_data()"
                        },
                        {
                            "line": 78,
                            "code": "unique_years = df[\"Year\"].unique()"
                        },
                        {
                            "line": 79,
                            "code": "train_years, test_years = ("
                        },
                        {
                            "line": 84,
                            "code": "train_idx = df[\"Year\"].isin(train_years)"
                        },
                        {
                            "line": 85,
                            "code": "test_idx = df[\"Year\"].isin(test_years)"
                        },
                        {
                            "line": 87,
                            "code": "X_train, X_test = X[train_idx], X[test_idx]"
                        },
                        {
                            "line": 88,
                            "code": "y_train, y_test = y[train_idx], y[test_idx]"
                        }
                    ]
                },
                {
                    "summaryComponent": "Trains an XGBoost ranking model",
                    "codeSegments": [
                        {
                            "line": 95,
                            "code": "model = XGBRanker("
                        },
                        {
                            "line": 104,
                            "code": "model.fit(X_train, y_train, group=train_groups)"
                        }
                    ]
                },
                {
                    "summaryComponent": "Predicts and evaluates MVP rankings for test years",
                    "codeSegments": [
                        {
                            "line": 107,
                            "code": "y_pred = model.predict(X_test)"
                        },
                        {
                            "line": 108,
                            "code": "df.loc[test_idx, \"PredictedScore\"] = y_pred"
                        },
                        {
                            "line": 109,
                            "code": "df.loc[test_idx, \"PredictedRank\"] = ("
                        },
                        {
                            "line": 115,
                            "code": "ndcg = evaluate_ndcg(y_test.to_numpy(), y_pred, test_groups)"
                        },
                        {
                            "line": 116,
                            "code": "print(f\"NDCG Score on test years {test_years.tolist()}: {ndcg:.4f}\")"
                        },
                        {
                            "line": 119,
                            "code": "print(df[test_idx][[\"Year\", \"Name\", \"Rank\", \"PredictedScore\", \"PredictedRank\"]])"
                        },
                        {
                            "line": 120,
                            "code": "plot_ranking_predictions(df, 2024)"
                        },
                        {
                            "line": 121,
                            "code": "plot_ranking_predictions(df, 2025)"
                        }
                    ]
                }
            ],
            "summary": "• Loads data and splits it into training and testing sets by year\n• Trains an XGBoost ranking model\n• Predicts and evaluates MVP rankings for test years",
            "code": "74: def main():\n75:     X, y, group, df = load_data()\n76: \n77:     # Train-test split on years\n78:     unique_years = df[\"Year\"].unique()\n79:     train_years, test_years = (\n80:         unique_years[:-2],  # train: 2015-2023\n81:         unique_years[-2:],  # test: 2024-2025\n82:     )\n83: \n84:     train_idx = df[\"Year\"].isin(train_years)\n85:     test_idx = df[\"Year\"].isin(test_years)\n86: \n87:     X_train, X_test = X[train_idx], X[test_idx]\n88:     y_train, y_test = y[train_idx], y[test_idx]\n89: \n90:     # Group sizes\n91:     train_groups = df[train_idx].groupby(\"Year\").size().to_numpy()\n92:     test_groups = df[test_idx].groupby(\"Year\").size().to_numpy()\n93: \n94:     # Model\n95:     model = XGBRanker(\n96:         objective=\"rank:pairwise\",\n97:         learning_rate=0.1,\n98:         n_estimators=100,\n99:         max_depth=4,\n100:         random_state=42,\n101:     )\n102: \n103:     print(\"Training XGBoostRanker...\")\n104:     model.fit(X_train, y_train, group=train_groups)\n105: \n106:     # Predict, sort, and evaluate\n107:     y_pred = model.predict(X_test)\n108:     df.loc[test_idx, \"PredictedScore\"] = y_pred\n109:     df.loc[test_idx, \"PredictedRank\"] = (\n110:         df.loc[test_idx]\n111:         .groupby(\"Year\")[\"PredictedScore\"]\n112:         .rank(ascending=False, method=\"first\")\n113:     )\n114: \n115:     ndcg = evaluate_ndcg(y_test.to_numpy(), y_pred, test_groups)\n116:     print(f\"NDCG Score on test years {test_years.tolist()}: {ndcg:.4f}\")\n117: \n118:     # Show results\n119:     print(df[test_idx][[\"Year\", \"Name\", \"Rank\", \"PredictedScore\", \"PredictedRank\"]])\n120:     plot_ranking_predictions(df, 2024)\n121:     plot_ranking_predictions(df, 2025)"
        },
        "source": "backend",
        "timestamp": "2025-08-23 10:41:44.000",
        "event": "map_summary_code",
        "id": "28eiJM9sPFd6ddHJYf9b"
    },
    {
        "data": {
            "mapping": [
                {
                    "summaryComponent": "This function trains",
                    "codeSegments": [
                        {
                            "line": 74,
                            "code": "def main():"
                        },
                        {
                            "line": 104,
                            "code": "model.fit(X_train, y_train, group=train_groups)"
                        }
                    ]
                },
                {
                    "summaryComponent": "and evaluates",
                    "codeSegments": [
                        {
                            "line": 115,
                            "code": "ndcg = evaluate_ndcg(y_test.to_numpy(), y_pred, test_groups)"
                        }
                    ]
                },
                {
                    "summaryComponent": "an XGBoost ranking model",
                    "codeSegments": [
                        {
                            "line": 95,
                            "code": "model = XGBRanker("
                        }
                    ]
                },
                {
                    "summaryComponent": "to predict MVP rankings",
                    "codeSegments": [
                        {
                            "line": 108,
                            "code": "df.loc[test_idx, \"PredictedScore\"] = y_pred"
                        },
                        {
                            "line": 109,
                            "code": "df.loc[test_idx, \"PredictedRank\"] = ("
                        }
                    ]
                },
                {
                    "summaryComponent": "for recent years.",
                    "codeSegments": [
                        {
                            "line": 81,
                            "code": "test_years = unique_years[-2:]"
                        },
                        {
                            "line": 85,
                            "code": "test_idx = df[\"Year\"].isin(test_years)"
                        }
                    ]
                }
            ],
            "summary": "This function trains and evaluates an XGBoost ranking model to predict MVP rankings for recent years.",
            "code": "74: def main():\n75:     X, y, group, df = load_data()\n76: \n77:     # Train-test split on years\n78:     unique_years = df[\"Year\"].unique()\n79:     train_years, test_years = (\n80:         unique_years[:-2],  # train: 2015-2023\n81:         unique_years[-2:],  # test: 2024-2025\n82:     )\n83: \n84:     train_idx = df[\"Year\"].isin(train_years)\n85:     test_idx = df[\"Year\"].isin(test_years)\n86: \n87:     X_train, X_test = X[train_idx], X[test_idx]\n88:     y_train, y_test = y[train_idx], y[test_idx]\n89: \n90:     # Group sizes\n91:     train_groups = df[train_idx].groupby(\"Year\").size().to_numpy()\n92:     test_groups = df[test_idx].groupby(\"Year\").size().to_numpy()\n93: \n94:     # Model\n95:     model = XGBRanker(\n96:         objective=\"rank:pairwise\",\n97:         learning_rate=0.1,\n98:         n_estimators=100,\n99:         max_depth=4,\n100:         random_state=42,\n101:     )\n102: \n103:     print(\"Training XGBoostRanker...\")\n104:     model.fit(X_train, y_train, group=train_groups)\n105: \n106:     # Predict, sort, and evaluate\n107:     y_pred = model.predict(X_test)\n108:     df.loc[test_idx, \"PredictedScore\"] = y_pred\n109:     df.loc[test_idx, \"PredictedRank\"] = (\n110:         df.loc[test_idx]\n111:         .groupby(\"Year\")[\"PredictedScore\"]\n112:         .rank(ascending=False, method=\"first\")\n113:     )\n114: \n115:     ndcg = evaluate_ndcg(y_test.to_numpy(), y_pred, test_groups)\n116:     print(f\"NDCG Score on test years {test_years.tolist()}: {ndcg:.4f}\")\n117: \n118:     # Show results\n119:     print(df[test_idx][[\"Year\", \"Name\", \"Rank\", \"PredictedScore\", \"PredictedRank\"]])\n120:     plot_ranking_predictions(df, 2024)\n121:     plot_ranking_predictions(df, 2025)"
        },
        "source": "backend",
        "timestamp": "2025-08-23 10:41:45.000",
        "event": "map_summary_code",
        "id": "3OeJmE2GkieScHq2prz1"
    },
    {
        "data": {
            "mapping": [
                {
                    "summaryComponent": "Loads data and separates it into features, labels, groups, and the full DataFrame",
                    "codeSegments": [
                        {
                            "line": 75,
                            "code": "X, y, group, df = load_data()"
                        }
                    ]
                },
                {
                    "summaryComponent": "Splits data into training (all but last two years) and testing (last two years) sets",
                    "codeSegments": [
                        {
                            "line": 78,
                            "code": "unique_years = df[\"Year\"].unique()"
                        },
                        {
                            "line": 79,
                            "code": "train_years, test_years = ("
                        },
                        {
                            "line": 80,
                            "code": "unique_years[:-2],  # train: 2015-2023"
                        },
                        {
                            "line": 81,
                            "code": "unique_years[-2:],  # test: 2024-2025"
                        },
                        {
                            "line": 84,
                            "code": "train_idx = df[\"Year\"].isin(train_years)"
                        },
                        {
                            "line": 85,
                            "code": "test_idx = df[\"Year\"].isin(test_years)"
                        },
                        {
                            "line": 87,
                            "code": "X_train, X_test = X[train_idx], X[test_idx]"
                        },
                        {
                            "line": 88,
                            "code": "y_train, y_test = y[train_idx], y[test_idx]"
                        }
                    ]
                },
                {
                    "summaryComponent": "Trains an XGBoostRanker model on the training data",
                    "codeSegments": [
                        {
                            "line": 95,
                            "code": "model = XGBRanker("
                        },
                        {
                            "line": 104,
                            "code": "model.fit(X_train, y_train, group=train_groups)"
                        }
                    ]
                },
                {
                    "summaryComponent": "Predicts and ranks MVPs for the test years",
                    "codeSegments": [
                        {
                            "line": 107,
                            "code": "y_pred = model.predict(X_test)"
                        },
                        {
                            "line": 108,
                            "code": "df.loc[test_idx, \"PredictedScore\"] = y_pred"
                        },
                        {
                            "line": 109,
                            "code": "df.loc[test_idx, \"PredictedRank\"] = ("
                        },
                        {
                            "line": 110,
                            "code": "df.loc[test_idx]"
                        },
                        {
                            "line": 111,
                            "code": ".groupby(\"Year\")[\"PredictedScore\"]"
                        },
                        {
                            "line": 112,
                            "code": ".rank(ascending=False, method=\"first\")"
                        }
                    ]
                },
                {
                    "summaryComponent": "Evaluates performance using NDCG",
                    "codeSegments": [
                        {
                            "line": 115,
                            "code": "ndcg = evaluate_ndcg(y_test.to_numpy(), y_pred, test_groups)"
                        }
                    ]
                },
                {
                    "summaryComponent": "Prints and visualizes results for the test years",
                    "codeSegments": [
                        {
                            "line": 119,
                            "code": "print(df[test_idx][[\"Year\", \"Name\", \"Rank\", \"PredictedScore\", \"PredictedRank\"]])"
                        },
                        {
                            "line": 120,
                            "code": "plot_ranking_predictions(df, 2024)"
                        },
                        {
                            "line": 121,
                            "code": "plot_ranking_predictions(df, 2025)"
                        }
                    ]
                }
            ],
            "summary": "• Loads data and separates it into features, labels, groups, and the full DataFrame\n• Splits data into training (all but last two years) and testing (last two years) sets\n• Trains an XGBoostRanker model on the training data\n• Predicts and ranks MVPs for the test years\n  ◦ Evaluates performance using NDCG\n  ◦ Prints and visualizes results for the test years",
            "code": "74: def main():\n75:     X, y, group, df = load_data()\n76: \n77:     # Train-test split on years\n78:     unique_years = df[\"Year\"].unique()\n79:     train_years, test_years = (\n80:         unique_years[:-2],  # train: 2015-2023\n81:         unique_years[-2:],  # test: 2024-2025\n82:     )\n83: \n84:     train_idx = df[\"Year\"].isin(train_years)\n85:     test_idx = df[\"Year\"].isin(test_years)\n86: \n87:     X_train, X_test = X[train_idx], X[test_idx]\n88:     y_train, y_test = y[train_idx], y[test_idx]\n89: \n90:     # Group sizes\n91:     train_groups = df[train_idx].groupby(\"Year\").size().to_numpy()\n92:     test_groups = df[test_idx].groupby(\"Year\").size().to_numpy()\n93: \n94:     # Model\n95:     model = XGBRanker(\n96:         objective=\"rank:pairwise\",\n97:         learning_rate=0.1,\n98:         n_estimators=100,\n99:         max_depth=4,\n100:         random_state=42,\n101:     )\n102: \n103:     print(\"Training XGBoostRanker...\")\n104:     model.fit(X_train, y_train, group=train_groups)\n105: \n106:     # Predict, sort, and evaluate\n107:     y_pred = model.predict(X_test)\n108:     df.loc[test_idx, \"PredictedScore\"] = y_pred\n109:     df.loc[test_idx, \"PredictedRank\"] = (\n110:         df.loc[test_idx]\n111:         .groupby(\"Year\")[\"PredictedScore\"]\n112:         .rank(ascending=False, method=\"first\")\n113:     )\n114: \n115:     ndcg = evaluate_ndcg(y_test.to_numpy(), y_pred, test_groups)\n116:     print(f\"NDCG Score on test years {test_years.tolist()}: {ndcg:.4f}\")\n117: \n118:     # Show results\n119:     print(df[test_idx][[\"Year\", \"Name\", \"Rank\", \"PredictedScore\", \"PredictedRank\"]])\n120:     plot_ranking_predictions(df, 2024)\n121:     plot_ranking_predictions(df, 2025)"
        },
        "source": "backend",
        "timestamp": "2025-08-23 10:41:47.000",
        "event": "map_summary_code",
        "id": "PTnq32vGUHbfxL3QEXPa"
    },
    {
        "data": {
            "mapping": [
                {
                    "summaryComponent": "Loads data and extracts features (X), labels (y), group sizes, and the full DataFrame",
                    "codeSegments": [
                        {
                            "line": 75,
                            "code": "X, y, group, df = load_data()"
                        }
                    ]
                },
                {
                    "summaryComponent": "Splits data by year:",
                    "codeSegments": [
                        {
                            "line": 78,
                            "code": "unique_years = df[\"Year\"].unique()"
                        },
                        {
                            "line": 79,
                            "code": "train_years, test_years = ("
                        },
                        {
                            "line": 80,
                            "code": "    unique_years[:-2],  # train: 2015-2023"
                        },
                        {
                            "line": 81,
                            "code": "    unique_years[-2:],  # test: 2024-2025"
                        }
                    ]
                },
                {
                    "summaryComponent": "Training: all years except the last two",
                    "codeSegments": [
                        {
                            "line": 79,
                            "code": "train_years, test_years = ("
                        },
                        {
                            "line": 80,
                            "code": "    unique_years[:-2],  # train: 2015-2023"
                        }
                    ]
                },
                {
                    "summaryComponent": "Testing: the last two years",
                    "codeSegments": [
                        {
                            "line": 79,
                            "code": "train_years, test_years = ("
                        },
                        {
                            "line": 81,
                            "code": "    unique_years[-2:],  # test: 2024-2025"
                        }
                    ]
                },
                {
                    "summaryComponent": "Creates boolean indices to separate training and test data",
                    "codeSegments": [
                        {
                            "line": 84,
                            "code": "train_idx = df[\"Year\"].isin(train_years)"
                        },
                        {
                            "line": 85,
                            "code": "test_idx = df[\"Year\"].isin(test_years)"
                        }
                    ]
                },
                {
                    "summaryComponent": "Prepares group sizes for both training and testing sets",
                    "codeSegments": [
                        {
                            "line": 91,
                            "code": "train_groups = df[train_idx].groupby(\"Year\").size().to_numpy()"
                        },
                        {
                            "line": 92,
                            "code": "test_groups = df[test_idx].groupby(\"Year\").size().to_numpy()"
                        }
                    ]
                },
                {
                    "summaryComponent": "Initializes and trains an XGBoostRanker model with specified hyperparameters",
                    "codeSegments": [
                        {
                            "line": 95,
                            "code": "model = XGBRanker("
                        },
                        {
                            "line": 96,
                            "code": "    objective=\"rank:pairwise\","
                        },
                        {
                            "line": 97,
                            "code": "    learning_rate=0.1,"
                        },
                        {
                            "line": 98,
                            "code": "    n_estimators=100,"
                        },
                        {
                            "line": 99,
                            "code": "    max_depth=4,"
                        },
                        {
                            "line": 100,
                            "code": "    random_state=42,"
                        },
                        {
                            "line": 101,
                            "code": ")"
                        },
                        {
                            "line": 104,
                            "code": "model.fit(X_train, y_train, group=train_groups)"
                        }
                    ]
                },
                {
                    "summaryComponent": "Uses group information to handle ranking within each year",
                    "codeSegments": [
                        {
                            "line": 104,
                            "code": "model.fit(X_train, y_train, group=train_groups)"
                        }
                    ]
                },
                {
                    "summaryComponent": "Predicts scores for the test set and assigns predicted ranks within each year",
                    "codeSegments": [
                        {
                            "line": 107,
                            "code": "y_pred = model.predict(X_test)"
                        },
                        {
                            "line": 108,
                            "code": "df.loc[test_idx, \"PredictedScore\"] = y_pred"
                        },
                        {
                            "line": 109,
                            "code": "df.loc[test_idx, \"PredictedRank\"] = ("
                        },
                        {
                            "line": 110,
                            "code": "    df.loc[test_idx]"
                        },
                        {
                            "line": 111,
                            "code": "    .groupby(\"Year\")[\"PredictedScore\"]"
                        },
                        {
                            "line": 112,
                            "code": "    .rank(ascending=False, method=\"first\")"
                        }
                    ]
                },
                {
                    "summaryComponent": "Stores predicted scores and ranks in the DataFrame",
                    "codeSegments": [
                        {
                            "line": 108,
                            "code": "df.loc[test_idx, \"PredictedScore\"] = y_pred"
                        },
                        {
                            "line": 109,
                            "code": "df.loc[test_idx, \"PredictedRank\"] = ("
                        }
                    ]
                },
                {
                    "summaryComponent": "Evaluates model performance using the NDCG metric and prints the result",
                    "codeSegments": [
                        {
                            "line": 115,
                            "code": "ndcg = evaluate_ndcg(y_test.to_numpy(), y_pred, test_groups)"
                        },
                        {
                            "line": 116,
                            "code": "print(f\"NDCG Score on test years {test_years.tolist()}: {ndcg:.4f}\")"
                        }
                    ]
                },
                {
                    "summaryComponent": "Displays detailed prediction results for the test years",
                    "codeSegments": [
                        {
                            "line": 119,
                            "code": "print(df[test_idx][[\"Year\", \"Name\", \"Rank\", \"PredictedScore\", \"PredictedRank\"]])"
                        }
                    ]
                },
                {
                    "summaryComponent": "Generates and saves bar plots of prediction errors for each test year",
                    "codeSegments": [
                        {
                            "line": 120,
                            "code": "plot_ranking_predictions(df, 2024)"
                        },
                        {
                            "line": 121,
                            "code": "plot_ranking_predictions(df, 2025)"
                        }
                    ]
                }
            ],
            "summary": "• Loads data and extracts features (X), labels (y), group sizes, and the full DataFrame\n• Splits data by year:\n  ◦ Training: all years except the last two\n  ◦ Testing: the last two years\n• Creates boolean indices to separate training and test data\n• Prepares group sizes for both training and testing sets\n• Initializes and trains an XGBoostRanker model with specified hyperparameters\n  ◦ Uses group information to handle ranking within each year\n• Predicts scores for the test set and assigns predicted ranks within each year\n  ◦ Stores predicted scores and ranks in the DataFrame\n• Evaluates model performance using the NDCG metric and prints the result\n• Displays detailed prediction results for the test years\n• Generates and saves bar plots of prediction errors for each test year",
            "code": "74: def main():\n75:     X, y, group, df = load_data()\n76: \n77:     # Train-test split on years\n78:     unique_years = df[\"Year\"].unique()\n79:     train_years, test_years = (\n80:         unique_years[:-2],  # train: 2015-2023\n81:         unique_years[-2:],  # test: 2024-2025\n82:     )\n83: \n84:     train_idx = df[\"Year\"].isin(train_years)\n85:     test_idx = df[\"Year\"].isin(test_years)\n86: \n87:     X_train, X_test = X[train_idx], X[test_idx]\n88:     y_train, y_test = y[train_idx], y[test_idx]\n89: \n90:     # Group sizes\n91:     train_groups = df[train_idx].groupby(\"Year\").size().to_numpy()\n92:     test_groups = df[test_idx].groupby(\"Year\").size().to_numpy()\n93: \n94:     # Model\n95:     model = XGBRanker(\n96:         objective=\"rank:pairwise\",\n97:         learning_rate=0.1,\n98:         n_estimators=100,\n99:         max_depth=4,\n100:         random_state=42,\n101:     )\n102: \n103:     print(\"Training XGBoostRanker...\")\n104:     model.fit(X_train, y_train, group=train_groups)\n105: \n106:     # Predict, sort, and evaluate\n107:     y_pred = model.predict(X_test)\n108:     df.loc[test_idx, \"PredictedScore\"] = y_pred\n109:     df.loc[test_idx, \"PredictedRank\"] = (\n110:         df.loc[test_idx]\n111:         .groupby(\"Year\")[\"PredictedScore\"]\n112:         .rank(ascending=False, method=\"first\")\n113:     )\n114: \n115:     ndcg = evaluate_ndcg(y_test.to_numpy(), y_pred, test_groups)\n116:     print(f\"NDCG Score on test years {test_years.tolist()}: {ndcg:.4f}\")\n117: \n118:     # Show results\n119:     print(df[test_idx][[\"Year\", \"Name\", \"Rank\", \"PredictedScore\", \"PredictedRank\"]])\n120:     plot_ranking_predictions(df, 2024)\n121:     plot_ranking_predictions(df, 2025)"
        },
        "source": "backend",
        "timestamp": "2025-08-23 10:41:47.000",
        "event": "map_summary_code",
        "id": "qDLYDLRbE2CKT5g9E0OI"
    },
    {
        "data": {
            "mapping_index": 2,
            "structured_type": "structured",
            "section_id": "b8ebaadc-fc99-48e5-882d-fad26e99fc33",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:41:48.000",
        "event": "mapping_hover",
        "id": "9pxFmYlmDIAHt0En5RZG"
    },
    {
        "data": {
            "structured_type": "structured",
            "section_id": "b8ebaadc-fc99-48e5-882d-fad26e99fc33",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:41:48.000",
        "event": "mapping_unhover",
        "id": "AYmCtH3Vl0H2pT3M7zlm"
    },
    {
        "data": {
            "structured_type": "structured",
            "section_id": "b8ebaadc-fc99-48e5-882d-fad26e99fc33",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:41:48.000",
        "event": "mapping_unhover",
        "id": "B432aONv8HCIi01XkgNa"
    },
    {
        "data": {
            "mapping_index": 1,
            "structured_type": "structured",
            "section_id": "b8ebaadc-fc99-48e5-882d-fad26e99fc33",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:41:48.000",
        "event": "mapping_hover",
        "id": "OtGIAr56j8rOKXoliRJo"
    },
    {
        "data": {
            "mapping_index": 3,
            "structured_type": "structured",
            "section_id": "b8ebaadc-fc99-48e5-882d-fad26e99fc33",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:41:48.000",
        "event": "mapping_hover",
        "id": "yC7vMNov0q67BNDzjPXK"
    },
    {
        "data": {
            "structured_type": "structured",
            "section_id": "b8ebaadc-fc99-48e5-882d-fad26e99fc33",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:41:49.000",
        "event": "mapping_unhover",
        "id": "ACsCjArlg0H8w562JD4c"
    },
    {
        "data": {
            "mapping": [
                {
                    "summaryComponent": "The main() function loads data",
                    "codeSegments": [
                        {
                            "line": 74,
                            "code": "def main():"
                        },
                        {
                            "line": 75,
                            "code": "X, y, group, df = load_data()"
                        }
                    ]
                },
                {
                    "summaryComponent": "splits it into training and test sets based on years",
                    "codeSegments": [
                        {
                            "line": 78,
                            "code": "unique_years = df[\"Year\"].unique()"
                        },
                        {
                            "line": 79,
                            "code": "train_years, test_years = ("
                        },
                        {
                            "line": 84,
                            "code": "train_idx = df[\"Year\"].isin(train_years)"
                        },
                        {
                            "line": 85,
                            "code": "test_idx = df[\"Year\"].isin(test_years)"
                        },
                        {
                            "line": 87,
                            "code": "X_train, X_test = X[train_idx], X[test_idx]"
                        },
                        {
                            "line": 88,
                            "code": "y_train, y_test = y[train_idx], y[test_idx]"
                        }
                    ]
                },
                {
                    "summaryComponent": "trains an XGBoost ranking model",
                    "codeSegments": [
                        {
                            "line": 95,
                            "code": "model = XGBRanker("
                        },
                        {
                            "line": 104,
                            "code": "model.fit(X_train, y_train, group=train_groups)"
                        }
                    ]
                },
                {
                    "summaryComponent": "It predicts MVP rankings for the test years",
                    "codeSegments": [
                        {
                            "line": 107,
                            "code": "y_pred = model.predict(X_test)"
                        },
                        {
                            "line": 108,
                            "code": "df.loc[test_idx, \"PredictedScore\"] = y_pred"
                        },
                        {
                            "line": 109,
                            "code": "df.loc[test_idx, \"PredictedRank\"] = ("
                        }
                    ]
                },
                {
                    "summaryComponent": "evaluates the model's performance using the NDCG metric",
                    "codeSegments": [
                        {
                            "line": 115,
                            "code": "ndcg = evaluate_ndcg(y_test.to_numpy(), y_pred, test_groups)"
                        }
                    ]
                },
                {
                    "summaryComponent": "prints the results",
                    "codeSegments": [
                        {
                            "line": 116,
                            "code": "print(f\"NDCG Score on test years {test_years.tolist()}: {ndcg:.4f}\")"
                        },
                        {
                            "line": 119,
                            "code": "print(df[test_idx][[\"Year\", \"Name\", \"Rank\", \"PredictedScore\", \"PredictedRank\"]])"
                        }
                    ]
                },
                {
                    "summaryComponent": "generates plots to visualize prediction errors for the test years",
                    "codeSegments": [
                        {
                            "line": 120,
                            "code": "plot_ranking_predictions(df, 2024)"
                        },
                        {
                            "line": 121,
                            "code": "plot_ranking_predictions(df, 2025)"
                        }
                    ]
                }
            ],
            "summary": "The main() function loads data, splits it into training and test sets based on years, and trains an XGBoost ranking model. It predicts MVP rankings for the test years, evaluates the model's performance using the NDCG metric, and prints the results. Finally, it generates plots to visualize prediction errors for the test years.",
            "code": "74: def main():\n75:     X, y, group, df = load_data()\n76: \n77:     # Train-test split on years\n78:     unique_years = df[\"Year\"].unique()\n79:     train_years, test_years = (\n80:         unique_years[:-2],  # train: 2015-2023\n81:         unique_years[-2:],  # test: 2024-2025\n82:     )\n83: \n84:     train_idx = df[\"Year\"].isin(train_years)\n85:     test_idx = df[\"Year\"].isin(test_years)\n86: \n87:     X_train, X_test = X[train_idx], X[test_idx]\n88:     y_train, y_test = y[train_idx], y[test_idx]\n89: \n90:     # Group sizes\n91:     train_groups = df[train_idx].groupby(\"Year\").size().to_numpy()\n92:     test_groups = df[test_idx].groupby(\"Year\").size().to_numpy()\n93: \n94:     # Model\n95:     model = XGBRanker(\n96:         objective=\"rank:pairwise\",\n97:         learning_rate=0.1,\n98:         n_estimators=100,\n99:         max_depth=4,\n100:         random_state=42,\n101:     )\n102: \n103:     print(\"Training XGBoostRanker...\")\n104:     model.fit(X_train, y_train, group=train_groups)\n105: \n106:     # Predict, sort, and evaluate\n107:     y_pred = model.predict(X_test)\n108:     df.loc[test_idx, \"PredictedScore\"] = y_pred\n109:     df.loc[test_idx, \"PredictedRank\"] = (\n110:         df.loc[test_idx]\n111:         .groupby(\"Year\")[\"PredictedScore\"]\n112:         .rank(ascending=False, method=\"first\")\n113:     )\n114: \n115:     ndcg = evaluate_ndcg(y_test.to_numpy(), y_pred, test_groups)\n116:     print(f\"NDCG Score on test years {test_years.tolist()}: {ndcg:.4f}\")\n117: \n118:     # Show results\n119:     print(df[test_idx][[\"Year\", \"Name\", \"Rank\", \"PredictedScore\", \"PredictedRank\"]])\n120:     plot_ranking_predictions(df, 2024)\n121:     plot_ranking_predictions(df, 2025)"
        },
        "source": "backend",
        "timestamp": "2025-08-23 10:41:49.000",
        "event": "map_summary_code",
        "id": "Fm4YTCtnGRUK8NX8SHq7"
    },
    {
        "data": {
            "mapping_index": 2,
            "structured_type": "structured",
            "section_id": "b8ebaadc-fc99-48e5-882d-fad26e99fc33",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:41:49.000",
        "event": "mapping_hover",
        "id": "YW3mQy9JLvshcpdOTuT0"
    },
    {
        "data": {
            "structured_type": "structured",
            "section_id": "b8ebaadc-fc99-48e5-882d-fad26e99fc33",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:41:49.000",
        "event": "mapping_unhover",
        "id": "qMnHJ8jNnhvGuunSfCIt"
    },
    {
        "data": {
            "mapping": [
                {
                    "summaryComponent": "The main() function orchestrates the process of training and evaluating an XGBoostRanker for MVP prediction.",
                    "codeSegments": [
                        {
                            "line": 74,
                            "code": "def main():"
                        },
                        {
                            "line": 95,
                            "code": "model = XGBRanker("
                        }
                    ]
                },
                {
                    "summaryComponent": "It first loads the dataset",
                    "codeSegments": [
                        {
                            "line": 75,
                            "code": "X, y, group, df = load_data()"
                        }
                    ]
                },
                {
                    "summaryComponent": "and splits it into training and testing sets based on years",
                    "codeSegments": [
                        {
                            "line": 78,
                            "code": "unique_years = df[\"Year\"].unique()"
                        },
                        {
                            "line": 79,
                            "code": "train_years, test_years = ("
                        },
                        {
                            "line": 84,
                            "code": "train_idx = df[\"Year\"].isin(train_years)"
                        },
                        {
                            "line": 85,
                            "code": "test_idx = df[\"Year\"].isin(test_years)"
                        }
                    ]
                },
                {
                    "summaryComponent": "ensuring that the most recent two years are reserved for testing.",
                    "codeSegments": [
                        {
                            "line": 79,
                            "code": "train_years, test_years = ("
                        },
                        {
                            "line": 81,
                            "code": "unique_years[-2:],  # test: 2024-2025"
                        }
                    ]
                },
                {
                    "summaryComponent": "The model is trained on the training set using group information to respect the ranking structure within each year.",
                    "codeSegments": [
                        {
                            "line": 91,
                            "code": "train_groups = df[train_idx].groupby(\"Year\").size().to_numpy()"
                        },
                        {
                            "line": 104,
                            "code": "model.fit(X_train, y_train, group=train_groups)"
                        }
                    ]
                },
                {
                    "summaryComponent": "After making predictions for the test years",
                    "codeSegments": [
                        {
                            "line": 107,
                            "code": "y_pred = model.predict(X_test)"
                        }
                    ]
                },
                {
                    "summaryComponent": "it assigns predicted ranks",
                    "codeSegments": [
                        {
                            "line": 109,
                            "code": "df.loc[test_idx, \"PredictedRank\"] = ("
                        }
                    ]
                },
                {
                    "summaryComponent": "evaluates the model's performance using the NDCG metric",
                    "codeSegments": [
                        {
                            "line": 115,
                            "code": "ndcg = evaluate_ndcg(y_test.to_numpy(), y_pred, test_groups)"
                        }
                    ]
                },
                {
                    "summaryComponent": "prints detailed results",
                    "codeSegments": [
                        {
                            "line": 119,
                            "code": "print(df[test_idx][[\"Year\", \"Name\", \"Rank\", \"PredictedScore\", \"PredictedRank\"]])"
                        }
                    ]
                },
                {
                    "summaryComponent": "and generates bar plots visualizing prediction errors for each test year.",
                    "codeSegments": [
                        {
                            "line": 120,
                            "code": "plot_ranking_predictions(df, 2024)"
                        },
                        {
                            "line": 121,
                            "code": "plot_ranking_predictions(df, 2025)"
                        }
                    ]
                }
            ],
            "summary": "The main() function orchestrates the process of training and evaluating an XGBoostRanker for MVP prediction. It first loads the dataset and splits it into training and testing sets based on years, ensuring that the most recent two years are reserved for testing. The model is trained on the training set using group information to respect the ranking structure within each year. After making predictions for the test years, it assigns predicted ranks, evaluates the model's performance using the NDCG metric, prints detailed results, and generates bar plots visualizing prediction errors for each test year.",
            "code": "74: def main():\n75:     X, y, group, df = load_data()\n76: \n77:     # Train-test split on years\n78:     unique_years = df[\"Year\"].unique()\n79:     train_years, test_years = (\n80:         unique_years[:-2],  # train: 2015-2023\n81:         unique_years[-2:],  # test: 2024-2025\n82:     )\n83: \n84:     train_idx = df[\"Year\"].isin(train_years)\n85:     test_idx = df[\"Year\"].isin(test_years)\n86: \n87:     X_train, X_test = X[train_idx], X[test_idx]\n88:     y_train, y_test = y[train_idx], y[test_idx]\n89: \n90:     # Group sizes\n91:     train_groups = df[train_idx].groupby(\"Year\").size().to_numpy()\n92:     test_groups = df[test_idx].groupby(\"Year\").size().to_numpy()\n93: \n94:     # Model\n95:     model = XGBRanker(\n96:         objective=\"rank:pairwise\",\n97:         learning_rate=0.1,\n98:         n_estimators=100,\n99:         max_depth=4,\n100:         random_state=42,\n101:     )\n102: \n103:     print(\"Training XGBoostRanker...\")\n104:     model.fit(X_train, y_train, group=train_groups)\n105: \n106:     # Predict, sort, and evaluate\n107:     y_pred = model.predict(X_test)\n108:     df.loc[test_idx, \"PredictedScore\"] = y_pred\n109:     df.loc[test_idx, \"PredictedRank\"] = (\n110:         df.loc[test_idx]\n111:         .groupby(\"Year\")[\"PredictedScore\"]\n112:         .rank(ascending=False, method=\"first\")\n113:     )\n114: \n115:     ndcg = evaluate_ndcg(y_test.to_numpy(), y_pred, test_groups)\n116:     print(f\"NDCG Score on test years {test_years.tolist()}: {ndcg:.4f}\")\n117: \n118:     # Show results\n119:     print(df[test_idx][[\"Year\", \"Name\", \"Rank\", \"PredictedScore\", \"PredictedRank\"]])\n120:     plot_ranking_predictions(df, 2024)\n121:     plot_ranking_predictions(df, 2025)"
        },
        "source": "backend",
        "timestamp": "2025-08-23 10:41:51.000",
        "event": "map_summary_code",
        "id": "6w54ldYR8tPbCNdet2rJ"
    },
    {
        "data": {
            "section_data": {
                "lines": [
                    74,
                    121
                ],
                "summaryData": {
                    "medium_unstructured": "The main() function loads data, splits it into training and test sets based on years, and trains an XGBoost ranking model. It predicts MVP rankings for the test years, evaluates the model's performance using the NDCG metric, and prints the results. Finally, it generates plots to visualize prediction errors for the test years.",
                    "low_structured": "• Loads data and splits it into training and testing sets by year\n• Trains an XGBoost ranking model\n• Predicts and evaluates MVP rankings for test years",
                    "title": "Summary of the main() Function for MVP Ranking with XGBoostRanker",
                    "medium_structured": "• Loads data and separates it into features, labels, groups, and the full DataFrame\n• Splits data into training (all but last two years) and testing (last two years) sets\n• Trains an XGBoostRanker model on the training data\n• Predicts and ranks MVPs for the test years\n  ◦ Evaluates performance using NDCG\n  ◦ Prints and visualizes results for the test years",
                    "high_unstructured": "The main() function orchestrates the process of training and evaluating an XGBoostRanker for MVP prediction. It first loads the dataset and splits it into training and testing sets based on years, ensuring that the most recent two years are reserved for testing. The model is trained on the training set using group information to respect the ranking structure within each year. After making predictions for the test years, it assigns predicted ranks, evaluates the model's performance using the NDCG metric, prints detailed results, and generates bar plots visualizing prediction errors for each test year.",
                    "high_structured": "• Loads data and extracts features (X), labels (y), group sizes, and the full DataFrame\n• Splits data by year:\n  ◦ Training: all years except the last two\n  ◦ Testing: the last two years\n• Creates boolean indices to separate training and test data\n• Prepares group sizes for both training and testing sets\n• Initializes and trains an XGBoostRanker model with specified hyperparameters\n  ◦ Uses group information to handle ranking within each year\n• Predicts scores for the test set and assigns predicted ranks within each year\n  ◦ Stores predicted scores and ranks in the DataFrame\n• Evaluates model performance using the NDCG metric and prints the result\n• Displays detailed prediction results for the test years\n• Generates and saves bar plots of prediction errors for each test year",
                    "low_unstructured": "This function trains and evaluates an XGBoost ranking model to predict MVP rankings for recent years."
                },
                "editPromptStructured": null,
                "createdAt": 1755974511000,
                "metadata": {
                    "filename": "rank_model.py",
                    "id": "98364d69-7071-47ca-9328-9f9a586aed75",
                    "originalCode": "def main():\n    X, y, group, df = load_data()\n\n    # Train-test split on years\n    unique_years = df[\"Year\"].unique()\n    train_years, test_years = (\n        unique_years[:-2],  # train: 2015-2023\n        unique_years[-2:],  # test: 2024-2025\n    )\n\n    train_idx = df[\"Year\"].isin(train_years)\n    test_idx = df[\"Year\"].isin(test_years)\n\n    X_train, X_test = X[train_idx], X[test_idx]\n    y_train, y_test = y[train_idx], y[test_idx]\n\n    # Group sizes\n    train_groups = df[train_idx].groupby(\"Year\").size().to_numpy()\n    test_groups = df[test_idx].groupby(\"Year\").size().to_numpy()\n\n    # Model\n    model = XGBRanker(\n        objective=\"rank:pairwise\",\n        learning_rate=0.1,\n        n_estimators=100,\n        max_depth=4,\n        random_state=42,\n    )\n\n    print(\"Training XGBoostRanker...\")\n    model.fit(X_train, y_train, group=train_groups)\n\n    # Predict, sort, and evaluate\n    y_pred = model.predict(X_test)\n    df.loc[test_idx, \"PredictedScore\"] = y_pred\n    df.loc[test_idx, \"PredictedRank\"] = (\n        df.loc[test_idx]\n        .groupby(\"Year\")[\"PredictedScore\"]\n        .rank(ascending=False, method=\"first\")\n    )\n\n    ndcg = evaluate_ndcg(y_test.to_numpy(), y_pred, test_groups)\n    print(f\"NDCG Score on test years {test_years.tolist()}: {ndcg:.4f}\")\n\n    # Show results\n    print(df[test_idx][[\"Year\", \"Name\", \"Rank\", \"PredictedScore\", \"PredictedRank\"]])\n    plot_ranking_predictions(df, 2024)\n    plot_ranking_predictions(df, 2025)",
                    "fullPath": "/project/workspace/rank_model.py",
                    "offset": 1952
                },
                "selectedStructured": "unstructured",
                "title": "Summary of the main() Function for MVP Ranking with XGBoostRanker",
                "selectedDetailLevel": "medium",
                "summaryMappings": {
                    "medium_unstructured": [
                        {
                            "summaryComponent": "The main() function loads data",
                            "codeSegments": [
                                {
                                    "line": 74,
                                    "code": "def main():"
                                },
                                {
                                    "line": 75,
                                    "code": "X, y, group, df = load_data()"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "splits it into training and test sets based on years",
                            "codeSegments": [
                                {
                                    "line": 78,
                                    "code": "unique_years = df[\"Year\"].unique()"
                                },
                                {
                                    "line": 79,
                                    "code": "train_years, test_years = ("
                                },
                                {
                                    "line": 84,
                                    "code": "train_idx = df[\"Year\"].isin(train_years)"
                                },
                                {
                                    "line": 85,
                                    "code": "test_idx = df[\"Year\"].isin(test_years)"
                                },
                                {
                                    "line": 87,
                                    "code": "X_train, X_test = X[train_idx], X[test_idx]"
                                },
                                {
                                    "line": 88,
                                    "code": "y_train, y_test = y[train_idx], y[test_idx]"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "trains an XGBoost ranking model",
                            "codeSegments": [
                                {
                                    "line": 95,
                                    "code": "model = XGBRanker("
                                },
                                {
                                    "line": 104,
                                    "code": "model.fit(X_train, y_train, group=train_groups)"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "It predicts MVP rankings for the test years",
                            "codeSegments": [
                                {
                                    "line": 107,
                                    "code": "y_pred = model.predict(X_test)"
                                },
                                {
                                    "line": 108,
                                    "code": "df.loc[test_idx, \"PredictedScore\"] = y_pred"
                                },
                                {
                                    "line": 109,
                                    "code": "df.loc[test_idx, \"PredictedRank\"] = ("
                                }
                            ]
                        },
                        {
                            "summaryComponent": "evaluates the model's performance using the NDCG metric",
                            "codeSegments": [
                                {
                                    "line": 115,
                                    "code": "ndcg = evaluate_ndcg(y_test.to_numpy(), y_pred, test_groups)"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "prints the results",
                            "codeSegments": [
                                {
                                    "line": 116,
                                    "code": "print(f\"NDCG Score on test years {test_years.tolist()}: {ndcg:.4f}\")"
                                },
                                {
                                    "line": 119,
                                    "code": "print(df[test_idx][[\"Year\", \"Name\", \"Rank\", \"PredictedScore\", \"PredictedRank\"]])"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "generates plots to visualize prediction errors for the test years",
                            "codeSegments": [
                                {
                                    "line": 120,
                                    "code": "plot_ranking_predictions(df, 2024)"
                                },
                                {
                                    "line": 121,
                                    "code": "plot_ranking_predictions(df, 2025)"
                                }
                            ]
                        }
                    ],
                    "low_structured": [
                        {
                            "summaryComponent": "Loads data and splits it into training and testing sets by year",
                            "codeSegments": [
                                {
                                    "line": 75,
                                    "code": "X, y, group, df = load_data()"
                                },
                                {
                                    "line": 78,
                                    "code": "unique_years = df[\"Year\"].unique()"
                                },
                                {
                                    "line": 79,
                                    "code": "train_years, test_years = ("
                                },
                                {
                                    "line": 84,
                                    "code": "train_idx = df[\"Year\"].isin(train_years)"
                                },
                                {
                                    "line": 85,
                                    "code": "test_idx = df[\"Year\"].isin(test_years)"
                                },
                                {
                                    "line": 87,
                                    "code": "X_train, X_test = X[train_idx], X[test_idx]"
                                },
                                {
                                    "line": 88,
                                    "code": "y_train, y_test = y[train_idx], y[test_idx]"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "Trains an XGBoost ranking model",
                            "codeSegments": [
                                {
                                    "line": 95,
                                    "code": "model = XGBRanker("
                                },
                                {
                                    "line": 104,
                                    "code": "model.fit(X_train, y_train, group=train_groups)"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "Predicts and evaluates MVP rankings for test years",
                            "codeSegments": [
                                {
                                    "line": 107,
                                    "code": "y_pred = model.predict(X_test)"
                                },
                                {
                                    "line": 108,
                                    "code": "df.loc[test_idx, \"PredictedScore\"] = y_pred"
                                },
                                {
                                    "line": 109,
                                    "code": "df.loc[test_idx, \"PredictedRank\"] = ("
                                },
                                {
                                    "line": 115,
                                    "code": "ndcg = evaluate_ndcg(y_test.to_numpy(), y_pred, test_groups)"
                                },
                                {
                                    "line": 116,
                                    "code": "print(f\"NDCG Score on test years {test_years.tolist()}: {ndcg:.4f}\")"
                                },
                                {
                                    "line": 119,
                                    "code": "print(df[test_idx][[\"Year\", \"Name\", \"Rank\", \"PredictedScore\", \"PredictedRank\"]])"
                                },
                                {
                                    "line": 120,
                                    "code": "plot_ranking_predictions(df, 2024)"
                                },
                                {
                                    "line": 121,
                                    "code": "plot_ranking_predictions(df, 2025)"
                                }
                            ]
                        }
                    ],
                    "low_unstructured": [
                        {
                            "summaryComponent": "This function trains",
                            "codeSegments": [
                                {
                                    "line": 74,
                                    "code": "def main():"
                                },
                                {
                                    "line": 104,
                                    "code": "model.fit(X_train, y_train, group=train_groups)"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "and evaluates",
                            "codeSegments": [
                                {
                                    "line": 115,
                                    "code": "ndcg = evaluate_ndcg(y_test.to_numpy(), y_pred, test_groups)"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "an XGBoost ranking model",
                            "codeSegments": [
                                {
                                    "line": 95,
                                    "code": "model = XGBRanker("
                                }
                            ]
                        },
                        {
                            "summaryComponent": "to predict MVP rankings",
                            "codeSegments": [
                                {
                                    "line": 108,
                                    "code": "df.loc[test_idx, \"PredictedScore\"] = y_pred"
                                },
                                {
                                    "line": 109,
                                    "code": "df.loc[test_idx, \"PredictedRank\"] = ("
                                }
                            ]
                        },
                        {
                            "summaryComponent": "for recent years.",
                            "codeSegments": [
                                {
                                    "line": 81,
                                    "code": "test_years = unique_years[-2:]"
                                },
                                {
                                    "line": 85,
                                    "code": "test_idx = df[\"Year\"].isin(test_years)"
                                }
                            ]
                        }
                    ],
                    "medium_structured": [
                        {
                            "summaryComponent": "Loads data and separates it into features, labels, groups, and the full DataFrame",
                            "codeSegments": [
                                {
                                    "line": 75,
                                    "code": "X, y, group, df = load_data()"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "Splits data into training (all but last two years) and testing (last two years) sets",
                            "codeSegments": [
                                {
                                    "line": 78,
                                    "code": "unique_years = df[\"Year\"].unique()"
                                },
                                {
                                    "line": 79,
                                    "code": "train_years, test_years = ("
                                },
                                {
                                    "line": 80,
                                    "code": "unique_years[:-2],  # train: 2015-2023"
                                },
                                {
                                    "line": 81,
                                    "code": "unique_years[-2:],  # test: 2024-2025"
                                },
                                {
                                    "line": 84,
                                    "code": "train_idx = df[\"Year\"].isin(train_years)"
                                },
                                {
                                    "line": 85,
                                    "code": "test_idx = df[\"Year\"].isin(test_years)"
                                },
                                {
                                    "line": 87,
                                    "code": "X_train, X_test = X[train_idx], X[test_idx]"
                                },
                                {
                                    "line": 88,
                                    "code": "y_train, y_test = y[train_idx], y[test_idx]"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "Trains an XGBoostRanker model on the training data",
                            "codeSegments": [
                                {
                                    "line": 95,
                                    "code": "model = XGBRanker("
                                },
                                {
                                    "line": 104,
                                    "code": "model.fit(X_train, y_train, group=train_groups)"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "Predicts and ranks MVPs for the test years",
                            "codeSegments": [
                                {
                                    "line": 107,
                                    "code": "y_pred = model.predict(X_test)"
                                },
                                {
                                    "line": 108,
                                    "code": "df.loc[test_idx, \"PredictedScore\"] = y_pred"
                                },
                                {
                                    "line": 109,
                                    "code": "df.loc[test_idx, \"PredictedRank\"] = ("
                                },
                                {
                                    "line": 110,
                                    "code": "df.loc[test_idx]"
                                },
                                {
                                    "line": 111,
                                    "code": ".groupby(\"Year\")[\"PredictedScore\"]"
                                },
                                {
                                    "line": 112,
                                    "code": ".rank(ascending=False, method=\"first\")"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "Evaluates performance using NDCG",
                            "codeSegments": [
                                {
                                    "line": 115,
                                    "code": "ndcg = evaluate_ndcg(y_test.to_numpy(), y_pred, test_groups)"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "Prints and visualizes results for the test years",
                            "codeSegments": [
                                {
                                    "line": 119,
                                    "code": "print(df[test_idx][[\"Year\", \"Name\", \"Rank\", \"PredictedScore\", \"PredictedRank\"]])"
                                },
                                {
                                    "line": 120,
                                    "code": "plot_ranking_predictions(df, 2024)"
                                },
                                {
                                    "line": 121,
                                    "code": "plot_ranking_predictions(df, 2025)"
                                }
                            ]
                        }
                    ],
                    "high_unstructured": [
                        {
                            "summaryComponent": "The main() function orchestrates the process of training and evaluating an XGBoostRanker for MVP prediction.",
                            "codeSegments": [
                                {
                                    "line": 74,
                                    "code": "def main():"
                                },
                                {
                                    "line": 95,
                                    "code": "model = XGBRanker("
                                }
                            ]
                        },
                        {
                            "summaryComponent": "It first loads the dataset",
                            "codeSegments": [
                                {
                                    "line": 75,
                                    "code": "X, y, group, df = load_data()"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "and splits it into training and testing sets based on years",
                            "codeSegments": [
                                {
                                    "line": 78,
                                    "code": "unique_years = df[\"Year\"].unique()"
                                },
                                {
                                    "line": 79,
                                    "code": "train_years, test_years = ("
                                },
                                {
                                    "line": 84,
                                    "code": "train_idx = df[\"Year\"].isin(train_years)"
                                },
                                {
                                    "line": 85,
                                    "code": "test_idx = df[\"Year\"].isin(test_years)"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "ensuring that the most recent two years are reserved for testing.",
                            "codeSegments": [
                                {
                                    "line": 79,
                                    "code": "train_years, test_years = ("
                                },
                                {
                                    "line": 81,
                                    "code": "unique_years[-2:],  # test: 2024-2025"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "The model is trained on the training set using group information to respect the ranking structure within each year.",
                            "codeSegments": [
                                {
                                    "line": 91,
                                    "code": "train_groups = df[train_idx].groupby(\"Year\").size().to_numpy()"
                                },
                                {
                                    "line": 104,
                                    "code": "model.fit(X_train, y_train, group=train_groups)"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "After making predictions for the test years",
                            "codeSegments": [
                                {
                                    "line": 107,
                                    "code": "y_pred = model.predict(X_test)"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "it assigns predicted ranks",
                            "codeSegments": [
                                {
                                    "line": 109,
                                    "code": "df.loc[test_idx, \"PredictedRank\"] = ("
                                }
                            ]
                        },
                        {
                            "summaryComponent": "evaluates the model's performance using the NDCG metric",
                            "codeSegments": [
                                {
                                    "line": 115,
                                    "code": "ndcg = evaluate_ndcg(y_test.to_numpy(), y_pred, test_groups)"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "prints detailed results",
                            "codeSegments": [
                                {
                                    "line": 119,
                                    "code": "print(df[test_idx][[\"Year\", \"Name\", \"Rank\", \"PredictedScore\", \"PredictedRank\"]])"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "and generates bar plots visualizing prediction errors for each test year.",
                            "codeSegments": [
                                {
                                    "line": 120,
                                    "code": "plot_ranking_predictions(df, 2024)"
                                },
                                {
                                    "line": 121,
                                    "code": "plot_ranking_predictions(df, 2025)"
                                }
                            ]
                        }
                    ],
                    "high_structured": [
                        {
                            "summaryComponent": "Loads data and extracts features (X), labels (y), group sizes, and the full DataFrame",
                            "codeSegments": [
                                {
                                    "line": 75,
                                    "code": "X, y, group, df = load_data()"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "Splits data by year:",
                            "codeSegments": [
                                {
                                    "line": 78,
                                    "code": "unique_years = df[\"Year\"].unique()"
                                },
                                {
                                    "line": 79,
                                    "code": "train_years, test_years = ("
                                },
                                {
                                    "line": 80,
                                    "code": "    unique_years[:-2],  # train: 2015-2023"
                                },
                                {
                                    "line": 81,
                                    "code": "    unique_years[-2:],  # test: 2024-2025"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "Training: all years except the last two",
                            "codeSegments": [
                                {
                                    "line": 79,
                                    "code": "train_years, test_years = ("
                                },
                                {
                                    "line": 80,
                                    "code": "    unique_years[:-2],  # train: 2015-2023"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "Testing: the last two years",
                            "codeSegments": [
                                {
                                    "line": 79,
                                    "code": "train_years, test_years = ("
                                },
                                {
                                    "line": 81,
                                    "code": "    unique_years[-2:],  # test: 2024-2025"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "Creates boolean indices to separate training and test data",
                            "codeSegments": [
                                {
                                    "line": 84,
                                    "code": "train_idx = df[\"Year\"].isin(train_years)"
                                },
                                {
                                    "line": 85,
                                    "code": "test_idx = df[\"Year\"].isin(test_years)"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "Prepares group sizes for both training and testing sets",
                            "codeSegments": [
                                {
                                    "line": 91,
                                    "code": "train_groups = df[train_idx].groupby(\"Year\").size().to_numpy()"
                                },
                                {
                                    "line": 92,
                                    "code": "test_groups = df[test_idx].groupby(\"Year\").size().to_numpy()"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "Initializes and trains an XGBoostRanker model with specified hyperparameters",
                            "codeSegments": [
                                {
                                    "line": 95,
                                    "code": "model = XGBRanker("
                                },
                                {
                                    "line": 96,
                                    "code": "    objective=\"rank:pairwise\","
                                },
                                {
                                    "line": 97,
                                    "code": "    learning_rate=0.1,"
                                },
                                {
                                    "line": 98,
                                    "code": "    n_estimators=100,"
                                },
                                {
                                    "line": 99,
                                    "code": "    max_depth=4,"
                                },
                                {
                                    "line": 100,
                                    "code": "    random_state=42,"
                                },
                                {
                                    "line": 101,
                                    "code": ")"
                                },
                                {
                                    "line": 104,
                                    "code": "model.fit(X_train, y_train, group=train_groups)"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "Uses group information to handle ranking within each year",
                            "codeSegments": [
                                {
                                    "line": 104,
                                    "code": "model.fit(X_train, y_train, group=train_groups)"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "Predicts scores for the test set and assigns predicted ranks within each year",
                            "codeSegments": [
                                {
                                    "line": 107,
                                    "code": "y_pred = model.predict(X_test)"
                                },
                                {
                                    "line": 108,
                                    "code": "df.loc[test_idx, \"PredictedScore\"] = y_pred"
                                },
                                {
                                    "line": 109,
                                    "code": "df.loc[test_idx, \"PredictedRank\"] = ("
                                },
                                {
                                    "line": 110,
                                    "code": "    df.loc[test_idx]"
                                },
                                {
                                    "line": 111,
                                    "code": "    .groupby(\"Year\")[\"PredictedScore\"]"
                                },
                                {
                                    "line": 112,
                                    "code": "    .rank(ascending=False, method=\"first\")"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "Stores predicted scores and ranks in the DataFrame",
                            "codeSegments": [
                                {
                                    "line": 108,
                                    "code": "df.loc[test_idx, \"PredictedScore\"] = y_pred"
                                },
                                {
                                    "line": 109,
                                    "code": "df.loc[test_idx, \"PredictedRank\"] = ("
                                }
                            ]
                        },
                        {
                            "summaryComponent": "Evaluates model performance using the NDCG metric and prints the result",
                            "codeSegments": [
                                {
                                    "line": 115,
                                    "code": "ndcg = evaluate_ndcg(y_test.to_numpy(), y_pred, test_groups)"
                                },
                                {
                                    "line": 116,
                                    "code": "print(f\"NDCG Score on test years {test_years.tolist()}: {ndcg:.4f}\")"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "Displays detailed prediction results for the test years",
                            "codeSegments": [
                                {
                                    "line": 119,
                                    "code": "print(df[test_idx][[\"Year\", \"Name\", \"Rank\", \"PredictedScore\", \"PredictedRank\"]])"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "Generates and saves bar plots of prediction errors for each test year",
                            "codeSegments": [
                                {
                                    "line": 120,
                                    "code": "plot_ranking_predictions(df, 2024)"
                                },
                                {
                                    "line": 121,
                                    "code": "plot_ranking_predictions(df, 2025)"
                                }
                            ]
                        }
                    ]
                },
                "editPromptValue": "",
                "editPromptDetailLevel": null
            },
            "section_id": "98364d69-7071-47ca-9328-9f9a586aed75"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:41:51.000",
        "event": "create_new_section",
        "id": "MQFQ3CccUe7et2H4QhPp"
    },
    {
        "data": {
            "before_section_id": "b8ebaadc-fc99-48e5-882d-fad26e99fc33",
            "after_section_id": "98364d69-7071-47ca-9328-9f9a586aed75"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:41:51.000",
        "event": "autotransit_section",
        "id": "mzVoGyLefbSM8BbbAGBm"
    },
    {
        "data": {
            "mapping_index": 0,
            "structured_type": "unstructured",
            "section_id": "98364d69-7071-47ca-9328-9f9a586aed75",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:41:57.000",
        "event": "mapping_hover",
        "id": "5uubgeuh6kskHrihJYQq"
    },
    {
        "data": {
            "structured_type": "unstructured",
            "section_id": "98364d69-7071-47ca-9328-9f9a586aed75",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:41:57.000",
        "event": "mapping_unhover",
        "id": "QnFG8s0JIUmCUMTRyx3R"
    },
    {
        "data": {
            "structured_type": "unstructured",
            "section_id": "98364d69-7071-47ca-9328-9f9a586aed75",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:41:57.000",
        "event": "mapping_unhover",
        "id": "V88gJZAQukSA9Z1PulgW"
    },
    {
        "data": {
            "mapping_index": 3,
            "structured_type": "unstructured",
            "section_id": "98364d69-7071-47ca-9328-9f9a586aed75",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:41:57.000",
        "event": "mapping_hover",
        "id": "W7ykBSVdKijiFmJDCGU6"
    },
    {
        "data": {
            "mapping_index": 1,
            "structured_type": "unstructured",
            "section_id": "98364d69-7071-47ca-9328-9f9a586aed75",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:41:57.000",
        "event": "mapping_hover",
        "id": "cw2JVYcw62TYlanf5emy"
    },
    {
        "data": {
            "structured_type": "unstructured",
            "section_id": "98364d69-7071-47ca-9328-9f9a586aed75",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:41:57.000",
        "event": "mapping_unhover",
        "id": "gDEABaa4IWKXnedMcbE7"
    },
    {
        "data": {
            "structured_type": "unstructured",
            "section_id": "98364d69-7071-47ca-9328-9f9a586aed75",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:41:57.000",
        "event": "mapping_unhover",
        "id": "rSP8BfKP45XkAxd8EnAP"
    },
    {
        "data": {
            "mapping_index": 2,
            "structured_type": "unstructured",
            "section_id": "98364d69-7071-47ca-9328-9f9a586aed75",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:41:57.000",
        "event": "mapping_hover",
        "id": "wIzYB9GIDYGQKFI8nn0s"
    },
    {
        "data": {
            "mapping_index": 4,
            "structured_type": "unstructured",
            "section_id": "98364d69-7071-47ca-9328-9f9a586aed75",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:41:57.000",
        "event": "mapping_hover",
        "id": "ydXlEqaFB10V9niNyz6q"
    },
    {
        "data": {
            "mapping_index": 2,
            "structured_type": "unstructured",
            "section_id": "98364d69-7071-47ca-9328-9f9a586aed75",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:41:58.000",
        "event": "mapping_hover",
        "id": "1zLRlmNjAJuq3EIml9yy"
    },
    {
        "data": {
            "structured_type": "unstructured",
            "section_id": "98364d69-7071-47ca-9328-9f9a586aed75",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:41:58.000",
        "event": "mapping_unhover",
        "id": "DXqivNQ27mctqqKkaavJ"
    },
    {
        "data": {
            "structured_type": "unstructured",
            "section_id": "98364d69-7071-47ca-9328-9f9a586aed75",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:41:58.000",
        "event": "mapping_unhover",
        "id": "Gks353JcNt7Qqs1oDleP"
    },
    {
        "data": {
            "structured_type": "unstructured",
            "section_id": "98364d69-7071-47ca-9328-9f9a586aed75",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:41:58.000",
        "event": "mapping_unhover",
        "id": "H1mxGvkEgLtzav4vRuzA"
    },
    {
        "data": {
            "mapping_index": 6,
            "structured_type": "unstructured",
            "section_id": "98364d69-7071-47ca-9328-9f9a586aed75",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:41:58.000",
        "event": "mapping_hover",
        "id": "KpS1NS01DLNFau03BJxj"
    },
    {
        "data": {
            "mapping_index": 4,
            "structured_type": "unstructured",
            "section_id": "98364d69-7071-47ca-9328-9f9a586aed75",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:41:58.000",
        "event": "mapping_hover",
        "id": "RU6FOu7G5MltS0oiRExg"
    },
    {
        "data": {
            "mapping_index": 5,
            "structured_type": "unstructured",
            "section_id": "98364d69-7071-47ca-9328-9f9a586aed75",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:41:58.000",
        "event": "mapping_hover",
        "id": "Sbwdf5k97aCLr3ak3SvC"
    },
    {
        "data": {
            "structured_type": "unstructured",
            "section_id": "98364d69-7071-47ca-9328-9f9a586aed75",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:41:58.000",
        "event": "mapping_unhover",
        "id": "SeCJIKYMoMjMhMMIDH4l"
    },
    {
        "data": {
            "structured_type": "unstructured",
            "section_id": "98364d69-7071-47ca-9328-9f9a586aed75",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:41:58.000",
        "event": "mapping_unhover",
        "id": "WZwd6olOwAPeo80dzXbL"
    },
    {
        "data": {
            "structured_type": "unstructured",
            "section_id": "98364d69-7071-47ca-9328-9f9a586aed75",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:41:58.000",
        "event": "mapping_unhover",
        "id": "kO1TyumUWpyp0CcEQVPM"
    },
    {
        "data": {
            "mapping_index": 3,
            "structured_type": "unstructured",
            "section_id": "98364d69-7071-47ca-9328-9f9a586aed75",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:41:58.000",
        "event": "mapping_hover",
        "id": "kc0XM2tRxZ4UBPw6QWCl"
    },
    {
        "data": {
            "mapping_index": 0,
            "structured_type": "unstructured",
            "section_id": "98364d69-7071-47ca-9328-9f9a586aed75",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:41:58.000",
        "event": "mapping_hover",
        "id": "mW5ObgcpHXNcDyIQVhJK"
    },
    {
        "data": {
            "mapping_index": 1,
            "structured_type": "unstructured",
            "section_id": "98364d69-7071-47ca-9328-9f9a586aed75",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:41:58.000",
        "event": "mapping_hover",
        "id": "suhPByopMPPFNloAUiAe"
    },
    {
        "data": {
            "structured_type": "unstructured",
            "section_id": "98364d69-7071-47ca-9328-9f9a586aed75",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:41:58.000",
        "event": "mapping_unhover",
        "id": "xIQ0OOjY8LyEt5vVvHhe"
    },
    {
        "data": {
            "structured_type": "unstructured",
            "section_id": "98364d69-7071-47ca-9328-9f9a586aed75",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:41:59.000",
        "event": "mapping_unhover",
        "id": "8buuWrBMH5tQ4qFmj1mp"
    },
    {
        "data": {
            "mapping_index": 1,
            "structured_type": "unstructured",
            "section_id": "98364d69-7071-47ca-9328-9f9a586aed75",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:41:59.000",
        "event": "mapping_hover",
        "id": "FrZz99noGCrukAsumOF5"
    },
    {
        "data": {
            "structured_type": "unstructured",
            "section_id": "98364d69-7071-47ca-9328-9f9a586aed75",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:41:59.000",
        "event": "mapping_unhover",
        "id": "jPLTH37fMPbLU4fjElWX"
    },
    {
        "data": {
            "mapping_index": 0,
            "structured_type": "unstructured",
            "section_id": "98364d69-7071-47ca-9328-9f9a586aed75",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:41:59.000",
        "event": "mapping_hover",
        "id": "oKWEjYnQd08omV4Ttx5J"
    },
    {
        "data": {
            "mapping_index": 1,
            "structured_type": "unstructured",
            "section_id": "98364d69-7071-47ca-9328-9f9a586aed75",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:42:00.000",
        "event": "mapping_hover",
        "id": "EkiIsU3JuZZ3R3IK2tDr"
    },
    {
        "data": {
            "structured_type": "unstructured",
            "section_id": "98364d69-7071-47ca-9328-9f9a586aed75",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:42:00.000",
        "event": "mapping_unhover",
        "id": "OM31Y6OKJrQIfg6nhh8R"
    },
    {
        "data": {
            "structured_type": "unstructured",
            "section_id": "98364d69-7071-47ca-9328-9f9a586aed75",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:42:00.000",
        "event": "mapping_unhover",
        "id": "RHXfkw9F38i3HjThoKdk"
    },
    {
        "data": {
            "mapping_index": 2,
            "structured_type": "unstructured",
            "section_id": "98364d69-7071-47ca-9328-9f9a586aed75",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:42:00.000",
        "event": "mapping_hover",
        "id": "T5UenuCW1ywcIggl45sC"
    },
    {
        "data": {
            "structured_type": "unstructured",
            "section_id": "98364d69-7071-47ca-9328-9f9a586aed75",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:42:00.000",
        "event": "mapping_unhover",
        "id": "wE4IYZ6lTxRE2NzLBqpo"
    },
    {
        "data": {
            "before_detail_level": "medium",
            "after_detail_level": "high",
            "before_structured": "unstructured",
            "section_id": "98364d69-7071-47ca-9328-9f9a586aed75",
            "after_structured": "unstructured"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:42:02.000",
        "event": "change_summary_level",
        "id": "7TsnqfAFpCSFkgmhGMzf"
    },
    {
        "data": {
            "structured_type": "unstructured",
            "section_id": "98364d69-7071-47ca-9328-9f9a586aed75",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:42:03.000",
        "event": "mapping_unhover",
        "id": "gt9DdMC3HccjLJx6iH1Z"
    },
    {
        "data": {
            "mapping_index": 0,
            "structured_type": "unstructured",
            "section_id": "98364d69-7071-47ca-9328-9f9a586aed75",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:42:03.000",
        "event": "mapping_hover",
        "id": "qprJuAB8F5EiFnTYTe1l"
    },
    {
        "data": {
            "before_detail_level": "high",
            "after_detail_level": "high",
            "before_structured": "unstructured",
            "section_id": "98364d69-7071-47ca-9328-9f9a586aed75",
            "after_structured": "structured"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:42:06.000",
        "event": "change_summary_level",
        "id": "YwbyCf64SHDiuoaub2N2"
    },
    {
        "data": {
            "mapping_index": 0,
            "structured_type": "structured",
            "section_id": "98364d69-7071-47ca-9328-9f9a586aed75",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:42:07.000",
        "event": "mapping_hover",
        "id": "ZvYsbvED0kVqmK3EwkVm"
    },
    {
        "data": {
            "mapping_index": 1,
            "structured_type": "structured",
            "section_id": "98364d69-7071-47ca-9328-9f9a586aed75",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:42:08.000",
        "event": "mapping_hover",
        "id": "XIZFJULeX8tF6PLm9qAM"
    },
    {
        "data": {
            "structured_type": "structured",
            "section_id": "98364d69-7071-47ca-9328-9f9a586aed75",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:42:08.000",
        "event": "mapping_unhover",
        "id": "hWp8GB0NiplTHyTuJoko"
    },
    {
        "data": {
            "mapping_index": 2,
            "structured_type": "structured",
            "section_id": "98364d69-7071-47ca-9328-9f9a586aed75",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:42:09.000",
        "event": "mapping_hover",
        "id": "6y38VrupOk93N4UJHpyI"
    },
    {
        "data": {
            "structured_type": "structured",
            "section_id": "98364d69-7071-47ca-9328-9f9a586aed75",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:42:09.000",
        "event": "mapping_unhover",
        "id": "U7UQVvNwCW8pE7KUL0wD"
    },
    {
        "data": {
            "structured_type": "structured",
            "section_id": "98364d69-7071-47ca-9328-9f9a586aed75",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:42:10.000",
        "event": "mapping_unhover",
        "id": "KlnMUyhHgFc8DgRH3J2a"
    },
    {
        "data": {
            "mapping_index": 3,
            "structured_type": "structured",
            "section_id": "98364d69-7071-47ca-9328-9f9a586aed75",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:42:10.000",
        "event": "mapping_hover",
        "id": "M78kn7kPumC95xW3l1an"
    },
    {
        "data": {
            "structured_type": "structured",
            "section_id": "98364d69-7071-47ca-9328-9f9a586aed75",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:42:10.000",
        "event": "mapping_unhover",
        "id": "RC0tBDvS1B06vf77q3El"
    },
    {
        "data": {
            "structured_type": "structured",
            "section_id": "98364d69-7071-47ca-9328-9f9a586aed75",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:42:10.000",
        "event": "mapping_unhover",
        "id": "kL6zxs2mxDMc2ITHw3gM"
    },
    {
        "data": {
            "mapping_index": 1,
            "structured_type": "structured",
            "section_id": "98364d69-7071-47ca-9328-9f9a586aed75",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:42:10.000",
        "event": "mapping_hover",
        "id": "m6cbsRJPcb7WpskdNhOp"
    },
    {
        "data": {
            "mapping_index": 0,
            "structured_type": "structured",
            "section_id": "98364d69-7071-47ca-9328-9f9a586aed75",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:42:10.000",
        "event": "mapping_hover",
        "id": "nPQa5ZvCbp0WdsTwfVcK"
    },
    {
        "data": {
            "mapping_index": 2,
            "structured_type": "structured",
            "section_id": "98364d69-7071-47ca-9328-9f9a586aed75",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:42:10.000",
        "event": "mapping_hover",
        "id": "oVhz5mHUcQP1wYDKnpgz"
    },
    {
        "data": {
            "structured_type": "structured",
            "section_id": "98364d69-7071-47ca-9328-9f9a586aed75",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:42:10.000",
        "event": "mapping_unhover",
        "id": "rS4FUW5msckDzhSDQg6q"
    },
    {
        "data": {
            "before_detail_level": "high",
            "after_detail_level": "high",
            "before_structured": "structured",
            "section_id": "98364d69-7071-47ca-9328-9f9a586aed75",
            "after_structured": "unstructured"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:42:11.000",
        "event": "change_summary_level",
        "id": "VfeDYfYDLVGTrmogCLdN"
    },
    {
        "data": {
            "structured_type": "structured",
            "section_id": "98364d69-7071-47ca-9328-9f9a586aed75",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:42:11.000",
        "event": "mapping_unhover",
        "id": "xjmFRyoTVN8ybpJCzmkF"
    },
    {
        "data": {
            "mapping_index": 0,
            "structured_type": "unstructured",
            "section_id": "98364d69-7071-47ca-9328-9f9a586aed75",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:42:12.000",
        "event": "mapping_hover",
        "id": "MSkPNBTNATjQBInit3LX"
    },
    {
        "data": {
            "structured_type": "unstructured",
            "section_id": "98364d69-7071-47ca-9328-9f9a586aed75",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:42:12.000",
        "event": "mapping_unhover",
        "id": "N2RsVl9TQV2v0Sum8msl"
    },
    {
        "data": {
            "mapping_index": 0,
            "structured_type": "unstructured",
            "section_id": "98364d69-7071-47ca-9328-9f9a586aed75",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:42:13.000",
        "event": "mapping_hover",
        "id": "I0PIQ2pRTRWAmA6zDv4b"
    },
    {
        "data": {
            "structured_type": "unstructured",
            "section_id": "98364d69-7071-47ca-9328-9f9a586aed75",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:42:14.000",
        "event": "mapping_unhover",
        "id": "0PUzj1M1osxUF6Ih2L2P"
    },
    {
        "data": {
            "mapping_index": 1,
            "structured_type": "unstructured",
            "section_id": "98364d69-7071-47ca-9328-9f9a586aed75",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:42:14.000",
        "event": "mapping_hover",
        "id": "Tjo7m4lVUTvwLTHIUpde"
    },
    {
        "data": {
            "mapping_index": 2,
            "structured_type": "unstructured",
            "section_id": "98364d69-7071-47ca-9328-9f9a586aed75",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:42:14.000",
        "event": "mapping_hover",
        "id": "dwdNwjkX5VxdweYkH8oD"
    },
    {
        "data": {
            "structured_type": "unstructured",
            "section_id": "98364d69-7071-47ca-9328-9f9a586aed75",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:42:14.000",
        "event": "mapping_unhover",
        "id": "uqRYb4BqVrYSJ8JjrVNU"
    },
    {
        "data": {
            "structured_type": "unstructured",
            "section_id": "98364d69-7071-47ca-9328-9f9a586aed75",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:42:15.000",
        "event": "mapping_unhover",
        "id": "8w1bh4hhANrtMvKciSQc"
    },
    {
        "data": {
            "mapping_index": 2,
            "structured_type": "unstructured",
            "section_id": "98364d69-7071-47ca-9328-9f9a586aed75",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:42:15.000",
        "event": "mapping_hover",
        "id": "9XejQpGUlgCIbhQITLy6"
    },
    {
        "data": {
            "structured_type": "unstructured",
            "section_id": "98364d69-7071-47ca-9328-9f9a586aed75",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:42:16.000",
        "event": "mapping_unhover",
        "id": "um5lNHAK65tdrXD9MHJ9"
    },
    {
        "data": {
            "structured_type": "unstructured",
            "section_id": "98364d69-7071-47ca-9328-9f9a586aed75",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:42:17.000",
        "event": "mapping_unhover",
        "id": "5UFFWZgL0kh0bsi5cHjA"
    },
    {
        "data": {
            "structured_type": "unstructured",
            "section_id": "98364d69-7071-47ca-9328-9f9a586aed75",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:42:17.000",
        "event": "mapping_unhover",
        "id": "RlhbYVQuu41mNBw3aAW1"
    },
    {
        "data": {
            "mapping_index": 3,
            "structured_type": "unstructured",
            "section_id": "98364d69-7071-47ca-9328-9f9a586aed75",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:42:17.000",
        "event": "mapping_hover",
        "id": "kKc9zjKMR6Y0NEwPMyQi"
    },
    {
        "data": {
            "mapping_index": 4,
            "structured_type": "unstructured",
            "section_id": "98364d69-7071-47ca-9328-9f9a586aed75",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:42:17.000",
        "event": "mapping_hover",
        "id": "xCtRr035JGJBbpV3CDMD"
    },
    {
        "data": {
            "mapping_index": 3,
            "structured_type": "unstructured",
            "section_id": "98364d69-7071-47ca-9328-9f9a586aed75",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:42:17.000",
        "event": "mapping_hover",
        "id": "zjatpByx9tW9iGBWTHed"
    },
    {
        "data": {
            "mapping_index": 4,
            "structured_type": "unstructured",
            "section_id": "98364d69-7071-47ca-9328-9f9a586aed75",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:42:19.000",
        "event": "mapping_hover",
        "id": "2isd80dK1o1aK1Rgv8cz"
    },
    {
        "data": {
            "structured_type": "unstructured",
            "section_id": "98364d69-7071-47ca-9328-9f9a586aed75",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:42:19.000",
        "event": "mapping_unhover",
        "id": "ENfAT29rmTN3btB961Kg"
    },
    {
        "data": {
            "structured_type": "unstructured",
            "section_id": "98364d69-7071-47ca-9328-9f9a586aed75",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:42:19.000",
        "event": "mapping_unhover",
        "id": "p9YuGba0sgKijm00E0xF"
    },
    {
        "data": {
            "mapping_index": 4,
            "structured_type": "unstructured",
            "section_id": "98364d69-7071-47ca-9328-9f9a586aed75",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:42:20.000",
        "event": "mapping_hover",
        "id": "LS6vggxaib26xAQnRws3"
    },
    {
        "data": {
            "mapping_index": 3,
            "structured_type": "unstructured",
            "section_id": "98364d69-7071-47ca-9328-9f9a586aed75",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:42:21.000",
        "event": "mapping_hover",
        "id": "OTxgFuy77qqjQy5Esj9e"
    },
    {
        "data": {
            "structured_type": "unstructured",
            "section_id": "98364d69-7071-47ca-9328-9f9a586aed75",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:42:21.000",
        "event": "mapping_unhover",
        "id": "qZEZW2GkTV9xE49M4hD3"
    },
    {
        "data": {
            "structured_type": "unstructured",
            "section_id": "98364d69-7071-47ca-9328-9f9a586aed75",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:42:21.000",
        "event": "mapping_unhover",
        "id": "yWnbQ1Mg91gKAJVwRDmV"
    },
    {
        "data": {
            "mapping_index": 5,
            "structured_type": "unstructured",
            "section_id": "98364d69-7071-47ca-9328-9f9a586aed75",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:42:22.000",
        "event": "mapping_hover",
        "id": "99FaMdGW7jUi9mE4ZX9I"
    },
    {
        "data": {
            "mapping_index": 4,
            "structured_type": "unstructured",
            "section_id": "98364d69-7071-47ca-9328-9f9a586aed75",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:42:22.000",
        "event": "mapping_hover",
        "id": "BYpU7P3nkeHzlJ1Lh4Vj"
    },
    {
        "data": {
            "mapping_index": 6,
            "structured_type": "unstructured",
            "section_id": "98364d69-7071-47ca-9328-9f9a586aed75",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:42:22.000",
        "event": "mapping_hover",
        "id": "MGnbs5uyPHCf6n1wA1eC"
    },
    {
        "data": {
            "structured_type": "unstructured",
            "section_id": "98364d69-7071-47ca-9328-9f9a586aed75",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:42:22.000",
        "event": "mapping_unhover",
        "id": "kk2mokZ44e7v5rnyqmYW"
    },
    {
        "data": {
            "structured_type": "unstructured",
            "section_id": "98364d69-7071-47ca-9328-9f9a586aed75",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:42:22.000",
        "event": "mapping_unhover",
        "id": "p1jozLBqxkFL3PEPvJJg"
    },
    {
        "data": {
            "structured_type": "unstructured",
            "section_id": "98364d69-7071-47ca-9328-9f9a586aed75",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:42:23.000",
        "event": "mapping_unhover",
        "id": "GN1BU6xMe7g541k1l2cq"
    },
    {
        "data": {
            "mapping_index": 5,
            "structured_type": "unstructured",
            "section_id": "98364d69-7071-47ca-9328-9f9a586aed75",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:42:23.000",
        "event": "mapping_hover",
        "id": "Q23wOzVD8Xqip5jp0AyB"
    },
    {
        "data": {
            "mapping_index": 7,
            "structured_type": "unstructured",
            "section_id": "98364d69-7071-47ca-9328-9f9a586aed75",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:42:23.000",
        "event": "mapping_hover",
        "id": "mGvcFRoSYQG0f0CkOTSm"
    },
    {
        "data": {
            "structured_type": "unstructured",
            "section_id": "98364d69-7071-47ca-9328-9f9a586aed75",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:42:23.000",
        "event": "mapping_unhover",
        "id": "ozlOtke6SNRBWMaDR3zm"
    },
    {
        "data": {
            "structured_type": "unstructured",
            "section_id": "98364d69-7071-47ca-9328-9f9a586aed75",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:42:25.000",
        "event": "mapping_unhover",
        "id": "9NLDeqAswrDpxOvGLd1b"
    },
    {
        "data": {
            "structured_type": "unstructured",
            "section_id": "98364d69-7071-47ca-9328-9f9a586aed75",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:42:25.000",
        "event": "mapping_unhover",
        "id": "RTUTr7lXC2emet9zF46o"
    },
    {
        "data": {
            "structured_type": "unstructured",
            "section_id": "98364d69-7071-47ca-9328-9f9a586aed75",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:42:25.000",
        "event": "mapping_unhover",
        "id": "ctP4VAvxccbvph1DEd4G"
    },
    {
        "data": {
            "mapping_index": 5,
            "structured_type": "unstructured",
            "section_id": "98364d69-7071-47ca-9328-9f9a586aed75",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:42:25.000",
        "event": "mapping_hover",
        "id": "oHmGfbuS8f4simInjiIF"
    },
    {
        "data": {
            "mapping_index": 4,
            "structured_type": "unstructured",
            "section_id": "98364d69-7071-47ca-9328-9f9a586aed75",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:42:25.000",
        "event": "mapping_hover",
        "id": "rAvsgHMtAq8jYis7slyS"
    },
    {
        "data": {
            "structured_type": "unstructured",
            "section_id": "98364d69-7071-47ca-9328-9f9a586aed75",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:42:26.000",
        "event": "mapping_unhover",
        "id": "5zmF8dIPOAeKF0mFS3FJ"
    },
    {
        "data": {
            "mapping_index": 5,
            "structured_type": "unstructured",
            "section_id": "98364d69-7071-47ca-9328-9f9a586aed75",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:42:26.000",
        "event": "mapping_hover",
        "id": "72Ck818NfQeTa2ePZ6fk"
    },
    {
        "data": {
            "mapping_index": 3,
            "structured_type": "unstructured",
            "section_id": "98364d69-7071-47ca-9328-9f9a586aed75",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:42:26.000",
        "event": "mapping_hover",
        "id": "8cWd0rlFzoEbs7IVR9kP"
    },
    {
        "data": {
            "structured_type": "unstructured",
            "section_id": "98364d69-7071-47ca-9328-9f9a586aed75",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:42:26.000",
        "event": "mapping_unhover",
        "id": "MEMJJ3H8kVPmWte4W3l7"
    },
    {
        "data": {
            "mapping_index": 8,
            "structured_type": "unstructured",
            "section_id": "98364d69-7071-47ca-9328-9f9a586aed75",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:42:26.000",
        "event": "mapping_hover",
        "id": "SntLYTpVKXYMyLxsBv0i"
    },
    {
        "data": {
            "mapping_index": 4,
            "structured_type": "unstructured",
            "section_id": "98364d69-7071-47ca-9328-9f9a586aed75",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:42:26.000",
        "event": "mapping_hover",
        "id": "Vyq6eSRIDmKsPyT1ErBP"
    },
    {
        "data": {
            "structured_type": "unstructured",
            "section_id": "98364d69-7071-47ca-9328-9f9a586aed75",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:42:26.000",
        "event": "mapping_unhover",
        "id": "XXBGasGeeOmsoRslqyWj"
    },
    {
        "data": {
            "structured_type": "unstructured",
            "section_id": "98364d69-7071-47ca-9328-9f9a586aed75",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:42:26.000",
        "event": "mapping_unhover",
        "id": "ei9GlMwoA6Bg5dJl8EGN"
    },
    {
        "data": {
            "structured_type": "unstructured",
            "section_id": "98364d69-7071-47ca-9328-9f9a586aed75",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:42:26.000",
        "event": "mapping_unhover",
        "id": "oHvs3oRanV7oCSohVU6d"
    },
    {
        "data": {
            "mapping_index": 9,
            "structured_type": "unstructured",
            "section_id": "98364d69-7071-47ca-9328-9f9a586aed75",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:42:26.000",
        "event": "mapping_hover",
        "id": "ro5nm2hSnFMGN2pya6R5"
    },
    {
        "data": {
            "mapping_index": 7,
            "structured_type": "unstructured",
            "section_id": "98364d69-7071-47ca-9328-9f9a586aed75",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:42:26.000",
        "event": "mapping_hover",
        "id": "xueQLprQzMUoReGAQgmY"
    },
    {
        "data": {
            "structured_type": "unstructured",
            "section_id": "98364d69-7071-47ca-9328-9f9a586aed75",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:42:27.000",
        "event": "mapping_unhover",
        "id": "0b9xmKeKhZQrdoGFWwh0"
    },
    {
        "data": {
            "mapping_index": 8,
            "structured_type": "unstructured",
            "section_id": "98364d69-7071-47ca-9328-9f9a586aed75",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:42:27.000",
        "event": "mapping_hover",
        "id": "8bcNyYRp7lxSsZy6eDDF"
    },
    {
        "data": {
            "structured_type": "unstructured",
            "section_id": "98364d69-7071-47ca-9328-9f9a586aed75",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:42:27.000",
        "event": "mapping_unhover",
        "id": "96MN4taw9JxprEmWGSCd"
    },
    {
        "data": {
            "structured_type": "unstructured",
            "section_id": "98364d69-7071-47ca-9328-9f9a586aed75",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:42:27.000",
        "event": "mapping_unhover",
        "id": "IXtRA6qgRLsvXI35YC4q"
    },
    {
        "data": {
            "mapping_index": 9,
            "structured_type": "unstructured",
            "section_id": "98364d69-7071-47ca-9328-9f9a586aed75",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:42:27.000",
        "event": "mapping_hover",
        "id": "QcZTPLu4rw46h6cYap7x"
    },
    {
        "data": {
            "mapping_index": 9,
            "structured_type": "unstructured",
            "section_id": "98364d69-7071-47ca-9328-9f9a586aed75",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:42:27.000",
        "event": "mapping_hover",
        "id": "QvE7sQFa8vnfq9Q02aCf"
    },
    {
        "data": {
            "mapping_index": 7,
            "structured_type": "unstructured",
            "section_id": "98364d69-7071-47ca-9328-9f9a586aed75",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:42:27.000",
        "event": "mapping_hover",
        "id": "TNfz0UEKacyYo8dGHtao"
    },
    {
        "data": {
            "structured_type": "unstructured",
            "section_id": "98364d69-7071-47ca-9328-9f9a586aed75",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:42:27.000",
        "event": "mapping_unhover",
        "id": "kl20Qf5VMfqzMBTcDW7c"
    },
    {
        "data": {
            "mapping_index": 7,
            "structured_type": "unstructured",
            "section_id": "98364d69-7071-47ca-9328-9f9a586aed75",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:42:27.000",
        "event": "mapping_hover",
        "id": "mKddOytMbRyhnGIWFxBR"
    },
    {
        "data": {
            "structured_type": "unstructured",
            "section_id": "98364d69-7071-47ca-9328-9f9a586aed75",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:42:27.000",
        "event": "mapping_unhover",
        "id": "meQYTsPRCK20qN8OaqOI"
    },
    {
        "data": {
            "structured_type": "unstructured",
            "section_id": "98364d69-7071-47ca-9328-9f9a586aed75",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:42:27.000",
        "event": "mapping_unhover",
        "id": "nSAJrs2nswuT4VUYvHef"
    },
    {
        "data": {
            "structured_type": "unstructured",
            "section_id": "98364d69-7071-47ca-9328-9f9a586aed75",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:42:27.000",
        "event": "mapping_unhover",
        "id": "si7xRhkNxAl6tegKhdoH"
    },
    {
        "data": {
            "mapping_index": 8,
            "structured_type": "unstructured",
            "section_id": "98364d69-7071-47ca-9328-9f9a586aed75",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:42:27.000",
        "event": "mapping_hover",
        "id": "uqA2H1Amh6rboXp6YbDS"
    },
    {
        "data": {
            "mapping_index": 2,
            "structured_type": "unstructured",
            "section_id": "98364d69-7071-47ca-9328-9f9a586aed75",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:42:30.000",
        "event": "mapping_hover",
        "id": "52xlOlp4Z0VJ6dCMdw4D"
    },
    {
        "data": {
            "mapping_index": 3,
            "structured_type": "unstructured",
            "section_id": "98364d69-7071-47ca-9328-9f9a586aed75",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:42:30.000",
        "event": "mapping_hover",
        "id": "Qv3IkRTqLvByEdUr4Bho"
    },
    {
        "data": {
            "structured_type": "unstructured",
            "section_id": "98364d69-7071-47ca-9328-9f9a586aed75",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:42:30.000",
        "event": "mapping_unhover",
        "id": "UdTzjjGCdH9h2KXlSh0X"
    },
    {
        "data": {
            "mapping_index": 4,
            "structured_type": "unstructured",
            "section_id": "98364d69-7071-47ca-9328-9f9a586aed75",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:42:30.000",
        "event": "mapping_hover",
        "id": "Xw7Uzrl1ys81droJvIU5"
    },
    {
        "data": {
            "structured_type": "unstructured",
            "section_id": "98364d69-7071-47ca-9328-9f9a586aed75",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:42:30.000",
        "event": "mapping_unhover",
        "id": "wZvJg21rKVXNX8GLtWf2"
    },
    {
        "data": {
            "mapping_index": 0,
            "structured_type": "unstructured",
            "section_id": "98364d69-7071-47ca-9328-9f9a586aed75",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:42:31.000",
        "event": "mapping_hover",
        "id": "0aHg6oj6qUsde8fTdyiu"
    },
    {
        "data": {
            "before_detail_level": "high",
            "after_detail_level": "high",
            "before_structured": "unstructured",
            "section_id": "98364d69-7071-47ca-9328-9f9a586aed75",
            "after_structured": "structured"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:42:31.000",
        "event": "change_summary_level",
        "id": "97Q25KShA7lll2t8Sv5f"
    },
    {
        "data": {
            "structured_type": "unstructured",
            "section_id": "98364d69-7071-47ca-9328-9f9a586aed75",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:42:31.000",
        "event": "mapping_unhover",
        "id": "XZMGplCEgLb7i4ZUU0aW"
    },
    {
        "data": {
            "structured_type": "unstructured",
            "section_id": "98364d69-7071-47ca-9328-9f9a586aed75",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:42:31.000",
        "event": "mapping_unhover",
        "id": "cqMDHXeHcJrBhqMw8gD3"
    },
    {
        "data": {
            "mapping_index": 0,
            "structured_type": "structured",
            "section_id": "98364d69-7071-47ca-9328-9f9a586aed75",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:42:32.000",
        "event": "mapping_hover",
        "id": "4v3EQvyXU3gFO8PlAOlp"
    },
    {
        "data": {
            "mapping_index": 5,
            "structured_type": "structured",
            "section_id": "98364d69-7071-47ca-9328-9f9a586aed75",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:42:32.000",
        "event": "mapping_hover",
        "id": "SP2adaHylVlSk4NqFgSR"
    },
    {
        "data": {
            "structured_type": "structured",
            "section_id": "98364d69-7071-47ca-9328-9f9a586aed75",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:42:32.000",
        "event": "mapping_unhover",
        "id": "WIFi3p1mJ9WJVHE8RMEw"
    },
    {
        "data": {
            "structured_type": "structured",
            "section_id": "98364d69-7071-47ca-9328-9f9a586aed75",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:42:32.000",
        "event": "mapping_unhover",
        "id": "XfI2giNXiVKB6KqtX3fo"
    },
    {
        "data": {
            "mapping_index": 3,
            "structured_type": "structured",
            "section_id": "98364d69-7071-47ca-9328-9f9a586aed75",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:42:32.000",
        "event": "mapping_hover",
        "id": "ZXaNYBvzHTvFfLsOKMwV"
    },
    {
        "data": {
            "structured_type": "structured",
            "section_id": "98364d69-7071-47ca-9328-9f9a586aed75",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:42:32.000",
        "event": "mapping_unhover",
        "id": "aBvP1xseDH8GChZ0ouPH"
    },
    {
        "data": {
            "mapping_index": 4,
            "structured_type": "structured",
            "section_id": "98364d69-7071-47ca-9328-9f9a586aed75",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:42:32.000",
        "event": "mapping_hover",
        "id": "jYwIsXiVm615LaGVntdc"
    },
    {
        "data": {
            "structured_type": "structured",
            "section_id": "98364d69-7071-47ca-9328-9f9a586aed75",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:42:32.000",
        "event": "mapping_unhover",
        "id": "mYeak1lizG9EiaOw5Rbq"
    },
    {
        "data": {
            "mapping_index": 8,
            "structured_type": "structured",
            "section_id": "98364d69-7071-47ca-9328-9f9a586aed75",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:42:32.000",
        "event": "mapping_hover",
        "id": "tS9MgUkeuAyD24jAWEgU"
    },
    {
        "data": {
            "structured_type": "structured",
            "section_id": "98364d69-7071-47ca-9328-9f9a586aed75",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:42:33.000",
        "event": "mapping_unhover",
        "id": "VSbO3HlsmoFpYr01NZSL"
    },
    {
        "data": {
            "structured_type": "structured",
            "section_id": "98364d69-7071-47ca-9328-9f9a586aed75",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:42:33.000",
        "event": "mapping_unhover",
        "id": "VqnT5ET8f0Yja7HSGA5I"
    },
    {
        "data": {
            "mapping_index": 7,
            "structured_type": "structured",
            "section_id": "98364d69-7071-47ca-9328-9f9a586aed75",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:42:33.000",
        "event": "mapping_hover",
        "id": "tpqpnHJRvuoeY9QNoAuL"
    },
    {
        "data": {
            "structured_type": "structured",
            "section_id": "98364d69-7071-47ca-9328-9f9a586aed75",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:42:49.000",
        "event": "mapping_unhover",
        "id": "C9kLoXZ3OSYJaCZUZGmN"
    },
    {
        "data": {
            "mapping_index": 5,
            "structured_type": "structured",
            "section_id": "98364d69-7071-47ca-9328-9f9a586aed75",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:42:49.000",
        "event": "mapping_hover",
        "id": "cMEdQGOATkOCc4cwsIwU"
    },
    {
        "data": {
            "mapping_index": 6,
            "structured_type": "structured",
            "section_id": "98364d69-7071-47ca-9328-9f9a586aed75",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:42:49.000",
        "event": "mapping_hover",
        "id": "vA3psa6bXfAD82rA5D7q"
    },
    {
        "data": {
            "structured_type": "structured",
            "section_id": "98364d69-7071-47ca-9328-9f9a586aed75",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:42:51.000",
        "event": "mapping_unhover",
        "id": "2jFJvCaeIfyi1aSKFhOF"
    },
    {
        "data": {
            "structured_type": "structured",
            "section_id": "98364d69-7071-47ca-9328-9f9a586aed75",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:42:51.000",
        "event": "mapping_unhover",
        "id": "4IjLqDc9TclQ4f4aCbOj"
    },
    {
        "data": {
            "mapping_index": 5,
            "structured_type": "structured",
            "section_id": "98364d69-7071-47ca-9328-9f9a586aed75",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:42:51.000",
        "event": "mapping_hover",
        "id": "AX9F1fL0czDcM7Lp3sdz"
    },
    {
        "data": {
            "mapping_index": 6,
            "structured_type": "structured",
            "section_id": "98364d69-7071-47ca-9328-9f9a586aed75",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:42:51.000",
        "event": "mapping_hover",
        "id": "JiNGO0wh1s6Vrb5spCXP"
    },
    {
        "data": {
            "mapping_index": 2,
            "structured_type": "structured",
            "section_id": "98364d69-7071-47ca-9328-9f9a586aed75",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:42:51.000",
        "event": "mapping_hover",
        "id": "Q98EUquaM6v372JvEhKW"
    },
    {
        "data": {
            "structured_type": "structured",
            "section_id": "98364d69-7071-47ca-9328-9f9a586aed75",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:42:51.000",
        "event": "mapping_unhover",
        "id": "QVNyApAMy5aSoHxhXKUM"
    },
    {
        "data": {
            "mapping_index": 3,
            "structured_type": "structured",
            "section_id": "98364d69-7071-47ca-9328-9f9a586aed75",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:42:51.000",
        "event": "mapping_hover",
        "id": "b9EqmJlx6k39o7oncPOq"
    },
    {
        "data": {
            "mapping_index": 0,
            "structured_type": "structured",
            "section_id": "98364d69-7071-47ca-9328-9f9a586aed75",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:42:51.000",
        "event": "mapping_hover",
        "id": "fDNkXJYa0iZkIY7vKZtt"
    },
    {
        "data": {
            "mapping_index": 7,
            "structured_type": "structured",
            "section_id": "98364d69-7071-47ca-9328-9f9a586aed75",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:42:51.000",
        "event": "mapping_hover",
        "id": "fHKaEjNO0VMb0Bz8IDCj"
    },
    {
        "data": {
            "structured_type": "structured",
            "section_id": "98364d69-7071-47ca-9328-9f9a586aed75",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:42:51.000",
        "event": "mapping_unhover",
        "id": "gOH8eQgHxo3KLr60nWXx"
    },
    {
        "data": {
            "structured_type": "structured",
            "section_id": "98364d69-7071-47ca-9328-9f9a586aed75",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:42:51.000",
        "event": "mapping_unhover",
        "id": "glRq5qC8oXZ7ttxPo5L3"
    },
    {
        "data": {
            "structured_type": "structured",
            "section_id": "98364d69-7071-47ca-9328-9f9a586aed75",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:42:51.000",
        "event": "mapping_unhover",
        "id": "mlBuyQIMTrL7IBMlFyoW"
    },
    {
        "data": {
            "structured_type": "structured",
            "section_id": "98364d69-7071-47ca-9328-9f9a586aed75",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:42:51.000",
        "event": "mapping_unhover",
        "id": "p3R4RjTLqNsh6YShPsLi"
    },
    {
        "data": {
            "mapping_index": 0,
            "structured_type": "structured",
            "section_id": "98364d69-7071-47ca-9328-9f9a586aed75",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:42:52.000",
        "event": "mapping_hover",
        "id": "0PHW36z0cWvz5l7oojE2"
    },
    {
        "data": {
            "structured_type": "structured",
            "section_id": "98364d69-7071-47ca-9328-9f9a586aed75",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:42:52.000",
        "event": "mapping_unhover",
        "id": "hTjGwqKtbERT4l2CArCh"
    },
    {
        "data": {},
        "source": "frontend",
        "timestamp": "2025-08-23 10:42:53.000",
        "event": "click_summarize_code",
        "id": "eMkkmOrRXBLhl9VriqCj"
    },
    {
        "data": {
            "selected_code": "    model = XGBRanker(\n        objective=\"rank:pairwise\",\n        learning_rate=0.1,\n        n_estimators=100,\n        max_depth=4,\n        random_state=42,\n    )\n",
            "summary": {
                "medium_unstructured": "The code initializes an XGBRanker model for ranking tasks using the XGBoost library. It specifies several hyperparameters, including the objective function, learning rate, number of estimators, maximum tree depth, and random seed. This setup prepares the model for training on pairwise ranking problems.",
                "low_structured": "• Instantiates an XGBRanker model\n• Sets specific hyperparameters for ranking tasks",
                "title": "Instantiation of an XGBRanker Model with Specific Hyperparameters",
                "medium_structured": "• Creates an XGBRanker instance from XGBoost\n• Sets the objective to 'rank:pairwise' for ranking tasks\n• Configures key parameters:\n  ◦ learning_rate is set to 0.1\n  ◦ n_estimators is set to 100\n  ◦ max_depth is set to 4\n  ◦ random_state is set to 42",
                "high_unstructured": "This code snippet instantiates an XGBRanker model from the XGBoost library, configuring it for pairwise ranking tasks by setting the objective to 'rank:pairwise'. The model is initialized with a learning rate of 0.1, 100 estimators (trees), a maximum tree depth of 4, and a fixed random seed of 42 for reproducibility. These hyperparameters control the model's learning speed, complexity, and randomness. The resulting model is ready to be trained on ranking data, such as in information retrieval or recommendation systems.",
                "high_structured": "• Instantiates an XGBRanker model from the XGBoost library\n• Sets the objective parameter to 'rank:pairwise', enabling pairwise ranking optimization\n• Configures hyperparameters:\n  ◦ learning_rate: 0.1, controlling the step size during learning\n  ◦ n_estimators: 100, specifying the number of boosting rounds (trees)\n  ◦ max_depth: 4, limiting the maximum depth of each tree to control model complexity\n  ◦ random_state: 42, ensuring reproducibility of results\n• Prepares the model for training on ranking tasks, such as those found in recommendation systems or information retrieval",
                "low_unstructured": "This code creates an XGBRanker model with predefined hyperparameters."
            }
        },
        "source": "backend",
        "timestamp": "2025-08-23 10:42:58.000",
        "event": "summarize_selected_code",
        "id": "sKV0ZNSQ5gleqr2uqiEG"
    },
    {
        "data": {
            "mapping": [
                {
                    "summaryComponent": "Instantiates an XGBRanker model",
                    "codeSegments": [
                        {
                            "line": 95,
                            "code": "model = XGBRanker("
                        },
                        {
                            "line": 101,
                            "code": ")"
                        }
                    ]
                },
                {
                    "summaryComponent": "Sets specific hyperparameters for ranking tasks",
                    "codeSegments": [
                        {
                            "line": 96,
                            "code": "objective=\"rank:pairwise\","
                        },
                        {
                            "line": 97,
                            "code": "learning_rate=0.1,"
                        },
                        {
                            "line": 98,
                            "code": "n_estimators=100,"
                        },
                        {
                            "line": 99,
                            "code": "max_depth=4,"
                        },
                        {
                            "line": 100,
                            "code": "random_state=42,"
                        }
                    ]
                }
            ],
            "summary": "• Instantiates an XGBRanker model\n• Sets specific hyperparameters for ranking tasks",
            "code": "95:     model = XGBRanker(\n96:         objective=\"rank:pairwise\",\n97:         learning_rate=0.1,\n98:         n_estimators=100,\n99:         max_depth=4,\n100:         random_state=42,\n101:     )\n102: "
        },
        "source": "backend",
        "timestamp": "2025-08-23 10:42:59.000",
        "event": "map_summary_code",
        "id": "5rPKHR8B92NPsb1Tl7yw"
    },
    {
        "data": {
            "mapping": [
                {
                    "summaryComponent": "creates an XGBRanker model",
                    "codeSegments": [
                        {
                            "line": 95,
                            "code": "model = XGBRanker("
                        }
                    ]
                },
                {
                    "summaryComponent": "with predefined hyperparameters",
                    "codeSegments": [
                        {
                            "line": 96,
                            "code": "objective=\"rank:pairwise\","
                        },
                        {
                            "line": 97,
                            "code": "learning_rate=0.1,"
                        },
                        {
                            "line": 98,
                            "code": "n_estimators=100,"
                        },
                        {
                            "line": 99,
                            "code": "max_depth=4,"
                        },
                        {
                            "line": 100,
                            "code": "random_state=42,"
                        }
                    ]
                }
            ],
            "summary": "This code creates an XGBRanker model with predefined hyperparameters.",
            "code": "95:     model = XGBRanker(\n96:         objective=\"rank:pairwise\",\n97:         learning_rate=0.1,\n98:         n_estimators=100,\n99:         max_depth=4,\n100:         random_state=42,\n101:     )\n102: "
        },
        "source": "backend",
        "timestamp": "2025-08-23 10:43:00.000",
        "event": "map_summary_code",
        "id": "B8aZiU420SfuMNITNXTh"
    },
    {
        "data": {
            "mapping": [
                {
                    "summaryComponent": "Instantiates an XGBRanker model from the XGBoost library",
                    "codeSegments": [
                        {
                            "line": 95,
                            "code": "model = XGBRanker("
                        }
                    ]
                },
                {
                    "summaryComponent": "Sets the objective parameter to 'rank:pairwise', enabling pairwise ranking optimization",
                    "codeSegments": [
                        {
                            "line": 96,
                            "code": "objective=\"rank:pairwise\","
                        }
                    ]
                },
                {
                    "summaryComponent": "Configures hyperparameters:",
                    "codeSegments": [
                        {
                            "line": 97,
                            "code": "learning_rate=0.1,"
                        },
                        {
                            "line": 98,
                            "code": "n_estimators=100,"
                        },
                        {
                            "line": 99,
                            "code": "max_depth=4,"
                        },
                        {
                            "line": 100,
                            "code": "random_state=42,"
                        }
                    ]
                },
                {
                    "summaryComponent": "learning_rate: 0.1, controlling the step size during learning",
                    "codeSegments": [
                        {
                            "line": 97,
                            "code": "learning_rate=0.1,"
                        }
                    ]
                },
                {
                    "summaryComponent": "n_estimators: 100, specifying the number of boosting rounds (trees)",
                    "codeSegments": [
                        {
                            "line": 98,
                            "code": "n_estimators=100,"
                        }
                    ]
                },
                {
                    "summaryComponent": "max_depth: 4, limiting the maximum depth of each tree to control model complexity",
                    "codeSegments": [
                        {
                            "line": 99,
                            "code": "max_depth=4,"
                        }
                    ]
                },
                {
                    "summaryComponent": "random_state: 42, ensuring reproducibility of results",
                    "codeSegments": [
                        {
                            "line": 100,
                            "code": "random_state=42,"
                        }
                    ]
                },
                {
                    "summaryComponent": "Prepares the model for training on ranking tasks, such as those found in recommendation systems or information retrieval",
                    "codeSegments": [
                        {
                            "line": 95,
                            "code": "model = XGBRanker("
                        }
                    ]
                }
            ],
            "summary": "• Instantiates an XGBRanker model from the XGBoost library\n• Sets the objective parameter to 'rank:pairwise', enabling pairwise ranking optimization\n• Configures hyperparameters:\n  ◦ learning_rate: 0.1, controlling the step size during learning\n  ◦ n_estimators: 100, specifying the number of boosting rounds (trees)\n  ◦ max_depth: 4, limiting the maximum depth of each tree to control model complexity\n  ◦ random_state: 42, ensuring reproducibility of results\n• Prepares the model for training on ranking tasks, such as those found in recommendation systems or information retrieval",
            "code": "95:     model = XGBRanker(\n96:         objective=\"rank:pairwise\",\n97:         learning_rate=0.1,\n98:         n_estimators=100,\n99:         max_depth=4,\n100:         random_state=42,\n101:     )\n102: "
        },
        "source": "backend",
        "timestamp": "2025-08-23 10:43:01.000",
        "event": "map_summary_code",
        "id": "AkwnJCJizDAMtrJnmwm4"
    },
    {
        "data": {
            "mapping": [
                {
                    "summaryComponent": "Creates an XGBRanker instance from XGBoost",
                    "codeSegments": [
                        {
                            "line": 95,
                            "code": "model = XGBRanker("
                        }
                    ]
                },
                {
                    "summaryComponent": "Sets the objective to 'rank:pairwise' for ranking tasks",
                    "codeSegments": [
                        {
                            "line": 96,
                            "code": "objective=\"rank:pairwise\","
                        }
                    ]
                },
                {
                    "summaryComponent": "Configures key parameters:",
                    "codeSegments": [
                        {
                            "line": 97,
                            "code": "learning_rate=0.1,"
                        },
                        {
                            "line": 98,
                            "code": "n_estimators=100,"
                        },
                        {
                            "line": 99,
                            "code": "max_depth=4,"
                        },
                        {
                            "line": 100,
                            "code": "random_state=42,"
                        }
                    ]
                },
                {
                    "summaryComponent": "learning_rate is set to 0.1",
                    "codeSegments": [
                        {
                            "line": 97,
                            "code": "learning_rate=0.1,"
                        }
                    ]
                },
                {
                    "summaryComponent": "n_estimators is set to 100",
                    "codeSegments": [
                        {
                            "line": 98,
                            "code": "n_estimators=100,"
                        }
                    ]
                },
                {
                    "summaryComponent": "max_depth is set to 4",
                    "codeSegments": [
                        {
                            "line": 99,
                            "code": "max_depth=4,"
                        }
                    ]
                },
                {
                    "summaryComponent": "random_state is set to 42",
                    "codeSegments": [
                        {
                            "line": 100,
                            "code": "random_state=42,"
                        }
                    ]
                }
            ],
            "summary": "• Creates an XGBRanker instance from XGBoost\n• Sets the objective to 'rank:pairwise' for ranking tasks\n• Configures key parameters:\n  ◦ learning_rate is set to 0.1\n  ◦ n_estimators is set to 100\n  ◦ max_depth is set to 4\n  ◦ random_state is set to 42",
            "code": "95:     model = XGBRanker(\n96:         objective=\"rank:pairwise\",\n97:         learning_rate=0.1,\n98:         n_estimators=100,\n99:         max_depth=4,\n100:         random_state=42,\n101:     )\n102: "
        },
        "source": "backend",
        "timestamp": "2025-08-23 10:43:01.000",
        "event": "map_summary_code",
        "id": "xFXnuxWholIW2clAF5Pc"
    },
    {
        "data": {
            "mapping": [
                {
                    "summaryComponent": "instantiates an XGBRanker model from the XGBoost library",
                    "codeSegments": [
                        {
                            "line": 95,
                            "code": "model = XGBRanker("
                        }
                    ]
                },
                {
                    "summaryComponent": "configuring it for pairwise ranking tasks by setting the objective to 'rank:pairwise'",
                    "codeSegments": [
                        {
                            "line": 96,
                            "code": "objective=\"rank:pairwise\","
                        }
                    ]
                },
                {
                    "summaryComponent": "The model is initialized with a learning rate of 0.1",
                    "codeSegments": [
                        {
                            "line": 97,
                            "code": "learning_rate=0.1,"
                        }
                    ]
                },
                {
                    "summaryComponent": "100 estimators (trees)",
                    "codeSegments": [
                        {
                            "line": 98,
                            "code": "n_estimators=100,"
                        }
                    ]
                },
                {
                    "summaryComponent": "a maximum tree depth of 4",
                    "codeSegments": [
                        {
                            "line": 99,
                            "code": "max_depth=4,"
                        }
                    ]
                },
                {
                    "summaryComponent": "a fixed random seed of 42 for reproducibility",
                    "codeSegments": [
                        {
                            "line": 100,
                            "code": "random_state=42,"
                        }
                    ]
                },
                {
                    "summaryComponent": "These hyperparameters control the model's learning speed, complexity, and randomness",
                    "codeSegments": [
                        {
                            "line": 97,
                            "code": "learning_rate=0.1,"
                        },
                        {
                            "line": 98,
                            "code": "n_estimators=100,"
                        },
                        {
                            "line": 99,
                            "code": "max_depth=4,"
                        },
                        {
                            "line": 100,
                            "code": "random_state=42,"
                        }
                    ]
                },
                {
                    "summaryComponent": "The resulting model is ready to be trained on ranking data",
                    "codeSegments": [
                        {
                            "line": 95,
                            "code": "model = XGBRanker("
                        }
                    ]
                },
                {
                    "summaryComponent": "such as in information retrieval or recommendation systems",
                    "codeSegments": []
                }
            ],
            "summary": "This code snippet instantiates an XGBRanker model from the XGBoost library, configuring it for pairwise ranking tasks by setting the objective to 'rank:pairwise'. The model is initialized with a learning rate of 0.1, 100 estimators (trees), a maximum tree depth of 4, and a fixed random seed of 42 for reproducibility. These hyperparameters control the model's learning speed, complexity, and randomness. The resulting model is ready to be trained on ranking data, such as in information retrieval or recommendation systems.",
            "code": "95:     model = XGBRanker(\n96:         objective=\"rank:pairwise\",\n97:         learning_rate=0.1,\n98:         n_estimators=100,\n99:         max_depth=4,\n100:         random_state=42,\n101:     )\n102: "
        },
        "source": "backend",
        "timestamp": "2025-08-23 10:43:03.000",
        "event": "map_summary_code",
        "id": "DETseQJYmIyouNbnJxXp"
    },
    {
        "data": {
            "section_data": {
                "lines": [
                    95,
                    102
                ],
                "summaryData": {
                    "medium_unstructured": "The code initializes an XGBRanker model for ranking tasks using the XGBoost library. It specifies several hyperparameters, including the objective function, learning rate, number of estimators, maximum tree depth, and random seed. This setup prepares the model for training on pairwise ranking problems.",
                    "low_structured": "• Instantiates an XGBRanker model\n• Sets specific hyperparameters for ranking tasks",
                    "title": "Instantiation of an XGBRanker Model with Specific Hyperparameters",
                    "medium_structured": "• Creates an XGBRanker instance from XGBoost\n• Sets the objective to 'rank:pairwise' for ranking tasks\n• Configures key parameters:\n  ◦ learning_rate is set to 0.1\n  ◦ n_estimators is set to 100\n  ◦ max_depth is set to 4\n  ◦ random_state is set to 42",
                    "high_unstructured": "This code snippet instantiates an XGBRanker model from the XGBoost library, configuring it for pairwise ranking tasks by setting the objective to 'rank:pairwise'. The model is initialized with a learning rate of 0.1, 100 estimators (trees), a maximum tree depth of 4, and a fixed random seed of 42 for reproducibility. These hyperparameters control the model's learning speed, complexity, and randomness. The resulting model is ready to be trained on ranking data, such as in information retrieval or recommendation systems.",
                    "high_structured": "• Instantiates an XGBRanker model from the XGBoost library\n• Sets the objective parameter to 'rank:pairwise', enabling pairwise ranking optimization\n• Configures hyperparameters:\n  ◦ learning_rate: 0.1, controlling the step size during learning\n  ◦ n_estimators: 100, specifying the number of boosting rounds (trees)\n  ◦ max_depth: 4, limiting the maximum depth of each tree to control model complexity\n  ◦ random_state: 42, ensuring reproducibility of results\n• Prepares the model for training on ranking tasks, such as those found in recommendation systems or information retrieval",
                    "low_unstructured": "This code creates an XGBRanker model with predefined hyperparameters."
                },
                "editPromptStructured": null,
                "createdAt": 1755974584000,
                "metadata": {
                    "filename": "rank_model.py",
                    "id": "a8ac0ba1-4aa9-45cd-b257-13f87c57764f",
                    "originalCode": "    model = XGBRanker(\n        objective=\"rank:pairwise\",\n        learning_rate=0.1,\n        n_estimators=100,\n        max_depth=4,\n        random_state=42,\n    )\n",
                    "fullPath": "/project/workspace/rank_model.py",
                    "offset": 2551
                },
                "selectedStructured": "unstructured",
                "title": "Instantiation of an XGBRanker Model with Specific Hyperparameters",
                "selectedDetailLevel": "medium",
                "summaryMappings": {
                    "medium_unstructured": [
                        {
                            "summaryComponent": "initializes an XGBRanker model",
                            "codeSegments": [
                                {
                                    "line": 95,
                                    "code": "model = XGBRanker("
                                }
                            ]
                        },
                        {
                            "summaryComponent": "for ranking tasks",
                            "codeSegments": [
                                {
                                    "line": 96,
                                    "code": "objective=\"rank:pairwise\","
                                }
                            ]
                        },
                        {
                            "summaryComponent": "using the XGBoost library",
                            "codeSegments": [
                                {
                                    "line": 95,
                                    "code": "XGBRanker("
                                }
                            ]
                        },
                        {
                            "summaryComponent": "specifies several hyperparameters",
                            "codeSegments": [
                                {
                                    "line": 96,
                                    "code": "objective=\"rank:pairwise\","
                                },
                                {
                                    "line": 97,
                                    "code": "learning_rate=0.1,"
                                },
                                {
                                    "line": 98,
                                    "code": "n_estimators=100,"
                                },
                                {
                                    "line": 99,
                                    "code": "max_depth=4,"
                                },
                                {
                                    "line": 100,
                                    "code": "random_state=42,"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "including the objective function",
                            "codeSegments": [
                                {
                                    "line": 96,
                                    "code": "objective=\"rank:pairwise\","
                                }
                            ]
                        },
                        {
                            "summaryComponent": "learning rate",
                            "codeSegments": [
                                {
                                    "line": 97,
                                    "code": "learning_rate=0.1,"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "number of estimators",
                            "codeSegments": [
                                {
                                    "line": 98,
                                    "code": "n_estimators=100,"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "maximum tree depth",
                            "codeSegments": [
                                {
                                    "line": 99,
                                    "code": "max_depth=4,"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "random seed",
                            "codeSegments": [
                                {
                                    "line": 100,
                                    "code": "random_state=42,"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "prepares the model for training on pairwise ranking problems",
                            "codeSegments": [
                                {
                                    "line": 96,
                                    "code": "objective=\"rank:pairwise\","
                                }
                            ]
                        }
                    ],
                    "low_structured": [
                        {
                            "summaryComponent": "Instantiates an XGBRanker model",
                            "codeSegments": [
                                {
                                    "line": 95,
                                    "code": "model = XGBRanker("
                                },
                                {
                                    "line": 101,
                                    "code": ")"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "Sets specific hyperparameters for ranking tasks",
                            "codeSegments": [
                                {
                                    "line": 96,
                                    "code": "objective=\"rank:pairwise\","
                                },
                                {
                                    "line": 97,
                                    "code": "learning_rate=0.1,"
                                },
                                {
                                    "line": 98,
                                    "code": "n_estimators=100,"
                                },
                                {
                                    "line": 99,
                                    "code": "max_depth=4,"
                                },
                                {
                                    "line": 100,
                                    "code": "random_state=42,"
                                }
                            ]
                        }
                    ],
                    "low_unstructured": [
                        {
                            "summaryComponent": "creates an XGBRanker model",
                            "codeSegments": [
                                {
                                    "line": 95,
                                    "code": "model = XGBRanker("
                                }
                            ]
                        },
                        {
                            "summaryComponent": "with predefined hyperparameters",
                            "codeSegments": [
                                {
                                    "line": 96,
                                    "code": "objective=\"rank:pairwise\","
                                },
                                {
                                    "line": 97,
                                    "code": "learning_rate=0.1,"
                                },
                                {
                                    "line": 98,
                                    "code": "n_estimators=100,"
                                },
                                {
                                    "line": 99,
                                    "code": "max_depth=4,"
                                },
                                {
                                    "line": 100,
                                    "code": "random_state=42,"
                                }
                            ]
                        }
                    ],
                    "medium_structured": [
                        {
                            "summaryComponent": "Creates an XGBRanker instance from XGBoost",
                            "codeSegments": [
                                {
                                    "line": 95,
                                    "code": "model = XGBRanker("
                                }
                            ]
                        },
                        {
                            "summaryComponent": "Sets the objective to 'rank:pairwise' for ranking tasks",
                            "codeSegments": [
                                {
                                    "line": 96,
                                    "code": "objective=\"rank:pairwise\","
                                }
                            ]
                        },
                        {
                            "summaryComponent": "Configures key parameters:",
                            "codeSegments": [
                                {
                                    "line": 97,
                                    "code": "learning_rate=0.1,"
                                },
                                {
                                    "line": 98,
                                    "code": "n_estimators=100,"
                                },
                                {
                                    "line": 99,
                                    "code": "max_depth=4,"
                                },
                                {
                                    "line": 100,
                                    "code": "random_state=42,"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "learning_rate is set to 0.1",
                            "codeSegments": [
                                {
                                    "line": 97,
                                    "code": "learning_rate=0.1,"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "n_estimators is set to 100",
                            "codeSegments": [
                                {
                                    "line": 98,
                                    "code": "n_estimators=100,"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "max_depth is set to 4",
                            "codeSegments": [
                                {
                                    "line": 99,
                                    "code": "max_depth=4,"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "random_state is set to 42",
                            "codeSegments": [
                                {
                                    "line": 100,
                                    "code": "random_state=42,"
                                }
                            ]
                        }
                    ],
                    "high_unstructured": [
                        {
                            "summaryComponent": "instantiates an XGBRanker model from the XGBoost library",
                            "codeSegments": [
                                {
                                    "line": 95,
                                    "code": "model = XGBRanker("
                                }
                            ]
                        },
                        {
                            "summaryComponent": "configuring it for pairwise ranking tasks by setting the objective to 'rank:pairwise'",
                            "codeSegments": [
                                {
                                    "line": 96,
                                    "code": "objective=\"rank:pairwise\","
                                }
                            ]
                        },
                        {
                            "summaryComponent": "The model is initialized with a learning rate of 0.1",
                            "codeSegments": [
                                {
                                    "line": 97,
                                    "code": "learning_rate=0.1,"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "100 estimators (trees)",
                            "codeSegments": [
                                {
                                    "line": 98,
                                    "code": "n_estimators=100,"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "a maximum tree depth of 4",
                            "codeSegments": [
                                {
                                    "line": 99,
                                    "code": "max_depth=4,"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "a fixed random seed of 42 for reproducibility",
                            "codeSegments": [
                                {
                                    "line": 100,
                                    "code": "random_state=42,"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "These hyperparameters control the model's learning speed, complexity, and randomness",
                            "codeSegments": [
                                {
                                    "line": 97,
                                    "code": "learning_rate=0.1,"
                                },
                                {
                                    "line": 98,
                                    "code": "n_estimators=100,"
                                },
                                {
                                    "line": 99,
                                    "code": "max_depth=4,"
                                },
                                {
                                    "line": 100,
                                    "code": "random_state=42,"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "The resulting model is ready to be trained on ranking data",
                            "codeSegments": [
                                {
                                    "line": 95,
                                    "code": "model = XGBRanker("
                                }
                            ]
                        },
                        {
                            "summaryComponent": "such as in information retrieval or recommendation systems",
                            "codeSegments": []
                        }
                    ],
                    "high_structured": [
                        {
                            "summaryComponent": "Instantiates an XGBRanker model from the XGBoost library",
                            "codeSegments": [
                                {
                                    "line": 95,
                                    "code": "model = XGBRanker("
                                }
                            ]
                        },
                        {
                            "summaryComponent": "Sets the objective parameter to 'rank:pairwise', enabling pairwise ranking optimization",
                            "codeSegments": [
                                {
                                    "line": 96,
                                    "code": "objective=\"rank:pairwise\","
                                }
                            ]
                        },
                        {
                            "summaryComponent": "Configures hyperparameters:",
                            "codeSegments": [
                                {
                                    "line": 97,
                                    "code": "learning_rate=0.1,"
                                },
                                {
                                    "line": 98,
                                    "code": "n_estimators=100,"
                                },
                                {
                                    "line": 99,
                                    "code": "max_depth=4,"
                                },
                                {
                                    "line": 100,
                                    "code": "random_state=42,"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "learning_rate: 0.1, controlling the step size during learning",
                            "codeSegments": [
                                {
                                    "line": 97,
                                    "code": "learning_rate=0.1,"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "n_estimators: 100, specifying the number of boosting rounds (trees)",
                            "codeSegments": [
                                {
                                    "line": 98,
                                    "code": "n_estimators=100,"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "max_depth: 4, limiting the maximum depth of each tree to control model complexity",
                            "codeSegments": [
                                {
                                    "line": 99,
                                    "code": "max_depth=4,"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "random_state: 42, ensuring reproducibility of results",
                            "codeSegments": [
                                {
                                    "line": 100,
                                    "code": "random_state=42,"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "Prepares the model for training on ranking tasks, such as those found in recommendation systems or information retrieval",
                            "codeSegments": [
                                {
                                    "line": 95,
                                    "code": "model = XGBRanker("
                                }
                            ]
                        }
                    ]
                },
                "editPromptValue": "",
                "editPromptDetailLevel": null
            },
            "section_id": "a8ac0ba1-4aa9-45cd-b257-13f87c57764f"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:43:04.000",
        "event": "create_new_section",
        "id": "FXittgt8zvD2EdZVqbz5"
    },
    {
        "data": {
            "before_section_id": "98364d69-7071-47ca-9328-9f9a586aed75",
            "after_section_id": "a8ac0ba1-4aa9-45cd-b257-13f87c57764f"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:43:04.000",
        "event": "autotransit_section",
        "id": "oOyNStTgAlJAhmFLbTED"
    },
    {
        "data": {
            "mapping": [
                {
                    "summaryComponent": "initializes an XGBRanker model",
                    "codeSegments": [
                        {
                            "line": 95,
                            "code": "model = XGBRanker("
                        }
                    ]
                },
                {
                    "summaryComponent": "for ranking tasks",
                    "codeSegments": [
                        {
                            "line": 96,
                            "code": "objective=\"rank:pairwise\","
                        }
                    ]
                },
                {
                    "summaryComponent": "using the XGBoost library",
                    "codeSegments": [
                        {
                            "line": 95,
                            "code": "XGBRanker("
                        }
                    ]
                },
                {
                    "summaryComponent": "specifies several hyperparameters",
                    "codeSegments": [
                        {
                            "line": 96,
                            "code": "objective=\"rank:pairwise\","
                        },
                        {
                            "line": 97,
                            "code": "learning_rate=0.1,"
                        },
                        {
                            "line": 98,
                            "code": "n_estimators=100,"
                        },
                        {
                            "line": 99,
                            "code": "max_depth=4,"
                        },
                        {
                            "line": 100,
                            "code": "random_state=42,"
                        }
                    ]
                },
                {
                    "summaryComponent": "including the objective function",
                    "codeSegments": [
                        {
                            "line": 96,
                            "code": "objective=\"rank:pairwise\","
                        }
                    ]
                },
                {
                    "summaryComponent": "learning rate",
                    "codeSegments": [
                        {
                            "line": 97,
                            "code": "learning_rate=0.1,"
                        }
                    ]
                },
                {
                    "summaryComponent": "number of estimators",
                    "codeSegments": [
                        {
                            "line": 98,
                            "code": "n_estimators=100,"
                        }
                    ]
                },
                {
                    "summaryComponent": "maximum tree depth",
                    "codeSegments": [
                        {
                            "line": 99,
                            "code": "max_depth=4,"
                        }
                    ]
                },
                {
                    "summaryComponent": "random seed",
                    "codeSegments": [
                        {
                            "line": 100,
                            "code": "random_state=42,"
                        }
                    ]
                },
                {
                    "summaryComponent": "prepares the model for training on pairwise ranking problems",
                    "codeSegments": [
                        {
                            "line": 96,
                            "code": "objective=\"rank:pairwise\","
                        }
                    ]
                }
            ],
            "summary": "The code initializes an XGBRanker model for ranking tasks using the XGBoost library. It specifies several hyperparameters, including the objective function, learning rate, number of estimators, maximum tree depth, and random seed. This setup prepares the model for training on pairwise ranking problems.",
            "code": "95:     model = XGBRanker(\n96:         objective=\"rank:pairwise\",\n97:         learning_rate=0.1,\n98:         n_estimators=100,\n99:         max_depth=4,\n100:         random_state=42,\n101:     )\n102: "
        },
        "source": "backend",
        "timestamp": "2025-08-23 10:43:04.000",
        "event": "map_summary_code",
        "id": "zdlfaBpsayofF1vXY6LV"
    },
    {
        "data": {
            "structured_type": "unstructured",
            "section_id": "a8ac0ba1-4aa9-45cd-b257-13f87c57764f",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:43:11.000",
        "event": "mapping_unhover",
        "id": "AExRuxsQ8YlAFRaS2axc"
    },
    {
        "data": {
            "structured_type": "unstructured",
            "section_id": "a8ac0ba1-4aa9-45cd-b257-13f87c57764f",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:43:11.000",
        "event": "mapping_unhover",
        "id": "H3I7vJVgcQcJylNO8d8A"
    },
    {
        "data": {
            "mapping_index": 6,
            "structured_type": "unstructured",
            "section_id": "a8ac0ba1-4aa9-45cd-b257-13f87c57764f",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:43:11.000",
        "event": "mapping_hover",
        "id": "a9cNVUeYbMcy7ZDV3a1y"
    },
    {
        "data": {
            "mapping_index": 0,
            "structured_type": "unstructured",
            "section_id": "a8ac0ba1-4aa9-45cd-b257-13f87c57764f",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:43:11.000",
        "event": "mapping_hover",
        "id": "hOV6pUI9lgoqG7m86lLI"
    },
    {
        "data": {
            "mapping_index": 3,
            "structured_type": "unstructured",
            "section_id": "a8ac0ba1-4aa9-45cd-b257-13f87c57764f",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:43:11.000",
        "event": "mapping_hover",
        "id": "pPqlcIvLRaHJ9bTf1475"
    },
    {
        "data": {
            "structured_type": "unstructured",
            "section_id": "a8ac0ba1-4aa9-45cd-b257-13f87c57764f",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:43:12.000",
        "event": "mapping_unhover",
        "id": "NnuUZUmnHyYJ1Q2l7wN4"
    },
    {
        "data": {
            "structured_type": "unstructured",
            "section_id": "a8ac0ba1-4aa9-45cd-b257-13f87c57764f",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:43:15.000",
        "event": "mapping_unhover",
        "id": "0Wpg5xfbchJcWgKX8Lzx"
    },
    {
        "data": {
            "structured_type": "unstructured",
            "section_id": "a8ac0ba1-4aa9-45cd-b257-13f87c57764f",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:43:15.000",
        "event": "mapping_unhover",
        "id": "0bMVEbk9kKyAJgQYawW0"
    },
    {
        "data": {
            "structured_type": "unstructured",
            "section_id": "a8ac0ba1-4aa9-45cd-b257-13f87c57764f",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:43:15.000",
        "event": "mapping_unhover",
        "id": "3fdays5Ur11FhdwQbnxB"
    },
    {
        "data": {
            "mapping_index": 0,
            "structured_type": "unstructured",
            "section_id": "a8ac0ba1-4aa9-45cd-b257-13f87c57764f",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:43:15.000",
        "event": "mapping_hover",
        "id": "6H4Oef4UO5ab9RvM8dA4"
    },
    {
        "data": {
            "mapping_index": 7,
            "structured_type": "unstructured",
            "section_id": "a8ac0ba1-4aa9-45cd-b257-13f87c57764f",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:43:15.000",
        "event": "mapping_hover",
        "id": "7cFpcrs56pbill6sEnfK"
    },
    {
        "data": {
            "structured_type": "unstructured",
            "section_id": "a8ac0ba1-4aa9-45cd-b257-13f87c57764f",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:43:15.000",
        "event": "mapping_unhover",
        "id": "PREvbJLLSAkxvADok2Et"
    },
    {
        "data": {
            "mapping_index": 3,
            "structured_type": "unstructured",
            "section_id": "a8ac0ba1-4aa9-45cd-b257-13f87c57764f",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:43:15.000",
        "event": "mapping_hover",
        "id": "dwavvV4YykwQumKaWJMW"
    },
    {
        "data": {
            "mapping_index": 2,
            "structured_type": "unstructured",
            "section_id": "a8ac0ba1-4aa9-45cd-b257-13f87c57764f",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:43:15.000",
        "event": "mapping_hover",
        "id": "hR64FUB3PZ3IltvBujPk"
    },
    {
        "data": {
            "mapping_index": 9,
            "structured_type": "unstructured",
            "section_id": "a8ac0ba1-4aa9-45cd-b257-13f87c57764f",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:43:15.000",
        "event": "mapping_hover",
        "id": "qER8c5H7fpUTdlCNhGja"
    },
    {
        "data": {
            "structured_type": "unstructured",
            "section_id": "a8ac0ba1-4aa9-45cd-b257-13f87c57764f",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:43:15.000",
        "event": "mapping_unhover",
        "id": "uwViPAxtQSmm4JEq3rRA"
    },
    {
        "data": {
            "mapping_index": 0,
            "structured_type": "unstructured",
            "section_id": "a8ac0ba1-4aa9-45cd-b257-13f87c57764f",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:43:15.000",
        "event": "mapping_hover",
        "id": "vRJtbwj7oCQI5oxhSrDF"
    },
    {
        "data": {
            "structured_type": "unstructured",
            "section_id": "a8ac0ba1-4aa9-45cd-b257-13f87c57764f",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:43:16.000",
        "event": "mapping_unhover",
        "id": "k00W1abi2U4SebR6lIu1"
    },
    {
        "data": {
            "structured_type": "unstructured",
            "section_id": "a8ac0ba1-4aa9-45cd-b257-13f87c57764f",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:43:17.000",
        "event": "mapping_unhover",
        "id": "30Rc4Ib62HO4n9feNfFB"
    },
    {
        "data": {
            "mapping_index": 0,
            "structured_type": "unstructured",
            "section_id": "a8ac0ba1-4aa9-45cd-b257-13f87c57764f",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:43:17.000",
        "event": "mapping_hover",
        "id": "iRB7cpyLn7Z6HJUghaTl"
    },
    {
        "data": {
            "mapping_index": 4,
            "structured_type": "unstructured",
            "section_id": "a8ac0ba1-4aa9-45cd-b257-13f87c57764f",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:43:29.000",
        "event": "mapping_hover",
        "id": "1mafuVBvoaPn1fGPe4Ta"
    },
    {
        "data": {
            "mapping_index": 7,
            "structured_type": "unstructured",
            "section_id": "a8ac0ba1-4aa9-45cd-b257-13f87c57764f",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:43:29.000",
        "event": "mapping_hover",
        "id": "Ghmv4weZw4kWo5biCJd5"
    },
    {
        "data": {
            "structured_type": "unstructured",
            "section_id": "a8ac0ba1-4aa9-45cd-b257-13f87c57764f",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:43:29.000",
        "event": "mapping_unhover",
        "id": "R4aWStxnCWjPbGoBdH7M"
    },
    {
        "data": {
            "structured_type": "unstructured",
            "section_id": "a8ac0ba1-4aa9-45cd-b257-13f87c57764f",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:43:29.000",
        "event": "mapping_unhover",
        "id": "XdRP78ostxWWCfuDWbtv"
    },
    {
        "data": {
            "mapping_index": 3,
            "structured_type": "unstructured",
            "section_id": "a8ac0ba1-4aa9-45cd-b257-13f87c57764f",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:43:29.000",
        "event": "mapping_hover",
        "id": "xAtsTOp4kjxPulRO9d0E"
    },
    {
        "data": {
            "mapping_index": 7,
            "structured_type": "unstructured",
            "section_id": "a8ac0ba1-4aa9-45cd-b257-13f87c57764f",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:43:30.000",
        "event": "mapping_hover",
        "id": "0fatHbF07AU97QGLOw4f"
    },
    {
        "data": {
            "structured_type": "unstructured",
            "section_id": "a8ac0ba1-4aa9-45cd-b257-13f87c57764f",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:43:30.000",
        "event": "mapping_unhover",
        "id": "EnONPxi8AENijOmW9c5g"
    },
    {
        "data": {
            "structured_type": "unstructured",
            "section_id": "a8ac0ba1-4aa9-45cd-b257-13f87c57764f",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:43:30.000",
        "event": "mapping_unhover",
        "id": "JdnEs6z65mgA3MN8ga8n"
    },
    {
        "data": {
            "structured_type": "unstructured",
            "section_id": "a8ac0ba1-4aa9-45cd-b257-13f87c57764f",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:43:30.000",
        "event": "mapping_unhover",
        "id": "NaLqVU7DO3HW8VNwB0fX"
    },
    {
        "data": {
            "mapping_index": 0,
            "structured_type": "unstructured",
            "section_id": "a8ac0ba1-4aa9-45cd-b257-13f87c57764f",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:43:30.000",
        "event": "mapping_hover",
        "id": "Owcrgk561ZxmujPbq8nc"
    },
    {
        "data": {
            "mapping_index": 1,
            "structured_type": "unstructured",
            "section_id": "a8ac0ba1-4aa9-45cd-b257-13f87c57764f",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:43:30.000",
        "event": "mapping_hover",
        "id": "S3LF57n6sIvQ78Rxlcbi"
    },
    {
        "data": {
            "mapping_index": 3,
            "structured_type": "unstructured",
            "section_id": "a8ac0ba1-4aa9-45cd-b257-13f87c57764f",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:43:30.000",
        "event": "mapping_hover",
        "id": "VSaGxVIlRmluxO1p3twU"
    },
    {
        "data": {
            "structured_type": "unstructured",
            "section_id": "a8ac0ba1-4aa9-45cd-b257-13f87c57764f",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:43:30.000",
        "event": "mapping_unhover",
        "id": "bAlz0Lf6HbJmDRdlzxFm"
    },
    {
        "data": {
            "mapping_index": 9,
            "structured_type": "unstructured",
            "section_id": "a8ac0ba1-4aa9-45cd-b257-13f87c57764f",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:43:30.000",
        "event": "mapping_hover",
        "id": "fl51hjTAJ5FDB1dXS75m"
    },
    {
        "data": {
            "structured_type": "unstructured",
            "section_id": "a8ac0ba1-4aa9-45cd-b257-13f87c57764f",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:43:30.000",
        "event": "mapping_unhover",
        "id": "q8ZmYbUHFi8eK42nncN8"
    },
    {
        "data": {
            "mapping_index": 3,
            "structured_type": "unstructured",
            "section_id": "a8ac0ba1-4aa9-45cd-b257-13f87c57764f",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:43:31.000",
        "event": "mapping_hover",
        "id": "6OEpqT4VhubtyUsjmq1V"
    },
    {
        "data": {
            "structured_type": "unstructured",
            "section_id": "a8ac0ba1-4aa9-45cd-b257-13f87c57764f",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:43:31.000",
        "event": "mapping_unhover",
        "id": "DEqnZe1Mumiu8RCqYsI3"
    },
    {
        "data": {
            "mapping_index": 2,
            "structured_type": "unstructured",
            "section_id": "a8ac0ba1-4aa9-45cd-b257-13f87c57764f",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:43:31.000",
        "event": "mapping_hover",
        "id": "ET6OC5ycrsPY0MjC4W13"
    },
    {
        "data": {
            "structured_type": "unstructured",
            "section_id": "a8ac0ba1-4aa9-45cd-b257-13f87c57764f",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:43:31.000",
        "event": "mapping_unhover",
        "id": "JwO9Kp05DJknFbAT9BIm"
    },
    {
        "data": {
            "mapping_index": 4,
            "structured_type": "unstructured",
            "section_id": "a8ac0ba1-4aa9-45cd-b257-13f87c57764f",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:43:32.000",
        "event": "mapping_hover",
        "id": "9iHXKxAv3XXmXEQyXNTk"
    },
    {
        "data": {
            "structured_type": "unstructured",
            "section_id": "a8ac0ba1-4aa9-45cd-b257-13f87c57764f",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:43:32.000",
        "event": "mapping_unhover",
        "id": "HAl26PAYHJJV3O8RriAr"
    },
    {
        "data": {
            "mapping_index": 6,
            "structured_type": "unstructured",
            "section_id": "a8ac0ba1-4aa9-45cd-b257-13f87c57764f",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:43:33.000",
        "event": "mapping_hover",
        "id": "OMpoakl44XySZzwlPPaJ"
    },
    {
        "data": {
            "structured_type": "unstructured",
            "section_id": "a8ac0ba1-4aa9-45cd-b257-13f87c57764f",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:43:33.000",
        "event": "mapping_unhover",
        "id": "R3XMMhZvZIHySv2d11O9"
    },
    {
        "data": {
            "structured_type": "unstructured",
            "section_id": "a8ac0ba1-4aa9-45cd-b257-13f87c57764f",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:43:33.000",
        "event": "mapping_unhover",
        "id": "o2CJWt7CkWaxB6RSHQ7o"
    },
    {
        "data": {
            "mapping_index": 5,
            "structured_type": "unstructured",
            "section_id": "a8ac0ba1-4aa9-45cd-b257-13f87c57764f",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:43:33.000",
        "event": "mapping_hover",
        "id": "xFSPYnNLpS6TLFJuzcn0"
    },
    {
        "data": {
            "mapping_index": 7,
            "structured_type": "unstructured",
            "section_id": "a8ac0ba1-4aa9-45cd-b257-13f87c57764f",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:43:34.000",
        "event": "mapping_hover",
        "id": "ffO6PBpZnx9RJKVWZbW0"
    },
    {
        "data": {
            "structured_type": "unstructured",
            "section_id": "a8ac0ba1-4aa9-45cd-b257-13f87c57764f",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:43:34.000",
        "event": "mapping_unhover",
        "id": "fswL0WvaMAN4gTx5fMqK"
    },
    {
        "data": {
            "structured_type": "unstructured",
            "section_id": "a8ac0ba1-4aa9-45cd-b257-13f87c57764f",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:43:34.000",
        "event": "mapping_unhover",
        "id": "kDttFTL2HeG0QnN3qIZD"
    },
    {
        "data": {
            "before_section_id": "a8ac0ba1-4aa9-45cd-b257-13f87c57764f",
            "after_section_id": "98364d69-7071-47ca-9328-9f9a586aed75"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:43:48.000",
        "event": "toggle_section",
        "id": "71225GEcT6Ixk6Ae37C3"
    },
    {
        "data": {
            "mapping_index": 11,
            "structured_type": "structured",
            "section_id": "98364d69-7071-47ca-9328-9f9a586aed75",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:43:48.000",
        "event": "mapping_hover",
        "id": "etaQZgDAj3LRcjMAafaX"
    },
    {
        "data": {
            "mapping_index": 11,
            "structured_type": "structured",
            "section_id": "98364d69-7071-47ca-9328-9f9a586aed75",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:43:50.000",
        "event": "mapping_hover",
        "id": "O5aIue5LqUb9nVCPiADy"
    },
    {
        "data": {
            "structured_type": "structured",
            "section_id": "98364d69-7071-47ca-9328-9f9a586aed75",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:43:50.000",
        "event": "mapping_unhover",
        "id": "WaDCzpr6zHlY2AMMiPC4"
    },
    {
        "data": {
            "structured_type": "structured",
            "section_id": "98364d69-7071-47ca-9328-9f9a586aed75",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:43:50.000",
        "event": "mapping_unhover",
        "id": "qrXNnbcKbphDZaYcLvMe"
    },
    {
        "data": {
            "structured_type": "structured",
            "section_id": "98364d69-7071-47ca-9328-9f9a586aed75",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:43:53.000",
        "event": "mapping_unhover",
        "id": "9ocg7Yf8nZOeSCvX2KWh"
    },
    {
        "data": {
            "mapping_index": 8,
            "structured_type": "structured",
            "section_id": "98364d69-7071-47ca-9328-9f9a586aed75",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:43:53.000",
        "event": "mapping_hover",
        "id": "Shua3xjivBsWg54wTmSS"
    },
    {
        "data": {
            "mapping_index": 7,
            "structured_type": "structured",
            "section_id": "98364d69-7071-47ca-9328-9f9a586aed75",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:43:53.000",
        "event": "mapping_hover",
        "id": "UE2I0S7QJF0IUDALwhUc"
    },
    {
        "data": {
            "structured_type": "structured",
            "section_id": "98364d69-7071-47ca-9328-9f9a586aed75",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:43:53.000",
        "event": "mapping_unhover",
        "id": "p0I0WSjR5X2lXTAkK60L"
    },
    {
        "data": {
            "structured_type": "structured",
            "section_id": "98364d69-7071-47ca-9328-9f9a586aed75",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:43:54.000",
        "event": "mapping_unhover",
        "id": "5IvxH4v2OnErEtu0Q3d2"
    },
    {
        "data": {
            "mapping_index": 6,
            "structured_type": "structured",
            "section_id": "98364d69-7071-47ca-9328-9f9a586aed75",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:43:54.000",
        "event": "mapping_hover",
        "id": "Kd5cestf1Iw38fylKNz9"
    },
    {
        "data": {
            "mapping_index": 7,
            "structured_type": "structured",
            "section_id": "98364d69-7071-47ca-9328-9f9a586aed75",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:43:54.000",
        "event": "mapping_hover",
        "id": "PvvbZEpoPRn6JiU7gecI"
    },
    {
        "data": {
            "structured_type": "structured",
            "section_id": "98364d69-7071-47ca-9328-9f9a586aed75",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:43:54.000",
        "event": "mapping_unhover",
        "id": "dxboXY4eTuyrFg6Plq8u"
    },
    {
        "data": {
            "structured_type": "structured",
            "section_id": "98364d69-7071-47ca-9328-9f9a586aed75",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:43:56.000",
        "event": "mapping_unhover",
        "id": "6dlm91HjiMqmzavz1B4Z"
    },
    {
        "data": {
            "mapping_index": 12,
            "structured_type": "structured",
            "section_id": "98364d69-7071-47ca-9328-9f9a586aed75",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:43:56.000",
        "event": "mapping_hover",
        "id": "7s21dqlbCuj1IFk5FEMi"
    },
    {
        "data": {
            "mapping_index": 11,
            "structured_type": "structured",
            "section_id": "98364d69-7071-47ca-9328-9f9a586aed75",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:43:56.000",
        "event": "mapping_hover",
        "id": "pCTgLKuMtXGw8HCUGOaU"
    },
    {
        "data": {
            "mapping_index": 4,
            "structured_type": "structured",
            "section_id": "98364d69-7071-47ca-9328-9f9a586aed75",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:43:57.000",
        "event": "mapping_hover",
        "id": "DuQGWptAxpjPULOBk4JB"
    },
    {
        "data": {
            "structured_type": "structured",
            "section_id": "98364d69-7071-47ca-9328-9f9a586aed75",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:43:57.000",
        "event": "mapping_unhover",
        "id": "iUqSbXq3o1UdUnNwpALO"
    },
    {
        "data": {
            "structured_type": "structured",
            "section_id": "98364d69-7071-47ca-9328-9f9a586aed75",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:43:57.000",
        "event": "mapping_unhover",
        "id": "jVa3xWq8PPhZiROObMfi"
    },
    {
        "data": {
            "mapping_index": 3,
            "structured_type": "structured",
            "section_id": "98364d69-7071-47ca-9328-9f9a586aed75",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:43:57.000",
        "event": "mapping_hover",
        "id": "u0zFZLgcxRgGFVB3h7O0"
    },
    {
        "data": {
            "structured_type": "structured",
            "section_id": "98364d69-7071-47ca-9328-9f9a586aed75",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:43:58.000",
        "event": "mapping_unhover",
        "id": "Yx89mA2oyuRkzUuMxwTN"
    },
    {
        "data": {
            "mapping_index": 0,
            "structured_type": "structured",
            "section_id": "98364d69-7071-47ca-9328-9f9a586aed75",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:44:00.000",
        "event": "mapping_hover",
        "id": "1Gg7nSDdaAGLcYDfU7Ez"
    },
    {
        "data": {
            "structured_type": "structured",
            "section_id": "98364d69-7071-47ca-9328-9f9a586aed75",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:44:00.000",
        "event": "mapping_unhover",
        "id": "fRuilbMAaThqvurhN6bu"
    },
    {
        "data": {
            "structured_type": "structured",
            "section_id": "98364d69-7071-47ca-9328-9f9a586aed75",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:44:00.000",
        "event": "mapping_unhover",
        "id": "s7z87Ez3pbkJ9QORVnSu"
    },
    {
        "data": {
            "mapping_index": 1,
            "structured_type": "structured",
            "section_id": "98364d69-7071-47ca-9328-9f9a586aed75",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:44:00.000",
        "event": "mapping_hover",
        "id": "zISvunfGNi8OZzz2CHzV"
    },
    {
        "data": {
            "structured_type": "structured",
            "section_id": "98364d69-7071-47ca-9328-9f9a586aed75",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:44:01.000",
        "event": "mapping_unhover",
        "id": "JhMMaTCsk12SrLEzKtAq"
    },
    {
        "data": {
            "mapping_index": 2,
            "structured_type": "structured",
            "section_id": "98364d69-7071-47ca-9328-9f9a586aed75",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:44:01.000",
        "event": "mapping_hover",
        "id": "SH2AlerBoOXdlnAy5RUt"
    },
    {
        "data": {
            "mapping_index": 1,
            "structured_type": "structured",
            "section_id": "98364d69-7071-47ca-9328-9f9a586aed75",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:44:01.000",
        "event": "mapping_hover",
        "id": "nZFEOg3k9guGHvQlkSmz"
    },
    {
        "data": {
            "mapping_index": 2,
            "structured_type": "structured",
            "section_id": "98364d69-7071-47ca-9328-9f9a586aed75",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:44:02.000",
        "event": "mapping_hover",
        "id": "NqvUQ92bMRub8b4AZ2oI"
    },
    {
        "data": {
            "structured_type": "structured",
            "section_id": "98364d69-7071-47ca-9328-9f9a586aed75",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:44:02.000",
        "event": "mapping_unhover",
        "id": "gcIIcBT63hBeCxtqMVlx"
    },
    {
        "data": {
            "structured_type": "structured",
            "section_id": "98364d69-7071-47ca-9328-9f9a586aed75",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:44:03.000",
        "event": "mapping_unhover",
        "id": "G8P3ZcYP1MREcHJc0cw5"
    },
    {
        "data": {
            "structured_type": "structured",
            "section_id": "98364d69-7071-47ca-9328-9f9a586aed75",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:44:03.000",
        "event": "mapping_unhover",
        "id": "QfyF5qiWS7xSIyQPjW3F"
    },
    {
        "data": {
            "mapping_index": 3,
            "structured_type": "structured",
            "section_id": "98364d69-7071-47ca-9328-9f9a586aed75",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:44:03.000",
        "event": "mapping_hover",
        "id": "ffglCScTUVNHuLf0LyXL"
    },
    {
        "data": {
            "mapping_index": 4,
            "structured_type": "structured",
            "section_id": "98364d69-7071-47ca-9328-9f9a586aed75",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:44:03.000",
        "event": "mapping_hover",
        "id": "ibnBIWSxPIXS64ARVSmr"
    },
    {
        "data": {
            "structured_type": "structured",
            "section_id": "98364d69-7071-47ca-9328-9f9a586aed75",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:44:03.000",
        "event": "mapping_unhover",
        "id": "rZ8b0fkj7UDM0qgKfHc0"
    },
    {
        "data": {
            "mapping_index": 2,
            "structured_type": "structured",
            "section_id": "98364d69-7071-47ca-9328-9f9a586aed75",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:44:04.000",
        "event": "mapping_hover",
        "id": "n8Xgk2dPAaR88EIwttbW"
    },
    {
        "data": {
            "structured_type": "structured",
            "section_id": "98364d69-7071-47ca-9328-9f9a586aed75",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:44:05.000",
        "event": "mapping_unhover",
        "id": "1gkrJlwiatAsvBRcxIdO"
    },
    {
        "data": {
            "mapping_index": 5,
            "structured_type": "structured",
            "section_id": "98364d69-7071-47ca-9328-9f9a586aed75",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:44:05.000",
        "event": "mapping_hover",
        "id": "dOma6OjXACv1apRmDeHO"
    },
    {
        "data": {
            "structured_type": "structured",
            "section_id": "98364d69-7071-47ca-9328-9f9a586aed75",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:44:05.000",
        "event": "mapping_unhover",
        "id": "xlaGul2yOoWhuKqxucvp"
    },
    {
        "data": {
            "structured_type": "structured",
            "section_id": "98364d69-7071-47ca-9328-9f9a586aed75",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:44:06.000",
        "event": "mapping_unhover",
        "id": "1BGS0yMwZSbjIR5biQIo"
    },
    {
        "data": {
            "mapping_index": 3,
            "structured_type": "structured",
            "section_id": "98364d69-7071-47ca-9328-9f9a586aed75",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:44:06.000",
        "event": "mapping_hover",
        "id": "3rtUv3eHbWhtjLRJUP4g"
    },
    {
        "data": {
            "mapping_index": 4,
            "structured_type": "structured",
            "section_id": "98364d69-7071-47ca-9328-9f9a586aed75",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:44:06.000",
        "event": "mapping_hover",
        "id": "8AkXdYs48Tw8PscIe5Cl"
    },
    {
        "data": {
            "structured_type": "structured",
            "section_id": "98364d69-7071-47ca-9328-9f9a586aed75",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:44:06.000",
        "event": "mapping_unhover",
        "id": "Jqc4PdB1EuAEuPAiB9uq"
    },
    {
        "data": {
            "mapping_index": 4,
            "structured_type": "structured",
            "section_id": "98364d69-7071-47ca-9328-9f9a586aed75",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:44:06.000",
        "event": "mapping_hover",
        "id": "Sp3piQm1U4aV9gv8FrYO"
    },
    {
        "data": {
            "mapping_index": 5,
            "structured_type": "structured",
            "section_id": "98364d69-7071-47ca-9328-9f9a586aed75",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:44:06.000",
        "event": "mapping_hover",
        "id": "fJh3eYdVyD0JVGp6lgdp"
    },
    {
        "data": {
            "structured_type": "structured",
            "section_id": "98364d69-7071-47ca-9328-9f9a586aed75",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:44:06.000",
        "event": "mapping_unhover",
        "id": "hzcMQGxvADNPykRxPZyn"
    },
    {
        "data": {
            "mapping_index": 5,
            "structured_type": "structured",
            "section_id": "98364d69-7071-47ca-9328-9f9a586aed75",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:44:07.000",
        "event": "mapping_hover",
        "id": "9DHRB1E3EYYRohLT6fiG"
    },
    {
        "data": {
            "structured_type": "structured",
            "section_id": "98364d69-7071-47ca-9328-9f9a586aed75",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:44:07.000",
        "event": "mapping_unhover",
        "id": "ypCp7BqoFwe8QIlWAgrA"
    },
    {
        "data": {
            "structured_type": "structured",
            "section_id": "98364d69-7071-47ca-9328-9f9a586aed75",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:44:08.000",
        "event": "mapping_unhover",
        "id": "cKwAgR4Wv7ofh3stPEwW"
    },
    {
        "data": {
            "structured_type": "structured",
            "section_id": "98364d69-7071-47ca-9328-9f9a586aed75",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:44:09.000",
        "event": "mapping_unhover",
        "id": "4KKIpmlfCUaZa0aFZqmw"
    },
    {
        "data": {
            "mapping_index": 6,
            "structured_type": "structured",
            "section_id": "98364d69-7071-47ca-9328-9f9a586aed75",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:44:09.000",
        "event": "mapping_hover",
        "id": "pqfpzJf7s180kX8DNenI"
    },
    {
        "data": {
            "structured_type": "structured",
            "section_id": "98364d69-7071-47ca-9328-9f9a586aed75",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:44:10.000",
        "event": "mapping_unhover",
        "id": "0MupcEJyAVSc7i5Tkalh"
    },
    {
        "data": {
            "mapping_index": 6,
            "structured_type": "structured",
            "section_id": "98364d69-7071-47ca-9328-9f9a586aed75",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:44:10.000",
        "event": "mapping_hover",
        "id": "CxAAO1xgmohv3RMhB960"
    },
    {
        "data": {
            "mapping_index": 7,
            "structured_type": "structured",
            "section_id": "98364d69-7071-47ca-9328-9f9a586aed75",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:44:10.000",
        "event": "mapping_hover",
        "id": "wFKdKGFUJDGpgIGyCNlN"
    },
    {
        "data": {
            "structured_type": "structured",
            "section_id": "98364d69-7071-47ca-9328-9f9a586aed75",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:44:10.000",
        "event": "mapping_unhover",
        "id": "xUFjljBNgPWp4JVnOG8n"
    },
    {
        "data": {
            "mapping_index": 6,
            "structured_type": "structured",
            "section_id": "98364d69-7071-47ca-9328-9f9a586aed75",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:44:10.000",
        "event": "mapping_hover",
        "id": "zt7Yvdier8k7YVb3nSAh"
    },
    {
        "data": {
            "mapping_index": 7,
            "structured_type": "structured",
            "section_id": "98364d69-7071-47ca-9328-9f9a586aed75",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:44:12.000",
        "event": "mapping_hover",
        "id": "CIAtfs1ysHKZkyQfewCK"
    },
    {
        "data": {
            "structured_type": "structured",
            "section_id": "98364d69-7071-47ca-9328-9f9a586aed75",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:44:12.000",
        "event": "mapping_unhover",
        "id": "nrm11Pm7dPmpaMTCWbse"
    },
    {
        "data": {
            "structured_type": "structured",
            "section_id": "98364d69-7071-47ca-9328-9f9a586aed75",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:44:12.000",
        "event": "mapping_unhover",
        "id": "yFianypGx0PXdBTDVIZa"
    },
    {
        "data": {
            "mapping_index": 8,
            "structured_type": "structured",
            "section_id": "98364d69-7071-47ca-9328-9f9a586aed75",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:44:13.000",
        "event": "mapping_hover",
        "id": "GmlJXpGRux14Z0RdbhZ1"
    },
    {
        "data": {
            "structured_type": "structured",
            "section_id": "98364d69-7071-47ca-9328-9f9a586aed75",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:44:13.000",
        "event": "mapping_unhover",
        "id": "RcOIzrZ9BVb5yjnR7zc8"
    },
    {
        "data": {
            "mapping_index": 7,
            "structured_type": "structured",
            "section_id": "98364d69-7071-47ca-9328-9f9a586aed75",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:44:13.000",
        "event": "mapping_hover",
        "id": "n95L26ZeUwcwBVcvRD2z"
    },
    {
        "data": {
            "mapping_index": 11,
            "structured_type": "structured",
            "section_id": "98364d69-7071-47ca-9328-9f9a586aed75",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:44:15.000",
        "event": "mapping_hover",
        "id": "5oDZua0XCsBtBLwchrSN"
    },
    {
        "data": {
            "mapping_index": 9,
            "structured_type": "structured",
            "section_id": "98364d69-7071-47ca-9328-9f9a586aed75",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:44:15.000",
        "event": "mapping_hover",
        "id": "MxZu2IUjB2t3ZJJECete"
    },
    {
        "data": {
            "structured_type": "structured",
            "section_id": "98364d69-7071-47ca-9328-9f9a586aed75",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:44:15.000",
        "event": "mapping_unhover",
        "id": "OEOC40paMC89Oq8oalaJ"
    },
    {
        "data": {
            "structured_type": "structured",
            "section_id": "98364d69-7071-47ca-9328-9f9a586aed75",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:44:15.000",
        "event": "mapping_unhover",
        "id": "fvLzRhtWe6P17HR6Qgn6"
    },
    {
        "data": {
            "structured_type": "structured",
            "section_id": "98364d69-7071-47ca-9328-9f9a586aed75",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:44:15.000",
        "event": "mapping_unhover",
        "id": "lNReZ7HjnUWnYpjrkJhC"
    },
    {
        "data": {
            "mapping_index": 10,
            "structured_type": "structured",
            "section_id": "98364d69-7071-47ca-9328-9f9a586aed75",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:44:15.000",
        "event": "mapping_hover",
        "id": "v6MNF844GHN9GdJV3F5B"
    },
    {
        "data": {
            "structured_type": "structured",
            "section_id": "98364d69-7071-47ca-9328-9f9a586aed75",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:44:16.000",
        "event": "mapping_unhover",
        "id": "QNzI3WPpuV2UdV3qhIP8"
    },
    {
        "data": {
            "structured_type": "structured",
            "section_id": "98364d69-7071-47ca-9328-9f9a586aed75",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:44:17.000",
        "event": "mapping_unhover",
        "id": "kb4pvPoDg0YcIGRsYFgB"
    },
    {
        "data": {
            "mapping_index": 9,
            "structured_type": "structured",
            "section_id": "98364d69-7071-47ca-9328-9f9a586aed75",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:44:17.000",
        "event": "mapping_hover",
        "id": "wh3ZcZtw3ZNfTx0e4iXo"
    },
    {
        "data": {
            "mapping_index": 6,
            "structured_type": "structured",
            "section_id": "98364d69-7071-47ca-9328-9f9a586aed75",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:44:18.000",
        "event": "mapping_hover",
        "id": "4hq2zwkukJEqcBZzsgU2"
    },
    {
        "data": {
            "structured_type": "structured",
            "section_id": "98364d69-7071-47ca-9328-9f9a586aed75",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:44:18.000",
        "event": "mapping_unhover",
        "id": "9k4XqGem0qz6Gg7wDHTt"
    },
    {
        "data": {
            "mapping_index": 8,
            "structured_type": "structured",
            "section_id": "98364d69-7071-47ca-9328-9f9a586aed75",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:44:18.000",
        "event": "mapping_hover",
        "id": "BWeihj2ixHmoDXyJc2sF"
    },
    {
        "data": {
            "structured_type": "structured",
            "section_id": "98364d69-7071-47ca-9328-9f9a586aed75",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:44:18.000",
        "event": "mapping_unhover",
        "id": "bbb5C4Cr5p1HyQHX5txw"
    },
    {
        "data": {
            "mapping_index": 9,
            "structured_type": "structured",
            "section_id": "98364d69-7071-47ca-9328-9f9a586aed75",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:44:18.000",
        "event": "mapping_hover",
        "id": "iLL4JtB0tzGru1GMofC5"
    },
    {
        "data": {
            "structured_type": "structured",
            "section_id": "98364d69-7071-47ca-9328-9f9a586aed75",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:44:18.000",
        "event": "mapping_unhover",
        "id": "u4QUKSW7vnSuWNV56LJf"
    },
    {
        "data": {
            "structured_type": "structured",
            "section_id": "98364d69-7071-47ca-9328-9f9a586aed75",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:44:18.000",
        "event": "mapping_unhover",
        "id": "w7YhHzMrRLflyCVfFF4E"
    },
    {
        "data": {
            "mapping_index": 7,
            "structured_type": "structured",
            "section_id": "98364d69-7071-47ca-9328-9f9a586aed75",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:44:18.000",
        "event": "mapping_hover",
        "id": "yfroeAK0MyaEnvwvnCKs"
    },
    {
        "data": {
            "structured_type": "structured",
            "section_id": "98364d69-7071-47ca-9328-9f9a586aed75",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:44:29.000",
        "event": "mapping_unhover",
        "id": "4AAEe81noUlSIo4t7p1h"
    },
    {
        "data": {
            "mapping_index": 10,
            "structured_type": "structured",
            "section_id": "98364d69-7071-47ca-9328-9f9a586aed75",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:44:29.000",
        "event": "mapping_hover",
        "id": "4Ea4X3667jGvjhZ4BfJ3"
    },
    {
        "data": {
            "mapping_index": 10,
            "structured_type": "structured",
            "section_id": "98364d69-7071-47ca-9328-9f9a586aed75",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:44:29.000",
        "event": "mapping_hover",
        "id": "rONIZX3awlSKXVNTgKuu"
    },
    {
        "data": {
            "mapping_index": 9,
            "structured_type": "structured",
            "section_id": "98364d69-7071-47ca-9328-9f9a586aed75",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:44:30.000",
        "event": "mapping_hover",
        "id": "FVCsQPheVuII2OsLtWPN"
    },
    {
        "data": {
            "structured_type": "structured",
            "section_id": "98364d69-7071-47ca-9328-9f9a586aed75",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:44:30.000",
        "event": "mapping_unhover",
        "id": "UoO1OBKkMuWLkLpuhyqV"
    },
    {
        "data": {
            "structured_type": "structured",
            "section_id": "98364d69-7071-47ca-9328-9f9a586aed75",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:44:30.000",
        "event": "mapping_unhover",
        "id": "mf2IHKpVJZXA7Jx2gLVW"
    },
    {
        "data": {
            "structured_type": "structured",
            "section_id": "98364d69-7071-47ca-9328-9f9a586aed75",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:44:34.000",
        "event": "mapping_unhover",
        "id": "KRQ3FRIF9fw2caqU3YpV"
    },
    {
        "data": {
            "mapping_index": 6,
            "structured_type": "structured",
            "section_id": "98364d69-7071-47ca-9328-9f9a586aed75",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:44:34.000",
        "event": "mapping_hover",
        "id": "Ope6fOp7sEXRSFqYI079"
    },
    {
        "data": {
            "structured_type": "structured",
            "section_id": "98364d69-7071-47ca-9328-9f9a586aed75",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:44:34.000",
        "event": "mapping_unhover",
        "id": "ncl5wNx038hibOEJEUWF"
    },
    {
        "data": {
            "mapping_index": 7,
            "structured_type": "structured",
            "section_id": "98364d69-7071-47ca-9328-9f9a586aed75",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:44:34.000",
        "event": "mapping_hover",
        "id": "tJtxzfpI4Qb2qcHUkgWB"
    },
    {
        "data": {
            "mapping_index": 10,
            "structured_type": "structured",
            "section_id": "98364d69-7071-47ca-9328-9f9a586aed75",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:44:35.000",
        "event": "mapping_hover",
        "id": "HiRFpVz3gHKekjnFf9bo"
    },
    {
        "data": {
            "structured_type": "structured",
            "section_id": "98364d69-7071-47ca-9328-9f9a586aed75",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:44:35.000",
        "event": "mapping_unhover",
        "id": "KQTgXlLdArjRS9XHqlZ6"
    },
    {
        "data": {
            "structured_type": "structured",
            "section_id": "98364d69-7071-47ca-9328-9f9a586aed75",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:44:35.000",
        "event": "mapping_unhover",
        "id": "L9JLRUmE3YTOLVuT9Izl"
    },
    {
        "data": {
            "mapping_index": 7,
            "structured_type": "structured",
            "section_id": "98364d69-7071-47ca-9328-9f9a586aed75",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:44:35.000",
        "event": "mapping_hover",
        "id": "MViOObVgyAWRBtRifOO6"
    },
    {
        "data": {
            "structured_type": "structured",
            "section_id": "98364d69-7071-47ca-9328-9f9a586aed75",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:44:35.000",
        "event": "mapping_unhover",
        "id": "Wu06BRaI3PEUpiYkXiCy"
    },
    {
        "data": {
            "mapping_index": 8,
            "structured_type": "structured",
            "section_id": "98364d69-7071-47ca-9328-9f9a586aed75",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:44:35.000",
        "event": "mapping_hover",
        "id": "bdB7LeTaZfXRjn7SyPRj"
    },
    {
        "data": {
            "mapping_index": 11,
            "structured_type": "structured",
            "section_id": "98364d69-7071-47ca-9328-9f9a586aed75",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:44:35.000",
        "event": "mapping_hover",
        "id": "fn1kLwnZNVHdhVI0diKW"
    },
    {
        "data": {
            "structured_type": "structured",
            "section_id": "98364d69-7071-47ca-9328-9f9a586aed75",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:44:35.000",
        "event": "mapping_unhover",
        "id": "nRj6h6EFstYDqxsZvjMn"
    },
    {
        "data": {
            "mapping_index": 9,
            "structured_type": "structured",
            "section_id": "98364d69-7071-47ca-9328-9f9a586aed75",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:44:35.000",
        "event": "mapping_hover",
        "id": "vHnYpU659llYpLXiv47M"
    },
    {
        "data": {
            "structured_type": "structured",
            "section_id": "98364d69-7071-47ca-9328-9f9a586aed75",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:44:36.000",
        "event": "mapping_unhover",
        "id": "PqO5KlldT6mgXxht39n9"
    },
    {
        "data": {
            "structured_type": "structured",
            "section_id": "98364d69-7071-47ca-9328-9f9a586aed75",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:44:43.000",
        "event": "mapping_unhover",
        "id": "R7pT3jgqCSjhaAtF4iqF"
    },
    {
        "data": {
            "mapping_index": 10,
            "structured_type": "structured",
            "section_id": "98364d69-7071-47ca-9328-9f9a586aed75",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:44:43.000",
        "event": "mapping_hover",
        "id": "bO64NL0GmERb0aSQlqh3"
    },
    {
        "data": {
            "structured_type": "structured",
            "section_id": "98364d69-7071-47ca-9328-9f9a586aed75",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:44:43.000",
        "event": "mapping_unhover",
        "id": "dp7fGwosYsQFtBWJVoZP"
    },
    {
        "data": {
            "mapping_index": 9,
            "structured_type": "structured",
            "section_id": "98364d69-7071-47ca-9328-9f9a586aed75",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:44:43.000",
        "event": "mapping_hover",
        "id": "rFqwNkB4S6lExNdo77g6"
    },
    {
        "data": {
            "mapping_index": 8,
            "structured_type": "structured",
            "section_id": "98364d69-7071-47ca-9328-9f9a586aed75",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:44:43.000",
        "event": "mapping_hover",
        "id": "xq1CVJyY9kpX1SYRlOE9"
    },
    {
        "data": {
            "structured_type": "structured",
            "section_id": "98364d69-7071-47ca-9328-9f9a586aed75",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:44:44.000",
        "event": "mapping_unhover",
        "id": "8akOQr6pPU79HbVIKd4E"
    },
    {
        "data": {
            "mapping_index": 11,
            "structured_type": "structured",
            "section_id": "98364d69-7071-47ca-9328-9f9a586aed75",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:44:44.000",
        "event": "mapping_hover",
        "id": "xp05cUSXCgQVd9HpjlQd"
    },
    {
        "data": {
            "structured_type": "structured",
            "section_id": "98364d69-7071-47ca-9328-9f9a586aed75",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:44:45.000",
        "event": "mapping_unhover",
        "id": "chXJK2ukfEF5HWySD3Id"
    },
    {
        "data": {
            "structured_type": "structured",
            "section_id": "98364d69-7071-47ca-9328-9f9a586aed75",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:44:48.000",
        "event": "mapping_unhover",
        "id": "AscZahHxniqaeQEHnjQy"
    },
    {
        "data": {
            "structured_type": "structured",
            "section_id": "98364d69-7071-47ca-9328-9f9a586aed75",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:44:48.000",
        "event": "mapping_unhover",
        "id": "UN6q9NdztNmoFNCE1tHV"
    },
    {
        "data": {
            "mapping_index": 9,
            "structured_type": "structured",
            "section_id": "98364d69-7071-47ca-9328-9f9a586aed75",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:44:48.000",
        "event": "mapping_hover",
        "id": "W1f5k70aK6jlyix5Tj0b"
    },
    {
        "data": {
            "mapping_index": 10,
            "structured_type": "structured",
            "section_id": "98364d69-7071-47ca-9328-9f9a586aed75",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:44:48.000",
        "event": "mapping_hover",
        "id": "uTstD3ltJQVdcCvLht56"
    },
    {
        "data": {
            "mapping_index": 11,
            "structured_type": "structured",
            "section_id": "98364d69-7071-47ca-9328-9f9a586aed75",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:44:48.000",
        "event": "mapping_hover",
        "id": "ymGVS1ahcn2DXaZSq6w5"
    },
    {
        "data": {
            "structured_type": "structured",
            "section_id": "98364d69-7071-47ca-9328-9f9a586aed75",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:44:49.000",
        "event": "mapping_unhover",
        "id": "91EcIeZMgcERPN9BnXWr"
    },
    {
        "data": {
            "structured_type": "structured",
            "section_id": "98364d69-7071-47ca-9328-9f9a586aed75",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:44:49.000",
        "event": "mapping_unhover",
        "id": "KaeNkNjI7Tb9vldYYx3s"
    },
    {
        "data": {
            "mapping_index": 5,
            "structured_type": "structured",
            "section_id": "98364d69-7071-47ca-9328-9f9a586aed75",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:44:49.000",
        "event": "mapping_hover",
        "id": "XBHK7PBthTrc7xjQUZcA"
    },
    {
        "data": {
            "structured_type": "structured",
            "section_id": "98364d69-7071-47ca-9328-9f9a586aed75",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:44:49.000",
        "event": "mapping_unhover",
        "id": "asG8lHgKDSR6wfJUYkUc"
    },
    {
        "data": {
            "mapping_index": 10,
            "structured_type": "structured",
            "section_id": "98364d69-7071-47ca-9328-9f9a586aed75",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:44:49.000",
        "event": "mapping_hover",
        "id": "diqqO1nbCog4nlvHwwzv"
    },
    {
        "data": {
            "mapping_index": 8,
            "structured_type": "structured",
            "section_id": "98364d69-7071-47ca-9328-9f9a586aed75",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:44:49.000",
        "event": "mapping_hover",
        "id": "lbOU5m1ZWLI8SCyqtJjY"
    },
    {
        "data": {
            "structured_type": "structured",
            "section_id": "98364d69-7071-47ca-9328-9f9a586aed75",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:44:49.000",
        "event": "mapping_unhover",
        "id": "t9dlEoenpt4QtgO8yEs0"
    },
    {
        "data": {
            "structured_type": "structured",
            "section_id": "98364d69-7071-47ca-9328-9f9a586aed75",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:44:58.000",
        "event": "mapping_unhover",
        "id": "BswR9797YCg6yI30leBa"
    },
    {
        "data": {
            "mapping_index": 12,
            "structured_type": "structured",
            "section_id": "98364d69-7071-47ca-9328-9f9a586aed75",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:44:58.000",
        "event": "mapping_hover",
        "id": "PZN9miZSq5h1ojNbWPCi"
    },
    {
        "data": {
            "structured_type": "structured",
            "section_id": "98364d69-7071-47ca-9328-9f9a586aed75",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:44:59.000",
        "event": "mapping_unhover",
        "id": "2xPbVI3wA4Kfzn5og0lI"
    },
    {
        "data": {
            "mapping_index": 10,
            "structured_type": "structured",
            "section_id": "98364d69-7071-47ca-9328-9f9a586aed75",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:44:59.000",
        "event": "mapping_hover",
        "id": "FiKZRU780idIzQmAzFIi"
    },
    {
        "data": {
            "mapping_index": 12,
            "structured_type": "structured",
            "section_id": "98364d69-7071-47ca-9328-9f9a586aed75",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:44:59.000",
        "event": "mapping_hover",
        "id": "J1dRkmQttFNbtCnBwJp5"
    },
    {
        "data": {
            "structured_type": "structured",
            "section_id": "98364d69-7071-47ca-9328-9f9a586aed75",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:44:59.000",
        "event": "mapping_unhover",
        "id": "NzoTvJB9XZMzOeHRFlvr"
    },
    {
        "data": {
            "structured_type": "structured",
            "section_id": "98364d69-7071-47ca-9328-9f9a586aed75",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:44:59.000",
        "event": "mapping_unhover",
        "id": "WR3byZhdCRL3BR9aWjrV"
    },
    {
        "data": {
            "structured_type": "structured",
            "section_id": "98364d69-7071-47ca-9328-9f9a586aed75",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:44:59.000",
        "event": "mapping_unhover",
        "id": "XbYCMEEOQX4CSvQTmqzL"
    },
    {
        "data": {
            "mapping_index": 9,
            "structured_type": "structured",
            "section_id": "98364d69-7071-47ca-9328-9f9a586aed75",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:44:59.000",
        "event": "mapping_hover",
        "id": "Y1wRrRMeBfhmSpzP1DgN"
    },
    {
        "data": {
            "mapping_index": 11,
            "structured_type": "structured",
            "section_id": "98364d69-7071-47ca-9328-9f9a586aed75",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:44:59.000",
        "event": "mapping_hover",
        "id": "n9aWRwM03a31OYP0UDLv"
    },
    {
        "data": {
            "mapping_index": 2,
            "structured_type": "structured",
            "section_id": "98364d69-7071-47ca-9328-9f9a586aed75",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:45:00.000",
        "event": "mapping_hover",
        "id": "1Qpu7gYf8pZTLXeBVfTM"
    },
    {
        "data": {
            "mapping_index": 1,
            "structured_type": "structured",
            "section_id": "98364d69-7071-47ca-9328-9f9a586aed75",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:45:00.000",
        "event": "mapping_hover",
        "id": "Ue4dsz3ZY9g252EsD7Br"
    },
    {
        "data": {
            "structured_type": "structured",
            "section_id": "98364d69-7071-47ca-9328-9f9a586aed75",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:45:00.000",
        "event": "mapping_unhover",
        "id": "giSrtEAsXmV8pNSyVXVf"
    },
    {
        "data": {
            "structured_type": "structured",
            "section_id": "98364d69-7071-47ca-9328-9f9a586aed75",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:45:00.000",
        "event": "mapping_unhover",
        "id": "hspo4kTrzm6BbUSBbcEI"
    },
    {
        "data": {
            "structured_type": "structured",
            "section_id": "98364d69-7071-47ca-9328-9f9a586aed75",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:45:41.000",
        "event": "mapping_unhover",
        "id": "GkVwVeaZ3vQ2v8s10wfb"
    },
    {
        "data": {
            "mapping_index": 6,
            "structured_type": "structured",
            "section_id": "98364d69-7071-47ca-9328-9f9a586aed75",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:45:41.000",
        "event": "mapping_hover",
        "id": "VHwUkvQWblxMiPGSfJ5P"
    },
    {
        "data": {
            "mapping_index": 5,
            "structured_type": "structured",
            "section_id": "98364d69-7071-47ca-9328-9f9a586aed75",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:45:41.000",
        "event": "mapping_hover",
        "id": "b0GxWKi17Ax0b9mEaCyo"
    },
    {
        "data": {
            "structured_type": "structured",
            "section_id": "98364d69-7071-47ca-9328-9f9a586aed75",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:45:42.000",
        "event": "mapping_unhover",
        "id": "6Iv5198OLae5nVvdgw4Z"
    },
    {
        "data": {
            "structured_type": "structured",
            "section_id": "98364d69-7071-47ca-9328-9f9a586aed75",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:45:42.000",
        "event": "mapping_unhover",
        "id": "D7U3asuZ6PBaQdOh8H2i"
    },
    {
        "data": {
            "mapping_index": 11,
            "structured_type": "structured",
            "section_id": "98364d69-7071-47ca-9328-9f9a586aed75",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:45:42.000",
        "event": "mapping_hover",
        "id": "HiKljvzlTcdcX0iqqFzm"
    },
    {
        "data": {
            "structured_type": "structured",
            "section_id": "98364d69-7071-47ca-9328-9f9a586aed75",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:45:42.000",
        "event": "mapping_unhover",
        "id": "PYeFD2J7tL1ZHmmhWozl"
    },
    {
        "data": {
            "structured_type": "structured",
            "section_id": "98364d69-7071-47ca-9328-9f9a586aed75",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:45:42.000",
        "event": "mapping_unhover",
        "id": "WontYUfAxfGuQkXXv8ZS"
    },
    {
        "data": {
            "mapping_index": 12,
            "structured_type": "structured",
            "section_id": "98364d69-7071-47ca-9328-9f9a586aed75",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:45:42.000",
        "event": "mapping_hover",
        "id": "Xcn5Vb6nxkUJbcIzuFpH"
    },
    {
        "data": {
            "mapping_index": 10,
            "structured_type": "structured",
            "section_id": "98364d69-7071-47ca-9328-9f9a586aed75",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:45:42.000",
        "event": "mapping_hover",
        "id": "q0QpSGfvkxgCGHYdHcE0"
    },
    {
        "data": {
            "mapping_index": 12,
            "structured_type": "structured",
            "section_id": "98364d69-7071-47ca-9328-9f9a586aed75",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:45:43.000",
        "event": "mapping_hover",
        "id": "nVoTEpJqat4M5nsAtQ1H"
    },
    {
        "data": {
            "mapping_index": 11,
            "structured_type": "structured",
            "section_id": "98364d69-7071-47ca-9328-9f9a586aed75",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:45:43.000",
        "event": "mapping_hover",
        "id": "s9wMc70s7QSA3fWai4BM"
    },
    {
        "data": {
            "structured_type": "structured",
            "section_id": "98364d69-7071-47ca-9328-9f9a586aed75",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:45:43.000",
        "event": "mapping_unhover",
        "id": "xhs6AGQvhefpTedl4RFo"
    },
    {
        "data": {
            "structured_type": "structured",
            "section_id": "98364d69-7071-47ca-9328-9f9a586aed75",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:45:43.000",
        "event": "mapping_unhover",
        "id": "zyNkrPzDb1cjDd02Noqa"
    },
    {
        "data": {
            "mapping_index": 8,
            "structured_type": "structured",
            "section_id": "98364d69-7071-47ca-9328-9f9a586aed75",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:45:46.000",
        "event": "mapping_hover",
        "id": "tllmWhOPvxYhQQuTKB4X"
    },
    {
        "data": {
            "structured_type": "structured",
            "section_id": "98364d69-7071-47ca-9328-9f9a586aed75",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:45:47.000",
        "event": "mapping_unhover",
        "id": "JW1nKBMRIq9aJPo472H5"
    },
    {
        "data": {
            "structured_type": "structured",
            "section_id": "98364d69-7071-47ca-9328-9f9a586aed75",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:45:47.000",
        "event": "mapping_unhover",
        "id": "Qfa9HysdDY3EXoITSOou"
    },
    {
        "data": {
            "mapping_index": 11,
            "structured_type": "structured",
            "section_id": "98364d69-7071-47ca-9328-9f9a586aed75",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:45:47.000",
        "event": "mapping_hover",
        "id": "V9r772wX3jFCXoONEOOl"
    },
    {
        "data": {
            "mapping_index": 10,
            "structured_type": "structured",
            "section_id": "98364d69-7071-47ca-9328-9f9a586aed75",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:45:47.000",
        "event": "mapping_hover",
        "id": "abaCGgHfRmnWBpCsPa8g"
    },
    {
        "data": {
            "structured_type": "structured",
            "section_id": "98364d69-7071-47ca-9328-9f9a586aed75",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:45:47.000",
        "event": "mapping_unhover",
        "id": "c9KN6X3wV2LvXDujW3od"
    },
    {
        "data": {
            "mapping_index": 9,
            "structured_type": "structured",
            "section_id": "98364d69-7071-47ca-9328-9f9a586aed75",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:45:47.000",
        "event": "mapping_hover",
        "id": "xUGbA7v6qcErrCwCcjFn"
    },
    {
        "data": {
            "structured_type": "structured",
            "section_id": "98364d69-7071-47ca-9328-9f9a586aed75",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:45:47.000",
        "event": "mapping_unhover",
        "id": "yqcYPl6Eo56ey26wY67M"
    },
    {
        "data": {
            "mapping_index": 9,
            "structured_type": "structured",
            "section_id": "98364d69-7071-47ca-9328-9f9a586aed75",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:45:48.000",
        "event": "mapping_hover",
        "id": "FSg0n0ldlRIkyauBgzTt"
    },
    {
        "data": {
            "structured_type": "structured",
            "section_id": "98364d69-7071-47ca-9328-9f9a586aed75",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:45:48.000",
        "event": "mapping_unhover",
        "id": "byG6H46SuaTTU2tOdwS8"
    },
    {
        "data": {
            "mapping_index": 11,
            "structured_type": "structured",
            "section_id": "98364d69-7071-47ca-9328-9f9a586aed75",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:45:48.000",
        "event": "mapping_hover",
        "id": "ctRCpN11gvwu1JTOG7aA"
    },
    {
        "data": {
            "mapping_index": 10,
            "structured_type": "structured",
            "section_id": "98364d69-7071-47ca-9328-9f9a586aed75",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:45:48.000",
        "event": "mapping_hover",
        "id": "m1WBch5G9VukanTuwKvv"
    },
    {
        "data": {
            "structured_type": "structured",
            "section_id": "98364d69-7071-47ca-9328-9f9a586aed75",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:45:48.000",
        "event": "mapping_unhover",
        "id": "mHu5RTNLFjpBbGCkBNht"
    },
    {
        "data": {
            "mapping_index": 8,
            "structured_type": "structured",
            "section_id": "98364d69-7071-47ca-9328-9f9a586aed75",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:45:49.000",
        "event": "mapping_hover",
        "id": "3SXTrGHSfnaWOwOAwrDv"
    },
    {
        "data": {
            "structured_type": "structured",
            "section_id": "98364d69-7071-47ca-9328-9f9a586aed75",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:45:49.000",
        "event": "mapping_unhover",
        "id": "F0xRs3Pxf33YcbWnCChb"
    },
    {
        "data": {
            "structured_type": "structured",
            "section_id": "98364d69-7071-47ca-9328-9f9a586aed75",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:45:50.000",
        "event": "mapping_unhover",
        "id": "5H30FfO19G0zvYQ7aZJo"
    },
    {
        "data": {
            "mapping_index": 11,
            "structured_type": "structured",
            "section_id": "98364d69-7071-47ca-9328-9f9a586aed75",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:45:50.000",
        "event": "mapping_hover",
        "id": "5rmBB1VEnOaaBb1uEc8O"
    },
    {
        "data": {
            "mapping_index": 10,
            "structured_type": "structured",
            "section_id": "98364d69-7071-47ca-9328-9f9a586aed75",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:45:50.000",
        "event": "mapping_hover",
        "id": "7wmqTIPI57jYKfEmF7pa"
    },
    {
        "data": {
            "structured_type": "structured",
            "section_id": "98364d69-7071-47ca-9328-9f9a586aed75",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:45:50.000",
        "event": "mapping_unhover",
        "id": "K9P2e7HZCL85vp2QrpI6"
    },
    {
        "data": {
            "mapping_index": 10,
            "structured_type": "structured",
            "section_id": "98364d69-7071-47ca-9328-9f9a586aed75",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:45:50.000",
        "event": "mapping_hover",
        "id": "U1BpgofZtKARNEOGR5j9"
    },
    {
        "data": {
            "structured_type": "structured",
            "section_id": "98364d69-7071-47ca-9328-9f9a586aed75",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:45:50.000",
        "event": "mapping_unhover",
        "id": "WZ3mvisLH48EY73UWRQV"
    },
    {
        "data": {
            "structured_type": "structured",
            "section_id": "98364d69-7071-47ca-9328-9f9a586aed75",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:45:50.000",
        "event": "mapping_unhover",
        "id": "geJPzVpzwiIq2TBjgovJ"
    },
    {
        "data": {
            "structured_type": "structured",
            "section_id": "98364d69-7071-47ca-9328-9f9a586aed75",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:45:50.000",
        "event": "mapping_unhover",
        "id": "op9meyyir8l8XZdsYU5X"
    },
    {
        "data": {
            "mapping_index": 9,
            "structured_type": "structured",
            "section_id": "98364d69-7071-47ca-9328-9f9a586aed75",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:45:50.000",
        "event": "mapping_hover",
        "id": "t0TnNIj048nJ0cmrMWqS"
    },
    {
        "data": {
            "structured_type": "structured",
            "section_id": "98364d69-7071-47ca-9328-9f9a586aed75",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:45:51.000",
        "event": "mapping_unhover",
        "id": "Hq2ppe9O1ME3zCzpQEWN"
    },
    {
        "data": {
            "structured_type": "structured",
            "section_id": "98364d69-7071-47ca-9328-9f9a586aed75",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:45:51.000",
        "event": "mapping_unhover",
        "id": "KOnn2YKkk63MYGuGmF27"
    },
    {
        "data": {
            "mapping_index": 9,
            "structured_type": "structured",
            "section_id": "98364d69-7071-47ca-9328-9f9a586aed75",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:45:51.000",
        "event": "mapping_hover",
        "id": "TSVldEFfaOOXtGTPfwev"
    },
    {
        "data": {
            "mapping_index": 12,
            "structured_type": "structured",
            "section_id": "98364d69-7071-47ca-9328-9f9a586aed75",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:45:51.000",
        "event": "mapping_hover",
        "id": "Tl393ilsxqGvZwVpJiSq"
    },
    {
        "data": {
            "mapping_index": 10,
            "structured_type": "structured",
            "section_id": "98364d69-7071-47ca-9328-9f9a586aed75",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:45:51.000",
        "event": "mapping_hover",
        "id": "hpnN3X5UeuYE1mijra0W"
    },
    {
        "data": {
            "mapping_index": 11,
            "structured_type": "structured",
            "section_id": "98364d69-7071-47ca-9328-9f9a586aed75",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:45:51.000",
        "event": "mapping_hover",
        "id": "kmuEQkgiBNPj9m8N8eHh"
    },
    {
        "data": {
            "structured_type": "structured",
            "section_id": "98364d69-7071-47ca-9328-9f9a586aed75",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:45:51.000",
        "event": "mapping_unhover",
        "id": "queQrvjjjHdS6qyOWiAz"
    },
    {
        "data": {
            "structured_type": "structured",
            "section_id": "98364d69-7071-47ca-9328-9f9a586aed75",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:45:53.000",
        "event": "mapping_unhover",
        "id": "1RNXSBYbVKLDTF5rSxhm"
    },
    {
        "data": {
            "structured_type": "structured",
            "section_id": "98364d69-7071-47ca-9328-9f9a586aed75",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:45:53.000",
        "event": "mapping_unhover",
        "id": "Rz9eL3g5x2AxSD7W82AW"
    },
    {
        "data": {
            "mapping_index": 11,
            "structured_type": "structured",
            "section_id": "98364d69-7071-47ca-9328-9f9a586aed75",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:45:53.000",
        "event": "mapping_hover",
        "id": "ZYvevLOgTQJ9fV8T5Ywa"
    },
    {
        "data": {
            "structured_type": "structured",
            "section_id": "98364d69-7071-47ca-9328-9f9a586aed75",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:45:54.000",
        "event": "mapping_unhover",
        "id": "1MkCfRRvbgf82QYeFW8E"
    },
    {
        "data": {
            "structured_type": "structured",
            "section_id": "98364d69-7071-47ca-9328-9f9a586aed75",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:45:54.000",
        "event": "mapping_unhover",
        "id": "95fZt6ZA4ep0XSG5EMFB"
    },
    {
        "data": {
            "mapping_index": 12,
            "structured_type": "structured",
            "section_id": "98364d69-7071-47ca-9328-9f9a586aed75",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:45:54.000",
        "event": "mapping_hover",
        "id": "CFSf9iWzg8YvH5e5xbN7"
    },
    {
        "data": {
            "mapping_index": 10,
            "structured_type": "structured",
            "section_id": "98364d69-7071-47ca-9328-9f9a586aed75",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:45:54.000",
        "event": "mapping_hover",
        "id": "IlmGETTNGhs4477Y6S22"
    },
    {
        "data": {
            "structured_type": "structured",
            "section_id": "98364d69-7071-47ca-9328-9f9a586aed75",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:45:54.000",
        "event": "mapping_unhover",
        "id": "JpgGj6NIO266YQXIjbdw"
    },
    {
        "data": {
            "structured_type": "structured",
            "section_id": "98364d69-7071-47ca-9328-9f9a586aed75",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:45:54.000",
        "event": "mapping_unhover",
        "id": "lC5FQMD6Jq1DvdUmFUIb"
    },
    {
        "data": {
            "mapping_index": 9,
            "structured_type": "structured",
            "section_id": "98364d69-7071-47ca-9328-9f9a586aed75",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:45:54.000",
        "event": "mapping_hover",
        "id": "oBcHmf0H7hDP94UfIuQ8"
    },
    {
        "data": {
            "mapping_index": 11,
            "structured_type": "structured",
            "section_id": "98364d69-7071-47ca-9328-9f9a586aed75",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:45:54.000",
        "event": "mapping_hover",
        "id": "pjFcZiuEfEzgBTxpOATg"
    },
    {
        "data": {
            "mapping_index": 7,
            "structured_type": "structured",
            "section_id": "98364d69-7071-47ca-9328-9f9a586aed75",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:46:44.000",
        "event": "mapping_hover",
        "id": "33sTwh7OeBvcWnfX0lnc"
    },
    {
        "data": {
            "mapping_index": 8,
            "structured_type": "structured",
            "section_id": "98364d69-7071-47ca-9328-9f9a586aed75",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:46:44.000",
        "event": "mapping_hover",
        "id": "5tp1bDYobc9GNhKKZmo2"
    },
    {
        "data": {
            "structured_type": "structured",
            "section_id": "98364d69-7071-47ca-9328-9f9a586aed75",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:46:44.000",
        "event": "mapping_unhover",
        "id": "7lgtlHZeWdMGLrua0qfo"
    },
    {
        "data": {
            "mapping_index": 3,
            "structured_type": "structured",
            "section_id": "98364d69-7071-47ca-9328-9f9a586aed75",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:46:44.000",
        "event": "mapping_hover",
        "id": "820TJ5PAwrPazj8NldXu"
    },
    {
        "data": {
            "mapping_index": 2,
            "structured_type": "structured",
            "section_id": "98364d69-7071-47ca-9328-9f9a586aed75",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:46:44.000",
        "event": "mapping_hover",
        "id": "BgDuW53jKbOT2n4wwDXC"
    },
    {
        "data": {
            "mapping_index": 11,
            "structured_type": "structured",
            "section_id": "98364d69-7071-47ca-9328-9f9a586aed75",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:46:44.000",
        "event": "mapping_hover",
        "id": "BmpGEDs9O3piiNKjOow5"
    },
    {
        "data": {
            "structured_type": "structured",
            "section_id": "98364d69-7071-47ca-9328-9f9a586aed75",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:46:44.000",
        "event": "mapping_unhover",
        "id": "Cd4TKPUsrUYx8Wsqhj3o"
    },
    {
        "data": {
            "structured_type": "structured",
            "section_id": "98364d69-7071-47ca-9328-9f9a586aed75",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:46:44.000",
        "event": "mapping_unhover",
        "id": "ChUYKKEBqtYRbOh8EJcq"
    },
    {
        "data": {
            "structured_type": "structured",
            "section_id": "98364d69-7071-47ca-9328-9f9a586aed75",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:46:44.000",
        "event": "mapping_unhover",
        "id": "PLpFr6vOeA4AxZgtCfGT"
    },
    {
        "data": {
            "mapping_index": 4,
            "structured_type": "structured",
            "section_id": "98364d69-7071-47ca-9328-9f9a586aed75",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:46:44.000",
        "event": "mapping_hover",
        "id": "RijN9w0AyvmYqBeEtPUO"
    },
    {
        "data": {
            "structured_type": "structured",
            "section_id": "98364d69-7071-47ca-9328-9f9a586aed75",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:46:44.000",
        "event": "mapping_unhover",
        "id": "hdMsg79agSmc7AqBaTkA"
    },
    {
        "data": {
            "structured_type": "structured",
            "section_id": "98364d69-7071-47ca-9328-9f9a586aed75",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:46:45.000",
        "event": "mapping_unhover",
        "id": "a9vw4KXtVPV51Hc25Hm2"
    },
    {
        "data": {},
        "source": "frontend",
        "timestamp": "2025-08-23 10:46:57.000",
        "event": "click_summarize_code",
        "id": "geWJKTwpgaRWXrh92o0I"
    },
    {
        "data": {
            "selected_code": "def main():\n    X, y, group, df = load_data()\n\n    # Train-test split on years\n    unique_years = df[\"Year\"].unique()\n    train_years, test_years = (\n        unique_years[:-2],  # train: 2015-2023\n        unique_years[-2:],  # test: 2024-2025\n    )\n\n    train_idx = df[\"Year\"].isin(train_years)\n    test_idx = df[\"Year\"].isin(test_years)\n\n    X_train, X_test = X[train_idx], X[test_idx]\n    y_train, y_test = y[train_idx], y[test_idx]\n\n    # Group sizes\n    train_groups = df[train_idx].groupby(\"Year\").size().to_numpy()\n    test_groups = df[test_idx].groupby(\"Year\").size().to_numpy()\n\n    # Model\n    model = XGBRanker(\n        objective=\"rank:pairwise\",\n        learning_rate=0.1,\n        n_estimators=1000,\n        max_depth=4,\n        random_state=42,\n    )\n\n    print(\"Training XGBoostRanker...\")\n    model.fit(X_train, y_train, group=train_groups)\n\n    # Predict, sort, and evaluate\n    y_pred = model.predict(X_test)\n    df.loc[test_idx, \"PredictedScore\"] = y_pred\n    df.loc[test_idx, \"PredictedRank\"] = (\n        df.loc[test_idx]\n        .groupby(\"Year\")[\"PredictedScore\"]\n        .rank(ascending=False, method=\"first\")\n    )\n\n    ndcg = evaluate_ndcg(y_test.to_numpy(), y_pred, test_groups)\n    print(f\"NDCG Score on test years {test_years.tolist()}: {ndcg:.4f}\")\n\n    # Show results\n    print(df[test_idx][[\"Year\", \"Name\", \"Rank\", \"PredictedScore\", \"PredictedRank\"]])\n    plot_ranking_predictions(df, 2024)\n    plot_ranking_predictions(df, 2025)\n\n",
            "summary": {
                "medium_unstructured": "The main() function loads MVP data, splits it into training and test sets by year, and trains an XGBoost ranking model. It predicts ranks for the test years, evaluates performance using NDCG, and prints the results. Finally, it generates plots to visualize prediction errors for the test years.",
                "low_structured": "• Trains an XGBoost ranking model on MVP data\n• Evaluates and prints results\n• Plots prediction errors for test years",
                "title": "Summary of the main() Function for MVP Ranking Prediction",
                "medium_structured": "• Loads data and splits it into training and test sets by year\n• Trains an XGBoost ranking model on the training data\n• Predicts and evaluates rankings for the test years\n  ◦ Calculates NDCG score for evaluation\n• Prints results and visualizes prediction errors for 2024 and 2025",
                "high_unstructured": "The main() function orchestrates the workflow for training and evaluating an XGBoost ranking model on MVP data. It first loads the data, splits it into training (all but the last two years) and test (the last two years) sets, and prepares group information for ranking. The function then initializes and trains an XGBRanker using the training data and group sizes. After training, it predicts scores for the test set, computes predicted ranks within each year, and evaluates the model's performance using the NDCG metric. Results, including predicted scores and ranks, are printed for the test years, and bar plots are generated to visualize prediction errors for 2024 and 2025.",
                "high_structured": "• Loads MVP data and splits it into features, labels, groups, and the full DataFrame\n• Splits data by year:\n  ◦ Training set: all years except the last two\n  ◦ Test set: last two years (2024, 2025)\n• Prepares training and test indices, and computes group sizes for ranking\n• Initializes an XGBRanker with specific hyperparameters (pairwise ranking, learning rate, estimators, depth, random state)\n• Trains the model on the training set with group information\n• Makes predictions on the test set:\n  ◦ Stores predicted scores\n  ◦ Calculates predicted ranks within each test year\n• Evaluates model performance using the NDCG metric on the test years\n• Prints detailed results for the test years, including true and predicted ranks and scores\n• Generates and saves bar plots of prediction errors for 2024 and 2025",
                "low_unstructured": "This function trains and evaluates an XGBoost ranking model on MVP data, then visualizes and prints the results."
            }
        },
        "source": "backend",
        "timestamp": "2025-08-23 10:47:03.000",
        "event": "summarize_selected_code",
        "id": "D44P8fhJye4OaKAJxSdB"
    },
    {
        "data": {
            "mapping": [
                {
                    "summaryComponent": "Trains an XGBoost ranking model on MVP data",
                    "codeSegments": [
                        {
                            "line": 95,
                            "code": "model = XGBRanker("
                        },
                        {
                            "line": 104,
                            "code": "model.fit(X_train, y_train, group=train_groups)"
                        }
                    ]
                },
                {
                    "summaryComponent": "Evaluates and prints results",
                    "codeSegments": [
                        {
                            "line": 115,
                            "code": "ndcg = evaluate_ndcg(y_test.to_numpy(), y_pred, test_groups)"
                        },
                        {
                            "line": 116,
                            "code": "print(f\"NDCG Score on test years {test_years.tolist()}: {ndcg:.4f}\")"
                        },
                        {
                            "line": 119,
                            "code": "print(df[test_idx][[\"Year\", \"Name\", \"Rank\", \"PredictedScore\", \"PredictedRank\"]])"
                        }
                    ]
                },
                {
                    "summaryComponent": "Plots prediction errors for test years",
                    "codeSegments": [
                        {
                            "line": 120,
                            "code": "plot_ranking_predictions(df, 2024)"
                        },
                        {
                            "line": 121,
                            "code": "plot_ranking_predictions(df, 2025)"
                        }
                    ]
                }
            ],
            "summary": "• Trains an XGBoost ranking model on MVP data\n• Evaluates and prints results\n• Plots prediction errors for test years",
            "code": "74: def main():\n75:     X, y, group, df = load_data()\n76: \n77:     # Train-test split on years\n78:     unique_years = df[\"Year\"].unique()\n79:     train_years, test_years = (\n80:         unique_years[:-2],  # train: 2015-2023\n81:         unique_years[-2:],  # test: 2024-2025\n82:     )\n83: \n84:     train_idx = df[\"Year\"].isin(train_years)\n85:     test_idx = df[\"Year\"].isin(test_years)\n86: \n87:     X_train, X_test = X[train_idx], X[test_idx]\n88:     y_train, y_test = y[train_idx], y[test_idx]\n89: \n90:     # Group sizes\n91:     train_groups = df[train_idx].groupby(\"Year\").size().to_numpy()\n92:     test_groups = df[test_idx].groupby(\"Year\").size().to_numpy()\n93: \n94:     # Model\n95:     model = XGBRanker(\n96:         objective=\"rank:pairwise\",\n97:         learning_rate=0.1,\n98:         n_estimators=1000,\n99:         max_depth=4,\n100:         random_state=42,\n101:     )\n102: \n103:     print(\"Training XGBoostRanker...\")\n104:     model.fit(X_train, y_train, group=train_groups)\n105: \n106:     # Predict, sort, and evaluate\n107:     y_pred = model.predict(X_test)\n108:     df.loc[test_idx, \"PredictedScore\"] = y_pred\n109:     df.loc[test_idx, \"PredictedRank\"] = (\n110:         df.loc[test_idx]\n111:         .groupby(\"Year\")[\"PredictedScore\"]\n112:         .rank(ascending=False, method=\"first\")\n113:     )\n114: \n115:     ndcg = evaluate_ndcg(y_test.to_numpy(), y_pred, test_groups)\n116:     print(f\"NDCG Score on test years {test_years.tolist()}: {ndcg:.4f}\")\n117: \n118:     # Show results\n119:     print(df[test_idx][[\"Year\", \"Name\", \"Rank\", \"PredictedScore\", \"PredictedRank\"]])\n120:     plot_ranking_predictions(df, 2024)\n121:     plot_ranking_predictions(df, 2025)\n122: \n123: "
        },
        "source": "backend",
        "timestamp": "2025-08-23 10:47:05.000",
        "event": "map_summary_code",
        "id": "hNtY3fyEhyiG3l3XPlmr"
    },
    {
        "data": {
            "mapping": [
                {
                    "summaryComponent": "trains",
                    "codeSegments": [
                        {
                            "line": 104,
                            "code": "model.fit(X_train, y_train, group=train_groups)"
                        }
                    ]
                },
                {
                    "summaryComponent": "evaluates",
                    "codeSegments": [
                        {
                            "line": 115,
                            "code": "ndcg = evaluate_ndcg(y_test.to_numpy(), y_pred, test_groups)"
                        }
                    ]
                },
                {
                    "summaryComponent": "an XGBoost ranking model",
                    "codeSegments": [
                        {
                            "line": 95,
                            "code": "model = XGBRanker("
                        }
                    ]
                },
                {
                    "summaryComponent": "on MVP data",
                    "codeSegments": [
                        {
                            "line": 75,
                            "code": "X, y, group, df = load_data()"
                        }
                    ]
                },
                {
                    "summaryComponent": "then visualizes",
                    "codeSegments": [
                        {
                            "line": 120,
                            "code": "plot_ranking_predictions(df, 2024)"
                        },
                        {
                            "line": 121,
                            "code": "plot_ranking_predictions(df, 2025)"
                        }
                    ]
                },
                {
                    "summaryComponent": "and prints the results",
                    "codeSegments": [
                        {
                            "line": 119,
                            "code": "print(df[test_idx][[\"Year\", \"Name\", \"Rank\", \"PredictedScore\", \"PredictedRank\"]])"
                        }
                    ]
                }
            ],
            "summary": "This function trains and evaluates an XGBoost ranking model on MVP data, then visualizes and prints the results.",
            "code": "74: def main():\n75:     X, y, group, df = load_data()\n76: \n77:     # Train-test split on years\n78:     unique_years = df[\"Year\"].unique()\n79:     train_years, test_years = (\n80:         unique_years[:-2],  # train: 2015-2023\n81:         unique_years[-2:],  # test: 2024-2025\n82:     )\n83: \n84:     train_idx = df[\"Year\"].isin(train_years)\n85:     test_idx = df[\"Year\"].isin(test_years)\n86: \n87:     X_train, X_test = X[train_idx], X[test_idx]\n88:     y_train, y_test = y[train_idx], y[test_idx]\n89: \n90:     # Group sizes\n91:     train_groups = df[train_idx].groupby(\"Year\").size().to_numpy()\n92:     test_groups = df[test_idx].groupby(\"Year\").size().to_numpy()\n93: \n94:     # Model\n95:     model = XGBRanker(\n96:         objective=\"rank:pairwise\",\n97:         learning_rate=0.1,\n98:         n_estimators=1000,\n99:         max_depth=4,\n100:         random_state=42,\n101:     )\n102: \n103:     print(\"Training XGBoostRanker...\")\n104:     model.fit(X_train, y_train, group=train_groups)\n105: \n106:     # Predict, sort, and evaluate\n107:     y_pred = model.predict(X_test)\n108:     df.loc[test_idx, \"PredictedScore\"] = y_pred\n109:     df.loc[test_idx, \"PredictedRank\"] = (\n110:         df.loc[test_idx]\n111:         .groupby(\"Year\")[\"PredictedScore\"]\n112:         .rank(ascending=False, method=\"first\")\n113:     )\n114: \n115:     ndcg = evaluate_ndcg(y_test.to_numpy(), y_pred, test_groups)\n116:     print(f\"NDCG Score on test years {test_years.tolist()}: {ndcg:.4f}\")\n117: \n118:     # Show results\n119:     print(df[test_idx][[\"Year\", \"Name\", \"Rank\", \"PredictedScore\", \"PredictedRank\"]])\n120:     plot_ranking_predictions(df, 2024)\n121:     plot_ranking_predictions(df, 2025)\n122: \n123: "
        },
        "source": "backend",
        "timestamp": "2025-08-23 10:47:06.000",
        "event": "map_summary_code",
        "id": "XkyonU4SPd6nDEaLuKeJ"
    },
    {
        "data": {
            "mapping": [
                {
                    "summaryComponent": "Loads data and splits it into training and test sets by year",
                    "codeSegments": [
                        {
                            "line": 75,
                            "code": "X, y, group, df = load_data()"
                        },
                        {
                            "line": 78,
                            "code": "unique_years = df[\"Year\"].unique()"
                        },
                        {
                            "line": 79,
                            "code": "train_years, test_years = ("
                        },
                        {
                            "line": 84,
                            "code": "train_idx = df[\"Year\"].isin(train_years)"
                        },
                        {
                            "line": 85,
                            "code": "test_idx = df[\"Year\"].isin(test_years)"
                        },
                        {
                            "line": 87,
                            "code": "X_train, X_test = X[train_idx], X[test_idx]"
                        },
                        {
                            "line": 88,
                            "code": "y_train, y_test = y[train_idx], y[test_idx]"
                        }
                    ]
                },
                {
                    "summaryComponent": "Trains an XGBoost ranking model on the training data",
                    "codeSegments": [
                        {
                            "line": 95,
                            "code": "model = XGBRanker("
                        },
                        {
                            "line": 104,
                            "code": "model.fit(X_train, y_train, group=train_groups)"
                        }
                    ]
                },
                {
                    "summaryComponent": "Predicts and evaluates rankings for the test years",
                    "codeSegments": [
                        {
                            "line": 107,
                            "code": "y_pred = model.predict(X_test)"
                        },
                        {
                            "line": 108,
                            "code": "df.loc[test_idx, \"PredictedScore\"] = y_pred"
                        },
                        {
                            "line": 109,
                            "code": "df.loc[test_idx, \"PredictedRank\"] = ("
                        }
                    ]
                },
                {
                    "summaryComponent": "Calculates NDCG score for evaluation",
                    "codeSegments": [
                        {
                            "line": 115,
                            "code": "ndcg = evaluate_ndcg(y_test.to_numpy(), y_pred, test_groups)"
                        }
                    ]
                },
                {
                    "summaryComponent": "Prints results and visualizes prediction errors for 2024 and 2025",
                    "codeSegments": [
                        {
                            "line": 119,
                            "code": "print(df[test_idx][[\"Year\", \"Name\", \"Rank\", \"PredictedScore\", \"PredictedRank\"]])"
                        },
                        {
                            "line": 120,
                            "code": "plot_ranking_predictions(df, 2024)"
                        },
                        {
                            "line": 121,
                            "code": "plot_ranking_predictions(df, 2025)"
                        }
                    ]
                }
            ],
            "summary": "• Loads data and splits it into training and test sets by year\n• Trains an XGBoost ranking model on the training data\n• Predicts and evaluates rankings for the test years\n  ◦ Calculates NDCG score for evaluation\n• Prints results and visualizes prediction errors for 2024 and 2025",
            "code": "74: def main():\n75:     X, y, group, df = load_data()\n76: \n77:     # Train-test split on years\n78:     unique_years = df[\"Year\"].unique()\n79:     train_years, test_years = (\n80:         unique_years[:-2],  # train: 2015-2023\n81:         unique_years[-2:],  # test: 2024-2025\n82:     )\n83: \n84:     train_idx = df[\"Year\"].isin(train_years)\n85:     test_idx = df[\"Year\"].isin(test_years)\n86: \n87:     X_train, X_test = X[train_idx], X[test_idx]\n88:     y_train, y_test = y[train_idx], y[test_idx]\n89: \n90:     # Group sizes\n91:     train_groups = df[train_idx].groupby(\"Year\").size().to_numpy()\n92:     test_groups = df[test_idx].groupby(\"Year\").size().to_numpy()\n93: \n94:     # Model\n95:     model = XGBRanker(\n96:         objective=\"rank:pairwise\",\n97:         learning_rate=0.1,\n98:         n_estimators=1000,\n99:         max_depth=4,\n100:         random_state=42,\n101:     )\n102: \n103:     print(\"Training XGBoostRanker...\")\n104:     model.fit(X_train, y_train, group=train_groups)\n105: \n106:     # Predict, sort, and evaluate\n107:     y_pred = model.predict(X_test)\n108:     df.loc[test_idx, \"PredictedScore\"] = y_pred\n109:     df.loc[test_idx, \"PredictedRank\"] = (\n110:         df.loc[test_idx]\n111:         .groupby(\"Year\")[\"PredictedScore\"]\n112:         .rank(ascending=False, method=\"first\")\n113:     )\n114: \n115:     ndcg = evaluate_ndcg(y_test.to_numpy(), y_pred, test_groups)\n116:     print(f\"NDCG Score on test years {test_years.tolist()}: {ndcg:.4f}\")\n117: \n118:     # Show results\n119:     print(df[test_idx][[\"Year\", \"Name\", \"Rank\", \"PredictedScore\", \"PredictedRank\"]])\n120:     plot_ranking_predictions(df, 2024)\n121:     plot_ranking_predictions(df, 2025)\n122: \n123: "
        },
        "source": "backend",
        "timestamp": "2025-08-23 10:47:07.000",
        "event": "map_summary_code",
        "id": "z9zu4xTwaizXOzqUGqw1"
    },
    {
        "data": {
            "mapping": [
                {
                    "summaryComponent": "The main() function",
                    "codeSegments": [
                        {
                            "line": 74,
                            "code": "def main():"
                        }
                    ]
                },
                {
                    "summaryComponent": "loads MVP data",
                    "codeSegments": [
                        {
                            "line": 75,
                            "code": "X, y, group, df = load_data()"
                        }
                    ]
                },
                {
                    "summaryComponent": "splits it into training and test sets by year",
                    "codeSegments": [
                        {
                            "line": 78,
                            "code": "unique_years = df[\"Year\"].unique()"
                        },
                        {
                            "line": 79,
                            "code": "train_years, test_years = ("
                        },
                        {
                            "line": 84,
                            "code": "train_idx = df[\"Year\"].isin(train_years)"
                        },
                        {
                            "line": 85,
                            "code": "test_idx = df[\"Year\"].isin(test_years)"
                        },
                        {
                            "line": 87,
                            "code": "X_train, X_test = X[train_idx], X[test_idx]"
                        },
                        {
                            "line": 88,
                            "code": "y_train, y_test = y[train_idx], y[test_idx]"
                        }
                    ]
                },
                {
                    "summaryComponent": "trains an XGBoost ranking model",
                    "codeSegments": [
                        {
                            "line": 95,
                            "code": "model = XGBRanker("
                        },
                        {
                            "line": 104,
                            "code": "model.fit(X_train, y_train, group=train_groups)"
                        }
                    ]
                },
                {
                    "summaryComponent": "It predicts ranks for the test years",
                    "codeSegments": [
                        {
                            "line": 107,
                            "code": "y_pred = model.predict(X_test)"
                        },
                        {
                            "line": 108,
                            "code": "df.loc[test_idx, \"PredictedScore\"] = y_pred"
                        },
                        {
                            "line": 109,
                            "code": "df.loc[test_idx, \"PredictedRank\"] = ("
                        }
                    ]
                },
                {
                    "summaryComponent": "evaluates performance using NDCG",
                    "codeSegments": [
                        {
                            "line": 115,
                            "code": "ndcg = evaluate_ndcg(y_test.to_numpy(), y_pred, test_groups)"
                        }
                    ]
                },
                {
                    "summaryComponent": "prints the results",
                    "codeSegments": [
                        {
                            "line": 116,
                            "code": "print(f\"NDCG Score on test years {test_years.tolist()}: {ndcg:.4f}\")"
                        },
                        {
                            "line": 119,
                            "code": "print(df[test_idx][[\"Year\", \"Name\", \"Rank\", \"PredictedScore\", \"PredictedRank\"]])"
                        }
                    ]
                },
                {
                    "summaryComponent": "generates plots to visualize prediction errors for the test years",
                    "codeSegments": [
                        {
                            "line": 120,
                            "code": "plot_ranking_predictions(df, 2024)"
                        },
                        {
                            "line": 121,
                            "code": "plot_ranking_predictions(df, 2025)"
                        }
                    ]
                }
            ],
            "summary": "The main() function loads MVP data, splits it into training and test sets by year, and trains an XGBoost ranking model. It predicts ranks for the test years, evaluates performance using NDCG, and prints the results. Finally, it generates plots to visualize prediction errors for the test years.",
            "code": "74: def main():\n75:     X, y, group, df = load_data()\n76: \n77:     # Train-test split on years\n78:     unique_years = df[\"Year\"].unique()\n79:     train_years, test_years = (\n80:         unique_years[:-2],  # train: 2015-2023\n81:         unique_years[-2:],  # test: 2024-2025\n82:     )\n83: \n84:     train_idx = df[\"Year\"].isin(train_years)\n85:     test_idx = df[\"Year\"].isin(test_years)\n86: \n87:     X_train, X_test = X[train_idx], X[test_idx]\n88:     y_train, y_test = y[train_idx], y[test_idx]\n89: \n90:     # Group sizes\n91:     train_groups = df[train_idx].groupby(\"Year\").size().to_numpy()\n92:     test_groups = df[test_idx].groupby(\"Year\").size().to_numpy()\n93: \n94:     # Model\n95:     model = XGBRanker(\n96:         objective=\"rank:pairwise\",\n97:         learning_rate=0.1,\n98:         n_estimators=1000,\n99:         max_depth=4,\n100:         random_state=42,\n101:     )\n102: \n103:     print(\"Training XGBoostRanker...\")\n104:     model.fit(X_train, y_train, group=train_groups)\n105: \n106:     # Predict, sort, and evaluate\n107:     y_pred = model.predict(X_test)\n108:     df.loc[test_idx, \"PredictedScore\"] = y_pred\n109:     df.loc[test_idx, \"PredictedRank\"] = (\n110:         df.loc[test_idx]\n111:         .groupby(\"Year\")[\"PredictedScore\"]\n112:         .rank(ascending=False, method=\"first\")\n113:     )\n114: \n115:     ndcg = evaluate_ndcg(y_test.to_numpy(), y_pred, test_groups)\n116:     print(f\"NDCG Score on test years {test_years.tolist()}: {ndcg:.4f}\")\n117: \n118:     # Show results\n119:     print(df[test_idx][[\"Year\", \"Name\", \"Rank\", \"PredictedScore\", \"PredictedRank\"]])\n120:     plot_ranking_predictions(df, 2024)\n121:     plot_ranking_predictions(df, 2025)\n122: \n123: "
        },
        "source": "backend",
        "timestamp": "2025-08-23 10:47:09.000",
        "event": "map_summary_code",
        "id": "p7tTAbf2HpHTwSCqaNSA"
    },
    {
        "data": {
            "mapping": [
                {
                    "summaryComponent": "The main() function orchestrates the workflow for training and evaluating an XGBoost ranking model on MVP data.",
                    "codeSegments": [
                        {
                            "line": 74,
                            "code": "def main():"
                        }
                    ]
                },
                {
                    "summaryComponent": "It first loads the data,",
                    "codeSegments": [
                        {
                            "line": 75,
                            "code": "X, y, group, df = load_data()"
                        }
                    ]
                },
                {
                    "summaryComponent": "splits it into training (all but the last two years) and test (the last two years) sets,",
                    "codeSegments": [
                        {
                            "line": 78,
                            "code": "unique_years = df[\"Year\"].unique()"
                        },
                        {
                            "line": 79,
                            "code": "train_years, test_years = ("
                        },
                        {
                            "line": 80,
                            "code": "unique_years[:-2],  # train: 2015-2023"
                        },
                        {
                            "line": 81,
                            "code": "unique_years[-2:],  # test: 2024-2025"
                        },
                        {
                            "line": 84,
                            "code": "train_idx = df[\"Year\"].isin(train_years)"
                        },
                        {
                            "line": 85,
                            "code": "test_idx = df[\"Year\"].isin(test_years)"
                        },
                        {
                            "line": 87,
                            "code": "X_train, X_test = X[train_idx], X[test_idx]"
                        },
                        {
                            "line": 88,
                            "code": "y_train, y_test = y[train_idx], y[test_idx]"
                        }
                    ]
                },
                {
                    "summaryComponent": "and prepares group information for ranking.",
                    "codeSegments": [
                        {
                            "line": 91,
                            "code": "train_groups = df[train_idx].groupby(\"Year\").size().to_numpy()"
                        },
                        {
                            "line": 92,
                            "code": "test_groups = df[test_idx].groupby(\"Year\").size().to_numpy()"
                        }
                    ]
                },
                {
                    "summaryComponent": "The function then initializes and trains an XGBRanker using the training data and group sizes.",
                    "codeSegments": [
                        {
                            "line": 95,
                            "code": "model = XGBRanker("
                        },
                        {
                            "line": 104,
                            "code": "model.fit(X_train, y_train, group=train_groups)"
                        }
                    ]
                },
                {
                    "summaryComponent": "After training, it predicts scores for the test set,",
                    "codeSegments": [
                        {
                            "line": 107,
                            "code": "y_pred = model.predict(X_test)"
                        }
                    ]
                },
                {
                    "summaryComponent": "computes predicted ranks within each year,",
                    "codeSegments": [
                        {
                            "line": 108,
                            "code": "df.loc[test_idx, \"PredictedScore\"] = y_pred"
                        },
                        {
                            "line": 109,
                            "code": "df.loc[test_idx, \"PredictedRank\"] = ("
                        },
                        {
                            "line": 110,
                            "code": "df.loc[test_idx]"
                        },
                        {
                            "line": 111,
                            "code": ".groupby(\"Year\")[\"PredictedScore\"]"
                        },
                        {
                            "line": 112,
                            "code": ".rank(ascending=False, method=\"first\")"
                        }
                    ]
                },
                {
                    "summaryComponent": "and evaluates the model's performance using the NDCG metric.",
                    "codeSegments": [
                        {
                            "line": 115,
                            "code": "ndcg = evaluate_ndcg(y_test.to_numpy(), y_pred, test_groups)"
                        },
                        {
                            "line": 116,
                            "code": "print(f\"NDCG Score on test years {test_years.tolist()}: {ndcg:.4f}\")"
                        }
                    ]
                },
                {
                    "summaryComponent": "Results, including predicted scores and ranks, are printed for the test years,",
                    "codeSegments": [
                        {
                            "line": 119,
                            "code": "print(df[test_idx][[\"Year\", \"Name\", \"Rank\", \"PredictedScore\", \"PredictedRank\"]])"
                        }
                    ]
                },
                {
                    "summaryComponent": "and bar plots are generated to visualize prediction errors for 2024 and 2025.",
                    "codeSegments": [
                        {
                            "line": 120,
                            "code": "plot_ranking_predictions(df, 2024)"
                        },
                        {
                            "line": 121,
                            "code": "plot_ranking_predictions(df, 2025)"
                        }
                    ]
                }
            ],
            "summary": "The main() function orchestrates the workflow for training and evaluating an XGBoost ranking model on MVP data. It first loads the data, splits it into training (all but the last two years) and test (the last two years) sets, and prepares group information for ranking. The function then initializes and trains an XGBRanker using the training data and group sizes. After training, it predicts scores for the test set, computes predicted ranks within each year, and evaluates the model's performance using the NDCG metric. Results, including predicted scores and ranks, are printed for the test years, and bar plots are generated to visualize prediction errors for 2024 and 2025.",
            "code": "74: def main():\n75:     X, y, group, df = load_data()\n76: \n77:     # Train-test split on years\n78:     unique_years = df[\"Year\"].unique()\n79:     train_years, test_years = (\n80:         unique_years[:-2],  # train: 2015-2023\n81:         unique_years[-2:],  # test: 2024-2025\n82:     )\n83: \n84:     train_idx = df[\"Year\"].isin(train_years)\n85:     test_idx = df[\"Year\"].isin(test_years)\n86: \n87:     X_train, X_test = X[train_idx], X[test_idx]\n88:     y_train, y_test = y[train_idx], y[test_idx]\n89: \n90:     # Group sizes\n91:     train_groups = df[train_idx].groupby(\"Year\").size().to_numpy()\n92:     test_groups = df[test_idx].groupby(\"Year\").size().to_numpy()\n93: \n94:     # Model\n95:     model = XGBRanker(\n96:         objective=\"rank:pairwise\",\n97:         learning_rate=0.1,\n98:         n_estimators=1000,\n99:         max_depth=4,\n100:         random_state=42,\n101:     )\n102: \n103:     print(\"Training XGBoostRanker...\")\n104:     model.fit(X_train, y_train, group=train_groups)\n105: \n106:     # Predict, sort, and evaluate\n107:     y_pred = model.predict(X_test)\n108:     df.loc[test_idx, \"PredictedScore\"] = y_pred\n109:     df.loc[test_idx, \"PredictedRank\"] = (\n110:         df.loc[test_idx]\n111:         .groupby(\"Year\")[\"PredictedScore\"]\n112:         .rank(ascending=False, method=\"first\")\n113:     )\n114: \n115:     ndcg = evaluate_ndcg(y_test.to_numpy(), y_pred, test_groups)\n116:     print(f\"NDCG Score on test years {test_years.tolist()}: {ndcg:.4f}\")\n117: \n118:     # Show results\n119:     print(df[test_idx][[\"Year\", \"Name\", \"Rank\", \"PredictedScore\", \"PredictedRank\"]])\n120:     plot_ranking_predictions(df, 2024)\n121:     plot_ranking_predictions(df, 2025)\n122: \n123: "
        },
        "source": "backend",
        "timestamp": "2025-08-23 10:47:11.000",
        "event": "map_summary_code",
        "id": "avnjfNeq5omKMJ7zfCmY"
    },
    {
        "data": {
            "before_section_id": "98364d69-7071-47ca-9328-9f9a586aed75",
            "after_section_id": "cc03caa6-0f55-4e5b-8a44-e0cbcce404a5"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:47:12.000",
        "event": "autotransit_section",
        "id": "kWnsSOOY9nbAW7zDZzNj"
    },
    {
        "data": {
            "mapping": [
                {
                    "summaryComponent": "Loads MVP data and splits it into features, labels, groups, and the full DataFrame",
                    "codeSegments": [
                        {
                            "line": 75,
                            "code": "X, y, group, df = load_data()"
                        }
                    ]
                },
                {
                    "summaryComponent": "Splits data by year:",
                    "codeSegments": [
                        {
                            "line": 78,
                            "code": "unique_years = df[\"Year\"].unique()"
                        },
                        {
                            "line": 79,
                            "code": "train_years, test_years = ("
                        },
                        {
                            "line": 80,
                            "code": "    unique_years[:-2],  # train: 2015-2023"
                        },
                        {
                            "line": 81,
                            "code": "    unique_years[-2:],  # test: 2024-2025"
                        }
                    ]
                },
                {
                    "summaryComponent": "Training set: all years except the last two",
                    "codeSegments": [
                        {
                            "line": 79,
                            "code": "train_years, test_years = ("
                        },
                        {
                            "line": 80,
                            "code": "    unique_years[:-2],  # train: 2015-2023"
                        }
                    ]
                },
                {
                    "summaryComponent": "Test set: last two years (2024, 2025)",
                    "codeSegments": [
                        {
                            "line": 81,
                            "code": "    unique_years[-2:],  # test: 2024-2025"
                        }
                    ]
                },
                {
                    "summaryComponent": "Prepares training and test indices, and computes group sizes for ranking",
                    "codeSegments": [
                        {
                            "line": 84,
                            "code": "train_idx = df[\"Year\"].isin(train_years)"
                        },
                        {
                            "line": 85,
                            "code": "test_idx = df[\"Year\"].isin(test_years)"
                        },
                        {
                            "line": 91,
                            "code": "train_groups = df[train_idx].groupby(\"Year\").size().to_numpy()"
                        },
                        {
                            "line": 92,
                            "code": "test_groups = df[test_idx].groupby(\"Year\").size().to_numpy()"
                        }
                    ]
                },
                {
                    "summaryComponent": "Initializes an XGBRanker with specific hyperparameters (pairwise ranking, learning rate, estimators, depth, random state)",
                    "codeSegments": [
                        {
                            "line": 95,
                            "code": "model = XGBRanker("
                        },
                        {
                            "line": 96,
                            "code": "    objective=\"rank:pairwise\","
                        },
                        {
                            "line": 97,
                            "code": "    learning_rate=0.1,"
                        },
                        {
                            "line": 98,
                            "code": "    n_estimators=1000,"
                        },
                        {
                            "line": 99,
                            "code": "    max_depth=4,"
                        },
                        {
                            "line": 100,
                            "code": "    random_state=42,"
                        }
                    ]
                },
                {
                    "summaryComponent": "Trains the model on the training set with group information",
                    "codeSegments": [
                        {
                            "line": 104,
                            "code": "model.fit(X_train, y_train, group=train_groups)"
                        }
                    ]
                },
                {
                    "summaryComponent": "Makes predictions on the test set:",
                    "codeSegments": [
                        {
                            "line": 107,
                            "code": "y_pred = model.predict(X_test)"
                        }
                    ]
                },
                {
                    "summaryComponent": "Stores predicted scores",
                    "codeSegments": [
                        {
                            "line": 108,
                            "code": "df.loc[test_idx, \"PredictedScore\"] = y_pred"
                        }
                    ]
                },
                {
                    "summaryComponent": "Calculates predicted ranks within each test year",
                    "codeSegments": [
                        {
                            "line": 109,
                            "code": "df.loc[test_idx, \"PredictedRank\"] = ("
                        },
                        {
                            "line": 110,
                            "code": "    df.loc[test_idx]"
                        },
                        {
                            "line": 111,
                            "code": "    .groupby(\"Year\")[\"PredictedScore\"]"
                        },
                        {
                            "line": 112,
                            "code": "    .rank(ascending=False, method=\"first\")"
                        }
                    ]
                },
                {
                    "summaryComponent": "Evaluates model performance using the NDCG metric on the test years",
                    "codeSegments": [
                        {
                            "line": 115,
                            "code": "ndcg = evaluate_ndcg(y_test.to_numpy(), y_pred, test_groups)"
                        }
                    ]
                },
                {
                    "summaryComponent": "Prints detailed results for the test years, including true and predicted ranks and scores",
                    "codeSegments": [
                        {
                            "line": 119,
                            "code": "print(df[test_idx][[\"Year\", \"Name\", \"Rank\", \"PredictedScore\", \"PredictedRank\"]])"
                        }
                    ]
                },
                {
                    "summaryComponent": "Generates and saves bar plots of prediction errors for 2024 and 2025",
                    "codeSegments": [
                        {
                            "line": 120,
                            "code": "plot_ranking_predictions(df, 2024)"
                        },
                        {
                            "line": 121,
                            "code": "plot_ranking_predictions(df, 2025)"
                        }
                    ]
                }
            ],
            "summary": "• Loads MVP data and splits it into features, labels, groups, and the full DataFrame\n• Splits data by year:\n  ◦ Training set: all years except the last two\n  ◦ Test set: last two years (2024, 2025)\n• Prepares training and test indices, and computes group sizes for ranking\n• Initializes an XGBRanker with specific hyperparameters (pairwise ranking, learning rate, estimators, depth, random state)\n• Trains the model on the training set with group information\n• Makes predictions on the test set:\n  ◦ Stores predicted scores\n  ◦ Calculates predicted ranks within each test year\n• Evaluates model performance using the NDCG metric on the test years\n• Prints detailed results for the test years, including true and predicted ranks and scores\n• Generates and saves bar plots of prediction errors for 2024 and 2025",
            "code": "74: def main():\n75:     X, y, group, df = load_data()\n76: \n77:     # Train-test split on years\n78:     unique_years = df[\"Year\"].unique()\n79:     train_years, test_years = (\n80:         unique_years[:-2],  # train: 2015-2023\n81:         unique_years[-2:],  # test: 2024-2025\n82:     )\n83: \n84:     train_idx = df[\"Year\"].isin(train_years)\n85:     test_idx = df[\"Year\"].isin(test_years)\n86: \n87:     X_train, X_test = X[train_idx], X[test_idx]\n88:     y_train, y_test = y[train_idx], y[test_idx]\n89: \n90:     # Group sizes\n91:     train_groups = df[train_idx].groupby(\"Year\").size().to_numpy()\n92:     test_groups = df[test_idx].groupby(\"Year\").size().to_numpy()\n93: \n94:     # Model\n95:     model = XGBRanker(\n96:         objective=\"rank:pairwise\",\n97:         learning_rate=0.1,\n98:         n_estimators=1000,\n99:         max_depth=4,\n100:         random_state=42,\n101:     )\n102: \n103:     print(\"Training XGBoostRanker...\")\n104:     model.fit(X_train, y_train, group=train_groups)\n105: \n106:     # Predict, sort, and evaluate\n107:     y_pred = model.predict(X_test)\n108:     df.loc[test_idx, \"PredictedScore\"] = y_pred\n109:     df.loc[test_idx, \"PredictedRank\"] = (\n110:         df.loc[test_idx]\n111:         .groupby(\"Year\")[\"PredictedScore\"]\n112:         .rank(ascending=False, method=\"first\")\n113:     )\n114: \n115:     ndcg = evaluate_ndcg(y_test.to_numpy(), y_pred, test_groups)\n116:     print(f\"NDCG Score on test years {test_years.tolist()}: {ndcg:.4f}\")\n117: \n118:     # Show results\n119:     print(df[test_idx][[\"Year\", \"Name\", \"Rank\", \"PredictedScore\", \"PredictedRank\"]])\n120:     plot_ranking_predictions(df, 2024)\n121:     plot_ranking_predictions(df, 2025)\n122: \n123: "
        },
        "source": "backend",
        "timestamp": "2025-08-23 10:47:12.000",
        "event": "map_summary_code",
        "id": "luXvFJnxrH2wboaP4BkQ"
    },
    {
        "data": {
            "section_data": {
                "lines": [
                    74,
                    123
                ],
                "summaryData": {
                    "medium_unstructured": "The main() function loads MVP data, splits it into training and test sets by year, and trains an XGBoost ranking model. It predicts ranks for the test years, evaluates performance using NDCG, and prints the results. Finally, it generates plots to visualize prediction errors for the test years.",
                    "low_structured": "• Trains an XGBoost ranking model on MVP data\n• Evaluates and prints results\n• Plots prediction errors for test years",
                    "title": "Summary of the main() Function for MVP Ranking Prediction",
                    "medium_structured": "• Loads data and splits it into training and test sets by year\n• Trains an XGBoost ranking model on the training data\n• Predicts and evaluates rankings for the test years\n  ◦ Calculates NDCG score for evaluation\n• Prints results and visualizes prediction errors for 2024 and 2025",
                    "high_unstructured": "The main() function orchestrates the workflow for training and evaluating an XGBoost ranking model on MVP data. It first loads the data, splits it into training (all but the last two years) and test (the last two years) sets, and prepares group information for ranking. The function then initializes and trains an XGBRanker using the training data and group sizes. After training, it predicts scores for the test set, computes predicted ranks within each year, and evaluates the model's performance using the NDCG metric. Results, including predicted scores and ranks, are printed for the test years, and bar plots are generated to visualize prediction errors for 2024 and 2025.",
                    "high_structured": "• Loads MVP data and splits it into features, labels, groups, and the full DataFrame\n• Splits data by year:\n  ◦ Training set: all years except the last two\n  ◦ Test set: last two years (2024, 2025)\n• Prepares training and test indices, and computes group sizes for ranking\n• Initializes an XGBRanker with specific hyperparameters (pairwise ranking, learning rate, estimators, depth, random state)\n• Trains the model on the training set with group information\n• Makes predictions on the test set:\n  ◦ Stores predicted scores\n  ◦ Calculates predicted ranks within each test year\n• Evaluates model performance using the NDCG metric on the test years\n• Prints detailed results for the test years, including true and predicted ranks and scores\n• Generates and saves bar plots of prediction errors for 2024 and 2025",
                    "low_unstructured": "This function trains and evaluates an XGBoost ranking model on MVP data, then visualizes and prints the results."
                },
                "editPromptStructured": null,
                "createdAt": 1755974832000,
                "metadata": {
                    "filename": "rank_model.py",
                    "id": "cc03caa6-0f55-4e5b-8a44-e0cbcce404a5",
                    "originalCode": "def main():\n    X, y, group, df = load_data()\n\n    # Train-test split on years\n    unique_years = df[\"Year\"].unique()\n    train_years, test_years = (\n        unique_years[:-2],  # train: 2015-2023\n        unique_years[-2:],  # test: 2024-2025\n    )\n\n    train_idx = df[\"Year\"].isin(train_years)\n    test_idx = df[\"Year\"].isin(test_years)\n\n    X_train, X_test = X[train_idx], X[test_idx]\n    y_train, y_test = y[train_idx], y[test_idx]\n\n    # Group sizes\n    train_groups = df[train_idx].groupby(\"Year\").size().to_numpy()\n    test_groups = df[test_idx].groupby(\"Year\").size().to_numpy()\n\n    # Model\n    model = XGBRanker(\n        objective=\"rank:pairwise\",\n        learning_rate=0.1,\n        n_estimators=1000,\n        max_depth=4,\n        random_state=42,\n    )\n\n    print(\"Training XGBoostRanker...\")\n    model.fit(X_train, y_train, group=train_groups)\n\n    # Predict, sort, and evaluate\n    y_pred = model.predict(X_test)\n    df.loc[test_idx, \"PredictedScore\"] = y_pred\n    df.loc[test_idx, \"PredictedRank\"] = (\n        df.loc[test_idx]\n        .groupby(\"Year\")[\"PredictedScore\"]\n        .rank(ascending=False, method=\"first\")\n    )\n\n    ndcg = evaluate_ndcg(y_test.to_numpy(), y_pred, test_groups)\n    print(f\"NDCG Score on test years {test_years.tolist()}: {ndcg:.4f}\")\n\n    # Show results\n    print(df[test_idx][[\"Year\", \"Name\", \"Rank\", \"PredictedScore\", \"PredictedRank\"]])\n    plot_ranking_predictions(df, 2024)\n    plot_ranking_predictions(df, 2025)\n\n",
                    "fullPath": "/project/workspace/rank_model.py",
                    "offset": 1952
                },
                "selectedStructured": "unstructured",
                "title": "Summary of the main() Function for MVP Ranking Prediction",
                "selectedDetailLevel": "medium",
                "summaryMappings": {
                    "medium_unstructured": [
                        {
                            "summaryComponent": "The main() function",
                            "codeSegments": [
                                {
                                    "line": 74,
                                    "code": "def main():"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "loads MVP data",
                            "codeSegments": [
                                {
                                    "line": 75,
                                    "code": "X, y, group, df = load_data()"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "splits it into training and test sets by year",
                            "codeSegments": [
                                {
                                    "line": 78,
                                    "code": "unique_years = df[\"Year\"].unique()"
                                },
                                {
                                    "line": 79,
                                    "code": "train_years, test_years = ("
                                },
                                {
                                    "line": 84,
                                    "code": "train_idx = df[\"Year\"].isin(train_years)"
                                },
                                {
                                    "line": 85,
                                    "code": "test_idx = df[\"Year\"].isin(test_years)"
                                },
                                {
                                    "line": 87,
                                    "code": "X_train, X_test = X[train_idx], X[test_idx]"
                                },
                                {
                                    "line": 88,
                                    "code": "y_train, y_test = y[train_idx], y[test_idx]"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "trains an XGBoost ranking model",
                            "codeSegments": [
                                {
                                    "line": 95,
                                    "code": "model = XGBRanker("
                                },
                                {
                                    "line": 104,
                                    "code": "model.fit(X_train, y_train, group=train_groups)"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "It predicts ranks for the test years",
                            "codeSegments": [
                                {
                                    "line": 107,
                                    "code": "y_pred = model.predict(X_test)"
                                },
                                {
                                    "line": 108,
                                    "code": "df.loc[test_idx, \"PredictedScore\"] = y_pred"
                                },
                                {
                                    "line": 109,
                                    "code": "df.loc[test_idx, \"PredictedRank\"] = ("
                                }
                            ]
                        },
                        {
                            "summaryComponent": "evaluates performance using NDCG",
                            "codeSegments": [
                                {
                                    "line": 115,
                                    "code": "ndcg = evaluate_ndcg(y_test.to_numpy(), y_pred, test_groups)"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "prints the results",
                            "codeSegments": [
                                {
                                    "line": 116,
                                    "code": "print(f\"NDCG Score on test years {test_years.tolist()}: {ndcg:.4f}\")"
                                },
                                {
                                    "line": 119,
                                    "code": "print(df[test_idx][[\"Year\", \"Name\", \"Rank\", \"PredictedScore\", \"PredictedRank\"]])"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "generates plots to visualize prediction errors for the test years",
                            "codeSegments": [
                                {
                                    "line": 120,
                                    "code": "plot_ranking_predictions(df, 2024)"
                                },
                                {
                                    "line": 121,
                                    "code": "plot_ranking_predictions(df, 2025)"
                                }
                            ]
                        }
                    ],
                    "low_structured": [
                        {
                            "summaryComponent": "Trains an XGBoost ranking model on MVP data",
                            "codeSegments": [
                                {
                                    "line": 95,
                                    "code": "model = XGBRanker("
                                },
                                {
                                    "line": 104,
                                    "code": "model.fit(X_train, y_train, group=train_groups)"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "Evaluates and prints results",
                            "codeSegments": [
                                {
                                    "line": 115,
                                    "code": "ndcg = evaluate_ndcg(y_test.to_numpy(), y_pred, test_groups)"
                                },
                                {
                                    "line": 116,
                                    "code": "print(f\"NDCG Score on test years {test_years.tolist()}: {ndcg:.4f}\")"
                                },
                                {
                                    "line": 119,
                                    "code": "print(df[test_idx][[\"Year\", \"Name\", \"Rank\", \"PredictedScore\", \"PredictedRank\"]])"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "Plots prediction errors for test years",
                            "codeSegments": [
                                {
                                    "line": 120,
                                    "code": "plot_ranking_predictions(df, 2024)"
                                },
                                {
                                    "line": 121,
                                    "code": "plot_ranking_predictions(df, 2025)"
                                }
                            ]
                        }
                    ],
                    "low_unstructured": [
                        {
                            "summaryComponent": "trains",
                            "codeSegments": [
                                {
                                    "line": 104,
                                    "code": "model.fit(X_train, y_train, group=train_groups)"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "evaluates",
                            "codeSegments": [
                                {
                                    "line": 115,
                                    "code": "ndcg = evaluate_ndcg(y_test.to_numpy(), y_pred, test_groups)"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "an XGBoost ranking model",
                            "codeSegments": [
                                {
                                    "line": 95,
                                    "code": "model = XGBRanker("
                                }
                            ]
                        },
                        {
                            "summaryComponent": "on MVP data",
                            "codeSegments": [
                                {
                                    "line": 75,
                                    "code": "X, y, group, df = load_data()"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "then visualizes",
                            "codeSegments": [
                                {
                                    "line": 120,
                                    "code": "plot_ranking_predictions(df, 2024)"
                                },
                                {
                                    "line": 121,
                                    "code": "plot_ranking_predictions(df, 2025)"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "and prints the results",
                            "codeSegments": [
                                {
                                    "line": 119,
                                    "code": "print(df[test_idx][[\"Year\", \"Name\", \"Rank\", \"PredictedScore\", \"PredictedRank\"]])"
                                }
                            ]
                        }
                    ],
                    "medium_structured": [
                        {
                            "summaryComponent": "Loads data and splits it into training and test sets by year",
                            "codeSegments": [
                                {
                                    "line": 75,
                                    "code": "X, y, group, df = load_data()"
                                },
                                {
                                    "line": 78,
                                    "code": "unique_years = df[\"Year\"].unique()"
                                },
                                {
                                    "line": 79,
                                    "code": "train_years, test_years = ("
                                },
                                {
                                    "line": 84,
                                    "code": "train_idx = df[\"Year\"].isin(train_years)"
                                },
                                {
                                    "line": 85,
                                    "code": "test_idx = df[\"Year\"].isin(test_years)"
                                },
                                {
                                    "line": 87,
                                    "code": "X_train, X_test = X[train_idx], X[test_idx]"
                                },
                                {
                                    "line": 88,
                                    "code": "y_train, y_test = y[train_idx], y[test_idx]"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "Trains an XGBoost ranking model on the training data",
                            "codeSegments": [
                                {
                                    "line": 95,
                                    "code": "model = XGBRanker("
                                },
                                {
                                    "line": 104,
                                    "code": "model.fit(X_train, y_train, group=train_groups)"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "Predicts and evaluates rankings for the test years",
                            "codeSegments": [
                                {
                                    "line": 107,
                                    "code": "y_pred = model.predict(X_test)"
                                },
                                {
                                    "line": 108,
                                    "code": "df.loc[test_idx, \"PredictedScore\"] = y_pred"
                                },
                                {
                                    "line": 109,
                                    "code": "df.loc[test_idx, \"PredictedRank\"] = ("
                                }
                            ]
                        },
                        {
                            "summaryComponent": "Calculates NDCG score for evaluation",
                            "codeSegments": [
                                {
                                    "line": 115,
                                    "code": "ndcg = evaluate_ndcg(y_test.to_numpy(), y_pred, test_groups)"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "Prints results and visualizes prediction errors for 2024 and 2025",
                            "codeSegments": [
                                {
                                    "line": 119,
                                    "code": "print(df[test_idx][[\"Year\", \"Name\", \"Rank\", \"PredictedScore\", \"PredictedRank\"]])"
                                },
                                {
                                    "line": 120,
                                    "code": "plot_ranking_predictions(df, 2024)"
                                },
                                {
                                    "line": 121,
                                    "code": "plot_ranking_predictions(df, 2025)"
                                }
                            ]
                        }
                    ],
                    "high_unstructured": [
                        {
                            "summaryComponent": "The main() function orchestrates the workflow for training and evaluating an XGBoost ranking model on MVP data.",
                            "codeSegments": [
                                {
                                    "line": 74,
                                    "code": "def main():"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "It first loads the data,",
                            "codeSegments": [
                                {
                                    "line": 75,
                                    "code": "X, y, group, df = load_data()"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "splits it into training (all but the last two years) and test (the last two years) sets,",
                            "codeSegments": [
                                {
                                    "line": 78,
                                    "code": "unique_years = df[\"Year\"].unique()"
                                },
                                {
                                    "line": 79,
                                    "code": "train_years, test_years = ("
                                },
                                {
                                    "line": 80,
                                    "code": "unique_years[:-2],  # train: 2015-2023"
                                },
                                {
                                    "line": 81,
                                    "code": "unique_years[-2:],  # test: 2024-2025"
                                },
                                {
                                    "line": 84,
                                    "code": "train_idx = df[\"Year\"].isin(train_years)"
                                },
                                {
                                    "line": 85,
                                    "code": "test_idx = df[\"Year\"].isin(test_years)"
                                },
                                {
                                    "line": 87,
                                    "code": "X_train, X_test = X[train_idx], X[test_idx]"
                                },
                                {
                                    "line": 88,
                                    "code": "y_train, y_test = y[train_idx], y[test_idx]"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "and prepares group information for ranking.",
                            "codeSegments": [
                                {
                                    "line": 91,
                                    "code": "train_groups = df[train_idx].groupby(\"Year\").size().to_numpy()"
                                },
                                {
                                    "line": 92,
                                    "code": "test_groups = df[test_idx].groupby(\"Year\").size().to_numpy()"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "The function then initializes and trains an XGBRanker using the training data and group sizes.",
                            "codeSegments": [
                                {
                                    "line": 95,
                                    "code": "model = XGBRanker("
                                },
                                {
                                    "line": 104,
                                    "code": "model.fit(X_train, y_train, group=train_groups)"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "After training, it predicts scores for the test set,",
                            "codeSegments": [
                                {
                                    "line": 107,
                                    "code": "y_pred = model.predict(X_test)"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "computes predicted ranks within each year,",
                            "codeSegments": [
                                {
                                    "line": 108,
                                    "code": "df.loc[test_idx, \"PredictedScore\"] = y_pred"
                                },
                                {
                                    "line": 109,
                                    "code": "df.loc[test_idx, \"PredictedRank\"] = ("
                                },
                                {
                                    "line": 110,
                                    "code": "df.loc[test_idx]"
                                },
                                {
                                    "line": 111,
                                    "code": ".groupby(\"Year\")[\"PredictedScore\"]"
                                },
                                {
                                    "line": 112,
                                    "code": ".rank(ascending=False, method=\"first\")"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "and evaluates the model's performance using the NDCG metric.",
                            "codeSegments": [
                                {
                                    "line": 115,
                                    "code": "ndcg = evaluate_ndcg(y_test.to_numpy(), y_pred, test_groups)"
                                },
                                {
                                    "line": 116,
                                    "code": "print(f\"NDCG Score on test years {test_years.tolist()}: {ndcg:.4f}\")"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "Results, including predicted scores and ranks, are printed for the test years,",
                            "codeSegments": [
                                {
                                    "line": 119,
                                    "code": "print(df[test_idx][[\"Year\", \"Name\", \"Rank\", \"PredictedScore\", \"PredictedRank\"]])"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "and bar plots are generated to visualize prediction errors for 2024 and 2025.",
                            "codeSegments": [
                                {
                                    "line": 120,
                                    "code": "plot_ranking_predictions(df, 2024)"
                                },
                                {
                                    "line": 121,
                                    "code": "plot_ranking_predictions(df, 2025)"
                                }
                            ]
                        }
                    ],
                    "high_structured": [
                        {
                            "summaryComponent": "Loads MVP data and splits it into features, labels, groups, and the full DataFrame",
                            "codeSegments": [
                                {
                                    "line": 75,
                                    "code": "X, y, group, df = load_data()"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "Splits data by year:",
                            "codeSegments": [
                                {
                                    "line": 78,
                                    "code": "unique_years = df[\"Year\"].unique()"
                                },
                                {
                                    "line": 79,
                                    "code": "train_years, test_years = ("
                                },
                                {
                                    "line": 80,
                                    "code": "    unique_years[:-2],  # train: 2015-2023"
                                },
                                {
                                    "line": 81,
                                    "code": "    unique_years[-2:],  # test: 2024-2025"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "Training set: all years except the last two",
                            "codeSegments": [
                                {
                                    "line": 79,
                                    "code": "train_years, test_years = ("
                                },
                                {
                                    "line": 80,
                                    "code": "    unique_years[:-2],  # train: 2015-2023"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "Test set: last two years (2024, 2025)",
                            "codeSegments": [
                                {
                                    "line": 81,
                                    "code": "    unique_years[-2:],  # test: 2024-2025"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "Prepares training and test indices, and computes group sizes for ranking",
                            "codeSegments": [
                                {
                                    "line": 84,
                                    "code": "train_idx = df[\"Year\"].isin(train_years)"
                                },
                                {
                                    "line": 85,
                                    "code": "test_idx = df[\"Year\"].isin(test_years)"
                                },
                                {
                                    "line": 91,
                                    "code": "train_groups = df[train_idx].groupby(\"Year\").size().to_numpy()"
                                },
                                {
                                    "line": 92,
                                    "code": "test_groups = df[test_idx].groupby(\"Year\").size().to_numpy()"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "Initializes an XGBRanker with specific hyperparameters (pairwise ranking, learning rate, estimators, depth, random state)",
                            "codeSegments": [
                                {
                                    "line": 95,
                                    "code": "model = XGBRanker("
                                },
                                {
                                    "line": 96,
                                    "code": "    objective=\"rank:pairwise\","
                                },
                                {
                                    "line": 97,
                                    "code": "    learning_rate=0.1,"
                                },
                                {
                                    "line": 98,
                                    "code": "    n_estimators=1000,"
                                },
                                {
                                    "line": 99,
                                    "code": "    max_depth=4,"
                                },
                                {
                                    "line": 100,
                                    "code": "    random_state=42,"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "Trains the model on the training set with group information",
                            "codeSegments": [
                                {
                                    "line": 104,
                                    "code": "model.fit(X_train, y_train, group=train_groups)"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "Makes predictions on the test set:",
                            "codeSegments": [
                                {
                                    "line": 107,
                                    "code": "y_pred = model.predict(X_test)"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "Stores predicted scores",
                            "codeSegments": [
                                {
                                    "line": 108,
                                    "code": "df.loc[test_idx, \"PredictedScore\"] = y_pred"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "Calculates predicted ranks within each test year",
                            "codeSegments": [
                                {
                                    "line": 109,
                                    "code": "df.loc[test_idx, \"PredictedRank\"] = ("
                                },
                                {
                                    "line": 110,
                                    "code": "    df.loc[test_idx]"
                                },
                                {
                                    "line": 111,
                                    "code": "    .groupby(\"Year\")[\"PredictedScore\"]"
                                },
                                {
                                    "line": 112,
                                    "code": "    .rank(ascending=False, method=\"first\")"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "Evaluates model performance using the NDCG metric on the test years",
                            "codeSegments": [
                                {
                                    "line": 115,
                                    "code": "ndcg = evaluate_ndcg(y_test.to_numpy(), y_pred, test_groups)"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "Prints detailed results for the test years, including true and predicted ranks and scores",
                            "codeSegments": [
                                {
                                    "line": 119,
                                    "code": "print(df[test_idx][[\"Year\", \"Name\", \"Rank\", \"PredictedScore\", \"PredictedRank\"]])"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "Generates and saves bar plots of prediction errors for 2024 and 2025",
                            "codeSegments": [
                                {
                                    "line": 120,
                                    "code": "plot_ranking_predictions(df, 2024)"
                                },
                                {
                                    "line": 121,
                                    "code": "plot_ranking_predictions(df, 2025)"
                                }
                            ]
                        }
                    ]
                },
                "editPromptValue": "",
                "editPromptDetailLevel": null
            },
            "section_id": "cc03caa6-0f55-4e5b-8a44-e0cbcce404a5"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:47:12.000",
        "event": "create_new_section",
        "id": "m4kfFKSStaUnvfwTPmfs"
    },
    {
        "data": {
            "mapping_index": 2,
            "structured_type": "unstructured",
            "section_id": "cc03caa6-0f55-4e5b-8a44-e0cbcce404a5",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:47:13.000",
        "event": "mapping_hover",
        "id": "6jjiNW3aItXqXtauI4NP"
    },
    {
        "data": {
            "structured_type": "unstructured",
            "section_id": "cc03caa6-0f55-4e5b-8a44-e0cbcce404a5",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:47:13.000",
        "event": "mapping_unhover",
        "id": "DEPhnaOqDgsC9kKcQW3j"
    },
    {
        "data": {
            "mapping_index": 3,
            "structured_type": "unstructured",
            "section_id": "cc03caa6-0f55-4e5b-8a44-e0cbcce404a5",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:47:13.000",
        "event": "mapping_hover",
        "id": "HL1Qyo0SHBEiEi4ZZ4Vh"
    },
    {
        "data": {
            "mapping_index": 6,
            "structured_type": "unstructured",
            "section_id": "cc03caa6-0f55-4e5b-8a44-e0cbcce404a5",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:47:13.000",
        "event": "mapping_hover",
        "id": "JZ6CCE2YuqWrCiFDvlr1"
    },
    {
        "data": {
            "mapping_index": 7,
            "structured_type": "unstructured",
            "section_id": "cc03caa6-0f55-4e5b-8a44-e0cbcce404a5",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:47:13.000",
        "event": "mapping_hover",
        "id": "SHyBQdFjj6Hy48Fk2YIj"
    },
    {
        "data": {
            "structured_type": "unstructured",
            "section_id": "cc03caa6-0f55-4e5b-8a44-e0cbcce404a5",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:47:13.000",
        "event": "mapping_unhover",
        "id": "Wm6TwstIUfwjtqkYwopL"
    },
    {
        "data": {
            "structured_type": "unstructured",
            "section_id": "cc03caa6-0f55-4e5b-8a44-e0cbcce404a5",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:47:13.000",
        "event": "mapping_unhover",
        "id": "g1mkpp6rtVXZIGfJXkRk"
    },
    {
        "data": {
            "mapping_index": 1,
            "structured_type": "unstructured",
            "section_id": "cc03caa6-0f55-4e5b-8a44-e0cbcce404a5",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:47:13.000",
        "event": "mapping_hover",
        "id": "hKeik38J8p00hNyDKJBb"
    },
    {
        "data": {
            "structured_type": "unstructured",
            "section_id": "cc03caa6-0f55-4e5b-8a44-e0cbcce404a5",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:47:13.000",
        "event": "mapping_unhover",
        "id": "i4PzkPQKg8xjEEgsqI4U"
    },
    {
        "data": {
            "mapping_index": 5,
            "structured_type": "unstructured",
            "section_id": "cc03caa6-0f55-4e5b-8a44-e0cbcce404a5",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:47:13.000",
        "event": "mapping_hover",
        "id": "j2GzyyJ2QTRx6VeDO1ww"
    },
    {
        "data": {
            "structured_type": "unstructured",
            "section_id": "cc03caa6-0f55-4e5b-8a44-e0cbcce404a5",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:47:13.000",
        "event": "mapping_unhover",
        "id": "nX5iUDa8aWy3MsMCJncp"
    },
    {
        "data": {
            "structured_type": "unstructured",
            "section_id": "cc03caa6-0f55-4e5b-8a44-e0cbcce404a5",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:47:13.000",
        "event": "mapping_unhover",
        "id": "q6YvuoDmqBLrouESAdg6"
    },
    {
        "data": {
            "mapping_index": 5,
            "structured_type": "unstructured",
            "section_id": "cc03caa6-0f55-4e5b-8a44-e0cbcce404a5",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:47:14.000",
        "event": "mapping_hover",
        "id": "A5T8Ao2mYd0Evj7y6j7l"
    },
    {
        "data": {
            "structured_type": "unstructured",
            "section_id": "cc03caa6-0f55-4e5b-8a44-e0cbcce404a5",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:47:14.000",
        "event": "mapping_unhover",
        "id": "cgOnYQXcU3y6k5NeIegg"
    },
    {
        "data": {
            "mapping_index": 7,
            "structured_type": "unstructured",
            "section_id": "cc03caa6-0f55-4e5b-8a44-e0cbcce404a5",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:47:14.000",
        "event": "mapping_hover",
        "id": "d4syBGA1J4q7g8Scoeoj"
    },
    {
        "data": {
            "structured_type": "unstructured",
            "section_id": "cc03caa6-0f55-4e5b-8a44-e0cbcce404a5",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:47:14.000",
        "event": "mapping_unhover",
        "id": "jQw5wIaITKVlPoGfbX7d"
    },
    {
        "data": {
            "structured_type": "unstructured",
            "section_id": "cc03caa6-0f55-4e5b-8a44-e0cbcce404a5",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:47:14.000",
        "event": "mapping_unhover",
        "id": "oaNSbujQlyUsOb8cTewo"
    },
    {
        "data": {
            "mapping_index": 2,
            "structured_type": "unstructured",
            "section_id": "cc03caa6-0f55-4e5b-8a44-e0cbcce404a5",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:47:14.000",
        "event": "mapping_hover",
        "id": "pD1DdFfxE45ItfUC0Zd9"
    },
    {
        "data": {
            "mapping_index": 1,
            "structured_type": "unstructured",
            "section_id": "cc03caa6-0f55-4e5b-8a44-e0cbcce404a5",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:47:14.000",
        "event": "mapping_hover",
        "id": "qZfNzN82qUHIwfK2w6ay"
    },
    {
        "data": {
            "structured_type": "unstructured",
            "section_id": "cc03caa6-0f55-4e5b-8a44-e0cbcce404a5",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:47:14.000",
        "event": "mapping_unhover",
        "id": "rtYPPfuPefRmtovrk0ny"
    },
    {
        "data": {
            "structured_type": "unstructured",
            "section_id": "cc03caa6-0f55-4e5b-8a44-e0cbcce404a5",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:47:15.000",
        "event": "mapping_unhover",
        "id": "1yAJb84bbs1o55UbbU6T"
    },
    {
        "data": {
            "structured_type": "unstructured",
            "section_id": "cc03caa6-0f55-4e5b-8a44-e0cbcce404a5",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:47:15.000",
        "event": "mapping_unhover",
        "id": "2kY8DINwssXN4M60yScm"
    },
    {
        "data": {
            "mapping_index": 6,
            "structured_type": "unstructured",
            "section_id": "cc03caa6-0f55-4e5b-8a44-e0cbcce404a5",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:47:15.000",
        "event": "mapping_hover",
        "id": "EuH3qoGD7169NxBOSoNq"
    },
    {
        "data": {
            "mapping_index": 4,
            "structured_type": "unstructured",
            "section_id": "cc03caa6-0f55-4e5b-8a44-e0cbcce404a5",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:47:15.000",
        "event": "mapping_hover",
        "id": "KDhL7jXXrEzAgcjANRUR"
    },
    {
        "data": {
            "mapping_index": 5,
            "structured_type": "unstructured",
            "section_id": "cc03caa6-0f55-4e5b-8a44-e0cbcce404a5",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:47:15.000",
        "event": "mapping_hover",
        "id": "MmQpGrNEM0YSdjkCSh1r"
    },
    {
        "data": {
            "mapping_index": 1,
            "structured_type": "unstructured",
            "section_id": "cc03caa6-0f55-4e5b-8a44-e0cbcce404a5",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:47:15.000",
        "event": "mapping_hover",
        "id": "ZBKymf1sfLimoOBiNmNV"
    },
    {
        "data": {
            "structured_type": "unstructured",
            "section_id": "cc03caa6-0f55-4e5b-8a44-e0cbcce404a5",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:47:15.000",
        "event": "mapping_unhover",
        "id": "jMkbr0mfU3SH63XQb3Ef"
    },
    {
        "data": {
            "mapping_index": 2,
            "structured_type": "unstructured",
            "section_id": "cc03caa6-0f55-4e5b-8a44-e0cbcce404a5",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:47:15.000",
        "event": "mapping_hover",
        "id": "pIM63YW572V51JOaDEHX"
    },
    {
        "data": {
            "structured_type": "unstructured",
            "section_id": "cc03caa6-0f55-4e5b-8a44-e0cbcce404a5",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:47:15.000",
        "event": "mapping_unhover",
        "id": "tsqxaRPnuvUKbeS73cNJ"
    },
    {
        "data": {
            "structured_type": "unstructured",
            "section_id": "cc03caa6-0f55-4e5b-8a44-e0cbcce404a5",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:47:16.000",
        "event": "mapping_unhover",
        "id": "9YzzGXsljwW04f2zTbzO"
    },
    {
        "data": {
            "structured_type": "unstructured",
            "section_id": "cc03caa6-0f55-4e5b-8a44-e0cbcce404a5",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:47:16.000",
        "event": "mapping_unhover",
        "id": "AkzrYsxPDAUDOVNNE9Zh"
    },
    {
        "data": {
            "mapping_index": 7,
            "structured_type": "unstructured",
            "section_id": "cc03caa6-0f55-4e5b-8a44-e0cbcce404a5",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:47:16.000",
        "event": "mapping_hover",
        "id": "J02OQynhLflY12YCRrR8"
    },
    {
        "data": {
            "structured_type": "unstructured",
            "section_id": "cc03caa6-0f55-4e5b-8a44-e0cbcce404a5",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:47:17.000",
        "event": "mapping_unhover",
        "id": "383dWV9wGlIdEG1uOve1"
    },
    {
        "data": {
            "structured_type": "unstructured",
            "section_id": "cc03caa6-0f55-4e5b-8a44-e0cbcce404a5",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:47:17.000",
        "event": "mapping_unhover",
        "id": "4x7h4AvQAQDb4GSV7id8"
    },
    {
        "data": {
            "structured_type": "unstructured",
            "section_id": "cc03caa6-0f55-4e5b-8a44-e0cbcce404a5",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:47:17.000",
        "event": "mapping_unhover",
        "id": "5xe0aR69lpNdvtLmX584"
    },
    {
        "data": {
            "mapping_index": 1,
            "structured_type": "unstructured",
            "section_id": "cc03caa6-0f55-4e5b-8a44-e0cbcce404a5",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:47:17.000",
        "event": "mapping_hover",
        "id": "MTxFhZUAXct0rp6w7v9H"
    },
    {
        "data": {
            "mapping_index": 4,
            "structured_type": "unstructured",
            "section_id": "cc03caa6-0f55-4e5b-8a44-e0cbcce404a5",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:47:17.000",
        "event": "mapping_hover",
        "id": "aFArflltEDoxKSsQaF7l"
    },
    {
        "data": {
            "structured_type": "unstructured",
            "section_id": "cc03caa6-0f55-4e5b-8a44-e0cbcce404a5",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:47:17.000",
        "event": "mapping_unhover",
        "id": "bCKgstbArkNCyukddP7B"
    },
    {
        "data": {
            "structured_type": "unstructured",
            "section_id": "cc03caa6-0f55-4e5b-8a44-e0cbcce404a5",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:47:17.000",
        "event": "mapping_unhover",
        "id": "cY00zqtgHYX5NjZHieMo"
    },
    {
        "data": {
            "mapping_index": 5,
            "structured_type": "unstructured",
            "section_id": "cc03caa6-0f55-4e5b-8a44-e0cbcce404a5",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:47:17.000",
        "event": "mapping_hover",
        "id": "f0FMNN0LUYoLU6iSmi86"
    },
    {
        "data": {
            "mapping_index": 2,
            "structured_type": "unstructured",
            "section_id": "cc03caa6-0f55-4e5b-8a44-e0cbcce404a5",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:47:17.000",
        "event": "mapping_hover",
        "id": "i1fu8yFU46xaaTUZo210"
    },
    {
        "data": {
            "mapping_index": 5,
            "structured_type": "unstructured",
            "section_id": "cc03caa6-0f55-4e5b-8a44-e0cbcce404a5",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:47:17.000",
        "event": "mapping_hover",
        "id": "oWcqtHpHkkJssAafEeWb"
    },
    {
        "data": {
            "structured_type": "unstructured",
            "section_id": "cc03caa6-0f55-4e5b-8a44-e0cbcce404a5",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:47:19.000",
        "event": "mapping_unhover",
        "id": "4s5Wq4oRtWNM8dGcIJ0a"
    },
    {
        "data": {
            "mapping_index": 4,
            "structured_type": "unstructured",
            "section_id": "cc03caa6-0f55-4e5b-8a44-e0cbcce404a5",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:47:19.000",
        "event": "mapping_hover",
        "id": "I6IoJ4QgwSnzU1MZmNgm"
    },
    {
        "data": {
            "structured_type": "unstructured",
            "section_id": "cc03caa6-0f55-4e5b-8a44-e0cbcce404a5",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:47:19.000",
        "event": "mapping_unhover",
        "id": "MlJygA1tFTf2zfMMuxBy"
    },
    {
        "data": {
            "structured_type": "unstructured",
            "section_id": "cc03caa6-0f55-4e5b-8a44-e0cbcce404a5",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:47:19.000",
        "event": "mapping_unhover",
        "id": "SufUXtwBnoTDRY0i3wx5"
    },
    {
        "data": {
            "mapping_index": 2,
            "structured_type": "unstructured",
            "section_id": "cc03caa6-0f55-4e5b-8a44-e0cbcce404a5",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:47:19.000",
        "event": "mapping_hover",
        "id": "Y6z8crOaF5H9KqTUdnbQ"
    },
    {
        "data": {
            "structured": "unstructured",
            "section_id": "cc03caa6-0f55-4e5b-8a44-e0cbcce404a5",
            "summary": "The main() function loads MVP data, splits it into training and test sets by year, and trains an XGBoost ranking model. It predicts ranks for the test years, evaluates performance using NDCG, and prints the results. Finally, it generates plots to visualize prediction errors for the test years.",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:47:19.000",
        "event": "click_edit_in_prompt",
        "id": "n6sdIx5EdVSUTD4uniEQ"
    },
    {
        "data": {
            "mapping_index": 3,
            "structured_type": "unstructured",
            "section_id": "cc03caa6-0f55-4e5b-8a44-e0cbcce404a5",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:47:19.000",
        "event": "mapping_hover",
        "id": "siGUp60Bmti6P2TD3QlZ"
    },
    {
        "data": {
            "mapping_index": 4,
            "structured_type": "unstructured",
            "section_id": "cc03caa6-0f55-4e5b-8a44-e0cbcce404a5",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:47:29.000",
        "event": "mapping_hover",
        "id": "jKsqDTBpkrBUgdrOpt1I"
    },
    {
        "data": {
            "mapping_index": 2,
            "structured_type": "unstructured",
            "section_id": "cc03caa6-0f55-4e5b-8a44-e0cbcce404a5",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:47:30.000",
        "event": "mapping_hover",
        "id": "8ZNZmPPKmb9wrq39a6wH"
    },
    {
        "data": {
            "mapping_index": 3,
            "structured_type": "unstructured",
            "section_id": "cc03caa6-0f55-4e5b-8a44-e0cbcce404a5",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:47:30.000",
        "event": "mapping_hover",
        "id": "GzxWIYnqTTleLNg64cFI"
    },
    {
        "data": {
            "before_detail_level": "medium",
            "after_detail_level": "high",
            "before_structured": "unstructured",
            "section_id": "cc03caa6-0f55-4e5b-8a44-e0cbcce404a5",
            "after_structured": "unstructured"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:47:30.000",
        "event": "change_summary_level",
        "id": "WBCZRXp41oOlbMWcNgk3"
    },
    {
        "data": {
            "structured_type": "unstructured",
            "section_id": "cc03caa6-0f55-4e5b-8a44-e0cbcce404a5",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:47:30.000",
        "event": "mapping_unhover",
        "id": "ZqtzXMwWuqQXphCaZnT2"
    },
    {
        "data": {
            "structured_type": "unstructured",
            "section_id": "cc03caa6-0f55-4e5b-8a44-e0cbcce404a5",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:47:30.000",
        "event": "mapping_unhover",
        "id": "acshoBvU9aMFymb44PQf"
    },
    {
        "data": {
            "structured_type": "unstructured",
            "section_id": "cc03caa6-0f55-4e5b-8a44-e0cbcce404a5",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:47:30.000",
        "event": "mapping_unhover",
        "id": "lPV0cLy9Mq3lFUddhwZt"
    },
    {
        "data": {
            "mapping_index": 0,
            "structured_type": "unstructured",
            "section_id": "cc03caa6-0f55-4e5b-8a44-e0cbcce404a5",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:47:30.000",
        "event": "mapping_hover",
        "id": "puxVfC3OU5wNOIPV5uW2"
    },
    {
        "data": {
            "structured_type": "unstructured",
            "section_id": "cc03caa6-0f55-4e5b-8a44-e0cbcce404a5",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:47:30.000",
        "event": "mapping_unhover",
        "id": "v4sepzGyU7UaUb4gi3sD"
    },
    {
        "data": {
            "mapping_index": 2,
            "structured_type": "unstructured",
            "section_id": "cc03caa6-0f55-4e5b-8a44-e0cbcce404a5",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:47:31.000",
        "event": "mapping_hover",
        "id": "Csa2e8lR91z8zO6w2zy5"
    },
    {
        "data": {
            "structured_type": "unstructured",
            "section_id": "cc03caa6-0f55-4e5b-8a44-e0cbcce404a5",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:47:31.000",
        "event": "mapping_unhover",
        "id": "NfAKnBsYBMyHpoUhPFJH"
    },
    {
        "data": {
            "mapping_index": 0,
            "structured_type": "unstructured",
            "section_id": "cc03caa6-0f55-4e5b-8a44-e0cbcce404a5",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:47:31.000",
        "event": "mapping_hover",
        "id": "lZZclysXuvfEbvLinytn"
    },
    {
        "data": {
            "structured_type": "unstructured",
            "section_id": "cc03caa6-0f55-4e5b-8a44-e0cbcce404a5",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:47:32.000",
        "event": "mapping_unhover",
        "id": "Nzfxe3nok5P3NYI2PlO7"
    },
    {
        "data": {
            "structured_type": "unstructured",
            "section_id": "cc03caa6-0f55-4e5b-8a44-e0cbcce404a5",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:47:32.000",
        "event": "mapping_unhover",
        "id": "Sfmo4D33YmoJSO4v0HC4"
    },
    {
        "data": {
            "structured_type": "unstructured",
            "section_id": "cc03caa6-0f55-4e5b-8a44-e0cbcce404a5",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:47:32.000",
        "event": "mapping_unhover",
        "id": "YKHicOf5jyhhdwLngtVv"
    },
    {
        "data": {
            "structured_type": "unstructured",
            "section_id": "cc03caa6-0f55-4e5b-8a44-e0cbcce404a5",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:47:32.000",
        "event": "mapping_unhover",
        "id": "jjAGOIUwlh5hhAY8gvvc"
    },
    {
        "data": {
            "mapping_index": 2,
            "structured_type": "unstructured",
            "section_id": "cc03caa6-0f55-4e5b-8a44-e0cbcce404a5",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:47:32.000",
        "event": "mapping_hover",
        "id": "lryxNYNTFBhcdoPcproX"
    },
    {
        "data": {
            "structured_type": "unstructured",
            "section_id": "cc03caa6-0f55-4e5b-8a44-e0cbcce404a5",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:47:32.000",
        "event": "mapping_unhover",
        "id": "oUiM59677GfqV459sJGi"
    },
    {
        "data": {
            "mapping_index": 1,
            "structured_type": "unstructured",
            "section_id": "cc03caa6-0f55-4e5b-8a44-e0cbcce404a5",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:47:32.000",
        "event": "mapping_hover",
        "id": "tMTIcFIueLGGWhKLGl8v"
    },
    {
        "data": {
            "mapping_index": 3,
            "structured_type": "unstructured",
            "section_id": "cc03caa6-0f55-4e5b-8a44-e0cbcce404a5",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:47:32.000",
        "event": "mapping_hover",
        "id": "xDOrL6U9LUwYndTT3SeK"
    },
    {
        "data": {
            "mapping_index": 4,
            "structured_type": "unstructured",
            "section_id": "cc03caa6-0f55-4e5b-8a44-e0cbcce404a5",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:47:32.000",
        "event": "mapping_hover",
        "id": "zJa5d97jiZ3ipIt48xQR"
    },
    {
        "data": {
            "mapping_index": 7,
            "structured_type": "unstructured",
            "section_id": "cc03caa6-0f55-4e5b-8a44-e0cbcce404a5",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:47:33.000",
        "event": "mapping_hover",
        "id": "1XYNCHrHajFs584GhraC"
    },
    {
        "data": {
            "mapping_index": 2,
            "structured_type": "unstructured",
            "section_id": "cc03caa6-0f55-4e5b-8a44-e0cbcce404a5",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:47:33.000",
        "event": "mapping_hover",
        "id": "QY9LqbDjFXdncXJltfUK"
    },
    {
        "data": {
            "mapping_index": 5,
            "structured_type": "unstructured",
            "section_id": "cc03caa6-0f55-4e5b-8a44-e0cbcce404a5",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:47:33.000",
        "event": "mapping_hover",
        "id": "TNptVnQKdrXxD5XUWzFz"
    },
    {
        "data": {
            "structured_type": "unstructured",
            "section_id": "cc03caa6-0f55-4e5b-8a44-e0cbcce404a5",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:47:33.000",
        "event": "mapping_unhover",
        "id": "ffotePdGbz9bVYVHoXWc"
    },
    {
        "data": {
            "structured": "unstructured",
            "section_id": "cc03caa6-0f55-4e5b-8a44-e0cbcce404a5",
            "summary": "The main() function orchestrates the workflow for training and evaluating an XGBoost ranking model on MVP data. It first loads the data, splits it into training (all but the last two years) and test (the last two years) sets, and prepares group information for ranking. The function then initializes and trains an XGBRanker using the training data and group sizes. After training, it predicts scores for the test set, computes predicted ranks within each year, and evaluates the model's performance using the NDCG metric. Results, including predicted scores and ranks, are printed for the test years, and bar plots are generated to visualize prediction errors for 2024 and 2025.",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:47:33.000",
        "event": "click_edit_in_prompt",
        "id": "jMcEFXXVi4yQ6KeTTc9k"
    },
    {
        "data": {
            "structured_type": "unstructured",
            "section_id": "cc03caa6-0f55-4e5b-8a44-e0cbcce404a5",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:47:33.000",
        "event": "mapping_unhover",
        "id": "lBfnEMMg0M2vqmlfR7Yj"
    },
    {
        "data": {
            "mapping_index": 4,
            "structured_type": "unstructured",
            "section_id": "cc03caa6-0f55-4e5b-8a44-e0cbcce404a5",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:47:33.000",
        "event": "mapping_hover",
        "id": "oZHxMdOssH1gMEQnS26g"
    },
    {
        "data": {
            "structured_type": "unstructured",
            "section_id": "cc03caa6-0f55-4e5b-8a44-e0cbcce404a5",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:47:33.000",
        "event": "mapping_unhover",
        "id": "obxXd2rhLJGuQZUSJZf3"
    },
    {
        "data": {
            "structured_type": "unstructured",
            "section_id": "cc03caa6-0f55-4e5b-8a44-e0cbcce404a5",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:47:33.000",
        "event": "mapping_unhover",
        "id": "sBd1s057oIDYJpQlxvN0"
    },
    {
        "data": {
            "mapping_index": 9,
            "structured_type": "unstructured",
            "section_id": "cc03caa6-0f55-4e5b-8a44-e0cbcce404a5",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:47:33.000",
        "event": "mapping_hover",
        "id": "waoVG67hjyDmggPXBGsQ"
    },
    {
        "data": {
            "structured_type": "unstructured",
            "section_id": "cc03caa6-0f55-4e5b-8a44-e0cbcce404a5",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:47:33.000",
        "event": "mapping_unhover",
        "id": "zWYPcEqASn22USFRPEXP"
    },
    {
        "data": {
            "mapping_index": 8,
            "structured_type": "unstructured",
            "section_id": "cc03caa6-0f55-4e5b-8a44-e0cbcce404a5",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:47:37.000",
        "event": "mapping_hover",
        "id": "8MdI1QUvykIbWbIKNUFO"
    },
    {
        "data": {
            "mapping_index": 6,
            "structured_type": "unstructured",
            "section_id": "cc03caa6-0f55-4e5b-8a44-e0cbcce404a5",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:47:37.000",
        "event": "mapping_hover",
        "id": "IAYlUTg50aKDUWGLg6Me"
    },
    {
        "data": {
            "structured_type": "unstructured",
            "section_id": "cc03caa6-0f55-4e5b-8a44-e0cbcce404a5",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:47:37.000",
        "event": "mapping_unhover",
        "id": "KPIKcOv3w6rarnXNp8gu"
    },
    {
        "data": {
            "structured_type": "unstructured",
            "section_id": "cc03caa6-0f55-4e5b-8a44-e0cbcce404a5",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:47:37.000",
        "event": "mapping_unhover",
        "id": "NLcpMltJYadMpby0buwt"
    },
    {
        "data": {
            "structured_type": "unstructured",
            "section_id": "cc03caa6-0f55-4e5b-8a44-e0cbcce404a5",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:47:37.000",
        "event": "mapping_unhover",
        "id": "NbCKX4JrKTgHao6Sstvv"
    },
    {
        "data": {
            "mapping_index": 4,
            "structured_type": "unstructured",
            "section_id": "cc03caa6-0f55-4e5b-8a44-e0cbcce404a5",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:47:37.000",
        "event": "mapping_hover",
        "id": "aBTPiAkhXzkeP4OOAwop"
    },
    {
        "data": {
            "mapping_index": 5,
            "structured_type": "unstructured",
            "section_id": "cc03caa6-0f55-4e5b-8a44-e0cbcce404a5",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:47:37.000",
        "event": "mapping_hover",
        "id": "uomxBnnmviuZ0Ysyk1H5"
    },
    {
        "data": {
            "structured_type": "unstructured",
            "section_id": "cc03caa6-0f55-4e5b-8a44-e0cbcce404a5",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:47:38.000",
        "event": "mapping_unhover",
        "id": "1R2453CF06WXhzzymHlM"
    },
    {
        "data": {
            "structured_type": "unstructured",
            "section_id": "cc03caa6-0f55-4e5b-8a44-e0cbcce404a5",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:47:38.000",
        "event": "mapping_unhover",
        "id": "IoPnmVIsYeSuuiU33cvc"
    },
    {
        "data": {
            "mapping_index": 5,
            "structured_type": "unstructured",
            "section_id": "cc03caa6-0f55-4e5b-8a44-e0cbcce404a5",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:47:38.000",
        "event": "mapping_hover",
        "id": "KCXfsp049Bkkn7EwNuGf"
    },
    {
        "data": {
            "mapping_index": 7,
            "structured_type": "unstructured",
            "section_id": "cc03caa6-0f55-4e5b-8a44-e0cbcce404a5",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:47:38.000",
        "event": "mapping_hover",
        "id": "aEZITXpf50i2KAHzgq5N"
    },
    {
        "data": {
            "structured_type": "unstructured",
            "section_id": "cc03caa6-0f55-4e5b-8a44-e0cbcce404a5",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:47:38.000",
        "event": "mapping_unhover",
        "id": "e78plBpFOQ10NIyBXmzX"
    },
    {
        "data": {
            "mapping_index": 6,
            "structured_type": "unstructured",
            "section_id": "cc03caa6-0f55-4e5b-8a44-e0cbcce404a5",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:47:38.000",
        "event": "mapping_hover",
        "id": "w2imyOKXYY5vmfaoyQQ7"
    },
    {
        "data": {
            "structured_type": "unstructured",
            "section_id": "cc03caa6-0f55-4e5b-8a44-e0cbcce404a5",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:47:39.000",
        "event": "mapping_unhover",
        "id": "0dVCb6DXbyumo4vmF7rE"
    },
    {
        "data": {
            "mapping_index": 4,
            "structured_type": "unstructured",
            "section_id": "cc03caa6-0f55-4e5b-8a44-e0cbcce404a5",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:47:39.000",
        "event": "mapping_hover",
        "id": "6IzgfNrcHi1BuBnH5UDg"
    },
    {
        "data": {
            "mapping_index": 3,
            "structured_type": "unstructured",
            "section_id": "cc03caa6-0f55-4e5b-8a44-e0cbcce404a5",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:47:39.000",
        "event": "mapping_hover",
        "id": "H7khbm5gxJ5JcxXTChGD"
    },
    {
        "data": {
            "structured_type": "unstructured",
            "section_id": "cc03caa6-0f55-4e5b-8a44-e0cbcce404a5",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:47:39.000",
        "event": "mapping_unhover",
        "id": "QgWEONigjctULlIl5hRe"
    },
    {
        "data": {
            "mapping_index": 2,
            "structured_type": "unstructured",
            "section_id": "cc03caa6-0f55-4e5b-8a44-e0cbcce404a5",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:47:39.000",
        "event": "mapping_hover",
        "id": "cKgQwipmwa08sIOKd6bw"
    },
    {
        "data": {
            "structured_type": "unstructured",
            "section_id": "cc03caa6-0f55-4e5b-8a44-e0cbcce404a5",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:47:39.000",
        "event": "mapping_unhover",
        "id": "iPkq9H5Fw0rdkihvtf1w"
    },
    {
        "data": {
            "structured_type": "unstructured",
            "section_id": "cc03caa6-0f55-4e5b-8a44-e0cbcce404a5",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:47:40.000",
        "event": "mapping_unhover",
        "id": "V5bPKslPtmFt7vEvTDk7"
    },
    {
        "data": {
            "structured_type": "unstructured",
            "section_id": "cc03caa6-0f55-4e5b-8a44-e0cbcce404a5",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:47:40.000",
        "event": "mapping_unhover",
        "id": "clxwwb9KbqjmWh54vO7N"
    },
    {
        "data": {
            "mapping_index": 3,
            "structured_type": "unstructured",
            "section_id": "cc03caa6-0f55-4e5b-8a44-e0cbcce404a5",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:47:40.000",
        "event": "mapping_hover",
        "id": "eT1j748Ya9xEOPwlEvne"
    },
    {
        "data": {
            "mapping_index": 4,
            "structured_type": "unstructured",
            "section_id": "cc03caa6-0f55-4e5b-8a44-e0cbcce404a5",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:47:40.000",
        "event": "mapping_hover",
        "id": "s4bRZrtSuyjSYrhTbqdg"
    },
    {
        "data": {
            "structured_type": "unstructured",
            "section_id": "cc03caa6-0f55-4e5b-8a44-e0cbcce404a5",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:47:41.000",
        "event": "mapping_unhover",
        "id": "gu5oJrfkyIF3LAjuIX5B"
    },
    {
        "data": {
            "mapping_index": 5,
            "structured_type": "unstructured",
            "section_id": "cc03caa6-0f55-4e5b-8a44-e0cbcce404a5",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:47:41.000",
        "event": "mapping_hover",
        "id": "i60xmm1ic2rg7zZi37c2"
    },
    {
        "data": {
            "structured_type": "unstructured",
            "section_id": "cc03caa6-0f55-4e5b-8a44-e0cbcce404a5",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:47:42.000",
        "event": "mapping_unhover",
        "id": "NV0VGHklekOEsJaT9wZg"
    },
    {
        "data": {
            "mapping_index": 7,
            "structured_type": "unstructured",
            "section_id": "cc03caa6-0f55-4e5b-8a44-e0cbcce404a5",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:47:42.000",
        "event": "mapping_hover",
        "id": "OlUqYQBTVxtNgCtGAhAB"
    },
    {
        "data": {
            "mapping_index": 8,
            "structured_type": "unstructured",
            "section_id": "cc03caa6-0f55-4e5b-8a44-e0cbcce404a5",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:47:42.000",
        "event": "mapping_hover",
        "id": "PiGvzVIdnhjfXFUJGyvF"
    },
    {
        "data": {
            "structured_type": "unstructured",
            "section_id": "cc03caa6-0f55-4e5b-8a44-e0cbcce404a5",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:47:42.000",
        "event": "mapping_unhover",
        "id": "QTc2lGPENN5sTAvHXWyi"
    },
    {
        "data": {
            "mapping_index": 6,
            "structured_type": "unstructured",
            "section_id": "cc03caa6-0f55-4e5b-8a44-e0cbcce404a5",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:47:42.000",
        "event": "mapping_hover",
        "id": "WGKJJD19JyZLluuAUevR"
    },
    {
        "data": {
            "structured_type": "unstructured",
            "section_id": "cc03caa6-0f55-4e5b-8a44-e0cbcce404a5",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:47:42.000",
        "event": "mapping_unhover",
        "id": "n5PwFpYtGGsYw13BAupZ"
    },
    {
        "data": {
            "structured_type": "unstructured",
            "section_id": "cc03caa6-0f55-4e5b-8a44-e0cbcce404a5",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:47:44.000",
        "event": "mapping_unhover",
        "id": "8yJUL7nFJ36dm8CENZWN"
    },
    {
        "data": {
            "structured_type": "unstructured",
            "section_id": "cc03caa6-0f55-4e5b-8a44-e0cbcce404a5",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:47:44.000",
        "event": "mapping_unhover",
        "id": "GrhjBPcowgTDt6JndSRB"
    },
    {
        "data": {
            "mapping_index": 9,
            "structured_type": "unstructured",
            "section_id": "cc03caa6-0f55-4e5b-8a44-e0cbcce404a5",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:47:44.000",
        "event": "mapping_hover",
        "id": "gjqBiPIbd8SMNYERnNE4"
    },
    {
        "data": {
            "structured_type": "unstructured",
            "section_id": "cc03caa6-0f55-4e5b-8a44-e0cbcce404a5",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:47:45.000",
        "event": "mapping_unhover",
        "id": "7KcHx731X0g2YgxIZ0RY"
    },
    {
        "data": {
            "mapping_index": 2,
            "structured_type": "unstructured",
            "section_id": "cc03caa6-0f55-4e5b-8a44-e0cbcce404a5",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:47:45.000",
        "event": "mapping_hover",
        "id": "7OmcDhXWqNnEbIMe1Y05"
    },
    {
        "data": {
            "structured_type": "unstructured",
            "section_id": "cc03caa6-0f55-4e5b-8a44-e0cbcce404a5",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:47:45.000",
        "event": "mapping_unhover",
        "id": "8akc1Rt1pvTc2d3mHJXG"
    },
    {
        "data": {
            "mapping_index": 5,
            "structured_type": "unstructured",
            "section_id": "cc03caa6-0f55-4e5b-8a44-e0cbcce404a5",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:47:45.000",
        "event": "mapping_hover",
        "id": "FvTUzijfsBoSGQlhbW3H"
    },
    {
        "data": {
            "mapping_index": 4,
            "structured_type": "unstructured",
            "section_id": "cc03caa6-0f55-4e5b-8a44-e0cbcce404a5",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:47:45.000",
        "event": "mapping_hover",
        "id": "GXmlf5Ov1Y2KwXnrbQLW"
    },
    {
        "data": {
            "structured_type": "unstructured",
            "section_id": "cc03caa6-0f55-4e5b-8a44-e0cbcce404a5",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:47:45.000",
        "event": "mapping_unhover",
        "id": "gAC6X0rM9HfFev39lADQ"
    },
    {
        "data": {
            "mapping_index": 4,
            "structured_type": "unstructured",
            "section_id": "cc03caa6-0f55-4e5b-8a44-e0cbcce404a5",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:47:45.000",
        "event": "mapping_hover",
        "id": "hjg0jgFoL1KUCkg5b0ez"
    },
    {
        "data": {
            "structured_type": "unstructured",
            "section_id": "cc03caa6-0f55-4e5b-8a44-e0cbcce404a5",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:47:46.000",
        "event": "mapping_unhover",
        "id": "D7OcrHoOS1mIQbrtitx6"
    },
    {
        "data": {
            "mapping_index": 4,
            "structured_type": "unstructured",
            "section_id": "cc03caa6-0f55-4e5b-8a44-e0cbcce404a5",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:47:47.000",
        "event": "mapping_hover",
        "id": "0jzIxay9tJBUTTR5QkC3"
    },
    {
        "data": {
            "structured_type": "unstructured",
            "section_id": "cc03caa6-0f55-4e5b-8a44-e0cbcce404a5",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:47:47.000",
        "event": "mapping_unhover",
        "id": "GpXhAjS4pnErqe7hFLfF"
    },
    {
        "data": {
            "mapping_index": 4,
            "structured_type": "unstructured",
            "section_id": "cc03caa6-0f55-4e5b-8a44-e0cbcce404a5",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:47:47.000",
        "event": "mapping_hover",
        "id": "HbCwnH5MRy7AvlTDkVbP"
    },
    {
        "data": {
            "mapping_index": 5,
            "structured_type": "unstructured",
            "section_id": "cc03caa6-0f55-4e5b-8a44-e0cbcce404a5",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:47:47.000",
        "event": "mapping_hover",
        "id": "JiviuxDpzPrQVCqvv9K6"
    },
    {
        "data": {
            "mapping_index": 3,
            "structured_type": "unstructured",
            "section_id": "cc03caa6-0f55-4e5b-8a44-e0cbcce404a5",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:47:47.000",
        "event": "mapping_hover",
        "id": "QLZyaSaGZsSfr5f5OK0X"
    },
    {
        "data": {
            "structured_type": "unstructured",
            "section_id": "cc03caa6-0f55-4e5b-8a44-e0cbcce404a5",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:47:47.000",
        "event": "mapping_unhover",
        "id": "cVNKwwyhLNgDH14uzWB4"
    },
    {
        "data": {
            "mapping_index": 4,
            "structured_type": "unstructured",
            "section_id": "cc03caa6-0f55-4e5b-8a44-e0cbcce404a5",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:47:47.000",
        "event": "mapping_hover",
        "id": "cWC9QmYcdkl4AfKcU40I"
    },
    {
        "data": {
            "mapping_index": 3,
            "structured_type": "unstructured",
            "section_id": "cc03caa6-0f55-4e5b-8a44-e0cbcce404a5",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:47:47.000",
        "event": "mapping_hover",
        "id": "l3FKXqULFBlSuo1VW6El"
    },
    {
        "data": {
            "structured_type": "unstructured",
            "section_id": "cc03caa6-0f55-4e5b-8a44-e0cbcce404a5",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:47:47.000",
        "event": "mapping_unhover",
        "id": "lZMISidGtz8EnFuHOpo1"
    },
    {
        "data": {
            "structured_type": "unstructured",
            "section_id": "cc03caa6-0f55-4e5b-8a44-e0cbcce404a5",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:47:47.000",
        "event": "mapping_unhover",
        "id": "reruxP4Nz1QflCKlvJe2"
    },
    {
        "data": {
            "structured_type": "unstructured",
            "section_id": "cc03caa6-0f55-4e5b-8a44-e0cbcce404a5",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:47:47.000",
        "event": "mapping_unhover",
        "id": "vMocn5yIZ4nMQXEbBtHp"
    },
    {
        "data": {
            "structured_type": "unstructured",
            "section_id": "cc03caa6-0f55-4e5b-8a44-e0cbcce404a5",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:47:48.000",
        "event": "mapping_unhover",
        "id": "8m4IQqBsfXBUOIQzZE7V"
    },
    {
        "data": {
            "structured_type": "unstructured",
            "section_id": "cc03caa6-0f55-4e5b-8a44-e0cbcce404a5",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:47:48.000",
        "event": "mapping_unhover",
        "id": "C65VgLCnL5gQ1mAw6NF5"
    },
    {
        "data": {
            "mapping_index": 6,
            "structured_type": "unstructured",
            "section_id": "cc03caa6-0f55-4e5b-8a44-e0cbcce404a5",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:47:48.000",
        "event": "mapping_hover",
        "id": "FpAHj6en1TPIQvdhKsVx"
    },
    {
        "data": {
            "mapping_index": 5,
            "structured_type": "unstructured",
            "section_id": "cc03caa6-0f55-4e5b-8a44-e0cbcce404a5",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:47:48.000",
        "event": "mapping_hover",
        "id": "LecNIh299WZG35vJPMWm"
    },
    {
        "data": {
            "mapping_index": 6,
            "structured_type": "unstructured",
            "section_id": "cc03caa6-0f55-4e5b-8a44-e0cbcce404a5",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:47:48.000",
        "event": "mapping_hover",
        "id": "Qf3eqTx7YaReetnqntzx"
    },
    {
        "data": {
            "structured_type": "unstructured",
            "section_id": "cc03caa6-0f55-4e5b-8a44-e0cbcce404a5",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:47:48.000",
        "event": "mapping_unhover",
        "id": "UCGaBj89Vk9YiKf6Sm0r"
    },
    {
        "data": {
            "mapping_index": 7,
            "structured_type": "unstructured",
            "section_id": "cc03caa6-0f55-4e5b-8a44-e0cbcce404a5",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:47:48.000",
        "event": "mapping_hover",
        "id": "X2iwDzBz7EGWzaGk7KFc"
    },
    {
        "data": {
            "structured_type": "unstructured",
            "section_id": "cc03caa6-0f55-4e5b-8a44-e0cbcce404a5",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:47:48.000",
        "event": "mapping_unhover",
        "id": "fJFkDAn3eSQbnFqR3dFk"
    },
    {
        "data": {
            "structured_type": "unstructured",
            "section_id": "cc03caa6-0f55-4e5b-8a44-e0cbcce404a5",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:47:49.000",
        "event": "mapping_unhover",
        "id": "7mDEN6Ok6Puvy1hpNLNg"
    },
    {
        "data": {
            "structured_type": "unstructured",
            "section_id": "cc03caa6-0f55-4e5b-8a44-e0cbcce404a5",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:47:49.000",
        "event": "mapping_unhover",
        "id": "9mUge35BxK5hkTEHjpyL"
    },
    {
        "data": {
            "mapping_index": 3,
            "structured_type": "unstructured",
            "section_id": "cc03caa6-0f55-4e5b-8a44-e0cbcce404a5",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:47:49.000",
        "event": "mapping_hover",
        "id": "DbRoUQqw4i5qLz50kfgx"
    },
    {
        "data": {
            "mapping_index": 4,
            "structured_type": "unstructured",
            "section_id": "cc03caa6-0f55-4e5b-8a44-e0cbcce404a5",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:47:49.000",
        "event": "mapping_hover",
        "id": "G8q3YDNJSes2woH7kOyc"
    },
    {
        "data": {
            "mapping_index": 2,
            "structured_type": "unstructured",
            "section_id": "cc03caa6-0f55-4e5b-8a44-e0cbcce404a5",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:47:49.000",
        "event": "mapping_hover",
        "id": "tw6nqoaLmSihG9U5izee"
    },
    {
        "data": {
            "structured_type": "unstructured",
            "section_id": "cc03caa6-0f55-4e5b-8a44-e0cbcce404a5",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:47:49.000",
        "event": "mapping_unhover",
        "id": "xHXNZEiCGcu1fOM5WxrQ"
    },
    {
        "data": {
            "mapping_index": 3,
            "structured_type": "unstructured",
            "section_id": "cc03caa6-0f55-4e5b-8a44-e0cbcce404a5",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:47:51.000",
        "event": "mapping_hover",
        "id": "2NwnrnHonqDRSRqCSzak"
    },
    {
        "data": {
            "structured_type": "unstructured",
            "section_id": "cc03caa6-0f55-4e5b-8a44-e0cbcce404a5",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:47:51.000",
        "event": "mapping_unhover",
        "id": "RTs88TB7TyRh2pzs8GOo"
    },
    {
        "data": {
            "structured_type": "unstructured",
            "section_id": "cc03caa6-0f55-4e5b-8a44-e0cbcce404a5",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:47:51.000",
        "event": "mapping_unhover",
        "id": "aJZKi5eqW1sPGpBuTktc"
    },
    {
        "data": {
            "mapping_index": 2,
            "structured_type": "unstructured",
            "section_id": "cc03caa6-0f55-4e5b-8a44-e0cbcce404a5",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:47:51.000",
        "event": "mapping_hover",
        "id": "kHJc8O4NxFS7wqaqsRx1"
    },
    {
        "data": {
            "mapping_index": 4,
            "structured_type": "unstructured",
            "section_id": "cc03caa6-0f55-4e5b-8a44-e0cbcce404a5",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:47:52.000",
        "event": "mapping_hover",
        "id": "IRVfWf4p2zvPqYOqDJYJ"
    },
    {
        "data": {
            "mapping_index": 3,
            "structured_type": "unstructured",
            "section_id": "cc03caa6-0f55-4e5b-8a44-e0cbcce404a5",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:47:52.000",
        "event": "mapping_hover",
        "id": "LAbomdNRBJfCpQ3Vgtd3"
    },
    {
        "data": {
            "structured_type": "unstructured",
            "section_id": "cc03caa6-0f55-4e5b-8a44-e0cbcce404a5",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:47:52.000",
        "event": "mapping_unhover",
        "id": "Q5BzeBdNyqRIOBvXEXGA"
    },
    {
        "data": {
            "structured_type": "unstructured",
            "section_id": "cc03caa6-0f55-4e5b-8a44-e0cbcce404a5",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:47:52.000",
        "event": "mapping_unhover",
        "id": "RsdmkjvSL1DiaWHXkSZX"
    },
    {
        "data": {
            "structured_type": "unstructured",
            "section_id": "cc03caa6-0f55-4e5b-8a44-e0cbcce404a5",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:47:52.000",
        "event": "mapping_unhover",
        "id": "iy1gH1yrWg428KguYa4d"
    },
    {
        "data": {
            "mapping_index": 5,
            "structured_type": "unstructured",
            "section_id": "cc03caa6-0f55-4e5b-8a44-e0cbcce404a5",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:47:52.000",
        "event": "mapping_hover",
        "id": "ksxZWRYYd1eR2bsK1vVM"
    },
    {
        "data": {
            "mapping_index": 9,
            "structured_type": "unstructured",
            "section_id": "cc03caa6-0f55-4e5b-8a44-e0cbcce404a5",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:47:57.000",
        "event": "mapping_hover",
        "id": "825kduftsyjE2dbHSilD"
    },
    {
        "data": {
            "mapping_index": 7,
            "structured_type": "unstructured",
            "section_id": "cc03caa6-0f55-4e5b-8a44-e0cbcce404a5",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:47:57.000",
        "event": "mapping_hover",
        "id": "Fl2zMG5YLTPlOwhQ6Wsk"
    },
    {
        "data": {
            "structured_type": "unstructured",
            "section_id": "cc03caa6-0f55-4e5b-8a44-e0cbcce404a5",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:47:57.000",
        "event": "mapping_unhover",
        "id": "LZJhlqfeYOVNus8L5zmb"
    },
    {
        "data": {
            "structured_type": "unstructured",
            "section_id": "cc03caa6-0f55-4e5b-8a44-e0cbcce404a5",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:47:57.000",
        "event": "mapping_unhover",
        "id": "SjG2JQThWvNSOC8F5DuX"
    },
    {
        "data": {
            "structured_type": "unstructured",
            "section_id": "cc03caa6-0f55-4e5b-8a44-e0cbcce404a5",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:47:57.000",
        "event": "mapping_unhover",
        "id": "TTLQu1IGOj7dP0mpQwEs"
    },
    {
        "data": {
            "mapping_index": 8,
            "structured_type": "unstructured",
            "section_id": "cc03caa6-0f55-4e5b-8a44-e0cbcce404a5",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:47:57.000",
        "event": "mapping_hover",
        "id": "xFLkySgAFzdWn8oPdIcl"
    },
    {
        "data": {
            "structured_type": "unstructured",
            "section_id": "cc03caa6-0f55-4e5b-8a44-e0cbcce404a5",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:47:57.000",
        "event": "mapping_unhover",
        "id": "xV83kKVf5J5RzzP2jcAo"
    },
    {
        "data": {
            "structured_type": "unstructured",
            "section_id": "cc03caa6-0f55-4e5b-8a44-e0cbcce404a5",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:48:11.000",
        "event": "mapping_unhover",
        "id": "4mCbfr8EEI0mpJWG6sSw"
    },
    {
        "data": {
            "structured_type": "unstructured",
            "section_id": "cc03caa6-0f55-4e5b-8a44-e0cbcce404a5",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:48:11.000",
        "event": "mapping_unhover",
        "id": "7aLLx2jNnqYUGrEXNafz"
    },
    {
        "data": {
            "mapping_index": 8,
            "structured_type": "unstructured",
            "section_id": "cc03caa6-0f55-4e5b-8a44-e0cbcce404a5",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:48:11.000",
        "event": "mapping_hover",
        "id": "8xqV2zbGsw1o7CCCRfjw"
    },
    {
        "data": {
            "structured_type": "unstructured",
            "section_id": "cc03caa6-0f55-4e5b-8a44-e0cbcce404a5",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:48:11.000",
        "event": "mapping_unhover",
        "id": "DapPJOAZRJAAjCBBGkOG"
    },
    {
        "data": {
            "structured_type": "unstructured",
            "section_id": "cc03caa6-0f55-4e5b-8a44-e0cbcce404a5",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:48:11.000",
        "event": "mapping_unhover",
        "id": "MMRlJ0XsVftH5AK9ZnWo"
    },
    {
        "data": {
            "mapping_index": 9,
            "structured_type": "unstructured",
            "section_id": "cc03caa6-0f55-4e5b-8a44-e0cbcce404a5",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:48:11.000",
        "event": "mapping_hover",
        "id": "ODVTwmwJHnuN4WBBrEbT"
    },
    {
        "data": {
            "structured_type": "unstructured",
            "section_id": "cc03caa6-0f55-4e5b-8a44-e0cbcce404a5",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:48:11.000",
        "event": "mapping_unhover",
        "id": "QlbQYeowkpqOt5zEwvfC"
    },
    {
        "data": {
            "mapping_index": 6,
            "structured_type": "unstructured",
            "section_id": "cc03caa6-0f55-4e5b-8a44-e0cbcce404a5",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:48:11.000",
        "event": "mapping_hover",
        "id": "T4RjnCkPAqMZPm9xEtlc"
    },
    {
        "data": {
            "structured_type": "unstructured",
            "section_id": "cc03caa6-0f55-4e5b-8a44-e0cbcce404a5",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:48:11.000",
        "event": "mapping_unhover",
        "id": "ZuMFi0gRqZvhodUoW1Xe"
    },
    {
        "data": {
            "mapping_index": 7,
            "structured_type": "unstructured",
            "section_id": "cc03caa6-0f55-4e5b-8a44-e0cbcce404a5",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:48:11.000",
        "event": "mapping_hover",
        "id": "eYJx3pGgP3OoESm4fGHJ"
    },
    {
        "data": {
            "structured_type": "unstructured",
            "section_id": "cc03caa6-0f55-4e5b-8a44-e0cbcce404a5",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:48:11.000",
        "event": "mapping_unhover",
        "id": "iPz0bSTBGAelk5tNIMB3"
    },
    {
        "data": {
            "mapping_index": 4,
            "structured_type": "unstructured",
            "section_id": "cc03caa6-0f55-4e5b-8a44-e0cbcce404a5",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:48:11.000",
        "event": "mapping_hover",
        "id": "ofut2TIR7k91SthuIx39"
    },
    {
        "data": {
            "mapping_index": 5,
            "structured_type": "unstructured",
            "section_id": "cc03caa6-0f55-4e5b-8a44-e0cbcce404a5",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:48:11.000",
        "event": "mapping_hover",
        "id": "pvhREHHVwrPWdjdFMuxY"
    },
    {
        "data": {
            "mapping_index": 0,
            "structured_type": "unstructured",
            "section_id": "cc03caa6-0f55-4e5b-8a44-e0cbcce404a5",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:48:11.000",
        "event": "mapping_hover",
        "id": "ualDtofD5xMKdoaFPvla"
    },
    {
        "data": {
            "mapping_index": 9,
            "structured_type": "unstructured",
            "section_id": "cc03caa6-0f55-4e5b-8a44-e0cbcce404a5",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:48:23.000",
        "event": "mapping_hover",
        "id": "HF03gsI1QDbnu6NteGEW"
    },
    {
        "data": {
            "mapping_index": 4,
            "structured_type": "unstructured",
            "section_id": "cc03caa6-0f55-4e5b-8a44-e0cbcce404a5",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:48:23.000",
        "event": "mapping_hover",
        "id": "SuP7KvR6MrsQVmP1X83X"
    },
    {
        "data": {
            "structured_type": "unstructured",
            "section_id": "cc03caa6-0f55-4e5b-8a44-e0cbcce404a5",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:48:23.000",
        "event": "mapping_unhover",
        "id": "vvfrdjWBNQEHU3nd8jMG"
    },
    {
        "data": {
            "structured_type": "unstructured",
            "section_id": "cc03caa6-0f55-4e5b-8a44-e0cbcce404a5",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:48:23.000",
        "event": "mapping_unhover",
        "id": "zL1SNw5o2IBfm4c47Nfd"
    },
    {
        "data": {
            "structured_type": "unstructured",
            "section_id": "cc03caa6-0f55-4e5b-8a44-e0cbcce404a5",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:48:30.000",
        "event": "mapping_unhover",
        "id": "FmlnkFlpbFrkWmdavFth"
    },
    {
        "data": {
            "mapping_index": 8,
            "structured_type": "unstructured",
            "section_id": "cc03caa6-0f55-4e5b-8a44-e0cbcce404a5",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:48:30.000",
        "event": "mapping_hover",
        "id": "HgdMiHCELEmtS28LGMfT"
    },
    {
        "data": {
            "structured_type": "unstructured",
            "section_id": "cc03caa6-0f55-4e5b-8a44-e0cbcce404a5",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:48:30.000",
        "event": "mapping_unhover",
        "id": "IvsNiUvS5smwuNrmsYlj"
    },
    {
        "data": {
            "structured_type": "unstructured",
            "section_id": "cc03caa6-0f55-4e5b-8a44-e0cbcce404a5",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:48:30.000",
        "event": "mapping_unhover",
        "id": "U8BoS9QbKJAFyTOnlU0C"
    },
    {
        "data": {
            "mapping_index": 9,
            "structured_type": "unstructured",
            "section_id": "cc03caa6-0f55-4e5b-8a44-e0cbcce404a5",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:48:30.000",
        "event": "mapping_hover",
        "id": "aena2HrEcQJA3V6SXVC8"
    },
    {
        "data": {
            "mapping_index": 4,
            "structured_type": "unstructured",
            "section_id": "cc03caa6-0f55-4e5b-8a44-e0cbcce404a5",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:48:30.000",
        "event": "mapping_hover",
        "id": "bywE9p5923hbWxYy6wpJ"
    },
    {
        "data": {
            "structured_type": "unstructured",
            "section_id": "cc03caa6-0f55-4e5b-8a44-e0cbcce404a5",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:48:30.000",
        "event": "mapping_unhover",
        "id": "jyB3UVDExYGUMO0M4fzS"
    },
    {
        "data": {
            "mapping_index": 0,
            "structured_type": "unstructured",
            "section_id": "cc03caa6-0f55-4e5b-8a44-e0cbcce404a5",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:48:30.000",
        "event": "mapping_hover",
        "id": "sj9xkDezUwPwZyO4JPRU"
    },
    {
        "data": {
            "mapping_index": 8,
            "structured_type": "unstructured",
            "section_id": "cc03caa6-0f55-4e5b-8a44-e0cbcce404a5",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:48:32.000",
        "event": "mapping_hover",
        "id": "0gRVIrhapysT3yaPjgFT"
    },
    {
        "data": {
            "mapping_index": 9,
            "structured_type": "unstructured",
            "section_id": "cc03caa6-0f55-4e5b-8a44-e0cbcce404a5",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:48:32.000",
        "event": "mapping_hover",
        "id": "9t5ns2gV3pTPriQbjKmm"
    },
    {
        "data": {
            "structured_type": "unstructured",
            "section_id": "cc03caa6-0f55-4e5b-8a44-e0cbcce404a5",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:48:32.000",
        "event": "mapping_unhover",
        "id": "ex39EiSjt4XJjqc4rwGb"
    },
    {
        "data": {
            "mapping_index": 0,
            "structured_type": "unstructured",
            "section_id": "cc03caa6-0f55-4e5b-8a44-e0cbcce404a5",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:48:33.000",
        "event": "mapping_hover",
        "id": "10C53Oyu3eQfacECmTnp"
    },
    {
        "data": {
            "mapping_index": 5,
            "structured_type": "unstructured",
            "section_id": "cc03caa6-0f55-4e5b-8a44-e0cbcce404a5",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:48:33.000",
        "event": "mapping_hover",
        "id": "EkfjdflInBsbfDUMozQ0"
    },
    {
        "data": {
            "mapping_index": 4,
            "structured_type": "unstructured",
            "section_id": "cc03caa6-0f55-4e5b-8a44-e0cbcce404a5",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:48:33.000",
        "event": "mapping_hover",
        "id": "JJEcOF9fcllSSvLrRnWi"
    },
    {
        "data": {
            "mapping_index": 2,
            "structured_type": "unstructured",
            "section_id": "cc03caa6-0f55-4e5b-8a44-e0cbcce404a5",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:48:33.000",
        "event": "mapping_hover",
        "id": "QVGAElwaOcvmo1qEryeT"
    },
    {
        "data": {
            "structured_type": "unstructured",
            "section_id": "cc03caa6-0f55-4e5b-8a44-e0cbcce404a5",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:48:33.000",
        "event": "mapping_unhover",
        "id": "Rsk6ZAcwbvnODrZbK7w9"
    },
    {
        "data": {
            "structured_type": "unstructured",
            "section_id": "cc03caa6-0f55-4e5b-8a44-e0cbcce404a5",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:48:33.000",
        "event": "mapping_unhover",
        "id": "TSER16RYacr2vGQBaYXj"
    },
    {
        "data": {
            "structured_type": "unstructured",
            "section_id": "cc03caa6-0f55-4e5b-8a44-e0cbcce404a5",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:48:33.000",
        "event": "mapping_unhover",
        "id": "cF0Dh6SiMch5k54bRBtQ"
    },
    {
        "data": {
            "mapping_index": 7,
            "structured_type": "unstructured",
            "section_id": "cc03caa6-0f55-4e5b-8a44-e0cbcce404a5",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:48:33.000",
        "event": "mapping_hover",
        "id": "oOgtL8UKI2viWQrmdKT8"
    },
    {
        "data": {
            "structured_type": "unstructured",
            "section_id": "cc03caa6-0f55-4e5b-8a44-e0cbcce404a5",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:48:33.000",
        "event": "mapping_unhover",
        "id": "p3TXslhVja4YciQViqZH"
    },
    {
        "data": {
            "structured_type": "unstructured",
            "section_id": "cc03caa6-0f55-4e5b-8a44-e0cbcce404a5",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:48:33.000",
        "event": "mapping_unhover",
        "id": "sT7yD8D8NJKA4PrMnRl2"
    },
    {
        "data": {
            "structured_type": "unstructured",
            "section_id": "cc03caa6-0f55-4e5b-8a44-e0cbcce404a5",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:48:33.000",
        "event": "mapping_unhover",
        "id": "w9GAA0bTw4StJ0AZy8GY"
    },
    {
        "data": {
            "mapping_index": 0,
            "structured_type": "unstructured",
            "section_id": "cc03caa6-0f55-4e5b-8a44-e0cbcce404a5",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:48:46.000",
        "event": "mapping_hover",
        "id": "DM7vZzrfmPIRGs7ljXz0"
    },
    {
        "data": {
            "structured_type": "unstructured",
            "section_id": "cc03caa6-0f55-4e5b-8a44-e0cbcce404a5",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:48:46.000",
        "event": "mapping_unhover",
        "id": "dtaMqhe3xMrKaaoCe0iJ"
    },
    {
        "data": {
            "structured_type": "unstructured",
            "section_id": "cc03caa6-0f55-4e5b-8a44-e0cbcce404a5",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:48:46.000",
        "event": "mapping_unhover",
        "id": "mUyL33GhC2F0RLZkXfZO"
    },
    {
        "data": {
            "mapping_index": 2,
            "structured_type": "unstructured",
            "section_id": "cc03caa6-0f55-4e5b-8a44-e0cbcce404a5",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:48:46.000",
        "event": "mapping_hover",
        "id": "sUN7Qu5RLVRLhNC5cB3r"
    },
    {
        "data": {
            "mapping_index": 1,
            "structured_type": "unstructured",
            "section_id": "cc03caa6-0f55-4e5b-8a44-e0cbcce404a5",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:48:46.000",
        "event": "mapping_hover",
        "id": "xzgQYWRj8CFiYopezz9R"
    },
    {
        "data": {
            "structured_type": "unstructured",
            "section_id": "cc03caa6-0f55-4e5b-8a44-e0cbcce404a5",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:48:58.000",
        "event": "mapping_unhover",
        "id": "gVnOS7psEHBbxvimLGnG"
    },
    {
        "data": {
            "mapping_index": 4,
            "structured_type": "unstructured",
            "section_id": "cc03caa6-0f55-4e5b-8a44-e0cbcce404a5",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:48:58.000",
        "event": "mapping_hover",
        "id": "lJeT8IdIYTLuWe5IsrOz"
    },
    {
        "data": {
            "structured_type": "unstructured",
            "section_id": "cc03caa6-0f55-4e5b-8a44-e0cbcce404a5",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:48:59.000",
        "event": "mapping_unhover",
        "id": "60szXTbIATKJNXkzhjkx"
    },
    {
        "data": {
            "mapping_index": 8,
            "structured_type": "unstructured",
            "section_id": "cc03caa6-0f55-4e5b-8a44-e0cbcce404a5",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:48:59.000",
        "event": "mapping_hover",
        "id": "6gy2QZN8xZQkB6S3cZ1U"
    },
    {
        "data": {
            "structured_type": "unstructured",
            "section_id": "cc03caa6-0f55-4e5b-8a44-e0cbcce404a5",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:48:59.000",
        "event": "mapping_unhover",
        "id": "9wlADREnB9IVeBaH0YC9"
    },
    {
        "data": {
            "structured_type": "unstructured",
            "section_id": "cc03caa6-0f55-4e5b-8a44-e0cbcce404a5",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:48:59.000",
        "event": "mapping_unhover",
        "id": "AG0Jpj7xrGcIgu45Xbqk"
    },
    {
        "data": {
            "mapping_index": 7,
            "structured_type": "unstructured",
            "section_id": "cc03caa6-0f55-4e5b-8a44-e0cbcce404a5",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:48:59.000",
        "event": "mapping_hover",
        "id": "BSIZ2nvxqGUnaIsGCTg3"
    },
    {
        "data": {
            "structured_type": "unstructured",
            "section_id": "cc03caa6-0f55-4e5b-8a44-e0cbcce404a5",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:48:59.000",
        "event": "mapping_unhover",
        "id": "bZ5n1m8397Z0iOFdVajn"
    },
    {
        "data": {
            "mapping_index": 5,
            "structured_type": "unstructured",
            "section_id": "cc03caa6-0f55-4e5b-8a44-e0cbcce404a5",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:48:59.000",
        "event": "mapping_hover",
        "id": "c2BwCP42yabH3v8W4EdV"
    },
    {
        "data": {
            "mapping_index": 9,
            "structured_type": "unstructured",
            "section_id": "cc03caa6-0f55-4e5b-8a44-e0cbcce404a5",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:48:59.000",
        "event": "mapping_hover",
        "id": "ckNcp1kASuGHaTlRR7Bc"
    },
    {
        "data": {
            "structured_type": "unstructured",
            "section_id": "cc03caa6-0f55-4e5b-8a44-e0cbcce404a5",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:48:59.000",
        "event": "mapping_unhover",
        "id": "gl7Wob4b88WpyRHhp0kZ"
    },
    {
        "data": {
            "instruction": "When creating the XGBRanker model, test the n_estimators values to be 100, 1000, and 2000, provide the NDCG scores, and give the entire predicted scores and ranks for the model with the best NDCG score.",
            "section_id": "cc03caa6-0f55-4e5b-8a44-e0cbcce404a5"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:49:01.000",
        "event": "commit_direct_instruction",
        "id": "qfalDPV11bS0SZ9UgB89"
    },
    {
        "data": {
            "instruction": "When creating the XGBRanker model, test the n_estimators values to be 100, 1000, and 2000, provide the NDCG scores, and give the entire predicted scores and ranks for the model with the best NDCG score.",
            "original_code": "def main():\n    X, y, group, df = load_data()\n\n    # Train-test split on years\n    unique_years = df[\"Year\"].unique()\n    train_years, test_years = (\n        unique_years[:-2],  # train: 2015-2023\n        unique_years[-2:],  # test: 2024-2025\n    )\n\n    train_idx = df[\"Year\"].isin(train_years)\n    test_idx = df[\"Year\"].isin(test_years)\n\n    X_train, X_test = X[train_idx], X[test_idx]\n    y_train, y_test = y[train_idx], y[test_idx]\n\n    # Group sizes\n    train_groups = df[train_idx].groupby(\"Year\").size().to_numpy()\n    test_groups = df[test_idx].groupby(\"Year\").size().to_numpy()\n\n    # Model\n    model = XGBRanker(\n        objective=\"rank:pairwise\",\n        learning_rate=0.1,\n        n_estimators=1000,\n        max_depth=4,\n        random_state=42,\n    )\n\n    print(\"Training XGBoostRanker...\")\n    model.fit(X_train, y_train, group=train_groups)\n\n    # Predict, sort, and evaluate\n    y_pred = model.predict(X_test)\n    df.loc[test_idx, \"PredictedScore\"] = y_pred\n    df.loc[test_idx, \"PredictedRank\"] = (\n        df.loc[test_idx]\n        .groupby(\"Year\")[\"PredictedScore\"]\n        .rank(ascending=False, method=\"first\")\n    )\n\n    ndcg = evaluate_ndcg(y_test.to_numpy(), y_pred, test_groups)\n    print(f\"NDCG Score on test years {test_years.tolist()}: {ndcg:.4f}\")\n\n    # Show results\n    print(df[test_idx][[\"Year\", \"Name\", \"Rank\", \"PredictedScore\", \"PredictedRank\"]])\n    plot_ranking_predictions(df, 2024)\n    plot_ranking_predictions(df, 2025)\n\n",
            "updated_code": "def main():\n    X, y, group, df = load_data()\n\n    # Train-test split on years\n    unique_years = df[\"Year\"].unique()\n    train_years, test_years = (\n        unique_years[:-2],  # train: 2015-2023\n        unique_years[-2:],  # test: 2024-2025\n    )\n\n    train_idx = df[\"Year\"].isin(train_years)\n    test_idx = df[\"Year\"].isin(test_years)\n\n    X_train, X_test = X[train_idx], X[test_idx]\n    y_train, y_test = y[train_idx], y[test_idx]\n\n    # Group sizes\n    train_groups = df[train_idx].groupby(\"Year\").size().to_numpy()\n    test_groups = df[test_idx].groupby(\"Year\").size().to_numpy()\n\n    n_estimators_list = [100, 1000, 2000]\n    ndcg_scores = []\n    predictions = []\n    predicted_ranks = []\n\n    for n_estimators in n_estimators_list:\n        model = XGBRanker(\n            objective=\"rank:pairwise\",\n            learning_rate=0.1,\n            n_estimators=n_estimators,\n            max_depth=4,\n            random_state=42,\n        )\n\n        print(f\"Training XGBoostRanker with n_estimators={n_estimators}...\")\n        model.fit(X_train, y_train, group=train_groups)\n\n        # Predict, sort, and evaluate\n        y_pred = model.predict(X_test)\n        pred_ranks = (\n            pd.Series(y_pred, index=df[test_idx].index)\n            .groupby(df.loc[test_idx, \"Year\"])\n            .rank(ascending=False, method=\"first\")\n        )\n        ndcg = evaluate_ndcg(y_test.to_numpy(), y_pred, test_groups)\n        ndcg_scores.append(ndcg)\n        predictions.append(y_pred)\n        predicted_ranks.append(pred_ranks)\n        print(f\"NDCG Score with n_estimators={n_estimators}: {ndcg:.4f}\")\n\n    # Find best model\n    best_idx = int(np.argmax(ndcg_scores))\n    best_n_estimators = n_estimators_list[best_idx]\n    best_pred = predictions[best_idx]\n    best_pred_rank = predicted_ranks[best_idx]\n\n    print(f\"\\nBest n_estimators: {best_n_estimators} with NDCG Score: {ndcg_scores[best_idx]:.4f}\\n\")\n\n    # Assign best predictions and ranks to df\n    df.loc[test_idx, \"PredictedScore\"] = best_pred\n    df.loc[test_idx, \"PredictedRank\"] = best_pred_rank\n\n    # Show results for best model\n    print(df[test_idx][[\"Year\", \"Name\", \"Rank\", \"PredictedScore\", \"PredictedRank\"]])\n    plot_ranking_predictions(df, 2024)\n    plot_ranking_predictions(df, 2025)"
        },
        "source": "backend",
        "timestamp": "2025-08-23 10:49:06.000",
        "event": "modify_direct_instruction",
        "id": "RMp5iOsNGdO81U1mvfRp"
    },
    {
        "data": {
            "new_code": "def main():\n    X, y, group, df = load_data()\n\n    # Train-test split on years\n    unique_years = df[\"Year\"].unique()\n    train_years, test_years = (\n        unique_years[:-2],  # train: 2015-2023\n        unique_years[-2:],  # test: 2024-2025\n    )\n\n    train_idx = df[\"Year\"].isin(train_years)\n    test_idx = df[\"Year\"].isin(test_years)\n\n    X_train, X_test = X[train_idx], X[test_idx]\n    y_train, y_test = y[train_idx], y[test_idx]\n\n    # Group sizes\n    train_groups = df[train_idx].groupby(\"Year\").size().to_numpy()\n    test_groups = df[test_idx].groupby(\"Year\").size().to_numpy()\n\n    n_estimators_list = [100, 1000, 2000]\n    ndcg_scores = []\n    predictions = []\n    predicted_ranks = []\n\n    for n_estimators in n_estimators_list:\n        model = XGBRanker(\n            objective=\"rank:pairwise\",\n            learning_rate=0.1,\n            n_estimators=n_estimators,\n            max_depth=4,\n            random_state=42,\n        )\n\n        print(f\"Training XGBoostRanker with n_estimators={n_estimators}...\")\n        model.fit(X_train, y_train, group=train_groups)\n\n        # Predict, sort, and evaluate\n        y_pred = model.predict(X_test)\n        pred_ranks = (\n            pd.Series(y_pred, index=df[test_idx].index)\n            .groupby(df.loc[test_idx, \"Year\"])\n            .rank(ascending=False, method=\"first\")\n        )\n        ndcg = evaluate_ndcg(y_test.to_numpy(), y_pred, test_groups)\n        ndcg_scores.append(ndcg)\n        predictions.append(y_pred)\n        predicted_ranks.append(pred_ranks)\n        print(f\"NDCG Score with n_estimators={n_estimators}: {ndcg:.4f}\")\n\n    # Find best model\n    best_idx = int(np.argmax(ndcg_scores))\n    best_n_estimators = n_estimators_list[best_idx]\n    best_pred = predictions[best_idx]\n    best_pred_rank = predicted_ranks[best_idx]\n\n    print(f\"\\nBest n_estimators: {best_n_estimators} with NDCG Score: {ndcg_scores[best_idx]:.4f}\\n\")\n\n    # Assign best predictions and ranks to df\n    df.loc[test_idx, \"PredictedScore\"] = best_pred\n    df.loc[test_idx, \"PredictedRank\"] = best_pred_rank\n\n    # Show results for best model\n    print(df[test_idx][[\"Year\", \"Name\", \"Rank\", \"PredictedScore\", \"PredictedRank\"]])\n    plot_ranking_predictions(df, 2024)\n    plot_ranking_predictions(df, 2025)",
            "old_summary": {
                "medium_unstructured": "The main() function loads MVP data, splits it into training and test sets by year, and trains an XGBoost ranking model. It predicts ranks for the test years, evaluates performance using NDCG, and prints the results. Finally, it generates plots to visualize prediction errors for the test years.",
                "low_structured": "• Trains an XGBoost ranking model on MVP data\n• Evaluates and prints results\n• Plots prediction errors for test years",
                "title": "Summary of the main() Function for MVP Ranking Prediction",
                "medium_structured": "• Loads data and splits it into training and test sets by year\n• Trains an XGBoost ranking model on the training data\n• Predicts and evaluates rankings for the test years\n  ◦ Calculates NDCG score for evaluation\n• Prints results and visualizes prediction errors for 2024 and 2025",
                "high_unstructured": "The main() function orchestrates the workflow for training and evaluating an XGBoost ranking model on MVP data. It first loads the data, splits it into training (all but the last two years) and test (the last two years) sets, and prepares group information for ranking. The function then initializes and trains an XGBRanker using the training data and group sizes. After training, it predicts scores for the test set, computes predicted ranks within each year, and evaluates the model's performance using the NDCG metric. Results, including predicted scores and ranks, are printed for the test years, and bar plots are generated to visualize prediction errors for 2024 and 2025.",
                "high_structured": "• Loads MVP data and splits it into features, labels, groups, and the full DataFrame\n• Splits data by year:\n  ◦ Training set: all years except the last two\n  ◦ Test set: last two years (2024, 2025)\n• Prepares training and test indices, and computes group sizes for ranking\n• Initializes an XGBRanker with specific hyperparameters (pairwise ranking, learning rate, estimators, depth, random state)\n• Trains the model on the training set with group information\n• Makes predictions on the test set:\n  ◦ Stores predicted scores\n  ◦ Calculates predicted ranks within each test year\n• Evaluates model performance using the NDCG metric on the test years\n• Prints detailed results for the test years, including true and predicted ranks and scores\n• Generates and saves bar plots of prediction errors for 2024 and 2025",
                "low_unstructured": "This function trains and evaluates an XGBoost ranking model on MVP data, then visualizes and prints the results."
            },
            "original_code": "def main():\n    X, y, group, df = load_data()\n\n    # Train-test split on years\n    unique_years = df[\"Year\"].unique()\n    train_years, test_years = (\n        unique_years[:-2],  # train: 2015-2023\n        unique_years[-2:],  # test: 2024-2025\n    )\n\n    train_idx = df[\"Year\"].isin(train_years)\n    test_idx = df[\"Year\"].isin(test_years)\n\n    X_train, X_test = X[train_idx], X[test_idx]\n    y_train, y_test = y[train_idx], y[test_idx]\n\n    # Group sizes\n    train_groups = df[train_idx].groupby(\"Year\").size().to_numpy()\n    test_groups = df[test_idx].groupby(\"Year\").size().to_numpy()\n\n    n_estimators_list = [100, 1000, 2000]\n    ndcg_scores = []\n    predictions = []\n    predicted_ranks = []\n\n    for n_estimators in n_estimators_list:\n        model = XGBRanker(\n            objective=\"rank:pairwise\",\n            learning_rate=0.1,\n            n_estimators=n_estimators,\n            max_depth=4,\n            random_state=42,\n        )\n\n        print(f\"Training XGBoostRanker with n_estimators={n_estimators}...\")\n        model.fit(X_train, y_train, group=train_groups)\n\n        # Predict, sort, and evaluate\n        y_pred = model.predict(X_test)\n        pred_ranks = (\n            pd.Series(y_pred, index=df[test_idx].index)\n            .groupby(df.loc[test_idx, \"Year\"])\n            .rank(ascending=False, method=\"first\")\n        )\n        ndcg = evaluate_ndcg(y_test.to_numpy(), y_pred, test_groups)\n        ndcg_scores.append(ndcg)\n        predictions.append(y_pred)\n        predicted_ranks.append(pred_ranks)\n        print(f\"NDCG Score with n_estimators={n_estimators}: {ndcg:.4f}\")\n\n    # Find best model\n    best_idx = int(np.argmax(ndcg_scores))\n    best_n_estimators = n_estimators_list[best_idx]\n    best_pred = predictions[best_idx]\n    best_pred_rank = predicted_ranks[best_idx]\n\n    print(f\"\\nBest n_estimators: {best_n_estimators} with NDCG Score: {ndcg_scores[best_idx]:.4f}\\n\")\n\n    # Assign best predictions and ranks to df\n    df.loc[test_idx, \"PredictedScore\"] = best_pred\n    df.loc[test_idx, \"PredictedRank\"] = best_pred_rank\n\n    # Show results for best model\n    print(df[test_idx][[\"Year\", \"Name\", \"Rank\", \"PredictedScore\", \"PredictedRank\"]])\n    plot_ranking_predictions(df, 2024)\n    plot_ranking_predictions(df, 2025)",
            "new_summary": {
                "medium_unstructured": "The main() function loads MVP data, splits it into training and test sets by year, and trains several XGBoost ranking models with different n_estimators values. It predicts ranks for the test years with each model, evaluates performance using NDCG, selects the best-performing model, and prints the results. Finally, it generates plots to visualize prediction errors for the test years using the best model.",
                "low_structured": "• Trains multiple XGBoost ranking models with varying n_estimators on MVP data\n• Selects the best model based on NDCG score\n• Evaluates and prints results for the best model\n• Plots prediction errors for test years",
                "title": "Summary of the main() Function for MVP Ranking Prediction (with Hyperparameter Search)",
                "medium_structured": "• Loads data and splits it into training and test sets by year\n• Trains several XGBoost ranking models with different n_estimators values on the training data\n• Predicts and evaluates rankings for the test years for each model\n  ◦ Calculates NDCG score for each model\n• Selects the model with the highest NDCG score\n• Prints results and visualizes prediction errors for 2024 and 2025 using the best model",
                "high_unstructured": "The main() function orchestrates the workflow for training and evaluating XGBoost ranking models on MVP data. It first loads the data, splits it into training (all but the last two years) and test (the last two years) sets, and prepares group information for ranking. The function then iteratively initializes and trains XGBRanker models with different n_estimators values using the training data and group sizes. For each model, it predicts scores for the test set, computes predicted ranks within each year, and evaluates performance using the NDCG metric, storing the results. The best model is selected based on the highest NDCG score, and its predicted scores and ranks are assigned to the DataFrame. Results, including predicted scores and ranks for the best model, are printed for the test years, and bar plots are generated to visualize prediction errors for 2024 and 2025.",
                "high_structured": "• Loads MVP data and splits it into features, labels, groups, and the full DataFrame\n• Splits data by year:\n  ◦ Training set: all years except the last two\n  ◦ Test set: last two years (2024, 2025)\n• Prepares training and test indices, and computes group sizes for ranking\n• Iteratively initializes XGBRanker models with different n_estimators values (hyperparameter search)\n  ◦ Trains each model on the training set with group information\n  ◦ Makes predictions on the test set for each model:\n    ▪ Stores predicted scores\n    ▪ Calculates predicted ranks within each test year\n  ◦ Evaluates model performance using the NDCG metric for each model\n• Selects the model with the highest NDCG score\n• Assigns the best model's predicted scores and ranks to the DataFrame\n• Prints detailed results for the test years, including true and predicted ranks and scores for the best model\n• Generates and saves bar plots of prediction errors for 2024 and 2025 using the best model",
                "low_unstructured": "This function trains and evaluates multiple XGBoost ranking models with different n_estimators on MVP data, selects the best model based on NDCG, then visualizes and prints the results."
            }
        },
        "source": "backend",
        "timestamp": "2025-08-23 10:49:20.000",
        "event": "summarize_modified_code",
        "id": "VSad8rjXQceSHHSLFugj"
    },
    {
        "data": {
            "mapping": [
                {
                    "summaryComponent": "trains and evaluates multiple XGBoost ranking models",
                    "codeSegments": [
                        {
                            "line": 99,
                            "code": "for n_estimators in n_estimators_list:"
                        },
                        {
                            "line": 100,
                            "code": "model = XGBRanker("
                        },
                        {
                            "line": 109,
                            "code": "model.fit(X_train, y_train, group=train_groups)"
                        },
                        {
                            "line": 112,
                            "code": "y_pred = model.predict(X_test)"
                        },
                        {
                            "line": 118,
                            "code": "ndcg = evaluate_ndcg(y_test.to_numpy(), y_pred, test_groups)"
                        }
                    ]
                },
                {
                    "summaryComponent": "with different n_estimators",
                    "codeSegments": [
                        {
                            "line": 94,
                            "code": "n_estimators_list = [100, 1000, 2000]"
                        },
                        {
                            "line": 99,
                            "code": "for n_estimators in n_estimators_list:"
                        },
                        {
                            "line": 103,
                            "code": "n_estimators=n_estimators,"
                        }
                    ]
                },
                {
                    "summaryComponent": "on MVP data",
                    "codeSegments": [
                        {
                            "line": 75,
                            "code": "X, y, group, df = load_data()"
                        }
                    ]
                },
                {
                    "summaryComponent": "selects the best model based on NDCG",
                    "codeSegments": [
                        {
                            "line": 119,
                            "code": "ndcg_scores.append(ndcg)"
                        },
                        {
                            "line": 125,
                            "code": "best_idx = int(np.argmax(ndcg_scores))"
                        },
                        {
                            "line": 126,
                            "code": "best_n_estimators = n_estimators_list[best_idx]"
                        }
                    ]
                },
                {
                    "summaryComponent": "then visualizes and prints the results",
                    "codeSegments": [
                        {
                            "line": 137,
                            "code": "print(df[test_idx][[\"Year\", \"Name\", \"Rank\", \"PredictedScore\", \"PredictedRank\"]])"
                        },
                        {
                            "line": 138,
                            "code": "plot_ranking_predictions(df, 2024)"
                        },
                        {
                            "line": 139,
                            "code": "plot_ranking_predictions(df, 2025)"
                        }
                    ]
                }
            ],
            "summary": "This function trains and evaluates multiple XGBoost ranking models with different n_estimators on MVP data, selects the best model based on NDCG, then visualizes and prints the results.",
            "code": "74: def main():\n75:     X, y, group, df = load_data()\n76: \n77:     # Train-test split on years\n78:     unique_years = df[\"Year\"].unique()\n79:     train_years, test_years = (\n80:         unique_years[:-2],  # train: 2015-2023\n81:         unique_years[-2:],  # test: 2024-2025\n82:     )\n83: \n84:     train_idx = df[\"Year\"].isin(train_years)\n85:     test_idx = df[\"Year\"].isin(test_years)\n86: \n87:     X_train, X_test = X[train_idx], X[test_idx]\n88:     y_train, y_test = y[train_idx], y[test_idx]\n89: \n90:     # Group sizes\n91:     train_groups = df[train_idx].groupby(\"Year\").size().to_numpy()\n92:     test_groups = df[test_idx].groupby(\"Year\").size().to_numpy()\n93: \n94:     n_estimators_list = [100, 1000, 2000]\n95:     ndcg_scores = []\n96:     predictions = []\n97:     predicted_ranks = []\n98: \n99:     for n_estimators in n_estimators_list:\n100:         model = XGBRanker(\n101:             objective=\"rank:pairwise\",\n102:             learning_rate=0.1,\n103:             n_estimators=n_estimators,\n104:             max_depth=4,\n105:             random_state=42,\n106:         )\n107: \n108:         print(f\"Training XGBoostRanker with n_estimators={n_estimators}...\")\n109:         model.fit(X_train, y_train, group=train_groups)\n110: \n111:         # Predict, sort, and evaluate\n112:         y_pred = model.predict(X_test)\n113:         pred_ranks = (\n114:             pd.Series(y_pred, index=df[test_idx].index)\n115:             .groupby(df.loc[test_idx, \"Year\"])\n116:             .rank(ascending=False, method=\"first\")\n117:         )\n118:         ndcg = evaluate_ndcg(y_test.to_numpy(), y_pred, test_groups)\n119:         ndcg_scores.append(ndcg)\n120:         predictions.append(y_pred)\n121:         predicted_ranks.append(pred_ranks)\n122:         print(f\"NDCG Score with n_estimators={n_estimators}: {ndcg:.4f}\")\n123: \n124:     # Find best model\n125:     best_idx = int(np.argmax(ndcg_scores))\n126:     best_n_estimators = n_estimators_list[best_idx]\n127:     best_pred = predictions[best_idx]\n128:     best_pred_rank = predicted_ranks[best_idx]\n129: \n130:     print(f\"\\nBest n_estimators: {best_n_estimators} with NDCG Score: {ndcg_scores[best_idx]:.4f}\\n\")\n131: \n132:     # Assign best predictions and ranks to df\n133:     df.loc[test_idx, \"PredictedScore\"] = best_pred\n134:     df.loc[test_idx, \"PredictedRank\"] = best_pred_rank\n135: \n136:     # Show results for best model\n137:     print(df[test_idx][[\"Year\", \"Name\", \"Rank\", \"PredictedScore\", \"PredictedRank\"]])\n138:     plot_ranking_predictions(df, 2024)\n139:     plot_ranking_predictions(df, 2025)"
        },
        "source": "backend",
        "timestamp": "2025-08-23 10:49:23.000",
        "event": "map_summary_code",
        "id": "Ug6MlOdj2KRGFM61I5Ac"
    },
    {
        "data": {
            "mapping": [
                {
                    "summaryComponent": "Trains multiple XGBoost ranking models with varying n_estimators on MVP data",
                    "codeSegments": [
                        {
                            "line": 99,
                            "code": "for n_estimators in n_estimators_list:"
                        },
                        {
                            "line": 100,
                            "code": "model = XGBRanker("
                        },
                        {
                            "line": 109,
                            "code": "model.fit(X_train, y_train, group=train_groups)"
                        }
                    ]
                },
                {
                    "summaryComponent": "Selects the best model based on NDCG score",
                    "codeSegments": [
                        {
                            "line": 125,
                            "code": "best_idx = int(np.argmax(ndcg_scores))"
                        },
                        {
                            "line": 126,
                            "code": "best_n_estimators = n_estimators_list[best_idx]"
                        },
                        {
                            "line": 127,
                            "code": "best_pred = predictions[best_idx]"
                        },
                        {
                            "line": 128,
                            "code": "best_pred_rank = predicted_ranks[best_idx]"
                        }
                    ]
                },
                {
                    "summaryComponent": "Evaluates and prints results for the best model",
                    "codeSegments": [
                        {
                            "line": 130,
                            "code": "print(f\"\\nBest n_estimators: {best_n_estimators} with NDCG Score: {ndcg_scores[best_idx]:.4f}\\n\")"
                        },
                        {
                            "line": 133,
                            "code": "df.loc[test_idx, \"PredictedScore\"] = best_pred"
                        },
                        {
                            "line": 134,
                            "code": "df.loc[test_idx, \"PredictedRank\"] = best_pred_rank"
                        },
                        {
                            "line": 137,
                            "code": "print(df[test_idx][[\"Year\", \"Name\", \"Rank\", \"PredictedScore\", \"PredictedRank\"]])"
                        }
                    ]
                },
                {
                    "summaryComponent": "Plots prediction errors for test years",
                    "codeSegments": [
                        {
                            "line": 138,
                            "code": "plot_ranking_predictions(df, 2024)"
                        },
                        {
                            "line": 139,
                            "code": "plot_ranking_predictions(df, 2025)"
                        }
                    ]
                }
            ],
            "summary": "• Trains multiple XGBoost ranking models with varying n_estimators on MVP data\n• Selects the best model based on NDCG score\n• Evaluates and prints results for the best model\n• Plots prediction errors for test years",
            "code": "74: def main():\n75:     X, y, group, df = load_data()\n76: \n77:     # Train-test split on years\n78:     unique_years = df[\"Year\"].unique()\n79:     train_years, test_years = (\n80:         unique_years[:-2],  # train: 2015-2023\n81:         unique_years[-2:],  # test: 2024-2025\n82:     )\n83: \n84:     train_idx = df[\"Year\"].isin(train_years)\n85:     test_idx = df[\"Year\"].isin(test_years)\n86: \n87:     X_train, X_test = X[train_idx], X[test_idx]\n88:     y_train, y_test = y[train_idx], y[test_idx]\n89: \n90:     # Group sizes\n91:     train_groups = df[train_idx].groupby(\"Year\").size().to_numpy()\n92:     test_groups = df[test_idx].groupby(\"Year\").size().to_numpy()\n93: \n94:     n_estimators_list = [100, 1000, 2000]\n95:     ndcg_scores = []\n96:     predictions = []\n97:     predicted_ranks = []\n98: \n99:     for n_estimators in n_estimators_list:\n100:         model = XGBRanker(\n101:             objective=\"rank:pairwise\",\n102:             learning_rate=0.1,\n103:             n_estimators=n_estimators,\n104:             max_depth=4,\n105:             random_state=42,\n106:         )\n107: \n108:         print(f\"Training XGBoostRanker with n_estimators={n_estimators}...\")\n109:         model.fit(X_train, y_train, group=train_groups)\n110: \n111:         # Predict, sort, and evaluate\n112:         y_pred = model.predict(X_test)\n113:         pred_ranks = (\n114:             pd.Series(y_pred, index=df[test_idx].index)\n115:             .groupby(df.loc[test_idx, \"Year\"])\n116:             .rank(ascending=False, method=\"first\")\n117:         )\n118:         ndcg = evaluate_ndcg(y_test.to_numpy(), y_pred, test_groups)\n119:         ndcg_scores.append(ndcg)\n120:         predictions.append(y_pred)\n121:         predicted_ranks.append(pred_ranks)\n122:         print(f\"NDCG Score with n_estimators={n_estimators}: {ndcg:.4f}\")\n123: \n124:     # Find best model\n125:     best_idx = int(np.argmax(ndcg_scores))\n126:     best_n_estimators = n_estimators_list[best_idx]\n127:     best_pred = predictions[best_idx]\n128:     best_pred_rank = predicted_ranks[best_idx]\n129: \n130:     print(f\"\\nBest n_estimators: {best_n_estimators} with NDCG Score: {ndcg_scores[best_idx]:.4f}\\n\")\n131: \n132:     # Assign best predictions and ranks to df\n133:     df.loc[test_idx, \"PredictedScore\"] = best_pred\n134:     df.loc[test_idx, \"PredictedRank\"] = best_pred_rank\n135: \n136:     # Show results for best model\n137:     print(df[test_idx][[\"Year\", \"Name\", \"Rank\", \"PredictedScore\", \"PredictedRank\"]])\n138:     plot_ranking_predictions(df, 2024)\n139:     plot_ranking_predictions(df, 2025)"
        },
        "source": "backend",
        "timestamp": "2025-08-23 10:49:23.000",
        "event": "map_summary_code",
        "id": "nWUgGv8eGfNFmUtYkazb"
    },
    {
        "data": {
            "mapping": [
                {
                    "summaryComponent": "Loads data and splits it into training and test sets by year",
                    "codeSegments": [
                        {
                            "line": 75,
                            "code": "X, y, group, df = load_data()"
                        },
                        {
                            "line": 78,
                            "code": "unique_years = df[\"Year\"].unique()"
                        },
                        {
                            "line": 79,
                            "code": "train_years, test_years = ("
                        },
                        {
                            "line": 84,
                            "code": "train_idx = df[\"Year\"].isin(train_years)"
                        },
                        {
                            "line": 85,
                            "code": "test_idx = df[\"Year\"].isin(test_years)"
                        },
                        {
                            "line": 87,
                            "code": "X_train, X_test = X[train_idx], X[test_idx]"
                        },
                        {
                            "line": 88,
                            "code": "y_train, y_test = y[train_idx], y[test_idx]"
                        }
                    ]
                },
                {
                    "summaryComponent": "Trains several XGBoost ranking models with different n_estimators values on the training data",
                    "codeSegments": [
                        {
                            "line": 94,
                            "code": "n_estimators_list = [100, 1000, 2000]"
                        },
                        {
                            "line": 99,
                            "code": "for n_estimators in n_estimators_list:"
                        },
                        {
                            "line": 100,
                            "code": "model = XGBRanker("
                        },
                        {
                            "line": 109,
                            "code": "model.fit(X_train, y_train, group=train_groups)"
                        }
                    ]
                },
                {
                    "summaryComponent": "Predicts and evaluates rankings for the test years for each model",
                    "codeSegments": [
                        {
                            "line": 112,
                            "code": "y_pred = model.predict(X_test)"
                        },
                        {
                            "line": 113,
                            "code": "pred_ranks = ("
                        }
                    ]
                },
                {
                    "summaryComponent": "Calculates NDCG score for each model",
                    "codeSegments": [
                        {
                            "line": 118,
                            "code": "ndcg = evaluate_ndcg(y_test.to_numpy(), y_pred, test_groups)"
                        },
                        {
                            "line": 119,
                            "code": "ndcg_scores.append(ndcg)"
                        }
                    ]
                },
                {
                    "summaryComponent": "Selects the model with the highest NDCG score",
                    "codeSegments": [
                        {
                            "line": 125,
                            "code": "best_idx = int(np.argmax(ndcg_scores))"
                        },
                        {
                            "line": 126,
                            "code": "best_n_estimators = n_estimators_list[best_idx]"
                        },
                        {
                            "line": 127,
                            "code": "best_pred = predictions[best_idx]"
                        },
                        {
                            "line": 128,
                            "code": "best_pred_rank = predicted_ranks[best_idx]"
                        }
                    ]
                },
                {
                    "summaryComponent": "Prints results and visualizes prediction errors for 2024 and 2025 using the best model",
                    "codeSegments": [
                        {
                            "line": 137,
                            "code": "print(df[test_idx][[\"Year\", \"Name\", \"Rank\", \"PredictedScore\", \"PredictedRank\"]])"
                        },
                        {
                            "line": 138,
                            "code": "plot_ranking_predictions(df, 2024)"
                        },
                        {
                            "line": 139,
                            "code": "plot_ranking_predictions(df, 2025)"
                        }
                    ]
                }
            ],
            "summary": "• Loads data and splits it into training and test sets by year\n• Trains several XGBoost ranking models with different n_estimators values on the training data\n• Predicts and evaluates rankings for the test years for each model\n  ◦ Calculates NDCG score for each model\n• Selects the model with the highest NDCG score\n• Prints results and visualizes prediction errors for 2024 and 2025 using the best model",
            "code": "74: def main():\n75:     X, y, group, df = load_data()\n76: \n77:     # Train-test split on years\n78:     unique_years = df[\"Year\"].unique()\n79:     train_years, test_years = (\n80:         unique_years[:-2],  # train: 2015-2023\n81:         unique_years[-2:],  # test: 2024-2025\n82:     )\n83: \n84:     train_idx = df[\"Year\"].isin(train_years)\n85:     test_idx = df[\"Year\"].isin(test_years)\n86: \n87:     X_train, X_test = X[train_idx], X[test_idx]\n88:     y_train, y_test = y[train_idx], y[test_idx]\n89: \n90:     # Group sizes\n91:     train_groups = df[train_idx].groupby(\"Year\").size().to_numpy()\n92:     test_groups = df[test_idx].groupby(\"Year\").size().to_numpy()\n93: \n94:     n_estimators_list = [100, 1000, 2000]\n95:     ndcg_scores = []\n96:     predictions = []\n97:     predicted_ranks = []\n98: \n99:     for n_estimators in n_estimators_list:\n100:         model = XGBRanker(\n101:             objective=\"rank:pairwise\",\n102:             learning_rate=0.1,\n103:             n_estimators=n_estimators,\n104:             max_depth=4,\n105:             random_state=42,\n106:         )\n107: \n108:         print(f\"Training XGBoostRanker with n_estimators={n_estimators}...\")\n109:         model.fit(X_train, y_train, group=train_groups)\n110: \n111:         # Predict, sort, and evaluate\n112:         y_pred = model.predict(X_test)\n113:         pred_ranks = (\n114:             pd.Series(y_pred, index=df[test_idx].index)\n115:             .groupby(df.loc[test_idx, \"Year\"])\n116:             .rank(ascending=False, method=\"first\")\n117:         )\n118:         ndcg = evaluate_ndcg(y_test.to_numpy(), y_pred, test_groups)\n119:         ndcg_scores.append(ndcg)\n120:         predictions.append(y_pred)\n121:         predicted_ranks.append(pred_ranks)\n122:         print(f\"NDCG Score with n_estimators={n_estimators}: {ndcg:.4f}\")\n123: \n124:     # Find best model\n125:     best_idx = int(np.argmax(ndcg_scores))\n126:     best_n_estimators = n_estimators_list[best_idx]\n127:     best_pred = predictions[best_idx]\n128:     best_pred_rank = predicted_ranks[best_idx]\n129: \n130:     print(f\"\\nBest n_estimators: {best_n_estimators} with NDCG Score: {ndcg_scores[best_idx]:.4f}\\n\")\n131: \n132:     # Assign best predictions and ranks to df\n133:     df.loc[test_idx, \"PredictedScore\"] = best_pred\n134:     df.loc[test_idx, \"PredictedRank\"] = best_pred_rank\n135: \n136:     # Show results for best model\n137:     print(df[test_idx][[\"Year\", \"Name\", \"Rank\", \"PredictedScore\", \"PredictedRank\"]])\n138:     plot_ranking_predictions(df, 2024)\n139:     plot_ranking_predictions(df, 2025)"
        },
        "source": "backend",
        "timestamp": "2025-08-23 10:49:24.000",
        "event": "map_summary_code",
        "id": "nZQyNNrpf8jlE35Z21Tc"
    },
    {
        "data": {
            "mapping": [
                {
                    "summaryComponent": "loads MVP data",
                    "codeSegments": [
                        {
                            "line": 75,
                            "code": "X, y, group, df = load_data()"
                        }
                    ]
                },
                {
                    "summaryComponent": "splits it into training and test sets by year",
                    "codeSegments": [
                        {
                            "line": 78,
                            "code": "unique_years = df[\"Year\"].unique()"
                        },
                        {
                            "line": 79,
                            "code": "train_years, test_years = ("
                        },
                        {
                            "line": 84,
                            "code": "train_idx = df[\"Year\"].isin(train_years)"
                        },
                        {
                            "line": 85,
                            "code": "test_idx = df[\"Year\"].isin(test_years)"
                        },
                        {
                            "line": 87,
                            "code": "X_train, X_test = X[train_idx], X[test_idx]"
                        },
                        {
                            "line": 88,
                            "code": "y_train, y_test = y[train_idx], y[test_idx]"
                        }
                    ]
                },
                {
                    "summaryComponent": "trains several XGBoost ranking models with different n_estimators values",
                    "codeSegments": [
                        {
                            "line": 94,
                            "code": "n_estimators_list = [100, 1000, 2000]"
                        },
                        {
                            "line": 99,
                            "code": "for n_estimators in n_estimators_list:"
                        },
                        {
                            "line": 100,
                            "code": "model = XGBRanker("
                        }
                    ]
                },
                {
                    "summaryComponent": "predicts ranks for the test years with each model",
                    "codeSegments": [
                        {
                            "line": 112,
                            "code": "y_pred = model.predict(X_test)"
                        },
                        {
                            "line": 113,
                            "code": "pred_ranks = ("
                        }
                    ]
                },
                {
                    "summaryComponent": "evaluates performance using NDCG",
                    "codeSegments": [
                        {
                            "line": 118,
                            "code": "ndcg = evaluate_ndcg(y_test.to_numpy(), y_pred, test_groups)"
                        }
                    ]
                },
                {
                    "summaryComponent": "selects the best-performing model",
                    "codeSegments": [
                        {
                            "line": 125,
                            "code": "best_idx = int(np.argmax(ndcg_scores))"
                        },
                        {
                            "line": 126,
                            "code": "best_n_estimators = n_estimators_list[best_idx]"
                        }
                    ]
                },
                {
                    "summaryComponent": "prints the results",
                    "codeSegments": [
                        {
                            "line": 137,
                            "code": "print(df[test_idx][[\"Year\", \"Name\", \"Rank\", \"PredictedScore\", \"PredictedRank\"]])"
                        }
                    ]
                },
                {
                    "summaryComponent": "generates plots to visualize prediction errors for the test years using the best model",
                    "codeSegments": [
                        {
                            "line": 138,
                            "code": "plot_ranking_predictions(df, 2024)"
                        },
                        {
                            "line": 139,
                            "code": "plot_ranking_predictions(df, 2025)"
                        }
                    ]
                }
            ],
            "summary": "The main() function loads MVP data, splits it into training and test sets by year, and trains several XGBoost ranking models with different n_estimators values. It predicts ranks for the test years with each model, evaluates performance using NDCG, selects the best-performing model, and prints the results. Finally, it generates plots to visualize prediction errors for the test years using the best model.",
            "code": "74: def main():\n75:     X, y, group, df = load_data()\n76: \n77:     # Train-test split on years\n78:     unique_years = df[\"Year\"].unique()\n79:     train_years, test_years = (\n80:         unique_years[:-2],  # train: 2015-2023\n81:         unique_years[-2:],  # test: 2024-2025\n82:     )\n83: \n84:     train_idx = df[\"Year\"].isin(train_years)\n85:     test_idx = df[\"Year\"].isin(test_years)\n86: \n87:     X_train, X_test = X[train_idx], X[test_idx]\n88:     y_train, y_test = y[train_idx], y[test_idx]\n89: \n90:     # Group sizes\n91:     train_groups = df[train_idx].groupby(\"Year\").size().to_numpy()\n92:     test_groups = df[test_idx].groupby(\"Year\").size().to_numpy()\n93: \n94:     n_estimators_list = [100, 1000, 2000]\n95:     ndcg_scores = []\n96:     predictions = []\n97:     predicted_ranks = []\n98: \n99:     for n_estimators in n_estimators_list:\n100:         model = XGBRanker(\n101:             objective=\"rank:pairwise\",\n102:             learning_rate=0.1,\n103:             n_estimators=n_estimators,\n104:             max_depth=4,\n105:             random_state=42,\n106:         )\n107: \n108:         print(f\"Training XGBoostRanker with n_estimators={n_estimators}...\")\n109:         model.fit(X_train, y_train, group=train_groups)\n110: \n111:         # Predict, sort, and evaluate\n112:         y_pred = model.predict(X_test)\n113:         pred_ranks = (\n114:             pd.Series(y_pred, index=df[test_idx].index)\n115:             .groupby(df.loc[test_idx, \"Year\"])\n116:             .rank(ascending=False, method=\"first\")\n117:         )\n118:         ndcg = evaluate_ndcg(y_test.to_numpy(), y_pred, test_groups)\n119:         ndcg_scores.append(ndcg)\n120:         predictions.append(y_pred)\n121:         predicted_ranks.append(pred_ranks)\n122:         print(f\"NDCG Score with n_estimators={n_estimators}: {ndcg:.4f}\")\n123: \n124:     # Find best model\n125:     best_idx = int(np.argmax(ndcg_scores))\n126:     best_n_estimators = n_estimators_list[best_idx]\n127:     best_pred = predictions[best_idx]\n128:     best_pred_rank = predicted_ranks[best_idx]\n129: \n130:     print(f\"\\nBest n_estimators: {best_n_estimators} with NDCG Score: {ndcg_scores[best_idx]:.4f}\\n\")\n131: \n132:     # Assign best predictions and ranks to df\n133:     df.loc[test_idx, \"PredictedScore\"] = best_pred\n134:     df.loc[test_idx, \"PredictedRank\"] = best_pred_rank\n135: \n136:     # Show results for best model\n137:     print(df[test_idx][[\"Year\", \"Name\", \"Rank\", \"PredictedScore\", \"PredictedRank\"]])\n138:     plot_ranking_predictions(df, 2024)\n139:     plot_ranking_predictions(df, 2025)"
        },
        "source": "backend",
        "timestamp": "2025-08-23 10:49:24.000",
        "event": "map_summary_code",
        "id": "tvvJzlW3FhA2DD1X3J32"
    },
    {
        "data": {
            "mapping": [
                {
                    "summaryComponent": "The main() function orchestrates the workflow for training and evaluating XGBoost ranking models on MVP data.",
                    "codeSegments": [
                        {
                            "line": 74,
                            "code": "def main():"
                        }
                    ]
                },
                {
                    "summaryComponent": "It first loads the data,",
                    "codeSegments": [
                        {
                            "line": 75,
                            "code": "X, y, group, df = load_data()"
                        }
                    ]
                },
                {
                    "summaryComponent": "splits it into training (all but the last two years) and test (the last two years) sets,",
                    "codeSegments": [
                        {
                            "line": 78,
                            "code": "unique_years = df[\"Year\"].unique()"
                        },
                        {
                            "line": 79,
                            "code": "train_years, test_years = ("
                        },
                        {
                            "line": 80,
                            "code": "unique_years[:-2],  # train: 2015-2023"
                        },
                        {
                            "line": 81,
                            "code": "unique_years[-2:],  # test: 2024-2025"
                        },
                        {
                            "line": 84,
                            "code": "train_idx = df[\"Year\"].isin(train_years)"
                        },
                        {
                            "line": 85,
                            "code": "test_idx = df[\"Year\"].isin(test_years)"
                        },
                        {
                            "line": 87,
                            "code": "X_train, X_test = X[train_idx], X[test_idx]"
                        },
                        {
                            "line": 88,
                            "code": "y_train, y_test = y[train_idx], y[test_idx]"
                        }
                    ]
                },
                {
                    "summaryComponent": "and prepares group information for ranking.",
                    "codeSegments": [
                        {
                            "line": 91,
                            "code": "train_groups = df[train_idx].groupby(\"Year\").size().to_numpy()"
                        },
                        {
                            "line": 92,
                            "code": "test_groups = df[test_idx].groupby(\"Year\").size().to_numpy()"
                        }
                    ]
                },
                {
                    "summaryComponent": "The function then iteratively initializes and trains XGBRanker models with different n_estimators values using the training data and group sizes.",
                    "codeSegments": [
                        {
                            "line": 99,
                            "code": "for n_estimators in n_estimators_list:"
                        },
                        {
                            "line": 100,
                            "code": "model = XGBRanker("
                        },
                        {
                            "line": 103,
                            "code": "n_estimators=n_estimators,"
                        },
                        {
                            "line": 109,
                            "code": "model.fit(X_train, y_train, group=train_groups)"
                        }
                    ]
                },
                {
                    "summaryComponent": "For each model, it predicts scores for the test set,",
                    "codeSegments": [
                        {
                            "line": 112,
                            "code": "y_pred = model.predict(X_test)"
                        }
                    ]
                },
                {
                    "summaryComponent": "computes predicted ranks within each year,",
                    "codeSegments": [
                        {
                            "line": 113,
                            "code": "pred_ranks = ("
                        },
                        {
                            "line": 115,
                            "code": ".groupby(df.loc[test_idx, \"Year\"])"
                        },
                        {
                            "line": 116,
                            "code": ".rank(ascending=False, method=\"first\")"
                        }
                    ]
                },
                {
                    "summaryComponent": "and evaluates performance using the NDCG metric, storing the results.",
                    "codeSegments": [
                        {
                            "line": 118,
                            "code": "ndcg = evaluate_ndcg(y_test.to_numpy(), y_pred, test_groups)"
                        },
                        {
                            "line": 119,
                            "code": "ndcg_scores.append(ndcg)"
                        },
                        {
                            "line": 120,
                            "code": "predictions.append(y_pred)"
                        },
                        {
                            "line": 121,
                            "code": "predicted_ranks.append(pred_ranks)"
                        }
                    ]
                },
                {
                    "summaryComponent": "The best model is selected based on the highest NDCG score,",
                    "codeSegments": [
                        {
                            "line": 125,
                            "code": "best_idx = int(np.argmax(ndcg_scores))"
                        },
                        {
                            "line": 126,
                            "code": "best_n_estimators = n_estimators_list[best_idx]"
                        }
                    ]
                },
                {
                    "summaryComponent": "and its predicted scores and ranks are assigned to the DataFrame.",
                    "codeSegments": [
                        {
                            "line": 133,
                            "code": "df.loc[test_idx, \"PredictedScore\"] = best_pred"
                        },
                        {
                            "line": 134,
                            "code": "df.loc[test_idx, \"PredictedRank\"] = best_pred_rank"
                        }
                    ]
                },
                {
                    "summaryComponent": "Results, including predicted scores and ranks for the best model, are printed for the test years, and bar plots are generated to visualize prediction errors for 2024 and 2025.",
                    "codeSegments": [
                        {
                            "line": 137,
                            "code": "print(df[test_idx][[\"Year\", \"Name\", \"Rank\", \"PredictedScore\", \"PredictedRank\"]])"
                        },
                        {
                            "line": 138,
                            "code": "plot_ranking_predictions(df, 2024)"
                        },
                        {
                            "line": 139,
                            "code": "plot_ranking_predictions(df, 2025)"
                        }
                    ]
                }
            ],
            "summary": "The main() function orchestrates the workflow for training and evaluating XGBoost ranking models on MVP data. It first loads the data, splits it into training (all but the last two years) and test (the last two years) sets, and prepares group information for ranking. The function then iteratively initializes and trains XGBRanker models with different n_estimators values using the training data and group sizes. For each model, it predicts scores for the test set, computes predicted ranks within each year, and evaluates performance using the NDCG metric, storing the results. The best model is selected based on the highest NDCG score, and its predicted scores and ranks are assigned to the DataFrame. Results, including predicted scores and ranks for the best model, are printed for the test years, and bar plots are generated to visualize prediction errors for 2024 and 2025.",
            "code": "74: def main():\n75:     X, y, group, df = load_data()\n76: \n77:     # Train-test split on years\n78:     unique_years = df[\"Year\"].unique()\n79:     train_years, test_years = (\n80:         unique_years[:-2],  # train: 2015-2023\n81:         unique_years[-2:],  # test: 2024-2025\n82:     )\n83: \n84:     train_idx = df[\"Year\"].isin(train_years)\n85:     test_idx = df[\"Year\"].isin(test_years)\n86: \n87:     X_train, X_test = X[train_idx], X[test_idx]\n88:     y_train, y_test = y[train_idx], y[test_idx]\n89: \n90:     # Group sizes\n91:     train_groups = df[train_idx].groupby(\"Year\").size().to_numpy()\n92:     test_groups = df[test_idx].groupby(\"Year\").size().to_numpy()\n93: \n94:     n_estimators_list = [100, 1000, 2000]\n95:     ndcg_scores = []\n96:     predictions = []\n97:     predicted_ranks = []\n98: \n99:     for n_estimators in n_estimators_list:\n100:         model = XGBRanker(\n101:             objective=\"rank:pairwise\",\n102:             learning_rate=0.1,\n103:             n_estimators=n_estimators,\n104:             max_depth=4,\n105:             random_state=42,\n106:         )\n107: \n108:         print(f\"Training XGBoostRanker with n_estimators={n_estimators}...\")\n109:         model.fit(X_train, y_train, group=train_groups)\n110: \n111:         # Predict, sort, and evaluate\n112:         y_pred = model.predict(X_test)\n113:         pred_ranks = (\n114:             pd.Series(y_pred, index=df[test_idx].index)\n115:             .groupby(df.loc[test_idx, \"Year\"])\n116:             .rank(ascending=False, method=\"first\")\n117:         )\n118:         ndcg = evaluate_ndcg(y_test.to_numpy(), y_pred, test_groups)\n119:         ndcg_scores.append(ndcg)\n120:         predictions.append(y_pred)\n121:         predicted_ranks.append(pred_ranks)\n122:         print(f\"NDCG Score with n_estimators={n_estimators}: {ndcg:.4f}\")\n123: \n124:     # Find best model\n125:     best_idx = int(np.argmax(ndcg_scores))\n126:     best_n_estimators = n_estimators_list[best_idx]\n127:     best_pred = predictions[best_idx]\n128:     best_pred_rank = predicted_ranks[best_idx]\n129: \n130:     print(f\"\\nBest n_estimators: {best_n_estimators} with NDCG Score: {ndcg_scores[best_idx]:.4f}\\n\")\n131: \n132:     # Assign best predictions and ranks to df\n133:     df.loc[test_idx, \"PredictedScore\"] = best_pred\n134:     df.loc[test_idx, \"PredictedRank\"] = best_pred_rank\n135: \n136:     # Show results for best model\n137:     print(df[test_idx][[\"Year\", \"Name\", \"Rank\", \"PredictedScore\", \"PredictedRank\"]])\n138:     plot_ranking_predictions(df, 2024)\n139:     plot_ranking_predictions(df, 2025)"
        },
        "source": "backend",
        "timestamp": "2025-08-23 10:49:27.000",
        "event": "map_summary_code",
        "id": "USITq81whaA6iz0FmniQ"
    },
    {
        "data": {
            "before_section_id": "cc03caa6-0f55-4e5b-8a44-e0cbcce404a5",
            "after_section_id": "2f949306-7eb1-4f59-b683-711587cf6906"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:49:35.000",
        "event": "autotransit_section",
        "id": "ID44kyIOrBYEPaGwmDpz"
    },
    {
        "data": {
            "section_data": {
                "lines": [
                    74,
                    139
                ],
                "summaryMappings": {
                    "medium_unstructured": [
                        {
                            "summaryComponent": "loads MVP data",
                            "codeSegments": [
                                {
                                    "line": 75,
                                    "code": "X, y, group, df = load_data()"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "splits it into training and test sets by year",
                            "codeSegments": [
                                {
                                    "line": 78,
                                    "code": "unique_years = df[\"Year\"].unique()"
                                },
                                {
                                    "line": 79,
                                    "code": "train_years, test_years = ("
                                },
                                {
                                    "line": 84,
                                    "code": "train_idx = df[\"Year\"].isin(train_years)"
                                },
                                {
                                    "line": 85,
                                    "code": "test_idx = df[\"Year\"].isin(test_years)"
                                },
                                {
                                    "line": 87,
                                    "code": "X_train, X_test = X[train_idx], X[test_idx]"
                                },
                                {
                                    "line": 88,
                                    "code": "y_train, y_test = y[train_idx], y[test_idx]"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "trains several XGBoost ranking models with different n_estimators values",
                            "codeSegments": [
                                {
                                    "line": 94,
                                    "code": "n_estimators_list = [100, 1000, 2000]"
                                },
                                {
                                    "line": 99,
                                    "code": "for n_estimators in n_estimators_list:"
                                },
                                {
                                    "line": 100,
                                    "code": "model = XGBRanker("
                                }
                            ]
                        },
                        {
                            "summaryComponent": "predicts ranks for the test years with each model",
                            "codeSegments": [
                                {
                                    "line": 112,
                                    "code": "y_pred = model.predict(X_test)"
                                },
                                {
                                    "line": 113,
                                    "code": "pred_ranks = ("
                                }
                            ]
                        },
                        {
                            "summaryComponent": "evaluates performance using NDCG",
                            "codeSegments": [
                                {
                                    "line": 118,
                                    "code": "ndcg = evaluate_ndcg(y_test.to_numpy(), y_pred, test_groups)"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "selects the best-performing model",
                            "codeSegments": [
                                {
                                    "line": 125,
                                    "code": "best_idx = int(np.argmax(ndcg_scores))"
                                },
                                {
                                    "line": 126,
                                    "code": "best_n_estimators = n_estimators_list[best_idx]"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "prints the results",
                            "codeSegments": [
                                {
                                    "line": 137,
                                    "code": "print(df[test_idx][[\"Year\", \"Name\", \"Rank\", \"PredictedScore\", \"PredictedRank\"]])"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "generates plots to visualize prediction errors for the test years using the best model",
                            "codeSegments": [
                                {
                                    "line": 138,
                                    "code": "plot_ranking_predictions(df, 2024)"
                                },
                                {
                                    "line": 139,
                                    "code": "plot_ranking_predictions(df, 2025)"
                                }
                            ]
                        }
                    ],
                    "low_structured": [
                        {
                            "summaryComponent": "Trains multiple XGBoost ranking models with varying n_estimators on MVP data",
                            "codeSegments": [
                                {
                                    "line": 99,
                                    "code": "for n_estimators in n_estimators_list:"
                                },
                                {
                                    "line": 100,
                                    "code": "model = XGBRanker("
                                },
                                {
                                    "line": 109,
                                    "code": "model.fit(X_train, y_train, group=train_groups)"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "Selects the best model based on NDCG score",
                            "codeSegments": [
                                {
                                    "line": 125,
                                    "code": "best_idx = int(np.argmax(ndcg_scores))"
                                },
                                {
                                    "line": 126,
                                    "code": "best_n_estimators = n_estimators_list[best_idx]"
                                },
                                {
                                    "line": 127,
                                    "code": "best_pred = predictions[best_idx]"
                                },
                                {
                                    "line": 128,
                                    "code": "best_pred_rank = predicted_ranks[best_idx]"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "Evaluates and prints results for the best model",
                            "codeSegments": [
                                {
                                    "line": 130,
                                    "code": "print(f\"\\nBest n_estimators: {best_n_estimators} with NDCG Score: {ndcg_scores[best_idx]:.4f}\\n\")"
                                },
                                {
                                    "line": 133,
                                    "code": "df.loc[test_idx, \"PredictedScore\"] = best_pred"
                                },
                                {
                                    "line": 134,
                                    "code": "df.loc[test_idx, \"PredictedRank\"] = best_pred_rank"
                                },
                                {
                                    "line": 137,
                                    "code": "print(df[test_idx][[\"Year\", \"Name\", \"Rank\", \"PredictedScore\", \"PredictedRank\"]])"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "Plots prediction errors for test years",
                            "codeSegments": [
                                {
                                    "line": 138,
                                    "code": "plot_ranking_predictions(df, 2024)"
                                },
                                {
                                    "line": 139,
                                    "code": "plot_ranking_predictions(df, 2025)"
                                }
                            ]
                        }
                    ],
                    "low_unstructured": [
                        {
                            "summaryComponent": "trains and evaluates multiple XGBoost ranking models",
                            "codeSegments": [
                                {
                                    "line": 99,
                                    "code": "for n_estimators in n_estimators_list:"
                                },
                                {
                                    "line": 100,
                                    "code": "model = XGBRanker("
                                },
                                {
                                    "line": 109,
                                    "code": "model.fit(X_train, y_train, group=train_groups)"
                                },
                                {
                                    "line": 112,
                                    "code": "y_pred = model.predict(X_test)"
                                },
                                {
                                    "line": 118,
                                    "code": "ndcg = evaluate_ndcg(y_test.to_numpy(), y_pred, test_groups)"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "with different n_estimators",
                            "codeSegments": [
                                {
                                    "line": 94,
                                    "code": "n_estimators_list = [100, 1000, 2000]"
                                },
                                {
                                    "line": 99,
                                    "code": "for n_estimators in n_estimators_list:"
                                },
                                {
                                    "line": 103,
                                    "code": "n_estimators=n_estimators,"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "on MVP data",
                            "codeSegments": [
                                {
                                    "line": 75,
                                    "code": "X, y, group, df = load_data()"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "selects the best model based on NDCG",
                            "codeSegments": [
                                {
                                    "line": 119,
                                    "code": "ndcg_scores.append(ndcg)"
                                },
                                {
                                    "line": 125,
                                    "code": "best_idx = int(np.argmax(ndcg_scores))"
                                },
                                {
                                    "line": 126,
                                    "code": "best_n_estimators = n_estimators_list[best_idx]"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "then visualizes and prints the results",
                            "codeSegments": [
                                {
                                    "line": 137,
                                    "code": "print(df[test_idx][[\"Year\", \"Name\", \"Rank\", \"PredictedScore\", \"PredictedRank\"]])"
                                },
                                {
                                    "line": 138,
                                    "code": "plot_ranking_predictions(df, 2024)"
                                },
                                {
                                    "line": 139,
                                    "code": "plot_ranking_predictions(df, 2025)"
                                }
                            ]
                        }
                    ],
                    "medium_structured": [
                        {
                            "summaryComponent": "Loads data and splits it into training and test sets by year",
                            "codeSegments": [
                                {
                                    "line": 75,
                                    "code": "X, y, group, df = load_data()"
                                },
                                {
                                    "line": 78,
                                    "code": "unique_years = df[\"Year\"].unique()"
                                },
                                {
                                    "line": 79,
                                    "code": "train_years, test_years = ("
                                },
                                {
                                    "line": 84,
                                    "code": "train_idx = df[\"Year\"].isin(train_years)"
                                },
                                {
                                    "line": 85,
                                    "code": "test_idx = df[\"Year\"].isin(test_years)"
                                },
                                {
                                    "line": 87,
                                    "code": "X_train, X_test = X[train_idx], X[test_idx]"
                                },
                                {
                                    "line": 88,
                                    "code": "y_train, y_test = y[train_idx], y[test_idx]"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "Trains several XGBoost ranking models with different n_estimators values on the training data",
                            "codeSegments": [
                                {
                                    "line": 94,
                                    "code": "n_estimators_list = [100, 1000, 2000]"
                                },
                                {
                                    "line": 99,
                                    "code": "for n_estimators in n_estimators_list:"
                                },
                                {
                                    "line": 100,
                                    "code": "model = XGBRanker("
                                },
                                {
                                    "line": 109,
                                    "code": "model.fit(X_train, y_train, group=train_groups)"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "Predicts and evaluates rankings for the test years for each model",
                            "codeSegments": [
                                {
                                    "line": 112,
                                    "code": "y_pred = model.predict(X_test)"
                                },
                                {
                                    "line": 113,
                                    "code": "pred_ranks = ("
                                }
                            ]
                        },
                        {
                            "summaryComponent": "Calculates NDCG score for each model",
                            "codeSegments": [
                                {
                                    "line": 118,
                                    "code": "ndcg = evaluate_ndcg(y_test.to_numpy(), y_pred, test_groups)"
                                },
                                {
                                    "line": 119,
                                    "code": "ndcg_scores.append(ndcg)"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "Selects the model with the highest NDCG score",
                            "codeSegments": [
                                {
                                    "line": 125,
                                    "code": "best_idx = int(np.argmax(ndcg_scores))"
                                },
                                {
                                    "line": 126,
                                    "code": "best_n_estimators = n_estimators_list[best_idx]"
                                },
                                {
                                    "line": 127,
                                    "code": "best_pred = predictions[best_idx]"
                                },
                                {
                                    "line": 128,
                                    "code": "best_pred_rank = predicted_ranks[best_idx]"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "Prints results and visualizes prediction errors for 2024 and 2025 using the best model",
                            "codeSegments": [
                                {
                                    "line": 137,
                                    "code": "print(df[test_idx][[\"Year\", \"Name\", \"Rank\", \"PredictedScore\", \"PredictedRank\"]])"
                                },
                                {
                                    "line": 138,
                                    "code": "plot_ranking_predictions(df, 2024)"
                                },
                                {
                                    "line": 139,
                                    "code": "plot_ranking_predictions(df, 2025)"
                                }
                            ]
                        }
                    ],
                    "high_unstructured": [
                        {
                            "summaryComponent": "The main() function orchestrates the workflow for training and evaluating XGBoost ranking models on MVP data.",
                            "codeSegments": [
                                {
                                    "line": 74,
                                    "code": "def main():"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "It first loads the data,",
                            "codeSegments": [
                                {
                                    "line": 75,
                                    "code": "X, y, group, df = load_data()"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "splits it into training (all but the last two years) and test (the last two years) sets,",
                            "codeSegments": [
                                {
                                    "line": 78,
                                    "code": "unique_years = df[\"Year\"].unique()"
                                },
                                {
                                    "line": 79,
                                    "code": "train_years, test_years = ("
                                },
                                {
                                    "line": 80,
                                    "code": "unique_years[:-2],  # train: 2015-2023"
                                },
                                {
                                    "line": 81,
                                    "code": "unique_years[-2:],  # test: 2024-2025"
                                },
                                {
                                    "line": 84,
                                    "code": "train_idx = df[\"Year\"].isin(train_years)"
                                },
                                {
                                    "line": 85,
                                    "code": "test_idx = df[\"Year\"].isin(test_years)"
                                },
                                {
                                    "line": 87,
                                    "code": "X_train, X_test = X[train_idx], X[test_idx]"
                                },
                                {
                                    "line": 88,
                                    "code": "y_train, y_test = y[train_idx], y[test_idx]"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "and prepares group information for ranking.",
                            "codeSegments": [
                                {
                                    "line": 91,
                                    "code": "train_groups = df[train_idx].groupby(\"Year\").size().to_numpy()"
                                },
                                {
                                    "line": 92,
                                    "code": "test_groups = df[test_idx].groupby(\"Year\").size().to_numpy()"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "The function then iteratively initializes and trains XGBRanker models with different n_estimators values using the training data and group sizes.",
                            "codeSegments": [
                                {
                                    "line": 99,
                                    "code": "for n_estimators in n_estimators_list:"
                                },
                                {
                                    "line": 100,
                                    "code": "model = XGBRanker("
                                },
                                {
                                    "line": 103,
                                    "code": "n_estimators=n_estimators,"
                                },
                                {
                                    "line": 109,
                                    "code": "model.fit(X_train, y_train, group=train_groups)"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "For each model, it predicts scores for the test set,",
                            "codeSegments": [
                                {
                                    "line": 112,
                                    "code": "y_pred = model.predict(X_test)"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "computes predicted ranks within each year,",
                            "codeSegments": [
                                {
                                    "line": 113,
                                    "code": "pred_ranks = ("
                                },
                                {
                                    "line": 115,
                                    "code": ".groupby(df.loc[test_idx, \"Year\"])"
                                },
                                {
                                    "line": 116,
                                    "code": ".rank(ascending=False, method=\"first\")"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "and evaluates performance using the NDCG metric, storing the results.",
                            "codeSegments": [
                                {
                                    "line": 118,
                                    "code": "ndcg = evaluate_ndcg(y_test.to_numpy(), y_pred, test_groups)"
                                },
                                {
                                    "line": 119,
                                    "code": "ndcg_scores.append(ndcg)"
                                },
                                {
                                    "line": 120,
                                    "code": "predictions.append(y_pred)"
                                },
                                {
                                    "line": 121,
                                    "code": "predicted_ranks.append(pred_ranks)"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "The best model is selected based on the highest NDCG score,",
                            "codeSegments": [
                                {
                                    "line": 125,
                                    "code": "best_idx = int(np.argmax(ndcg_scores))"
                                },
                                {
                                    "line": 126,
                                    "code": "best_n_estimators = n_estimators_list[best_idx]"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "and its predicted scores and ranks are assigned to the DataFrame.",
                            "codeSegments": [
                                {
                                    "line": 133,
                                    "code": "df.loc[test_idx, \"PredictedScore\"] = best_pred"
                                },
                                {
                                    "line": 134,
                                    "code": "df.loc[test_idx, \"PredictedRank\"] = best_pred_rank"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "Results, including predicted scores and ranks for the best model, are printed for the test years, and bar plots are generated to visualize prediction errors for 2024 and 2025.",
                            "codeSegments": [
                                {
                                    "line": 137,
                                    "code": "print(df[test_idx][[\"Year\", \"Name\", \"Rank\", \"PredictedScore\", \"PredictedRank\"]])"
                                },
                                {
                                    "line": 138,
                                    "code": "plot_ranking_predictions(df, 2024)"
                                },
                                {
                                    "line": 139,
                                    "code": "plot_ranking_predictions(df, 2025)"
                                }
                            ]
                        }
                    ],
                    "high_structured": [
                        {
                            "summaryComponent": "Loads MVP data and splits it into features, labels, groups, and the full DataFrame",
                            "codeSegments": [
                                {
                                    "line": 75,
                                    "code": "X, y, group, df = load_data()"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "Splits data by year:",
                            "codeSegments": [
                                {
                                    "line": 78,
                                    "code": "unique_years = df[\"Year\"].unique()"
                                },
                                {
                                    "line": 79,
                                    "code": "train_years, test_years = ("
                                },
                                {
                                    "line": 80,
                                    "code": "    unique_years[:-2],  # train: 2015-2023"
                                },
                                {
                                    "line": 81,
                                    "code": "    unique_years[-2:],  # test: 2024-2025"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "Training set: all years except the last two",
                            "codeSegments": [
                                {
                                    "line": 79,
                                    "code": "train_years, test_years = ("
                                },
                                {
                                    "line": 80,
                                    "code": "    unique_years[:-2],  # train: 2015-2023"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "Test set: last two years (2024, 2025)",
                            "codeSegments": [
                                {
                                    "line": 81,
                                    "code": "    unique_years[-2:],  # test: 2024-2025"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "Prepares training and test indices, and computes group sizes for ranking",
                            "codeSegments": [
                                {
                                    "line": 84,
                                    "code": "train_idx = df[\"Year\"].isin(train_years)"
                                },
                                {
                                    "line": 85,
                                    "code": "test_idx = df[\"Year\"].isin(test_years)"
                                },
                                {
                                    "line": 91,
                                    "code": "train_groups = df[train_idx].groupby(\"Year\").size().to_numpy()"
                                },
                                {
                                    "line": 92,
                                    "code": "test_groups = df[test_idx].groupby(\"Year\").size().to_numpy()"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "Iteratively initializes XGBRanker models with different n_estimators values (hyperparameter search)",
                            "codeSegments": [
                                {
                                    "line": 99,
                                    "code": "for n_estimators in n_estimators_list:"
                                },
                                {
                                    "line": 100,
                                    "code": "model = XGBRanker("
                                },
                                {
                                    "line": 103,
                                    "code": "    n_estimators=n_estimators,"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "Trains each model on the training set with group information",
                            "codeSegments": [
                                {
                                    "line": 109,
                                    "code": "model.fit(X_train, y_train, group=train_groups)"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "Makes predictions on the test set for each model:",
                            "codeSegments": [
                                {
                                    "line": 112,
                                    "code": "y_pred = model.predict(X_test)"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "Stores predicted scores",
                            "codeSegments": [
                                {
                                    "line": 120,
                                    "code": "predictions.append(y_pred)"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "Calculates predicted ranks within each test year",
                            "codeSegments": [
                                {
                                    "line": 113,
                                    "code": "pred_ranks = ("
                                },
                                {
                                    "line": 114,
                                    "code": "    pd.Series(y_pred, index=df[test_idx].index)"
                                },
                                {
                                    "line": 115,
                                    "code": "    .groupby(df.loc[test_idx, \"Year\"])"
                                },
                                {
                                    "line": 116,
                                    "code": "    .rank(ascending=False, method=\"first\")"
                                }
                            ]
                        }
                    ]
                },
                "summaryData": {
                    "medium_unstructured": "The main() function loads MVP data, splits it into training and test sets by year, and trains several XGBoost ranking models with different n_estimators values. It predicts ranks for the test years with each model, evaluates performance using NDCG, selects the best-performing model, and prints the results. Finally, it generates plots to visualize prediction errors for the test years using the best model.",
                    "low_structured": "• Trains multiple XGBoost ranking models with varying n_estimators on MVP data\n• Selects the best model based on NDCG score\n• Evaluates and prints results for the best model\n• Plots prediction errors for test years",
                    "title": "Summary of the main() Function for MVP Ranking Prediction (with Hyperparameter Search)",
                    "medium_structured": "• Loads data and splits it into training and test sets by year\n• Trains several XGBoost ranking models with different n_estimators values on the training data\n• Predicts and evaluates rankings for the test years for each model\n  ◦ Calculates NDCG score for each model\n• Selects the model with the highest NDCG score\n• Prints results and visualizes prediction errors for 2024 and 2025 using the best model",
                    "high_unstructured": "The main() function orchestrates the workflow for training and evaluating XGBoost ranking models on MVP data. It first loads the data, splits it into training (all but the last two years) and test (the last two years) sets, and prepares group information for ranking. The function then iteratively initializes and trains XGBRanker models with different n_estimators values using the training data and group sizes. For each model, it predicts scores for the test set, computes predicted ranks within each year, and evaluates performance using the NDCG metric, storing the results. The best model is selected based on the highest NDCG score, and its predicted scores and ranks are assigned to the DataFrame. Results, including predicted scores and ranks for the best model, are printed for the test years, and bar plots are generated to visualize prediction errors for 2024 and 2025.",
                    "high_structured": "• Loads MVP data and splits it into features, labels, groups, and the full DataFrame\n• Splits data by year:\n  ◦ Training set: all years except the last two\n  ◦ Test set: last two years (2024, 2025)\n• Prepares training and test indices, and computes group sizes for ranking\n• Iteratively initializes XGBRanker models with different n_estimators values (hyperparameter search)\n  ◦ Trains each model on the training set with group information\n  ◦ Makes predictions on the test set for each model:\n    ▪ Stores predicted scores\n    ▪ Calculates predicted ranks within each test year\n  ◦ Evaluates model performance using the NDCG metric for each model\n• Selects the model with the highest NDCG score\n• Assigns the best model's predicted scores and ranks to the DataFrame\n• Prints detailed results for the test years, including true and predicted ranks and scores for the best model\n• Generates and saves bar plots of prediction errors for 2024 and 2025 using the best model",
                    "low_unstructured": "This function trains and evaluates multiple XGBoost ranking models with different n_estimators on MVP data, selects the best model based on NDCG, then visualizes and prints the results."
                },
                "editPromptStructured": null,
                "createdAt": 1755974975000,
                "metadata": {
                    "filename": "rank_model.py",
                    "id": "2f949306-7eb1-4f59-b683-711587cf6906",
                    "originalCode": "def main():\n    X, y, group, df = load_data()\n\n    # Train-test split on years\n    unique_years = df[\"Year\"].unique()\n    train_years, test_years = (\n        unique_years[:-2],  # train: 2015-2023\n        unique_years[-2:],  # test: 2024-2025\n    )\n\n    train_idx = df[\"Year\"].isin(train_years)\n    test_idx = df[\"Year\"].isin(test_years)\n\n    X_train, X_test = X[train_idx], X[test_idx]\n    y_train, y_test = y[train_idx], y[test_idx]\n\n    # Group sizes\n    train_groups = df[train_idx].groupby(\"Year\").size().to_numpy()\n    test_groups = df[test_idx].groupby(\"Year\").size().to_numpy()\n\n    n_estimators_list = [100, 1000, 2000]\n    ndcg_scores = []\n    predictions = []\n    predicted_ranks = []\n\n    for n_estimators in n_estimators_list:\n        model = XGBRanker(\n            objective=\"rank:pairwise\",\n            learning_rate=0.1,\n            n_estimators=n_estimators,\n            max_depth=4,\n            random_state=42,\n        )\n\n        print(f\"Training XGBoostRanker with n_estimators={n_estimators}...\")\n        model.fit(X_train, y_train, group=train_groups)\n\n        # Predict, sort, and evaluate\n        y_pred = model.predict(X_test)\n        pred_ranks = (\n            pd.Series(y_pred, index=df[test_idx].index)\n            .groupby(df.loc[test_idx, \"Year\"])\n            .rank(ascending=False, method=\"first\")\n        )\n        ndcg = evaluate_ndcg(y_test.to_numpy(), y_pred, test_groups)\n        ndcg_scores.append(ndcg)\n        predictions.append(y_pred)\n        predicted_ranks.append(pred_ranks)\n        print(f\"NDCG Score with n_estimators={n_estimators}: {ndcg:.4f}\")\n\n    # Find best model\n    best_idx = int(np.argmax(ndcg_scores))\n    best_n_estimators = n_estimators_list[best_idx]\n    best_pred = predictions[best_idx]\n    best_pred_rank = predicted_ranks[best_idx]\n\n    print(f\"\\nBest n_estimators: {best_n_estimators} with NDCG Score: {ndcg_scores[best_idx]:.4f}\\n\")\n\n    # Assign best predictions and ranks to df\n    df.loc[test_idx, \"PredictedScore\"] = best_pred\n    df.loc[test_idx, \"PredictedRank\"] = best_pred_rank\n\n    # Show results for best model\n    print(df[test_idx][[\"Year\", \"Name\", \"Rank\", \"PredictedScore\", \"PredictedRank\"]])\n    plot_ranking_predictions(df, 2024)\n    plot_ranking_predictions(df, 2025)",
                    "fullPath": "/project/workspace/rank_model.py",
                    "offset": 1952
                },
                "selectedStructured": "unstructured",
                "title": "Summary of the main() Function for MVP Ranking Prediction (with Hyperparameter Search)",
                "selectedDetailLevel": "medium",
                "oldSummaryData": {
                    "medium_unstructured": "The main() function loads MVP data, splits it into training and test sets by year, and trains an XGBoost ranking model. It predicts ranks for the test years, evaluates performance using NDCG, and prints the results. Finally, it generates plots to visualize prediction errors for the test years.",
                    "low_structured": "• Trains an XGBoost ranking model on MVP data\n• Evaluates and prints results\n• Plots prediction errors for test years",
                    "title": "Summary of the main() Function for MVP Ranking Prediction",
                    "medium_structured": "• Loads data and splits it into training and test sets by year\n• Trains an XGBoost ranking model on the training data\n• Predicts and evaluates rankings for the test years\n  ◦ Calculates NDCG score for evaluation\n• Prints results and visualizes prediction errors for 2024 and 2025",
                    "high_unstructured": "The main() function orchestrates the workflow for training and evaluating an XGBoost ranking model on MVP data. It first loads the data, splits it into training (all but the last two years) and test (the last two years) sets, and prepares group information for ranking. The function then initializes and trains an XGBRanker using the training data and group sizes. After training, it predicts scores for the test set, computes predicted ranks within each year, and evaluates the model's performance using the NDCG metric. Results, including predicted scores and ranks, are printed for the test years, and bar plots are generated to visualize prediction errors for 2024 and 2025.",
                    "high_structured": "• Loads MVP data and splits it into features, labels, groups, and the full DataFrame\n• Splits data by year:\n  ◦ Training set: all years except the last two\n  ◦ Test set: last two years (2024, 2025)\n• Prepares training and test indices, and computes group sizes for ranking\n• Initializes an XGBRanker with specific hyperparameters (pairwise ranking, learning rate, estimators, depth, random state)\n• Trains the model on the training set with group information\n• Makes predictions on the test set:\n  ◦ Stores predicted scores\n  ◦ Calculates predicted ranks within each test year\n• Evaluates model performance using the NDCG metric on the test years\n• Prints detailed results for the test years, including true and predicted ranks and scores\n• Generates and saves bar plots of prediction errors for 2024 and 2025",
                    "low_unstructured": "This function trains and evaluates an XGBoost ranking model on MVP data, then visualizes and prints the results."
                },
                "editPromptValue": "",
                "editPromptDetailLevel": null
            },
            "section_id": "2f949306-7eb1-4f59-b683-711587cf6906"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:49:35.000",
        "event": "create_new_section",
        "id": "Ilr8W7XbqCE6sZVmFpU8"
    },
    {
        "data": {
            "mapping": [
                {
                    "summaryComponent": "Loads MVP data and splits it into features, labels, groups, and the full DataFrame",
                    "codeSegments": [
                        {
                            "line": 75,
                            "code": "X, y, group, df = load_data()"
                        }
                    ]
                },
                {
                    "summaryComponent": "Splits data by year:",
                    "codeSegments": [
                        {
                            "line": 78,
                            "code": "unique_years = df[\"Year\"].unique()"
                        },
                        {
                            "line": 79,
                            "code": "train_years, test_years = ("
                        },
                        {
                            "line": 80,
                            "code": "    unique_years[:-2],  # train: 2015-2023"
                        },
                        {
                            "line": 81,
                            "code": "    unique_years[-2:],  # test: 2024-2025"
                        }
                    ]
                },
                {
                    "summaryComponent": "Training set: all years except the last two",
                    "codeSegments": [
                        {
                            "line": 79,
                            "code": "train_years, test_years = ("
                        },
                        {
                            "line": 80,
                            "code": "    unique_years[:-2],  # train: 2015-2023"
                        }
                    ]
                },
                {
                    "summaryComponent": "Test set: last two years (2024, 2025)",
                    "codeSegments": [
                        {
                            "line": 81,
                            "code": "    unique_years[-2:],  # test: 2024-2025"
                        }
                    ]
                },
                {
                    "summaryComponent": "Prepares training and test indices, and computes group sizes for ranking",
                    "codeSegments": [
                        {
                            "line": 84,
                            "code": "train_idx = df[\"Year\"].isin(train_years)"
                        },
                        {
                            "line": 85,
                            "code": "test_idx = df[\"Year\"].isin(test_years)"
                        },
                        {
                            "line": 91,
                            "code": "train_groups = df[train_idx].groupby(\"Year\").size().to_numpy()"
                        },
                        {
                            "line": 92,
                            "code": "test_groups = df[test_idx].groupby(\"Year\").size().to_numpy()"
                        }
                    ]
                },
                {
                    "summaryComponent": "Iteratively initializes XGBRanker models with different n_estimators values (hyperparameter search)",
                    "codeSegments": [
                        {
                            "line": 99,
                            "code": "for n_estimators in n_estimators_list:"
                        },
                        {
                            "line": 100,
                            "code": "model = XGBRanker("
                        },
                        {
                            "line": 103,
                            "code": "    n_estimators=n_estimators,"
                        }
                    ]
                },
                {
                    "summaryComponent": "Trains each model on the training set with group information",
                    "codeSegments": [
                        {
                            "line": 109,
                            "code": "model.fit(X_train, y_train, group=train_groups)"
                        }
                    ]
                },
                {
                    "summaryComponent": "Makes predictions on the test set for each model:",
                    "codeSegments": [
                        {
                            "line": 112,
                            "code": "y_pred = model.predict(X_test)"
                        }
                    ]
                },
                {
                    "summaryComponent": "Stores predicted scores",
                    "codeSegments": [
                        {
                            "line": 120,
                            "code": "predictions.append(y_pred)"
                        }
                    ]
                },
                {
                    "summaryComponent": "Calculates predicted ranks within each test year",
                    "codeSegments": [
                        {
                            "line": 113,
                            "code": "pred_ranks = ("
                        },
                        {
                            "line": 114,
                            "code": "    pd.Series(y_pred, index=df[test_idx].index)"
                        },
                        {
                            "line": 115,
                            "code": "    .groupby(df.loc[test_idx, \"Year\"])"
                        },
                        {
                            "line": 116,
                            "code": "    .rank(ascending=False, method=\"first\")"
                        }
                    ]
                }
            ],
            "summary": "• Loads MVP data and splits it into features, labels, groups, and the full DataFrame\n• Splits data by year:\n  ◦ Training set: all years except the last two\n  ◦ Test set: last two years (2024, 2025)\n• Prepares training and test indices, and computes group sizes for ranking\n• Iteratively initializes XGBRanker models with different n_estimators values (hyperparameter search)\n  ◦ Trains each model on the training set with group information\n  ◦ Makes predictions on the test set for each model:\n    ▪ Stores predicted scores\n    ▪ Calculates predicted ranks within each test year\n  ◦ Evaluates model performance using the NDCG metric for each model\n• Selects the model with the highest NDCG score\n• Assigns the best model's predicted scores and ranks to the DataFrame\n• Prints detailed results for the test years, including true and predicted ranks and scores for the best model\n• Generates and saves bar plots of prediction errors for 2024 and 2025 using the best model",
            "code": "74: def main():\n75:     X, y, group, df = load_data()\n76: \n77:     # Train-test split on years\n78:     unique_years = df[\"Year\"].unique()\n79:     train_years, test_years = (\n80:         unique_years[:-2],  # train: 2015-2023\n81:         unique_years[-2:],  # test: 2024-2025\n82:     )\n83: \n84:     train_idx = df[\"Year\"].isin(train_years)\n85:     test_idx = df[\"Year\"].isin(test_years)\n86: \n87:     X_train, X_test = X[train_idx], X[test_idx]\n88:     y_train, y_test = y[train_idx], y[test_idx]\n89: \n90:     # Group sizes\n91:     train_groups = df[train_idx].groupby(\"Year\").size().to_numpy()\n92:     test_groups = df[test_idx].groupby(\"Year\").size().to_numpy()\n93: \n94:     n_estimators_list = [100, 1000, 2000]\n95:     ndcg_scores = []\n96:     predictions = []\n97:     predicted_ranks = []\n98: \n99:     for n_estimators in n_estimators_list:\n100:         model = XGBRanker(\n101:             objective=\"rank:pairwise\",\n102:             learning_rate=0.1,\n103:             n_estimators=n_estimators,\n104:             max_depth=4,\n105:             random_state=42,\n106:         )\n107: \n108:         print(f\"Training XGBoostRanker with n_estimators={n_estimators}...\")\n109:         model.fit(X_train, y_train, group=train_groups)\n110: \n111:         # Predict, sort, and evaluate\n112:         y_pred = model.predict(X_test)\n113:         pred_ranks = (\n114:             pd.Series(y_pred, index=df[test_idx].index)\n115:             .groupby(df.loc[test_idx, \"Year\"])\n116:             .rank(ascending=False, method=\"first\")\n117:         )\n118:         ndcg = evaluate_ndcg(y_test.to_numpy(), y_pred, test_groups)\n119:         ndcg_scores.append(ndcg)\n120:         predictions.append(y_pred)\n121:         predicted_ranks.append(pred_ranks)\n122:         print(f\"NDCG Score with n_estimators={n_estimators}: {ndcg:.4f}\")\n123: \n124:     # Find best model\n125:     best_idx = int(np.argmax(ndcg_scores))\n126:     best_n_estimators = n_estimators_list[best_idx]\n127:     best_pred = predictions[best_idx]\n128:     best_pred_rank = predicted_ranks[best_idx]\n129: \n130:     print(f\"\\nBest n_estimators: {best_n_estimators} with NDCG Score: {ndcg_scores[best_idx]:.4f}\\n\")\n131: \n132:     # Assign best predictions and ranks to df\n133:     df.loc[test_idx, \"PredictedScore\"] = best_pred\n134:     df.loc[test_idx, \"PredictedRank\"] = best_pred_rank\n135: \n136:     # Show results for best model\n137:     print(df[test_idx][[\"Year\", \"Name\", \"Rank\", \"PredictedScore\", \"PredictedRank\"]])\n138:     plot_ranking_predictions(df, 2024)\n139:     plot_ranking_predictions(df, 2025)"
        },
        "source": "backend",
        "timestamp": "2025-08-23 10:49:35.000",
        "event": "map_summary_code",
        "id": "MvOxsBepwjptLjMuqpIk"
    },
    {
        "data": {
            "structured_type": "unstructured",
            "section_id": "2f949306-7eb1-4f59-b683-711587cf6906",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:49:58.000",
        "event": "mapping_unhover",
        "id": "MtLDHVrw1G6I3MkT0vUP"
    },
    {
        "data": {
            "mapping_index": 0,
            "structured_type": "unstructured",
            "section_id": "2f949306-7eb1-4f59-b683-711587cf6906",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:49:58.000",
        "event": "mapping_hover",
        "id": "V6npPS1IGYl5OSCRUYKs"
    },
    {
        "data": {
            "mapping_index": 7,
            "structured_type": "unstructured",
            "section_id": "2f949306-7eb1-4f59-b683-711587cf6906",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:50:09.000",
        "event": "mapping_hover",
        "id": "2PDthuJBdUmulzmB9O4n"
    },
    {
        "data": {
            "structured_type": "unstructured",
            "section_id": "2f949306-7eb1-4f59-b683-711587cf6906",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:50:09.000",
        "event": "mapping_unhover",
        "id": "Co5RA3YtchlbjiAX25qf"
    },
    {
        "data": {
            "structured_type": "unstructured",
            "section_id": "2f949306-7eb1-4f59-b683-711587cf6906",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:50:09.000",
        "event": "mapping_unhover",
        "id": "UKFYW20JZHu8maWAnC3V"
    },
    {
        "data": {
            "mapping_index": 4,
            "structured_type": "unstructured",
            "section_id": "2f949306-7eb1-4f59-b683-711587cf6906",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:50:09.000",
        "event": "mapping_hover",
        "id": "cpVmc8ETlxVtSDQmVP9g"
    },
    {
        "data": {
            "structured_type": "unstructured",
            "section_id": "2f949306-7eb1-4f59-b683-711587cf6906",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:50:52.000",
        "event": "mapping_unhover",
        "id": "FONkTRuEeeKZ9L4dRhMa"
    },
    {
        "data": {
            "mapping_index": 4,
            "structured_type": "unstructured",
            "section_id": "2f949306-7eb1-4f59-b683-711587cf6906",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:50:52.000",
        "event": "mapping_hover",
        "id": "NFnxiAN3a0BnmjAc22U7"
    },
    {
        "data": {
            "structured_type": "unstructured",
            "section_id": "2f949306-7eb1-4f59-b683-711587cf6906",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:50:52.000",
        "event": "mapping_unhover",
        "id": "OEDQSi7MU3iBuXeRfSGv"
    },
    {
        "data": {
            "mapping_index": 5,
            "structured_type": "unstructured",
            "section_id": "2f949306-7eb1-4f59-b683-711587cf6906",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:50:52.000",
        "event": "mapping_hover",
        "id": "cf5hvJqIY9nuVsH0sCXR"
    },
    {
        "data": {
            "mapping_index": 3,
            "structured_type": "unstructured",
            "section_id": "2f949306-7eb1-4f59-b683-711587cf6906",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:50:52.000",
        "event": "mapping_hover",
        "id": "l6e5NWKEJKWBaEYsTh1l"
    },
    {
        "data": {},
        "source": "frontend",
        "timestamp": "2025-08-23 10:50:53.000",
        "event": "click_summarize_code",
        "id": "OUy4cNuXXCZOsW7LSTJT"
    },
    {
        "data": {
            "structured_type": "unstructured",
            "section_id": "2f949306-7eb1-4f59-b683-711587cf6906",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:50:53.000",
        "event": "mapping_unhover",
        "id": "qDzybTLlv0fuk1twOcfw"
    },
    {
        "data": {
            "selected_code": "def plot_ranking_predictions(df, year):\n    \"\"\"\n    Plot prediction error for a specific year.\n\n    Args:\n        df: DataFrame containing prediction results\n        year: Year to plot prediction errors for\n    \"\"\"\n    df[\"RankError\"] = df[\"PredictedRank\"] - df[\"Rank\"]\n    year_df = df[df[\"Year\"] == year].copy()\n    year_df.sort_values(\"Rank\", inplace=True)\n\n    plt.figure(figsize=(12, 6))\n    sns.barplot(x=\"Name\", y=\"RankError\", data=year_df, hue=\"Name\", palette=\"coolwarm\")\n    plt.axhline(0, color=\"black\", linestyle=\"--\")\n    plt.xticks(rotation=45, ha=\"right\")\n    plt.ylabel(\"Predicted Rank - True Rank\")\n    plt.title(f\"MVP Ranking Predictions ({year})\")\n    plt.tight_layout()\n    plt.savefig(f\"data/ranking_predictions_{year}.png\")",
            "summary": {
                "medium_unstructured": "The plot_ranking_predictions function visualizes the difference between predicted and actual ranks for a specified year. It generates a bar plot showing these errors for each player and saves the figure as a PNG file. The plot helps assess the accuracy of ranking predictions.",
                "low_structured": "• Plots prediction errors for a specified year\n• Saves the plot as a PNG file",
                "title": "plot_ranking_predictions Function Summary",
                "medium_structured": "• Calculates prediction errors as the difference between predicted and true ranks\n• Filters the DataFrame for the specified year and sorts by actual rank\n• Creates and saves a bar plot of rank errors for each player",
                "high_unstructured": "The plot_ranking_predictions function visualizes the prediction errors of player rankings for a given year. It computes the 'RankError' as the difference between each player's predicted and actual rank, then filters and sorts the data for the specified year. A bar plot is generated using Seaborn, with each player's error displayed and a horizontal reference line at zero to indicate perfect predictions. The plot is formatted for readability and saved as a PNG file named according to the year.",
                "high_structured": "• Computes 'RankError' as PredictedRank minus actual Rank for each player\n• Filters the DataFrame to include only entries from the specified year\n  ◦ Makes a copy and sorts it by actual Rank for consistent plotting\n• Sets up a matplotlib figure with a specific size\n• Uses Seaborn to create a bar plot of RankError for each player, colored by player name\n• Adds a horizontal dashed line at zero to indicate no prediction error\n• Rotates x-axis labels for readability and sets axis labels and plot title\n• Adjusts layout and saves the plot as a PNG file named with the year",
                "low_unstructured": "This function creates and saves a bar plot of prediction errors for a given year."
            }
        },
        "source": "backend",
        "timestamp": "2025-08-23 10:50:58.000",
        "event": "summarize_selected_code",
        "id": "ZyuGs89Tuvrp1uFrvyPq"
    },
    {
        "data": {
            "mapping": [
                {
                    "summaryComponent": "Plots prediction errors for a specified year",
                    "codeSegments": [
                        {
                            "line": 52,
                            "code": "def plot_ranking_predictions(df, year):"
                        },
                        {
                            "line": 60,
                            "code": "df[\"RankError\"] = df[\"PredictedRank\"] - df[\"Rank\"]"
                        },
                        {
                            "line": 61,
                            "code": "year_df = df[df[\"Year\"] == year].copy()"
                        },
                        {
                            "line": 65,
                            "code": "sns.barplot(x=\"Name\", y=\"RankError\", data=year_df, hue=\"Name\", palette=\"coolwarm\")"
                        }
                    ]
                },
                {
                    "summaryComponent": "Saves the plot as a PNG file",
                    "codeSegments": [
                        {
                            "line": 71,
                            "code": "plt.savefig(f\"data/ranking_predictions_{year}.png\")"
                        }
                    ]
                }
            ],
            "summary": "• Plots prediction errors for a specified year\n• Saves the plot as a PNG file",
            "code": "52: def plot_ranking_predictions(df, year):\n53:     \"\"\"\n54:     Plot prediction error for a specific year.\n55: \n56:     Args:\n57:         df: DataFrame containing prediction results\n58:         year: Year to plot prediction errors for\n59:     \"\"\"\n60:     df[\"RankError\"] = df[\"PredictedRank\"] - df[\"Rank\"]\n61:     year_df = df[df[\"Year\"] == year].copy()\n62:     year_df.sort_values(\"Rank\", inplace=True)\n63: \n64:     plt.figure(figsize=(12, 6))\n65:     sns.barplot(x=\"Name\", y=\"RankError\", data=year_df, hue=\"Name\", palette=\"coolwarm\")\n66:     plt.axhline(0, color=\"black\", linestyle=\"--\")\n67:     plt.xticks(rotation=45, ha=\"right\")\n68:     plt.ylabel(\"Predicted Rank - True Rank\")\n69:     plt.title(f\"MVP Ranking Predictions ({year})\")\n70:     plt.tight_layout()\n71:     plt.savefig(f\"data/ranking_predictions_{year}.png\")"
        },
        "source": "backend",
        "timestamp": "2025-08-23 10:50:59.000",
        "event": "map_summary_code",
        "id": "UBd7NwRa344AYqDlbR65"
    },
    {
        "data": {
            "mapping": [
                {
                    "summaryComponent": "This function",
                    "codeSegments": [
                        {
                            "line": 52,
                            "code": "def plot_ranking_predictions(df, year):"
                        }
                    ]
                },
                {
                    "summaryComponent": "creates and saves a bar plot",
                    "codeSegments": [
                        {
                            "line": 65,
                            "code": "sns.barplot(x=\"Name\", y=\"RankError\", data=year_df, hue=\"Name\", palette=\"coolwarm\")"
                        },
                        {
                            "line": 71,
                            "code": "plt.savefig(f\"data/ranking_predictions_{year}.png\")"
                        }
                    ]
                },
                {
                    "summaryComponent": "of prediction errors",
                    "codeSegments": [
                        {
                            "line": 60,
                            "code": "df[\"RankError\"] = df[\"PredictedRank\"] - df[\"Rank\"]"
                        }
                    ]
                },
                {
                    "summaryComponent": "for a given year",
                    "codeSegments": [
                        {
                            "line": 61,
                            "code": "year_df = df[df[\"Year\"] == year].copy()"
                        }
                    ]
                }
            ],
            "summary": "This function creates and saves a bar plot of prediction errors for a given year.",
            "code": "52: def plot_ranking_predictions(df, year):\n53:     \"\"\"\n54:     Plot prediction error for a specific year.\n55: \n56:     Args:\n57:         df: DataFrame containing prediction results\n58:         year: Year to plot prediction errors for\n59:     \"\"\"\n60:     df[\"RankError\"] = df[\"PredictedRank\"] - df[\"Rank\"]\n61:     year_df = df[df[\"Year\"] == year].copy()\n62:     year_df.sort_values(\"Rank\", inplace=True)\n63: \n64:     plt.figure(figsize=(12, 6))\n65:     sns.barplot(x=\"Name\", y=\"RankError\", data=year_df, hue=\"Name\", palette=\"coolwarm\")\n66:     plt.axhline(0, color=\"black\", linestyle=\"--\")\n67:     plt.xticks(rotation=45, ha=\"right\")\n68:     plt.ylabel(\"Predicted Rank - True Rank\")\n69:     plt.title(f\"MVP Ranking Predictions ({year})\")\n70:     plt.tight_layout()\n71:     plt.savefig(f\"data/ranking_predictions_{year}.png\")"
        },
        "source": "backend",
        "timestamp": "2025-08-23 10:51:00.000",
        "event": "map_summary_code",
        "id": "FPGrJ2kKeevYczrsZpk5"
    },
    {
        "data": {
            "mapping": [
                {
                    "summaryComponent": "The plot_ranking_predictions function",
                    "codeSegments": [
                        {
                            "line": 52,
                            "code": "def plot_ranking_predictions(df, year):"
                        }
                    ]
                },
                {
                    "summaryComponent": "visualizes the difference between predicted and actual ranks",
                    "codeSegments": [
                        {
                            "line": 60,
                            "code": "df[\"RankError\"] = df[\"PredictedRank\"] - df[\"Rank\"]"
                        }
                    ]
                },
                {
                    "summaryComponent": "for a specified year",
                    "codeSegments": [
                        {
                            "line": 61,
                            "code": "year_df = df[df[\"Year\"] == year].copy()"
                        }
                    ]
                },
                {
                    "summaryComponent": "It generates a bar plot",
                    "codeSegments": [
                        {
                            "line": 65,
                            "code": "sns.barplot(x=\"Name\", y=\"RankError\", data=year_df, hue=\"Name\", palette=\"coolwarm\")"
                        }
                    ]
                },
                {
                    "summaryComponent": "showing these errors for each player",
                    "codeSegments": [
                        {
                            "line": 65,
                            "code": "x=\"Name\", y=\"RankError\", data=year_df"
                        }
                    ]
                },
                {
                    "summaryComponent": "and saves the figure as a PNG file",
                    "codeSegments": [
                        {
                            "line": 71,
                            "code": "plt.savefig(f\"data/ranking_predictions_{year}.png\")"
                        }
                    ]
                },
                {
                    "summaryComponent": "The plot helps assess the accuracy of ranking predictions.",
                    "codeSegments": [
                        {
                            "line": 68,
                            "code": "plt.ylabel(\"Predicted Rank - True Rank\")"
                        }
                    ]
                }
            ],
            "summary": "The plot_ranking_predictions function visualizes the difference between predicted and actual ranks for a specified year. It generates a bar plot showing these errors for each player and saves the figure as a PNG file. The plot helps assess the accuracy of ranking predictions.",
            "code": "52: def plot_ranking_predictions(df, year):\n53:     \"\"\"\n54:     Plot prediction error for a specific year.\n55: \n56:     Args:\n57:         df: DataFrame containing prediction results\n58:         year: Year to plot prediction errors for\n59:     \"\"\"\n60:     df[\"RankError\"] = df[\"PredictedRank\"] - df[\"Rank\"]\n61:     year_df = df[df[\"Year\"] == year].copy()\n62:     year_df.sort_values(\"Rank\", inplace=True)\n63: \n64:     plt.figure(figsize=(12, 6))\n65:     sns.barplot(x=\"Name\", y=\"RankError\", data=year_df, hue=\"Name\", palette=\"coolwarm\")\n66:     plt.axhline(0, color=\"black\", linestyle=\"--\")\n67:     plt.xticks(rotation=45, ha=\"right\")\n68:     plt.ylabel(\"Predicted Rank - True Rank\")\n69:     plt.title(f\"MVP Ranking Predictions ({year})\")\n70:     plt.tight_layout()\n71:     plt.savefig(f\"data/ranking_predictions_{year}.png\")"
        },
        "source": "backend",
        "timestamp": "2025-08-23 10:51:00.000",
        "event": "map_summary_code",
        "id": "qLPxxJ28ObVhipxad93P"
    },
    {
        "data": {
            "mapping": [
                {
                    "summaryComponent": "The plot_ranking_predictions function visualizes the prediction errors of player rankings for a given year.",
                    "codeSegments": [
                        {
                            "line": 52,
                            "code": "def plot_ranking_predictions(df, year):"
                        }
                    ]
                },
                {
                    "summaryComponent": "It computes the 'RankError' as the difference between each player's predicted and actual rank,",
                    "codeSegments": [
                        {
                            "line": 60,
                            "code": "df[\"RankError\"] = df[\"PredictedRank\"] - df[\"Rank\"]"
                        }
                    ]
                },
                {
                    "summaryComponent": "then filters and sorts the data for the specified year.",
                    "codeSegments": [
                        {
                            "line": 61,
                            "code": "year_df = df[df[\"Year\"] == year].copy()"
                        },
                        {
                            "line": 62,
                            "code": "year_df.sort_values(\"Rank\", inplace=True)"
                        }
                    ]
                },
                {
                    "summaryComponent": "A bar plot is generated using Seaborn,",
                    "codeSegments": [
                        {
                            "line": 65,
                            "code": "sns.barplot(x=\"Name\", y=\"RankError\", data=year_df, hue=\"Name\", palette=\"coolwarm\")"
                        }
                    ]
                },
                {
                    "summaryComponent": "with each player's error displayed",
                    "codeSegments": [
                        {
                            "line": 65,
                            "code": "y=\"RankError\""
                        }
                    ]
                },
                {
                    "summaryComponent": "and a horizontal reference line at zero to indicate perfect predictions.",
                    "codeSegments": [
                        {
                            "line": 66,
                            "code": "plt.axhline(0, color=\"black\", linestyle=\"--\")"
                        }
                    ]
                },
                {
                    "summaryComponent": "The plot is formatted for readability",
                    "codeSegments": [
                        {
                            "line": 67,
                            "code": "plt.xticks(rotation=45, ha=\"right\")"
                        },
                        {
                            "line": 68,
                            "code": "plt.ylabel(\"Predicted Rank - True Rank\")"
                        },
                        {
                            "line": 69,
                            "code": "plt.title(f\"MVP Ranking Predictions ({year})\")"
                        },
                        {
                            "line": 70,
                            "code": "plt.tight_layout()"
                        }
                    ]
                },
                {
                    "summaryComponent": "and saved as a PNG file named according to the year.",
                    "codeSegments": [
                        {
                            "line": 71,
                            "code": "plt.savefig(f\"data/ranking_predictions_{year}.png\")"
                        }
                    ]
                }
            ],
            "summary": "The plot_ranking_predictions function visualizes the prediction errors of player rankings for a given year. It computes the 'RankError' as the difference between each player's predicted and actual rank, then filters and sorts the data for the specified year. A bar plot is generated using Seaborn, with each player's error displayed and a horizontal reference line at zero to indicate perfect predictions. The plot is formatted for readability and saved as a PNG file named according to the year.",
            "code": "52: def plot_ranking_predictions(df, year):\n53:     \"\"\"\n54:     Plot prediction error for a specific year.\n55: \n56:     Args:\n57:         df: DataFrame containing prediction results\n58:         year: Year to plot prediction errors for\n59:     \"\"\"\n60:     df[\"RankError\"] = df[\"PredictedRank\"] - df[\"Rank\"]\n61:     year_df = df[df[\"Year\"] == year].copy()\n62:     year_df.sort_values(\"Rank\", inplace=True)\n63: \n64:     plt.figure(figsize=(12, 6))\n65:     sns.barplot(x=\"Name\", y=\"RankError\", data=year_df, hue=\"Name\", palette=\"coolwarm\")\n66:     plt.axhline(0, color=\"black\", linestyle=\"--\")\n67:     plt.xticks(rotation=45, ha=\"right\")\n68:     plt.ylabel(\"Predicted Rank - True Rank\")\n69:     plt.title(f\"MVP Ranking Predictions ({year})\")\n70:     plt.tight_layout()\n71:     plt.savefig(f\"data/ranking_predictions_{year}.png\")"
        },
        "source": "backend",
        "timestamp": "2025-08-23 10:51:01.000",
        "event": "map_summary_code",
        "id": "JYzd507EG2ZeI2rGvMfk"
    },
    {
        "data": {
            "mapping": [
                {
                    "summaryComponent": "Computes 'RankError' as PredictedRank minus actual Rank for each player",
                    "codeSegments": [
                        {
                            "line": 60,
                            "code": "df[\"RankError\"] = df[\"PredictedRank\"] - df[\"Rank\"]"
                        }
                    ]
                },
                {
                    "summaryComponent": "Filters the DataFrame to include only entries from the specified year",
                    "codeSegments": [
                        {
                            "line": 61,
                            "code": "year_df = df[df[\"Year\"] == year].copy()"
                        }
                    ]
                },
                {
                    "summaryComponent": "Makes a copy and sorts it by actual Rank for consistent plotting",
                    "codeSegments": [
                        {
                            "line": 61,
                            "code": "year_df = df[df[\"Year\"] == year].copy()"
                        },
                        {
                            "line": 62,
                            "code": "year_df.sort_values(\"Rank\", inplace=True)"
                        }
                    ]
                },
                {
                    "summaryComponent": "Sets up a matplotlib figure with a specific size",
                    "codeSegments": [
                        {
                            "line": 64,
                            "code": "plt.figure(figsize=(12, 6))"
                        }
                    ]
                },
                {
                    "summaryComponent": "Uses Seaborn to create a bar plot of RankError for each player, colored by player name",
                    "codeSegments": [
                        {
                            "line": 65,
                            "code": "sns.barplot(x=\"Name\", y=\"RankError\", data=year_df, hue=\"Name\", palette=\"coolwarm\")"
                        }
                    ]
                },
                {
                    "summaryComponent": "Adds a horizontal dashed line at zero to indicate no prediction error",
                    "codeSegments": [
                        {
                            "line": 66,
                            "code": "plt.axhline(0, color=\"black\", linestyle=\"--\")"
                        }
                    ]
                },
                {
                    "summaryComponent": "Rotates x-axis labels for readability and sets axis labels and plot title",
                    "codeSegments": [
                        {
                            "line": 67,
                            "code": "plt.xticks(rotation=45, ha=\"right\")"
                        },
                        {
                            "line": 68,
                            "code": "plt.ylabel(\"Predicted Rank - True Rank\")"
                        },
                        {
                            "line": 69,
                            "code": "plt.title(f\"MVP Ranking Predictions ({year})\")"
                        }
                    ]
                },
                {
                    "summaryComponent": "Adjusts layout and saves the plot as a PNG file named with the year",
                    "codeSegments": [
                        {
                            "line": 70,
                            "code": "plt.tight_layout()"
                        },
                        {
                            "line": 71,
                            "code": "plt.savefig(f\"data/ranking_predictions_{year}.png\")"
                        }
                    ]
                }
            ],
            "summary": "• Computes 'RankError' as PredictedRank minus actual Rank for each player\n• Filters the DataFrame to include only entries from the specified year\n  ◦ Makes a copy and sorts it by actual Rank for consistent plotting\n• Sets up a matplotlib figure with a specific size\n• Uses Seaborn to create a bar plot of RankError for each player, colored by player name\n• Adds a horizontal dashed line at zero to indicate no prediction error\n• Rotates x-axis labels for readability and sets axis labels and plot title\n• Adjusts layout and saves the plot as a PNG file named with the year",
            "code": "52: def plot_ranking_predictions(df, year):\n53:     \"\"\"\n54:     Plot prediction error for a specific year.\n55: \n56:     Args:\n57:         df: DataFrame containing prediction results\n58:         year: Year to plot prediction errors for\n59:     \"\"\"\n60:     df[\"RankError\"] = df[\"PredictedRank\"] - df[\"Rank\"]\n61:     year_df = df[df[\"Year\"] == year].copy()\n62:     year_df.sort_values(\"Rank\", inplace=True)\n63: \n64:     plt.figure(figsize=(12, 6))\n65:     sns.barplot(x=\"Name\", y=\"RankError\", data=year_df, hue=\"Name\", palette=\"coolwarm\")\n66:     plt.axhline(0, color=\"black\", linestyle=\"--\")\n67:     plt.xticks(rotation=45, ha=\"right\")\n68:     plt.ylabel(\"Predicted Rank - True Rank\")\n69:     plt.title(f\"MVP Ranking Predictions ({year})\")\n70:     plt.tight_layout()\n71:     plt.savefig(f\"data/ranking_predictions_{year}.png\")"
        },
        "source": "backend",
        "timestamp": "2025-08-23 10:51:01.000",
        "event": "map_summary_code",
        "id": "NhnSi5rVYMA7Id0HEzaf"
    },
    {
        "data": {
            "before_section_id": "2f949306-7eb1-4f59-b683-711587cf6906",
            "after_section_id": "b6b77310-ab0b-44db-91fe-071174316af5"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:51:05.000",
        "event": "autotransit_section",
        "id": "AiWlixNxLBdyT3qf5yu7"
    },
    {
        "data": {
            "mapping": [
                {
                    "summaryComponent": "Calculates prediction errors as the difference between predicted and true ranks",
                    "codeSegments": [
                        {
                            "line": 60,
                            "code": "df[\"RankError\"] = df[\"PredictedRank\"] - df[\"Rank\"]"
                        }
                    ]
                },
                {
                    "summaryComponent": "Filters the DataFrame for the specified year and sorts by actual rank",
                    "codeSegments": [
                        {
                            "line": 61,
                            "code": "year_df = df[df[\"Year\"] == year].copy()"
                        },
                        {
                            "line": 62,
                            "code": "year_df.sort_values(\"Rank\", inplace=True)"
                        }
                    ]
                },
                {
                    "summaryComponent": "Creates and saves a bar plot of rank errors for each player",
                    "codeSegments": [
                        {
                            "line": 64,
                            "code": "plt.figure(figsize=(12, 6))"
                        },
                        {
                            "line": 65,
                            "code": "sns.barplot(x=\"Name\", y=\"RankError\", data=year_df, hue=\"Name\", palette=\"coolwarm\")"
                        },
                        {
                            "line": 66,
                            "code": "plt.axhline(0, color=\"black\", linestyle=\"--\")"
                        },
                        {
                            "line": 67,
                            "code": "plt.xticks(rotation=45, ha=\"right\")"
                        },
                        {
                            "line": 68,
                            "code": "plt.ylabel(\"Predicted Rank - True Rank\")"
                        },
                        {
                            "line": 69,
                            "code": "plt.title(f\"MVP Ranking Predictions ({year})\")"
                        },
                        {
                            "line": 70,
                            "code": "plt.tight_layout()"
                        },
                        {
                            "line": 71,
                            "code": "plt.savefig(f\"data/ranking_predictions_{year}.png\")"
                        }
                    ]
                }
            ],
            "summary": "• Calculates prediction errors as the difference between predicted and true ranks\n• Filters the DataFrame for the specified year and sorts by actual rank\n• Creates and saves a bar plot of rank errors for each player",
            "code": "52: def plot_ranking_predictions(df, year):\n53:     \"\"\"\n54:     Plot prediction error for a specific year.\n55: \n56:     Args:\n57:         df: DataFrame containing prediction results\n58:         year: Year to plot prediction errors for\n59:     \"\"\"\n60:     df[\"RankError\"] = df[\"PredictedRank\"] - df[\"Rank\"]\n61:     year_df = df[df[\"Year\"] == year].copy()\n62:     year_df.sort_values(\"Rank\", inplace=True)\n63: \n64:     plt.figure(figsize=(12, 6))\n65:     sns.barplot(x=\"Name\", y=\"RankError\", data=year_df, hue=\"Name\", palette=\"coolwarm\")\n66:     plt.axhline(0, color=\"black\", linestyle=\"--\")\n67:     plt.xticks(rotation=45, ha=\"right\")\n68:     plt.ylabel(\"Predicted Rank - True Rank\")\n69:     plt.title(f\"MVP Ranking Predictions ({year})\")\n70:     plt.tight_layout()\n71:     plt.savefig(f\"data/ranking_predictions_{year}.png\")"
        },
        "source": "backend",
        "timestamp": "2025-08-23 10:51:05.000",
        "event": "map_summary_code",
        "id": "SboBcmewqP7tyNYFbWtS"
    },
    {
        "data": {
            "section_data": {
                "lines": [
                    52,
                    71
                ],
                "summaryData": {
                    "medium_unstructured": "The plot_ranking_predictions function visualizes the difference between predicted and actual ranks for a specified year. It generates a bar plot showing these errors for each player and saves the figure as a PNG file. The plot helps assess the accuracy of ranking predictions.",
                    "low_structured": "• Plots prediction errors for a specified year\n• Saves the plot as a PNG file",
                    "title": "plot_ranking_predictions Function Summary",
                    "medium_structured": "• Calculates prediction errors as the difference between predicted and true ranks\n• Filters the DataFrame for the specified year and sorts by actual rank\n• Creates and saves a bar plot of rank errors for each player",
                    "high_unstructured": "The plot_ranking_predictions function visualizes the prediction errors of player rankings for a given year. It computes the 'RankError' as the difference between each player's predicted and actual rank, then filters and sorts the data for the specified year. A bar plot is generated using Seaborn, with each player's error displayed and a horizontal reference line at zero to indicate perfect predictions. The plot is formatted for readability and saved as a PNG file named according to the year.",
                    "high_structured": "• Computes 'RankError' as PredictedRank minus actual Rank for each player\n• Filters the DataFrame to include only entries from the specified year\n  ◦ Makes a copy and sorts it by actual Rank for consistent plotting\n• Sets up a matplotlib figure with a specific size\n• Uses Seaborn to create a bar plot of RankError for each player, colored by player name\n• Adds a horizontal dashed line at zero to indicate no prediction error\n• Rotates x-axis labels for readability and sets axis labels and plot title\n• Adjusts layout and saves the plot as a PNG file named with the year",
                    "low_unstructured": "This function creates and saves a bar plot of prediction errors for a given year."
                },
                "editPromptStructured": null,
                "createdAt": 1755975065000,
                "metadata": {
                    "filename": "rank_model.py",
                    "id": "b6b77310-ab0b-44db-91fe-071174316af5",
                    "originalCode": "def plot_ranking_predictions(df, year):\n    \"\"\"\n    Plot prediction error for a specific year.\n\n    Args:\n        df: DataFrame containing prediction results\n        year: Year to plot prediction errors for\n    \"\"\"\n    df[\"RankError\"] = df[\"PredictedRank\"] - df[\"Rank\"]\n    year_df = df[df[\"Year\"] == year].copy()\n    year_df.sort_values(\"Rank\", inplace=True)\n\n    plt.figure(figsize=(12, 6))\n    sns.barplot(x=\"Name\", y=\"RankError\", data=year_df, hue=\"Name\", palette=\"coolwarm\")\n    plt.axhline(0, color=\"black\", linestyle=\"--\")\n    plt.xticks(rotation=45, ha=\"right\")\n    plt.ylabel(\"Predicted Rank - True Rank\")\n    plt.title(f\"MVP Ranking Predictions ({year})\")\n    plt.tight_layout()\n    plt.savefig(f\"data/ranking_predictions_{year}.png\")",
                    "fullPath": "/project/workspace/rank_model.py",
                    "offset": 1205
                },
                "selectedStructured": "unstructured",
                "title": "plot_ranking_predictions Function Summary",
                "selectedDetailLevel": "medium",
                "summaryMappings": {
                    "medium_unstructured": [
                        {
                            "summaryComponent": "The plot_ranking_predictions function",
                            "codeSegments": [
                                {
                                    "line": 52,
                                    "code": "def plot_ranking_predictions(df, year):"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "visualizes the difference between predicted and actual ranks",
                            "codeSegments": [
                                {
                                    "line": 60,
                                    "code": "df[\"RankError\"] = df[\"PredictedRank\"] - df[\"Rank\"]"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "for a specified year",
                            "codeSegments": [
                                {
                                    "line": 61,
                                    "code": "year_df = df[df[\"Year\"] == year].copy()"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "It generates a bar plot",
                            "codeSegments": [
                                {
                                    "line": 65,
                                    "code": "sns.barplot(x=\"Name\", y=\"RankError\", data=year_df, hue=\"Name\", palette=\"coolwarm\")"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "showing these errors for each player",
                            "codeSegments": [
                                {
                                    "line": 65,
                                    "code": "x=\"Name\", y=\"RankError\", data=year_df"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "and saves the figure as a PNG file",
                            "codeSegments": [
                                {
                                    "line": 71,
                                    "code": "plt.savefig(f\"data/ranking_predictions_{year}.png\")"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "The plot helps assess the accuracy of ranking predictions.",
                            "codeSegments": [
                                {
                                    "line": 68,
                                    "code": "plt.ylabel(\"Predicted Rank - True Rank\")"
                                }
                            ]
                        }
                    ],
                    "low_structured": [
                        {
                            "summaryComponent": "Plots prediction errors for a specified year",
                            "codeSegments": [
                                {
                                    "line": 52,
                                    "code": "def plot_ranking_predictions(df, year):"
                                },
                                {
                                    "line": 60,
                                    "code": "df[\"RankError\"] = df[\"PredictedRank\"] - df[\"Rank\"]"
                                },
                                {
                                    "line": 61,
                                    "code": "year_df = df[df[\"Year\"] == year].copy()"
                                },
                                {
                                    "line": 65,
                                    "code": "sns.barplot(x=\"Name\", y=\"RankError\", data=year_df, hue=\"Name\", palette=\"coolwarm\")"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "Saves the plot as a PNG file",
                            "codeSegments": [
                                {
                                    "line": 71,
                                    "code": "plt.savefig(f\"data/ranking_predictions_{year}.png\")"
                                }
                            ]
                        }
                    ],
                    "low_unstructured": [
                        {
                            "summaryComponent": "This function",
                            "codeSegments": [
                                {
                                    "line": 52,
                                    "code": "def plot_ranking_predictions(df, year):"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "creates and saves a bar plot",
                            "codeSegments": [
                                {
                                    "line": 65,
                                    "code": "sns.barplot(x=\"Name\", y=\"RankError\", data=year_df, hue=\"Name\", palette=\"coolwarm\")"
                                },
                                {
                                    "line": 71,
                                    "code": "plt.savefig(f\"data/ranking_predictions_{year}.png\")"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "of prediction errors",
                            "codeSegments": [
                                {
                                    "line": 60,
                                    "code": "df[\"RankError\"] = df[\"PredictedRank\"] - df[\"Rank\"]"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "for a given year",
                            "codeSegments": [
                                {
                                    "line": 61,
                                    "code": "year_df = df[df[\"Year\"] == year].copy()"
                                }
                            ]
                        }
                    ],
                    "medium_structured": [
                        {
                            "summaryComponent": "Calculates prediction errors as the difference between predicted and true ranks",
                            "codeSegments": [
                                {
                                    "line": 60,
                                    "code": "df[\"RankError\"] = df[\"PredictedRank\"] - df[\"Rank\"]"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "Filters the DataFrame for the specified year and sorts by actual rank",
                            "codeSegments": [
                                {
                                    "line": 61,
                                    "code": "year_df = df[df[\"Year\"] == year].copy()"
                                },
                                {
                                    "line": 62,
                                    "code": "year_df.sort_values(\"Rank\", inplace=True)"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "Creates and saves a bar plot of rank errors for each player",
                            "codeSegments": [
                                {
                                    "line": 64,
                                    "code": "plt.figure(figsize=(12, 6))"
                                },
                                {
                                    "line": 65,
                                    "code": "sns.barplot(x=\"Name\", y=\"RankError\", data=year_df, hue=\"Name\", palette=\"coolwarm\")"
                                },
                                {
                                    "line": 66,
                                    "code": "plt.axhline(0, color=\"black\", linestyle=\"--\")"
                                },
                                {
                                    "line": 67,
                                    "code": "plt.xticks(rotation=45, ha=\"right\")"
                                },
                                {
                                    "line": 68,
                                    "code": "plt.ylabel(\"Predicted Rank - True Rank\")"
                                },
                                {
                                    "line": 69,
                                    "code": "plt.title(f\"MVP Ranking Predictions ({year})\")"
                                },
                                {
                                    "line": 70,
                                    "code": "plt.tight_layout()"
                                },
                                {
                                    "line": 71,
                                    "code": "plt.savefig(f\"data/ranking_predictions_{year}.png\")"
                                }
                            ]
                        }
                    ],
                    "high_unstructured": [
                        {
                            "summaryComponent": "The plot_ranking_predictions function visualizes the prediction errors of player rankings for a given year.",
                            "codeSegments": [
                                {
                                    "line": 52,
                                    "code": "def plot_ranking_predictions(df, year):"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "It computes the 'RankError' as the difference between each player's predicted and actual rank,",
                            "codeSegments": [
                                {
                                    "line": 60,
                                    "code": "df[\"RankError\"] = df[\"PredictedRank\"] - df[\"Rank\"]"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "then filters and sorts the data for the specified year.",
                            "codeSegments": [
                                {
                                    "line": 61,
                                    "code": "year_df = df[df[\"Year\"] == year].copy()"
                                },
                                {
                                    "line": 62,
                                    "code": "year_df.sort_values(\"Rank\", inplace=True)"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "A bar plot is generated using Seaborn,",
                            "codeSegments": [
                                {
                                    "line": 65,
                                    "code": "sns.barplot(x=\"Name\", y=\"RankError\", data=year_df, hue=\"Name\", palette=\"coolwarm\")"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "with each player's error displayed",
                            "codeSegments": [
                                {
                                    "line": 65,
                                    "code": "y=\"RankError\""
                                }
                            ]
                        },
                        {
                            "summaryComponent": "and a horizontal reference line at zero to indicate perfect predictions.",
                            "codeSegments": [
                                {
                                    "line": 66,
                                    "code": "plt.axhline(0, color=\"black\", linestyle=\"--\")"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "The plot is formatted for readability",
                            "codeSegments": [
                                {
                                    "line": 67,
                                    "code": "plt.xticks(rotation=45, ha=\"right\")"
                                },
                                {
                                    "line": 68,
                                    "code": "plt.ylabel(\"Predicted Rank - True Rank\")"
                                },
                                {
                                    "line": 69,
                                    "code": "plt.title(f\"MVP Ranking Predictions ({year})\")"
                                },
                                {
                                    "line": 70,
                                    "code": "plt.tight_layout()"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "and saved as a PNG file named according to the year.",
                            "codeSegments": [
                                {
                                    "line": 71,
                                    "code": "plt.savefig(f\"data/ranking_predictions_{year}.png\")"
                                }
                            ]
                        }
                    ],
                    "high_structured": [
                        {
                            "summaryComponent": "Computes 'RankError' as PredictedRank minus actual Rank for each player",
                            "codeSegments": [
                                {
                                    "line": 60,
                                    "code": "df[\"RankError\"] = df[\"PredictedRank\"] - df[\"Rank\"]"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "Filters the DataFrame to include only entries from the specified year",
                            "codeSegments": [
                                {
                                    "line": 61,
                                    "code": "year_df = df[df[\"Year\"] == year].copy()"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "Makes a copy and sorts it by actual Rank for consistent plotting",
                            "codeSegments": [
                                {
                                    "line": 61,
                                    "code": "year_df = df[df[\"Year\"] == year].copy()"
                                },
                                {
                                    "line": 62,
                                    "code": "year_df.sort_values(\"Rank\", inplace=True)"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "Sets up a matplotlib figure with a specific size",
                            "codeSegments": [
                                {
                                    "line": 64,
                                    "code": "plt.figure(figsize=(12, 6))"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "Uses Seaborn to create a bar plot of RankError for each player, colored by player name",
                            "codeSegments": [
                                {
                                    "line": 65,
                                    "code": "sns.barplot(x=\"Name\", y=\"RankError\", data=year_df, hue=\"Name\", palette=\"coolwarm\")"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "Adds a horizontal dashed line at zero to indicate no prediction error",
                            "codeSegments": [
                                {
                                    "line": 66,
                                    "code": "plt.axhline(0, color=\"black\", linestyle=\"--\")"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "Rotates x-axis labels for readability and sets axis labels and plot title",
                            "codeSegments": [
                                {
                                    "line": 67,
                                    "code": "plt.xticks(rotation=45, ha=\"right\")"
                                },
                                {
                                    "line": 68,
                                    "code": "plt.ylabel(\"Predicted Rank - True Rank\")"
                                },
                                {
                                    "line": 69,
                                    "code": "plt.title(f\"MVP Ranking Predictions ({year})\")"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "Adjusts layout and saves the plot as a PNG file named with the year",
                            "codeSegments": [
                                {
                                    "line": 70,
                                    "code": "plt.tight_layout()"
                                },
                                {
                                    "line": 71,
                                    "code": "plt.savefig(f\"data/ranking_predictions_{year}.png\")"
                                }
                            ]
                        }
                    ]
                },
                "editPromptValue": "",
                "editPromptDetailLevel": null
            },
            "section_id": "b6b77310-ab0b-44db-91fe-071174316af5"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:51:05.000",
        "event": "create_new_section",
        "id": "wGG8vl3zKiSY0UU8entZ"
    },
    {
        "data": {
            "structured_type": "unstructured",
            "section_id": "b6b77310-ab0b-44db-91fe-071174316af5",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:51:13.000",
        "event": "mapping_unhover",
        "id": "1mcssh7FLZXARmKij30Z"
    },
    {
        "data": {
            "mapping_index": 4,
            "structured_type": "unstructured",
            "section_id": "b6b77310-ab0b-44db-91fe-071174316af5",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:51:13.000",
        "event": "mapping_hover",
        "id": "4Ut8tFPw4ThmswvIcQiA"
    },
    {
        "data": {
            "mapping_index": 2,
            "structured_type": "unstructured",
            "section_id": "b6b77310-ab0b-44db-91fe-071174316af5",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:51:13.000",
        "event": "mapping_hover",
        "id": "F2KkpCGALAr2mYbx7jLg"
    },
    {
        "data": {
            "mapping_index": 5,
            "structured_type": "unstructured",
            "section_id": "b6b77310-ab0b-44db-91fe-071174316af5",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:51:13.000",
        "event": "mapping_hover",
        "id": "Jd6uyFxApJxePuWg6W3r"
    },
    {
        "data": {
            "mapping_index": 0,
            "structured_type": "unstructured",
            "section_id": "b6b77310-ab0b-44db-91fe-071174316af5",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:51:13.000",
        "event": "mapping_hover",
        "id": "XfdKIcjv5qMLKJ4CkeO8"
    },
    {
        "data": {
            "structured_type": "unstructured",
            "section_id": "b6b77310-ab0b-44db-91fe-071174316af5",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:51:13.000",
        "event": "mapping_unhover",
        "id": "fh14ed4oikYc6j9X4KzS"
    },
    {
        "data": {
            "structured_type": "unstructured",
            "section_id": "b6b77310-ab0b-44db-91fe-071174316af5",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:51:13.000",
        "event": "mapping_unhover",
        "id": "nMSPu2pLy0FRQQChIv3L"
    },
    {
        "data": {
            "structured_type": "unstructured",
            "section_id": "b6b77310-ab0b-44db-91fe-071174316af5",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:51:14.000",
        "event": "mapping_unhover",
        "id": "Ev0YBaMrgzaCLbAIab8G"
    },
    {
        "data": {
            "mapping_index": 0,
            "structured_type": "unstructured",
            "section_id": "b6b77310-ab0b-44db-91fe-071174316af5",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:51:14.000",
        "event": "mapping_hover",
        "id": "GqPnbNQq7xai9MgwAjZF"
    },
    {
        "data": {
            "structured_type": "unstructured",
            "section_id": "b6b77310-ab0b-44db-91fe-071174316af5",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:51:14.000",
        "event": "mapping_unhover",
        "id": "H8RKnDf35TdsFmZfO7Jk"
    },
    {
        "data": {
            "mapping_index": 2,
            "structured_type": "unstructured",
            "section_id": "b6b77310-ab0b-44db-91fe-071174316af5",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:51:14.000",
        "event": "mapping_hover",
        "id": "SQqrA3WZefBhOX8eFQ6M"
    },
    {
        "data": {
            "structured_type": "unstructured",
            "section_id": "b6b77310-ab0b-44db-91fe-071174316af5",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:51:14.000",
        "event": "mapping_unhover",
        "id": "baMhNJKVSQylXp2Sabfq"
    },
    {
        "data": {
            "structured_type": "unstructured",
            "section_id": "b6b77310-ab0b-44db-91fe-071174316af5",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:51:14.000",
        "event": "mapping_unhover",
        "id": "fVbiiL5gY8JAkUHGrugt"
    },
    {
        "data": {
            "structured_type": "unstructured",
            "section_id": "b6b77310-ab0b-44db-91fe-071174316af5",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:51:14.000",
        "event": "mapping_unhover",
        "id": "lpByZj0HMG4pIkMAuVyb"
    },
    {
        "data": {
            "mapping_index": 4,
            "structured_type": "unstructured",
            "section_id": "b6b77310-ab0b-44db-91fe-071174316af5",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:51:14.000",
        "event": "mapping_hover",
        "id": "mCIB9uzGyy49xGXYnibB"
    },
    {
        "data": {
            "mapping_index": 1,
            "structured_type": "unstructured",
            "section_id": "b6b77310-ab0b-44db-91fe-071174316af5",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:51:14.000",
        "event": "mapping_hover",
        "id": "vrSAKcXBSJRj2IW7PyGh"
    },
    {
        "data": {
            "mapping_index": 1,
            "structured_type": "unstructured",
            "section_id": "b6b77310-ab0b-44db-91fe-071174316af5",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:51:14.000",
        "event": "mapping_hover",
        "id": "y5Yrfe2uKb9VEuJOSufG"
    },
    {
        "data": {
            "mapping_index": 2,
            "structured_type": "unstructured",
            "section_id": "b6b77310-ab0b-44db-91fe-071174316af5",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:51:16.000",
        "event": "mapping_hover",
        "id": "IiQQzTlIweV93ApuEFyN"
    },
    {
        "data": {
            "structured_type": "unstructured",
            "section_id": "b6b77310-ab0b-44db-91fe-071174316af5",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:51:16.000",
        "event": "mapping_unhover",
        "id": "ZoyYgmIXvzaKPnSjAhOT"
    },
    {
        "data": {
            "mapping_index": 3,
            "structured_type": "unstructured",
            "section_id": "b6b77310-ab0b-44db-91fe-071174316af5",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:51:17.000",
        "event": "mapping_hover",
        "id": "AvIw4jl7GelQb9XZv8DV"
    },
    {
        "data": {
            "mapping_index": 4,
            "structured_type": "unstructured",
            "section_id": "b6b77310-ab0b-44db-91fe-071174316af5",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:51:17.000",
        "event": "mapping_hover",
        "id": "XsaHfxGfQrFGJajN98Sp"
    },
    {
        "data": {
            "mapping_index": 2,
            "structured_type": "unstructured",
            "section_id": "b6b77310-ab0b-44db-91fe-071174316af5",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:51:17.000",
        "event": "mapping_hover",
        "id": "aA9HnfFO41otgSAd0ayN"
    },
    {
        "data": {
            "structured_type": "unstructured",
            "section_id": "b6b77310-ab0b-44db-91fe-071174316af5",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:51:17.000",
        "event": "mapping_unhover",
        "id": "aUD3sgVft6RCYT7nYGtV"
    },
    {
        "data": {
            "structured_type": "unstructured",
            "section_id": "b6b77310-ab0b-44db-91fe-071174316af5",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:51:17.000",
        "event": "mapping_unhover",
        "id": "fTZIucToOo4msJ0MfkbJ"
    },
    {
        "data": {
            "structured_type": "unstructured",
            "section_id": "b6b77310-ab0b-44db-91fe-071174316af5",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:51:17.000",
        "event": "mapping_unhover",
        "id": "gqrlRmhHuvCIO7NSdXdx"
    },
    {
        "data": {
            "mapping_index": 1,
            "structured_type": "unstructured",
            "section_id": "b6b77310-ab0b-44db-91fe-071174316af5",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:51:17.000",
        "event": "mapping_hover",
        "id": "haMJk69nduoH7sgg1g57"
    },
    {
        "data": {
            "structured_type": "unstructured",
            "section_id": "b6b77310-ab0b-44db-91fe-071174316af5",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:51:17.000",
        "event": "mapping_unhover",
        "id": "kRFcXLNAxBAXSHUrgklz"
    },
    {
        "data": {
            "mapping_index": 4,
            "structured_type": "unstructured",
            "section_id": "b6b77310-ab0b-44db-91fe-071174316af5",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:51:18.000",
        "event": "mapping_hover",
        "id": "G4efLwuQ0RXJyAAWjCQ0"
    },
    {
        "data": {
            "structured_type": "unstructured",
            "section_id": "b6b77310-ab0b-44db-91fe-071174316af5",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:51:18.000",
        "event": "mapping_unhover",
        "id": "fBqJveYBFMk5AiKpXaM7"
    },
    {
        "data": {
            "structured_type": "unstructured",
            "section_id": "b6b77310-ab0b-44db-91fe-071174316af5",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:51:20.000",
        "event": "mapping_unhover",
        "id": "cNRTakbmpc7JZivObpCa"
    },
    {
        "data": {
            "mapping_index": 5,
            "structured_type": "unstructured",
            "section_id": "b6b77310-ab0b-44db-91fe-071174316af5",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:51:20.000",
        "event": "mapping_hover",
        "id": "xTCoer2JkI9iCcU3rV8y"
    },
    {
        "data": {
            "mapping_index": 6,
            "structured_type": "unstructured",
            "section_id": "b6b77310-ab0b-44db-91fe-071174316af5",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:51:21.000",
        "event": "mapping_hover",
        "id": "tiQyngiIUDK1YiXEFfc0"
    },
    {
        "data": {
            "structured_type": "unstructured",
            "section_id": "b6b77310-ab0b-44db-91fe-071174316af5",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:51:21.000",
        "event": "mapping_unhover",
        "id": "zt2e2nQFthqoIW8PhmfE"
    },
    {
        "data": {
            "mapping_index": 4,
            "structured_type": "unstructured",
            "section_id": "b6b77310-ab0b-44db-91fe-071174316af5",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:51:22.000",
        "event": "mapping_hover",
        "id": "0dyCkHBc6YIW4GuHt3sF"
    },
    {
        "data": {
            "structured_type": "unstructured",
            "section_id": "b6b77310-ab0b-44db-91fe-071174316af5",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:51:22.000",
        "event": "mapping_unhover",
        "id": "6EBd0iVIGXydvs4H6NPj"
    },
    {
        "data": {
            "structured_type": "unstructured",
            "section_id": "b6b77310-ab0b-44db-91fe-071174316af5",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:51:22.000",
        "event": "mapping_unhover",
        "id": "6VLYDDmKUqkT6EL0Ax5S"
    },
    {
        "data": {
            "mapping_index": 3,
            "structured_type": "unstructured",
            "section_id": "b6b77310-ab0b-44db-91fe-071174316af5",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:51:22.000",
        "event": "mapping_hover",
        "id": "HwB4OmfZqv2rX22ES3q5"
    },
    {
        "data": {
            "mapping_index": 0,
            "structured_type": "unstructured",
            "section_id": "b6b77310-ab0b-44db-91fe-071174316af5",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:51:23.000",
        "event": "mapping_hover",
        "id": "84HLAmhP9JwvaOoiHIP3"
    },
    {
        "data": {
            "structured_type": "unstructured",
            "section_id": "b6b77310-ab0b-44db-91fe-071174316af5",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:51:23.000",
        "event": "mapping_unhover",
        "id": "UAvHcXK04MdToTW91TV1"
    },
    {
        "data": {
            "mapping_index": 1,
            "structured_type": "unstructured",
            "section_id": "b6b77310-ab0b-44db-91fe-071174316af5",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:51:23.000",
        "event": "mapping_hover",
        "id": "YsWwqI37UZalDJj2XziA"
    },
    {
        "data": {
            "structured_type": "unstructured",
            "section_id": "b6b77310-ab0b-44db-91fe-071174316af5",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:51:23.000",
        "event": "mapping_unhover",
        "id": "aNoIU3eZ5KJIKCuCUSI9"
    },
    {
        "data": {
            "structured_type": "unstructured",
            "section_id": "b6b77310-ab0b-44db-91fe-071174316af5",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:51:23.000",
        "event": "mapping_unhover",
        "id": "tFWaw8LZwSzn0Me0Gkwv"
    },
    {
        "data": {
            "structured_type": "unstructured",
            "section_id": "b6b77310-ab0b-44db-91fe-071174316af5",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:51:45.000",
        "event": "mapping_unhover",
        "id": "9ChfyAx6bdXiHTR5428j"
    },
    {
        "data": {
            "mapping_index": 1,
            "structured_type": "unstructured",
            "section_id": "b6b77310-ab0b-44db-91fe-071174316af5",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:51:45.000",
        "event": "mapping_hover",
        "id": "9PyI08VCrFkQDzYxbmIG"
    },
    {
        "data": {
            "mapping_index": 2,
            "structured_type": "unstructured",
            "section_id": "b6b77310-ab0b-44db-91fe-071174316af5",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:51:45.000",
        "event": "mapping_hover",
        "id": "FDOZi3VQCXXVlHUDzisY"
    },
    {
        "data": {
            "mapping_index": 0,
            "structured_type": "unstructured",
            "section_id": "b6b77310-ab0b-44db-91fe-071174316af5",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:51:45.000",
        "event": "mapping_hover",
        "id": "QqPZdAAJLu4QK1aF4N8C"
    },
    {
        "data": {
            "structured_type": "unstructured",
            "section_id": "b6b77310-ab0b-44db-91fe-071174316af5",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:51:45.000",
        "event": "mapping_unhover",
        "id": "kZQrGjJnnyExweWCdQoK"
    },
    {
        "data": {
            "structured_type": "unstructured",
            "section_id": "b6b77310-ab0b-44db-91fe-071174316af5",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:51:45.000",
        "event": "mapping_unhover",
        "id": "nM7dEloJGbW56mU5ZYGL"
    },
    {
        "data": {
            "structured_type": "unstructured",
            "section_id": "b6b77310-ab0b-44db-91fe-071174316af5",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:51:46.000",
        "event": "mapping_unhover",
        "id": "4wj3JXBJIpRXOo2jyPoJ"
    },
    {
        "data": {
            "structured_type": "unstructured",
            "section_id": "b6b77310-ab0b-44db-91fe-071174316af5",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:51:46.000",
        "event": "mapping_unhover",
        "id": "GRsQgNZdJz4OZxvGcTgM"
    },
    {
        "data": {
            "mapping_index": 6,
            "structured_type": "unstructured",
            "section_id": "b6b77310-ab0b-44db-91fe-071174316af5",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:51:46.000",
        "event": "mapping_hover",
        "id": "UgRjjQEAR4IzGPOa06mJ"
    },
    {
        "data": {
            "mapping_index": 5,
            "structured_type": "unstructured",
            "section_id": "b6b77310-ab0b-44db-91fe-071174316af5",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:51:46.000",
        "event": "mapping_hover",
        "id": "fXzWaBmDaRxFmuvzt4L6"
    },
    {
        "data": {
            "mapping_index": 4,
            "structured_type": "unstructured",
            "section_id": "b6b77310-ab0b-44db-91fe-071174316af5",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:51:51.000",
        "event": "mapping_hover",
        "id": "AgAydOI89PKusYPhoTMe"
    },
    {
        "data": {
            "mapping_index": 1,
            "structured_type": "unstructured",
            "section_id": "b6b77310-ab0b-44db-91fe-071174316af5",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:51:51.000",
        "event": "mapping_hover",
        "id": "TME7kictZjM3HBxhrVqa"
    },
    {
        "data": {
            "structured_type": "unstructured",
            "section_id": "b6b77310-ab0b-44db-91fe-071174316af5",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:51:51.000",
        "event": "mapping_unhover",
        "id": "cdJSFZrpqe9tw630FCXD"
    },
    {
        "data": {
            "mapping_index": 2,
            "structured_type": "unstructured",
            "section_id": "b6b77310-ab0b-44db-91fe-071174316af5",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:51:51.000",
        "event": "mapping_hover",
        "id": "iVRTvz2h4mP6BAhhZVX4"
    },
    {
        "data": {
            "structured_type": "unstructured",
            "section_id": "b6b77310-ab0b-44db-91fe-071174316af5",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:51:51.000",
        "event": "mapping_unhover",
        "id": "uamWOWC4UBoG4UVXLwKi"
    },
    {
        "data": {
            "structured_type": "unstructured",
            "section_id": "b6b77310-ab0b-44db-91fe-071174316af5",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:51:52.000",
        "event": "mapping_unhover",
        "id": "7u14LCjt5Tkz8fF7Q8ui"
    },
    {
        "data": {
            "mapping_index": 2,
            "structured_type": "unstructured",
            "section_id": "b6b77310-ab0b-44db-91fe-071174316af5",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:51:52.000",
        "event": "mapping_hover",
        "id": "OG7Q6rahWkXfVaS9CMbC"
    },
    {
        "data": {
            "mapping_index": 1,
            "structured_type": "unstructured",
            "section_id": "b6b77310-ab0b-44db-91fe-071174316af5",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:51:52.000",
        "event": "mapping_hover",
        "id": "vyfAqw70mSqleGE8rUAB"
    },
    {
        "data": {
            "structured_type": "unstructured",
            "section_id": "b6b77310-ab0b-44db-91fe-071174316af5",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:51:52.000",
        "event": "mapping_unhover",
        "id": "wOS1WYEP2eD9510tETZq"
    },
    {
        "data": {
            "mapping_index": 0,
            "structured_type": "unstructured",
            "section_id": "b6b77310-ab0b-44db-91fe-071174316af5",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:51:53.000",
        "event": "mapping_hover",
        "id": "LMH59Tu1etWPPU6zAIpO"
    },
    {
        "data": {
            "structured_type": "unstructured",
            "section_id": "b6b77310-ab0b-44db-91fe-071174316af5",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:51:53.000",
        "event": "mapping_unhover",
        "id": "LUIDYPNhVgOZitl02oT9"
    },
    {
        "data": {
            "structured_type": "unstructured",
            "section_id": "b6b77310-ab0b-44db-91fe-071174316af5",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:51:53.000",
        "event": "mapping_unhover",
        "id": "OhHaEkaET7LHoMpCyYV2"
    },
    {
        "data": {
            "before_detail_level": "medium",
            "after_detail_level": "high",
            "before_structured": "unstructured",
            "section_id": "b6b77310-ab0b-44db-91fe-071174316af5",
            "after_structured": "unstructured"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:51:53.000",
        "event": "change_summary_level",
        "id": "t7GIn2MrH2BeVKxdb0Gn"
    },
    {
        "data": {
            "mapping_index": 0,
            "structured_type": "unstructured",
            "section_id": "b6b77310-ab0b-44db-91fe-071174316af5",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:51:54.000",
        "event": "mapping_hover",
        "id": "0mexqgmULIpMpeobr3sH"
    },
    {
        "data": {
            "structured_type": "unstructured",
            "section_id": "b6b77310-ab0b-44db-91fe-071174316af5",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:51:54.000",
        "event": "mapping_unhover",
        "id": "G8c3yCVhcCZxtbJudeZM"
    },
    {
        "data": {
            "mapping_index": 1,
            "structured_type": "unstructured",
            "section_id": "b6b77310-ab0b-44db-91fe-071174316af5",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:51:54.000",
        "event": "mapping_hover",
        "id": "teqBRNJqFLAsjbswkYYS"
    },
    {
        "data": {
            "mapping_index": 2,
            "structured_type": "unstructured",
            "section_id": "b6b77310-ab0b-44db-91fe-071174316af5",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:51:56.000",
        "event": "mapping_hover",
        "id": "Ivuwk6dtgbUl42rBw7qr"
    },
    {
        "data": {
            "structured_type": "unstructured",
            "section_id": "b6b77310-ab0b-44db-91fe-071174316af5",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:51:56.000",
        "event": "mapping_unhover",
        "id": "KE0jT2xJurU8vZUa3w1d"
    },
    {
        "data": {
            "mapping_index": 3,
            "structured_type": "unstructured",
            "section_id": "b6b77310-ab0b-44db-91fe-071174316af5",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:51:57.000",
        "event": "mapping_hover",
        "id": "7vgZfRv8B4hGbPUnuujc"
    },
    {
        "data": {
            "structured_type": "unstructured",
            "section_id": "b6b77310-ab0b-44db-91fe-071174316af5",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:51:57.000",
        "event": "mapping_unhover",
        "id": "iQAy8VY473IkYOUEeQ7U"
    },
    {
        "data": {
            "mapping_index": 6,
            "structured_type": "unstructured",
            "section_id": "b6b77310-ab0b-44db-91fe-071174316af5",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:51:58.000",
        "event": "mapping_hover",
        "id": "ABhH4QfRF4dH1sPqHUgt"
    },
    {
        "data": {
            "structured_type": "unstructured",
            "section_id": "b6b77310-ab0b-44db-91fe-071174316af5",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:51:58.000",
        "event": "mapping_unhover",
        "id": "MaxidchyMlGzihEWGkxp"
    },
    {
        "data": {
            "structured_type": "unstructured",
            "section_id": "b6b77310-ab0b-44db-91fe-071174316af5",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:51:58.000",
        "event": "mapping_unhover",
        "id": "YWGYUjAlCwPzCRvdoZnx"
    },
    {
        "data": {
            "mapping_index": 4,
            "structured_type": "unstructured",
            "section_id": "b6b77310-ab0b-44db-91fe-071174316af5",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:51:58.000",
        "event": "mapping_hover",
        "id": "dLcAt9hNfAsMaXIOnOGX"
    },
    {
        "data": {
            "structured_type": "unstructured",
            "section_id": "b6b77310-ab0b-44db-91fe-071174316af5",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:51:58.000",
        "event": "mapping_unhover",
        "id": "iMXOj4Atf6zzkRxNOnpN"
    },
    {
        "data": {
            "mapping_index": 7,
            "structured_type": "unstructured",
            "section_id": "b6b77310-ab0b-44db-91fe-071174316af5",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:51:58.000",
        "event": "mapping_hover",
        "id": "qithESTRuQRhsYItZ3uq"
    },
    {
        "data": {
            "structured_type": "unstructured",
            "section_id": "b6b77310-ab0b-44db-91fe-071174316af5",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:51:58.000",
        "event": "mapping_unhover",
        "id": "rBm40CEBARvK1lvvDCSw"
    },
    {
        "data": {
            "structured_type": "unstructured",
            "section_id": "b6b77310-ab0b-44db-91fe-071174316af5",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:51:58.000",
        "event": "mapping_unhover",
        "id": "rTIzL4ZnaXSMlLPYfFo4"
    },
    {
        "data": {
            "mapping_index": 5,
            "structured_type": "unstructured",
            "section_id": "b6b77310-ab0b-44db-91fe-071174316af5",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:51:58.000",
        "event": "mapping_hover",
        "id": "uZ3p2sojFAGzqwaBCg7Y"
    },
    {
        "data": {
            "mapping_index": 6,
            "structured_type": "unstructured",
            "section_id": "b6b77310-ab0b-44db-91fe-071174316af5",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:52:06.000",
        "event": "mapping_hover",
        "id": "KWClcFPtMb6rpjy8z6o2"
    },
    {
        "data": {
            "structured_type": "unstructured",
            "section_id": "b6b77310-ab0b-44db-91fe-071174316af5",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:52:06.000",
        "event": "mapping_unhover",
        "id": "hqTvWWDafOe0VzxeGMFE"
    },
    {
        "data": {
            "structured_type": "unstructured",
            "section_id": "b6b77310-ab0b-44db-91fe-071174316af5",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:52:12.000",
        "event": "mapping_unhover",
        "id": "FRrdkdw8zKKur1qmmUMA"
    },
    {
        "data": {
            "mapping_index": 2,
            "structured_type": "unstructured",
            "section_id": "b6b77310-ab0b-44db-91fe-071174316af5",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:52:12.000",
        "event": "mapping_hover",
        "id": "UoBEUi8iooD5O4nIZCwS"
    },
    {
        "data": {
            "structured_type": "unstructured",
            "section_id": "b6b77310-ab0b-44db-91fe-071174316af5",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:52:12.000",
        "event": "mapping_unhover",
        "id": "WzwdCr3cSx0hre1OFJn0"
    },
    {
        "data": {
            "mapping_index": 1,
            "structured_type": "unstructured",
            "section_id": "b6b77310-ab0b-44db-91fe-071174316af5",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:52:12.000",
        "event": "mapping_hover",
        "id": "cHKxEnZRZBbdMY1Hh5tY"
    },
    {
        "data": {
            "mapping_index": 0,
            "structured_type": "unstructured",
            "section_id": "b6b77310-ab0b-44db-91fe-071174316af5",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:52:12.000",
        "event": "mapping_hover",
        "id": "itSlIKTo4IUExDRA2GKt"
    },
    {
        "data": {
            "mapping_index": 1,
            "structured_type": "unstructured",
            "section_id": "b6b77310-ab0b-44db-91fe-071174316af5",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:52:13.000",
        "event": "mapping_hover",
        "id": "V222hRcZiePsbG9r326T"
    },
    {
        "data": {
            "structured_type": "unstructured",
            "section_id": "b6b77310-ab0b-44db-91fe-071174316af5",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:52:13.000",
        "event": "mapping_unhover",
        "id": "mTtqcxFhbABoGzQFcOnV"
    },
    {
        "data": {
            "structured_type": "unstructured",
            "section_id": "b6b77310-ab0b-44db-91fe-071174316af5",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:52:14.000",
        "event": "mapping_unhover",
        "id": "KVfnM8a7168tlFd4IUnR"
    },
    {
        "data": {
            "structured_type": "unstructured",
            "section_id": "b6b77310-ab0b-44db-91fe-071174316af5",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:52:14.000",
        "event": "mapping_unhover",
        "id": "LZMSeoYkKwUufowBlgqk"
    },
    {
        "data": {
            "structured_type": "unstructured",
            "section_id": "b6b77310-ab0b-44db-91fe-071174316af5",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:52:14.000",
        "event": "mapping_unhover",
        "id": "O9O7tBH6mBFT0YMwdyEg"
    },
    {
        "data": {
            "structured_type": "unstructured",
            "section_id": "b6b77310-ab0b-44db-91fe-071174316af5",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:52:14.000",
        "event": "mapping_unhover",
        "id": "WBeYiRZl7fwb7pi9HLCp"
    },
    {
        "data": {
            "mapping_index": 5,
            "structured_type": "unstructured",
            "section_id": "b6b77310-ab0b-44db-91fe-071174316af5",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:52:14.000",
        "event": "mapping_hover",
        "id": "aAtuOZRHlOka21cxLC10"
    },
    {
        "data": {
            "mapping_index": 7,
            "structured_type": "unstructured",
            "section_id": "b6b77310-ab0b-44db-91fe-071174316af5",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:52:14.000",
        "event": "mapping_hover",
        "id": "fBgkUPoesw8CNTJUXh0l"
    },
    {
        "data": {
            "mapping_index": 2,
            "structured_type": "unstructured",
            "section_id": "b6b77310-ab0b-44db-91fe-071174316af5",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:52:14.000",
        "event": "mapping_hover",
        "id": "hKy10VggJVl6te5RoZK8"
    },
    {
        "data": {
            "mapping_index": 1,
            "structured_type": "unstructured",
            "section_id": "b6b77310-ab0b-44db-91fe-071174316af5",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:52:21.000",
        "event": "mapping_hover",
        "id": "1JJ2Vn7xvhtXrd4Rzenr"
    },
    {
        "data": {
            "structured_type": "unstructured",
            "section_id": "b6b77310-ab0b-44db-91fe-071174316af5",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:52:21.000",
        "event": "mapping_unhover",
        "id": "2UnJiL59lJB2BQtl0gHx"
    },
    {
        "data": {
            "mapping_index": 7,
            "structured_type": "unstructured",
            "section_id": "b6b77310-ab0b-44db-91fe-071174316af5",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:52:21.000",
        "event": "mapping_hover",
        "id": "8loBZm1csNACYb6sNC0E"
    },
    {
        "data": {
            "structured_type": "unstructured",
            "section_id": "b6b77310-ab0b-44db-91fe-071174316af5",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:52:21.000",
        "event": "mapping_unhover",
        "id": "sgnsuJ3WshBzYFcGWne9"
    },
    {
        "data": {
            "mapping_index": 0,
            "structured_type": "unstructured",
            "section_id": "b6b77310-ab0b-44db-91fe-071174316af5",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:52:24.000",
        "event": "mapping_hover",
        "id": "Z3a1jHTGERR2YxD8ZagX"
    },
    {
        "data": {
            "mapping_index": 2,
            "structured_type": "unstructured",
            "section_id": "b6b77310-ab0b-44db-91fe-071174316af5",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:52:25.000",
        "event": "mapping_hover",
        "id": "2aGi0oZgeIYM8cbcwRtO"
    },
    {
        "data": {
            "structured_type": "unstructured",
            "section_id": "b6b77310-ab0b-44db-91fe-071174316af5",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:52:25.000",
        "event": "mapping_unhover",
        "id": "DmtLfMXSRKZoC8VY8347"
    },
    {
        "data": {
            "mapping_index": 6,
            "structured_type": "unstructured",
            "section_id": "b6b77310-ab0b-44db-91fe-071174316af5",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:52:25.000",
        "event": "mapping_hover",
        "id": "FqSTH1OhRgygTVEeLCBe"
    },
    {
        "data": {
            "structured_type": "unstructured",
            "section_id": "b6b77310-ab0b-44db-91fe-071174316af5",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:52:25.000",
        "event": "mapping_unhover",
        "id": "NlwlX36GElIVN8VBePHr"
    },
    {
        "data": {
            "structured_type": "unstructured",
            "section_id": "b6b77310-ab0b-44db-91fe-071174316af5",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:52:25.000",
        "event": "mapping_unhover",
        "id": "PCvT8ML4kQak9UcIZF59"
    },
    {
        "data": {
            "structured_type": "unstructured",
            "section_id": "b6b77310-ab0b-44db-91fe-071174316af5",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:52:25.000",
        "event": "mapping_unhover",
        "id": "YWrAVXBI9P763DXfXJIn"
    },
    {
        "data": {
            "mapping_index": 4,
            "structured_type": "unstructured",
            "section_id": "b6b77310-ab0b-44db-91fe-071174316af5",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:52:25.000",
        "event": "mapping_hover",
        "id": "ZoUpDoEY7IVJXWp4pDiS"
    },
    {
        "data": {
            "structured_type": "unstructured",
            "section_id": "b6b77310-ab0b-44db-91fe-071174316af5",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:52:25.000",
        "event": "mapping_unhover",
        "id": "fMtJ4P80VdgHIfMwIQec"
    },
    {
        "data": {
            "mapping_index": 1,
            "structured_type": "unstructured",
            "section_id": "b6b77310-ab0b-44db-91fe-071174316af5",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:52:25.000",
        "event": "mapping_hover",
        "id": "i2ugb0pR8uBP2Reqlu6J"
    },
    {
        "data": {
            "mapping_index": 7,
            "structured_type": "unstructured",
            "section_id": "b6b77310-ab0b-44db-91fe-071174316af5",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:52:25.000",
        "event": "mapping_hover",
        "id": "pj07jlO7iBup9e6kbfiW"
    },
    {
        "data": {
            "structured_type": "unstructured",
            "section_id": "b6b77310-ab0b-44db-91fe-071174316af5",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:52:25.000",
        "event": "mapping_unhover",
        "id": "rvQkjvYKrBOjR1J6LV5C"
    },
    {
        "data": {
            "instruction": "For the bar plot, use a grouped bar chart to compare each players true and predicted rank",
            "section_id": "b6b77310-ab0b-44db-91fe-071174316af5"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:52:31.000",
        "event": "commit_direct_instruction",
        "id": "39Gks9LNY1Qgf1ZN1FtH"
    },
    {
        "data": {
            "instruction": "For the bar plot, use a grouped bar chart to compare each players true and predicted rank",
            "original_code": "def plot_ranking_predictions(df, year):\n    \"\"\"\n    Plot prediction error for a specific year.\n\n    Args:\n        df: DataFrame containing prediction results\n        year: Year to plot prediction errors for\n    \"\"\"\n    df[\"RankError\"] = df[\"PredictedRank\"] - df[\"Rank\"]\n    year_df = df[df[\"Year\"] == year].copy()\n    year_df.sort_values(\"Rank\", inplace=True)\n\n    plt.figure(figsize=(12, 6))\n    sns.barplot(x=\"Name\", y=\"RankError\", data=year_df, hue=\"Name\", palette=\"coolwarm\")\n    plt.axhline(0, color=\"black\", linestyle=\"--\")\n    plt.xticks(rotation=45, ha=\"right\")\n    plt.ylabel(\"Predicted Rank - True Rank\")\n    plt.title(f\"MVP Ranking Predictions ({year})\")\n    plt.tight_layout()\n    plt.savefig(f\"data/ranking_predictions_{year}.png\")",
            "updated_code": "def plot_ranking_predictions(df, year):\n    \"\"\"\n    Plot prediction error for a specific year.\n\n    Args:\n        df: DataFrame containing prediction results\n        year: Year to plot prediction errors for\n    \"\"\"\n    year_df = df[df[\"Year\"] == year].copy()\n    year_df.sort_values(\"Rank\", inplace=True)\n\n    # Prepare data for grouped bar chart\n    plot_df = year_df[[\"Name\", \"Rank\", \"PredictedRank\"]].melt(\n        id_vars=\"Name\", value_vars=[\"Rank\", \"PredictedRank\"], var_name=\"Type\", value_name=\"Value\"\n    )\n\n    plt.figure(figsize=(12, 6))\n    sns.barplot(x=\"Name\", y=\"Value\", hue=\"Type\", data=plot_df, palette=\"coolwarm\")\n    plt.xticks(rotation=45, ha=\"right\")\n    plt.ylabel(\"Rank\")\n    plt.title(f\"MVP Ranking Predictions ({year})\")\n    plt.tight_layout()\n    plt.savefig(f\"data/ranking_predictions_{year}.png\")"
        },
        "source": "backend",
        "timestamp": "2025-08-23 10:52:33.000",
        "event": "modify_direct_instruction",
        "id": "odjluHeMFI4Xq32Im4xX"
    },
    {
        "data": {
            "new_code": "def plot_ranking_predictions(df, year):\n    \"\"\"\n    Plot prediction error for a specific year.\n\n    Args:\n        df: DataFrame containing prediction results\n        year: Year to plot prediction errors for\n    \"\"\"\n    year_df = df[df[\"Year\"] == year].copy()\n    year_df.sort_values(\"Rank\", inplace=True)\n\n    # Prepare data for grouped bar chart\n    plot_df = year_df[[\"Name\", \"Rank\", \"PredictedRank\"]].melt(\n        id_vars=\"Name\", value_vars=[\"Rank\", \"PredictedRank\"], var_name=\"Type\", value_name=\"Value\"\n    )\n\n    plt.figure(figsize=(12, 6))\n    sns.barplot(x=\"Name\", y=\"Value\", hue=\"Type\", data=plot_df, palette=\"coolwarm\")\n    plt.xticks(rotation=45, ha=\"right\")\n    plt.ylabel(\"Rank\")\n    plt.title(f\"MVP Ranking Predictions ({year})\")\n    plt.tight_layout()\n    plt.savefig(f\"data/ranking_predictions_{year}.png\")",
            "old_summary": {
                "medium_unstructured": "The plot_ranking_predictions function visualizes the difference between predicted and actual ranks for a specified year. It generates a bar plot showing these errors for each player and saves the figure as a PNG file. The plot helps assess the accuracy of ranking predictions.",
                "low_structured": "• Plots prediction errors for a specified year\n• Saves the plot as a PNG file",
                "title": "plot_ranking_predictions Function Summary",
                "medium_structured": "• Calculates prediction errors as the difference between predicted and true ranks\n• Filters the DataFrame for the specified year and sorts by actual rank\n• Creates and saves a bar plot of rank errors for each player",
                "high_unstructured": "The plot_ranking_predictions function visualizes the prediction errors of player rankings for a given year. It computes the 'RankError' as the difference between each player's predicted and actual rank, then filters and sorts the data for the specified year. A bar plot is generated using Seaborn, with each player's error displayed and a horizontal reference line at zero to indicate perfect predictions. The plot is formatted for readability and saved as a PNG file named according to the year.",
                "high_structured": "• Computes 'RankError' as PredictedRank minus actual Rank for each player\n• Filters the DataFrame to include only entries from the specified year\n  ◦ Makes a copy and sorts it by actual Rank for consistent plotting\n• Sets up a matplotlib figure with a specific size\n• Uses Seaborn to create a bar plot of RankError for each player, colored by player name\n• Adds a horizontal dashed line at zero to indicate no prediction error\n• Rotates x-axis labels for readability and sets axis labels and plot title\n• Adjusts layout and saves the plot as a PNG file named with the year",
                "low_unstructured": "This function creates and saves a bar plot of prediction errors for a given year."
            },
            "original_code": "def plot_ranking_predictions(df, year):\n    \"\"\"\n    Plot prediction error for a specific year.\n\n    Args:\n        df: DataFrame containing prediction results\n        year: Year to plot prediction errors for\n    \"\"\"\n    year_df = df[df[\"Year\"] == year].copy()\n    year_df.sort_values(\"Rank\", inplace=True)\n\n    # Prepare data for grouped bar chart\n    plot_df = year_df[[\"Name\", \"Rank\", \"PredictedRank\"]].melt(\n        id_vars=\"Name\", value_vars=[\"Rank\", \"PredictedRank\"], var_name=\"Type\", value_name=\"Value\"\n    )\n\n    plt.figure(figsize=(12, 6))\n    sns.barplot(x=\"Name\", y=\"Value\", hue=\"Type\", data=plot_df, palette=\"coolwarm\")\n    plt.xticks(rotation=45, ha=\"right\")\n    plt.ylabel(\"Rank\")\n    plt.title(f\"MVP Ranking Predictions ({year})\")\n    plt.tight_layout()\n    plt.savefig(f\"data/ranking_predictions_{year}.png\")",
            "new_summary": {
                "medium_unstructured": "The plot_ranking_predictions function visualizes both the predicted and actual ranks for a specified year. It generates a grouped bar plot showing these values for each player and saves the figure as a PNG file. The plot helps assess the accuracy of ranking predictions by direct comparison.",
                "low_structured": "• Plots actual and predicted ranks for a specified year as grouped bars\n• Saves the plot as a PNG file",
                "title": "plot_ranking_predictions Function Summary",
                "medium_structured": "• Displays both predicted and true ranks for each player as grouped bars\n• Filters the DataFrame for the specified year and sorts by actual rank\n• Creates and saves a grouped bar plot of actual and predicted ranks for each player",
                "high_unstructured": "The plot_ranking_predictions function visualizes the actual and predicted player rankings for a given year. It reshapes the data to include both 'Rank' and 'PredictedRank' for each player, then filters and sorts the data for the specified year. A grouped bar plot is generated using Seaborn, with each player's actual and predicted ranks displayed side by side for direct comparison. The plot is formatted for readability and saved as a PNG file named according to the year.",
                "high_structured": "• Reshapes the DataFrame to include both 'Rank' and 'PredictedRank' for each player\n• Filters the DataFrame to include only entries from the specified year\n  ◦ Makes a copy and sorts it by actual Rank for consistent plotting\n• Sets up a matplotlib figure with a specific size\n• Uses Seaborn to create a grouped bar plot of actual and predicted ranks for each player, colored by type\n• Rotates x-axis labels for readability and sets axis labels and plot title\n• Adjusts layout and saves the plot as a PNG file named with the year",
                "low_unstructured": "This function creates and saves a grouped bar plot comparing actual and predicted ranks for a given year."
            }
        },
        "source": "backend",
        "timestamp": "2025-08-23 10:52:40.000",
        "event": "summarize_modified_code",
        "id": "95rbldXueiiKVzLKfToV"
    },
    {
        "data": {
            "mapping": [
                {
                    "summaryComponent": "Displays both predicted and true ranks for each player as grouped bars",
                    "codeSegments": [
                        {
                            "line": 64,
                            "code": "plot_df = year_df[[\"Name\", \"Rank\", \"PredictedRank\"]].melt("
                        },
                        {
                            "line": 69,
                            "code": "sns.barplot(x=\"Name\", y=\"Value\", hue=\"Type\", data=plot_df, palette=\"coolwarm\")"
                        }
                    ]
                },
                {
                    "summaryComponent": "Filters the DataFrame for the specified year and sorts by actual rank",
                    "codeSegments": [
                        {
                            "line": 60,
                            "code": "year_df = df[df[\"Year\"] == year].copy()"
                        },
                        {
                            "line": 61,
                            "code": "year_df.sort_values(\"Rank\", inplace=True)"
                        }
                    ]
                },
                {
                    "summaryComponent": "Creates and saves a grouped bar plot of actual and predicted ranks for each player",
                    "codeSegments": [
                        {
                            "line": 69,
                            "code": "sns.barplot(x=\"Name\", y=\"Value\", hue=\"Type\", data=plot_df, palette=\"coolwarm\")"
                        },
                        {
                            "line": 74,
                            "code": "plt.savefig(f\"data/ranking_predictions_{year}.png\")"
                        }
                    ]
                }
            ],
            "summary": "• Displays both predicted and true ranks for each player as grouped bars\n• Filters the DataFrame for the specified year and sorts by actual rank\n• Creates and saves a grouped bar plot of actual and predicted ranks for each player",
            "code": "52: def plot_ranking_predictions(df, year):\n53:     \"\"\"\n54:     Plot prediction error for a specific year.\n55: \n56:     Args:\n57:         df: DataFrame containing prediction results\n58:         year: Year to plot prediction errors for\n59:     \"\"\"\n60:     year_df = df[df[\"Year\"] == year].copy()\n61:     year_df.sort_values(\"Rank\", inplace=True)\n62: \n63:     # Prepare data for grouped bar chart\n64:     plot_df = year_df[[\"Name\", \"Rank\", \"PredictedRank\"]].melt(\n65:         id_vars=\"Name\", value_vars=[\"Rank\", \"PredictedRank\"], var_name=\"Type\", value_name=\"Value\"\n66:     )\n67: \n68:     plt.figure(figsize=(12, 6))\n69:     sns.barplot(x=\"Name\", y=\"Value\", hue=\"Type\", data=plot_df, palette=\"coolwarm\")\n70:     plt.xticks(rotation=45, ha=\"right\")\n71:     plt.ylabel(\"Rank\")\n72:     plt.title(f\"MVP Ranking Predictions ({year})\")\n73:     plt.tight_layout()\n74:     plt.savefig(f\"data/ranking_predictions_{year}.png\")"
        },
        "source": "backend",
        "timestamp": "2025-08-23 10:52:43.000",
        "event": "map_summary_code",
        "id": "7Puwvd8w3JiMU1WrQNZ4"
    },
    {
        "data": {
            "mapping": [
                {
                    "summaryComponent": "This function creates",
                    "codeSegments": [
                        {
                            "line": 52,
                            "code": "def plot_ranking_predictions(df, year):"
                        }
                    ]
                },
                {
                    "summaryComponent": "saves",
                    "codeSegments": [
                        {
                            "line": 74,
                            "code": "plt.savefig(f\"data/ranking_predictions_{year}.png\")"
                        }
                    ]
                },
                {
                    "summaryComponent": "a grouped bar plot",
                    "codeSegments": [
                        {
                            "line": 69,
                            "code": "sns.barplot(x=\"Name\", y=\"Value\", hue=\"Type\", data=plot_df, palette=\"coolwarm\")"
                        }
                    ]
                },
                {
                    "summaryComponent": "comparing actual and predicted ranks",
                    "codeSegments": [
                        {
                            "line": 64,
                            "code": "plot_df = year_df[[\"Name\", \"Rank\", \"PredictedRank\"]].melt("
                        },
                        {
                            "line": 65,
                            "code": "id_vars=\"Name\", value_vars=[\"Rank\", \"PredictedRank\"], var_name=\"Type\", value_name=\"Value\""
                        }
                    ]
                },
                {
                    "summaryComponent": "for a given year.",
                    "codeSegments": [
                        {
                            "line": 60,
                            "code": "year_df = df[df[\"Year\"] == year].copy()"
                        }
                    ]
                }
            ],
            "summary": "This function creates and saves a grouped bar plot comparing actual and predicted ranks for a given year.",
            "code": "52: def plot_ranking_predictions(df, year):\n53:     \"\"\"\n54:     Plot prediction error for a specific year.\n55: \n56:     Args:\n57:         df: DataFrame containing prediction results\n58:         year: Year to plot prediction errors for\n59:     \"\"\"\n60:     year_df = df[df[\"Year\"] == year].copy()\n61:     year_df.sort_values(\"Rank\", inplace=True)\n62: \n63:     # Prepare data for grouped bar chart\n64:     plot_df = year_df[[\"Name\", \"Rank\", \"PredictedRank\"]].melt(\n65:         id_vars=\"Name\", value_vars=[\"Rank\", \"PredictedRank\"], var_name=\"Type\", value_name=\"Value\"\n66:     )\n67: \n68:     plt.figure(figsize=(12, 6))\n69:     sns.barplot(x=\"Name\", y=\"Value\", hue=\"Type\", data=plot_df, palette=\"coolwarm\")\n70:     plt.xticks(rotation=45, ha=\"right\")\n71:     plt.ylabel(\"Rank\")\n72:     plt.title(f\"MVP Ranking Predictions ({year})\")\n73:     plt.tight_layout()\n74:     plt.savefig(f\"data/ranking_predictions_{year}.png\")"
        },
        "source": "backend",
        "timestamp": "2025-08-23 10:52:43.000",
        "event": "map_summary_code",
        "id": "RoOiaN4eNhdOW7Ed2Jb2"
    },
    {
        "data": {
            "mapping": [
                {
                    "summaryComponent": "Plots actual and predicted ranks for a specified year as grouped bars",
                    "codeSegments": [
                        {
                            "line": 60,
                            "code": "year_df = df[df[\"Year\"] == year].copy()"
                        },
                        {
                            "line": 61,
                            "code": "year_df.sort_values(\"Rank\", inplace=True)"
                        },
                        {
                            "line": 64,
                            "code": "plot_df = year_df[[\"Name\", \"Rank\", \"PredictedRank\"]].melt("
                        },
                        {
                            "line": 65,
                            "code": "id_vars=\"Name\", value_vars=[\"Rank\", \"PredictedRank\"], var_name=\"Type\", value_name=\"Value\""
                        },
                        {
                            "line": 69,
                            "code": "sns.barplot(x=\"Name\", y=\"Value\", hue=\"Type\", data=plot_df, palette=\"coolwarm\")"
                        }
                    ]
                },
                {
                    "summaryComponent": "Saves the plot as a PNG file",
                    "codeSegments": [
                        {
                            "line": 74,
                            "code": "plt.savefig(f\"data/ranking_predictions_{year}.png\")"
                        }
                    ]
                }
            ],
            "summary": "• Plots actual and predicted ranks for a specified year as grouped bars\n• Saves the plot as a PNG file",
            "code": "52: def plot_ranking_predictions(df, year):\n53:     \"\"\"\n54:     Plot prediction error for a specific year.\n55: \n56:     Args:\n57:         df: DataFrame containing prediction results\n58:         year: Year to plot prediction errors for\n59:     \"\"\"\n60:     year_df = df[df[\"Year\"] == year].copy()\n61:     year_df.sort_values(\"Rank\", inplace=True)\n62: \n63:     # Prepare data for grouped bar chart\n64:     plot_df = year_df[[\"Name\", \"Rank\", \"PredictedRank\"]].melt(\n65:         id_vars=\"Name\", value_vars=[\"Rank\", \"PredictedRank\"], var_name=\"Type\", value_name=\"Value\"\n66:     )\n67: \n68:     plt.figure(figsize=(12, 6))\n69:     sns.barplot(x=\"Name\", y=\"Value\", hue=\"Type\", data=plot_df, palette=\"coolwarm\")\n70:     plt.xticks(rotation=45, ha=\"right\")\n71:     plt.ylabel(\"Rank\")\n72:     plt.title(f\"MVP Ranking Predictions ({year})\")\n73:     plt.tight_layout()\n74:     plt.savefig(f\"data/ranking_predictions_{year}.png\")"
        },
        "source": "backend",
        "timestamp": "2025-08-23 10:52:43.000",
        "event": "map_summary_code",
        "id": "XOBi5aNQGfKjgkY2tn81"
    },
    {
        "data": {
            "mapping": [
                {
                    "summaryComponent": "Reshapes the DataFrame to include both 'Rank' and 'PredictedRank' for each player",
                    "codeSegments": [
                        {
                            "line": 64,
                            "code": "plot_df = year_df[[\"Name\", \"Rank\", \"PredictedRank\"]].melt("
                        },
                        {
                            "line": 65,
                            "code": "id_vars=\"Name\", value_vars=[\"Rank\", \"PredictedRank\"], var_name=\"Type\", value_name=\"Value\""
                        }
                    ]
                },
                {
                    "summaryComponent": "Filters the DataFrame to include only entries from the specified year",
                    "codeSegments": [
                        {
                            "line": 60,
                            "code": "year_df = df[df[\"Year\"] == year].copy()"
                        }
                    ]
                },
                {
                    "summaryComponent": "Makes a copy and sorts it by actual Rank for consistent plotting",
                    "codeSegments": [
                        {
                            "line": 60,
                            "code": "year_df = df[df[\"Year\"] == year].copy()"
                        },
                        {
                            "line": 61,
                            "code": "year_df.sort_values(\"Rank\", inplace=True)"
                        }
                    ]
                },
                {
                    "summaryComponent": "Sets up a matplotlib figure with a specific size",
                    "codeSegments": [
                        {
                            "line": 68,
                            "code": "plt.figure(figsize=(12, 6))"
                        }
                    ]
                },
                {
                    "summaryComponent": "Uses Seaborn to create a grouped bar plot of actual and predicted ranks for each player, colored by type",
                    "codeSegments": [
                        {
                            "line": 69,
                            "code": "sns.barplot(x=\"Name\", y=\"Value\", hue=\"Type\", data=plot_df, palette=\"coolwarm\")"
                        }
                    ]
                },
                {
                    "summaryComponent": "Rotates x-axis labels for readability and sets axis labels and plot title",
                    "codeSegments": [
                        {
                            "line": 70,
                            "code": "plt.xticks(rotation=45, ha=\"right\")"
                        },
                        {
                            "line": 71,
                            "code": "plt.ylabel(\"Rank\")"
                        },
                        {
                            "line": 72,
                            "code": "plt.title(f\"MVP Ranking Predictions ({year})\")"
                        }
                    ]
                },
                {
                    "summaryComponent": "Adjusts layout and saves the plot as a PNG file named with the year",
                    "codeSegments": [
                        {
                            "line": 73,
                            "code": "plt.tight_layout()"
                        },
                        {
                            "line": 74,
                            "code": "plt.savefig(f\"data/ranking_predictions_{year}.png\")"
                        }
                    ]
                }
            ],
            "summary": "• Reshapes the DataFrame to include both 'Rank' and 'PredictedRank' for each player\n• Filters the DataFrame to include only entries from the specified year\n  ◦ Makes a copy and sorts it by actual Rank for consistent plotting\n• Sets up a matplotlib figure with a specific size\n• Uses Seaborn to create a grouped bar plot of actual and predicted ranks for each player, colored by type\n• Rotates x-axis labels for readability and sets axis labels and plot title\n• Adjusts layout and saves the plot as a PNG file named with the year",
            "code": "52: def plot_ranking_predictions(df, year):\n53:     \"\"\"\n54:     Plot prediction error for a specific year.\n55: \n56:     Args:\n57:         df: DataFrame containing prediction results\n58:         year: Year to plot prediction errors for\n59:     \"\"\"\n60:     year_df = df[df[\"Year\"] == year].copy()\n61:     year_df.sort_values(\"Rank\", inplace=True)\n62: \n63:     # Prepare data for grouped bar chart\n64:     plot_df = year_df[[\"Name\", \"Rank\", \"PredictedRank\"]].melt(\n65:         id_vars=\"Name\", value_vars=[\"Rank\", \"PredictedRank\"], var_name=\"Type\", value_name=\"Value\"\n66:     )\n67: \n68:     plt.figure(figsize=(12, 6))\n69:     sns.barplot(x=\"Name\", y=\"Value\", hue=\"Type\", data=plot_df, palette=\"coolwarm\")\n70:     plt.xticks(rotation=45, ha=\"right\")\n71:     plt.ylabel(\"Rank\")\n72:     plt.title(f\"MVP Ranking Predictions ({year})\")\n73:     plt.tight_layout()\n74:     plt.savefig(f\"data/ranking_predictions_{year}.png\")"
        },
        "source": "backend",
        "timestamp": "2025-08-23 10:52:44.000",
        "event": "map_summary_code",
        "id": "rJ9CmJQTazAXk7QnbEsP"
    },
    {
        "data": {
            "mapping": [
                {
                    "summaryComponent": "The plot_ranking_predictions function",
                    "codeSegments": [
                        {
                            "line": 52,
                            "code": "def plot_ranking_predictions(df, year):"
                        }
                    ]
                },
                {
                    "summaryComponent": "visualizes the actual and predicted player rankings for a given year",
                    "codeSegments": [
                        {
                            "line": 72,
                            "code": "plt.title(f\"MVP Ranking Predictions ({year})\")"
                        },
                        {
                            "line": 69,
                            "code": "sns.barplot(x=\"Name\", y=\"Value\", hue=\"Type\", data=plot_df, palette=\"coolwarm\")"
                        }
                    ]
                },
                {
                    "summaryComponent": "It reshapes the data to include both 'Rank' and 'PredictedRank' for each player",
                    "codeSegments": [
                        {
                            "line": 64,
                            "code": "plot_df = year_df[[\"Name\", \"Rank\", \"PredictedRank\"]].melt("
                        },
                        {
                            "line": 65,
                            "code": "id_vars=\"Name\", value_vars=[\"Rank\", \"PredictedRank\"], var_name=\"Type\", value_name=\"Value\""
                        }
                    ]
                },
                {
                    "summaryComponent": "then filters and sorts the data for the specified year",
                    "codeSegments": [
                        {
                            "line": 60,
                            "code": "year_df = df[df[\"Year\"] == year].copy()"
                        },
                        {
                            "line": 61,
                            "code": "year_df.sort_values(\"Rank\", inplace=True)"
                        }
                    ]
                },
                {
                    "summaryComponent": "A grouped bar plot is generated using Seaborn",
                    "codeSegments": [
                        {
                            "line": 69,
                            "code": "sns.barplot(x=\"Name\", y=\"Value\", hue=\"Type\", data=plot_df, palette=\"coolwarm\")"
                        }
                    ]
                },
                {
                    "summaryComponent": "with each player's actual and predicted ranks displayed side by side for direct comparison",
                    "codeSegments": [
                        {
                            "line": 69,
                            "code": "sns.barplot(x=\"Name\", y=\"Value\", hue=\"Type\", data=plot_df, palette=\"coolwarm\")"
                        }
                    ]
                },
                {
                    "summaryComponent": "The plot is formatted for readability",
                    "codeSegments": [
                        {
                            "line": 70,
                            "code": "plt.xticks(rotation=45, ha=\"right\")"
                        },
                        {
                            "line": 71,
                            "code": "plt.ylabel(\"Rank\")"
                        },
                        {
                            "line": 72,
                            "code": "plt.title(f\"MVP Ranking Predictions ({year})\")"
                        },
                        {
                            "line": 73,
                            "code": "plt.tight_layout()"
                        }
                    ]
                },
                {
                    "summaryComponent": "and saved as a PNG file named according to the year",
                    "codeSegments": [
                        {
                            "line": 74,
                            "code": "plt.savefig(f\"data/ranking_predictions_{year}.png\")"
                        }
                    ]
                }
            ],
            "summary": "The plot_ranking_predictions function visualizes the actual and predicted player rankings for a given year. It reshapes the data to include both 'Rank' and 'PredictedRank' for each player, then filters and sorts the data for the specified year. A grouped bar plot is generated using Seaborn, with each player's actual and predicted ranks displayed side by side for direct comparison. The plot is formatted for readability and saved as a PNG file named according to the year.",
            "code": "52: def plot_ranking_predictions(df, year):\n53:     \"\"\"\n54:     Plot prediction error for a specific year.\n55: \n56:     Args:\n57:         df: DataFrame containing prediction results\n58:         year: Year to plot prediction errors for\n59:     \"\"\"\n60:     year_df = df[df[\"Year\"] == year].copy()\n61:     year_df.sort_values(\"Rank\", inplace=True)\n62: \n63:     # Prepare data for grouped bar chart\n64:     plot_df = year_df[[\"Name\", \"Rank\", \"PredictedRank\"]].melt(\n65:         id_vars=\"Name\", value_vars=[\"Rank\", \"PredictedRank\"], var_name=\"Type\", value_name=\"Value\"\n66:     )\n67: \n68:     plt.figure(figsize=(12, 6))\n69:     sns.barplot(x=\"Name\", y=\"Value\", hue=\"Type\", data=plot_df, palette=\"coolwarm\")\n70:     plt.xticks(rotation=45, ha=\"right\")\n71:     plt.ylabel(\"Rank\")\n72:     plt.title(f\"MVP Ranking Predictions ({year})\")\n73:     plt.tight_layout()\n74:     plt.savefig(f\"data/ranking_predictions_{year}.png\")"
        },
        "source": "backend",
        "timestamp": "2025-08-23 10:52:45.000",
        "event": "map_summary_code",
        "id": "eF4QcsqxgysorjRxjLpW"
    },
    {
        "data": {
            "before_section_id": "b6b77310-ab0b-44db-91fe-071174316af5",
            "after_section_id": "99fc83b5-aef9-4d3c-ada9-c5e0760078ff"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:52:50.000",
        "event": "autotransit_section",
        "id": "ZvhuHhVnQpyjxosfTaAM"
    },
    {
        "data": {
            "section_data": {
                "lines": [
                    52,
                    74
                ],
                "summaryMappings": {
                    "medium_unstructured": [
                        {
                            "summaryComponent": "The plot_ranking_predictions function",
                            "codeSegments": [
                                {
                                    "line": 52,
                                    "code": "def plot_ranking_predictions(df, year):"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "visualizes both the predicted and actual ranks",
                            "codeSegments": [
                                {
                                    "line": 64,
                                    "code": "plot_df = year_df[[\"Name\", \"Rank\", \"PredictedRank\"]].melt("
                                },
                                {
                                    "line": 65,
                                    "code": "value_vars=[\"Rank\", \"PredictedRank\"]"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "for a specified year",
                            "codeSegments": [
                                {
                                    "line": 60,
                                    "code": "year_df = df[df[\"Year\"] == year].copy()"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "It generates a grouped bar plot",
                            "codeSegments": [
                                {
                                    "line": 69,
                                    "code": "sns.barplot(x=\"Name\", y=\"Value\", hue=\"Type\", data=plot_df, palette=\"coolwarm\")"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "showing these values for each player",
                            "codeSegments": [
                                {
                                    "line": 69,
                                    "code": "x=\"Name\""
                                }
                            ]
                        },
                        {
                            "summaryComponent": "and saves the figure as a PNG file",
                            "codeSegments": [
                                {
                                    "line": 74,
                                    "code": "plt.savefig(f\"data/ranking_predictions_{year}.png\")"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "The plot helps assess the accuracy of ranking predictions by direct comparison.",
                            "codeSegments": [
                                {
                                    "line": 69,
                                    "code": "sns.barplot(x=\"Name\", y=\"Value\", hue=\"Type\", data=plot_df, palette=\"coolwarm\")"
                                }
                            ]
                        }
                    ],
                    "low_structured": [
                        {
                            "summaryComponent": "Plots actual and predicted ranks for a specified year as grouped bars",
                            "codeSegments": [
                                {
                                    "line": 60,
                                    "code": "year_df = df[df[\"Year\"] == year].copy()"
                                },
                                {
                                    "line": 61,
                                    "code": "year_df.sort_values(\"Rank\", inplace=True)"
                                },
                                {
                                    "line": 64,
                                    "code": "plot_df = year_df[[\"Name\", \"Rank\", \"PredictedRank\"]].melt("
                                },
                                {
                                    "line": 65,
                                    "code": "id_vars=\"Name\", value_vars=[\"Rank\", \"PredictedRank\"], var_name=\"Type\", value_name=\"Value\""
                                },
                                {
                                    "line": 69,
                                    "code": "sns.barplot(x=\"Name\", y=\"Value\", hue=\"Type\", data=plot_df, palette=\"coolwarm\")"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "Saves the plot as a PNG file",
                            "codeSegments": [
                                {
                                    "line": 74,
                                    "code": "plt.savefig(f\"data/ranking_predictions_{year}.png\")"
                                }
                            ]
                        }
                    ],
                    "low_unstructured": [
                        {
                            "summaryComponent": "This function creates",
                            "codeSegments": [
                                {
                                    "line": 52,
                                    "code": "def plot_ranking_predictions(df, year):"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "saves",
                            "codeSegments": [
                                {
                                    "line": 74,
                                    "code": "plt.savefig(f\"data/ranking_predictions_{year}.png\")"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "a grouped bar plot",
                            "codeSegments": [
                                {
                                    "line": 69,
                                    "code": "sns.barplot(x=\"Name\", y=\"Value\", hue=\"Type\", data=plot_df, palette=\"coolwarm\")"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "comparing actual and predicted ranks",
                            "codeSegments": [
                                {
                                    "line": 64,
                                    "code": "plot_df = year_df[[\"Name\", \"Rank\", \"PredictedRank\"]].melt("
                                },
                                {
                                    "line": 65,
                                    "code": "id_vars=\"Name\", value_vars=[\"Rank\", \"PredictedRank\"], var_name=\"Type\", value_name=\"Value\""
                                }
                            ]
                        },
                        {
                            "summaryComponent": "for a given year.",
                            "codeSegments": [
                                {
                                    "line": 60,
                                    "code": "year_df = df[df[\"Year\"] == year].copy()"
                                }
                            ]
                        }
                    ],
                    "medium_structured": [
                        {
                            "summaryComponent": "Displays both predicted and true ranks for each player as grouped bars",
                            "codeSegments": [
                                {
                                    "line": 64,
                                    "code": "plot_df = year_df[[\"Name\", \"Rank\", \"PredictedRank\"]].melt("
                                },
                                {
                                    "line": 69,
                                    "code": "sns.barplot(x=\"Name\", y=\"Value\", hue=\"Type\", data=plot_df, palette=\"coolwarm\")"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "Filters the DataFrame for the specified year and sorts by actual rank",
                            "codeSegments": [
                                {
                                    "line": 60,
                                    "code": "year_df = df[df[\"Year\"] == year].copy()"
                                },
                                {
                                    "line": 61,
                                    "code": "year_df.sort_values(\"Rank\", inplace=True)"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "Creates and saves a grouped bar plot of actual and predicted ranks for each player",
                            "codeSegments": [
                                {
                                    "line": 69,
                                    "code": "sns.barplot(x=\"Name\", y=\"Value\", hue=\"Type\", data=plot_df, palette=\"coolwarm\")"
                                },
                                {
                                    "line": 74,
                                    "code": "plt.savefig(f\"data/ranking_predictions_{year}.png\")"
                                }
                            ]
                        }
                    ],
                    "high_unstructured": [
                        {
                            "summaryComponent": "The plot_ranking_predictions function",
                            "codeSegments": [
                                {
                                    "line": 52,
                                    "code": "def plot_ranking_predictions(df, year):"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "visualizes the actual and predicted player rankings for a given year",
                            "codeSegments": [
                                {
                                    "line": 72,
                                    "code": "plt.title(f\"MVP Ranking Predictions ({year})\")"
                                },
                                {
                                    "line": 69,
                                    "code": "sns.barplot(x=\"Name\", y=\"Value\", hue=\"Type\", data=plot_df, palette=\"coolwarm\")"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "It reshapes the data to include both 'Rank' and 'PredictedRank' for each player",
                            "codeSegments": [
                                {
                                    "line": 64,
                                    "code": "plot_df = year_df[[\"Name\", \"Rank\", \"PredictedRank\"]].melt("
                                },
                                {
                                    "line": 65,
                                    "code": "id_vars=\"Name\", value_vars=[\"Rank\", \"PredictedRank\"], var_name=\"Type\", value_name=\"Value\""
                                }
                            ]
                        },
                        {
                            "summaryComponent": "then filters and sorts the data for the specified year",
                            "codeSegments": [
                                {
                                    "line": 60,
                                    "code": "year_df = df[df[\"Year\"] == year].copy()"
                                },
                                {
                                    "line": 61,
                                    "code": "year_df.sort_values(\"Rank\", inplace=True)"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "A grouped bar plot is generated using Seaborn",
                            "codeSegments": [
                                {
                                    "line": 69,
                                    "code": "sns.barplot(x=\"Name\", y=\"Value\", hue=\"Type\", data=plot_df, palette=\"coolwarm\")"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "with each player's actual and predicted ranks displayed side by side for direct comparison",
                            "codeSegments": [
                                {
                                    "line": 69,
                                    "code": "sns.barplot(x=\"Name\", y=\"Value\", hue=\"Type\", data=plot_df, palette=\"coolwarm\")"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "The plot is formatted for readability",
                            "codeSegments": [
                                {
                                    "line": 70,
                                    "code": "plt.xticks(rotation=45, ha=\"right\")"
                                },
                                {
                                    "line": 71,
                                    "code": "plt.ylabel(\"Rank\")"
                                },
                                {
                                    "line": 72,
                                    "code": "plt.title(f\"MVP Ranking Predictions ({year})\")"
                                },
                                {
                                    "line": 73,
                                    "code": "plt.tight_layout()"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "and saved as a PNG file named according to the year",
                            "codeSegments": [
                                {
                                    "line": 74,
                                    "code": "plt.savefig(f\"data/ranking_predictions_{year}.png\")"
                                }
                            ]
                        }
                    ],
                    "high_structured": [
                        {
                            "summaryComponent": "Reshapes the DataFrame to include both 'Rank' and 'PredictedRank' for each player",
                            "codeSegments": [
                                {
                                    "line": 64,
                                    "code": "plot_df = year_df[[\"Name\", \"Rank\", \"PredictedRank\"]].melt("
                                },
                                {
                                    "line": 65,
                                    "code": "id_vars=\"Name\", value_vars=[\"Rank\", \"PredictedRank\"], var_name=\"Type\", value_name=\"Value\""
                                }
                            ]
                        },
                        {
                            "summaryComponent": "Filters the DataFrame to include only entries from the specified year",
                            "codeSegments": [
                                {
                                    "line": 60,
                                    "code": "year_df = df[df[\"Year\"] == year].copy()"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "Makes a copy and sorts it by actual Rank for consistent plotting",
                            "codeSegments": [
                                {
                                    "line": 60,
                                    "code": "year_df = df[df[\"Year\"] == year].copy()"
                                },
                                {
                                    "line": 61,
                                    "code": "year_df.sort_values(\"Rank\", inplace=True)"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "Sets up a matplotlib figure with a specific size",
                            "codeSegments": [
                                {
                                    "line": 68,
                                    "code": "plt.figure(figsize=(12, 6))"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "Uses Seaborn to create a grouped bar plot of actual and predicted ranks for each player, colored by type",
                            "codeSegments": [
                                {
                                    "line": 69,
                                    "code": "sns.barplot(x=\"Name\", y=\"Value\", hue=\"Type\", data=plot_df, palette=\"coolwarm\")"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "Rotates x-axis labels for readability and sets axis labels and plot title",
                            "codeSegments": [
                                {
                                    "line": 70,
                                    "code": "plt.xticks(rotation=45, ha=\"right\")"
                                },
                                {
                                    "line": 71,
                                    "code": "plt.ylabel(\"Rank\")"
                                },
                                {
                                    "line": 72,
                                    "code": "plt.title(f\"MVP Ranking Predictions ({year})\")"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "Adjusts layout and saves the plot as a PNG file named with the year",
                            "codeSegments": [
                                {
                                    "line": 73,
                                    "code": "plt.tight_layout()"
                                },
                                {
                                    "line": 74,
                                    "code": "plt.savefig(f\"data/ranking_predictions_{year}.png\")"
                                }
                            ]
                        }
                    ]
                },
                "summaryData": {
                    "medium_unstructured": "The plot_ranking_predictions function visualizes both the predicted and actual ranks for a specified year. It generates a grouped bar plot showing these values for each player and saves the figure as a PNG file. The plot helps assess the accuracy of ranking predictions by direct comparison.",
                    "low_structured": "• Plots actual and predicted ranks for a specified year as grouped bars\n• Saves the plot as a PNG file",
                    "title": "plot_ranking_predictions Function Summary",
                    "medium_structured": "• Displays both predicted and true ranks for each player as grouped bars\n• Filters the DataFrame for the specified year and sorts by actual rank\n• Creates and saves a grouped bar plot of actual and predicted ranks for each player",
                    "high_unstructured": "The plot_ranking_predictions function visualizes the actual and predicted player rankings for a given year. It reshapes the data to include both 'Rank' and 'PredictedRank' for each player, then filters and sorts the data for the specified year. A grouped bar plot is generated using Seaborn, with each player's actual and predicted ranks displayed side by side for direct comparison. The plot is formatted for readability and saved as a PNG file named according to the year.",
                    "high_structured": "• Reshapes the DataFrame to include both 'Rank' and 'PredictedRank' for each player\n• Filters the DataFrame to include only entries from the specified year\n  ◦ Makes a copy and sorts it by actual Rank for consistent plotting\n• Sets up a matplotlib figure with a specific size\n• Uses Seaborn to create a grouped bar plot of actual and predicted ranks for each player, colored by type\n• Rotates x-axis labels for readability and sets axis labels and plot title\n• Adjusts layout and saves the plot as a PNG file named with the year",
                    "low_unstructured": "This function creates and saves a grouped bar plot comparing actual and predicted ranks for a given year."
                },
                "editPromptStructured": null,
                "createdAt": 1755975170000,
                "metadata": {
                    "filename": "rank_model.py",
                    "id": "99fc83b5-aef9-4d3c-ada9-c5e0760078ff",
                    "originalCode": "def plot_ranking_predictions(df, year):\n    \"\"\"\n    Plot prediction error for a specific year.\n\n    Args:\n        df: DataFrame containing prediction results\n        year: Year to plot prediction errors for\n    \"\"\"\n    year_df = df[df[\"Year\"] == year].copy()\n    year_df.sort_values(\"Rank\", inplace=True)\n\n    # Prepare data for grouped bar chart\n    plot_df = year_df[[\"Name\", \"Rank\", \"PredictedRank\"]].melt(\n        id_vars=\"Name\", value_vars=[\"Rank\", \"PredictedRank\"], var_name=\"Type\", value_name=\"Value\"\n    )\n\n    plt.figure(figsize=(12, 6))\n    sns.barplot(x=\"Name\", y=\"Value\", hue=\"Type\", data=plot_df, palette=\"coolwarm\")\n    plt.xticks(rotation=45, ha=\"right\")\n    plt.ylabel(\"Rank\")\n    plt.title(f\"MVP Ranking Predictions ({year})\")\n    plt.tight_layout()\n    plt.savefig(f\"data/ranking_predictions_{year}.png\")",
                    "fullPath": "/project/workspace/rank_model.py",
                    "offset": 1205
                },
                "selectedStructured": "unstructured",
                "title": "plot_ranking_predictions Function Summary",
                "selectedDetailLevel": "medium",
                "oldSummaryData": {
                    "medium_unstructured": "The plot_ranking_predictions function visualizes the difference between predicted and actual ranks for a specified year. It generates a bar plot showing these errors for each player and saves the figure as a PNG file. The plot helps assess the accuracy of ranking predictions.",
                    "low_structured": "• Plots prediction errors for a specified year\n• Saves the plot as a PNG file",
                    "title": "plot_ranking_predictions Function Summary",
                    "medium_structured": "• Calculates prediction errors as the difference between predicted and true ranks\n• Filters the DataFrame for the specified year and sorts by actual rank\n• Creates and saves a bar plot of rank errors for each player",
                    "high_unstructured": "The plot_ranking_predictions function visualizes the prediction errors of player rankings for a given year. It computes the 'RankError' as the difference between each player's predicted and actual rank, then filters and sorts the data for the specified year. A bar plot is generated using Seaborn, with each player's error displayed and a horizontal reference line at zero to indicate perfect predictions. The plot is formatted for readability and saved as a PNG file named according to the year.",
                    "high_structured": "• Computes 'RankError' as PredictedRank minus actual Rank for each player\n• Filters the DataFrame to include only entries from the specified year\n  ◦ Makes a copy and sorts it by actual Rank for consistent plotting\n• Sets up a matplotlib figure with a specific size\n• Uses Seaborn to create a bar plot of RankError for each player, colored by player name\n• Adds a horizontal dashed line at zero to indicate no prediction error\n• Rotates x-axis labels for readability and sets axis labels and plot title\n• Adjusts layout and saves the plot as a PNG file named with the year",
                    "low_unstructured": "This function creates and saves a bar plot of prediction errors for a given year."
                },
                "editPromptValue": "",
                "editPromptDetailLevel": null
            },
            "section_id": "99fc83b5-aef9-4d3c-ada9-c5e0760078ff"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:52:50.000",
        "event": "create_new_section",
        "id": "i7FPQV6gnfhLEISEfkQv"
    },
    {
        "data": {
            "mapping": [
                {
                    "summaryComponent": "The plot_ranking_predictions function",
                    "codeSegments": [
                        {
                            "line": 52,
                            "code": "def plot_ranking_predictions(df, year):"
                        }
                    ]
                },
                {
                    "summaryComponent": "visualizes both the predicted and actual ranks",
                    "codeSegments": [
                        {
                            "line": 64,
                            "code": "plot_df = year_df[[\"Name\", \"Rank\", \"PredictedRank\"]].melt("
                        },
                        {
                            "line": 65,
                            "code": "value_vars=[\"Rank\", \"PredictedRank\"]"
                        }
                    ]
                },
                {
                    "summaryComponent": "for a specified year",
                    "codeSegments": [
                        {
                            "line": 60,
                            "code": "year_df = df[df[\"Year\"] == year].copy()"
                        }
                    ]
                },
                {
                    "summaryComponent": "It generates a grouped bar plot",
                    "codeSegments": [
                        {
                            "line": 69,
                            "code": "sns.barplot(x=\"Name\", y=\"Value\", hue=\"Type\", data=plot_df, palette=\"coolwarm\")"
                        }
                    ]
                },
                {
                    "summaryComponent": "showing these values for each player",
                    "codeSegments": [
                        {
                            "line": 69,
                            "code": "x=\"Name\""
                        }
                    ]
                },
                {
                    "summaryComponent": "and saves the figure as a PNG file",
                    "codeSegments": [
                        {
                            "line": 74,
                            "code": "plt.savefig(f\"data/ranking_predictions_{year}.png\")"
                        }
                    ]
                },
                {
                    "summaryComponent": "The plot helps assess the accuracy of ranking predictions by direct comparison.",
                    "codeSegments": [
                        {
                            "line": 69,
                            "code": "sns.barplot(x=\"Name\", y=\"Value\", hue=\"Type\", data=plot_df, palette=\"coolwarm\")"
                        }
                    ]
                }
            ],
            "summary": "The plot_ranking_predictions function visualizes both the predicted and actual ranks for a specified year. It generates a grouped bar plot showing these values for each player and saves the figure as a PNG file. The plot helps assess the accuracy of ranking predictions by direct comparison.",
            "code": "52: def plot_ranking_predictions(df, year):\n53:     \"\"\"\n54:     Plot prediction error for a specific year.\n55: \n56:     Args:\n57:         df: DataFrame containing prediction results\n58:         year: Year to plot prediction errors for\n59:     \"\"\"\n60:     year_df = df[df[\"Year\"] == year].copy()\n61:     year_df.sort_values(\"Rank\", inplace=True)\n62: \n63:     # Prepare data for grouped bar chart\n64:     plot_df = year_df[[\"Name\", \"Rank\", \"PredictedRank\"]].melt(\n65:         id_vars=\"Name\", value_vars=[\"Rank\", \"PredictedRank\"], var_name=\"Type\", value_name=\"Value\"\n66:     )\n67: \n68:     plt.figure(figsize=(12, 6))\n69:     sns.barplot(x=\"Name\", y=\"Value\", hue=\"Type\", data=plot_df, palette=\"coolwarm\")\n70:     plt.xticks(rotation=45, ha=\"right\")\n71:     plt.ylabel(\"Rank\")\n72:     plt.title(f\"MVP Ranking Predictions ({year})\")\n73:     plt.tight_layout()\n74:     plt.savefig(f\"data/ranking_predictions_{year}.png\")"
        },
        "source": "backend",
        "timestamp": "2025-08-23 10:52:50.000",
        "event": "map_summary_code",
        "id": "w5UO0CCsQeNsnFSX3oLY"
    },
    {
        "data": {
            "structured_type": "unstructured",
            "section_id": "99fc83b5-aef9-4d3c-ada9-c5e0760078ff",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:53:11.000",
        "event": "mapping_unhover",
        "id": "58LsGH8Xkp0EmStXQ0cP"
    },
    {
        "data": {
            "mapping_index": 6,
            "structured_type": "unstructured",
            "section_id": "99fc83b5-aef9-4d3c-ada9-c5e0760078ff",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:53:11.000",
        "event": "mapping_hover",
        "id": "kY0jV4GSfOVnIiv80F9c"
    },
    {
        "data": {
            "mapping_index": 0,
            "structured_type": "unstructured",
            "section_id": "99fc83b5-aef9-4d3c-ada9-c5e0760078ff",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:53:23.000",
        "event": "mapping_hover",
        "id": "0gcjUEaT5CzVaZnMe3xm"
    },
    {
        "data": {
            "mapping_index": 0,
            "structured_type": "unstructured",
            "section_id": "99fc83b5-aef9-4d3c-ada9-c5e0760078ff",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:53:23.000",
        "event": "mapping_hover",
        "id": "lEI14IkiundHgyAZ6Yrv"
    },
    {
        "data": {
            "structured_type": "unstructured",
            "section_id": "99fc83b5-aef9-4d3c-ada9-c5e0760078ff",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:53:23.000",
        "event": "mapping_unhover",
        "id": "qkOk3N8D7cQvEFEWqVVb"
    },
    {
        "data": {
            "mapping_index": 1,
            "structured_type": "unstructured",
            "section_id": "99fc83b5-aef9-4d3c-ada9-c5e0760078ff",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:53:27.000",
        "event": "mapping_hover",
        "id": "7tkFArXa0hVtN7YsRxcM"
    },
    {
        "data": {
            "mapping_index": 2,
            "structured_type": "unstructured",
            "section_id": "99fc83b5-aef9-4d3c-ada9-c5e0760078ff",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:53:27.000",
        "event": "mapping_hover",
        "id": "Fblt8UcoEgQjlrV59ZWr"
    },
    {
        "data": {
            "structured_type": "unstructured",
            "section_id": "99fc83b5-aef9-4d3c-ada9-c5e0760078ff",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:53:27.000",
        "event": "mapping_unhover",
        "id": "PTiwk8J9qtQA1FyrIefg"
    },
    {
        "data": {
            "structured_type": "unstructured",
            "section_id": "99fc83b5-aef9-4d3c-ada9-c5e0760078ff",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:53:27.000",
        "event": "mapping_unhover",
        "id": "jsfDiMsmwfUvH3jOzA3K"
    },
    {
        "data": {
            "mapping_index": 3,
            "structured_type": "unstructured",
            "section_id": "99fc83b5-aef9-4d3c-ada9-c5e0760078ff",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:53:27.000",
        "event": "mapping_hover",
        "id": "n5GJCzR0YmroiMl06H3A"
    },
    {
        "data": {
            "structured_type": "unstructured",
            "section_id": "99fc83b5-aef9-4d3c-ada9-c5e0760078ff",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:53:27.000",
        "event": "mapping_unhover",
        "id": "nEbnbXLCOMokpbB2dqUx"
    },
    {
        "data": {
            "mapping_index": 2,
            "structured_type": "unstructured",
            "section_id": "99fc83b5-aef9-4d3c-ada9-c5e0760078ff",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:53:27.000",
        "event": "mapping_hover",
        "id": "tIe0H1MJNzWBmJbhXoJ8"
    },
    {
        "data": {
            "structured_type": "unstructured",
            "section_id": "99fc83b5-aef9-4d3c-ada9-c5e0760078ff",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:53:27.000",
        "event": "mapping_unhover",
        "id": "xDQRF15MmQeCFfvbZg2U"
    },
    {
        "data": {
            "structured_type": "unstructured",
            "section_id": "99fc83b5-aef9-4d3c-ada9-c5e0760078ff",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:53:28.000",
        "event": "mapping_unhover",
        "id": "7mnuna2TNbROLbYJjy2m"
    },
    {
        "data": {
            "mapping_index": 1,
            "structured_type": "unstructured",
            "section_id": "99fc83b5-aef9-4d3c-ada9-c5e0760078ff",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:53:28.000",
        "event": "mapping_hover",
        "id": "9ocJC10uDOfe3wyRRMuN"
    },
    {
        "data": {
            "mapping_index": 4,
            "structured_type": "unstructured",
            "section_id": "99fc83b5-aef9-4d3c-ada9-c5e0760078ff",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:53:28.000",
        "event": "mapping_hover",
        "id": "Nh5TavHddstxsYND5Rps"
    },
    {
        "data": {
            "structured_type": "unstructured",
            "section_id": "99fc83b5-aef9-4d3c-ada9-c5e0760078ff",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:53:28.000",
        "event": "mapping_unhover",
        "id": "Q5nvQ0AZDP6I0IvTIM6S"
    },
    {
        "data": {
            "mapping_index": 2,
            "structured_type": "unstructured",
            "section_id": "99fc83b5-aef9-4d3c-ada9-c5e0760078ff",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:53:28.000",
        "event": "mapping_hover",
        "id": "e03JH4xWkROnFI9Zj9A7"
    },
    {
        "data": {
            "structured_type": "unstructured",
            "section_id": "99fc83b5-aef9-4d3c-ada9-c5e0760078ff",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:53:28.000",
        "event": "mapping_unhover",
        "id": "rPrSDwerNx3Wu3a2pJu4"
    },
    {
        "data": {
            "structured_type": "unstructured",
            "section_id": "99fc83b5-aef9-4d3c-ada9-c5e0760078ff",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:53:28.000",
        "event": "mapping_unhover",
        "id": "yM8bBEhW9QfpbKWaJIZM"
    },
    {
        "data": {},
        "source": "frontend",
        "timestamp": "2025-08-23 10:53:52.000",
        "event": "click_summarize_code",
        "id": "ekQKe9PIbOC3AESzSD54"
    },
    {
        "data": {
            "selected_code": "        model = XGBRanker(\n            objective=\"rank:pairwise\",\n            learning_rate=0.1,\n            n_estimators=n_estimators,\n            max_depth=4,\n            random_state=42,\n        )",
            "summary": {
                "medium_unstructured": "The code initializes an XGBRanker model from the XGBoost library with several defined hyperparameters. It sets the objective to 'rank:pairwise', uses a learning rate of 0.1, and specifies the number of estimators and maximum tree depth. A random state is also provided for reproducibility.",
                "low_structured": "• Instantiates an XGBRanker model\n• Sets key parameters like objective, learning rate, and number of estimators",
                "title": "Instantiation of XGBRanker with Specific Parameters",
                "medium_structured": "• Creates an XGBRanker instance for ranking tasks\n• Sets the objective to 'rank:pairwise' for pairwise ranking\n• Configures hyperparameters:\n  ◦ learning_rate=0.1\n  ◦ n_estimators=n_estimators (variable)\n  ◦ max_depth=4\n  ◦ random_state=42 for reproducibility",
                "high_unstructured": "This snippet instantiates an XGBRanker object from the XGBoost library, tailored for ranking tasks using pairwise ranking as the objective. The model is configured with a learning rate of 0.1, a variable number of estimators (n_estimators), a maximum tree depth of 4, and a fixed random seed of 42 to ensure reproducibility. These hyperparameters are chosen to control the model's complexity, learning speed, and output consistency. The resulting model is ready to be trained on ranking data.",
                "high_structured": "• Instantiates an XGBRanker model from the XGBoost library\n• Sets the objective to 'rank:pairwise', enabling pairwise ranking optimization\n• Configures model hyperparameters:\n  ◦ learning_rate is set to 0.1, controlling the step size during boosting\n  ◦ n_estimators is set via a variable, determining the number of boosting rounds\n  ◦ max_depth is fixed at 4, limiting the depth of each tree to prevent overfitting\n  ◦ random_state is set to 42, ensuring reproducible results\n• The model is prepared for subsequent training on ranking datasets",
                "low_unstructured": "This code creates an XGBRanker model with specified hyperparameters."
            }
        },
        "source": "backend",
        "timestamp": "2025-08-23 10:53:57.000",
        "event": "summarize_selected_code",
        "id": "p8Js7OB1SP9uUpKre82Z"
    },
    {
        "data": {
            "mapping": [
                {
                    "summaryComponent": "creates an XGBRanker model",
                    "codeSegments": [
                        {
                            "line": 103,
                            "code": "model = XGBRanker("
                        }
                    ]
                },
                {
                    "summaryComponent": "with specified hyperparameters",
                    "codeSegments": [
                        {
                            "line": 104,
                            "code": "objective=\"rank:pairwise\","
                        },
                        {
                            "line": 105,
                            "code": "learning_rate=0.1,"
                        },
                        {
                            "line": 106,
                            "code": "n_estimators=n_estimators,"
                        },
                        {
                            "line": 107,
                            "code": "max_depth=4,"
                        },
                        {
                            "line": 108,
                            "code": "random_state=42,"
                        }
                    ]
                }
            ],
            "summary": "This code creates an XGBRanker model with specified hyperparameters.",
            "code": "103:         model = XGBRanker(\n104:             objective=\"rank:pairwise\",\n105:             learning_rate=0.1,\n106:             n_estimators=n_estimators,\n107:             max_depth=4,\n108:             random_state=42,\n109:         )"
        },
        "source": "backend",
        "timestamp": "2025-08-23 10:53:58.000",
        "event": "map_summary_code",
        "id": "7R8JqD8NkYlqdI4chY3b"
    },
    {
        "data": {
            "mapping": [
                {
                    "summaryComponent": "Instantiates an XGBRanker model",
                    "codeSegments": [
                        {
                            "line": 103,
                            "code": "model = XGBRanker("
                        },
                        {
                            "line": 109,
                            "code": ")"
                        }
                    ]
                },
                {
                    "summaryComponent": "Sets key parameters like objective, learning rate, and number of estimators",
                    "codeSegments": [
                        {
                            "line": 104,
                            "code": "objective=\"rank:pairwise\","
                        },
                        {
                            "line": 105,
                            "code": "learning_rate=0.1,"
                        },
                        {
                            "line": 106,
                            "code": "n_estimators=n_estimators,"
                        }
                    ]
                }
            ],
            "summary": "• Instantiates an XGBRanker model\n• Sets key parameters like objective, learning rate, and number of estimators",
            "code": "103:         model = XGBRanker(\n104:             objective=\"rank:pairwise\",\n105:             learning_rate=0.1,\n106:             n_estimators=n_estimators,\n107:             max_depth=4,\n108:             random_state=42,\n109:         )"
        },
        "source": "backend",
        "timestamp": "2025-08-23 10:53:58.000",
        "event": "map_summary_code",
        "id": "DD9d5w3459ON65GSNgt2"
    },
    {
        "data": {
            "mapping": [
                {
                    "summaryComponent": "initializes an XGBRanker model from the XGBoost library",
                    "codeSegments": [
                        {
                            "line": 103,
                            "code": "model = XGBRanker("
                        }
                    ]
                },
                {
                    "summaryComponent": "with several defined hyperparameters",
                    "codeSegments": [
                        {
                            "line": 104,
                            "code": "objective=\"rank:pairwise\","
                        },
                        {
                            "line": 105,
                            "code": "learning_rate=0.1,"
                        },
                        {
                            "line": 106,
                            "code": "n_estimators=n_estimators,"
                        },
                        {
                            "line": 107,
                            "code": "max_depth=4,"
                        },
                        {
                            "line": 108,
                            "code": "random_state=42,"
                        }
                    ]
                },
                {
                    "summaryComponent": "sets the objective to 'rank:pairwise'",
                    "codeSegments": [
                        {
                            "line": 104,
                            "code": "objective=\"rank:pairwise\","
                        }
                    ]
                },
                {
                    "summaryComponent": "uses a learning rate of 0.1",
                    "codeSegments": [
                        {
                            "line": 105,
                            "code": "learning_rate=0.1,"
                        }
                    ]
                },
                {
                    "summaryComponent": "specifies the number of estimators",
                    "codeSegments": [
                        {
                            "line": 106,
                            "code": "n_estimators=n_estimators,"
                        }
                    ]
                },
                {
                    "summaryComponent": "maximum tree depth",
                    "codeSegments": [
                        {
                            "line": 107,
                            "code": "max_depth=4,"
                        }
                    ]
                },
                {
                    "summaryComponent": "random state is also provided for reproducibility",
                    "codeSegments": [
                        {
                            "line": 108,
                            "code": "random_state=42,"
                        }
                    ]
                }
            ],
            "summary": "The code initializes an XGBRanker model from the XGBoost library with several defined hyperparameters. It sets the objective to 'rank:pairwise', uses a learning rate of 0.1, and specifies the number of estimators and maximum tree depth. A random state is also provided for reproducibility.",
            "code": "103:         model = XGBRanker(\n104:             objective=\"rank:pairwise\",\n105:             learning_rate=0.1,\n106:             n_estimators=n_estimators,\n107:             max_depth=4,\n108:             random_state=42,\n109:         )"
        },
        "source": "backend",
        "timestamp": "2025-08-23 10:53:59.000",
        "event": "map_summary_code",
        "id": "i8xRBVVJs8La10y6Pahx"
    },
    {
        "data": {
            "mapping": [
                {
                    "summaryComponent": "Creates an XGBRanker instance for ranking tasks",
                    "codeSegments": [
                        {
                            "line": 103,
                            "code": "model = XGBRanker("
                        }
                    ]
                },
                {
                    "summaryComponent": "Sets the objective to 'rank:pairwise' for pairwise ranking",
                    "codeSegments": [
                        {
                            "line": 104,
                            "code": "objective=\"rank:pairwise\","
                        }
                    ]
                },
                {
                    "summaryComponent": "Configures hyperparameters:",
                    "codeSegments": [
                        {
                            "line": 105,
                            "code": "learning_rate=0.1,"
                        },
                        {
                            "line": 106,
                            "code": "n_estimators=n_estimators,"
                        },
                        {
                            "line": 107,
                            "code": "max_depth=4,"
                        },
                        {
                            "line": 108,
                            "code": "random_state=42,"
                        }
                    ]
                },
                {
                    "summaryComponent": "learning_rate=0.1",
                    "codeSegments": [
                        {
                            "line": 105,
                            "code": "learning_rate=0.1,"
                        }
                    ]
                },
                {
                    "summaryComponent": "n_estimators=n_estimators (variable)",
                    "codeSegments": [
                        {
                            "line": 106,
                            "code": "n_estimators=n_estimators,"
                        }
                    ]
                },
                {
                    "summaryComponent": "max_depth=4",
                    "codeSegments": [
                        {
                            "line": 107,
                            "code": "max_depth=4,"
                        }
                    ]
                },
                {
                    "summaryComponent": "random_state=42 for reproducibility",
                    "codeSegments": [
                        {
                            "line": 108,
                            "code": "random_state=42,"
                        }
                    ]
                }
            ],
            "summary": "• Creates an XGBRanker instance for ranking tasks\n• Sets the objective to 'rank:pairwise' for pairwise ranking\n• Configures hyperparameters:\n  ◦ learning_rate=0.1\n  ◦ n_estimators=n_estimators (variable)\n  ◦ max_depth=4\n  ◦ random_state=42 for reproducibility",
            "code": "103:         model = XGBRanker(\n104:             objective=\"rank:pairwise\",\n105:             learning_rate=0.1,\n106:             n_estimators=n_estimators,\n107:             max_depth=4,\n108:             random_state=42,\n109:         )"
        },
        "source": "backend",
        "timestamp": "2025-08-23 10:53:59.000",
        "event": "map_summary_code",
        "id": "y2U5MXxxxmZhuQraktfW"
    },
    {
        "data": {
            "mapping": [
                {
                    "summaryComponent": "Instantiates an XGBRanker model from the XGBoost library",
                    "codeSegments": [
                        {
                            "line": 103,
                            "code": "model = XGBRanker("
                        }
                    ]
                },
                {
                    "summaryComponent": "Sets the objective to 'rank:pairwise', enabling pairwise ranking optimization",
                    "codeSegments": [
                        {
                            "line": 104,
                            "code": "objective=\"rank:pairwise\","
                        }
                    ]
                },
                {
                    "summaryComponent": "Configures model hyperparameters:",
                    "codeSegments": [
                        {
                            "line": 105,
                            "code": "learning_rate=0.1,"
                        },
                        {
                            "line": 106,
                            "code": "n_estimators=n_estimators,"
                        },
                        {
                            "line": 107,
                            "code": "max_depth=4,"
                        },
                        {
                            "line": 108,
                            "code": "random_state=42,"
                        }
                    ]
                },
                {
                    "summaryComponent": "learning_rate is set to 0.1, controlling the step size during boosting",
                    "codeSegments": [
                        {
                            "line": 105,
                            "code": "learning_rate=0.1,"
                        }
                    ]
                },
                {
                    "summaryComponent": "n_estimators is set via a variable, determining the number of boosting rounds",
                    "codeSegments": [
                        {
                            "line": 106,
                            "code": "n_estimators=n_estimators,"
                        }
                    ]
                },
                {
                    "summaryComponent": "max_depth is fixed at 4, limiting the depth of each tree to prevent overfitting",
                    "codeSegments": [
                        {
                            "line": 107,
                            "code": "max_depth=4,"
                        }
                    ]
                },
                {
                    "summaryComponent": "random_state is set to 42, ensuring reproducible results",
                    "codeSegments": [
                        {
                            "line": 108,
                            "code": "random_state=42,"
                        }
                    ]
                },
                {
                    "summaryComponent": "The model is prepared for subsequent training on ranking datasets",
                    "codeSegments": [
                        {
                            "line": 103,
                            "code": "model = XGBRanker("
                        }
                    ]
                }
            ],
            "summary": "• Instantiates an XGBRanker model from the XGBoost library\n• Sets the objective to 'rank:pairwise', enabling pairwise ranking optimization\n• Configures model hyperparameters:\n  ◦ learning_rate is set to 0.1, controlling the step size during boosting\n  ◦ n_estimators is set via a variable, determining the number of boosting rounds\n  ◦ max_depth is fixed at 4, limiting the depth of each tree to prevent overfitting\n  ◦ random_state is set to 42, ensuring reproducible results\n• The model is prepared for subsequent training on ranking datasets",
            "code": "103:         model = XGBRanker(\n104:             objective=\"rank:pairwise\",\n105:             learning_rate=0.1,\n106:             n_estimators=n_estimators,\n107:             max_depth=4,\n108:             random_state=42,\n109:         )"
        },
        "source": "backend",
        "timestamp": "2025-08-23 10:54:00.000",
        "event": "map_summary_code",
        "id": "Bwuo8jKldwlqp9NZOMmP"
    },
    {
        "data": {
            "mapping_index": 0,
            "structured_type": "unstructured",
            "section_id": "93335828-8d7f-4a31-8029-c903c7a9319b",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:54:00.000",
        "event": "mapping_hover",
        "id": "U8lig228c9ToVs45lOwE"
    },
    {
        "data": {
            "mapping": [
                {
                    "summaryComponent": "instantiates an XGBRanker object from the XGBoost library",
                    "codeSegments": [
                        {
                            "line": 103,
                            "code": "model = XGBRanker("
                        }
                    ]
                },
                {
                    "summaryComponent": "tailored for ranking tasks using pairwise ranking as the objective",
                    "codeSegments": [
                        {
                            "line": 104,
                            "code": "objective=\"rank:pairwise\","
                        }
                    ]
                },
                {
                    "summaryComponent": "configured with a learning rate of 0.1",
                    "codeSegments": [
                        {
                            "line": 105,
                            "code": "learning_rate=0.1,"
                        }
                    ]
                },
                {
                    "summaryComponent": "a variable number of estimators (n_estimators)",
                    "codeSegments": [
                        {
                            "line": 106,
                            "code": "n_estimators=n_estimators,"
                        }
                    ]
                },
                {
                    "summaryComponent": "a maximum tree depth of 4",
                    "codeSegments": [
                        {
                            "line": 107,
                            "code": "max_depth=4,"
                        }
                    ]
                },
                {
                    "summaryComponent": "a fixed random seed of 42 to ensure reproducibility",
                    "codeSegments": [
                        {
                            "line": 108,
                            "code": "random_state=42,"
                        }
                    ]
                },
                {
                    "summaryComponent": "These hyperparameters are chosen to control the model's complexity, learning speed, and output consistency",
                    "codeSegments": [
                        {
                            "line": 105,
                            "code": "learning_rate=0.1,"
                        },
                        {
                            "line": 106,
                            "code": "n_estimators=n_estimators,"
                        },
                        {
                            "line": 107,
                            "code": "max_depth=4,"
                        },
                        {
                            "line": 108,
                            "code": "random_state=42,"
                        }
                    ]
                },
                {
                    "summaryComponent": "The resulting model is ready to be trained on ranking data",
                    "codeSegments": [
                        {
                            "line": 103,
                            "code": "model = XGBRanker("
                        }
                    ]
                }
            ],
            "summary": "This snippet instantiates an XGBRanker object from the XGBoost library, tailored for ranking tasks using pairwise ranking as the objective. The model is configured with a learning rate of 0.1, a variable number of estimators (n_estimators), a maximum tree depth of 4, and a fixed random seed of 42 to ensure reproducibility. These hyperparameters are chosen to control the model's complexity, learning speed, and output consistency. The resulting model is ready to be trained on ranking data.",
            "code": "103:         model = XGBRanker(\n104:             objective=\"rank:pairwise\",\n105:             learning_rate=0.1,\n106:             n_estimators=n_estimators,\n107:             max_depth=4,\n108:             random_state=42,\n109:         )"
        },
        "source": "backend",
        "timestamp": "2025-08-23 10:54:00.000",
        "event": "map_summary_code",
        "id": "Wsea5IZQwsbkLwOxNHZq"
    },
    {
        "data": {
            "structured_type": "unstructured",
            "section_id": "93335828-8d7f-4a31-8029-c903c7a9319b",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:54:00.000",
        "event": "mapping_unhover",
        "id": "g5665lYptm8We2SwSe2I"
    },
    {
        "data": {
            "section_data": {
                "lines": [
                    103,
                    109
                ],
                "summaryData": {
                    "medium_unstructured": "The code initializes an XGBRanker model from the XGBoost library with several defined hyperparameters. It sets the objective to 'rank:pairwise', uses a learning rate of 0.1, and specifies the number of estimators and maximum tree depth. A random state is also provided for reproducibility.",
                    "low_structured": "• Instantiates an XGBRanker model\n• Sets key parameters like objective, learning rate, and number of estimators",
                    "title": "Instantiation of XGBRanker with Specific Parameters",
                    "medium_structured": "• Creates an XGBRanker instance for ranking tasks\n• Sets the objective to 'rank:pairwise' for pairwise ranking\n• Configures hyperparameters:\n  ◦ learning_rate=0.1\n  ◦ n_estimators=n_estimators (variable)\n  ◦ max_depth=4\n  ◦ random_state=42 for reproducibility",
                    "high_unstructured": "This snippet instantiates an XGBRanker object from the XGBoost library, tailored for ranking tasks using pairwise ranking as the objective. The model is configured with a learning rate of 0.1, a variable number of estimators (n_estimators), a maximum tree depth of 4, and a fixed random seed of 42 to ensure reproducibility. These hyperparameters are chosen to control the model's complexity, learning speed, and output consistency. The resulting model is ready to be trained on ranking data.",
                    "high_structured": "• Instantiates an XGBRanker model from the XGBoost library\n• Sets the objective to 'rank:pairwise', enabling pairwise ranking optimization\n• Configures model hyperparameters:\n  ◦ learning_rate is set to 0.1, controlling the step size during boosting\n  ◦ n_estimators is set via a variable, determining the number of boosting rounds\n  ◦ max_depth is fixed at 4, limiting the depth of each tree to prevent overfitting\n  ◦ random_state is set to 42, ensuring reproducible results\n• The model is prepared for subsequent training on ranking datasets",
                    "low_unstructured": "This code creates an XGBRanker model with specified hyperparameters."
                },
                "editPromptStructured": null,
                "createdAt": 1755975240000,
                "metadata": {
                    "filename": "rank_model.py",
                    "id": "93335828-8d7f-4a31-8029-c903c7a9319b",
                    "originalCode": "        model = XGBRanker(\n            objective=\"rank:pairwise\",\n            learning_rate=0.1,\n            n_estimators=n_estimators,\n            max_depth=4,\n            random_state=42,\n        )",
                    "fullPath": "/project/workspace/rank_model.py",
                    "offset": 2770
                },
                "selectedStructured": "unstructured",
                "title": "Instantiation of XGBRanker with Specific Parameters",
                "selectedDetailLevel": "medium",
                "summaryMappings": {
                    "medium_unstructured": [
                        {
                            "summaryComponent": "initializes an XGBRanker model from the XGBoost library",
                            "codeSegments": [
                                {
                                    "line": 103,
                                    "code": "model = XGBRanker("
                                }
                            ]
                        },
                        {
                            "summaryComponent": "with several defined hyperparameters",
                            "codeSegments": [
                                {
                                    "line": 104,
                                    "code": "objective=\"rank:pairwise\","
                                },
                                {
                                    "line": 105,
                                    "code": "learning_rate=0.1,"
                                },
                                {
                                    "line": 106,
                                    "code": "n_estimators=n_estimators,"
                                },
                                {
                                    "line": 107,
                                    "code": "max_depth=4,"
                                },
                                {
                                    "line": 108,
                                    "code": "random_state=42,"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "sets the objective to 'rank:pairwise'",
                            "codeSegments": [
                                {
                                    "line": 104,
                                    "code": "objective=\"rank:pairwise\","
                                }
                            ]
                        },
                        {
                            "summaryComponent": "uses a learning rate of 0.1",
                            "codeSegments": [
                                {
                                    "line": 105,
                                    "code": "learning_rate=0.1,"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "specifies the number of estimators",
                            "codeSegments": [
                                {
                                    "line": 106,
                                    "code": "n_estimators=n_estimators,"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "maximum tree depth",
                            "codeSegments": [
                                {
                                    "line": 107,
                                    "code": "max_depth=4,"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "random state is also provided for reproducibility",
                            "codeSegments": [
                                {
                                    "line": 108,
                                    "code": "random_state=42,"
                                }
                            ]
                        }
                    ],
                    "low_structured": [
                        {
                            "summaryComponent": "Instantiates an XGBRanker model",
                            "codeSegments": [
                                {
                                    "line": 103,
                                    "code": "model = XGBRanker("
                                },
                                {
                                    "line": 109,
                                    "code": ")"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "Sets key parameters like objective, learning rate, and number of estimators",
                            "codeSegments": [
                                {
                                    "line": 104,
                                    "code": "objective=\"rank:pairwise\","
                                },
                                {
                                    "line": 105,
                                    "code": "learning_rate=0.1,"
                                },
                                {
                                    "line": 106,
                                    "code": "n_estimators=n_estimators,"
                                }
                            ]
                        }
                    ],
                    "low_unstructured": [
                        {
                            "summaryComponent": "creates an XGBRanker model",
                            "codeSegments": [
                                {
                                    "line": 103,
                                    "code": "model = XGBRanker("
                                }
                            ]
                        },
                        {
                            "summaryComponent": "with specified hyperparameters",
                            "codeSegments": [
                                {
                                    "line": 104,
                                    "code": "objective=\"rank:pairwise\","
                                },
                                {
                                    "line": 105,
                                    "code": "learning_rate=0.1,"
                                },
                                {
                                    "line": 106,
                                    "code": "n_estimators=n_estimators,"
                                },
                                {
                                    "line": 107,
                                    "code": "max_depth=4,"
                                },
                                {
                                    "line": 108,
                                    "code": "random_state=42,"
                                }
                            ]
                        }
                    ],
                    "medium_structured": [
                        {
                            "summaryComponent": "Creates an XGBRanker instance for ranking tasks",
                            "codeSegments": [
                                {
                                    "line": 103,
                                    "code": "model = XGBRanker("
                                }
                            ]
                        },
                        {
                            "summaryComponent": "Sets the objective to 'rank:pairwise' for pairwise ranking",
                            "codeSegments": [
                                {
                                    "line": 104,
                                    "code": "objective=\"rank:pairwise\","
                                }
                            ]
                        },
                        {
                            "summaryComponent": "Configures hyperparameters:",
                            "codeSegments": [
                                {
                                    "line": 105,
                                    "code": "learning_rate=0.1,"
                                },
                                {
                                    "line": 106,
                                    "code": "n_estimators=n_estimators,"
                                },
                                {
                                    "line": 107,
                                    "code": "max_depth=4,"
                                },
                                {
                                    "line": 108,
                                    "code": "random_state=42,"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "learning_rate=0.1",
                            "codeSegments": [
                                {
                                    "line": 105,
                                    "code": "learning_rate=0.1,"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "n_estimators=n_estimators (variable)",
                            "codeSegments": [
                                {
                                    "line": 106,
                                    "code": "n_estimators=n_estimators,"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "max_depth=4",
                            "codeSegments": [
                                {
                                    "line": 107,
                                    "code": "max_depth=4,"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "random_state=42 for reproducibility",
                            "codeSegments": [
                                {
                                    "line": 108,
                                    "code": "random_state=42,"
                                }
                            ]
                        }
                    ],
                    "high_unstructured": [
                        {
                            "summaryComponent": "instantiates an XGBRanker object from the XGBoost library",
                            "codeSegments": [
                                {
                                    "line": 103,
                                    "code": "model = XGBRanker("
                                }
                            ]
                        },
                        {
                            "summaryComponent": "tailored for ranking tasks using pairwise ranking as the objective",
                            "codeSegments": [
                                {
                                    "line": 104,
                                    "code": "objective=\"rank:pairwise\","
                                }
                            ]
                        },
                        {
                            "summaryComponent": "configured with a learning rate of 0.1",
                            "codeSegments": [
                                {
                                    "line": 105,
                                    "code": "learning_rate=0.1,"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "a variable number of estimators (n_estimators)",
                            "codeSegments": [
                                {
                                    "line": 106,
                                    "code": "n_estimators=n_estimators,"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "a maximum tree depth of 4",
                            "codeSegments": [
                                {
                                    "line": 107,
                                    "code": "max_depth=4,"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "a fixed random seed of 42 to ensure reproducibility",
                            "codeSegments": [
                                {
                                    "line": 108,
                                    "code": "random_state=42,"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "These hyperparameters are chosen to control the model's complexity, learning speed, and output consistency",
                            "codeSegments": [
                                {
                                    "line": 105,
                                    "code": "learning_rate=0.1,"
                                },
                                {
                                    "line": 106,
                                    "code": "n_estimators=n_estimators,"
                                },
                                {
                                    "line": 107,
                                    "code": "max_depth=4,"
                                },
                                {
                                    "line": 108,
                                    "code": "random_state=42,"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "The resulting model is ready to be trained on ranking data",
                            "codeSegments": [
                                {
                                    "line": 103,
                                    "code": "model = XGBRanker("
                                }
                            ]
                        }
                    ],
                    "high_structured": [
                        {
                            "summaryComponent": "Instantiates an XGBRanker model from the XGBoost library",
                            "codeSegments": [
                                {
                                    "line": 103,
                                    "code": "model = XGBRanker("
                                }
                            ]
                        },
                        {
                            "summaryComponent": "Sets the objective to 'rank:pairwise', enabling pairwise ranking optimization",
                            "codeSegments": [
                                {
                                    "line": 104,
                                    "code": "objective=\"rank:pairwise\","
                                }
                            ]
                        },
                        {
                            "summaryComponent": "Configures model hyperparameters:",
                            "codeSegments": [
                                {
                                    "line": 105,
                                    "code": "learning_rate=0.1,"
                                },
                                {
                                    "line": 106,
                                    "code": "n_estimators=n_estimators,"
                                },
                                {
                                    "line": 107,
                                    "code": "max_depth=4,"
                                },
                                {
                                    "line": 108,
                                    "code": "random_state=42,"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "learning_rate is set to 0.1, controlling the step size during boosting",
                            "codeSegments": [
                                {
                                    "line": 105,
                                    "code": "learning_rate=0.1,"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "n_estimators is set via a variable, determining the number of boosting rounds",
                            "codeSegments": [
                                {
                                    "line": 106,
                                    "code": "n_estimators=n_estimators,"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "max_depth is fixed at 4, limiting the depth of each tree to prevent overfitting",
                            "codeSegments": [
                                {
                                    "line": 107,
                                    "code": "max_depth=4,"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "random_state is set to 42, ensuring reproducible results",
                            "codeSegments": [
                                {
                                    "line": 108,
                                    "code": "random_state=42,"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "The model is prepared for subsequent training on ranking datasets",
                            "codeSegments": [
                                {
                                    "line": 103,
                                    "code": "model = XGBRanker("
                                }
                            ]
                        }
                    ]
                },
                "editPromptValue": "",
                "editPromptDetailLevel": null
            },
            "section_id": "93335828-8d7f-4a31-8029-c903c7a9319b"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:54:00.000",
        "event": "create_new_section",
        "id": "nrAKkC7fV6Vor0nCMfqV"
    },
    {
        "data": {
            "before_section_id": "99fc83b5-aef9-4d3c-ada9-c5e0760078ff",
            "after_section_id": "93335828-8d7f-4a31-8029-c903c7a9319b"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:54:00.000",
        "event": "autotransit_section",
        "id": "q9jkkvP7sROJitQcdbw3"
    },
    {
        "data": {
            "mapping_index": 0,
            "structured_type": "unstructured",
            "section_id": "93335828-8d7f-4a31-8029-c903c7a9319b",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:54:01.000",
        "event": "mapping_hover",
        "id": "djXMC0cgGhzatVRhSXOA"
    },
    {
        "data": {
            "before_detail_level": "medium",
            "after_detail_level": "high",
            "before_structured": "unstructured",
            "section_id": "93335828-8d7f-4a31-8029-c903c7a9319b",
            "after_structured": "unstructured"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:54:01.000",
        "event": "change_summary_level",
        "id": "kczbVAhaVbjhaz73pi14"
    },
    {
        "data": {
            "structured_type": "unstructured",
            "section_id": "93335828-8d7f-4a31-8029-c903c7a9319b",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:54:01.000",
        "event": "mapping_unhover",
        "id": "tB82mzjYalR8Zz9mM42F"
    },
    {
        "data": {
            "mapping_index": 0,
            "structured_type": "unstructured",
            "section_id": "93335828-8d7f-4a31-8029-c903c7a9319b",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:54:02.000",
        "event": "mapping_hover",
        "id": "ZEsIfAyDhalai571Alry"
    },
    {
        "data": {
            "mapping_index": 0,
            "structured_type": "unstructured",
            "section_id": "93335828-8d7f-4a31-8029-c903c7a9319b",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:54:02.000",
        "event": "mapping_hover",
        "id": "hMzFc8FB2wQDqAYitmGS"
    },
    {
        "data": {
            "structured_type": "unstructured",
            "section_id": "93335828-8d7f-4a31-8029-c903c7a9319b",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:54:02.000",
        "event": "mapping_unhover",
        "id": "lh5mslIC92oZThRmRa0I"
    },
    {
        "data": {
            "structured_type": "unstructured",
            "section_id": "93335828-8d7f-4a31-8029-c903c7a9319b",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:54:02.000",
        "event": "mapping_unhover",
        "id": "vRdXwL4eSP7KbXksgNeJ"
    },
    {
        "data": {
            "mapping_index": 1,
            "structured_type": "unstructured",
            "section_id": "93335828-8d7f-4a31-8029-c903c7a9319b",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:54:02.000",
        "event": "mapping_hover",
        "id": "wSRRWwZqtMc8lnxQFW0n"
    },
    {
        "data": {
            "structured_type": "unstructured",
            "section_id": "93335828-8d7f-4a31-8029-c903c7a9319b",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:54:04.000",
        "event": "mapping_unhover",
        "id": "T7zDCBhx73jWsqrvSYb2"
    },
    {
        "data": {
            "mapping_index": 1,
            "structured_type": "unstructured",
            "section_id": "93335828-8d7f-4a31-8029-c903c7a9319b",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:54:04.000",
        "event": "mapping_hover",
        "id": "fjvIE25GIe8lLu0r1Nzr"
    },
    {
        "data": {
            "structured_type": "unstructured",
            "section_id": "93335828-8d7f-4a31-8029-c903c7a9319b",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:54:06.000",
        "event": "mapping_unhover",
        "id": "CiB4IXTJKNWQnVZc6JRV"
    },
    {
        "data": {
            "structured_type": "unstructured",
            "section_id": "93335828-8d7f-4a31-8029-c903c7a9319b",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:54:06.000",
        "event": "mapping_unhover",
        "id": "DctwZATgb1MGx4kQrBeR"
    },
    {
        "data": {
            "mapping_index": 4,
            "structured_type": "unstructured",
            "section_id": "93335828-8d7f-4a31-8029-c903c7a9319b",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:54:06.000",
        "event": "mapping_hover",
        "id": "JbXowqnLarWRpsWTXqqx"
    },
    {
        "data": {
            "mapping_index": 2,
            "structured_type": "unstructured",
            "section_id": "93335828-8d7f-4a31-8029-c903c7a9319b",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:54:06.000",
        "event": "mapping_hover",
        "id": "OIynujMKdzBfY8vLtHy1"
    },
    {
        "data": {
            "mapping_index": 1,
            "structured_type": "unstructured",
            "section_id": "93335828-8d7f-4a31-8029-c903c7a9319b",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:54:06.000",
        "event": "mapping_hover",
        "id": "UAsDOUiJf1UdRU7ZPUpt"
    },
    {
        "data": {
            "structured_type": "unstructured",
            "section_id": "93335828-8d7f-4a31-8029-c903c7a9319b",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:54:06.000",
        "event": "mapping_unhover",
        "id": "XGeiaptpESSv49ed7HZT"
    },
    {
        "data": {
            "mapping_index": 3,
            "structured_type": "unstructured",
            "section_id": "93335828-8d7f-4a31-8029-c903c7a9319b",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:54:06.000",
        "event": "mapping_hover",
        "id": "bhfFdryDT00VPiPh5ZQd"
    },
    {
        "data": {
            "structured_type": "unstructured",
            "section_id": "93335828-8d7f-4a31-8029-c903c7a9319b",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:54:06.000",
        "event": "mapping_unhover",
        "id": "bsuKsfluZugBy1ZOkyMT"
    },
    {
        "data": {
            "mapping_index": 2,
            "structured_type": "unstructured",
            "section_id": "93335828-8d7f-4a31-8029-c903c7a9319b",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:54:08.000",
        "event": "mapping_hover",
        "id": "64OEAhAsKFjIakkmxovF"
    },
    {
        "data": {
            "structured_type": "unstructured",
            "section_id": "93335828-8d7f-4a31-8029-c903c7a9319b",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:54:08.000",
        "event": "mapping_unhover",
        "id": "9m4RL8a44oqEegHApeyk"
    },
    {
        "data": {
            "structured_type": "unstructured",
            "section_id": "93335828-8d7f-4a31-8029-c903c7a9319b",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:54:08.000",
        "event": "mapping_unhover",
        "id": "Y008wweZlOLhWW0iUGHv"
    },
    {
        "data": {
            "structured_type": "unstructured",
            "section_id": "93335828-8d7f-4a31-8029-c903c7a9319b",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:54:08.000",
        "event": "mapping_unhover",
        "id": "n10JH8v7cMC3S95m7vor"
    },
    {
        "data": {
            "mapping_index": 3,
            "structured_type": "unstructured",
            "section_id": "93335828-8d7f-4a31-8029-c903c7a9319b",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:54:08.000",
        "event": "mapping_hover",
        "id": "nUgGLmEKwr1WJsgCnAa1"
    },
    {
        "data": {
            "mapping_index": 2,
            "structured_type": "unstructured",
            "section_id": "93335828-8d7f-4a31-8029-c903c7a9319b",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:54:08.000",
        "event": "mapping_hover",
        "id": "tSNhuIXM6W2iLM6rMfTR"
    },
    {
        "data": {
            "mapping_index": 4,
            "structured_type": "unstructured",
            "section_id": "93335828-8d7f-4a31-8029-c903c7a9319b",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:54:10.000",
        "event": "mapping_hover",
        "id": "7fIwKzgN267jfko468rT"
    },
    {
        "data": {
            "structured_type": "unstructured",
            "section_id": "93335828-8d7f-4a31-8029-c903c7a9319b",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:54:10.000",
        "event": "mapping_unhover",
        "id": "Cm1ZKbFO3rDuw049GpnJ"
    },
    {
        "data": {
            "mapping_index": 3,
            "structured_type": "unstructured",
            "section_id": "93335828-8d7f-4a31-8029-c903c7a9319b",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:54:10.000",
        "event": "mapping_hover",
        "id": "YgVh4tHfYseXAoogtHjS"
    },
    {
        "data": {
            "mapping_index": 3,
            "structured_type": "unstructured",
            "section_id": "93335828-8d7f-4a31-8029-c903c7a9319b",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:54:10.000",
        "event": "mapping_hover",
        "id": "cElO50ojtY5snfvcniPR"
    },
    {
        "data": {
            "structured_type": "unstructured",
            "section_id": "93335828-8d7f-4a31-8029-c903c7a9319b",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:54:10.000",
        "event": "mapping_unhover",
        "id": "e35sdDrOD0biSe4r4wKk"
    },
    {
        "data": {
            "structured_type": "unstructured",
            "section_id": "93335828-8d7f-4a31-8029-c903c7a9319b",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:54:10.000",
        "event": "mapping_unhover",
        "id": "mhyekt88rFxDWyzMz4xF"
    },
    {
        "data": {
            "structured_type": "unstructured",
            "section_id": "93335828-8d7f-4a31-8029-c903c7a9319b",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:54:17.000",
        "event": "mapping_unhover",
        "id": "0SRrydcn9EEM0gfMynaq"
    },
    {
        "data": {
            "mapping_index": 4,
            "structured_type": "unstructured",
            "section_id": "93335828-8d7f-4a31-8029-c903c7a9319b",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:54:17.000",
        "event": "mapping_hover",
        "id": "YJrRBIUnWwmJ9evuEQEC"
    },
    {
        "data": {
            "mapping_index": 5,
            "structured_type": "unstructured",
            "section_id": "93335828-8d7f-4a31-8029-c903c7a9319b",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:54:17.000",
        "event": "mapping_hover",
        "id": "iaAlnhulV7z8pmfXrtUu"
    },
    {
        "data": {
            "structured_type": "unstructured",
            "section_id": "93335828-8d7f-4a31-8029-c903c7a9319b",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:54:17.000",
        "event": "mapping_unhover",
        "id": "yzeuALE6dBVsOvIpVNQZ"
    },
    {
        "data": {
            "structured_type": "unstructured",
            "section_id": "93335828-8d7f-4a31-8029-c903c7a9319b",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:54:19.000",
        "event": "mapping_unhover",
        "id": "6MHfObzBIpKy2FmKeaLE"
    },
    {
        "data": {
            "mapping_index": 5,
            "structured_type": "unstructured",
            "section_id": "93335828-8d7f-4a31-8029-c903c7a9319b",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:54:19.000",
        "event": "mapping_hover",
        "id": "6T0DmUJcB6XMQt9onnCT"
    },
    {
        "data": {
            "mapping_index": 6,
            "structured_type": "unstructured",
            "section_id": "93335828-8d7f-4a31-8029-c903c7a9319b",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:54:20.000",
        "event": "mapping_hover",
        "id": "6HX5dcodkCXHdGtRjM97"
    },
    {
        "data": {
            "structured_type": "unstructured",
            "section_id": "93335828-8d7f-4a31-8029-c903c7a9319b",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:54:20.000",
        "event": "mapping_unhover",
        "id": "vK8adsRhZ9804zhuXycS"
    },
    {
        "data": {
            "mapping_index": 7,
            "structured_type": "unstructured",
            "section_id": "93335828-8d7f-4a31-8029-c903c7a9319b",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:54:23.000",
        "event": "mapping_hover",
        "id": "DXGICveszn7OnDesjjKU"
    },
    {
        "data": {
            "structured_type": "unstructured",
            "section_id": "93335828-8d7f-4a31-8029-c903c7a9319b",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:54:23.000",
        "event": "mapping_unhover",
        "id": "zQa7sJtdXgZ5Ve38UFT4"
    },
    {
        "data": {
            "structured_type": "unstructured",
            "section_id": "93335828-8d7f-4a31-8029-c903c7a9319b",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:54:25.000",
        "event": "mapping_unhover",
        "id": "JbHTzTb4mXXlAUQl1pHJ"
    },
    {
        "data": {
            "mapping_index": 6,
            "structured_type": "unstructured",
            "section_id": "93335828-8d7f-4a31-8029-c903c7a9319b",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:54:25.000",
        "event": "mapping_hover",
        "id": "VKnhKytsIub7sBbaAno1"
    },
    {
        "data": {
            "mapping_index": 5,
            "structured_type": "unstructured",
            "section_id": "93335828-8d7f-4a31-8029-c903c7a9319b",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:54:26.000",
        "event": "mapping_hover",
        "id": "FI4MRqjti2GNwB1b99M7"
    },
    {
        "data": {
            "structured_type": "unstructured",
            "section_id": "93335828-8d7f-4a31-8029-c903c7a9319b",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:54:26.000",
        "event": "mapping_unhover",
        "id": "P3NTwoVyQ5BaDOozchGE"
    },
    {
        "data": {
            "structured_type": "unstructured",
            "section_id": "93335828-8d7f-4a31-8029-c903c7a9319b",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:54:28.000",
        "event": "mapping_unhover",
        "id": "cjdqVnZNhFeVWEpxGMaI"
    },
    {
        "data": {
            "mapping_index": 2,
            "structured_type": "unstructured",
            "section_id": "93335828-8d7f-4a31-8029-c903c7a9319b",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:54:28.000",
        "event": "mapping_hover",
        "id": "hRQIgLipgCpvdgSlEewd"
    },
    {
        "data": {
            "structured_type": "unstructured",
            "section_id": "93335828-8d7f-4a31-8029-c903c7a9319b",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:54:28.000",
        "event": "mapping_unhover",
        "id": "nFP6wSqt7rQBXB0KfiQa"
    },
    {
        "data": {
            "mapping_index": 3,
            "structured_type": "unstructured",
            "section_id": "93335828-8d7f-4a31-8029-c903c7a9319b",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:54:28.000",
        "event": "mapping_hover",
        "id": "uVsEeGDdVAPCbF8QfI0y"
    },
    {
        "data": {
            "structured_type": "unstructured",
            "section_id": "93335828-8d7f-4a31-8029-c903c7a9319b",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:54:29.000",
        "event": "mapping_unhover",
        "id": "ThYatyHFA3Aj7owOGwif"
    },
    {
        "data": {
            "mapping_index": 1,
            "structured_type": "unstructured",
            "section_id": "93335828-8d7f-4a31-8029-c903c7a9319b",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:54:29.000",
        "event": "mapping_hover",
        "id": "XoBlOJomRp2hcOnj9Mzf"
    },
    {
        "data": {
            "mapping_index": 1,
            "structured_type": "unstructured",
            "section_id": "93335828-8d7f-4a31-8029-c903c7a9319b",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:54:31.000",
        "event": "mapping_hover",
        "id": "REGmSxcdTledV5VcsEsa"
    },
    {
        "data": {
            "structured_type": "unstructured",
            "section_id": "93335828-8d7f-4a31-8029-c903c7a9319b",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:54:31.000",
        "event": "mapping_unhover",
        "id": "zQRsnYtK2ETgFcoD5CNu"
    },
    {
        "data": {
            "structured_type": "unstructured",
            "section_id": "93335828-8d7f-4a31-8029-c903c7a9319b",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:54:33.000",
        "event": "mapping_unhover",
        "id": "30opuKGlKprhxxmZecta"
    },
    {
        "data": {
            "structured_type": "unstructured",
            "section_id": "93335828-8d7f-4a31-8029-c903c7a9319b",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:54:33.000",
        "event": "mapping_unhover",
        "id": "6sEp7crmLsHO0x7IdYeb"
    },
    {
        "data": {
            "mapping_index": 2,
            "structured_type": "unstructured",
            "section_id": "93335828-8d7f-4a31-8029-c903c7a9319b",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:54:33.000",
        "event": "mapping_hover",
        "id": "FDaZsuA61nl1BTeGvprt"
    },
    {
        "data": {
            "structured_type": "unstructured",
            "section_id": "93335828-8d7f-4a31-8029-c903c7a9319b",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:54:33.000",
        "event": "mapping_unhover",
        "id": "S3QKSBiWUwhRFlaN4jZ2"
    },
    {
        "data": {
            "structured_type": "unstructured",
            "section_id": "93335828-8d7f-4a31-8029-c903c7a9319b",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:54:33.000",
        "event": "mapping_unhover",
        "id": "gKez0wO7HAV5RP3B6Z7m"
    },
    {
        "data": {
            "mapping_index": 4,
            "structured_type": "unstructured",
            "section_id": "93335828-8d7f-4a31-8029-c903c7a9319b",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:54:33.000",
        "event": "mapping_hover",
        "id": "iZ7ZlErZ3ats7ZchQ81Z"
    },
    {
        "data": {
            "mapping_index": 3,
            "structured_type": "unstructured",
            "section_id": "93335828-8d7f-4a31-8029-c903c7a9319b",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:54:33.000",
        "event": "mapping_hover",
        "id": "nrCrE0YjzDXGL93zu6Ip"
    },
    {
        "data": {
            "mapping_index": 2,
            "structured_type": "unstructured",
            "section_id": "93335828-8d7f-4a31-8029-c903c7a9319b",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:54:33.000",
        "event": "mapping_hover",
        "id": "qYhfUfjCdEVci0AHL8zd"
    },
    {
        "data": {
            "mapping_index": 3,
            "structured_type": "unstructured",
            "section_id": "93335828-8d7f-4a31-8029-c903c7a9319b",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:54:33.000",
        "event": "mapping_hover",
        "id": "rGh2TLps7VDUhEVObyps"
    },
    {
        "data": {
            "structured_type": "unstructured",
            "section_id": "93335828-8d7f-4a31-8029-c903c7a9319b",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:54:33.000",
        "event": "mapping_unhover",
        "id": "tAWiBj5HPqg1GvA5D5yu"
    },
    {
        "data": {
            "structured_type": "unstructured",
            "section_id": "93335828-8d7f-4a31-8029-c903c7a9319b",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:54:35.000",
        "event": "mapping_unhover",
        "id": "1pjkIMm1yjKuHJXXbbA4"
    },
    {
        "data": {
            "mapping_index": 3,
            "structured_type": "unstructured",
            "section_id": "93335828-8d7f-4a31-8029-c903c7a9319b",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:54:35.000",
        "event": "mapping_hover",
        "id": "ush6dESp5Kp3Sk7cjDkA"
    },
    {
        "data": {
            "structured_type": "unstructured",
            "section_id": "93335828-8d7f-4a31-8029-c903c7a9319b",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:54:36.000",
        "event": "mapping_unhover",
        "id": "THPLKCkXb6tjszH8cxNr"
    },
    {
        "data": {
            "mapping_index": 3,
            "structured_type": "unstructured",
            "section_id": "93335828-8d7f-4a31-8029-c903c7a9319b",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:54:36.000",
        "event": "mapping_hover",
        "id": "byD65R24xNvTko7R9nUC"
    },
    {
        "data": {
            "structured_type": "unstructured",
            "section_id": "93335828-8d7f-4a31-8029-c903c7a9319b",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:54:36.000",
        "event": "mapping_unhover",
        "id": "s56eDVl0pCcfWreWQMYJ"
    },
    {
        "data": {
            "mapping_index": 4,
            "structured_type": "unstructured",
            "section_id": "93335828-8d7f-4a31-8029-c903c7a9319b",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:54:36.000",
        "event": "mapping_hover",
        "id": "w5rL7H1YKm3SkYInwCrF"
    },
    {
        "data": {
            "structured_type": "unstructured",
            "section_id": "93335828-8d7f-4a31-8029-c903c7a9319b",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:54:37.000",
        "event": "mapping_unhover",
        "id": "48UDHiiEvrbhO9Tx5mZ6"
    },
    {
        "data": {
            "mapping_index": 2,
            "structured_type": "unstructured",
            "section_id": "93335828-8d7f-4a31-8029-c903c7a9319b",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:54:37.000",
        "event": "mapping_hover",
        "id": "DsLyOvBjF1f92TSgthAH"
    },
    {
        "data": {
            "structured_type": "unstructured",
            "section_id": "93335828-8d7f-4a31-8029-c903c7a9319b",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:54:37.000",
        "event": "mapping_unhover",
        "id": "SPf5jUAUM1PVxQzRCgyV"
    },
    {
        "data": {
            "mapping_index": 3,
            "structured_type": "unstructured",
            "section_id": "93335828-8d7f-4a31-8029-c903c7a9319b",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:54:37.000",
        "event": "mapping_hover",
        "id": "ivYtH3j3MGMShjiERTIp"
    },
    {
        "data": {
            "mapping_index": 3,
            "structured_type": "unstructured",
            "section_id": "93335828-8d7f-4a31-8029-c903c7a9319b",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:54:39.000",
        "event": "mapping_hover",
        "id": "AB0f8gM4g9uU1iQexSPE"
    },
    {
        "data": {
            "mapping_index": 4,
            "structured_type": "unstructured",
            "section_id": "93335828-8d7f-4a31-8029-c903c7a9319b",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:54:39.000",
        "event": "mapping_hover",
        "id": "EdZ1F5CBj7VQctBFqCER"
    },
    {
        "data": {
            "structured_type": "unstructured",
            "section_id": "93335828-8d7f-4a31-8029-c903c7a9319b",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:54:39.000",
        "event": "mapping_unhover",
        "id": "G22hEnYFSq8RIx4dVA8n"
    },
    {
        "data": {
            "structured_type": "unstructured",
            "section_id": "93335828-8d7f-4a31-8029-c903c7a9319b",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:54:39.000",
        "event": "mapping_unhover",
        "id": "fID3qrMPgBbPhCtE8DtI"
    },
    {
        "data": {
            "structured_type": "unstructured",
            "section_id": "93335828-8d7f-4a31-8029-c903c7a9319b",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:54:40.000",
        "event": "mapping_unhover",
        "id": "M6nN0Ne8zU7XMrLG5TNV"
    },
    {
        "data": {
            "mapping_index": 2,
            "structured_type": "unstructured",
            "section_id": "93335828-8d7f-4a31-8029-c903c7a9319b",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:54:40.000",
        "event": "mapping_hover",
        "id": "ahHuf3XGUGC2kow4DYSv"
    },
    {
        "data": {
            "structured_type": "unstructured",
            "section_id": "93335828-8d7f-4a31-8029-c903c7a9319b",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:54:41.000",
        "event": "mapping_unhover",
        "id": "OWTvH7bZQ5HqbcvmDfsL"
    },
    {
        "data": {
            "mapping_index": 3,
            "structured_type": "unstructured",
            "section_id": "93335828-8d7f-4a31-8029-c903c7a9319b",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:54:41.000",
        "event": "mapping_hover",
        "id": "wsomcDOXB7D24AQKxrll"
    },
    {
        "data": {
            "structured_type": "unstructured",
            "section_id": "93335828-8d7f-4a31-8029-c903c7a9319b",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:54:42.000",
        "event": "mapping_unhover",
        "id": "uFT62nGJCSa0I1Xc6ka6"
    },
    {
        "data": {
            "structured_type": "unstructured",
            "section_id": "93335828-8d7f-4a31-8029-c903c7a9319b",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:54:45.000",
        "event": "mapping_unhover",
        "id": "8PsSqpmgeOIHykaZlf3x"
    },
    {
        "data": {
            "mapping_index": 3,
            "structured_type": "unstructured",
            "section_id": "93335828-8d7f-4a31-8029-c903c7a9319b",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:54:45.000",
        "event": "mapping_hover",
        "id": "FhhJYyitzSjX3mIEAAGR"
    },
    {
        "data": {
            "mapping_index": 5,
            "structured_type": "unstructured",
            "section_id": "93335828-8d7f-4a31-8029-c903c7a9319b",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:54:45.000",
        "event": "mapping_hover",
        "id": "FvxH8k7Hw89EKxwt2pUU"
    },
    {
        "data": {
            "mapping_index": 6,
            "structured_type": "unstructured",
            "section_id": "93335828-8d7f-4a31-8029-c903c7a9319b",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:54:45.000",
        "event": "mapping_hover",
        "id": "Q16iP4FDZMkmupPcFicV"
    },
    {
        "data": {
            "mapping_index": 0,
            "structured_type": "unstructured",
            "section_id": "93335828-8d7f-4a31-8029-c903c7a9319b",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:54:45.000",
        "event": "mapping_hover",
        "id": "T9MPfrFSKh0xA4jve20k"
    },
    {
        "data": {
            "mapping_index": 1,
            "structured_type": "unstructured",
            "section_id": "93335828-8d7f-4a31-8029-c903c7a9319b",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:54:45.000",
        "event": "mapping_hover",
        "id": "UXLutxEts9M2R6diFsAv"
    },
    {
        "data": {
            "structured_type": "unstructured",
            "section_id": "93335828-8d7f-4a31-8029-c903c7a9319b",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:54:45.000",
        "event": "mapping_unhover",
        "id": "XJZEh4GZ0seLhTYuW0jB"
    },
    {
        "data": {
            "structured_type": "unstructured",
            "section_id": "93335828-8d7f-4a31-8029-c903c7a9319b",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:54:45.000",
        "event": "mapping_unhover",
        "id": "aIhctIY3T7tjqfibvj1d"
    },
    {
        "data": {
            "structured_type": "unstructured",
            "section_id": "93335828-8d7f-4a31-8029-c903c7a9319b",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:54:45.000",
        "event": "mapping_unhover",
        "id": "jL1VpVli0iKEEbP6Nyti"
    },
    {
        "data": {
            "structured_type": "unstructured",
            "section_id": "93335828-8d7f-4a31-8029-c903c7a9319b",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:54:46.000",
        "event": "mapping_unhover",
        "id": "7aeINKR5w0HcSEgiY4tX"
    },
    {
        "data": {
            "structured_type": "unstructured",
            "section_id": "93335828-8d7f-4a31-8029-c903c7a9319b",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:54:46.000",
        "event": "mapping_unhover",
        "id": "7hSHT0F2TgnCv9Z0Af76"
    },
    {
        "data": {
            "mapping_index": 0,
            "structured_type": "unstructured",
            "section_id": "93335828-8d7f-4a31-8029-c903c7a9319b",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:54:46.000",
        "event": "mapping_hover",
        "id": "J58Q2GyfcPzXP7TiXnVq"
    },
    {
        "data": {
            "mapping_index": 1,
            "structured_type": "unstructured",
            "section_id": "93335828-8d7f-4a31-8029-c903c7a9319b",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:54:46.000",
        "event": "mapping_hover",
        "id": "N7UC93vMNzj7v7UKapjv"
    },
    {
        "data": {
            "structured_type": "unstructured",
            "section_id": "93335828-8d7f-4a31-8029-c903c7a9319b",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:54:46.000",
        "event": "mapping_unhover",
        "id": "NfoopIDeiuw7XWG3ICCb"
    },
    {
        "data": {
            "structured_type": "unstructured",
            "section_id": "93335828-8d7f-4a31-8029-c903c7a9319b",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:54:46.000",
        "event": "mapping_unhover",
        "id": "elQ1rwTd45e5lTgN3e0O"
    },
    {
        "data": {
            "mapping_index": 2,
            "structured_type": "unstructured",
            "section_id": "93335828-8d7f-4a31-8029-c903c7a9319b",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:54:46.000",
        "event": "mapping_hover",
        "id": "saKC1aRpGYZvGaS00zGJ"
    },
    {
        "data": {
            "mapping_index": 4,
            "structured_type": "unstructured",
            "section_id": "93335828-8d7f-4a31-8029-c903c7a9319b",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:54:47.000",
        "event": "mapping_hover",
        "id": "H5NzMah0dGTh6gxVd5VZ"
    },
    {
        "data": {
            "mapping_index": 5,
            "structured_type": "unstructured",
            "section_id": "93335828-8d7f-4a31-8029-c903c7a9319b",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:54:47.000",
        "event": "mapping_hover",
        "id": "Y5n098QilPyJXZ3mmOUy"
    },
    {
        "data": {
            "structured_type": "unstructured",
            "section_id": "93335828-8d7f-4a31-8029-c903c7a9319b",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:54:47.000",
        "event": "mapping_unhover",
        "id": "msQbSxGMFaoqQs0Qqig9"
    },
    {
        "data": {
            "structured_type": "unstructured",
            "section_id": "93335828-8d7f-4a31-8029-c903c7a9319b",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:54:47.000",
        "event": "mapping_unhover",
        "id": "tNHJWbj72JN8IPwYvbvZ"
    },
    {
        "data": {
            "mapping_index": 6,
            "structured_type": "unstructured",
            "section_id": "93335828-8d7f-4a31-8029-c903c7a9319b",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:54:47.000",
        "event": "mapping_hover",
        "id": "uMii8uvrIPoDHk02kXUQ"
    },
    {
        "data": {
            "structured_type": "unstructured",
            "section_id": "93335828-8d7f-4a31-8029-c903c7a9319b",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:54:48.000",
        "event": "mapping_unhover",
        "id": "KhnTOKvQQByEOziKgHW9"
    },
    {
        "data": {
            "mapping_index": 3,
            "structured_type": "unstructured",
            "section_id": "93335828-8d7f-4a31-8029-c903c7a9319b",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:54:48.000",
        "event": "mapping_hover",
        "id": "R3J1iNPdou5Y6dDeMQ7o"
    },
    {
        "data": {
            "structured_type": "unstructured",
            "section_id": "93335828-8d7f-4a31-8029-c903c7a9319b",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:54:48.000",
        "event": "mapping_unhover",
        "id": "hTRquJexMqCnuXxrbmYY"
    },
    {
        "data": {
            "mapping_index": 6,
            "structured_type": "unstructured",
            "section_id": "93335828-8d7f-4a31-8029-c903c7a9319b",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:54:53.000",
        "event": "mapping_hover",
        "id": "upmkUixx8GAjeo00mpWS"
    },
    {
        "data": {
            "structured_type": "unstructured",
            "section_id": "93335828-8d7f-4a31-8029-c903c7a9319b",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:54:53.000",
        "event": "mapping_unhover",
        "id": "wBA4z52kXCwNbz0KxAS1"
    },
    {
        "data": {
            "mapping_index": 0,
            "structured_type": "unstructured",
            "section_id": "93335828-8d7f-4a31-8029-c903c7a9319b",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:54:56.000",
        "event": "mapping_hover",
        "id": "lk7nnHID9dUZzVhceCOK"
    },
    {
        "data": {
            "structured_type": "unstructured",
            "section_id": "93335828-8d7f-4a31-8029-c903c7a9319b",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:54:56.000",
        "event": "mapping_unhover",
        "id": "xwDqYDI0h9BDvb9Sb4co"
    },
    {
        "data": {
            "mapping_index": 3,
            "structured_type": "unstructured",
            "section_id": "93335828-8d7f-4a31-8029-c903c7a9319b",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:54:57.000",
        "event": "mapping_hover",
        "id": "67yiH8jezmGTIE4GlJeb"
    },
    {
        "data": {
            "structured_type": "unstructured",
            "section_id": "93335828-8d7f-4a31-8029-c903c7a9319b",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:54:57.000",
        "event": "mapping_unhover",
        "id": "7tjQYuzzGjm4nWast0qu"
    },
    {
        "data": {
            "mapping_index": 2,
            "structured_type": "unstructured",
            "section_id": "93335828-8d7f-4a31-8029-c903c7a9319b",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:54:57.000",
        "event": "mapping_hover",
        "id": "UYXx63Jog9Ms2aBKdlqh"
    },
    {
        "data": {
            "structured_type": "unstructured",
            "section_id": "93335828-8d7f-4a31-8029-c903c7a9319b",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:54:57.000",
        "event": "mapping_unhover",
        "id": "wxToPPKCEhoJphsblsId"
    },
    {
        "data": {},
        "source": "frontend",
        "timestamp": "2025-08-23 10:54:59.000",
        "event": "click_summarize_code",
        "id": "PTybLO2fmqCrkNcbC6yf"
    },
    {
        "data": {
            "selected_code": "n_estimators=n_estimators,",
            "summary": {
                "medium_unstructured": "In this snippet, the n_estimators parameter is assigned during the initialization of the XGBRanker model. This parameter controls the number of boosting rounds the model will perform. Its value is determined by the current n_estimators variable.",
                "low_structured": "• Sets n_estimators in model initialization\n• Used for XGBRanker configuration",
                "title": "Assignment of n_estimators Parameter in XGBRanker Initialization",
                "medium_structured": "• Assigns n_estimators parameter in XGBRanker constructor\n• n_estimators determines the number of boosting rounds\n• Value comes from the n_estimators variable in the loop",
                "high_unstructured": "This line assigns the n_estimators parameter when initializing an XGBRanker model, specifying how many boosting rounds (trees) the model should train. The value for n_estimators is dynamically set by the n_estimators variable, which is iterated over in a loop to test different model complexities. Adjusting n_estimators allows the code to compare model performance across different numbers of trees. This parameter is crucial for controlling the trade-off between underfitting and overfitting in gradient boosting models.",
                "high_structured": "• Sets the n_estimators parameter in the XGBRanker model initialization\n  ◦ Determines the number of boosting rounds (trees) to train\n• The value is provided by the n_estimators variable, which changes in a loop\n  ◦ Enables experimentation with different model complexities\n• Adjusting n_estimators helps balance underfitting and overfitting\n• This parameter is essential for tuning the performance of the gradient boosting model",
                "low_unstructured": "The code sets the n_estimators parameter when creating an XGBRanker model."
            }
        },
        "source": "backend",
        "timestamp": "2025-08-23 10:55:03.000",
        "event": "summarize_selected_code",
        "id": "ox1pI6ni78cmww8zVHp8"
    },
    {
        "data": {
            "structured_type": "unstructured",
            "section_id": "93335828-8d7f-4a31-8029-c903c7a9319b",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:55:04.000",
        "event": "mapping_unhover",
        "id": "Cf3ZI3aInVhJupKmRLVq"
    },
    {
        "data": {
            "mapping": [
                {
                    "summaryComponent": "Assigns n_estimators parameter in XGBRanker constructor",
                    "codeSegments": [
                        {
                            "line": 106,
                            "code": "n_estimators=n_estimators,"
                        }
                    ]
                },
                {
                    "summaryComponent": "n_estimators determines the number of boosting rounds",
                    "codeSegments": [
                        {
                            "line": 106,
                            "code": "n_estimators=n_estimators,"
                        }
                    ]
                },
                {
                    "summaryComponent": "Value comes from the n_estimators variable in the loop",
                    "codeSegments": [
                        {
                            "line": 106,
                            "code": "n_estimators"
                        }
                    ]
                }
            ],
            "summary": "• Assigns n_estimators parameter in XGBRanker constructor\n• n_estimators determines the number of boosting rounds\n• Value comes from the n_estimators variable in the loop",
            "code": "106: n_estimators=n_estimators,"
        },
        "source": "backend",
        "timestamp": "2025-08-23 10:55:04.000",
        "event": "map_summary_code",
        "id": "EvHUIuRHj2e5bi19lE9D"
    },
    {
        "data": {
            "mapping_index": 1,
            "structured_type": "unstructured",
            "section_id": "93335828-8d7f-4a31-8029-c903c7a9319b",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:55:04.000",
        "event": "mapping_hover",
        "id": "IArrbicWYqgwdcBPkSkb"
    },
    {
        "data": {
            "mapping": [
                {
                    "summaryComponent": "Sets n_estimators in model initialization",
                    "codeSegments": [
                        {
                            "line": 106,
                            "code": "n_estimators=n_estimators,"
                        }
                    ]
                },
                {
                    "summaryComponent": "Used for XGBRanker configuration",
                    "codeSegments": [
                        {
                            "line": 106,
                            "code": "n_estimators=n_estimators,"
                        }
                    ]
                }
            ],
            "summary": "• Sets n_estimators in model initialization\n• Used for XGBRanker configuration",
            "code": "106: n_estimators=n_estimators,"
        },
        "source": "backend",
        "timestamp": "2025-08-23 10:55:04.000",
        "event": "map_summary_code",
        "id": "Jk030CqD7dP46InGSb6x"
    },
    {
        "data": {
            "structured_type": "unstructured",
            "section_id": "93335828-8d7f-4a31-8029-c903c7a9319b",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:55:04.000",
        "event": "mapping_unhover",
        "id": "NqjAxnPT2ShD1t03gGH0"
    },
    {
        "data": {
            "mapping_index": 0,
            "structured_type": "unstructured",
            "section_id": "93335828-8d7f-4a31-8029-c903c7a9319b",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:55:04.000",
        "event": "mapping_hover",
        "id": "PNovJSGGmcul1wCpRQrn"
    },
    {
        "data": {
            "mapping_index": 3,
            "structured_type": "unstructured",
            "section_id": "93335828-8d7f-4a31-8029-c903c7a9319b",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:55:04.000",
        "event": "mapping_hover",
        "id": "ox0g4zQGYYK7RnQAB3vm"
    },
    {
        "data": {
            "mapping": [
                {
                    "summaryComponent": "the n_estimators parameter is assigned",
                    "codeSegments": [
                        {
                            "line": 106,
                            "code": "n_estimators=n_estimators,"
                        }
                    ]
                },
                {
                    "summaryComponent": "during the initialization of the XGBRanker model",
                    "codeSegments": [
                        {
                            "line": 106,
                            "code": "n_estimators=n_estimators,"
                        }
                    ]
                },
                {
                    "summaryComponent": "This parameter controls the number of boosting rounds the model will perform",
                    "codeSegments": [
                        {
                            "line": 106,
                            "code": "n_estimators=n_estimators,"
                        }
                    ]
                },
                {
                    "summaryComponent": "Its value is determined by the current n_estimators variable",
                    "codeSegments": [
                        {
                            "line": 106,
                            "code": "n_estimators=n_estimators,"
                        }
                    ]
                }
            ],
            "summary": "In this snippet, the n_estimators parameter is assigned during the initialization of the XGBRanker model. This parameter controls the number of boosting rounds the model will perform. Its value is determined by the current n_estimators variable.",
            "code": "106: n_estimators=n_estimators,"
        },
        "source": "backend",
        "timestamp": "2025-08-23 10:55:05.000",
        "event": "map_summary_code",
        "id": "3hj5iUnrX0cWMpGz1FMg"
    },
    {
        "data": {
            "structured_type": "unstructured",
            "section_id": "93335828-8d7f-4a31-8029-c903c7a9319b",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:55:05.000",
        "event": "mapping_unhover",
        "id": "Ba46nps95zy1lIsGdi3G"
    },
    {
        "data": {
            "before_section_id": "93335828-8d7f-4a31-8029-c903c7a9319b",
            "after_section_id": "7ffe7acb-50ac-4749-a589-5ab44e23a67d"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:55:05.000",
        "event": "autotransit_section",
        "id": "EF73amyW9yYfoDR4AKFf"
    },
    {
        "data": {
            "mapping": [
                {
                    "summaryComponent": "Sets the n_estimators parameter in the XGBRanker model initialization",
                    "codeSegments": [
                        {
                            "line": 106,
                            "code": "n_estimators=n_estimators,"
                        }
                    ]
                },
                {
                    "summaryComponent": "Determines the number of boosting rounds (trees) to train",
                    "codeSegments": [
                        {
                            "line": 106,
                            "code": "n_estimators=n_estimators,"
                        }
                    ]
                },
                {
                    "summaryComponent": "The value is provided by the n_estimators variable, which changes in a loop",
                    "codeSegments": [
                        {
                            "line": 106,
                            "code": "n_estimators=n_estimators,"
                        }
                    ]
                },
                {
                    "summaryComponent": "Enables experimentation with different model complexities",
                    "codeSegments": [
                        {
                            "line": 106,
                            "code": "n_estimators=n_estimators,"
                        }
                    ]
                },
                {
                    "summaryComponent": "Adjusting n_estimators helps balance underfitting and overfitting",
                    "codeSegments": [
                        {
                            "line": 106,
                            "code": "n_estimators=n_estimators,"
                        }
                    ]
                },
                {
                    "summaryComponent": "This parameter is essential for tuning the performance of the gradient boosting model",
                    "codeSegments": [
                        {
                            "line": 106,
                            "code": "n_estimators=n_estimators,"
                        }
                    ]
                }
            ],
            "summary": "• Sets the n_estimators parameter in the XGBRanker model initialization\n  ◦ Determines the number of boosting rounds (trees) to train\n• The value is provided by the n_estimators variable, which changes in a loop\n  ◦ Enables experimentation with different model complexities\n• Adjusting n_estimators helps balance underfitting and overfitting\n• This parameter is essential for tuning the performance of the gradient boosting model",
            "code": "106: n_estimators=n_estimators,"
        },
        "source": "backend",
        "timestamp": "2025-08-23 10:55:05.000",
        "event": "map_summary_code",
        "id": "PtFDSLPKkR92gIJhCSNH"
    },
    {
        "data": {
            "section_data": {
                "lines": [
                    106,
                    106
                ],
                "summaryData": {
                    "medium_unstructured": "In this snippet, the n_estimators parameter is assigned during the initialization of the XGBRanker model. This parameter controls the number of boosting rounds the model will perform. Its value is determined by the current n_estimators variable.",
                    "low_structured": "• Sets n_estimators in model initialization\n• Used for XGBRanker configuration",
                    "title": "Assignment of n_estimators Parameter in XGBRanker Initialization",
                    "medium_structured": "• Assigns n_estimators parameter in XGBRanker constructor\n• n_estimators determines the number of boosting rounds\n• Value comes from the n_estimators variable in the loop",
                    "high_unstructured": "This line assigns the n_estimators parameter when initializing an XGBRanker model, specifying how many boosting rounds (trees) the model should train. The value for n_estimators is dynamically set by the n_estimators variable, which is iterated over in a loop to test different model complexities. Adjusting n_estimators allows the code to compare model performance across different numbers of trees. This parameter is crucial for controlling the trade-off between underfitting and overfitting in gradient boosting models.",
                    "high_structured": "• Sets the n_estimators parameter in the XGBRanker model initialization\n  ◦ Determines the number of boosting rounds (trees) to train\n• The value is provided by the n_estimators variable, which changes in a loop\n  ◦ Enables experimentation with different model complexities\n• Adjusting n_estimators helps balance underfitting and overfitting\n• This parameter is essential for tuning the performance of the gradient boosting model",
                    "low_unstructured": "The code sets the n_estimators parameter when creating an XGBRanker model."
                },
                "editPromptStructured": null,
                "createdAt": 1755975305000,
                "metadata": {
                    "filename": "rank_model.py",
                    "id": "7ffe7acb-50ac-4749-a589-5ab44e23a67d",
                    "originalCode": "n_estimators=n_estimators,",
                    "fullPath": "/project/workspace/rank_model.py",
                    "offset": 2879
                },
                "selectedStructured": "unstructured",
                "title": "Assignment of n_estimators Parameter in XGBRanker Initialization",
                "selectedDetailLevel": "medium",
                "summaryMappings": {
                    "medium_unstructured": [
                        {
                            "summaryComponent": "the n_estimators parameter is assigned",
                            "codeSegments": [
                                {
                                    "line": 106,
                                    "code": "n_estimators=n_estimators,"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "during the initialization of the XGBRanker model",
                            "codeSegments": [
                                {
                                    "line": 106,
                                    "code": "n_estimators=n_estimators,"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "This parameter controls the number of boosting rounds the model will perform",
                            "codeSegments": [
                                {
                                    "line": 106,
                                    "code": "n_estimators=n_estimators,"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "Its value is determined by the current n_estimators variable",
                            "codeSegments": [
                                {
                                    "line": 106,
                                    "code": "n_estimators=n_estimators,"
                                }
                            ]
                        }
                    ],
                    "low_structured": [
                        {
                            "summaryComponent": "Sets n_estimators in model initialization",
                            "codeSegments": [
                                {
                                    "line": 106,
                                    "code": "n_estimators=n_estimators,"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "Used for XGBRanker configuration",
                            "codeSegments": [
                                {
                                    "line": 106,
                                    "code": "n_estimators=n_estimators,"
                                }
                            ]
                        }
                    ],
                    "low_unstructured": [
                        {
                            "summaryComponent": "sets the n_estimators parameter",
                            "codeSegments": [
                                {
                                    "line": 106,
                                    "code": "n_estimators=n_estimators,"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "when creating an XGBRanker model",
                            "codeSegments": [
                                {
                                    "line": 106,
                                    "code": "n_estimators=n_estimators,"
                                }
                            ]
                        }
                    ],
                    "medium_structured": [
                        {
                            "summaryComponent": "Assigns n_estimators parameter in XGBRanker constructor",
                            "codeSegments": [
                                {
                                    "line": 106,
                                    "code": "n_estimators=n_estimators,"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "n_estimators determines the number of boosting rounds",
                            "codeSegments": [
                                {
                                    "line": 106,
                                    "code": "n_estimators=n_estimators,"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "Value comes from the n_estimators variable in the loop",
                            "codeSegments": [
                                {
                                    "line": 106,
                                    "code": "n_estimators"
                                }
                            ]
                        }
                    ],
                    "high_unstructured": [
                        {
                            "summaryComponent": "assigns the n_estimators parameter",
                            "codeSegments": [
                                {
                                    "line": 106,
                                    "code": "n_estimators=n_estimators,"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "when initializing an XGBRanker model",
                            "codeSegments": [
                                {
                                    "line": 106,
                                    "code": "n_estimators=n_estimators,"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "specifying how many boosting rounds (trees) the model should train",
                            "codeSegments": [
                                {
                                    "line": 106,
                                    "code": "n_estimators=n_estimators,"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "The value for n_estimators is dynamically set by the n_estimators variable",
                            "codeSegments": [
                                {
                                    "line": 106,
                                    "code": "n_estimators=n_estimators,"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "which is iterated over in a loop to test different model complexities",
                            "codeSegments": [
                                {
                                    "line": 106,
                                    "code": "n_estimators=n_estimators,"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "Adjusting n_estimators allows the code to compare model performance across different numbers of trees",
                            "codeSegments": [
                                {
                                    "line": 106,
                                    "code": "n_estimators=n_estimators,"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "This parameter is crucial for controlling the trade-off between underfitting and overfitting in gradient boosting models",
                            "codeSegments": [
                                {
                                    "line": 106,
                                    "code": "n_estimators=n_estimators,"
                                }
                            ]
                        }
                    ],
                    "high_structured": [
                        {
                            "summaryComponent": "Sets the n_estimators parameter in the XGBRanker model initialization",
                            "codeSegments": [
                                {
                                    "line": 106,
                                    "code": "n_estimators=n_estimators,"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "Determines the number of boosting rounds (trees) to train",
                            "codeSegments": [
                                {
                                    "line": 106,
                                    "code": "n_estimators=n_estimators,"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "The value is provided by the n_estimators variable, which changes in a loop",
                            "codeSegments": [
                                {
                                    "line": 106,
                                    "code": "n_estimators=n_estimators,"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "Enables experimentation with different model complexities",
                            "codeSegments": [
                                {
                                    "line": 106,
                                    "code": "n_estimators=n_estimators,"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "Adjusting n_estimators helps balance underfitting and overfitting",
                            "codeSegments": [
                                {
                                    "line": 106,
                                    "code": "n_estimators=n_estimators,"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "This parameter is essential for tuning the performance of the gradient boosting model",
                            "codeSegments": [
                                {
                                    "line": 106,
                                    "code": "n_estimators=n_estimators,"
                                }
                            ]
                        }
                    ]
                },
                "editPromptValue": "",
                "editPromptDetailLevel": null
            },
            "section_id": "7ffe7acb-50ac-4749-a589-5ab44e23a67d"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:55:05.000",
        "event": "create_new_section",
        "id": "TEsNxNJ0Ujoa4jWopbQX"
    },
    {
        "data": {
            "structured_type": "unstructured",
            "section_id": "93335828-8d7f-4a31-8029-c903c7a9319b",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:55:05.000",
        "event": "mapping_unhover",
        "id": "cq76FG7Iuc7uhBGUTKU7"
    },
    {
        "data": {
            "mapping": [
                {
                    "summaryComponent": "assigns the n_estimators parameter",
                    "codeSegments": [
                        {
                            "line": 106,
                            "code": "n_estimators=n_estimators,"
                        }
                    ]
                },
                {
                    "summaryComponent": "when initializing an XGBRanker model",
                    "codeSegments": [
                        {
                            "line": 106,
                            "code": "n_estimators=n_estimators,"
                        }
                    ]
                },
                {
                    "summaryComponent": "specifying how many boosting rounds (trees) the model should train",
                    "codeSegments": [
                        {
                            "line": 106,
                            "code": "n_estimators=n_estimators,"
                        }
                    ]
                },
                {
                    "summaryComponent": "The value for n_estimators is dynamically set by the n_estimators variable",
                    "codeSegments": [
                        {
                            "line": 106,
                            "code": "n_estimators=n_estimators,"
                        }
                    ]
                },
                {
                    "summaryComponent": "which is iterated over in a loop to test different model complexities",
                    "codeSegments": [
                        {
                            "line": 106,
                            "code": "n_estimators=n_estimators,"
                        }
                    ]
                },
                {
                    "summaryComponent": "Adjusting n_estimators allows the code to compare model performance across different numbers of trees",
                    "codeSegments": [
                        {
                            "line": 106,
                            "code": "n_estimators=n_estimators,"
                        }
                    ]
                },
                {
                    "summaryComponent": "This parameter is crucial for controlling the trade-off between underfitting and overfitting in gradient boosting models",
                    "codeSegments": [
                        {
                            "line": 106,
                            "code": "n_estimators=n_estimators,"
                        }
                    ]
                }
            ],
            "summary": "This line assigns the n_estimators parameter when initializing an XGBRanker model, specifying how many boosting rounds (trees) the model should train. The value for n_estimators is dynamically set by the n_estimators variable, which is iterated over in a loop to test different model complexities. Adjusting n_estimators allows the code to compare model performance across different numbers of trees. This parameter is crucial for controlling the trade-off between underfitting and overfitting in gradient boosting models.",
            "code": "106: n_estimators=n_estimators,"
        },
        "source": "backend",
        "timestamp": "2025-08-23 10:55:05.000",
        "event": "map_summary_code",
        "id": "i4QyViYlQdzIGVlOILen"
    },
    {
        "data": {
            "mapping": [
                {
                    "summaryComponent": "sets the n_estimators parameter",
                    "codeSegments": [
                        {
                            "line": 106,
                            "code": "n_estimators=n_estimators,"
                        }
                    ]
                },
                {
                    "summaryComponent": "when creating an XGBRanker model",
                    "codeSegments": [
                        {
                            "line": 106,
                            "code": "n_estimators=n_estimators,"
                        }
                    ]
                }
            ],
            "summary": "The code sets the n_estimators parameter when creating an XGBRanker model.",
            "code": "106: n_estimators=n_estimators,"
        },
        "source": "backend",
        "timestamp": "2025-08-23 10:55:05.000",
        "event": "map_summary_code",
        "id": "lR02HQvo5WJnyfCebrZe"
    },
    {
        "data": {
            "mapping_index": 2,
            "structured_type": "unstructured",
            "section_id": "93335828-8d7f-4a31-8029-c903c7a9319b",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:55:05.000",
        "event": "mapping_hover",
        "id": "sHTP1fkhHCaIQH5DOLow"
    },
    {
        "data": {
            "mapping_index": 0,
            "structured_type": "unstructured",
            "section_id": "7ffe7acb-50ac-4749-a589-5ab44e23a67d",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:55:06.000",
        "event": "mapping_hover",
        "id": "RxvrqjKI2PMQtUiQdqCA"
    },
    {
        "data": {
            "mapping_index": 1,
            "structured_type": "unstructured",
            "section_id": "7ffe7acb-50ac-4749-a589-5ab44e23a67d",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:55:06.000",
        "event": "mapping_hover",
        "id": "XXejLG0rGzD4wwlZgVkT"
    },
    {
        "data": {
            "structured_type": "unstructured",
            "section_id": "7ffe7acb-50ac-4749-a589-5ab44e23a67d",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:55:06.000",
        "event": "mapping_unhover",
        "id": "dtpWBXxllIah5QbCIfti"
    },
    {
        "data": {
            "mapping_index": 2,
            "structured_type": "unstructured",
            "section_id": "7ffe7acb-50ac-4749-a589-5ab44e23a67d",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:55:06.000",
        "event": "mapping_hover",
        "id": "fkmeaFQGUmCFVyNBP3Uj"
    },
    {
        "data": {
            "structured_type": "unstructured",
            "section_id": "7ffe7acb-50ac-4749-a589-5ab44e23a67d",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:55:06.000",
        "event": "mapping_unhover",
        "id": "hwFgJwaxIpvcxvnWtga0"
    },
    {
        "data": {
            "mapping_index": 3,
            "structured_type": "unstructured",
            "section_id": "7ffe7acb-50ac-4749-a589-5ab44e23a67d",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:55:07.000",
        "event": "mapping_hover",
        "id": "3eyCTEVU1YMouoUsPsHP"
    },
    {
        "data": {
            "structured_type": "unstructured",
            "section_id": "7ffe7acb-50ac-4749-a589-5ab44e23a67d",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:55:07.000",
        "event": "mapping_unhover",
        "id": "Y0RF0jSK2XLr3erWT8tZ"
    },
    {
        "data": {
            "mapping_index": 1,
            "structured_type": "unstructured",
            "section_id": "7ffe7acb-50ac-4749-a589-5ab44e23a67d",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:55:12.000",
        "event": "mapping_hover",
        "id": "CkFefy5hvCA47Z9m3Zt3"
    },
    {
        "data": {
            "structured_type": "unstructured",
            "section_id": "7ffe7acb-50ac-4749-a589-5ab44e23a67d",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:55:12.000",
        "event": "mapping_unhover",
        "id": "K9xlfI3NUqclwbCF2GR4"
    },
    {
        "data": {
            "mapping_index": 0,
            "structured_type": "unstructured",
            "section_id": "7ffe7acb-50ac-4749-a589-5ab44e23a67d",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:55:12.000",
        "event": "mapping_hover",
        "id": "Yg8fdKp2fN7HJMWhSy3v"
    },
    {
        "data": {
            "structured_type": "unstructured",
            "section_id": "7ffe7acb-50ac-4749-a589-5ab44e23a67d",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:55:12.000",
        "event": "mapping_unhover",
        "id": "fNQCmRHlM9iKIN5f23fm"
    },
    {
        "data": {
            "structured_type": "unstructured",
            "section_id": "7ffe7acb-50ac-4749-a589-5ab44e23a67d",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:55:12.000",
        "event": "mapping_unhover",
        "id": "hv6dBPuJjQop1HjOia1K"
    },
    {
        "data": {
            "mapping_index": 2,
            "structured_type": "unstructured",
            "section_id": "7ffe7acb-50ac-4749-a589-5ab44e23a67d",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:55:12.000",
        "event": "mapping_hover",
        "id": "u9PO8npZkmneTSWAWMPL"
    },
    {
        "data": {
            "structured_type": "unstructured",
            "section_id": "7ffe7acb-50ac-4749-a589-5ab44e23a67d",
            "detail_level": "medium"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:55:12.000",
        "event": "mapping_unhover",
        "id": "yBFPoUgki9qbmJFQ0bvh"
    },
    {
        "data": {
            "before_detail_level": "medium",
            "after_detail_level": "high",
            "before_structured": "unstructured",
            "section_id": "7ffe7acb-50ac-4749-a589-5ab44e23a67d",
            "after_structured": "unstructured"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:55:13.000",
        "event": "change_summary_level",
        "id": "bIEjxa90cDSI4YCIM7Se"
    },
    {
        "data": {
            "mapping_index": 3,
            "structured_type": "unstructured",
            "section_id": "7ffe7acb-50ac-4749-a589-5ab44e23a67d",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:55:14.000",
        "event": "mapping_hover",
        "id": "1NrJrYyFelDepdM1DjOG"
    },
    {
        "data": {
            "structured_type": "unstructured",
            "section_id": "7ffe7acb-50ac-4749-a589-5ab44e23a67d",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:55:14.000",
        "event": "mapping_unhover",
        "id": "6uRPWWy4mCMfUJCjwYA5"
    },
    {
        "data": {
            "mapping_index": 1,
            "structured_type": "unstructured",
            "section_id": "7ffe7acb-50ac-4749-a589-5ab44e23a67d",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:55:14.000",
        "event": "mapping_hover",
        "id": "LKHklev9Sk3AgAu4d3GX"
    },
    {
        "data": {
            "structured_type": "unstructured",
            "section_id": "7ffe7acb-50ac-4749-a589-5ab44e23a67d",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:55:14.000",
        "event": "mapping_unhover",
        "id": "UTdkPVxUkTuhMjF04piW"
    },
    {
        "data": {
            "mapping_index": 0,
            "structured_type": "unstructured",
            "section_id": "7ffe7acb-50ac-4749-a589-5ab44e23a67d",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:55:14.000",
        "event": "mapping_hover",
        "id": "c1FA8OoPr2GZyyJ5OhMT"
    },
    {
        "data": {
            "structured_type": "unstructured",
            "section_id": "7ffe7acb-50ac-4749-a589-5ab44e23a67d",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:55:14.000",
        "event": "mapping_unhover",
        "id": "gYYtgIpqHuFfmCnVx6fj"
    },
    {
        "data": {
            "structured_type": "unstructured",
            "section_id": "7ffe7acb-50ac-4749-a589-5ab44e23a67d",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:55:14.000",
        "event": "mapping_unhover",
        "id": "kpSqL6mNvKDuQbjheeum"
    },
    {
        "data": {
            "mapping_index": 2,
            "structured_type": "unstructured",
            "section_id": "7ffe7acb-50ac-4749-a589-5ab44e23a67d",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:55:14.000",
        "event": "mapping_hover",
        "id": "lctigtuwFnItraDqmYIk"
    },
    {
        "data": {
            "mapping_index": 2,
            "structured_type": "unstructured",
            "section_id": "7ffe7acb-50ac-4749-a589-5ab44e23a67d",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:55:14.000",
        "event": "mapping_hover",
        "id": "nkJus0zah9257dUOUr0D"
    },
    {
        "data": {
            "structured_type": "unstructured",
            "section_id": "7ffe7acb-50ac-4749-a589-5ab44e23a67d",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:55:17.000",
        "event": "mapping_unhover",
        "id": "MWFlp4DJbWalvKbNJ6dU"
    },
    {
        "data": {
            "mapping_index": 1,
            "structured_type": "unstructured",
            "section_id": "7ffe7acb-50ac-4749-a589-5ab44e23a67d",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:55:17.000",
        "event": "mapping_hover",
        "id": "Zz3opUuOe8erieFcvUT9"
    },
    {
        "data": {
            "mapping_index": 0,
            "structured_type": "unstructured",
            "section_id": "7ffe7acb-50ac-4749-a589-5ab44e23a67d",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:55:17.000",
        "event": "mapping_hover",
        "id": "bSpj96ZFnivJActcx3y0"
    },
    {
        "data": {
            "structured_type": "unstructured",
            "section_id": "7ffe7acb-50ac-4749-a589-5ab44e23a67d",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:55:17.000",
        "event": "mapping_unhover",
        "id": "sJClosuFul0Nz4qSmtWL"
    },
    {
        "data": {
            "structured_type": "unstructured",
            "section_id": "7ffe7acb-50ac-4749-a589-5ab44e23a67d",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:55:20.000",
        "event": "mapping_unhover",
        "id": "BZWhY8DwatrO3ivnCmb3"
    },
    {
        "data": {
            "mapping_index": 1,
            "structured_type": "unstructured",
            "section_id": "7ffe7acb-50ac-4749-a589-5ab44e23a67d",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:55:20.000",
        "event": "mapping_hover",
        "id": "BmsgGaQKxTSEhRrDIiwF"
    },
    {
        "data": {
            "structured_type": "unstructured",
            "section_id": "7ffe7acb-50ac-4749-a589-5ab44e23a67d",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:55:21.000",
        "event": "mapping_unhover",
        "id": "56SEoAi8eZlYYo9iGarS"
    },
    {
        "data": {
            "structured_type": "unstructured",
            "section_id": "7ffe7acb-50ac-4749-a589-5ab44e23a67d",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:55:21.000",
        "event": "mapping_unhover",
        "id": "841rv89AGFXOA1tfalvx"
    },
    {
        "data": {
            "structured_type": "unstructured",
            "section_id": "7ffe7acb-50ac-4749-a589-5ab44e23a67d",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:55:21.000",
        "event": "mapping_unhover",
        "id": "9ZeiuhrYSVAmumuNWU4p"
    },
    {
        "data": {
            "mapping_index": 2,
            "structured_type": "unstructured",
            "section_id": "7ffe7acb-50ac-4749-a589-5ab44e23a67d",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:55:21.000",
        "event": "mapping_hover",
        "id": "BUMGYeiXTACCBC4I01w6"
    },
    {
        "data": {
            "mapping_index": 3,
            "structured_type": "unstructured",
            "section_id": "7ffe7acb-50ac-4749-a589-5ab44e23a67d",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:55:21.000",
        "event": "mapping_hover",
        "id": "wa5AvaavCjxKLpBR764A"
    },
    {
        "data": {
            "mapping_index": 3,
            "structured_type": "unstructured",
            "section_id": "7ffe7acb-50ac-4749-a589-5ab44e23a67d",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:55:22.000",
        "event": "mapping_hover",
        "id": "vnr9EqjQpfcmZ4psMN0p"
    },
    {
        "data": {
            "mapping_index": 1,
            "structured_type": "unstructured",
            "section_id": "7ffe7acb-50ac-4749-a589-5ab44e23a67d",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:55:23.000",
        "event": "mapping_hover",
        "id": "0VXj6H5KXyDBjyYWwEdt"
    },
    {
        "data": {
            "mapping_index": 4,
            "structured_type": "unstructured",
            "section_id": "7ffe7acb-50ac-4749-a589-5ab44e23a67d",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:55:23.000",
        "event": "mapping_hover",
        "id": "6hK7v026zalyTONe8OYz"
    },
    {
        "data": {
            "structured_type": "unstructured",
            "section_id": "7ffe7acb-50ac-4749-a589-5ab44e23a67d",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:55:23.000",
        "event": "mapping_unhover",
        "id": "7OWpkXwwY1BffYvaYwoJ"
    },
    {
        "data": {
            "structured_type": "unstructured",
            "section_id": "7ffe7acb-50ac-4749-a589-5ab44e23a67d",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:55:23.000",
        "event": "mapping_unhover",
        "id": "HIzSBCRuvPdo3Ythl8N6"
    },
    {
        "data": {
            "mapping_index": 2,
            "structured_type": "unstructured",
            "section_id": "7ffe7acb-50ac-4749-a589-5ab44e23a67d",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:55:23.000",
        "event": "mapping_hover",
        "id": "LUEOEzJRtOpiGYuz7aec"
    },
    {
        "data": {
            "structured_type": "unstructured",
            "section_id": "7ffe7acb-50ac-4749-a589-5ab44e23a67d",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:55:23.000",
        "event": "mapping_unhover",
        "id": "LeYk6K3hFMP1hpxTAfg1"
    },
    {
        "data": {
            "mapping_index": 0,
            "structured_type": "unstructured",
            "section_id": "7ffe7acb-50ac-4749-a589-5ab44e23a67d",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:55:23.000",
        "event": "mapping_hover",
        "id": "bHpthc9SrMDqvScAlli2"
    },
    {
        "data": {
            "structured_type": "unstructured",
            "section_id": "7ffe7acb-50ac-4749-a589-5ab44e23a67d",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:55:23.000",
        "event": "mapping_unhover",
        "id": "cOncrT8zzPFNqKfonDba"
    },
    {
        "data": {
            "structured_type": "unstructured",
            "section_id": "7ffe7acb-50ac-4749-a589-5ab44e23a67d",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:55:23.000",
        "event": "mapping_unhover",
        "id": "n7Ku6jxaJjxOhk3Am7we"
    },
    {
        "data": {
            "mapping_index": 3,
            "structured_type": "unstructured",
            "section_id": "7ffe7acb-50ac-4749-a589-5ab44e23a67d",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:55:23.000",
        "event": "mapping_hover",
        "id": "rG7FvmZfaEk1FJyU4r3s"
    },
    {
        "data": {
            "structured_type": "unstructured",
            "section_id": "7ffe7acb-50ac-4749-a589-5ab44e23a67d",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:55:23.000",
        "event": "mapping_unhover",
        "id": "y2MbXKzsaiObY3GROO3O"
    },
    {
        "data": {
            "structured_type": "unstructured",
            "section_id": "7ffe7acb-50ac-4749-a589-5ab44e23a67d",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:55:24.000",
        "event": "mapping_unhover",
        "id": "4nmVZk9sadPNZBfZ77T0"
    },
    {
        "data": {
            "structured_type": "unstructured",
            "section_id": "7ffe7acb-50ac-4749-a589-5ab44e23a67d",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:55:24.000",
        "event": "mapping_unhover",
        "id": "FgVdslY6OpBIO9qN9Ycp"
    },
    {
        "data": {
            "mapping_index": 0,
            "structured_type": "unstructured",
            "section_id": "7ffe7acb-50ac-4749-a589-5ab44e23a67d",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:55:24.000",
        "event": "mapping_hover",
        "id": "GgwIQHdeyDrsNm3jqDTM"
    },
    {
        "data": {
            "structured_type": "unstructured",
            "section_id": "7ffe7acb-50ac-4749-a589-5ab44e23a67d",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:55:24.000",
        "event": "mapping_unhover",
        "id": "HS6cGNq7tOUourCXfjYs"
    },
    {
        "data": {
            "mapping_index": 5,
            "structured_type": "unstructured",
            "section_id": "7ffe7acb-50ac-4749-a589-5ab44e23a67d",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:55:24.000",
        "event": "mapping_hover",
        "id": "HiKu2w12qiiaOqftvy1d"
    },
    {
        "data": {
            "mapping_index": 6,
            "structured_type": "unstructured",
            "section_id": "7ffe7acb-50ac-4749-a589-5ab44e23a67d",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:55:24.000",
        "event": "mapping_hover",
        "id": "HuN9c5Ij5x4dLOXLIrTp"
    },
    {
        "data": {
            "structured_type": "unstructured",
            "section_id": "7ffe7acb-50ac-4749-a589-5ab44e23a67d",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:55:24.000",
        "event": "mapping_unhover",
        "id": "K2oJKJ40rJe7mMZghwc1"
    },
    {
        "data": {
            "mapping_index": 5,
            "structured_type": "unstructured",
            "section_id": "7ffe7acb-50ac-4749-a589-5ab44e23a67d",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:55:24.000",
        "event": "mapping_hover",
        "id": "KBjEYXfxrZWGlGSQzDBJ"
    },
    {
        "data": {
            "structured_type": "unstructured",
            "section_id": "7ffe7acb-50ac-4749-a589-5ab44e23a67d",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:55:24.000",
        "event": "mapping_unhover",
        "id": "RWoxymjSloDqmQFVci6O"
    },
    {
        "data": {
            "mapping_index": 6,
            "structured_type": "unstructured",
            "section_id": "7ffe7acb-50ac-4749-a589-5ab44e23a67d",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:55:24.000",
        "event": "mapping_hover",
        "id": "ZpM75vYTsr8SMPeolnJf"
    },
    {
        "data": {
            "structured_type": "unstructured",
            "section_id": "7ffe7acb-50ac-4749-a589-5ab44e23a67d",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:55:24.000",
        "event": "mapping_unhover",
        "id": "bIgq9g3z9RvpKivf5kei"
    },
    {
        "data": {
            "mapping_index": 1,
            "structured_type": "unstructured",
            "section_id": "7ffe7acb-50ac-4749-a589-5ab44e23a67d",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:55:24.000",
        "event": "mapping_hover",
        "id": "dBRqUzZJZUSOSKVhEWfZ"
    },
    {
        "data": {
            "structured_type": "unstructured",
            "section_id": "7ffe7acb-50ac-4749-a589-5ab44e23a67d",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:55:24.000",
        "event": "mapping_unhover",
        "id": "fWNXrmVMluHW1jYlM2sh"
    },
    {
        "data": {
            "structured_type": "unstructured",
            "section_id": "7ffe7acb-50ac-4749-a589-5ab44e23a67d",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:55:24.000",
        "event": "mapping_unhover",
        "id": "iibKiMpEobYYNkM663Ou"
    },
    {
        "data": {
            "mapping_index": 4,
            "structured_type": "unstructured",
            "section_id": "7ffe7acb-50ac-4749-a589-5ab44e23a67d",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:55:24.000",
        "event": "mapping_hover",
        "id": "llKGWfDltCghVBQcwcOl"
    },
    {
        "data": {
            "mapping_index": 3,
            "structured_type": "unstructured",
            "section_id": "7ffe7acb-50ac-4749-a589-5ab44e23a67d",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:55:24.000",
        "event": "mapping_hover",
        "id": "qm4TsptELv0htVHXELGG"
    },
    {
        "data": {
            "mapping_index": 2,
            "structured_type": "unstructured",
            "section_id": "7ffe7acb-50ac-4749-a589-5ab44e23a67d",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:55:24.000",
        "event": "mapping_hover",
        "id": "vzDWC6JInl2noivaRKac"
    },
    {
        "data": {
            "structured_type": "unstructured",
            "section_id": "7ffe7acb-50ac-4749-a589-5ab44e23a67d",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:55:25.000",
        "event": "mapping_unhover",
        "id": "0NtvXodiPJsJAuj7sKZq"
    },
    {
        "data": {
            "mapping_index": 5,
            "structured_type": "unstructured",
            "section_id": "7ffe7acb-50ac-4749-a589-5ab44e23a67d",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:55:25.000",
        "event": "mapping_hover",
        "id": "3JenSTCF3QTqMiaB7gqi"
    },
    {
        "data": {
            "structured_type": "unstructured",
            "section_id": "7ffe7acb-50ac-4749-a589-5ab44e23a67d",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:55:25.000",
        "event": "mapping_unhover",
        "id": "FW4GCXy5WdOPcbEDvmMn"
    },
    {
        "data": {
            "mapping_index": 6,
            "structured_type": "unstructured",
            "section_id": "7ffe7acb-50ac-4749-a589-5ab44e23a67d",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:55:25.000",
        "event": "mapping_hover",
        "id": "Jf9dEyZHSQauYasaQr5r"
    },
    {
        "data": {
            "structured_type": "unstructured",
            "section_id": "7ffe7acb-50ac-4749-a589-5ab44e23a67d",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:55:25.000",
        "event": "mapping_unhover",
        "id": "wrwykaoQ7aO6CZF3qWN6"
    },
    {
        "data": {
            "mapping_index": 5,
            "structured_type": "unstructured",
            "section_id": "7ffe7acb-50ac-4749-a589-5ab44e23a67d",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:55:26.000",
        "event": "mapping_hover",
        "id": "AgH0uNVBRD8PoA7irwoH"
    },
    {
        "data": {
            "structured_type": "unstructured",
            "section_id": "7ffe7acb-50ac-4749-a589-5ab44e23a67d",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:55:26.000",
        "event": "mapping_unhover",
        "id": "M6DfPRYfGrgrgzBFhuOh"
    },
    {
        "data": {
            "mapping_index": 6,
            "structured_type": "unstructured",
            "section_id": "7ffe7acb-50ac-4749-a589-5ab44e23a67d",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:55:26.000",
        "event": "mapping_hover",
        "id": "M9MdlOhuYLO75VP8iUhi"
    },
    {
        "data": {
            "structured_type": "unstructured",
            "section_id": "7ffe7acb-50ac-4749-a589-5ab44e23a67d",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:55:26.000",
        "event": "mapping_unhover",
        "id": "Sqd1O1nK7tV4uMHgP6AU"
    },
    {
        "data": {
            "mapping_index": 6,
            "structured_type": "unstructured",
            "section_id": "7ffe7acb-50ac-4749-a589-5ab44e23a67d",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:55:26.000",
        "event": "mapping_hover",
        "id": "xbAiHHHNVwyJSeGIW70f"
    },
    {
        "data": {
            "structured_type": "unstructured",
            "section_id": "7ffe7acb-50ac-4749-a589-5ab44e23a67d",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:55:27.000",
        "event": "mapping_unhover",
        "id": "2MMdRjqdUqiGKutGht0M"
    },
    {
        "data": {
            "mapping_index": 5,
            "structured_type": "unstructured",
            "section_id": "7ffe7acb-50ac-4749-a589-5ab44e23a67d",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:55:27.000",
        "event": "mapping_hover",
        "id": "9ns6xF5N7cXdjEkuR5uz"
    },
    {
        "data": {
            "structured_type": "unstructured",
            "section_id": "7ffe7acb-50ac-4749-a589-5ab44e23a67d",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:55:27.000",
        "event": "mapping_unhover",
        "id": "KDWRXWrfdV6BAZ2EYB9V"
    },
    {
        "data": {
            "mapping_index": 5,
            "structured_type": "unstructured",
            "section_id": "7ffe7acb-50ac-4749-a589-5ab44e23a67d",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:55:27.000",
        "event": "mapping_hover",
        "id": "UpoHfkEn2hoA3ez8IXmM"
    },
    {
        "data": {
            "structured_type": "unstructured",
            "section_id": "7ffe7acb-50ac-4749-a589-5ab44e23a67d",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:55:27.000",
        "event": "mapping_unhover",
        "id": "dxf1VxKSYVkrX88AMLEV"
    },
    {
        "data": {
            "mapping_index": 4,
            "structured_type": "unstructured",
            "section_id": "7ffe7acb-50ac-4749-a589-5ab44e23a67d",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:55:27.000",
        "event": "mapping_hover",
        "id": "esJ8i8RDtgKXSkqaShGb"
    },
    {
        "data": {
            "mapping_index": 4,
            "structured_type": "unstructured",
            "section_id": "7ffe7acb-50ac-4749-a589-5ab44e23a67d",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:55:27.000",
        "event": "mapping_hover",
        "id": "hPw2Fi3OyikdK3BmdwVW"
    },
    {
        "data": {
            "structured_type": "unstructured",
            "section_id": "7ffe7acb-50ac-4749-a589-5ab44e23a67d",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:55:27.000",
        "event": "mapping_unhover",
        "id": "j7P6AQPJXkuzrRTGuPnd"
    },
    {
        "data": {
            "mapping_index": 3,
            "structured_type": "unstructured",
            "section_id": "7ffe7acb-50ac-4749-a589-5ab44e23a67d",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:55:27.000",
        "event": "mapping_hover",
        "id": "kImsPO1NQtk8UuIW5NSU"
    },
    {
        "data": {
            "structured_type": "unstructured",
            "section_id": "7ffe7acb-50ac-4749-a589-5ab44e23a67d",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:55:27.000",
        "event": "mapping_unhover",
        "id": "vb7LBRNytraW2AJ0x0IV"
    },
    {
        "data": {
            "structured_type": "unstructured",
            "section_id": "7ffe7acb-50ac-4749-a589-5ab44e23a67d",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:55:28.000",
        "event": "mapping_unhover",
        "id": "Q28ZTuUbI1CQzhCefGax"
    },
    {
        "data": {
            "mapping_index": 2,
            "structured_type": "unstructured",
            "section_id": "7ffe7acb-50ac-4749-a589-5ab44e23a67d",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:55:28.000",
        "event": "mapping_hover",
        "id": "yr3ii9hESz08Pnh4f8sI"
    },
    {
        "data": {
            "structured_type": "unstructured",
            "section_id": "7ffe7acb-50ac-4749-a589-5ab44e23a67d",
            "detail_level": "high"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:55:28.000",
        "event": "mapping_unhover",
        "id": "zbytenvlTP7VPoZO4Gp7"
    },
    {
        "data": {
            "before_detail_level": "medium",
            "after_detail_level": "low",
            "before_structured": "unstructured",
            "section_id": "7ffe7acb-50ac-4749-a589-5ab44e23a67d",
            "after_structured": "unstructured"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:55:31.000",
        "event": "change_summary_level",
        "id": "3agNKwOQDCiPHGrXMigI"
    },
    {
        "data": {
            "before_detail_level": "high",
            "after_detail_level": "medium",
            "before_structured": "unstructured",
            "section_id": "7ffe7acb-50ac-4749-a589-5ab44e23a67d",
            "after_structured": "unstructured"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:55:31.000",
        "event": "change_summary_level",
        "id": "a2lWtSpRFOWCcJL3FTR0"
    },
    {
        "data": {
            "mapping_index": 0,
            "structured_type": "unstructured",
            "section_id": "7ffe7acb-50ac-4749-a589-5ab44e23a67d",
            "detail_level": "low"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:55:32.000",
        "event": "mapping_hover",
        "id": "KyeP5k5NLQsyNJNa90uo"
    },
    {
        "data": {
            "mapping_index": 1,
            "structured_type": "unstructured",
            "section_id": "7ffe7acb-50ac-4749-a589-5ab44e23a67d",
            "detail_level": "low"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:55:32.000",
        "event": "mapping_hover",
        "id": "qT77AtBULC9Lmur865M3"
    },
    {
        "data": {
            "structured_type": "unstructured",
            "section_id": "7ffe7acb-50ac-4749-a589-5ab44e23a67d",
            "detail_level": "low"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:55:32.000",
        "event": "mapping_unhover",
        "id": "yc1jZEfk8nSS8LyGxRNZ"
    },
    {
        "data": {
            "mapping_index": 1,
            "structured_type": "unstructured",
            "section_id": "7ffe7acb-50ac-4749-a589-5ab44e23a67d",
            "detail_level": "low"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:55:33.000",
        "event": "mapping_hover",
        "id": "0v3HJbeDbPNjb53yKI9R"
    },
    {
        "data": {
            "structured_type": "unstructured",
            "section_id": "7ffe7acb-50ac-4749-a589-5ab44e23a67d",
            "detail_level": "low"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:55:33.000",
        "event": "mapping_unhover",
        "id": "AZbMub1dAhjS9eaG7qDO"
    },
    {
        "data": {
            "structured_type": "unstructured",
            "section_id": "7ffe7acb-50ac-4749-a589-5ab44e23a67d",
            "detail_level": "low"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:55:34.000",
        "event": "mapping_unhover",
        "id": "pIXbskEhm2V8vngIEQvh"
    },
    {
        "data": {
            "structured_type": "unstructured",
            "section_id": "7ffe7acb-50ac-4749-a589-5ab44e23a67d",
            "detail_level": "low"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:55:37.000",
        "event": "mapping_unhover",
        "id": "HkJJvp7U4AgjQRywSWov"
    },
    {
        "data": {
            "mapping_index": 0,
            "structured_type": "unstructured",
            "section_id": "7ffe7acb-50ac-4749-a589-5ab44e23a67d",
            "detail_level": "low"
        },
        "source": "frontend",
        "timestamp": "2025-08-23 10:55:37.000",
        "event": "mapping_hover",
        "id": "WsiMiTBdGracOgUs42MT"
    }
]