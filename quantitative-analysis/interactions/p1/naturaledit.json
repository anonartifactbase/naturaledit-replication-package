[
    {
        "source": "frontend",
        "event": "click_summarize_code",
        "data": {},
        "timestamp": "2025-08-16 22:49:05.000",
        "id": "MRGR4deCIV9B8VxoJnha"
    },
    {
        "source": "backend",
        "event": "summarize_selected_code",
        "data": {
            "selected_code": "def scrape_season_stats(year):\n    base_url_reg = (\n        f\"https://www.basketball-reference.com/leagues/NBA_{year}_per_game.html\"\n    )\n    df_reg = pd.read_html(base_url_reg, header=0)[0]\n    df_reg = df_reg[df_reg[\"Player\"] != \"Player\"]  # remove repeated header rows\n    df_reg[\"Year\"] = year\n\n    df_reg = df_reg[\n        [\"Player\", \"Year\", \"PTS\", \"AST\", \"TRB\", \"FG%\"]\n    ]  # Keep only specified columns\n    df_reg = df_reg.dropna(\n        subset=[\"PTS\", \"AST\", \"TRB\", \"FG%\"]\n    )  # Ensure key stats aren't invalid\n    return df_reg",
            "summary": {
                "low_structured": "• Fetches NBA per-game stats for a specified year\n• Cleans and filters the data\n• Returns selected player statistics",
                "high_unstructured": "The scrape_season_stats function fetches NBA per-game statistics for a specified year from the Basketball Reference website using pandas' read_html. It processes the resulting DataFrame by removing any repeated header rows, adds a 'Year' column, and selects only the columns for player name, year, points, assists, rebounds, and field goal percentage. The function further cleans the data by dropping any rows where these key statistics are missing, ensuring only valid player data is included. Finally, it returns the cleaned DataFrame containing the relevant stats for all players in that season.",
                "medium_unstructured": "The scrape_season_stats function downloads NBA per-game statistics for a given year from Basketball Reference. It cleans the data by removing repeated header rows and keeps only relevant columns like player name, year, points, assists, rebounds, and field goal percentage. The function also ensures that rows with missing key stats are excluded before returning the final DataFrame.",
                "high_structured": "• Constructs the URL for NBA per-game stats for the given year\n• Reads the first table from the webpage using pandas' read_html\n• Cleans the DataFrame:\n  ◦ Removes rows where the 'Player' column is equal to 'Player' (repeated header rows)\n  ◦ Adds a 'Year' column with the specified year\n• Selects only the relevant columns:\n  ◦ 'Player', 'Year', 'PTS', 'AST', 'TRB', 'FG%'\n• Drops rows with missing values in any of the key stat columns\n• Returns the resulting DataFrame with cleaned and filtered player statistics for that year",
                "title": "Summary of scrape_season_stats Function",
                "low_unstructured": "This function retrieves and processes NBA per-game player statistics for a given year.",
                "medium_structured": "• Downloads NBA per-game stats for a specified year from Basketball Reference\n• Cleans the DataFrame:\n  ◦ Removes repeated header rows\n  ◦ Adds the year column\n• Selects only key columns: Player, Year, PTS, AST, TRB, FG%\n• Drops rows with missing values in the key stats\n• Returns the cleaned DataFrame"
            }
        },
        "timestamp": "2025-08-16 22:49:11.000",
        "id": "YstS0TxQqOJ2t2hEce33"
    },
    {
        "source": "backend",
        "event": "map_summary_code",
        "data": {
            "summary": "• Fetches NBA per-game stats for a specified year\n• Cleans and filters the data\n• Returns selected player statistics",
            "mapping": [
                {
                    "summaryComponent": "Fetches NBA per-game stats for a specified year",
                    "codeSegments": [
                        {
                            "line": 22,
                            "code": "def scrape_season_stats(year):"
                        },
                        {
                            "line": 23,
                            "code": "base_url_reg = ("
                        },
                        {
                            "line": 24,
                            "code": "f\"https://www.basketball-reference.com/leagues/NBA_{year}_per_game.html\""
                        },
                        {
                            "line": 26,
                            "code": "df_reg = pd.read_html(base_url_reg, header=0)[0]"
                        }
                    ]
                },
                {
                    "summaryComponent": "Cleans and filters the data",
                    "codeSegments": [
                        {
                            "line": 27,
                            "code": "df_reg = df_reg[df_reg[\"Player\"] != \"Player\"]  # remove repeated header rows"
                        },
                        {
                            "line": 28,
                            "code": "df_reg[\"Year\"] = year"
                        },
                        {
                            "line": 30,
                            "code": "df_reg = df_reg["
                        },
                        {
                            "line": 31,
                            "code": "[\"Player\", \"Year\", \"PTS\", \"AST\", \"TRB\", \"FG%\"]"
                        },
                        {
                            "line": 33,
                            "code": "df_reg = df_reg.dropna("
                        },
                        {
                            "line": 34,
                            "code": "subset=[\"PTS\", \"AST\", \"TRB\", \"FG%\"]"
                        }
                    ]
                },
                {
                    "summaryComponent": "Returns selected player statistics",
                    "codeSegments": [
                        {
                            "line": 36,
                            "code": "return df_reg"
                        }
                    ]
                }
            ],
            "code": "22: def scrape_season_stats(year):\n23:     base_url_reg = (\n24:         f\"https://www.basketball-reference.com/leagues/NBA_{year}_per_game.html\"\n25:     )\n26:     df_reg = pd.read_html(base_url_reg, header=0)[0]\n27:     df_reg = df_reg[df_reg[\"Player\"] != \"Player\"]  # remove repeated header rows\n28:     df_reg[\"Year\"] = year\n29: \n30:     df_reg = df_reg[\n31:         [\"Player\", \"Year\", \"PTS\", \"AST\", \"TRB\", \"FG%\"]\n32:     ]  # Keep only specified columns\n33:     df_reg = df_reg.dropna(\n34:         subset=[\"PTS\", \"AST\", \"TRB\", \"FG%\"]\n35:     )  # Ensure key stats aren't invalid\n36:     return df_reg"
        },
        "timestamp": "2025-08-16 22:49:13.000",
        "id": "9WO7QLD3hT3F1uyO3ODs"
    },
    {
        "source": "backend",
        "event": "map_summary_code",
        "data": {
            "summary": "This function retrieves and processes NBA per-game player statistics for a given year.",
            "mapping": [
                {
                    "summaryComponent": "This function",
                    "codeSegments": [
                        {
                            "line": 22,
                            "code": "def scrape_season_stats(year):"
                        }
                    ]
                },
                {
                    "summaryComponent": "retrieves",
                    "codeSegments": [
                        {
                            "line": 26,
                            "code": "df_reg = pd.read_html(base_url_reg, header=0)[0]"
                        }
                    ]
                },
                {
                    "summaryComponent": "and processes",
                    "codeSegments": [
                        {
                            "line": 27,
                            "code": "df_reg = df_reg[df_reg[\"Player\"] != \"Player\"]  # remove repeated header rows"
                        },
                        {
                            "line": 28,
                            "code": "df_reg[\"Year\"] = year"
                        },
                        {
                            "line": 30,
                            "code": "df_reg = df_reg[\n    [\"Player\", \"Year\", \"PTS\", \"AST\", \"TRB\", \"FG%\"]\n]"
                        },
                        {
                            "line": 33,
                            "code": "df_reg = df_reg.dropna(\n    subset=[\"PTS\", \"AST\", \"TRB\", \"FG%\"]\n)"
                        }
                    ]
                },
                {
                    "summaryComponent": "NBA per-game player statistics",
                    "codeSegments": [
                        {
                            "line": 24,
                            "code": "f\"https://www.basketball-reference.com/leagues/NBA_{year}_per_game.html\""
                        }
                    ]
                },
                {
                    "summaryComponent": "for a given year",
                    "codeSegments": [
                        {
                            "line": 22,
                            "code": "def scrape_season_stats(year):"
                        },
                        {
                            "line": 24,
                            "code": "f\"https://www.basketball-reference.com/leagues/NBA_{year}_per_game.html\""
                        },
                        {
                            "line": 28,
                            "code": "df_reg[\"Year\"] = year"
                        }
                    ]
                }
            ],
            "code": "22: def scrape_season_stats(year):\n23:     base_url_reg = (\n24:         f\"https://www.basketball-reference.com/leagues/NBA_{year}_per_game.html\"\n25:     )\n26:     df_reg = pd.read_html(base_url_reg, header=0)[0]\n27:     df_reg = df_reg[df_reg[\"Player\"] != \"Player\"]  # remove repeated header rows\n28:     df_reg[\"Year\"] = year\n29: \n30:     df_reg = df_reg[\n31:         [\"Player\", \"Year\", \"PTS\", \"AST\", \"TRB\", \"FG%\"]\n32:     ]  # Keep only specified columns\n33:     df_reg = df_reg.dropna(\n34:         subset=[\"PTS\", \"AST\", \"TRB\", \"FG%\"]\n35:     )  # Ensure key stats aren't invalid\n36:     return df_reg"
        },
        "timestamp": "2025-08-16 22:49:13.000",
        "id": "m6eDBXJMRRXWSeI9j27U"
    },
    {
        "source": "backend",
        "event": "map_summary_code",
        "data": {
            "summary": "The scrape_season_stats function downloads NBA per-game statistics for a given year from Basketball Reference. It cleans the data by removing repeated header rows and keeps only relevant columns like player name, year, points, assists, rebounds, and field goal percentage. The function also ensures that rows with missing key stats are excluded before returning the final DataFrame.",
            "mapping": [
                {
                    "summaryComponent": "The scrape_season_stats function",
                    "codeSegments": [
                        {
                            "line": 22,
                            "code": "def scrape_season_stats(year):"
                        }
                    ]
                },
                {
                    "summaryComponent": "downloads NBA per-game statistics for a given year from Basketball Reference",
                    "codeSegments": [
                        {
                            "line": 24,
                            "code": "f\"https://www.basketball-reference.com/leagues/NBA_{year}_per_game.html\""
                        },
                        {
                            "line": 26,
                            "code": "df_reg = pd.read_html(base_url_reg, header=0)[0]"
                        }
                    ]
                },
                {
                    "summaryComponent": "It cleans the data by removing repeated header rows",
                    "codeSegments": [
                        {
                            "line": 27,
                            "code": "df_reg = df_reg[df_reg[\"Player\"] != \"Player\"]  # remove repeated header rows"
                        }
                    ]
                },
                {
                    "summaryComponent": "keeps only relevant columns like player name, year, points, assists, rebounds, and field goal percentage",
                    "codeSegments": [
                        {
                            "line": 30,
                            "code": "df_reg = df_reg["
                        },
                        {
                            "line": 31,
                            "code": "[\"Player\", \"Year\", \"PTS\", \"AST\", \"TRB\", \"FG%\"]"
                        }
                    ]
                },
                {
                    "summaryComponent": "The function also ensures that rows with missing key stats are excluded",
                    "codeSegments": [
                        {
                            "line": 33,
                            "code": "df_reg = df_reg.dropna("
                        },
                        {
                            "line": 34,
                            "code": "subset=[\"PTS\", \"AST\", \"TRB\", \"FG%\"]"
                        }
                    ]
                },
                {
                    "summaryComponent": "before returning the final DataFrame",
                    "codeSegments": [
                        {
                            "line": 36,
                            "code": "return df_reg"
                        }
                    ]
                }
            ],
            "code": "22: def scrape_season_stats(year):\n23:     base_url_reg = (\n24:         f\"https://www.basketball-reference.com/leagues/NBA_{year}_per_game.html\"\n25:     )\n26:     df_reg = pd.read_html(base_url_reg, header=0)[0]\n27:     df_reg = df_reg[df_reg[\"Player\"] != \"Player\"]  # remove repeated header rows\n28:     df_reg[\"Year\"] = year\n29: \n30:     df_reg = df_reg[\n31:         [\"Player\", \"Year\", \"PTS\", \"AST\", \"TRB\", \"FG%\"]\n32:     ]  # Keep only specified columns\n33:     df_reg = df_reg.dropna(\n34:         subset=[\"PTS\", \"AST\", \"TRB\", \"FG%\"]\n35:     )  # Ensure key stats aren't invalid\n36:     return df_reg"
        },
        "timestamp": "2025-08-16 22:49:14.000",
        "id": "07HNKvKcbv8RTA1iOKke"
    },
    {
        "source": "backend",
        "event": "map_summary_code",
        "data": {
            "summary": "• Constructs the URL for NBA per-game stats for the given year\n• Reads the first table from the webpage using pandas' read_html\n• Cleans the DataFrame:\n  ◦ Removes rows where the 'Player' column is equal to 'Player' (repeated header rows)\n  ◦ Adds a 'Year' column with the specified year\n• Selects only the relevant columns:\n  ◦ 'Player', 'Year', 'PTS', 'AST', 'TRB', 'FG%'\n• Drops rows with missing values in any of the key stat columns\n• Returns the resulting DataFrame with cleaned and filtered player statistics for that year",
            "mapping": [
                {
                    "summaryComponent": "Constructs the URL for NBA per-game stats for the given year",
                    "codeSegments": [
                        {
                            "line": 23,
                            "code": "base_url_reg = (\n    f\"https://www.basketball-reference.com/leagues/NBA_{year}_per_game.html\"\n)"
                        }
                    ]
                },
                {
                    "summaryComponent": "Reads the first table from the webpage using pandas' read_html",
                    "codeSegments": [
                        {
                            "line": 26,
                            "code": "df_reg = pd.read_html(base_url_reg, header=0)[0]"
                        }
                    ]
                },
                {
                    "summaryComponent": "Removes rows where the 'Player' column is equal to 'Player' (repeated header rows)",
                    "codeSegments": [
                        {
                            "line": 27,
                            "code": "df_reg = df_reg[df_reg[\"Player\"] != \"Player\"]  # remove repeated header rows"
                        }
                    ]
                },
                {
                    "summaryComponent": "Adds a 'Year' column with the specified year",
                    "codeSegments": [
                        {
                            "line": 28,
                            "code": "df_reg[\"Year\"] = year"
                        }
                    ]
                },
                {
                    "summaryComponent": "Selects only the relevant columns:",
                    "codeSegments": [
                        {
                            "line": 30,
                            "code": "df_reg = df_reg[\n    [\"Player\", \"Year\", \"PTS\", \"AST\", \"TRB\", \"FG%\"]\n]"
                        }
                    ]
                },
                {
                    "summaryComponent": "'Player', 'Year', 'PTS', 'AST', 'TRB', 'FG%'",
                    "codeSegments": [
                        {
                            "line": 31,
                            "code": "[\"Player\", \"Year\", \"PTS\", \"AST\", \"TRB\", \"FG%\"]"
                        }
                    ]
                },
                {
                    "summaryComponent": "Drops rows with missing values in any of the key stat columns",
                    "codeSegments": [
                        {
                            "line": 33,
                            "code": "df_reg = df_reg.dropna(\n    subset=[\"PTS\", \"AST\", \"TRB\", \"FG%\"]\n)"
                        }
                    ]
                },
                {
                    "summaryComponent": "Returns the resulting DataFrame with cleaned and filtered player statistics for that year",
                    "codeSegments": [
                        {
                            "line": 36,
                            "code": "return df_reg"
                        }
                    ]
                }
            ],
            "code": "22: def scrape_season_stats(year):\n23:     base_url_reg = (\n24:         f\"https://www.basketball-reference.com/leagues/NBA_{year}_per_game.html\"\n25:     )\n26:     df_reg = pd.read_html(base_url_reg, header=0)[0]\n27:     df_reg = df_reg[df_reg[\"Player\"] != \"Player\"]  # remove repeated header rows\n28:     df_reg[\"Year\"] = year\n29: \n30:     df_reg = df_reg[\n31:         [\"Player\", \"Year\", \"PTS\", \"AST\", \"TRB\", \"FG%\"]\n32:     ]  # Keep only specified columns\n33:     df_reg = df_reg.dropna(\n34:         subset=[\"PTS\", \"AST\", \"TRB\", \"FG%\"]\n35:     )  # Ensure key stats aren't invalid\n36:     return df_reg"
        },
        "timestamp": "2025-08-16 22:49:14.000",
        "id": "CgmJvenTTtVCPgCDY98q"
    },
    {
        "source": "frontend",
        "event": "autotransit_section",
        "data": {
            "before_section_id": null,
            "after_section_id": "94e232d8-8f75-4045-a81c-fb03a7b3aacc"
        },
        "timestamp": "2025-08-16 22:49:14.000",
        "id": "GN6QdAOrUknup68408HU"
    },
    {
        "source": "backend",
        "event": "map_summary_code",
        "data": {
            "summary": "The scrape_season_stats function fetches NBA per-game statistics for a specified year from the Basketball Reference website using pandas' read_html. It processes the resulting DataFrame by removing any repeated header rows, adds a 'Year' column, and selects only the columns for player name, year, points, assists, rebounds, and field goal percentage. The function further cleans the data by dropping any rows where these key statistics are missing, ensuring only valid player data is included. Finally, it returns the cleaned DataFrame containing the relevant stats for all players in that season.",
            "mapping": [
                {
                    "summaryComponent": "The scrape_season_stats function",
                    "codeSegments": [
                        {
                            "line": 22,
                            "code": "def scrape_season_stats(year):"
                        }
                    ]
                },
                {
                    "summaryComponent": "fetches NBA per-game statistics for a specified year from the Basketball Reference website",
                    "codeSegments": [
                        {
                            "line": 23,
                            "code": "base_url_reg = ("
                        },
                        {
                            "line": 24,
                            "code": "f\"https://www.basketball-reference.com/leagues/NBA_{year}_per_game.html\""
                        },
                        {
                            "line": 26,
                            "code": "df_reg = pd.read_html(base_url_reg, header=0)[0]"
                        }
                    ]
                },
                {
                    "summaryComponent": "using pandas' read_html",
                    "codeSegments": [
                        {
                            "line": 26,
                            "code": "pd.read_html(base_url_reg, header=0)[0]"
                        }
                    ]
                },
                {
                    "summaryComponent": "removing any repeated header rows",
                    "codeSegments": [
                        {
                            "line": 27,
                            "code": "df_reg = df_reg[df_reg[\"Player\"] != \"Player\"]  # remove repeated header rows"
                        }
                    ]
                },
                {
                    "summaryComponent": "adds a 'Year' column",
                    "codeSegments": [
                        {
                            "line": 28,
                            "code": "df_reg[\"Year\"] = year"
                        }
                    ]
                },
                {
                    "summaryComponent": "selects only the columns for player name, year, points, assists, rebounds, and field goal percentage",
                    "codeSegments": [
                        {
                            "line": 30,
                            "code": "df_reg = df_reg["
                        },
                        {
                            "line": 31,
                            "code": "[\"Player\", \"Year\", \"PTS\", \"AST\", \"TRB\", \"FG%\"]"
                        }
                    ]
                },
                {
                    "summaryComponent": "dropping any rows where these key statistics are missing",
                    "codeSegments": [
                        {
                            "line": 33,
                            "code": "df_reg = df_reg.dropna("
                        },
                        {
                            "line": 34,
                            "code": "subset=[\"PTS\", \"AST\", \"TRB\", \"FG%\"]"
                        }
                    ]
                },
                {
                    "summaryComponent": "ensuring only valid player data is included",
                    "codeSegments": [
                        {
                            "line": 35,
                            "code": "# Ensure key stats aren't invalid"
                        }
                    ]
                },
                {
                    "summaryComponent": "returns the cleaned DataFrame containing the relevant stats for all players in that season",
                    "codeSegments": [
                        {
                            "line": 36,
                            "code": "return df_reg"
                        }
                    ]
                }
            ],
            "code": "22: def scrape_season_stats(year):\n23:     base_url_reg = (\n24:         f\"https://www.basketball-reference.com/leagues/NBA_{year}_per_game.html\"\n25:     )\n26:     df_reg = pd.read_html(base_url_reg, header=0)[0]\n27:     df_reg = df_reg[df_reg[\"Player\"] != \"Player\"]  # remove repeated header rows\n28:     df_reg[\"Year\"] = year\n29: \n30:     df_reg = df_reg[\n31:         [\"Player\", \"Year\", \"PTS\", \"AST\", \"TRB\", \"FG%\"]\n32:     ]  # Keep only specified columns\n33:     df_reg = df_reg.dropna(\n34:         subset=[\"PTS\", \"AST\", \"TRB\", \"FG%\"]\n35:     )  # Ensure key stats aren't invalid\n36:     return df_reg"
        },
        "timestamp": "2025-08-16 22:49:14.000",
        "id": "ONj41UXsCzXc042g06yP"
    },
    {
        "source": "backend",
        "event": "map_summary_code",
        "data": {
            "summary": "• Downloads NBA per-game stats for a specified year from Basketball Reference\n• Cleans the DataFrame:\n  ◦ Removes repeated header rows\n  ◦ Adds the year column\n• Selects only key columns: Player, Year, PTS, AST, TRB, FG%\n• Drops rows with missing values in the key stats\n• Returns the cleaned DataFrame",
            "mapping": [
                {
                    "summaryComponent": "Downloads NBA per-game stats for a specified year from Basketball Reference",
                    "codeSegments": [
                        {
                            "line": 23,
                            "code": "base_url_reg = (\n    f\"https://www.basketball-reference.com/leagues/NBA_{year}_per_game.html\"\n)"
                        },
                        {
                            "line": 26,
                            "code": "df_reg = pd.read_html(base_url_reg, header=0)[0]"
                        }
                    ]
                },
                {
                    "summaryComponent": "Cleans the DataFrame:",
                    "codeSegments": [
                        {
                            "line": 27,
                            "code": "# remove repeated header rows"
                        },
                        {
                            "line": 28,
                            "code": "df_reg[\"Year\"] = year"
                        }
                    ]
                },
                {
                    "summaryComponent": "Removes repeated header rows",
                    "codeSegments": [
                        {
                            "line": 27,
                            "code": "df_reg = df_reg[df_reg[\"Player\"] != \"Player\"]  # remove repeated header rows"
                        }
                    ]
                },
                {
                    "summaryComponent": "Adds the year column",
                    "codeSegments": [
                        {
                            "line": 28,
                            "code": "df_reg[\"Year\"] = year"
                        }
                    ]
                },
                {
                    "summaryComponent": "Selects only key columns: Player, Year, PTS, AST, TRB, FG%",
                    "codeSegments": [
                        {
                            "line": 30,
                            "code": "df_reg = df_reg[\n    [\"Player\", \"Year\", \"PTS\", \"AST\", \"TRB\", \"FG%\"]\n]"
                        }
                    ]
                },
                {
                    "summaryComponent": "Drops rows with missing values in the key stats",
                    "codeSegments": [
                        {
                            "line": 33,
                            "code": "df_reg = df_reg.dropna(\n    subset=[\"PTS\", \"AST\", \"TRB\", \"FG%\"]\n)"
                        }
                    ]
                },
                {
                    "summaryComponent": "Returns the cleaned DataFrame",
                    "codeSegments": [
                        {
                            "line": 36,
                            "code": "return df_reg"
                        }
                    ]
                }
            ],
            "code": "22: def scrape_season_stats(year):\n23:     base_url_reg = (\n24:         f\"https://www.basketball-reference.com/leagues/NBA_{year}_per_game.html\"\n25:     )\n26:     df_reg = pd.read_html(base_url_reg, header=0)[0]\n27:     df_reg = df_reg[df_reg[\"Player\"] != \"Player\"]  # remove repeated header rows\n28:     df_reg[\"Year\"] = year\n29: \n30:     df_reg = df_reg[\n31:         [\"Player\", \"Year\", \"PTS\", \"AST\", \"TRB\", \"FG%\"]\n32:     ]  # Keep only specified columns\n33:     df_reg = df_reg.dropna(\n34:         subset=[\"PTS\", \"AST\", \"TRB\", \"FG%\"]\n35:     )  # Ensure key stats aren't invalid\n36:     return df_reg"
        },
        "timestamp": "2025-08-16 22:49:14.000",
        "id": "Shb1EkAGhYsZHaHa3Ftj"
    },
    {
        "source": "frontend",
        "event": "create_new_section",
        "data": {
            "section_id": "94e232d8-8f75-4045-a81c-fb03a7b3aacc",
            "section_data": {
                "editPromptDetailLevel": null,
                "selectedStructured": "unstructured",
                "createdAt": 1755370154000,
                "lines": [
                    22,
                    36
                ],
                "editPromptStructured": null,
                "summaryData": {
                    "low_structured": "• Fetches NBA per-game stats for a specified year\n• Cleans and filters the data\n• Returns selected player statistics",
                    "high_unstructured": "The scrape_season_stats function fetches NBA per-game statistics for a specified year from the Basketball Reference website using pandas' read_html. It processes the resulting DataFrame by removing any repeated header rows, adds a 'Year' column, and selects only the columns for player name, year, points, assists, rebounds, and field goal percentage. The function further cleans the data by dropping any rows where these key statistics are missing, ensuring only valid player data is included. Finally, it returns the cleaned DataFrame containing the relevant stats for all players in that season.",
                    "medium_unstructured": "The scrape_season_stats function downloads NBA per-game statistics for a given year from Basketball Reference. It cleans the data by removing repeated header rows and keeps only relevant columns like player name, year, points, assists, rebounds, and field goal percentage. The function also ensures that rows with missing key stats are excluded before returning the final DataFrame.",
                    "high_structured": "• Constructs the URL for NBA per-game stats for the given year\n• Reads the first table from the webpage using pandas' read_html\n• Cleans the DataFrame:\n  ◦ Removes rows where the 'Player' column is equal to 'Player' (repeated header rows)\n  ◦ Adds a 'Year' column with the specified year\n• Selects only the relevant columns:\n  ◦ 'Player', 'Year', 'PTS', 'AST', 'TRB', 'FG%'\n• Drops rows with missing values in any of the key stat columns\n• Returns the resulting DataFrame with cleaned and filtered player statistics for that year",
                    "title": "Summary of scrape_season_stats Function",
                    "low_unstructured": "This function retrieves and processes NBA per-game player statistics for a given year.",
                    "medium_structured": "• Downloads NBA per-game stats for a specified year from Basketball Reference\n• Cleans the DataFrame:\n  ◦ Removes repeated header rows\n  ◦ Adds the year column\n• Selects only key columns: Player, Year, PTS, AST, TRB, FG%\n• Drops rows with missing values in the key stats\n• Returns the cleaned DataFrame"
                },
                "selectedDetailLevel": "medium",
                "metadata": {
                    "originalCode": "def scrape_season_stats(year):\n    base_url_reg = (\n        f\"https://www.basketball-reference.com/leagues/NBA_{year}_per_game.html\"\n    )\n    df_reg = pd.read_html(base_url_reg, header=0)[0]\n    df_reg = df_reg[df_reg[\"Player\"] != \"Player\"]  # remove repeated header rows\n    df_reg[\"Year\"] = year\n\n    df_reg = df_reg[\n        [\"Player\", \"Year\", \"PTS\", \"AST\", \"TRB\", \"FG%\"]\n    ]  # Keep only specified columns\n    df_reg = df_reg.dropna(\n        subset=[\"PTS\", \"AST\", \"TRB\", \"FG%\"]\n    )  # Ensure key stats aren't invalid\n    return df_reg",
                    "fullPath": "/project/workspace/scraper.py",
                    "id": "94e232d8-8f75-4045-a81c-fb03a7b3aacc",
                    "offset": 652,
                    "filename": "scraper.py"
                },
                "editPromptValue": "",
                "title": "Summary of scrape_season_stats Function",
                "summaryMappings": {
                    "high_unstructured": [
                        {
                            "summaryComponent": "The scrape_season_stats function",
                            "codeSegments": [
                                {
                                    "line": 22,
                                    "code": "def scrape_season_stats(year):"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "fetches NBA per-game statistics for a specified year from the Basketball Reference website",
                            "codeSegments": [
                                {
                                    "line": 23,
                                    "code": "base_url_reg = ("
                                },
                                {
                                    "line": 24,
                                    "code": "f\"https://www.basketball-reference.com/leagues/NBA_{year}_per_game.html\""
                                },
                                {
                                    "line": 26,
                                    "code": "df_reg = pd.read_html(base_url_reg, header=0)[0]"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "using pandas' read_html",
                            "codeSegments": [
                                {
                                    "line": 26,
                                    "code": "pd.read_html(base_url_reg, header=0)[0]"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "removing any repeated header rows",
                            "codeSegments": [
                                {
                                    "line": 27,
                                    "code": "df_reg = df_reg[df_reg[\"Player\"] != \"Player\"]  # remove repeated header rows"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "adds a 'Year' column",
                            "codeSegments": [
                                {
                                    "line": 28,
                                    "code": "df_reg[\"Year\"] = year"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "selects only the columns for player name, year, points, assists, rebounds, and field goal percentage",
                            "codeSegments": [
                                {
                                    "line": 30,
                                    "code": "df_reg = df_reg["
                                },
                                {
                                    "line": 31,
                                    "code": "[\"Player\", \"Year\", \"PTS\", \"AST\", \"TRB\", \"FG%\"]"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "dropping any rows where these key statistics are missing",
                            "codeSegments": [
                                {
                                    "line": 33,
                                    "code": "df_reg = df_reg.dropna("
                                },
                                {
                                    "line": 34,
                                    "code": "subset=[\"PTS\", \"AST\", \"TRB\", \"FG%\"]"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "ensuring only valid player data is included",
                            "codeSegments": [
                                {
                                    "line": 35,
                                    "code": "# Ensure key stats aren't invalid"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "returns the cleaned DataFrame containing the relevant stats for all players in that season",
                            "codeSegments": [
                                {
                                    "line": 36,
                                    "code": "return df_reg"
                                }
                            ]
                        }
                    ],
                    "medium_unstructured": [
                        {
                            "summaryComponent": "The scrape_season_stats function",
                            "codeSegments": [
                                {
                                    "line": 22,
                                    "code": "def scrape_season_stats(year):"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "downloads NBA per-game statistics for a given year from Basketball Reference",
                            "codeSegments": [
                                {
                                    "line": 24,
                                    "code": "f\"https://www.basketball-reference.com/leagues/NBA_{year}_per_game.html\""
                                },
                                {
                                    "line": 26,
                                    "code": "df_reg = pd.read_html(base_url_reg, header=0)[0]"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "It cleans the data by removing repeated header rows",
                            "codeSegments": [
                                {
                                    "line": 27,
                                    "code": "df_reg = df_reg[df_reg[\"Player\"] != \"Player\"]  # remove repeated header rows"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "keeps only relevant columns like player name, year, points, assists, rebounds, and field goal percentage",
                            "codeSegments": [
                                {
                                    "line": 30,
                                    "code": "df_reg = df_reg["
                                },
                                {
                                    "line": 31,
                                    "code": "[\"Player\", \"Year\", \"PTS\", \"AST\", \"TRB\", \"FG%\"]"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "The function also ensures that rows with missing key stats are excluded",
                            "codeSegments": [
                                {
                                    "line": 33,
                                    "code": "df_reg = df_reg.dropna("
                                },
                                {
                                    "line": 34,
                                    "code": "subset=[\"PTS\", \"AST\", \"TRB\", \"FG%\"]"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "before returning the final DataFrame",
                            "codeSegments": [
                                {
                                    "line": 36,
                                    "code": "return df_reg"
                                }
                            ]
                        }
                    ],
                    "high_structured": [
                        {
                            "summaryComponent": "Constructs the URL for NBA per-game stats for the given year",
                            "codeSegments": [
                                {
                                    "line": 23,
                                    "code": "base_url_reg = (\n    f\"https://www.basketball-reference.com/leagues/NBA_{year}_per_game.html\"\n)"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "Reads the first table from the webpage using pandas' read_html",
                            "codeSegments": [
                                {
                                    "line": 26,
                                    "code": "df_reg = pd.read_html(base_url_reg, header=0)[0]"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "Removes rows where the 'Player' column is equal to 'Player' (repeated header rows)",
                            "codeSegments": [
                                {
                                    "line": 27,
                                    "code": "df_reg = df_reg[df_reg[\"Player\"] != \"Player\"]  # remove repeated header rows"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "Adds a 'Year' column with the specified year",
                            "codeSegments": [
                                {
                                    "line": 28,
                                    "code": "df_reg[\"Year\"] = year"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "Selects only the relevant columns:",
                            "codeSegments": [
                                {
                                    "line": 30,
                                    "code": "df_reg = df_reg[\n    [\"Player\", \"Year\", \"PTS\", \"AST\", \"TRB\", \"FG%\"]\n]"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "'Player', 'Year', 'PTS', 'AST', 'TRB', 'FG%'",
                            "codeSegments": [
                                {
                                    "line": 31,
                                    "code": "[\"Player\", \"Year\", \"PTS\", \"AST\", \"TRB\", \"FG%\"]"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "Drops rows with missing values in any of the key stat columns",
                            "codeSegments": [
                                {
                                    "line": 33,
                                    "code": "df_reg = df_reg.dropna(\n    subset=[\"PTS\", \"AST\", \"TRB\", \"FG%\"]\n)"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "Returns the resulting DataFrame with cleaned and filtered player statistics for that year",
                            "codeSegments": [
                                {
                                    "line": 36,
                                    "code": "return df_reg"
                                }
                            ]
                        }
                    ],
                    "low_unstructured": [
                        {
                            "summaryComponent": "This function",
                            "codeSegments": [
                                {
                                    "line": 22,
                                    "code": "def scrape_season_stats(year):"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "retrieves",
                            "codeSegments": [
                                {
                                    "line": 26,
                                    "code": "df_reg = pd.read_html(base_url_reg, header=0)[0]"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "and processes",
                            "codeSegments": [
                                {
                                    "line": 27,
                                    "code": "df_reg = df_reg[df_reg[\"Player\"] != \"Player\"]  # remove repeated header rows"
                                },
                                {
                                    "line": 28,
                                    "code": "df_reg[\"Year\"] = year"
                                },
                                {
                                    "line": 30,
                                    "code": "df_reg = df_reg[\n    [\"Player\", \"Year\", \"PTS\", \"AST\", \"TRB\", \"FG%\"]\n]"
                                },
                                {
                                    "line": 33,
                                    "code": "df_reg = df_reg.dropna(\n    subset=[\"PTS\", \"AST\", \"TRB\", \"FG%\"]\n)"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "NBA per-game player statistics",
                            "codeSegments": [
                                {
                                    "line": 24,
                                    "code": "f\"https://www.basketball-reference.com/leagues/NBA_{year}_per_game.html\""
                                }
                            ]
                        },
                        {
                            "summaryComponent": "for a given year",
                            "codeSegments": [
                                {
                                    "line": 22,
                                    "code": "def scrape_season_stats(year):"
                                },
                                {
                                    "line": 24,
                                    "code": "f\"https://www.basketball-reference.com/leagues/NBA_{year}_per_game.html\""
                                },
                                {
                                    "line": 28,
                                    "code": "df_reg[\"Year\"] = year"
                                }
                            ]
                        }
                    ],
                    "low_structured": [
                        {
                            "summaryComponent": "Fetches NBA per-game stats for a specified year",
                            "codeSegments": [
                                {
                                    "line": 22,
                                    "code": "def scrape_season_stats(year):"
                                },
                                {
                                    "line": 23,
                                    "code": "base_url_reg = ("
                                },
                                {
                                    "line": 24,
                                    "code": "f\"https://www.basketball-reference.com/leagues/NBA_{year}_per_game.html\""
                                },
                                {
                                    "line": 26,
                                    "code": "df_reg = pd.read_html(base_url_reg, header=0)[0]"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "Cleans and filters the data",
                            "codeSegments": [
                                {
                                    "line": 27,
                                    "code": "df_reg = df_reg[df_reg[\"Player\"] != \"Player\"]  # remove repeated header rows"
                                },
                                {
                                    "line": 28,
                                    "code": "df_reg[\"Year\"] = year"
                                },
                                {
                                    "line": 30,
                                    "code": "df_reg = df_reg["
                                },
                                {
                                    "line": 31,
                                    "code": "[\"Player\", \"Year\", \"PTS\", \"AST\", \"TRB\", \"FG%\"]"
                                },
                                {
                                    "line": 33,
                                    "code": "df_reg = df_reg.dropna("
                                },
                                {
                                    "line": 34,
                                    "code": "subset=[\"PTS\", \"AST\", \"TRB\", \"FG%\"]"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "Returns selected player statistics",
                            "codeSegments": [
                                {
                                    "line": 36,
                                    "code": "return df_reg"
                                }
                            ]
                        }
                    ],
                    "medium_structured": [
                        {
                            "summaryComponent": "Downloads NBA per-game stats for a specified year from Basketball Reference",
                            "codeSegments": [
                                {
                                    "line": 23,
                                    "code": "base_url_reg = (\n    f\"https://www.basketball-reference.com/leagues/NBA_{year}_per_game.html\"\n)"
                                },
                                {
                                    "line": 26,
                                    "code": "df_reg = pd.read_html(base_url_reg, header=0)[0]"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "Cleans the DataFrame:",
                            "codeSegments": [
                                {
                                    "line": 27,
                                    "code": "# remove repeated header rows"
                                },
                                {
                                    "line": 28,
                                    "code": "df_reg[\"Year\"] = year"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "Removes repeated header rows",
                            "codeSegments": [
                                {
                                    "line": 27,
                                    "code": "df_reg = df_reg[df_reg[\"Player\"] != \"Player\"]  # remove repeated header rows"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "Adds the year column",
                            "codeSegments": [
                                {
                                    "line": 28,
                                    "code": "df_reg[\"Year\"] = year"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "Selects only key columns: Player, Year, PTS, AST, TRB, FG%",
                            "codeSegments": [
                                {
                                    "line": 30,
                                    "code": "df_reg = df_reg[\n    [\"Player\", \"Year\", \"PTS\", \"AST\", \"TRB\", \"FG%\"]\n]"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "Drops rows with missing values in the key stats",
                            "codeSegments": [
                                {
                                    "line": 33,
                                    "code": "df_reg = df_reg.dropna(\n    subset=[\"PTS\", \"AST\", \"TRB\", \"FG%\"]\n)"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "Returns the cleaned DataFrame",
                            "codeSegments": [
                                {
                                    "line": 36,
                                    "code": "return df_reg"
                                }
                            ]
                        }
                    ]
                }
            }
        },
        "timestamp": "2025-08-16 22:49:14.000",
        "id": "h3PKq91PNm0YHaHPEIfg"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "94e232d8-8f75-4045-a81c-fb03a7b3aacc",
            "detail_level": "medium",
            "structured_type": "unstructured"
        },
        "timestamp": "2025-08-16 22:49:20.000",
        "id": "0LmrBfSSSUXc7WOmRdjm"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "94e232d8-8f75-4045-a81c-fb03a7b3aacc",
            "detail_level": "medium",
            "structured_type": "unstructured"
        },
        "timestamp": "2025-08-16 22:49:20.000",
        "id": "3yKDji1qYdn2G2hagQ3D"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "94e232d8-8f75-4045-a81c-fb03a7b3aacc",
            "detail_level": "medium",
            "structured_type": "unstructured"
        },
        "timestamp": "2025-08-16 22:49:20.000",
        "id": "6gKtfa8hujc3Oho578a8"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "94e232d8-8f75-4045-a81c-fb03a7b3aacc",
            "mapping_index": 1,
            "structured_type": "unstructured",
            "detail_level": "medium"
        },
        "timestamp": "2025-08-16 22:49:20.000",
        "id": "RXQTNfp2oI0gpLxKMld0"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "94e232d8-8f75-4045-a81c-fb03a7b3aacc",
            "mapping_index": 4,
            "structured_type": "unstructured",
            "detail_level": "medium"
        },
        "timestamp": "2025-08-16 22:49:20.000",
        "id": "qVh3lrW1aI5UZRZQF0Zm"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "94e232d8-8f75-4045-a81c-fb03a7b3aacc",
            "mapping_index": 3,
            "structured_type": "unstructured",
            "detail_level": "medium"
        },
        "timestamp": "2025-08-16 22:49:20.000",
        "id": "wrZ8hMkqmyyYE1zNNhpT"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "94e232d8-8f75-4045-a81c-fb03a7b3aacc",
            "mapping_index": 1,
            "structured_type": "unstructured",
            "detail_level": "medium"
        },
        "timestamp": "2025-08-16 22:49:21.000",
        "id": "7SsCIW5pFPn0Kphvo0aw"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "94e232d8-8f75-4045-a81c-fb03a7b3aacc",
            "detail_level": "medium",
            "structured_type": "unstructured"
        },
        "timestamp": "2025-08-16 22:49:21.000",
        "id": "Db9CiPa7ZnCbXdOTfhKL"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "94e232d8-8f75-4045-a81c-fb03a7b3aacc",
            "mapping_index": 2,
            "structured_type": "unstructured",
            "detail_level": "medium"
        },
        "timestamp": "2025-08-16 22:49:21.000",
        "id": "eJXVDCjveXeOxzeCVOKv"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "94e232d8-8f75-4045-a81c-fb03a7b3aacc",
            "mapping_index": 3,
            "structured_type": "unstructured",
            "detail_level": "medium"
        },
        "timestamp": "2025-08-16 22:49:22.000",
        "id": "aj7WSGvBaBbmQvHt2c5u"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "94e232d8-8f75-4045-a81c-fb03a7b3aacc",
            "detail_level": "medium",
            "structured_type": "unstructured"
        },
        "timestamp": "2025-08-16 22:49:22.000",
        "id": "z8Rj1mPU4ML8GmOp7cnv"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "94e232d8-8f75-4045-a81c-fb03a7b3aacc",
            "mapping_index": 1,
            "structured_type": "unstructured",
            "detail_level": "medium"
        },
        "timestamp": "2025-08-16 22:49:24.000",
        "id": "HgrZB2y89sYzkCmo1CGb"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "94e232d8-8f75-4045-a81c-fb03a7b3aacc",
            "detail_level": "medium",
            "structured_type": "unstructured"
        },
        "timestamp": "2025-08-16 22:49:24.000",
        "id": "Mm8fP1rx6a5FtZb6InMi"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "94e232d8-8f75-4045-a81c-fb03a7b3aacc",
            "detail_level": "medium",
            "structured_type": "unstructured"
        },
        "timestamp": "2025-08-16 22:49:24.000",
        "id": "akwU3srHLXM6zHu6ju0E"
    },
    {
        "source": "frontend",
        "event": "change_summary_level",
        "data": {
            "before_detail_level": "medium",
            "section_id": "94e232d8-8f75-4045-a81c-fb03a7b3aacc",
            "before_structured": "unstructured",
            "after_structured": "structured",
            "after_detail_level": "medium"
        },
        "timestamp": "2025-08-16 22:49:25.000",
        "id": "7JGUaFR7v9EjRyPEb6JK"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "94e232d8-8f75-4045-a81c-fb03a7b3aacc",
            "mapping_index": 0,
            "structured_type": "structured",
            "detail_level": "medium"
        },
        "timestamp": "2025-08-16 22:49:25.000",
        "id": "vgJk1dfc4kFMQW915rRu"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "94e232d8-8f75-4045-a81c-fb03a7b3aacc",
            "detail_level": "medium",
            "structured_type": "structured"
        },
        "timestamp": "2025-08-16 22:49:26.000",
        "id": "2PBmbO5J6wtYMjmUXgAD"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "94e232d8-8f75-4045-a81c-fb03a7b3aacc",
            "mapping_index": 2,
            "structured_type": "structured",
            "detail_level": "medium"
        },
        "timestamp": "2025-08-16 22:49:26.000",
        "id": "6YqHeqbUiEhUSBB91KdP"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "94e232d8-8f75-4045-a81c-fb03a7b3aacc",
            "mapping_index": 1,
            "structured_type": "structured",
            "detail_level": "medium"
        },
        "timestamp": "2025-08-16 22:49:26.000",
        "id": "OhlIQy5bXiVy0IYW5o3U"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "94e232d8-8f75-4045-a81c-fb03a7b3aacc",
            "mapping_index": 1,
            "structured_type": "structured",
            "detail_level": "medium"
        },
        "timestamp": "2025-08-16 22:49:26.000",
        "id": "QajTfu3KFBYC84iNPuOa"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "94e232d8-8f75-4045-a81c-fb03a7b3aacc",
            "detail_level": "medium",
            "structured_type": "structured"
        },
        "timestamp": "2025-08-16 22:49:26.000",
        "id": "iPv7cjSSYocNrwP3S7Pv"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "94e232d8-8f75-4045-a81c-fb03a7b3aacc",
            "detail_level": "medium",
            "structured_type": "structured"
        },
        "timestamp": "2025-08-16 22:49:26.000",
        "id": "trifHf0EZgvxViLsVoVk"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "94e232d8-8f75-4045-a81c-fb03a7b3aacc",
            "mapping_index": 0,
            "structured_type": "structured",
            "detail_level": "medium"
        },
        "timestamp": "2025-08-16 22:49:27.000",
        "id": "83SBAjRdY2Lu2gM3Yw38"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "94e232d8-8f75-4045-a81c-fb03a7b3aacc",
            "mapping_index": 1,
            "structured_type": "structured",
            "detail_level": "medium"
        },
        "timestamp": "2025-08-16 22:49:27.000",
        "id": "cf14nIPIXekbcR7lE2rm"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "94e232d8-8f75-4045-a81c-fb03a7b3aacc",
            "detail_level": "medium",
            "structured_type": "structured"
        },
        "timestamp": "2025-08-16 22:49:27.000",
        "id": "fzkqaK2udH4JeImnL9Ib"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "94e232d8-8f75-4045-a81c-fb03a7b3aacc",
            "detail_level": "medium",
            "structured_type": "structured"
        },
        "timestamp": "2025-08-16 22:49:27.000",
        "id": "pQ3YeH4u0zGn1pDIPsHo"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "94e232d8-8f75-4045-a81c-fb03a7b3aacc",
            "detail_level": "medium",
            "structured_type": "structured"
        },
        "timestamp": "2025-08-16 22:49:29.000",
        "id": "B7wYoc5j5GbY67iljaAL"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "94e232d8-8f75-4045-a81c-fb03a7b3aacc",
            "mapping_index": 2,
            "structured_type": "structured",
            "detail_level": "medium"
        },
        "timestamp": "2025-08-16 22:49:29.000",
        "id": "EgQCQoVEckhovwqutEyP"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "94e232d8-8f75-4045-a81c-fb03a7b3aacc",
            "detail_level": "medium",
            "structured_type": "structured"
        },
        "timestamp": "2025-08-16 22:49:30.000",
        "id": "9EWtzzliZ4AYZ964rbMl"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "94e232d8-8f75-4045-a81c-fb03a7b3aacc",
            "detail_level": "medium",
            "structured_type": "structured"
        },
        "timestamp": "2025-08-16 22:49:30.000",
        "id": "Q9X4F05KTd3XhtkbjGpe"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "94e232d8-8f75-4045-a81c-fb03a7b3aacc",
            "mapping_index": 1,
            "structured_type": "structured",
            "detail_level": "medium"
        },
        "timestamp": "2025-08-16 22:49:30.000",
        "id": "UL4f8yRTy0YdlZGHTCh9"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "94e232d8-8f75-4045-a81c-fb03a7b3aacc",
            "detail_level": "medium",
            "structured_type": "structured"
        },
        "timestamp": "2025-08-16 22:49:30.000",
        "id": "x4j48OyEawvOJWy9xckn"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "94e232d8-8f75-4045-a81c-fb03a7b3aacc",
            "mapping_index": 0,
            "structured_type": "structured",
            "detail_level": "medium"
        },
        "timestamp": "2025-08-16 22:49:30.000",
        "id": "z3mamEi7hyK5onhiY3FB"
    },
    {
        "source": "frontend",
        "event": "change_summary_level",
        "data": {
            "before_detail_level": "medium",
            "section_id": "94e232d8-8f75-4045-a81c-fb03a7b3aacc",
            "before_structured": "structured",
            "after_structured": "unstructured",
            "after_detail_level": "medium"
        },
        "timestamp": "2025-08-16 22:49:31.000",
        "id": "PBHaWmhYxEPpZU4Wcoq4"
    },
    {
        "source": "frontend",
        "event": "change_summary_level",
        "data": {
            "before_detail_level": "medium",
            "section_id": "94e232d8-8f75-4045-a81c-fb03a7b3aacc",
            "before_structured": "unstructured",
            "after_structured": "unstructured",
            "after_detail_level": "low"
        },
        "timestamp": "2025-08-16 22:49:32.000",
        "id": "fjMhCx1pPIELTc7oVx5F"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "94e232d8-8f75-4045-a81c-fb03a7b3aacc",
            "mapping_index": 2,
            "structured_type": "unstructured",
            "detail_level": "low"
        },
        "timestamp": "2025-08-16 22:49:33.000",
        "id": "D6J1pdcoHJ2oAgLiS68P"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "94e232d8-8f75-4045-a81c-fb03a7b3aacc",
            "detail_level": "low",
            "structured_type": "unstructured"
        },
        "timestamp": "2025-08-16 22:49:33.000",
        "id": "KPANuKmcJRgJl3eojSZ2"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "94e232d8-8f75-4045-a81c-fb03a7b3aacc",
            "detail_level": "low",
            "structured_type": "unstructured"
        },
        "timestamp": "2025-08-16 22:49:33.000",
        "id": "SH9Txk1blUGsHXH6v2cD"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "94e232d8-8f75-4045-a81c-fb03a7b3aacc",
            "detail_level": "low",
            "structured_type": "unstructured"
        },
        "timestamp": "2025-08-16 22:49:33.000",
        "id": "W8wgd5qagaE8biCyARh7"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "94e232d8-8f75-4045-a81c-fb03a7b3aacc",
            "mapping_index": 3,
            "structured_type": "unstructured",
            "detail_level": "low"
        },
        "timestamp": "2025-08-16 22:49:33.000",
        "id": "kc2vlDiF3ARnWiW1Tg22"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "94e232d8-8f75-4045-a81c-fb03a7b3aacc",
            "mapping_index": 2,
            "structured_type": "unstructured",
            "detail_level": "low"
        },
        "timestamp": "2025-08-16 22:49:33.000",
        "id": "lFFJfJTkD2L3Lkl2dEwp"
    },
    {
        "source": "frontend",
        "event": "change_summary_level",
        "data": {
            "before_detail_level": "low",
            "section_id": "94e232d8-8f75-4045-a81c-fb03a7b3aacc",
            "before_structured": "unstructured",
            "after_structured": "unstructured",
            "after_detail_level": "medium"
        },
        "timestamp": "2025-08-16 22:49:34.000",
        "id": "aNAbIwzgsAPtguHqE8DB"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "94e232d8-8f75-4045-a81c-fb03a7b3aacc",
            "detail_level": "low",
            "structured_type": "unstructured"
        },
        "timestamp": "2025-08-16 22:49:35.000",
        "id": "MA0hEmJICQBn9OMZFSrh"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "94e232d8-8f75-4045-a81c-fb03a7b3aacc",
            "mapping_index": 3,
            "structured_type": "unstructured",
            "detail_level": "low"
        },
        "timestamp": "2025-08-16 22:49:35.000",
        "id": "hScqGx8syox2P9S86cre"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "94e232d8-8f75-4045-a81c-fb03a7b3aacc",
            "mapping_index": 4,
            "structured_type": "unstructured",
            "detail_level": "low"
        },
        "timestamp": "2025-08-16 22:49:35.000",
        "id": "nAWlxnD1dwKxVBXTQH02"
    },
    {
        "source": "frontend",
        "event": "change_summary_level",
        "data": {
            "before_detail_level": "medium",
            "section_id": "94e232d8-8f75-4045-a81c-fb03a7b3aacc",
            "before_structured": "unstructured",
            "after_structured": "unstructured",
            "after_detail_level": "low"
        },
        "timestamp": "2025-08-16 22:49:35.000",
        "id": "vG9heXl3TrSSXwccSH6U"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "94e232d8-8f75-4045-a81c-fb03a7b3aacc",
            "detail_level": "low",
            "structured_type": "unstructured"
        },
        "timestamp": "2025-08-16 22:49:36.000",
        "id": "0plAzjUx1pkhvX69bDlB"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "94e232d8-8f75-4045-a81c-fb03a7b3aacc",
            "mapping_index": 3,
            "structured_type": "unstructured",
            "detail_level": "low"
        },
        "timestamp": "2025-08-16 22:49:36.000",
        "id": "9Ctb61c8QFp4Vq8ipYvU"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "94e232d8-8f75-4045-a81c-fb03a7b3aacc",
            "detail_level": "low",
            "structured_type": "unstructured"
        },
        "timestamp": "2025-08-16 22:49:37.000",
        "id": "5Te9IBM8OFNlLCcY5chi"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "94e232d8-8f75-4045-a81c-fb03a7b3aacc",
            "detail_level": "low",
            "structured_type": "unstructured"
        },
        "timestamp": "2025-08-16 22:49:37.000",
        "id": "GBJj63WnvqPqaOsuapJj"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "94e232d8-8f75-4045-a81c-fb03a7b3aacc",
            "mapping_index": 3,
            "structured_type": "unstructured",
            "detail_level": "low"
        },
        "timestamp": "2025-08-16 22:49:37.000",
        "id": "St9p7NVUmlCxImRz7RCU"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "94e232d8-8f75-4045-a81c-fb03a7b3aacc",
            "detail_level": "low",
            "structured_type": "unstructured"
        },
        "timestamp": "2025-08-16 22:49:37.000",
        "id": "h8saIHMvSKkMn3fBpKEx"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "94e232d8-8f75-4045-a81c-fb03a7b3aacc",
            "mapping_index": 2,
            "structured_type": "unstructured",
            "detail_level": "low"
        },
        "timestamp": "2025-08-16 22:49:37.000",
        "id": "hJSfaOVR6eqSVq6ecE3A"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "94e232d8-8f75-4045-a81c-fb03a7b3aacc",
            "detail_level": "low",
            "structured_type": "unstructured"
        },
        "timestamp": "2025-08-16 22:49:39.000",
        "id": "GDT9bBrd32PiCCBQa84A"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "94e232d8-8f75-4045-a81c-fb03a7b3aacc",
            "mapping_index": 0,
            "structured_type": "unstructured",
            "detail_level": "low"
        },
        "timestamp": "2025-08-16 22:49:39.000",
        "id": "YKDGMSdHQGAuea03TudM"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "94e232d8-8f75-4045-a81c-fb03a7b3aacc",
            "mapping_index": 1,
            "structured_type": "unstructured",
            "detail_level": "low"
        },
        "timestamp": "2025-08-16 22:49:39.000",
        "id": "hCETMIfiH1GApgLzFplo"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "94e232d8-8f75-4045-a81c-fb03a7b3aacc",
            "mapping_index": 1,
            "structured_type": "unstructured",
            "detail_level": "low"
        },
        "timestamp": "2025-08-16 22:49:40.000",
        "id": "IbMdBybx1QkuIqVNOeN2"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "94e232d8-8f75-4045-a81c-fb03a7b3aacc",
            "mapping_index": 1,
            "structured_type": "unstructured",
            "detail_level": "low"
        },
        "timestamp": "2025-08-16 22:49:40.000",
        "id": "XTSidB1dKWr98puOtqNe"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "94e232d8-8f75-4045-a81c-fb03a7b3aacc",
            "detail_level": "low",
            "structured_type": "unstructured"
        },
        "timestamp": "2025-08-16 22:49:40.000",
        "id": "ZGp2ubYjien0HQLGzgxi"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "94e232d8-8f75-4045-a81c-fb03a7b3aacc",
            "detail_level": "low",
            "structured_type": "unstructured"
        },
        "timestamp": "2025-08-16 22:49:40.000",
        "id": "xmy7aCjZFcNqJzxK0cg0"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "94e232d8-8f75-4045-a81c-fb03a7b3aacc",
            "mapping_index": 2,
            "structured_type": "unstructured",
            "detail_level": "low"
        },
        "timestamp": "2025-08-16 22:49:41.000",
        "id": "4IGyRua6Gwbeb8Sf4tEg"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "94e232d8-8f75-4045-a81c-fb03a7b3aacc",
            "mapping_index": 2,
            "structured_type": "unstructured",
            "detail_level": "low"
        },
        "timestamp": "2025-08-16 22:49:41.000",
        "id": "6GK6EnMQvfYBWUg73GcT"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "94e232d8-8f75-4045-a81c-fb03a7b3aacc",
            "detail_level": "low",
            "structured_type": "unstructured"
        },
        "timestamp": "2025-08-16 22:49:41.000",
        "id": "JgxFLqwWHWLeICn98cuZ"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "94e232d8-8f75-4045-a81c-fb03a7b3aacc",
            "detail_level": "low",
            "structured_type": "unstructured"
        },
        "timestamp": "2025-08-16 22:49:41.000",
        "id": "MH8loSbLYkSzoiNbSesj"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "94e232d8-8f75-4045-a81c-fb03a7b3aacc",
            "detail_level": "low",
            "structured_type": "unstructured"
        },
        "timestamp": "2025-08-16 22:49:41.000",
        "id": "pD5exaqCX4a7Wu3XgStm"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "94e232d8-8f75-4045-a81c-fb03a7b3aacc",
            "mapping_index": 3,
            "structured_type": "unstructured",
            "detail_level": "low"
        },
        "timestamp": "2025-08-16 22:49:41.000",
        "id": "wzQ43gxpOiEdNs3JMjWM"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "94e232d8-8f75-4045-a81c-fb03a7b3aacc",
            "mapping_index": 3,
            "structured_type": "unstructured",
            "detail_level": "low"
        },
        "timestamp": "2025-08-16 22:49:42.000",
        "id": "3Rjpvs44JYhsNZghIkQO"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "94e232d8-8f75-4045-a81c-fb03a7b3aacc",
            "detail_level": "low",
            "structured_type": "unstructured"
        },
        "timestamp": "2025-08-16 22:49:42.000",
        "id": "6Re2TBvYVFyJxbSKdBBW"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "94e232d8-8f75-4045-a81c-fb03a7b3aacc",
            "mapping_index": 0,
            "structured_type": "unstructured",
            "detail_level": "low"
        },
        "timestamp": "2025-08-16 22:49:42.000",
        "id": "A2X8eALCvSK5gem9VLBf"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "94e232d8-8f75-4045-a81c-fb03a7b3aacc",
            "mapping_index": 3,
            "structured_type": "unstructured",
            "detail_level": "low"
        },
        "timestamp": "2025-08-16 22:49:42.000",
        "id": "Fqz55ege7Kouyhg8KDEj"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "94e232d8-8f75-4045-a81c-fb03a7b3aacc",
            "detail_level": "low",
            "structured_type": "unstructured"
        },
        "timestamp": "2025-08-16 22:49:42.000",
        "id": "IYWu27QW8qzl08sPnnN5"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "94e232d8-8f75-4045-a81c-fb03a7b3aacc",
            "mapping_index": 1,
            "structured_type": "unstructured",
            "detail_level": "low"
        },
        "timestamp": "2025-08-16 22:49:42.000",
        "id": "K4aBXTZ5j6rUWYNOT9UQ"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "94e232d8-8f75-4045-a81c-fb03a7b3aacc",
            "detail_level": "low",
            "structured_type": "unstructured"
        },
        "timestamp": "2025-08-16 22:49:42.000",
        "id": "cxael7JTjvaexhThUb9C"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "94e232d8-8f75-4045-a81c-fb03a7b3aacc",
            "mapping_index": 4,
            "structured_type": "unstructured",
            "detail_level": "low"
        },
        "timestamp": "2025-08-16 22:49:42.000",
        "id": "hsaYSlFmhtFOTtUqmlhd"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "94e232d8-8f75-4045-a81c-fb03a7b3aacc",
            "mapping_index": 2,
            "structured_type": "unstructured",
            "detail_level": "low"
        },
        "timestamp": "2025-08-16 22:49:42.000",
        "id": "jNv5nzsGgKpobji6LXyn"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "94e232d8-8f75-4045-a81c-fb03a7b3aacc",
            "detail_level": "low",
            "structured_type": "unstructured"
        },
        "timestamp": "2025-08-16 22:49:42.000",
        "id": "kpvuRlDi8oHmOVFX1sso"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "94e232d8-8f75-4045-a81c-fb03a7b3aacc",
            "detail_level": "low",
            "structured_type": "unstructured"
        },
        "timestamp": "2025-08-16 22:49:42.000",
        "id": "oe2a5mk5cagzCk7HaMpf"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "94e232d8-8f75-4045-a81c-fb03a7b3aacc",
            "detail_level": "low",
            "structured_type": "unstructured"
        },
        "timestamp": "2025-08-16 22:49:42.000",
        "id": "qztdgOrEztC6axZtJR7j"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "94e232d8-8f75-4045-a81c-fb03a7b3aacc",
            "mapping_index": 1,
            "structured_type": "unstructured",
            "detail_level": "low"
        },
        "timestamp": "2025-08-16 22:49:42.000",
        "id": "uWZEASZylvZpF5Dn6I8Q"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "94e232d8-8f75-4045-a81c-fb03a7b3aacc",
            "detail_level": "low",
            "structured_type": "unstructured"
        },
        "timestamp": "2025-08-16 22:49:42.000",
        "id": "udERAhKDO5cM7U9JiU8c"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "94e232d8-8f75-4045-a81c-fb03a7b3aacc",
            "detail_level": "low",
            "structured_type": "unstructured"
        },
        "timestamp": "2025-08-16 22:49:43.000",
        "id": "5Jz6RMyguvpROwxkOzp6"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "94e232d8-8f75-4045-a81c-fb03a7b3aacc",
            "mapping_index": 3,
            "structured_type": "unstructured",
            "detail_level": "low"
        },
        "timestamp": "2025-08-16 22:49:43.000",
        "id": "6OptEpXEUr8TwY6rmb8s"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "94e232d8-8f75-4045-a81c-fb03a7b3aacc",
            "detail_level": "low",
            "structured_type": "unstructured"
        },
        "timestamp": "2025-08-16 22:49:43.000",
        "id": "73zqxNCA0LSyS2MJEfsH"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "94e232d8-8f75-4045-a81c-fb03a7b3aacc",
            "mapping_index": 3,
            "structured_type": "unstructured",
            "detail_level": "low"
        },
        "timestamp": "2025-08-16 22:49:43.000",
        "id": "7ChaK35PJhOsm8edwXjD"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "94e232d8-8f75-4045-a81c-fb03a7b3aacc",
            "mapping_index": 1,
            "structured_type": "unstructured",
            "detail_level": "low"
        },
        "timestamp": "2025-08-16 22:49:43.000",
        "id": "ChsfGp4FlKao5oJrdabP"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "94e232d8-8f75-4045-a81c-fb03a7b3aacc",
            "detail_level": "low",
            "structured_type": "unstructured"
        },
        "timestamp": "2025-08-16 22:49:43.000",
        "id": "IXNPWdER6bSlJYAEI4su"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "94e232d8-8f75-4045-a81c-fb03a7b3aacc",
            "mapping_index": 4,
            "structured_type": "unstructured",
            "detail_level": "low"
        },
        "timestamp": "2025-08-16 22:49:43.000",
        "id": "MLd6ZcCJWQB5P8TF75Ba"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "94e232d8-8f75-4045-a81c-fb03a7b3aacc",
            "detail_level": "low",
            "structured_type": "unstructured"
        },
        "timestamp": "2025-08-16 22:49:43.000",
        "id": "ORsE94c8BzhbHmQRCRj7"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "94e232d8-8f75-4045-a81c-fb03a7b3aacc",
            "mapping_index": 1,
            "structured_type": "unstructured",
            "detail_level": "low"
        },
        "timestamp": "2025-08-16 22:49:43.000",
        "id": "SAK2DsQhyT5RY2coVfjE"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "94e232d8-8f75-4045-a81c-fb03a7b3aacc",
            "mapping_index": 2,
            "structured_type": "unstructured",
            "detail_level": "low"
        },
        "timestamp": "2025-08-16 22:49:43.000",
        "id": "WgCbOsoqiRefjDxnXa82"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "94e232d8-8f75-4045-a81c-fb03a7b3aacc",
            "detail_level": "low",
            "structured_type": "unstructured"
        },
        "timestamp": "2025-08-16 22:49:43.000",
        "id": "bsfh6aBRyl3Sm10sc0YT"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "94e232d8-8f75-4045-a81c-fb03a7b3aacc",
            "mapping_index": 2,
            "structured_type": "unstructured",
            "detail_level": "low"
        },
        "timestamp": "2025-08-16 22:49:43.000",
        "id": "ckpUkBNNRrF21raCqJsT"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "94e232d8-8f75-4045-a81c-fb03a7b3aacc",
            "detail_level": "low",
            "structured_type": "unstructured"
        },
        "timestamp": "2025-08-16 22:49:43.000",
        "id": "g0Z50sIsdYfvnbmgnCTH"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "94e232d8-8f75-4045-a81c-fb03a7b3aacc",
            "detail_level": "low",
            "structured_type": "unstructured"
        },
        "timestamp": "2025-08-16 22:49:43.000",
        "id": "ipKXNYRdIINR2IJQMzQH"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "94e232d8-8f75-4045-a81c-fb03a7b3aacc",
            "mapping_index": 0,
            "structured_type": "unstructured",
            "detail_level": "low"
        },
        "timestamp": "2025-08-16 22:49:43.000",
        "id": "l48Sa5vCHcLA9NqZvTLg"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "94e232d8-8f75-4045-a81c-fb03a7b3aacc",
            "detail_level": "low",
            "structured_type": "unstructured"
        },
        "timestamp": "2025-08-16 22:49:43.000",
        "id": "m473mdKMjDEESY3RFtJs"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "94e232d8-8f75-4045-a81c-fb03a7b3aacc",
            "detail_level": "low",
            "structured_type": "unstructured"
        },
        "timestamp": "2025-08-16 22:49:43.000",
        "id": "wBTVqXPLMKtzypN37iT8"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "94e232d8-8f75-4045-a81c-fb03a7b3aacc",
            "mapping_index": 2,
            "structured_type": "unstructured",
            "detail_level": "low"
        },
        "timestamp": "2025-08-16 22:49:43.000",
        "id": "zJKTzPGeU2pHFvsLL6y7"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "94e232d8-8f75-4045-a81c-fb03a7b3aacc",
            "detail_level": "low",
            "structured_type": "unstructured"
        },
        "timestamp": "2025-08-16 22:49:44.000",
        "id": "WCmVwcbhd8WmDCs130Cf"
    },
    {
        "source": "frontend",
        "event": "change_summary_level",
        "data": {
            "before_detail_level": "low",
            "section_id": "94e232d8-8f75-4045-a81c-fb03a7b3aacc",
            "before_structured": "unstructured",
            "after_structured": "structured",
            "after_detail_level": "low"
        },
        "timestamp": "2025-08-16 22:49:46.000",
        "id": "5uh5iAr9Cvotugh8C3TL"
    },
    {
        "source": "frontend",
        "event": "change_summary_level",
        "data": {
            "before_detail_level": "low",
            "section_id": "94e232d8-8f75-4045-a81c-fb03a7b3aacc",
            "before_structured": "structured",
            "after_structured": "structured",
            "after_detail_level": "medium"
        },
        "timestamp": "2025-08-16 22:49:47.000",
        "id": "HDd5mQwvMxOLhqrgzo9l"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "94e232d8-8f75-4045-a81c-fb03a7b3aacc",
            "mapping_index": 0,
            "structured_type": "structured",
            "detail_level": "medium"
        },
        "timestamp": "2025-08-16 22:49:48.000",
        "id": "7tIshYAEkDv3Ja0dGx48"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "94e232d8-8f75-4045-a81c-fb03a7b3aacc",
            "mapping_index": 1,
            "structured_type": "structured",
            "detail_level": "medium"
        },
        "timestamp": "2025-08-16 22:49:50.000",
        "id": "6bPQV7o099UziGmgRbRl"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "94e232d8-8f75-4045-a81c-fb03a7b3aacc",
            "detail_level": "medium",
            "structured_type": "structured"
        },
        "timestamp": "2025-08-16 22:49:50.000",
        "id": "hePVZP7nbAaEh4W9zgX3"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "94e232d8-8f75-4045-a81c-fb03a7b3aacc",
            "detail_level": "medium",
            "structured_type": "structured"
        },
        "timestamp": "2025-08-16 22:49:51.000",
        "id": "H0svEFynsZKaOp1Ot6jq"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "94e232d8-8f75-4045-a81c-fb03a7b3aacc",
            "mapping_index": 2,
            "structured_type": "structured",
            "detail_level": "medium"
        },
        "timestamp": "2025-08-16 22:49:51.000",
        "id": "NUTMneJi1dBhAZ3fPD6m"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "94e232d8-8f75-4045-a81c-fb03a7b3aacc",
            "detail_level": "medium",
            "structured_type": "structured"
        },
        "timestamp": "2025-08-16 22:49:51.000",
        "id": "RIcMqIMZLl6FAG3W5zU2"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "94e232d8-8f75-4045-a81c-fb03a7b3aacc",
            "mapping_index": 0,
            "structured_type": "structured",
            "detail_level": "medium"
        },
        "timestamp": "2025-08-16 22:49:51.000",
        "id": "fpO3pqnCnhjF6cjffoZh"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "94e232d8-8f75-4045-a81c-fb03a7b3aacc",
            "detail_level": "medium",
            "structured_type": "structured"
        },
        "timestamp": "2025-08-16 22:49:51.000",
        "id": "kQaABp6pxKBd2rKoEEaK"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "94e232d8-8f75-4045-a81c-fb03a7b3aacc",
            "detail_level": "medium",
            "structured_type": "structured"
        },
        "timestamp": "2025-08-16 22:49:51.000",
        "id": "opdmGVgyRqXviURsMWj8"
    },
    {
        "source": "frontend",
        "event": "change_summary_level",
        "data": {
            "before_detail_level": "medium",
            "section_id": "94e232d8-8f75-4045-a81c-fb03a7b3aacc",
            "before_structured": "structured",
            "after_structured": "structured",
            "after_detail_level": "high"
        },
        "timestamp": "2025-08-16 22:49:51.000",
        "id": "pKy9WJNJDPsqTapT75nt"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "94e232d8-8f75-4045-a81c-fb03a7b3aacc",
            "mapping_index": 1,
            "structured_type": "structured",
            "detail_level": "medium"
        },
        "timestamp": "2025-08-16 22:49:51.000",
        "id": "v2JcnFufdlL4vb3wjXrP"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "94e232d8-8f75-4045-a81c-fb03a7b3aacc",
            "detail_level": "high",
            "structured_type": "structured"
        },
        "timestamp": "2025-08-16 22:49:53.000",
        "id": "Xv7ZA6xp5a0KfcPOQ9rj"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "94e232d8-8f75-4045-a81c-fb03a7b3aacc",
            "mapping_index": 0,
            "structured_type": "structured",
            "detail_level": "high"
        },
        "timestamp": "2025-08-16 22:49:53.000",
        "id": "lwHgof2pBliSCIi6Cc9Q"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "94e232d8-8f75-4045-a81c-fb03a7b3aacc",
            "mapping_index": 0,
            "structured_type": "structured",
            "detail_level": "medium"
        },
        "timestamp": "2025-08-16 22:49:54.000",
        "id": "ElGxTk3zJiJihtOqErak"
    },
    {
        "source": "frontend",
        "event": "change_summary_level",
        "data": {
            "before_detail_level": "high",
            "section_id": "94e232d8-8f75-4045-a81c-fb03a7b3aacc",
            "before_structured": "structured",
            "after_structured": "structured",
            "after_detail_level": "medium"
        },
        "timestamp": "2025-08-16 22:49:54.000",
        "id": "aHa6CyfHg3CrrzVBMOl3"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "94e232d8-8f75-4045-a81c-fb03a7b3aacc",
            "mapping_index": 1,
            "structured_type": "structured",
            "detail_level": "medium"
        },
        "timestamp": "2025-08-16 22:49:55.000",
        "id": "DSvfFTsHp9QsgTXT7Nev"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "94e232d8-8f75-4045-a81c-fb03a7b3aacc",
            "detail_level": "medium",
            "structured_type": "structured"
        },
        "timestamp": "2025-08-16 22:49:55.000",
        "id": "fBgyIhsYnxa66YYOuIik"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "94e232d8-8f75-4045-a81c-fb03a7b3aacc",
            "detail_level": "medium",
            "structured_type": "structured"
        },
        "timestamp": "2025-08-16 22:49:56.000",
        "id": "FMyzru0zoueCRSALVZ1Y"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "94e232d8-8f75-4045-a81c-fb03a7b3aacc",
            "mapping_index": 2,
            "structured_type": "structured",
            "detail_level": "medium"
        },
        "timestamp": "2025-08-16 22:49:56.000",
        "id": "JDlNgqCUnSHEYV4huGzS"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "94e232d8-8f75-4045-a81c-fb03a7b3aacc",
            "detail_level": "medium",
            "structured_type": "structured"
        },
        "timestamp": "2025-08-16 22:49:57.000",
        "id": "I77KPZ0WaT5kcHbsamfd"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "94e232d8-8f75-4045-a81c-fb03a7b3aacc",
            "mapping_index": 1,
            "structured_type": "structured",
            "detail_level": "medium"
        },
        "timestamp": "2025-08-16 22:49:57.000",
        "id": "rCi87VeNvxVLbGdu5TsI"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "94e232d8-8f75-4045-a81c-fb03a7b3aacc",
            "detail_level": "medium",
            "structured_type": "structured"
        },
        "timestamp": "2025-08-16 22:49:58.000",
        "id": "XJCRI3uqEyQmax64F0OK"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "94e232d8-8f75-4045-a81c-fb03a7b3aacc",
            "mapping_index": 3,
            "structured_type": "structured",
            "detail_level": "medium"
        },
        "timestamp": "2025-08-16 22:49:58.000",
        "id": "aKXb6m9jfKHgnY3haC6P"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "94e232d8-8f75-4045-a81c-fb03a7b3aacc",
            "mapping_index": 2,
            "structured_type": "structured",
            "detail_level": "medium"
        },
        "timestamp": "2025-08-16 22:49:58.000",
        "id": "dpgy0FOq3mceyagBBc7n"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "94e232d8-8f75-4045-a81c-fb03a7b3aacc",
            "detail_level": "medium",
            "structured_type": "structured"
        },
        "timestamp": "2025-08-16 22:49:58.000",
        "id": "pLH1WZtfxCDZkTBfE72C"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "94e232d8-8f75-4045-a81c-fb03a7b3aacc",
            "mapping_index": 2,
            "structured_type": "structured",
            "detail_level": "medium"
        },
        "timestamp": "2025-08-16 22:49:59.000",
        "id": "MD16pAuzr4E8mR8jriko"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "94e232d8-8f75-4045-a81c-fb03a7b3aacc",
            "mapping_index": 1,
            "structured_type": "structured",
            "detail_level": "medium"
        },
        "timestamp": "2025-08-16 22:49:59.000",
        "id": "MKrhP4RsBczR3Z55Rwp8"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "94e232d8-8f75-4045-a81c-fb03a7b3aacc",
            "detail_level": "medium",
            "structured_type": "structured"
        },
        "timestamp": "2025-08-16 22:49:59.000",
        "id": "QWD6l5EMFKiKBmyuGxHX"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "94e232d8-8f75-4045-a81c-fb03a7b3aacc",
            "mapping_index": 2,
            "structured_type": "structured",
            "detail_level": "medium"
        },
        "timestamp": "2025-08-16 22:49:59.000",
        "id": "YTfJj2RMA4wGGGbo6uus"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "94e232d8-8f75-4045-a81c-fb03a7b3aacc",
            "detail_level": "medium",
            "structured_type": "structured"
        },
        "timestamp": "2025-08-16 22:49:59.000",
        "id": "i61pMuKOejA0hxO9rDDq"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "94e232d8-8f75-4045-a81c-fb03a7b3aacc",
            "detail_level": "medium",
            "structured_type": "structured"
        },
        "timestamp": "2025-08-16 22:49:59.000",
        "id": "uyrop8b9CaW99XWEm5M0"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "94e232d8-8f75-4045-a81c-fb03a7b3aacc",
            "detail_level": "medium",
            "structured_type": "structured"
        },
        "timestamp": "2025-08-16 22:50:00.000",
        "id": "HcLSdmRsYVvaBT4Fwepu"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "94e232d8-8f75-4045-a81c-fb03a7b3aacc",
            "mapping_index": 3,
            "structured_type": "structured",
            "detail_level": "medium"
        },
        "timestamp": "2025-08-16 22:50:00.000",
        "id": "XLRdG5EInc2FgyUKNZW6"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "94e232d8-8f75-4045-a81c-fb03a7b3aacc",
            "detail_level": "medium",
            "structured_type": "structured"
        },
        "timestamp": "2025-08-16 22:50:00.000",
        "id": "cju8NOqAVoCjyXPm8t2C"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "94e232d8-8f75-4045-a81c-fb03a7b3aacc",
            "mapping_index": 4,
            "structured_type": "structured",
            "detail_level": "medium"
        },
        "timestamp": "2025-08-16 22:50:00.000",
        "id": "gAfY0ZHZE4tTeveZUapk"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "94e232d8-8f75-4045-a81c-fb03a7b3aacc",
            "detail_level": "medium",
            "structured_type": "structured"
        },
        "timestamp": "2025-08-16 22:50:01.000",
        "id": "7QkcacDNVUGhIOKIixJu"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "94e232d8-8f75-4045-a81c-fb03a7b3aacc",
            "mapping_index": 5,
            "structured_type": "structured",
            "detail_level": "medium"
        },
        "timestamp": "2025-08-16 22:50:01.000",
        "id": "AHqvo1CsTSw3BVfnAnzC"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "94e232d8-8f75-4045-a81c-fb03a7b3aacc",
            "mapping_index": 6,
            "structured_type": "structured",
            "detail_level": "medium"
        },
        "timestamp": "2025-08-16 22:50:01.000",
        "id": "OPzMSJrnKP90HHyBGX7C"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "94e232d8-8f75-4045-a81c-fb03a7b3aacc",
            "detail_level": "medium",
            "structured_type": "structured"
        },
        "timestamp": "2025-08-16 22:50:01.000",
        "id": "xoTAzX63zjSc2qphXQKT"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "94e232d8-8f75-4045-a81c-fb03a7b3aacc",
            "mapping_index": 5,
            "structured_type": "structured",
            "detail_level": "medium"
        },
        "timestamp": "2025-08-16 22:50:02.000",
        "id": "2wxan3dHAVQb3zmmjqbo"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "94e232d8-8f75-4045-a81c-fb03a7b3aacc",
            "mapping_index": 4,
            "structured_type": "structured",
            "detail_level": "medium"
        },
        "timestamp": "2025-08-16 22:50:02.000",
        "id": "67XlOWKxnOqNJeoSjF6O"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "94e232d8-8f75-4045-a81c-fb03a7b3aacc",
            "detail_level": "medium",
            "structured_type": "structured"
        },
        "timestamp": "2025-08-16 22:50:02.000",
        "id": "75YIFtOaBQrtz9mUpAVF"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "94e232d8-8f75-4045-a81c-fb03a7b3aacc",
            "mapping_index": 5,
            "structured_type": "structured",
            "detail_level": "medium"
        },
        "timestamp": "2025-08-16 22:50:02.000",
        "id": "BLXRwUsCgN4qRhIBSvSM"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "94e232d8-8f75-4045-a81c-fb03a7b3aacc",
            "detail_level": "medium",
            "structured_type": "structured"
        },
        "timestamp": "2025-08-16 22:50:02.000",
        "id": "mnHWgBUdyvf2u0Lw76M8"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "94e232d8-8f75-4045-a81c-fb03a7b3aacc",
            "detail_level": "medium",
            "structured_type": "structured"
        },
        "timestamp": "2025-08-16 22:50:02.000",
        "id": "nQfmVHMPp2crrFxeCAJI"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "94e232d8-8f75-4045-a81c-fb03a7b3aacc",
            "mapping_index": 6,
            "structured_type": "structured",
            "detail_level": "medium"
        },
        "timestamp": "2025-08-16 22:50:05.000",
        "id": "U5TUaCk72DboaarSkVsF"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "94e232d8-8f75-4045-a81c-fb03a7b3aacc",
            "mapping_index": 5,
            "structured_type": "structured",
            "detail_level": "medium"
        },
        "timestamp": "2025-08-16 22:50:05.000",
        "id": "odZMLcxhOtelqKanZPeN"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "94e232d8-8f75-4045-a81c-fb03a7b3aacc",
            "detail_level": "medium",
            "structured_type": "structured"
        },
        "timestamp": "2025-08-16 22:50:05.000",
        "id": "qnyU5eCO3VFMTYoHErKg"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "94e232d8-8f75-4045-a81c-fb03a7b3aacc",
            "detail_level": "medium",
            "structured_type": "structured"
        },
        "timestamp": "2025-08-16 22:50:05.000",
        "id": "yrQ9sa9WWgmZl3xdbsSr"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "94e232d8-8f75-4045-a81c-fb03a7b3aacc",
            "detail_level": "medium",
            "structured_type": "structured"
        },
        "timestamp": "2025-08-16 22:50:06.000",
        "id": "SC2soebMdgsWcLJ5qWu1"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "94e232d8-8f75-4045-a81c-fb03a7b3aacc",
            "mapping_index": 4,
            "structured_type": "structured",
            "detail_level": "medium"
        },
        "timestamp": "2025-08-16 22:50:06.000",
        "id": "cBeVd8qujSsTA6hpbtr8"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "94e232d8-8f75-4045-a81c-fb03a7b3aacc",
            "detail_level": "medium",
            "structured_type": "structured"
        },
        "timestamp": "2025-08-16 22:50:06.000",
        "id": "lQ2IdANjajQu1rh4qHRY"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "94e232d8-8f75-4045-a81c-fb03a7b3aacc",
            "detail_level": "medium",
            "structured_type": "structured"
        },
        "timestamp": "2025-08-16 22:50:06.000",
        "id": "paAa0z6oAEPvsCFwbszL"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "94e232d8-8f75-4045-a81c-fb03a7b3aacc",
            "mapping_index": 6,
            "structured_type": "structured",
            "detail_level": "medium"
        },
        "timestamp": "2025-08-16 22:50:06.000",
        "id": "sS9oCA5DvKZ9tNuoQOih"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "94e232d8-8f75-4045-a81c-fb03a7b3aacc",
            "mapping_index": 5,
            "structured_type": "structured",
            "detail_level": "medium"
        },
        "timestamp": "2025-08-16 22:50:06.000",
        "id": "tn2WPTkf1bVTbroM6yH9"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "94e232d8-8f75-4045-a81c-fb03a7b3aacc",
            "mapping_index": 5,
            "structured_type": "structured",
            "detail_level": "medium"
        },
        "timestamp": "2025-08-16 22:50:08.000",
        "id": "3oOux4mRqsI8TXQGa32S"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "94e232d8-8f75-4045-a81c-fb03a7b3aacc",
            "detail_level": "medium",
            "structured_type": "structured"
        },
        "timestamp": "2025-08-16 22:50:08.000",
        "id": "kftAOqPFnnsZ1eSQFgPK"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "94e232d8-8f75-4045-a81c-fb03a7b3aacc",
            "detail_level": "medium",
            "structured_type": "structured"
        },
        "timestamp": "2025-08-16 22:50:08.000",
        "id": "y6hYWZ0YiuyvN3e2XRQY"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "94e232d8-8f75-4045-a81c-fb03a7b3aacc",
            "mapping_index": 6,
            "structured_type": "structured",
            "detail_level": "medium"
        },
        "timestamp": "2025-08-16 22:50:08.000",
        "id": "zGqFpcRZYk7iFOPEDBIZ"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "94e232d8-8f75-4045-a81c-fb03a7b3aacc",
            "detail_level": "medium",
            "structured_type": "structured"
        },
        "timestamp": "2025-08-16 22:50:09.000",
        "id": "PKMFdPNGbYwDDM3Z0Y0v"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "94e232d8-8f75-4045-a81c-fb03a7b3aacc",
            "mapping_index": 4,
            "structured_type": "structured",
            "detail_level": "medium"
        },
        "timestamp": "2025-08-16 22:50:12.000",
        "id": "5dKhvNxKKGSyw02OMgGM"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "94e232d8-8f75-4045-a81c-fb03a7b3aacc",
            "detail_level": "medium",
            "structured_type": "structured"
        },
        "timestamp": "2025-08-16 22:50:12.000",
        "id": "aqQeSKYcFFY38jc4TCKw"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "94e232d8-8f75-4045-a81c-fb03a7b3aacc",
            "mapping_index": 0,
            "structured_type": "structured",
            "detail_level": "medium"
        },
        "timestamp": "2025-08-16 22:50:12.000",
        "id": "bkKIOesHJw71YRmeHkYs"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "94e232d8-8f75-4045-a81c-fb03a7b3aacc",
            "detail_level": "medium",
            "structured_type": "structured"
        },
        "timestamp": "2025-08-16 22:50:12.000",
        "id": "ujxWBJUn2vTYJV8jTg0X"
    },
    {
        "source": "frontend",
        "event": "change_summary_level",
        "data": {
            "before_detail_level": "medium",
            "section_id": "94e232d8-8f75-4045-a81c-fb03a7b3aacc",
            "before_structured": "structured",
            "after_structured": "structured",
            "after_detail_level": "low"
        },
        "timestamp": "2025-08-16 22:50:13.000",
        "id": "dCAR9poJwqZ2w5M0Xl5K"
    },
    {
        "source": "frontend",
        "event": "change_summary_level",
        "data": {
            "before_detail_level": "low",
            "section_id": "94e232d8-8f75-4045-a81c-fb03a7b3aacc",
            "before_structured": "structured",
            "after_structured": "structured",
            "after_detail_level": "medium"
        },
        "timestamp": "2025-08-16 22:50:13.000",
        "id": "pt78VaFSktTC8OUT88Yh"
    },
    {
        "source": "frontend",
        "event": "change_summary_level",
        "data": {
            "before_detail_level": "medium",
            "section_id": "94e232d8-8f75-4045-a81c-fb03a7b3aacc",
            "before_structured": "structured",
            "after_structured": "unstructured",
            "after_detail_level": "medium"
        },
        "timestamp": "2025-08-16 22:50:14.000",
        "id": "LtB2nK9shZVmcxl5CyWy"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "94e232d8-8f75-4045-a81c-fb03a7b3aacc",
            "mapping_index": 1,
            "structured_type": "unstructured",
            "detail_level": "medium"
        },
        "timestamp": "2025-08-16 22:50:15.000",
        "id": "PFTOEmbpFq0AHo48TfiA"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "94e232d8-8f75-4045-a81c-fb03a7b3aacc",
            "detail_level": "medium",
            "structured_type": "unstructured"
        },
        "timestamp": "2025-08-16 22:50:15.000",
        "id": "hfNMo8K70xfKrKXFerAt"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "94e232d8-8f75-4045-a81c-fb03a7b3aacc",
            "mapping_index": 0,
            "structured_type": "unstructured",
            "detail_level": "medium"
        },
        "timestamp": "2025-08-16 22:50:15.000",
        "id": "kNCabe8QAZSWiZ6waur9"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "94e232d8-8f75-4045-a81c-fb03a7b3aacc",
            "detail_level": "medium",
            "structured_type": "unstructured"
        },
        "timestamp": "2025-08-16 22:50:17.000",
        "id": "LarzOub52zuSrRjyrdJS"
    },
    {
        "source": "frontend",
        "event": "change_summary_level",
        "data": {
            "before_detail_level": "medium",
            "section_id": "94e232d8-8f75-4045-a81c-fb03a7b3aacc",
            "before_structured": "unstructured",
            "after_structured": "structured",
            "after_detail_level": "medium"
        },
        "timestamp": "2025-08-16 22:50:17.000",
        "id": "mpWaOOTstymMcSpOb7wt"
    },
    {
        "source": "frontend",
        "event": "change_summary_level",
        "data": {
            "before_detail_level": "medium",
            "section_id": "94e232d8-8f75-4045-a81c-fb03a7b3aacc",
            "before_structured": "structured",
            "after_structured": "unstructured",
            "after_detail_level": "medium"
        },
        "timestamp": "2025-08-16 22:50:19.000",
        "id": "8gBzamFjBMGr2C4GyFk9"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "94e232d8-8f75-4045-a81c-fb03a7b3aacc",
            "detail_level": "medium",
            "structured_type": "unstructured"
        },
        "timestamp": "2025-08-16 22:50:20.000",
        "id": "22ocDs0uVpavYOvicagN"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "94e232d8-8f75-4045-a81c-fb03a7b3aacc",
            "detail_level": "medium",
            "structured_type": "unstructured"
        },
        "timestamp": "2025-08-16 22:50:20.000",
        "id": "25Hlqas8ZcPQXP7xSKEF"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "94e232d8-8f75-4045-a81c-fb03a7b3aacc",
            "mapping_index": 0,
            "structured_type": "unstructured",
            "detail_level": "medium"
        },
        "timestamp": "2025-08-16 22:50:20.000",
        "id": "3kLzrJcBucjqyypLVFR8"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "94e232d8-8f75-4045-a81c-fb03a7b3aacc",
            "detail_level": "medium",
            "structured_type": "unstructured"
        },
        "timestamp": "2025-08-16 22:50:20.000",
        "id": "5UMKTo0eEIPGqIv58y1B"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "94e232d8-8f75-4045-a81c-fb03a7b3aacc",
            "mapping_index": 2,
            "structured_type": "unstructured",
            "detail_level": "medium"
        },
        "timestamp": "2025-08-16 22:50:20.000",
        "id": "8fwGAXzPB31Tc4zaDveB"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "94e232d8-8f75-4045-a81c-fb03a7b3aacc",
            "mapping_index": 1,
            "structured_type": "unstructured",
            "detail_level": "medium"
        },
        "timestamp": "2025-08-16 22:50:20.000",
        "id": "YCCJdmdjEQSRtAVOFtQn"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "94e232d8-8f75-4045-a81c-fb03a7b3aacc",
            "mapping_index": 0,
            "structured_type": "unstructured",
            "detail_level": "medium"
        },
        "timestamp": "2025-08-16 22:50:20.000",
        "id": "ytOYXePvtvd8NkO1852i"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "94e232d8-8f75-4045-a81c-fb03a7b3aacc",
            "detail_level": "medium",
            "structured_type": "unstructured"
        },
        "timestamp": "2025-08-16 22:50:20.000",
        "id": "zedqioiHHW9flprjXkWG"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "94e232d8-8f75-4045-a81c-fb03a7b3aacc",
            "detail_level": "medium",
            "structured_type": "unstructured"
        },
        "timestamp": "2025-08-16 22:50:21.000",
        "id": "UdAZmR1m2TUUv6PpvHDI"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "94e232d8-8f75-4045-a81c-fb03a7b3aacc",
            "mapping_index": 1,
            "structured_type": "unstructured",
            "detail_level": "medium"
        },
        "timestamp": "2025-08-16 22:50:21.000",
        "id": "nRMlEOkXlLZOf2pk1isC"
    },
    {
        "source": "frontend",
        "event": "change_summary_level",
        "data": {
            "before_detail_level": "medium",
            "section_id": "94e232d8-8f75-4045-a81c-fb03a7b3aacc",
            "before_structured": "unstructured",
            "after_structured": "unstructured",
            "after_detail_level": "high"
        },
        "timestamp": "2025-08-16 22:50:22.000",
        "id": "kEXqQBJUhE0aSAewvKHF"
    },
    {
        "source": "frontend",
        "event": "change_summary_level",
        "data": {
            "before_detail_level": "high",
            "section_id": "94e232d8-8f75-4045-a81c-fb03a7b3aacc",
            "before_structured": "unstructured",
            "after_structured": "unstructured",
            "after_detail_level": "medium"
        },
        "timestamp": "2025-08-16 22:50:23.000",
        "id": "gOEHfFYWwpwdcOkgKMhX"
    },
    {
        "source": "frontend",
        "event": "change_summary_level",
        "data": {
            "before_detail_level": "medium",
            "section_id": "94e232d8-8f75-4045-a81c-fb03a7b3aacc",
            "before_structured": "unstructured",
            "after_structured": "unstructured",
            "after_detail_level": "high"
        },
        "timestamp": "2025-08-16 22:50:27.000",
        "id": "oSKuiqEvQPF9QviVXDBX"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "94e232d8-8f75-4045-a81c-fb03a7b3aacc",
            "mapping_index": 0,
            "structured_type": "unstructured",
            "detail_level": "high"
        },
        "timestamp": "2025-08-16 22:50:30.000",
        "id": "6l4sAVDG2MiATg7DpM7l"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "94e232d8-8f75-4045-a81c-fb03a7b3aacc",
            "detail_level": "high",
            "structured_type": "unstructured"
        },
        "timestamp": "2025-08-16 22:50:30.000",
        "id": "JAW7aDy9MUrZKw2ON6JF"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "94e232d8-8f75-4045-a81c-fb03a7b3aacc",
            "mapping_index": 2,
            "structured_type": "unstructured",
            "detail_level": "high"
        },
        "timestamp": "2025-08-16 22:50:30.000",
        "id": "ecY8FxLjdPWDqfw2sRWo"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "94e232d8-8f75-4045-a81c-fb03a7b3aacc",
            "detail_level": "high",
            "structured_type": "unstructured"
        },
        "timestamp": "2025-08-16 22:50:32.000",
        "id": "TruLnqn2C4x6sZEjWoDZ"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "94e232d8-8f75-4045-a81c-fb03a7b3aacc",
            "mapping_index": 0,
            "structured_type": "unstructured",
            "detail_level": "high"
        },
        "timestamp": "2025-08-16 22:50:32.000",
        "id": "rDRJMDffGXu1kU13x1KQ"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "94e232d8-8f75-4045-a81c-fb03a7b3aacc",
            "mapping_index": 0,
            "structured_type": "unstructured",
            "detail_level": "high"
        },
        "timestamp": "2025-08-16 22:50:33.000",
        "id": "0kJd489Rr5WrnunKYnM0"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "94e232d8-8f75-4045-a81c-fb03a7b3aacc",
            "detail_level": "high",
            "structured_type": "unstructured"
        },
        "timestamp": "2025-08-16 22:50:33.000",
        "id": "Mm2nHnCJqILbPkH4EUtw"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "94e232d8-8f75-4045-a81c-fb03a7b3aacc",
            "mapping_index": 0,
            "structured_type": "unstructured",
            "detail_level": "high"
        },
        "timestamp": "2025-08-16 22:50:33.000",
        "id": "eGPZlUOW4HZfQgtcJMwX"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "94e232d8-8f75-4045-a81c-fb03a7b3aacc",
            "detail_level": "high",
            "structured_type": "unstructured"
        },
        "timestamp": "2025-08-16 22:50:33.000",
        "id": "jU0nTxMFX39obB1JwrRN"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "94e232d8-8f75-4045-a81c-fb03a7b3aacc",
            "mapping_index": 1,
            "structured_type": "unstructured",
            "detail_level": "high"
        },
        "timestamp": "2025-08-16 22:50:33.000",
        "id": "o04PFTkBfwn2kgoLhuz8"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "94e232d8-8f75-4045-a81c-fb03a7b3aacc",
            "mapping_index": 1,
            "structured_type": "unstructured",
            "detail_level": "high"
        },
        "timestamp": "2025-08-16 22:50:33.000",
        "id": "s5ZX1CXoeO7j9rYpf7m1"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "94e232d8-8f75-4045-a81c-fb03a7b3aacc",
            "detail_level": "high",
            "structured_type": "unstructured"
        },
        "timestamp": "2025-08-16 22:50:33.000",
        "id": "tspdbqnkWi2Z4ZiqCkz3"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "94e232d8-8f75-4045-a81c-fb03a7b3aacc",
            "detail_level": "high",
            "structured_type": "unstructured"
        },
        "timestamp": "2025-08-16 22:50:33.000",
        "id": "vvtXfncCkfrV9KLtbbIu"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "94e232d8-8f75-4045-a81c-fb03a7b3aacc",
            "detail_level": "high",
            "structured_type": "unstructured"
        },
        "timestamp": "2025-08-16 22:50:34.000",
        "id": "2lwGJ1fno0sHbw80gqkR"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "94e232d8-8f75-4045-a81c-fb03a7b3aacc",
            "mapping_index": 0,
            "structured_type": "unstructured",
            "detail_level": "high"
        },
        "timestamp": "2025-08-16 22:50:34.000",
        "id": "4kARaDN8rRJiETW8Ee8M"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "94e232d8-8f75-4045-a81c-fb03a7b3aacc",
            "mapping_index": 8,
            "structured_type": "unstructured",
            "detail_level": "high"
        },
        "timestamp": "2025-08-16 22:50:34.000",
        "id": "8D3c3zvykd2y5CfgMBTH"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "94e232d8-8f75-4045-a81c-fb03a7b3aacc",
            "detail_level": "high",
            "structured_type": "unstructured"
        },
        "timestamp": "2025-08-16 22:50:34.000",
        "id": "UqisSiiRuFtiI0jYpVOG"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "94e232d8-8f75-4045-a81c-fb03a7b3aacc",
            "detail_level": "high",
            "structured_type": "unstructured"
        },
        "timestamp": "2025-08-16 22:50:34.000",
        "id": "Z3KQmVnpOHqjgHr8lRc7"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "94e232d8-8f75-4045-a81c-fb03a7b3aacc",
            "mapping_index": 5,
            "structured_type": "unstructured",
            "detail_level": "high"
        },
        "timestamp": "2025-08-16 22:50:34.000",
        "id": "aJIsacyeZ7Fy7r7GjsVD"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "94e232d8-8f75-4045-a81c-fb03a7b3aacc",
            "detail_level": "high",
            "structured_type": "unstructured"
        },
        "timestamp": "2025-08-16 22:50:34.000",
        "id": "fcx6HrZ9A05h8Szjy3kU"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "94e232d8-8f75-4045-a81c-fb03a7b3aacc",
            "detail_level": "high",
            "structured_type": "unstructured"
        },
        "timestamp": "2025-08-16 22:50:34.000",
        "id": "fwgczM2MOTRy0RJS05JE"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "94e232d8-8f75-4045-a81c-fb03a7b3aacc",
            "mapping_index": 5,
            "structured_type": "unstructured",
            "detail_level": "high"
        },
        "timestamp": "2025-08-16 22:50:34.000",
        "id": "j4RMwAgjmF6EfFUgVxKf"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "94e232d8-8f75-4045-a81c-fb03a7b3aacc",
            "detail_level": "high",
            "structured_type": "unstructured"
        },
        "timestamp": "2025-08-16 22:50:34.000",
        "id": "qaWOzjoTCpoFpNFqko20"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "94e232d8-8f75-4045-a81c-fb03a7b3aacc",
            "detail_level": "high",
            "structured_type": "unstructured"
        },
        "timestamp": "2025-08-16 22:50:34.000",
        "id": "qfliU5EIY41QK9J3Dz1w"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "94e232d8-8f75-4045-a81c-fb03a7b3aacc",
            "mapping_index": 6,
            "structured_type": "unstructured",
            "detail_level": "high"
        },
        "timestamp": "2025-08-16 22:50:34.000",
        "id": "w1n0HUdGZTfsI4cFh4pr"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "94e232d8-8f75-4045-a81c-fb03a7b3aacc",
            "mapping_index": 6,
            "structured_type": "unstructured",
            "detail_level": "high"
        },
        "timestamp": "2025-08-16 22:50:34.000",
        "id": "xHJTxxMswCVZkCbqlKHF"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "94e232d8-8f75-4045-a81c-fb03a7b3aacc",
            "mapping_index": 0,
            "structured_type": "unstructured",
            "detail_level": "high"
        },
        "timestamp": "2025-08-16 22:50:35.000",
        "id": "1p6numnq9KlwRrPpn4Yk"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "94e232d8-8f75-4045-a81c-fb03a7b3aacc",
            "detail_level": "high",
            "structured_type": "unstructured"
        },
        "timestamp": "2025-08-16 22:50:36.000",
        "id": "Pvr9DRKMZlOAhNfn4PwP"
    },
    {
        "source": "frontend",
        "event": "change_summary_level",
        "data": {
            "before_detail_level": "high",
            "section_id": "94e232d8-8f75-4045-a81c-fb03a7b3aacc",
            "before_structured": "unstructured",
            "after_structured": "unstructured",
            "after_detail_level": "medium"
        },
        "timestamp": "2025-08-16 22:50:36.000",
        "id": "rxmiSkkmej4lpjd77V13"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "94e232d8-8f75-4045-a81c-fb03a7b3aacc",
            "mapping_index": 0,
            "structured_type": "unstructured",
            "detail_level": "medium"
        },
        "timestamp": "2025-08-16 22:50:37.000",
        "id": "k28c2V17vwW28sYU2GSL"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "94e232d8-8f75-4045-a81c-fb03a7b3aacc",
            "detail_level": "medium",
            "structured_type": "unstructured"
        },
        "timestamp": "2025-08-16 22:50:38.000",
        "id": "wBNwH0bSbnzv3r1Fptlw"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "94e232d8-8f75-4045-a81c-fb03a7b3aacc",
            "mapping_index": 1,
            "structured_type": "unstructured",
            "detail_level": "medium"
        },
        "timestamp": "2025-08-16 22:50:38.000",
        "id": "wdJaZiES3zrdZfeHayRo"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "94e232d8-8f75-4045-a81c-fb03a7b3aacc",
            "mapping_index": 3,
            "structured_type": "unstructured",
            "detail_level": "medium"
        },
        "timestamp": "2025-08-16 22:50:39.000",
        "id": "AdzON0Lp2zmpo0PWiKTA"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "94e232d8-8f75-4045-a81c-fb03a7b3aacc",
            "detail_level": "medium",
            "structured_type": "unstructured"
        },
        "timestamp": "2025-08-16 22:50:39.000",
        "id": "Mjxu0o2M2xw0EdKoDWG8"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "94e232d8-8f75-4045-a81c-fb03a7b3aacc",
            "detail_level": "medium",
            "structured_type": "unstructured"
        },
        "timestamp": "2025-08-16 22:50:40.000",
        "id": "9clEkVZM7dduItow6pfp"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "94e232d8-8f75-4045-a81c-fb03a7b3aacc",
            "mapping_index": 1,
            "structured_type": "unstructured",
            "detail_level": "medium"
        },
        "timestamp": "2025-08-16 22:50:40.000",
        "id": "DQQU8u627AUJSXz1cj2O"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "94e232d8-8f75-4045-a81c-fb03a7b3aacc",
            "detail_level": "medium",
            "structured_type": "unstructured"
        },
        "timestamp": "2025-08-16 22:50:52.000",
        "id": "DXPEp3exT5I8ydICyY2H"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "94e232d8-8f75-4045-a81c-fb03a7b3aacc",
            "mapping_index": 3,
            "structured_type": "unstructured",
            "detail_level": "medium"
        },
        "timestamp": "2025-08-16 22:50:52.000",
        "id": "FqWQJmAwa04xvbk5FIGS"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "94e232d8-8f75-4045-a81c-fb03a7b3aacc",
            "detail_level": "medium",
            "structured_type": "unstructured"
        },
        "timestamp": "2025-08-16 22:50:52.000",
        "id": "ZzETVdnWhnUi2vC554W8"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "94e232d8-8f75-4045-a81c-fb03a7b3aacc",
            "mapping_index": 1,
            "structured_type": "unstructured",
            "detail_level": "medium"
        },
        "timestamp": "2025-08-16 22:50:52.000",
        "id": "oLaMw02u1dKO6whxEvaT"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "94e232d8-8f75-4045-a81c-fb03a7b3aacc",
            "mapping_index": 0,
            "structured_type": "unstructured",
            "detail_level": "medium"
        },
        "timestamp": "2025-08-16 22:50:57.000",
        "id": "DC4yxIqpsHemF6Sc5MIt"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "94e232d8-8f75-4045-a81c-fb03a7b3aacc",
            "detail_level": "medium",
            "structured_type": "unstructured"
        },
        "timestamp": "2025-08-16 22:50:57.000",
        "id": "SiUW34qtq2ocIB6ZdOnh"
    },
    {
        "source": "frontend",
        "event": "change_summary_level",
        "data": {
            "before_detail_level": "medium",
            "section_id": "94e232d8-8f75-4045-a81c-fb03a7b3aacc",
            "before_structured": "unstructured",
            "after_structured": "structured",
            "after_detail_level": "medium"
        },
        "timestamp": "2025-08-16 22:50:58.000",
        "id": "9DcbfgvImdAawpl7GtSd"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "94e232d8-8f75-4045-a81c-fb03a7b3aacc",
            "detail_level": "medium",
            "structured_type": "unstructured"
        },
        "timestamp": "2025-08-16 22:50:58.000",
        "id": "N46UZC622I5ve6Mkj15S"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "94e232d8-8f75-4045-a81c-fb03a7b3aacc",
            "mapping_index": 1,
            "structured_type": "structured",
            "detail_level": "medium"
        },
        "timestamp": "2025-08-16 22:50:59.000",
        "id": "9o7lRTLlr2dyS44Kmy2o"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "94e232d8-8f75-4045-a81c-fb03a7b3aacc",
            "mapping_index": 0,
            "structured_type": "structured",
            "detail_level": "medium"
        },
        "timestamp": "2025-08-16 22:50:59.000",
        "id": "E817vfPMrzs0aEwVut5X"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "94e232d8-8f75-4045-a81c-fb03a7b3aacc",
            "detail_level": "medium",
            "structured_type": "structured"
        },
        "timestamp": "2025-08-16 22:50:59.000",
        "id": "MA28Yfwx3zq39z2HMUBE"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "94e232d8-8f75-4045-a81c-fb03a7b3aacc",
            "mapping_index": 0,
            "structured_type": "structured",
            "detail_level": "medium"
        },
        "timestamp": "2025-08-16 22:51:00.000",
        "id": "DMCjfkU3P5bfgljuxybG"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "94e232d8-8f75-4045-a81c-fb03a7b3aacc",
            "detail_level": "medium",
            "structured_type": "structured"
        },
        "timestamp": "2025-08-16 22:51:00.000",
        "id": "rsDNPtE6aQHDtpYKdEUE"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "94e232d8-8f75-4045-a81c-fb03a7b3aacc",
            "detail_level": "medium",
            "structured_type": "structured"
        },
        "timestamp": "2025-08-16 22:51:03.000",
        "id": "6FCDAGIVtgx4eojrp0G5"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "94e232d8-8f75-4045-a81c-fb03a7b3aacc",
            "mapping_index": 0,
            "structured_type": "structured",
            "detail_level": "medium"
        },
        "timestamp": "2025-08-16 22:51:03.000",
        "id": "No0s9XNDCVkujNKuxP2h"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "94e232d8-8f75-4045-a81c-fb03a7b3aacc",
            "detail_level": "medium",
            "structured_type": "structured"
        },
        "timestamp": "2025-08-16 22:51:03.000",
        "id": "r9Cancsn8z6XfVYdX6vU"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "94e232d8-8f75-4045-a81c-fb03a7b3aacc",
            "mapping_index": 1,
            "structured_type": "structured",
            "detail_level": "medium"
        },
        "timestamp": "2025-08-16 22:51:03.000",
        "id": "rYj8BVznOJH8K1YfybYp"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "94e232d8-8f75-4045-a81c-fb03a7b3aacc",
            "detail_level": "medium",
            "structured_type": "structured"
        },
        "timestamp": "2025-08-16 22:51:04.000",
        "id": "mTnHOuCzZ35ADmak9yP1"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "94e232d8-8f75-4045-a81c-fb03a7b3aacc",
            "detail_level": "medium",
            "structured_type": "structured"
        },
        "timestamp": "2025-08-16 22:51:07.000",
        "id": "ZH0T0p5bCtc0otJ5JKEb"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "94e232d8-8f75-4045-a81c-fb03a7b3aacc",
            "mapping_index": 2,
            "structured_type": "structured",
            "detail_level": "medium"
        },
        "timestamp": "2025-08-16 22:51:07.000",
        "id": "bnN3w7tWTg0X78HXtRel"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "94e232d8-8f75-4045-a81c-fb03a7b3aacc",
            "detail_level": "medium",
            "structured_type": "structured"
        },
        "timestamp": "2025-08-16 22:51:08.000",
        "id": "c7qrDioiAC1d29Yb7VWP"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "94e232d8-8f75-4045-a81c-fb03a7b3aacc",
            "mapping_index": 0,
            "structured_type": "structured",
            "detail_level": "medium"
        },
        "timestamp": "2025-08-16 22:51:08.000",
        "id": "sd9GvGymq4xIsT6uXlpD"
    },
    {
        "source": "frontend",
        "event": "change_summary_level",
        "data": {
            "before_detail_level": "medium",
            "section_id": "94e232d8-8f75-4045-a81c-fb03a7b3aacc",
            "before_structured": "structured",
            "after_structured": "structured",
            "after_detail_level": "low"
        },
        "timestamp": "2025-08-16 22:51:09.000",
        "id": "ET7N2aS5qrw7BpbbgVBG"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "94e232d8-8f75-4045-a81c-fb03a7b3aacc",
            "detail_level": "low",
            "structured_type": "structured"
        },
        "timestamp": "2025-08-16 22:51:10.000",
        "id": "0WQ6JS51JnB50kaRanwd"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "94e232d8-8f75-4045-a81c-fb03a7b3aacc",
            "detail_level": "low",
            "structured_type": "structured"
        },
        "timestamp": "2025-08-16 22:51:10.000",
        "id": "6KEeP3MirqpADqdMEqkW"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "94e232d8-8f75-4045-a81c-fb03a7b3aacc",
            "mapping_index": 1,
            "structured_type": "structured",
            "detail_level": "low"
        },
        "timestamp": "2025-08-16 22:51:10.000",
        "id": "CvgQWvQxTwkcDGkkRryW"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "94e232d8-8f75-4045-a81c-fb03a7b3aacc",
            "mapping_index": 2,
            "structured_type": "structured",
            "detail_level": "low"
        },
        "timestamp": "2025-08-16 22:51:10.000",
        "id": "KkRPqc10mY2X062tnndn"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "94e232d8-8f75-4045-a81c-fb03a7b3aacc",
            "detail_level": "low",
            "structured_type": "structured"
        },
        "timestamp": "2025-08-16 22:51:10.000",
        "id": "KqjcGZ7rfGLrcNAvyqfR"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "94e232d8-8f75-4045-a81c-fb03a7b3aacc",
            "mapping_index": 0,
            "structured_type": "structured",
            "detail_level": "low"
        },
        "timestamp": "2025-08-16 22:51:10.000",
        "id": "PryQQo9mWOAPcqpa6kwg"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "94e232d8-8f75-4045-a81c-fb03a7b3aacc",
            "mapping_index": 0,
            "structured_type": "structured",
            "detail_level": "low"
        },
        "timestamp": "2025-08-16 22:51:10.000",
        "id": "TAhRHmm5aZkGbygPT3MS"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "94e232d8-8f75-4045-a81c-fb03a7b3aacc",
            "mapping_index": 2,
            "structured_type": "structured",
            "detail_level": "low"
        },
        "timestamp": "2025-08-16 22:51:10.000",
        "id": "VckrUcM1TaGfictS11FL"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "94e232d8-8f75-4045-a81c-fb03a7b3aacc",
            "detail_level": "low",
            "structured_type": "structured"
        },
        "timestamp": "2025-08-16 22:51:10.000",
        "id": "xhdTRGVrTMPmtngbGY8f"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "94e232d8-8f75-4045-a81c-fb03a7b3aacc",
            "detail_level": "low",
            "structured_type": "structured"
        },
        "timestamp": "2025-08-16 22:51:10.000",
        "id": "yj7ToZGvgpqeHNFOuldo"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "94e232d8-8f75-4045-a81c-fb03a7b3aacc",
            "mapping_index": 1,
            "structured_type": "structured",
            "detail_level": "low"
        },
        "timestamp": "2025-08-16 22:51:10.000",
        "id": "zTqP7Jtbdmdjew2DxjmB"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "94e232d8-8f75-4045-a81c-fb03a7b3aacc",
            "detail_level": "low",
            "structured_type": "structured"
        },
        "timestamp": "2025-08-16 22:51:11.000",
        "id": "L99YFTxY5jVD5iDmHbST"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "94e232d8-8f75-4045-a81c-fb03a7b3aacc",
            "mapping_index": 1,
            "structured_type": "structured",
            "detail_level": "low"
        },
        "timestamp": "2025-08-16 22:51:11.000",
        "id": "gPKgghOSSYoaoQd5HJn4"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "94e232d8-8f75-4045-a81c-fb03a7b3aacc",
            "mapping_index": 2,
            "structured_type": "structured",
            "detail_level": "low"
        },
        "timestamp": "2025-08-16 22:51:11.000",
        "id": "ySeuY8meZL6hmgq1RRHr"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "94e232d8-8f75-4045-a81c-fb03a7b3aacc",
            "detail_level": "low",
            "structured_type": "structured"
        },
        "timestamp": "2025-08-16 22:51:11.000",
        "id": "z7ueZk0Cb7mIxLW4tTfR"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "94e232d8-8f75-4045-a81c-fb03a7b3aacc",
            "detail_level": "low",
            "structured_type": "structured"
        },
        "timestamp": "2025-08-16 22:51:12.000",
        "id": "13wG8PsGilRy6XOCF6VV"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "94e232d8-8f75-4045-a81c-fb03a7b3aacc",
            "detail_level": "low",
            "structured_type": "structured"
        },
        "timestamp": "2025-08-16 22:51:12.000",
        "id": "9AWOB5mgAYgz4kRKrsGV"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "94e232d8-8f75-4045-a81c-fb03a7b3aacc",
            "mapping_index": 0,
            "structured_type": "structured",
            "detail_level": "low"
        },
        "timestamp": "2025-08-16 22:51:12.000",
        "id": "gCNliQh6mUoFpNblF4e9"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "94e232d8-8f75-4045-a81c-fb03a7b3aacc",
            "detail_level": "low",
            "structured_type": "structured"
        },
        "timestamp": "2025-08-16 22:51:12.000",
        "id": "mLHSIwAATrcEgbzuLBBr"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "94e232d8-8f75-4045-a81c-fb03a7b3aacc",
            "mapping_index": 1,
            "structured_type": "structured",
            "detail_level": "low"
        },
        "timestamp": "2025-08-16 22:51:12.000",
        "id": "vCe90rDH9JggzmW6SyxD"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "94e232d8-8f75-4045-a81c-fb03a7b3aacc",
            "detail_level": "low",
            "structured_type": "unstructured"
        },
        "timestamp": "2025-08-16 22:51:13.000",
        "id": "0xzdSRvoXMsDAlQ1cxpB"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "94e232d8-8f75-4045-a81c-fb03a7b3aacc",
            "mapping_index": 2,
            "structured_type": "unstructured",
            "detail_level": "low"
        },
        "timestamp": "2025-08-16 22:51:13.000",
        "id": "8PeWaopOcYstZQpdL3zq"
    },
    {
        "source": "frontend",
        "event": "change_summary_level",
        "data": {
            "before_detail_level": "low",
            "section_id": "94e232d8-8f75-4045-a81c-fb03a7b3aacc",
            "before_structured": "structured",
            "after_structured": "unstructured",
            "after_detail_level": "low"
        },
        "timestamp": "2025-08-16 22:51:13.000",
        "id": "CmgFrzOTbKf4uDz8YwNq"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "94e232d8-8f75-4045-a81c-fb03a7b3aacc",
            "mapping_index": 1,
            "structured_type": "unstructured",
            "detail_level": "low"
        },
        "timestamp": "2025-08-16 22:51:13.000",
        "id": "DLrLrQLmYAdfxZmHeVCd"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "94e232d8-8f75-4045-a81c-fb03a7b3aacc",
            "detail_level": "low",
            "structured_type": "unstructured"
        },
        "timestamp": "2025-08-16 22:51:13.000",
        "id": "FRXloCXrhLdzVRu6sxil"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "94e232d8-8f75-4045-a81c-fb03a7b3aacc",
            "detail_level": "low",
            "structured_type": "unstructured"
        },
        "timestamp": "2025-08-16 22:51:13.000",
        "id": "KPxvhkqSWQ0LV8L6tWdL"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "94e232d8-8f75-4045-a81c-fb03a7b3aacc",
            "mapping_index": 2,
            "structured_type": "unstructured",
            "detail_level": "low"
        },
        "timestamp": "2025-08-16 22:51:13.000",
        "id": "YiZiCBTInY2NCNuBiaDi"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "94e232d8-8f75-4045-a81c-fb03a7b3aacc",
            "detail_level": "low",
            "structured_type": "unstructured"
        },
        "timestamp": "2025-08-16 22:51:13.000",
        "id": "cQ3nDejAxN6ZGtNd8BA7"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "94e232d8-8f75-4045-a81c-fb03a7b3aacc",
            "mapping_index": 1,
            "structured_type": "unstructured",
            "detail_level": "low"
        },
        "timestamp": "2025-08-16 22:51:13.000",
        "id": "eOOwTsPoXXkF98ee4p02"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "94e232d8-8f75-4045-a81c-fb03a7b3aacc",
            "mapping_index": 0,
            "structured_type": "unstructured",
            "detail_level": "low"
        },
        "timestamp": "2025-08-16 22:51:13.000",
        "id": "f5AVpoe33Bjm6a4oC6gA"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "94e232d8-8f75-4045-a81c-fb03a7b3aacc",
            "detail_level": "low",
            "structured_type": "unstructured"
        },
        "timestamp": "2025-08-16 22:51:14.000",
        "id": "7A3muDpvTuoSdAth05Gj"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "94e232d8-8f75-4045-a81c-fb03a7b3aacc",
            "mapping_index": 1,
            "structured_type": "unstructured",
            "detail_level": "low"
        },
        "timestamp": "2025-08-16 22:51:14.000",
        "id": "CPZegfXB0CsntEqjSFUa"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "94e232d8-8f75-4045-a81c-fb03a7b3aacc",
            "mapping_index": 2,
            "structured_type": "unstructured",
            "detail_level": "low"
        },
        "timestamp": "2025-08-16 22:51:14.000",
        "id": "F1efLN7APYk1DFXSEC5i"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "94e232d8-8f75-4045-a81c-fb03a7b3aacc",
            "detail_level": "low",
            "structured_type": "unstructured"
        },
        "timestamp": "2025-08-16 22:51:14.000",
        "id": "GiVascGMgw4ce32v3rF4"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "94e232d8-8f75-4045-a81c-fb03a7b3aacc",
            "mapping_index": 4,
            "structured_type": "unstructured",
            "detail_level": "low"
        },
        "timestamp": "2025-08-16 22:51:14.000",
        "id": "IJcdYuzdNIf8EhdVNp3Y"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "94e232d8-8f75-4045-a81c-fb03a7b3aacc",
            "detail_level": "low",
            "structured_type": "unstructured"
        },
        "timestamp": "2025-08-16 22:51:14.000",
        "id": "KreKRY7xFlAAgzOL2wkR"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "94e232d8-8f75-4045-a81c-fb03a7b3aacc",
            "mapping_index": 3,
            "structured_type": "unstructured",
            "detail_level": "low"
        },
        "timestamp": "2025-08-16 22:51:14.000",
        "id": "S9n74UdVFbpjnEDTnWE1"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "94e232d8-8f75-4045-a81c-fb03a7b3aacc",
            "mapping_index": 3,
            "structured_type": "unstructured",
            "detail_level": "low"
        },
        "timestamp": "2025-08-16 22:51:14.000",
        "id": "gB4r9fIg6owfZDDGRXRt"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "94e232d8-8f75-4045-a81c-fb03a7b3aacc",
            "detail_level": "low",
            "structured_type": "unstructured"
        },
        "timestamp": "2025-08-16 22:51:14.000",
        "id": "kuozczcJpQ5aBdz1zOK7"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "94e232d8-8f75-4045-a81c-fb03a7b3aacc",
            "detail_level": "low",
            "structured_type": "unstructured"
        },
        "timestamp": "2025-08-16 22:51:14.000",
        "id": "mqDoTHVv78wqn8GQa8Xm"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "94e232d8-8f75-4045-a81c-fb03a7b3aacc",
            "detail_level": "low",
            "structured_type": "unstructured"
        },
        "timestamp": "2025-08-16 22:51:14.000",
        "id": "sbGsE0sSwJt8kMA7LDex"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "94e232d8-8f75-4045-a81c-fb03a7b3aacc",
            "detail_level": "low",
            "structured_type": "unstructured"
        },
        "timestamp": "2025-08-16 22:51:16.000",
        "id": "53uxYfIY5LO2bbOKUtB9"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "94e232d8-8f75-4045-a81c-fb03a7b3aacc",
            "mapping_index": 3,
            "structured_type": "unstructured",
            "detail_level": "low"
        },
        "timestamp": "2025-08-16 22:51:16.000",
        "id": "8QdqZytNqwPyjJEyprDz"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "94e232d8-8f75-4045-a81c-fb03a7b3aacc",
            "mapping_index": 4,
            "structured_type": "unstructured",
            "detail_level": "low"
        },
        "timestamp": "2025-08-16 22:51:16.000",
        "id": "NZe98RjLKynUJZH2wr34"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "94e232d8-8f75-4045-a81c-fb03a7b3aacc",
            "mapping_index": 2,
            "structured_type": "unstructured",
            "detail_level": "low"
        },
        "timestamp": "2025-08-16 22:51:16.000",
        "id": "kFzbym5EiIhDbpzLbDvg"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "94e232d8-8f75-4045-a81c-fb03a7b3aacc",
            "detail_level": "low",
            "structured_type": "unstructured"
        },
        "timestamp": "2025-08-16 22:51:16.000",
        "id": "tBVCg7s3Brt8eCO9dICJ"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "94e232d8-8f75-4045-a81c-fb03a7b3aacc",
            "detail_level": "low",
            "structured_type": "unstructured"
        },
        "timestamp": "2025-08-16 22:51:16.000",
        "id": "td9Q8QdeCGwMaIiIIWc2"
    },
    {
        "source": "frontend",
        "event": "change_summary_level",
        "data": {
            "before_detail_level": "low",
            "section_id": "94e232d8-8f75-4045-a81c-fb03a7b3aacc",
            "before_structured": "unstructured",
            "after_structured": "unstructured",
            "after_detail_level": "medium"
        },
        "timestamp": "2025-08-16 22:51:19.000",
        "id": "3uPDEpMrTzwVbtKFnKat"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "94e232d8-8f75-4045-a81c-fb03a7b3aacc",
            "mapping_index": 0,
            "structured_type": "unstructured",
            "detail_level": "medium"
        },
        "timestamp": "2025-08-16 22:51:20.000",
        "id": "VPbrsN1p5YkImyEzHCfe"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "94e232d8-8f75-4045-a81c-fb03a7b3aacc",
            "mapping_index": 1,
            "structured_type": "unstructured",
            "detail_level": "medium"
        },
        "timestamp": "2025-08-16 22:51:21.000",
        "id": "5j95Tptevg2z7IxYyx2d"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "94e232d8-8f75-4045-a81c-fb03a7b3aacc",
            "detail_level": "medium",
            "structured_type": "unstructured"
        },
        "timestamp": "2025-08-16 22:51:21.000",
        "id": "X3JocsKPWGjoMu76I2zv"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "94e232d8-8f75-4045-a81c-fb03a7b3aacc",
            "detail_level": "medium",
            "structured_type": "unstructured"
        },
        "timestamp": "2025-08-16 22:51:21.000",
        "id": "hFNC2HEjn3cFBOrS9NpA"
    },
    {
        "source": "frontend",
        "event": "change_summary_level",
        "data": {
            "before_detail_level": "medium",
            "section_id": "94e232d8-8f75-4045-a81c-fb03a7b3aacc",
            "before_structured": "unstructured",
            "after_structured": "unstructured",
            "after_detail_level": "low"
        },
        "timestamp": "2025-08-16 22:51:22.000",
        "id": "EBeRBWPFi6r6IoFeIQcr"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "94e232d8-8f75-4045-a81c-fb03a7b3aacc",
            "mapping_index": 3,
            "structured_type": "unstructured",
            "detail_level": "low"
        },
        "timestamp": "2025-08-16 22:51:22.000",
        "id": "gkKTFVQYKPXOcOIRyfFn"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "94e232d8-8f75-4045-a81c-fb03a7b3aacc",
            "detail_level": "low",
            "structured_type": "unstructured"
        },
        "timestamp": "2025-08-16 22:51:22.000",
        "id": "uL3G7ExjpK1nXy4cAtD0"
    },
    {
        "source": "frontend",
        "event": "click_edit_in_prompt",
        "data": {
            "section_id": "94e232d8-8f75-4045-a81c-fb03a7b3aacc",
            "summary": "This function retrieves and processes NBA per-game player statistics for a given year.",
            "detail_level": "low",
            "structured": "unstructured"
        },
        "timestamp": "2025-08-16 22:51:26.000",
        "id": "gAU39yYzKrBCKjfLdKqx"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "94e232d8-8f75-4045-a81c-fb03a7b3aacc",
            "detail_level": "low",
            "structured_type": "unstructured"
        },
        "timestamp": "2025-08-16 22:51:33.000",
        "id": "3XvlhpriEPGUXSM1MLCC"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "94e232d8-8f75-4045-a81c-fb03a7b3aacc",
            "mapping_index": 0,
            "structured_type": "unstructured",
            "detail_level": "low"
        },
        "timestamp": "2025-08-16 22:51:33.000",
        "id": "BdtwiV00Rvy1GflUIwo8"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "94e232d8-8f75-4045-a81c-fb03a7b3aacc",
            "mapping_index": 1,
            "structured_type": "unstructured",
            "detail_level": "low"
        },
        "timestamp": "2025-08-16 22:51:33.000",
        "id": "KtnKK5JkA6mZ2d3FQh2N"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "94e232d8-8f75-4045-a81c-fb03a7b3aacc",
            "detail_level": "low",
            "structured_type": "unstructured"
        },
        "timestamp": "2025-08-16 22:51:33.000",
        "id": "d6QCdqy2vUcEBqpz4mAP"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "94e232d8-8f75-4045-a81c-fb03a7b3aacc",
            "detail_level": "medium",
            "structured_type": "unstructured"
        },
        "timestamp": "2025-08-16 22:51:34.000",
        "id": "LJ8JxbkHHKEkOVCAUdkr"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "94e232d8-8f75-4045-a81c-fb03a7b3aacc",
            "mapping_index": 0,
            "structured_type": "unstructured",
            "detail_level": "medium"
        },
        "timestamp": "2025-08-16 22:51:34.000",
        "id": "P6TfKZoDXoITfmtMyGq5"
    },
    {
        "source": "frontend",
        "event": "change_summary_level",
        "data": {
            "before_detail_level": "low",
            "section_id": "94e232d8-8f75-4045-a81c-fb03a7b3aacc",
            "before_structured": "unstructured",
            "after_structured": "unstructured",
            "after_detail_level": "medium"
        },
        "timestamp": "2025-08-16 22:51:34.000",
        "id": "c9VIParfVhL278CnVSRc"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "94e232d8-8f75-4045-a81c-fb03a7b3aacc",
            "mapping_index": 1,
            "structured_type": "unstructured",
            "detail_level": "medium"
        },
        "timestamp": "2025-08-16 22:51:34.000",
        "id": "vbZgyiz8S0N8h3jH4hXY"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "94e232d8-8f75-4045-a81c-fb03a7b3aacc",
            "mapping_index": 5,
            "structured_type": "unstructured",
            "detail_level": "medium"
        },
        "timestamp": "2025-08-16 22:51:35.000",
        "id": "BuF2WcQA1f5kLL8Qr6Ol"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "94e232d8-8f75-4045-a81c-fb03a7b3aacc",
            "detail_level": "medium",
            "structured_type": "unstructured"
        },
        "timestamp": "2025-08-16 22:51:35.000",
        "id": "JfgrZMHAaYLcElcxlghN"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "94e232d8-8f75-4045-a81c-fb03a7b3aacc",
            "detail_level": "medium",
            "structured_type": "unstructured"
        },
        "timestamp": "2025-08-16 22:51:35.000",
        "id": "Nn7elRjjXldyMvvpzoiq"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "94e232d8-8f75-4045-a81c-fb03a7b3aacc",
            "detail_level": "medium",
            "structured_type": "unstructured"
        },
        "timestamp": "2025-08-16 22:51:35.000",
        "id": "RHbFZLewTybXgsA71h8B"
    },
    {
        "source": "frontend",
        "event": "click_edit_in_prompt",
        "data": {
            "section_id": "94e232d8-8f75-4045-a81c-fb03a7b3aacc",
            "summary": "The scrape_season_stats function downloads NBA per-game statistics for a given year from Basketball Reference. It cleans the data by removing repeated header rows and keeps only relevant columns like player name, year, points, assists, rebounds, and field goal percentage. The function also ensures that rows with missing key stats are excluded before returning the final DataFrame.",
            "detail_level": "medium",
            "structured": "unstructured"
        },
        "timestamp": "2025-08-16 22:51:35.000",
        "id": "XiBbYdQ1CXqD9K49eVbG"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "94e232d8-8f75-4045-a81c-fb03a7b3aacc",
            "mapping_index": 4,
            "structured_type": "unstructured",
            "detail_level": "medium"
        },
        "timestamp": "2025-08-16 22:51:35.000",
        "id": "gKE5WIZ8gmeVMduyjtR1"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "94e232d8-8f75-4045-a81c-fb03a7b3aacc",
            "detail_level": "medium",
            "structured_type": "unstructured"
        },
        "timestamp": "2025-08-16 22:51:35.000",
        "id": "jfR2yxR6VhJi0trvdiXW"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "94e232d8-8f75-4045-a81c-fb03a7b3aacc",
            "mapping_index": 2,
            "structured_type": "unstructured",
            "detail_level": "medium"
        },
        "timestamp": "2025-08-16 22:51:35.000",
        "id": "pxI1wM16gzY0vxad5fyv"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "94e232d8-8f75-4045-a81c-fb03a7b3aacc",
            "mapping_index": 3,
            "structured_type": "unstructured",
            "detail_level": "medium"
        },
        "timestamp": "2025-08-16 22:51:35.000",
        "id": "qSUSmhRwoXgetwwrzkxD"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "94e232d8-8f75-4045-a81c-fb03a7b3aacc",
            "detail_level": "medium",
            "structured_type": "unstructured"
        },
        "timestamp": "2025-08-16 22:51:35.000",
        "id": "sUidsTD8UFQQeRLMxLwy"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "94e232d8-8f75-4045-a81c-fb03a7b3aacc",
            "detail_level": "medium",
            "structured_type": "unstructured"
        },
        "timestamp": "2025-08-16 22:51:35.000",
        "id": "uSKn9ZegokufnqCHzhzY"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "94e232d8-8f75-4045-a81c-fb03a7b3aacc",
            "mapping_index": 3,
            "structured_type": "unstructured",
            "detail_level": "medium"
        },
        "timestamp": "2025-08-16 22:51:35.000",
        "id": "uyiNkCqQNZqd3H7GDBHe"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "94e232d8-8f75-4045-a81c-fb03a7b3aacc",
            "detail_level": "medium",
            "structured_type": "unstructured"
        },
        "timestamp": "2025-08-16 22:51:36.000",
        "id": "1a1tS3DHywqoHlvMCT4C"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "94e232d8-8f75-4045-a81c-fb03a7b3aacc",
            "detail_level": "medium",
            "structured_type": "unstructured"
        },
        "timestamp": "2025-08-16 22:51:36.000",
        "id": "24sGJtXNySjEISAd6v6u"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "94e232d8-8f75-4045-a81c-fb03a7b3aacc",
            "mapping_index": 5,
            "structured_type": "unstructured",
            "detail_level": "medium"
        },
        "timestamp": "2025-08-16 22:51:36.000",
        "id": "F53EdJwAW1r0tlzODag9"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "94e232d8-8f75-4045-a81c-fb03a7b3aacc",
            "mapping_index": 3,
            "structured_type": "unstructured",
            "detail_level": "medium"
        },
        "timestamp": "2025-08-16 22:51:36.000",
        "id": "M7YoFXQWKpv5HEaHozFi"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "94e232d8-8f75-4045-a81c-fb03a7b3aacc",
            "detail_level": "medium",
            "structured_type": "unstructured"
        },
        "timestamp": "2025-08-16 22:51:36.000",
        "id": "QJZl06d27LSaoMZze9mH"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "94e232d8-8f75-4045-a81c-fb03a7b3aacc",
            "mapping_index": 2,
            "structured_type": "unstructured",
            "detail_level": "medium"
        },
        "timestamp": "2025-08-16 22:51:36.000",
        "id": "RBzXUdXTnhI4FIsCuic8"
    },
    {
        "source": "frontend",
        "event": "apply_instruction_summary",
        "data": {
            "section_id": "94e232d8-8f75-4045-a81c-fb03a7b3aacc",
            "instruction": "currently the url is for basic stats, also scrap advanced stats from \"https://www.basketball-reference.com/leagues/NBA_2025_advanced.html\". after this, merge the basic stats and advanced stats using the keys [Name. MVP_Points]",
            "detail_level": "medium",
            "original_summary": "The scrape_season_stats function downloads NBA per-game statistics for a given year from Basketball Reference. It cleans the data by removing repeated header rows and keeps only relevant columns like player name, year, points, assists, rebounds, and field goal percentage. The function also ensures that rows with missing key stats are excluded before returning the final DataFrame.",
            "structured": "unstructured"
        },
        "timestamp": "2025-08-16 22:52:52.000",
        "id": "dDsbdalGXfRXtyGoHKEC"
    },
    {
        "source": "backend",
        "event": "apply_instruction_summary",
        "data": {
            "original_code": "def scrape_season_stats(year):\n    base_url_reg = (\n        f\"https://www.basketball-reference.com/leagues/NBA_{year}_per_game.html\"\n    )\n    df_reg = pd.read_html(base_url_reg, header=0)[0]\n    df_reg = df_reg[df_reg[\"Player\"] != \"Player\"]  # remove repeated header rows\n    df_reg[\"Year\"] = year\n\n    df_reg = df_reg[\n        [\"Player\", \"Year\", \"PTS\", \"AST\", \"TRB\", \"FG%\"]\n    ]  # Keep only specified columns\n    df_reg = df_reg.dropna(\n        subset=[\"PTS\", \"AST\", \"TRB\", \"FG%\"]\n    )  # Ensure key stats aren't invalid\n    return df_reg",
            "original_summary": "The scrape_season_stats function downloads NBA per-game statistics for a given year from Basketball Reference. It cleans the data by removing repeated header rows and keeps only relevant columns like player name, year, points, assists, rebounds, and field goal percentage. The function also ensures that rows with missing key stats are excluded before returning the final DataFrame.",
            "instruction": "currently the url is for basic stats, also scrap advanced stats from \"https://www.basketball-reference.com/leagues/NBA_2025_advanced.html\". after this, merge the basic stats and advanced stats using the keys [Name. MVP_Points]",
            "updated_summary": "The scrape_season_stats function downloads NBA per-game statistics for a given year from Basketball Reference. It also scrapes advanced statistics from the corresponding advanced stats page for that year (e.g., \"https://www.basketball-reference.com/leagues/NBA_2025_advanced.html\"). The function cleans the data by removing repeated header rows and keeps only relevant columns like player name, year, points, assists, rebounds, and field goal percentage. Advanced stats are similarly processed. After scraping both basic and advanced stats, the function merges them using the keys [Name, MVP_Points]. The function also ensures that rows with missing key stats are excluded before returning the final DataFrame."
        },
        "timestamp": "2025-08-16 22:52:53.000",
        "id": "OyH1yrHyzSxqsJJaFRlE"
    },
    {
        "source": "frontend",
        "event": "commit_modified_summary",
        "data": {
            "section_id": "94e232d8-8f75-4045-a81c-fb03a7b3aacc",
            "edited_summary": "The scrape_season_stats function downloads NBA per-game statistics for a given year from Basketball Reference. It also scrapes advanced statistics from the corresponding advanced stats page for that year (e.g., \"https://www.basketball-reference.com/leagues/NBA_2025_advanced.html\"). The function cleans the data by removing repeated header rows and keeps only relevant columns like player name, year, points, assists, rebounds, and field goal percentage. Advanced stats are similarly processed. After scraping both basic and advanced stats, the function merges them using the keys [Name, MVP_Points]. The function also ensures that rows with missing key stats are excluded before returning the final DataFrame.",
            "detail_level": "medium",
            "original_summary": "The scrape_season_stats function downloads NBA per-game statistics for a given year from Basketball Reference. It cleans the data by removing repeated header rows and keeps only relevant columns like player name, year, points, assists, rebounds, and field goal percentage. The function also ensures that rows with missing key stats are excluded before returning the final DataFrame.",
            "structured": "unstructured"
        },
        "timestamp": "2025-08-16 22:53:22.000",
        "id": "86nYaWlccK4tyXba5mci"
    },
    {
        "source": "backend",
        "event": "modify_summary_mediation",
        "data": {
            "original_code": "def scrape_season_stats(year):\n    base_url_reg = (\n        f\"https://www.basketball-reference.com/leagues/NBA_{year}_per_game.html\"\n    )\n    df_reg = pd.read_html(base_url_reg, header=0)[0]\n    df_reg = df_reg[df_reg[\"Player\"] != \"Player\"]  # remove repeated header rows\n    df_reg[\"Year\"] = year\n\n    df_reg = df_reg[\n        [\"Player\", \"Year\", \"PTS\", \"AST\", \"TRB\", \"FG%\"]\n    ]  # Keep only specified columns\n    df_reg = df_reg.dropna(\n        subset=[\"PTS\", \"AST\", \"TRB\", \"FG%\"]\n    )  # Ensure key stats aren't invalid\n    return df_reg",
            "original_summary": "The scrape_season_stats function downloads NBA per-game statistics for a given year from Basketball Reference. It cleans the data by removing repeated header rows and keeps only relevant columns like player name, year, points, assists, rebounds, and field goal percentage. The function also ensures that rows with missing key stats are excluded before returning the final DataFrame.",
            "edited_summary": "The scrape_season_stats function downloads NBA per-game statistics for a given year from Basketball Reference. It also scrapes advanced statistics from the corresponding advanced stats page for that year (e.g., \"https://www.basketball-reference.com/leagues/NBA_2025_advanced.html\"). The function cleans the data by removing repeated header rows and keeps only relevant columns like player name, year, points, assists, rebounds, and field goal percentage. Advanced stats are similarly processed. After scraping both basic and advanced stats, the function merges them using the keys [Name, MVP_Points]. The function also ensures that rows with missing key stats are excluded before returning the final DataFrame.",
            "structured_type": "unstructured",
            "detail_level": "medium",
            "updated_code": "def scrape_season_stats(year):\n    base_url_reg = (\n        f\"https://www.basketball-reference.com/leagues/NBA_{year}_per_game.html\"\n    )\n    base_url_adv = (\n        f\"https://www.basketball-reference.com/leagues/NBA_{year}_advanced.html\"\n    )\n    # Scrape regular per-game stats\n    df_reg = pd.read_html(base_url_reg, header=0)[0]\n    df_reg = df_reg[df_reg[\"Player\"] != \"Player\"]  # remove repeated header rows\n    df_reg[\"Year\"] = year\n    df_reg = df_reg[\n        [\"Player\", \"Year\", \"PTS\", \"AST\", \"TRB\", \"FG%\"]\n    ]  # Keep only specified columns\n    df_reg = df_reg.dropna(\n        subset=[\"PTS\", \"AST\", \"TRB\", \"FG%\"]\n    )  # Ensure key stats aren't invalid\n\n    # Scrape advanced stats\n    df_adv = pd.read_html(base_url_adv, header=0)[0]\n    df_adv = df_adv[df_adv[\"Player\"] != \"Player\"]  # remove repeated header rows\n    df_adv[\"Year\"] = year\n    # Keep only relevant advanced stats columns (example: \"Player\", \"PER\", \"TS%\", \"USG%\")\n    adv_cols = [\"Player\", \"Year\"]\n    for col in [\"PER\", \"TS%\", \"USG%\"]:\n        if col in df_adv.columns:\n            adv_cols.append(col)\n    df_adv = df_adv[adv_cols]\n    df_adv = df_adv.dropna(subset=adv_cols[2:])  # Drop rows with missing advanced stats\n\n    # Merge per-game and advanced stats on Player and Year\n    df_merged = pd.merge(df_reg, df_adv, how=\"inner\", on=[\"Player\", \"Year\"])\n\n    return df_merged"
        },
        "timestamp": "2025-08-16 22:53:26.000",
        "id": "lZvcuw2HPQOSzL3pC1at"
    },
    {
        "source": "backend",
        "event": "summarize_modified_code",
        "data": {
            "new_code": "def scrape_season_stats(year):\n    base_url_reg = (\n        f\"https://www.basketball-reference.com/leagues/NBA_{year}_per_game.html\"\n    )\n    base_url_adv = (\n        f\"https://www.basketball-reference.com/leagues/NBA_{year}_advanced.html\"\n    )\n    # Scrape regular per-game stats\n    df_reg = pd.read_html(base_url_reg, header=0)[0]\n    df_reg = df_reg[df_reg[\"Player\"] != \"Player\"]  # remove repeated header rows\n    df_reg[\"Year\"] = year\n    df_reg = df_reg[\n        [\"Player\", \"Year\", \"PTS\", \"AST\", \"TRB\", \"FG%\"]\n    ]  # Keep only specified columns\n    df_reg = df_reg.dropna(\n        subset=[\"PTS\", \"AST\", \"TRB\", \"FG%\"]\n    )  # Ensure key stats aren't invalid\n\n    # Scrape advanced stats\n    df_adv = pd.read_html(base_url_adv, header=0)[0]\n    df_adv = df_adv[df_adv[\"Player\"] != \"Player\"]  # remove repeated header rows\n    df_adv[\"Year\"] = year\n    # Keep only relevant advanced stats columns (example: \"Player\", \"PER\", \"TS%\", \"USG%\")\n    adv_cols = [\"Player\", \"Year\"]\n    for col in [\"PER\", \"TS%\", \"USG%\"]:\n        if col in df_adv.columns:\n            adv_cols.append(col)\n    df_adv = df_adv[adv_cols]\n    df_adv = df_adv.dropna(subset=adv_cols[2:])  # Drop rows with missing advanced stats\n\n    # Merge per-game and advanced stats on Player and Year\n    df_merged = pd.merge(df_reg, df_adv, how=\"inner\", on=[\"Player\", \"Year\"])\n\n    return df_merged",
            "original_code": "def scrape_season_stats(year):\n    base_url_reg = (\n        f\"https://www.basketball-reference.com/leagues/NBA_{year}_per_game.html\"\n    )\n    base_url_adv = (\n        f\"https://www.basketball-reference.com/leagues/NBA_{year}_advanced.html\"\n    )\n    # Scrape regular per-game stats\n    df_reg = pd.read_html(base_url_reg, header=0)[0]\n    df_reg = df_reg[df_reg[\"Player\"] != \"Player\"]  # remove repeated header rows\n    df_reg[\"Year\"] = year\n    df_reg = df_reg[\n        [\"Player\", \"Year\", \"PTS\", \"AST\", \"TRB\", \"FG%\"]\n    ]  # Keep only specified columns\n    df_reg = df_reg.dropna(\n        subset=[\"PTS\", \"AST\", \"TRB\", \"FG%\"]\n    )  # Ensure key stats aren't invalid\n\n    # Scrape advanced stats\n    df_adv = pd.read_html(base_url_adv, header=0)[0]\n    df_adv = df_adv[df_adv[\"Player\"] != \"Player\"]  # remove repeated header rows\n    df_adv[\"Year\"] = year\n    # Keep only relevant advanced stats columns (example: \"Player\", \"PER\", \"TS%\", \"USG%\")\n    adv_cols = [\"Player\", \"Year\"]\n    for col in [\"PER\", \"TS%\", \"USG%\"]:\n        if col in df_adv.columns:\n            adv_cols.append(col)\n    df_adv = df_adv[adv_cols]\n    df_adv = df_adv.dropna(subset=adv_cols[2:])  # Drop rows with missing advanced stats\n\n    # Merge per-game and advanced stats on Player and Year\n    df_merged = pd.merge(df_reg, df_adv, how=\"inner\", on=[\"Player\", \"Year\"])\n\n    return df_merged",
            "old_summary": {
                "low_structured": "• Fetches NBA per-game stats for a specified year\n• Cleans and filters the data\n• Returns selected player statistics",
                "high_unstructured": "The scrape_season_stats function fetches NBA per-game statistics for a specified year from the Basketball Reference website using pandas' read_html. It processes the resulting DataFrame by removing any repeated header rows, adds a 'Year' column, and selects only the columns for player name, year, points, assists, rebounds, and field goal percentage. The function further cleans the data by dropping any rows where these key statistics are missing, ensuring only valid player data is included. Finally, it returns the cleaned DataFrame containing the relevant stats for all players in that season.",
                "medium_unstructured": "The scrape_season_stats function downloads NBA per-game statistics for a given year from Basketball Reference. It cleans the data by removing repeated header rows and keeps only relevant columns like player name, year, points, assists, rebounds, and field goal percentage. The function also ensures that rows with missing key stats are excluded before returning the final DataFrame.",
                "high_structured": "• Constructs the URL for NBA per-game stats for the given year\n• Reads the first table from the webpage using pandas' read_html\n• Cleans the DataFrame:\n  ◦ Removes rows where the 'Player' column is equal to 'Player' (repeated header rows)\n  ◦ Adds a 'Year' column with the specified year\n• Selects only the relevant columns:\n  ◦ 'Player', 'Year', 'PTS', 'AST', 'TRB', 'FG%'\n• Drops rows with missing values in any of the key stat columns\n• Returns the resulting DataFrame with cleaned and filtered player statistics for that year",
                "title": "Summary of scrape_season_stats Function",
                "low_unstructured": "This function retrieves and processes NBA per-game player statistics for a given year.",
                "medium_structured": "• Downloads NBA per-game stats for a specified year from Basketball Reference\n• Cleans the DataFrame:\n  ◦ Removes repeated header rows\n  ◦ Adds the year column\n• Selects only key columns: Player, Year, PTS, AST, TRB, FG%\n• Drops rows with missing values in the key stats\n• Returns the cleaned DataFrame"
            },
            "new_summary": {
                "low_structured": "• Fetches NBA per-game stats for a specified year\n• Cleans and filters the data\n• Merges in selected advanced player statistics\n• Returns selected player and advanced statistics",
                "high_unstructured": "The scrape_season_stats function fetches NBA per-game statistics for a specified year from the Basketball Reference website using pandas' read_html. It processes the resulting DataFrame by removing any repeated header rows, adds a 'Year' column, and selects only the columns for player name, year, points, assists, rebounds, and field goal percentage. The function further cleans the data by dropping any rows where these key statistics are missing. In addition, it now retrieves advanced statistics (such as PER, TS%, and USG% if present), drops rows with missing advanced stats, and merges these advanced stats with the per-game stats on player and year, ensuring only valid player data is included. Finally, it returns the cleaned DataFrame containing both per-game and advanced stats for all players in that season.",
                "medium_unstructured": "The scrape_season_stats function downloads NBA per-game statistics for a given year from Basketball Reference. In addition to cleaning the data by removing repeated header rows and keeping only relevant columns like player name, year, points, assists, rebounds, and field goal percentage, it now also retrieves advanced stats (such as PER, TS%, and USG% if available), drops rows with missing advanced stats, and merges these advanced stats with the per-game stats before returning the final DataFrame.",
                "high_structured": "• Constructs the URL for NBA per-game stats for the given year\n• Reads the first table from the webpage using pandas' read_html\n• Cleans the DataFrame:\n  ◦ Removes rows where the 'Player' column is equal to 'Player' (repeated header rows)\n  ◦ Adds a 'Year' column with the specified year\n• Selects only the relevant columns:\n  ◦ 'Player', 'Year', 'PTS', 'AST', 'TRB', 'FG%'\n• Drops rows with missing values in any of the key stat columns\n• Retrieves advanced stats (PER, TS%, USG% if available) from a separate table:\n  ◦ Removes repeated header rows and adds the year column\n  ◦ Selects only available advanced stat columns\n  ◦ Drops rows with missing advanced stats\n• Merges the per-game and advanced stats DataFrames on 'Player' and 'Year'\n• Returns the resulting DataFrame with cleaned and filtered player statistics, now including both per-game and advanced stats for that year",
                "title": "Summary of scrape_season_stats Function (with Advanced Stats Merge)",
                "low_unstructured": "This function retrieves and processes NBA per-game player statistics for a given year, and now also merges in selected advanced statistics for each player.",
                "medium_structured": "• Downloads NBA per-game stats for a specified year from Basketball Reference\n• Cleans the DataFrame:\n  ◦ Removes repeated header rows\n  ◦ Adds the year column\n• Selects only key columns: Player, Year, PTS, AST, TRB, FG%\n• Drops rows with missing values in the key stats\n• Retrieves advanced stats (PER, TS%, USG% if available), drops rows with missing advanced stats, and merges these with the per-game stats\n• Returns the combined and cleaned DataFrame"
            }
        },
        "timestamp": "2025-08-16 22:53:38.000",
        "id": "CPKNvQo0bMKGKlvj3LiE"
    },
    {
        "source": "backend",
        "event": "map_summary_code",
        "data": {
            "summary": "This function retrieves and processes NBA per-game player statistics for a given year, and now also merges in selected advanced statistics for each player.",
            "mapping": [
                {
                    "summaryComponent": "retrieves and processes NBA per-game player statistics for a given year",
                    "codeSegments": [
                        {
                            "line": 30,
                            "code": "df_reg = pd.read_html(base_url_reg, header=0)[0]"
                        },
                        {
                            "line": 31,
                            "code": "df_reg = df_reg[df_reg[\"Player\"] != \"Player\"]  # remove repeated header rows"
                        },
                        {
                            "line": 32,
                            "code": "df_reg[\"Year\"] = year"
                        },
                        {
                            "line": 33,
                            "code": "df_reg = df_reg[\n    [\"Player\", \"Year\", \"PTS\", \"AST\", \"TRB\", \"FG%\"]\n]"
                        },
                        {
                            "line": 36,
                            "code": "df_reg = df_reg.dropna(\n    subset=[\"PTS\", \"AST\", \"TRB\", \"FG%\"]\n)"
                        }
                    ]
                },
                {
                    "summaryComponent": "now also merges in selected advanced statistics for each player",
                    "codeSegments": [
                        {
                            "line": 41,
                            "code": "df_adv = pd.read_html(base_url_adv, header=0)[0]"
                        },
                        {
                            "line": 42,
                            "code": "df_adv = df_adv[df_adv[\"Player\"] != \"Player\"]  # remove repeated header rows"
                        },
                        {
                            "line": 43,
                            "code": "df_adv[\"Year\"] = year"
                        },
                        {
                            "line": 45,
                            "code": "adv_cols = [\"Player\", \"Year\"]"
                        },
                        {
                            "line": 46,
                            "code": "for col in [\"PER\", \"TS%\", \"USG%\"]:"
                        },
                        {
                            "line": 47,
                            "code": "if col in df_adv.columns:"
                        },
                        {
                            "line": 48,
                            "code": "adv_cols.append(col)"
                        },
                        {
                            "line": 49,
                            "code": "df_adv = df_adv[adv_cols]"
                        },
                        {
                            "line": 50,
                            "code": "df_adv = df_adv.dropna(subset=adv_cols[2:])  # Drop rows with missing advanced stats"
                        },
                        {
                            "line": 53,
                            "code": "df_merged = pd.merge(df_reg, df_adv, how=\"inner\", on=[\"Player\", \"Year\"])"
                        }
                    ]
                }
            ],
            "code": "22: def scrape_season_stats(year):\n23:     base_url_reg = (\n24:         f\"https://www.basketball-reference.com/leagues/NBA_{year}_per_game.html\"\n25:     )\n26:     base_url_adv = (\n27:         f\"https://www.basketball-reference.com/leagues/NBA_{year}_advanced.html\"\n28:     )\n29:     # Scrape regular per-game stats\n30:     df_reg = pd.read_html(base_url_reg, header=0)[0]\n31:     df_reg = df_reg[df_reg[\"Player\"] != \"Player\"]  # remove repeated header rows\n32:     df_reg[\"Year\"] = year\n33:     df_reg = df_reg[\n34:         [\"Player\", \"Year\", \"PTS\", \"AST\", \"TRB\", \"FG%\"]\n35:     ]  # Keep only specified columns\n36:     df_reg = df_reg.dropna(\n37:         subset=[\"PTS\", \"AST\", \"TRB\", \"FG%\"]\n38:     )  # Ensure key stats aren't invalid\n39: \n40:     # Scrape advanced stats\n41:     df_adv = pd.read_html(base_url_adv, header=0)[0]\n42:     df_adv = df_adv[df_adv[\"Player\"] != \"Player\"]  # remove repeated header rows\n43:     df_adv[\"Year\"] = year\n44:     # Keep only relevant advanced stats columns (example: \"Player\", \"PER\", \"TS%\", \"USG%\")\n45:     adv_cols = [\"Player\", \"Year\"]\n46:     for col in [\"PER\", \"TS%\", \"USG%\"]:\n47:         if col in df_adv.columns:\n48:             adv_cols.append(col)\n49:     df_adv = df_adv[adv_cols]\n50:     df_adv = df_adv.dropna(subset=adv_cols[2:])  # Drop rows with missing advanced stats\n51: \n52:     # Merge per-game and advanced stats on Player and Year\n53:     df_merged = pd.merge(df_reg, df_adv, how=\"inner\", on=[\"Player\", \"Year\"])\n54: \n55:     return df_merged"
        },
        "timestamp": "2025-08-16 22:53:40.000",
        "id": "dFrz8Xwmlqyhz8F8JLgK"
    },
    {
        "source": "backend",
        "event": "map_summary_code",
        "data": {
            "summary": "• Fetches NBA per-game stats for a specified year\n• Cleans and filters the data\n• Merges in selected advanced player statistics\n• Returns selected player and advanced statistics",
            "mapping": [
                {
                    "summaryComponent": "Fetches NBA per-game stats for a specified year",
                    "codeSegments": [
                        {
                            "line": 23,
                            "code": "base_url_reg = (\n    f\"https://www.basketball-reference.com/leagues/NBA_{year}_per_game.html\"\n)"
                        },
                        {
                            "line": 30,
                            "code": "df_reg = pd.read_html(base_url_reg, header=0)[0]"
                        }
                    ]
                },
                {
                    "summaryComponent": "Cleans and filters the data",
                    "codeSegments": [
                        {
                            "line": 31,
                            "code": "df_reg = df_reg[df_reg[\"Player\"] != \"Player\"]  # remove repeated header rows"
                        },
                        {
                            "line": 33,
                            "code": "df_reg = df_reg[\n    [\"Player\", \"Year\", \"PTS\", \"AST\", \"TRB\", \"FG%\"]\n]"
                        },
                        {
                            "line": 36,
                            "code": "df_reg = df_reg.dropna(\n    subset=[\"PTS\", \"AST\", \"TRB\", \"FG%\"]\n)"
                        },
                        {
                            "line": 42,
                            "code": "df_adv = df_adv[df_adv[\"Player\"] != \"Player\"]  # remove repeated header rows"
                        },
                        {
                            "line": 49,
                            "code": "df_adv = df_adv[adv_cols]"
                        },
                        {
                            "line": 50,
                            "code": "df_adv = df_adv.dropna(subset=adv_cols[2:])  # Drop rows with missing advanced stats"
                        }
                    ]
                },
                {
                    "summaryComponent": "Merges in selected advanced player statistics",
                    "codeSegments": [
                        {
                            "line": 53,
                            "code": "df_merged = pd.merge(df_reg, df_adv, how=\"inner\", on=[\"Player\", \"Year\"])"
                        }
                    ]
                },
                {
                    "summaryComponent": "Returns selected player and advanced statistics",
                    "codeSegments": [
                        {
                            "line": 55,
                            "code": "return df_merged"
                        }
                    ]
                }
            ],
            "code": "22: def scrape_season_stats(year):\n23:     base_url_reg = (\n24:         f\"https://www.basketball-reference.com/leagues/NBA_{year}_per_game.html\"\n25:     )\n26:     base_url_adv = (\n27:         f\"https://www.basketball-reference.com/leagues/NBA_{year}_advanced.html\"\n28:     )\n29:     # Scrape regular per-game stats\n30:     df_reg = pd.read_html(base_url_reg, header=0)[0]\n31:     df_reg = df_reg[df_reg[\"Player\"] != \"Player\"]  # remove repeated header rows\n32:     df_reg[\"Year\"] = year\n33:     df_reg = df_reg[\n34:         [\"Player\", \"Year\", \"PTS\", \"AST\", \"TRB\", \"FG%\"]\n35:     ]  # Keep only specified columns\n36:     df_reg = df_reg.dropna(\n37:         subset=[\"PTS\", \"AST\", \"TRB\", \"FG%\"]\n38:     )  # Ensure key stats aren't invalid\n39: \n40:     # Scrape advanced stats\n41:     df_adv = pd.read_html(base_url_adv, header=0)[0]\n42:     df_adv = df_adv[df_adv[\"Player\"] != \"Player\"]  # remove repeated header rows\n43:     df_adv[\"Year\"] = year\n44:     # Keep only relevant advanced stats columns (example: \"Player\", \"PER\", \"TS%\", \"USG%\")\n45:     adv_cols = [\"Player\", \"Year\"]\n46:     for col in [\"PER\", \"TS%\", \"USG%\"]:\n47:         if col in df_adv.columns:\n48:             adv_cols.append(col)\n49:     df_adv = df_adv[adv_cols]\n50:     df_adv = df_adv.dropna(subset=adv_cols[2:])  # Drop rows with missing advanced stats\n51: \n52:     # Merge per-game and advanced stats on Player and Year\n53:     df_merged = pd.merge(df_reg, df_adv, how=\"inner\", on=[\"Player\", \"Year\"])\n54: \n55:     return df_merged"
        },
        "timestamp": "2025-08-16 22:53:40.000",
        "id": "yscdOziPMLkMxRFxeKdP"
    },
    {
        "source": "backend",
        "event": "map_summary_code",
        "data": {
            "summary": "The scrape_season_stats function downloads NBA per-game statistics for a given year from Basketball Reference. In addition to cleaning the data by removing repeated header rows and keeping only relevant columns like player name, year, points, assists, rebounds, and field goal percentage, it now also retrieves advanced stats (such as PER, TS%, and USG% if available), drops rows with missing advanced stats, and merges these advanced stats with the per-game stats before returning the final DataFrame.",
            "mapping": [
                {
                    "summaryComponent": "The scrape_season_stats function",
                    "codeSegments": [
                        {
                            "line": 22,
                            "code": "def scrape_season_stats(year):"
                        }
                    ]
                },
                {
                    "summaryComponent": "downloads NBA per-game statistics for a given year from Basketball Reference",
                    "codeSegments": [
                        {
                            "line": 23,
                            "code": "base_url_reg = ("
                        },
                        {
                            "line": 24,
                            "code": "f\"https://www.basketball-reference.com/leagues/NBA_{year}_per_game.html\""
                        },
                        {
                            "line": 30,
                            "code": "df_reg = pd.read_html(base_url_reg, header=0)[0]"
                        }
                    ]
                },
                {
                    "summaryComponent": "cleaning the data by removing repeated header rows",
                    "codeSegments": [
                        {
                            "line": 31,
                            "code": "df_reg = df_reg[df_reg[\"Player\"] != \"Player\"]  # remove repeated header rows"
                        }
                    ]
                },
                {
                    "summaryComponent": "keeping only relevant columns like player name, year, points, assists, rebounds, and field goal percentage",
                    "codeSegments": [
                        {
                            "line": 33,
                            "code": "df_reg = df_reg["
                        },
                        {
                            "line": 34,
                            "code": "[\"Player\", \"Year\", \"PTS\", \"AST\", \"TRB\", \"FG%\"]"
                        }
                    ]
                },
                {
                    "summaryComponent": "retrieves advanced stats (such as PER, TS%, and USG% if available)",
                    "codeSegments": [
                        {
                            "line": 26,
                            "code": "base_url_adv = ("
                        },
                        {
                            "line": 27,
                            "code": "f\"https://www.basketball-reference.com/leagues/NBA_{year}_advanced.html\""
                        },
                        {
                            "line": 41,
                            "code": "df_adv = pd.read_html(base_url_adv, header=0)[0]"
                        },
                        {
                            "line": 46,
                            "code": "for col in [\"PER\", \"TS%\", \"USG%\"]:"
                        }
                    ]
                },
                {
                    "summaryComponent": "drops rows with missing advanced stats",
                    "codeSegments": [
                        {
                            "line": 50,
                            "code": "df_adv = df_adv.dropna(subset=adv_cols[2:])  # Drop rows with missing advanced stats"
                        }
                    ]
                },
                {
                    "summaryComponent": "merges these advanced stats with the per-game stats",
                    "codeSegments": [
                        {
                            "line": 53,
                            "code": "df_merged = pd.merge(df_reg, df_adv, how=\"inner\", on=[\"Player\", \"Year\"])"
                        }
                    ]
                },
                {
                    "summaryComponent": "returning the final DataFrame",
                    "codeSegments": [
                        {
                            "line": 55,
                            "code": "return df_merged"
                        }
                    ]
                }
            ],
            "code": "22: def scrape_season_stats(year):\n23:     base_url_reg = (\n24:         f\"https://www.basketball-reference.com/leagues/NBA_{year}_per_game.html\"\n25:     )\n26:     base_url_adv = (\n27:         f\"https://www.basketball-reference.com/leagues/NBA_{year}_advanced.html\"\n28:     )\n29:     # Scrape regular per-game stats\n30:     df_reg = pd.read_html(base_url_reg, header=0)[0]\n31:     df_reg = df_reg[df_reg[\"Player\"] != \"Player\"]  # remove repeated header rows\n32:     df_reg[\"Year\"] = year\n33:     df_reg = df_reg[\n34:         [\"Player\", \"Year\", \"PTS\", \"AST\", \"TRB\", \"FG%\"]\n35:     ]  # Keep only specified columns\n36:     df_reg = df_reg.dropna(\n37:         subset=[\"PTS\", \"AST\", \"TRB\", \"FG%\"]\n38:     )  # Ensure key stats aren't invalid\n39: \n40:     # Scrape advanced stats\n41:     df_adv = pd.read_html(base_url_adv, header=0)[0]\n42:     df_adv = df_adv[df_adv[\"Player\"] != \"Player\"]  # remove repeated header rows\n43:     df_adv[\"Year\"] = year\n44:     # Keep only relevant advanced stats columns (example: \"Player\", \"PER\", \"TS%\", \"USG%\")\n45:     adv_cols = [\"Player\", \"Year\"]\n46:     for col in [\"PER\", \"TS%\", \"USG%\"]:\n47:         if col in df_adv.columns:\n48:             adv_cols.append(col)\n49:     df_adv = df_adv[adv_cols]\n50:     df_adv = df_adv.dropna(subset=adv_cols[2:])  # Drop rows with missing advanced stats\n51: \n52:     # Merge per-game and advanced stats on Player and Year\n53:     df_merged = pd.merge(df_reg, df_adv, how=\"inner\", on=[\"Player\", \"Year\"])\n54: \n55:     return df_merged"
        },
        "timestamp": "2025-08-16 22:53:41.000",
        "id": "MsiknbbTX4eAE4s37Tmp"
    },
    {
        "source": "backend",
        "event": "map_summary_code",
        "data": {
            "summary": "• Downloads NBA per-game stats for a specified year from Basketball Reference\n• Cleans the DataFrame:\n  ◦ Removes repeated header rows\n  ◦ Adds the year column\n• Selects only key columns: Player, Year, PTS, AST, TRB, FG%\n• Drops rows with missing values in the key stats\n• Retrieves advanced stats (PER, TS%, USG% if available), drops rows with missing advanced stats, and merges these with the per-game stats\n• Returns the combined and cleaned DataFrame",
            "mapping": [
                {
                    "summaryComponent": "Downloads NBA per-game stats for a specified year from Basketball Reference",
                    "codeSegments": [
                        {
                            "line": 23,
                            "code": "base_url_reg = (\n    f\"https://www.basketball-reference.com/leagues/NBA_{year}_per_game.html\"\n)"
                        },
                        {
                            "line": 30,
                            "code": "df_reg = pd.read_html(base_url_reg, header=0)[0]"
                        }
                    ]
                },
                {
                    "summaryComponent": "Cleans the DataFrame:",
                    "codeSegments": [
                        {
                            "line": 31,
                            "code": "# remove repeated header rows"
                        },
                        {
                            "line": 32,
                            "code": "df_reg[\"Year\"] = year"
                        }
                    ]
                },
                {
                    "summaryComponent": "Removes repeated header rows",
                    "codeSegments": [
                        {
                            "line": 31,
                            "code": "df_reg = df_reg[df_reg[\"Player\"] != \"Player\"]  # remove repeated header rows"
                        }
                    ]
                },
                {
                    "summaryComponent": "Adds the year column",
                    "codeSegments": [
                        {
                            "line": 32,
                            "code": "df_reg[\"Year\"] = year"
                        }
                    ]
                },
                {
                    "summaryComponent": "Selects only key columns: Player, Year, PTS, AST, TRB, FG%",
                    "codeSegments": [
                        {
                            "line": 33,
                            "code": "df_reg = df_reg[\n    [\"Player\", \"Year\", \"PTS\", \"AST\", \"TRB\", \"FG%\"]\n]"
                        }
                    ]
                },
                {
                    "summaryComponent": "Drops rows with missing values in the key stats",
                    "codeSegments": [
                        {
                            "line": 36,
                            "code": "df_reg = df_reg.dropna(\n    subset=[\"PTS\", \"AST\", \"TRB\", \"FG%\"]\n)"
                        }
                    ]
                },
                {
                    "summaryComponent": "Retrieves advanced stats (PER, TS%, USG% if available), drops rows with missing advanced stats, and merges these with the per-game stats",
                    "codeSegments": [
                        {
                            "line": 26,
                            "code": "base_url_adv = (\n    f\"https://www.basketball-reference.com/leagues/NBA_{year}_advanced.html\"\n)"
                        },
                        {
                            "line": 41,
                            "code": "df_adv = pd.read_html(base_url_adv, header=0)[0]"
                        },
                        {
                            "line": 46,
                            "code": "for col in [\"PER\", \"TS%\", \"USG%\"]:\n    if col in df_adv.columns:\n        adv_cols.append(col)"
                        },
                        {
                            "line": 49,
                            "code": "df_adv = df_adv[adv_cols]"
                        },
                        {
                            "line": 50,
                            "code": "df_adv = df_adv.dropna(subset=adv_cols[2:])  # Drop rows with missing advanced stats"
                        },
                        {
                            "line": 53,
                            "code": "df_merged = pd.merge(df_reg, df_adv, how=\"inner\", on=[\"Player\", \"Year\"])"
                        }
                    ]
                },
                {
                    "summaryComponent": "Returns the combined and cleaned DataFrame",
                    "codeSegments": [
                        {
                            "line": 55,
                            "code": "return df_merged"
                        }
                    ]
                }
            ],
            "code": "22: def scrape_season_stats(year):\n23:     base_url_reg = (\n24:         f\"https://www.basketball-reference.com/leagues/NBA_{year}_per_game.html\"\n25:     )\n26:     base_url_adv = (\n27:         f\"https://www.basketball-reference.com/leagues/NBA_{year}_advanced.html\"\n28:     )\n29:     # Scrape regular per-game stats\n30:     df_reg = pd.read_html(base_url_reg, header=0)[0]\n31:     df_reg = df_reg[df_reg[\"Player\"] != \"Player\"]  # remove repeated header rows\n32:     df_reg[\"Year\"] = year\n33:     df_reg = df_reg[\n34:         [\"Player\", \"Year\", \"PTS\", \"AST\", \"TRB\", \"FG%\"]\n35:     ]  # Keep only specified columns\n36:     df_reg = df_reg.dropna(\n37:         subset=[\"PTS\", \"AST\", \"TRB\", \"FG%\"]\n38:     )  # Ensure key stats aren't invalid\n39: \n40:     # Scrape advanced stats\n41:     df_adv = pd.read_html(base_url_adv, header=0)[0]\n42:     df_adv = df_adv[df_adv[\"Player\"] != \"Player\"]  # remove repeated header rows\n43:     df_adv[\"Year\"] = year\n44:     # Keep only relevant advanced stats columns (example: \"Player\", \"PER\", \"TS%\", \"USG%\")\n45:     adv_cols = [\"Player\", \"Year\"]\n46:     for col in [\"PER\", \"TS%\", \"USG%\"]:\n47:         if col in df_adv.columns:\n48:             adv_cols.append(col)\n49:     df_adv = df_adv[adv_cols]\n50:     df_adv = df_adv.dropna(subset=adv_cols[2:])  # Drop rows with missing advanced stats\n51: \n52:     # Merge per-game and advanced stats on Player and Year\n53:     df_merged = pd.merge(df_reg, df_adv, how=\"inner\", on=[\"Player\", \"Year\"])\n54: \n55:     return df_merged"
        },
        "timestamp": "2025-08-16 22:53:42.000",
        "id": "Ap71otBmqUccr3DZjK0s"
    },
    {
        "source": "backend",
        "event": "map_summary_code",
        "data": {
            "summary": "The scrape_season_stats function fetches NBA per-game statistics for a specified year from the Basketball Reference website using pandas' read_html. It processes the resulting DataFrame by removing any repeated header rows, adds a 'Year' column, and selects only the columns for player name, year, points, assists, rebounds, and field goal percentage. The function further cleans the data by dropping any rows where these key statistics are missing. In addition, it now retrieves advanced statistics (such as PER, TS%, and USG% if present), drops rows with missing advanced stats, and merges these advanced stats with the per-game stats on player and year, ensuring only valid player data is included. Finally, it returns the cleaned DataFrame containing both per-game and advanced stats for all players in that season.",
            "mapping": [
                {
                    "summaryComponent": "The scrape_season_stats function",
                    "codeSegments": [
                        {
                            "line": 22,
                            "code": "def scrape_season_stats(year):"
                        }
                    ]
                },
                {
                    "summaryComponent": "fetches NBA per-game statistics for a specified year from the Basketball Reference website using pandas' read_html",
                    "codeSegments": [
                        {
                            "line": 23,
                            "code": "base_url_reg = ("
                        },
                        {
                            "line": 24,
                            "code": "f\"https://www.basketball-reference.com/leagues/NBA_{year}_per_game.html\""
                        },
                        {
                            "line": 30,
                            "code": "df_reg = pd.read_html(base_url_reg, header=0)[0]"
                        }
                    ]
                },
                {
                    "summaryComponent": "removing any repeated header rows",
                    "codeSegments": [
                        {
                            "line": 31,
                            "code": "df_reg = df_reg[df_reg[\"Player\"] != \"Player\"]  # remove repeated header rows"
                        }
                    ]
                },
                {
                    "summaryComponent": "adds a 'Year' column",
                    "codeSegments": [
                        {
                            "line": 32,
                            "code": "df_reg[\"Year\"] = year"
                        }
                    ]
                },
                {
                    "summaryComponent": "selects only the columns for player name, year, points, assists, rebounds, and field goal percentage",
                    "codeSegments": [
                        {
                            "line": 33,
                            "code": "df_reg = df_reg["
                        },
                        {
                            "line": 34,
                            "code": "[\"Player\", \"Year\", \"PTS\", \"AST\", \"TRB\", \"FG%\"]"
                        }
                    ]
                },
                {
                    "summaryComponent": "dropping any rows where these key statistics are missing",
                    "codeSegments": [
                        {
                            "line": 36,
                            "code": "df_reg = df_reg.dropna("
                        },
                        {
                            "line": 37,
                            "code": "subset=[\"PTS\", \"AST\", \"TRB\", \"FG%\"]"
                        }
                    ]
                },
                {
                    "summaryComponent": "retrieves advanced statistics (such as PER, TS%, and USG% if present)",
                    "codeSegments": [
                        {
                            "line": 26,
                            "code": "base_url_adv = ("
                        },
                        {
                            "line": 27,
                            "code": "f\"https://www.basketball-reference.com/leagues/NBA_{year}_advanced.html\""
                        },
                        {
                            "line": 41,
                            "code": "df_adv = pd.read_html(base_url_adv, header=0)[0]"
                        },
                        {
                            "line": 46,
                            "code": "for col in [\"PER\", \"TS%\", \"USG%\"]:"
                        }
                    ]
                },
                {
                    "summaryComponent": "drops rows with missing advanced stats",
                    "codeSegments": [
                        {
                            "line": 50,
                            "code": "df_adv = df_adv.dropna(subset=adv_cols[2:])  # Drop rows with missing advanced stats"
                        }
                    ]
                },
                {
                    "summaryComponent": "merges these advanced stats with the per-game stats on player and year",
                    "codeSegments": [
                        {
                            "line": 53,
                            "code": "df_merged = pd.merge(df_reg, df_adv, how=\"inner\", on=[\"Player\", \"Year\"])"
                        }
                    ]
                },
                {
                    "summaryComponent": "returns the cleaned DataFrame containing both per-game and advanced stats for all players in that season",
                    "codeSegments": [
                        {
                            "line": 55,
                            "code": "return df_merged"
                        }
                    ]
                }
            ],
            "code": "22: def scrape_season_stats(year):\n23:     base_url_reg = (\n24:         f\"https://www.basketball-reference.com/leagues/NBA_{year}_per_game.html\"\n25:     )\n26:     base_url_adv = (\n27:         f\"https://www.basketball-reference.com/leagues/NBA_{year}_advanced.html\"\n28:     )\n29:     # Scrape regular per-game stats\n30:     df_reg = pd.read_html(base_url_reg, header=0)[0]\n31:     df_reg = df_reg[df_reg[\"Player\"] != \"Player\"]  # remove repeated header rows\n32:     df_reg[\"Year\"] = year\n33:     df_reg = df_reg[\n34:         [\"Player\", \"Year\", \"PTS\", \"AST\", \"TRB\", \"FG%\"]\n35:     ]  # Keep only specified columns\n36:     df_reg = df_reg.dropna(\n37:         subset=[\"PTS\", \"AST\", \"TRB\", \"FG%\"]\n38:     )  # Ensure key stats aren't invalid\n39: \n40:     # Scrape advanced stats\n41:     df_adv = pd.read_html(base_url_adv, header=0)[0]\n42:     df_adv = df_adv[df_adv[\"Player\"] != \"Player\"]  # remove repeated header rows\n43:     df_adv[\"Year\"] = year\n44:     # Keep only relevant advanced stats columns (example: \"Player\", \"PER\", \"TS%\", \"USG%\")\n45:     adv_cols = [\"Player\", \"Year\"]\n46:     for col in [\"PER\", \"TS%\", \"USG%\"]:\n47:         if col in df_adv.columns:\n48:             adv_cols.append(col)\n49:     df_adv = df_adv[adv_cols]\n50:     df_adv = df_adv.dropna(subset=adv_cols[2:])  # Drop rows with missing advanced stats\n51: \n52:     # Merge per-game and advanced stats on Player and Year\n53:     df_merged = pd.merge(df_reg, df_adv, how=\"inner\", on=[\"Player\", \"Year\"])\n54: \n55:     return df_merged"
        },
        "timestamp": "2025-08-16 22:53:42.000",
        "id": "LghX185ALd050HETMmMW"
    },
    {
        "source": "frontend",
        "event": "create_new_section",
        "data": {
            "section_id": "124b9b5f-6151-450a-9107-101530543ad5",
            "section_data": {
                "editPromptDetailLevel": null,
                "selectedStructured": "unstructured",
                "createdAt": 1755370423000,
                "lines": [
                    22,
                    55
                ],
                "editPromptStructured": null,
                "summaryData": {
                    "low_structured": "• Fetches NBA per-game stats for a specified year\n• Cleans and filters the data\n• Merges in selected advanced player statistics\n• Returns selected player and advanced statistics",
                    "high_unstructured": "The scrape_season_stats function fetches NBA per-game statistics for a specified year from the Basketball Reference website using pandas' read_html. It processes the resulting DataFrame by removing any repeated header rows, adds a 'Year' column, and selects only the columns for player name, year, points, assists, rebounds, and field goal percentage. The function further cleans the data by dropping any rows where these key statistics are missing. In addition, it now retrieves advanced statistics (such as PER, TS%, and USG% if present), drops rows with missing advanced stats, and merges these advanced stats with the per-game stats on player and year, ensuring only valid player data is included. Finally, it returns the cleaned DataFrame containing both per-game and advanced stats for all players in that season.",
                    "medium_unstructured": "The scrape_season_stats function downloads NBA per-game statistics for a given year from Basketball Reference. In addition to cleaning the data by removing repeated header rows and keeping only relevant columns like player name, year, points, assists, rebounds, and field goal percentage, it now also retrieves advanced stats (such as PER, TS%, and USG% if available), drops rows with missing advanced stats, and merges these advanced stats with the per-game stats before returning the final DataFrame.",
                    "high_structured": "• Constructs the URL for NBA per-game stats for the given year\n• Reads the first table from the webpage using pandas' read_html\n• Cleans the DataFrame:\n  ◦ Removes rows where the 'Player' column is equal to 'Player' (repeated header rows)\n  ◦ Adds a 'Year' column with the specified year\n• Selects only the relevant columns:\n  ◦ 'Player', 'Year', 'PTS', 'AST', 'TRB', 'FG%'\n• Drops rows with missing values in any of the key stat columns\n• Retrieves advanced stats (PER, TS%, USG% if available) from a separate table:\n  ◦ Removes repeated header rows and adds the year column\n  ◦ Selects only available advanced stat columns\n  ◦ Drops rows with missing advanced stats\n• Merges the per-game and advanced stats DataFrames on 'Player' and 'Year'\n• Returns the resulting DataFrame with cleaned and filtered player statistics, now including both per-game and advanced stats for that year",
                    "title": "Summary of scrape_season_stats Function (with Advanced Stats Merge)",
                    "low_unstructured": "This function retrieves and processes NBA per-game player statistics for a given year, and now also merges in selected advanced statistics for each player.",
                    "medium_structured": "• Downloads NBA per-game stats for a specified year from Basketball Reference\n• Cleans the DataFrame:\n  ◦ Removes repeated header rows\n  ◦ Adds the year column\n• Selects only key columns: Player, Year, PTS, AST, TRB, FG%\n• Drops rows with missing values in the key stats\n• Retrieves advanced stats (PER, TS%, USG% if available), drops rows with missing advanced stats, and merges these with the per-game stats\n• Returns the combined and cleaned DataFrame"
                },
                "selectedDetailLevel": "medium",
                "oldSummaryData": {
                    "low_structured": "• Fetches NBA per-game stats for a specified year\n• Cleans and filters the data\n• Returns selected player statistics",
                    "high_unstructured": "The scrape_season_stats function fetches NBA per-game statistics for a specified year from the Basketball Reference website using pandas' read_html. It processes the resulting DataFrame by removing any repeated header rows, adds a 'Year' column, and selects only the columns for player name, year, points, assists, rebounds, and field goal percentage. The function further cleans the data by dropping any rows where these key statistics are missing, ensuring only valid player data is included. Finally, it returns the cleaned DataFrame containing the relevant stats for all players in that season.",
                    "medium_unstructured": "The scrape_season_stats function downloads NBA per-game statistics for a given year from Basketball Reference. It cleans the data by removing repeated header rows and keeps only relevant columns like player name, year, points, assists, rebounds, and field goal percentage. The function also ensures that rows with missing key stats are excluded before returning the final DataFrame.",
                    "high_structured": "• Constructs the URL for NBA per-game stats for the given year\n• Reads the first table from the webpage using pandas' read_html\n• Cleans the DataFrame:\n  ◦ Removes rows where the 'Player' column is equal to 'Player' (repeated header rows)\n  ◦ Adds a 'Year' column with the specified year\n• Selects only the relevant columns:\n  ◦ 'Player', 'Year', 'PTS', 'AST', 'TRB', 'FG%'\n• Drops rows with missing values in any of the key stat columns\n• Returns the resulting DataFrame with cleaned and filtered player statistics for that year",
                    "title": "Summary of scrape_season_stats Function",
                    "low_unstructured": "This function retrieves and processes NBA per-game player statistics for a given year.",
                    "medium_structured": "• Downloads NBA per-game stats for a specified year from Basketball Reference\n• Cleans the DataFrame:\n  ◦ Removes repeated header rows\n  ◦ Adds the year column\n• Selects only key columns: Player, Year, PTS, AST, TRB, FG%\n• Drops rows with missing values in the key stats\n• Returns the cleaned DataFrame"
                },
                "metadata": {
                    "originalCode": "def scrape_season_stats(year):\n    base_url_reg = (\n        f\"https://www.basketball-reference.com/leagues/NBA_{year}_per_game.html\"\n    )\n    base_url_adv = (\n        f\"https://www.basketball-reference.com/leagues/NBA_{year}_advanced.html\"\n    )\n    # Scrape regular per-game stats\n    df_reg = pd.read_html(base_url_reg, header=0)[0]\n    df_reg = df_reg[df_reg[\"Player\"] != \"Player\"]  # remove repeated header rows\n    df_reg[\"Year\"] = year\n    df_reg = df_reg[\n        [\"Player\", \"Year\", \"PTS\", \"AST\", \"TRB\", \"FG%\"]\n    ]  # Keep only specified columns\n    df_reg = df_reg.dropna(\n        subset=[\"PTS\", \"AST\", \"TRB\", \"FG%\"]\n    )  # Ensure key stats aren't invalid\n\n    # Scrape advanced stats\n    df_adv = pd.read_html(base_url_adv, header=0)[0]\n    df_adv = df_adv[df_adv[\"Player\"] != \"Player\"]  # remove repeated header rows\n    df_adv[\"Year\"] = year\n    # Keep only relevant advanced stats columns (example: \"Player\", \"PER\", \"TS%\", \"USG%\")\n    adv_cols = [\"Player\", \"Year\"]\n    for col in [\"PER\", \"TS%\", \"USG%\"]:\n        if col in df_adv.columns:\n            adv_cols.append(col)\n    df_adv = df_adv[adv_cols]\n    df_adv = df_adv.dropna(subset=adv_cols[2:])  # Drop rows with missing advanced stats\n\n    # Merge per-game and advanced stats on Player and Year\n    df_merged = pd.merge(df_reg, df_adv, how=\"inner\", on=[\"Player\", \"Year\"])\n\n    return df_merged",
                    "fullPath": "/project/workspace/scraper.py",
                    "id": "124b9b5f-6151-450a-9107-101530543ad5",
                    "offset": 652,
                    "filename": "scraper.py"
                },
                "editPromptValue": "",
                "title": "Summary of scrape_season_stats Function (with Advanced Stats Merge)",
                "summaryMappings": {
                    "high_unstructured": [
                        {
                            "summaryComponent": "The scrape_season_stats function",
                            "codeSegments": [
                                {
                                    "line": 22,
                                    "code": "def scrape_season_stats(year):"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "fetches NBA per-game statistics for a specified year from the Basketball Reference website using pandas' read_html",
                            "codeSegments": [
                                {
                                    "line": 23,
                                    "code": "base_url_reg = ("
                                },
                                {
                                    "line": 24,
                                    "code": "f\"https://www.basketball-reference.com/leagues/NBA_{year}_per_game.html\""
                                },
                                {
                                    "line": 30,
                                    "code": "df_reg = pd.read_html(base_url_reg, header=0)[0]"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "removing any repeated header rows",
                            "codeSegments": [
                                {
                                    "line": 31,
                                    "code": "df_reg = df_reg[df_reg[\"Player\"] != \"Player\"]  # remove repeated header rows"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "adds a 'Year' column",
                            "codeSegments": [
                                {
                                    "line": 32,
                                    "code": "df_reg[\"Year\"] = year"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "selects only the columns for player name, year, points, assists, rebounds, and field goal percentage",
                            "codeSegments": [
                                {
                                    "line": 33,
                                    "code": "df_reg = df_reg["
                                },
                                {
                                    "line": 34,
                                    "code": "[\"Player\", \"Year\", \"PTS\", \"AST\", \"TRB\", \"FG%\"]"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "dropping any rows where these key statistics are missing",
                            "codeSegments": [
                                {
                                    "line": 36,
                                    "code": "df_reg = df_reg.dropna("
                                },
                                {
                                    "line": 37,
                                    "code": "subset=[\"PTS\", \"AST\", \"TRB\", \"FG%\"]"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "retrieves advanced statistics (such as PER, TS%, and USG% if present)",
                            "codeSegments": [
                                {
                                    "line": 26,
                                    "code": "base_url_adv = ("
                                },
                                {
                                    "line": 27,
                                    "code": "f\"https://www.basketball-reference.com/leagues/NBA_{year}_advanced.html\""
                                },
                                {
                                    "line": 41,
                                    "code": "df_adv = pd.read_html(base_url_adv, header=0)[0]"
                                },
                                {
                                    "line": 46,
                                    "code": "for col in [\"PER\", \"TS%\", \"USG%\"]:"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "drops rows with missing advanced stats",
                            "codeSegments": [
                                {
                                    "line": 50,
                                    "code": "df_adv = df_adv.dropna(subset=adv_cols[2:])  # Drop rows with missing advanced stats"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "merges these advanced stats with the per-game stats on player and year",
                            "codeSegments": [
                                {
                                    "line": 53,
                                    "code": "df_merged = pd.merge(df_reg, df_adv, how=\"inner\", on=[\"Player\", \"Year\"])"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "returns the cleaned DataFrame containing both per-game and advanced stats for all players in that season",
                            "codeSegments": [
                                {
                                    "line": 55,
                                    "code": "return df_merged"
                                }
                            ]
                        }
                    ],
                    "medium_unstructured": [
                        {
                            "summaryComponent": "The scrape_season_stats function",
                            "codeSegments": [
                                {
                                    "line": 22,
                                    "code": "def scrape_season_stats(year):"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "downloads NBA per-game statistics for a given year from Basketball Reference",
                            "codeSegments": [
                                {
                                    "line": 23,
                                    "code": "base_url_reg = ("
                                },
                                {
                                    "line": 24,
                                    "code": "f\"https://www.basketball-reference.com/leagues/NBA_{year}_per_game.html\""
                                },
                                {
                                    "line": 30,
                                    "code": "df_reg = pd.read_html(base_url_reg, header=0)[0]"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "cleaning the data by removing repeated header rows",
                            "codeSegments": [
                                {
                                    "line": 31,
                                    "code": "df_reg = df_reg[df_reg[\"Player\"] != \"Player\"]  # remove repeated header rows"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "keeping only relevant columns like player name, year, points, assists, rebounds, and field goal percentage",
                            "codeSegments": [
                                {
                                    "line": 33,
                                    "code": "df_reg = df_reg["
                                },
                                {
                                    "line": 34,
                                    "code": "[\"Player\", \"Year\", \"PTS\", \"AST\", \"TRB\", \"FG%\"]"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "retrieves advanced stats (such as PER, TS%, and USG% if available)",
                            "codeSegments": [
                                {
                                    "line": 26,
                                    "code": "base_url_adv = ("
                                },
                                {
                                    "line": 27,
                                    "code": "f\"https://www.basketball-reference.com/leagues/NBA_{year}_advanced.html\""
                                },
                                {
                                    "line": 41,
                                    "code": "df_adv = pd.read_html(base_url_adv, header=0)[0]"
                                },
                                {
                                    "line": 46,
                                    "code": "for col in [\"PER\", \"TS%\", \"USG%\"]:"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "drops rows with missing advanced stats",
                            "codeSegments": [
                                {
                                    "line": 50,
                                    "code": "df_adv = df_adv.dropna(subset=adv_cols[2:])  # Drop rows with missing advanced stats"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "merges these advanced stats with the per-game stats",
                            "codeSegments": [
                                {
                                    "line": 53,
                                    "code": "df_merged = pd.merge(df_reg, df_adv, how=\"inner\", on=[\"Player\", \"Year\"])"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "returning the final DataFrame",
                            "codeSegments": [
                                {
                                    "line": 55,
                                    "code": "return df_merged"
                                }
                            ]
                        }
                    ],
                    "high_structured": [
                        {
                            "summaryComponent": "Constructs the URL for NBA per-game stats for the given year",
                            "codeSegments": [
                                {
                                    "line": 23,
                                    "code": "base_url_reg = ("
                                },
                                {
                                    "line": 24,
                                    "code": "f\"https://www.basketball-reference.com/leagues/NBA_{year}_per_game.html\""
                                }
                            ]
                        },
                        {
                            "summaryComponent": "Reads the first table from the webpage using pandas' read_html",
                            "codeSegments": [
                                {
                                    "line": 30,
                                    "code": "df_reg = pd.read_html(base_url_reg, header=0)[0]"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "Removes rows where the 'Player' column is equal to 'Player' (repeated header rows)",
                            "codeSegments": [
                                {
                                    "line": 31,
                                    "code": "df_reg = df_reg[df_reg[\"Player\"] != \"Player\"]  # remove repeated header rows"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "Adds a 'Year' column with the specified year",
                            "codeSegments": [
                                {
                                    "line": 32,
                                    "code": "df_reg[\"Year\"] = year"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "Selects only the relevant columns:",
                            "codeSegments": [
                                {
                                    "line": 33,
                                    "code": "df_reg = df_reg["
                                },
                                {
                                    "line": 34,
                                    "code": "[\"Player\", \"Year\", \"PTS\", \"AST\", \"TRB\", \"FG%\"]"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "Drops rows with missing values in any of the key stat columns",
                            "codeSegments": [
                                {
                                    "line": 36,
                                    "code": "df_reg = df_reg.dropna("
                                },
                                {
                                    "line": 37,
                                    "code": "subset=[\"PTS\", \"AST\", \"TRB\", \"FG%\"]"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "Retrieves advanced stats (PER, TS%, USG% if available) from a separate table:",
                            "codeSegments": [
                                {
                                    "line": 26,
                                    "code": "base_url_adv = ("
                                },
                                {
                                    "line": 27,
                                    "code": "f\"https://www.basketball-reference.com/leagues/NBA_{year}_advanced.html\""
                                },
                                {
                                    "line": 41,
                                    "code": "df_adv = pd.read_html(base_url_adv, header=0)[0]"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "Removes repeated header rows and adds the year column",
                            "codeSegments": [
                                {
                                    "line": 42,
                                    "code": "df_adv = df_adv[df_adv[\"Player\"] != \"Player\"]  # remove repeated header rows"
                                },
                                {
                                    "line": 43,
                                    "code": "df_adv[\"Year\"] = year"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "Selects only available advanced stat columns",
                            "codeSegments": [
                                {
                                    "line": 45,
                                    "code": "adv_cols = [\"Player\", \"Year\"]"
                                },
                                {
                                    "line": 46,
                                    "code": "for col in [\"PER\", \"TS%\", \"USG%\"]:"
                                },
                                {
                                    "line": 47,
                                    "code": "if col in df_adv.columns:"
                                },
                                {
                                    "line": 48,
                                    "code": "adv_cols.append(col)"
                                },
                                {
                                    "line": 49,
                                    "code": "df_adv = df_adv[adv_cols]"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "Drops rows with missing advanced stats",
                            "codeSegments": [
                                {
                                    "line": 50,
                                    "code": "df_adv = df_adv.dropna(subset=adv_cols[2:])  # Drop rows with missing advanced stats"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "Merges the per-game and advanced stats DataFrames on 'Player' and 'Year'",
                            "codeSegments": [
                                {
                                    "line": 53,
                                    "code": "df_merged = pd.merge(df_reg, df_adv, how=\"inner\", on=[\"Player\", \"Year\"])"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "Returns the resulting DataFrame with cleaned and filtered player statistics, now including both per-game and advanced stats for that year",
                            "codeSegments": [
                                {
                                    "line": 55,
                                    "code": "return df_merged"
                                }
                            ]
                        }
                    ],
                    "low_unstructured": [
                        {
                            "summaryComponent": "retrieves and processes NBA per-game player statistics for a given year",
                            "codeSegments": [
                                {
                                    "line": 30,
                                    "code": "df_reg = pd.read_html(base_url_reg, header=0)[0]"
                                },
                                {
                                    "line": 31,
                                    "code": "df_reg = df_reg[df_reg[\"Player\"] != \"Player\"]  # remove repeated header rows"
                                },
                                {
                                    "line": 32,
                                    "code": "df_reg[\"Year\"] = year"
                                },
                                {
                                    "line": 33,
                                    "code": "df_reg = df_reg[\n    [\"Player\", \"Year\", \"PTS\", \"AST\", \"TRB\", \"FG%\"]\n]"
                                },
                                {
                                    "line": 36,
                                    "code": "df_reg = df_reg.dropna(\n    subset=[\"PTS\", \"AST\", \"TRB\", \"FG%\"]\n)"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "now also merges in selected advanced statistics for each player",
                            "codeSegments": [
                                {
                                    "line": 41,
                                    "code": "df_adv = pd.read_html(base_url_adv, header=0)[0]"
                                },
                                {
                                    "line": 42,
                                    "code": "df_adv = df_adv[df_adv[\"Player\"] != \"Player\"]  # remove repeated header rows"
                                },
                                {
                                    "line": 43,
                                    "code": "df_adv[\"Year\"] = year"
                                },
                                {
                                    "line": 45,
                                    "code": "adv_cols = [\"Player\", \"Year\"]"
                                },
                                {
                                    "line": 46,
                                    "code": "for col in [\"PER\", \"TS%\", \"USG%\"]:"
                                },
                                {
                                    "line": 47,
                                    "code": "if col in df_adv.columns:"
                                },
                                {
                                    "line": 48,
                                    "code": "adv_cols.append(col)"
                                },
                                {
                                    "line": 49,
                                    "code": "df_adv = df_adv[adv_cols]"
                                },
                                {
                                    "line": 50,
                                    "code": "df_adv = df_adv.dropna(subset=adv_cols[2:])  # Drop rows with missing advanced stats"
                                },
                                {
                                    "line": 53,
                                    "code": "df_merged = pd.merge(df_reg, df_adv, how=\"inner\", on=[\"Player\", \"Year\"])"
                                }
                            ]
                        }
                    ],
                    "low_structured": [
                        {
                            "summaryComponent": "Fetches NBA per-game stats for a specified year",
                            "codeSegments": [
                                {
                                    "line": 23,
                                    "code": "base_url_reg = (\n    f\"https://www.basketball-reference.com/leagues/NBA_{year}_per_game.html\"\n)"
                                },
                                {
                                    "line": 30,
                                    "code": "df_reg = pd.read_html(base_url_reg, header=0)[0]"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "Cleans and filters the data",
                            "codeSegments": [
                                {
                                    "line": 31,
                                    "code": "df_reg = df_reg[df_reg[\"Player\"] != \"Player\"]  # remove repeated header rows"
                                },
                                {
                                    "line": 33,
                                    "code": "df_reg = df_reg[\n    [\"Player\", \"Year\", \"PTS\", \"AST\", \"TRB\", \"FG%\"]\n]"
                                },
                                {
                                    "line": 36,
                                    "code": "df_reg = df_reg.dropna(\n    subset=[\"PTS\", \"AST\", \"TRB\", \"FG%\"]\n)"
                                },
                                {
                                    "line": 42,
                                    "code": "df_adv = df_adv[df_adv[\"Player\"] != \"Player\"]  # remove repeated header rows"
                                },
                                {
                                    "line": 49,
                                    "code": "df_adv = df_adv[adv_cols]"
                                },
                                {
                                    "line": 50,
                                    "code": "df_adv = df_adv.dropna(subset=adv_cols[2:])  # Drop rows with missing advanced stats"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "Merges in selected advanced player statistics",
                            "codeSegments": [
                                {
                                    "line": 53,
                                    "code": "df_merged = pd.merge(df_reg, df_adv, how=\"inner\", on=[\"Player\", \"Year\"])"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "Returns selected player and advanced statistics",
                            "codeSegments": [
                                {
                                    "line": 55,
                                    "code": "return df_merged"
                                }
                            ]
                        }
                    ],
                    "medium_structured": [
                        {
                            "summaryComponent": "Downloads NBA per-game stats for a specified year from Basketball Reference",
                            "codeSegments": [
                                {
                                    "line": 23,
                                    "code": "base_url_reg = (\n    f\"https://www.basketball-reference.com/leagues/NBA_{year}_per_game.html\"\n)"
                                },
                                {
                                    "line": 30,
                                    "code": "df_reg = pd.read_html(base_url_reg, header=0)[0]"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "Cleans the DataFrame:",
                            "codeSegments": [
                                {
                                    "line": 31,
                                    "code": "# remove repeated header rows"
                                },
                                {
                                    "line": 32,
                                    "code": "df_reg[\"Year\"] = year"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "Removes repeated header rows",
                            "codeSegments": [
                                {
                                    "line": 31,
                                    "code": "df_reg = df_reg[df_reg[\"Player\"] != \"Player\"]  # remove repeated header rows"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "Adds the year column",
                            "codeSegments": [
                                {
                                    "line": 32,
                                    "code": "df_reg[\"Year\"] = year"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "Selects only key columns: Player, Year, PTS, AST, TRB, FG%",
                            "codeSegments": [
                                {
                                    "line": 33,
                                    "code": "df_reg = df_reg[\n    [\"Player\", \"Year\", \"PTS\", \"AST\", \"TRB\", \"FG%\"]\n]"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "Drops rows with missing values in the key stats",
                            "codeSegments": [
                                {
                                    "line": 36,
                                    "code": "df_reg = df_reg.dropna(\n    subset=[\"PTS\", \"AST\", \"TRB\", \"FG%\"]\n)"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "Retrieves advanced stats (PER, TS%, USG% if available), drops rows with missing advanced stats, and merges these with the per-game stats",
                            "codeSegments": [
                                {
                                    "line": 26,
                                    "code": "base_url_adv = (\n    f\"https://www.basketball-reference.com/leagues/NBA_{year}_advanced.html\"\n)"
                                },
                                {
                                    "line": 41,
                                    "code": "df_adv = pd.read_html(base_url_adv, header=0)[0]"
                                },
                                {
                                    "line": 46,
                                    "code": "for col in [\"PER\", \"TS%\", \"USG%\"]:\n    if col in df_adv.columns:\n        adv_cols.append(col)"
                                },
                                {
                                    "line": 49,
                                    "code": "df_adv = df_adv[adv_cols]"
                                },
                                {
                                    "line": 50,
                                    "code": "df_adv = df_adv.dropna(subset=adv_cols[2:])  # Drop rows with missing advanced stats"
                                },
                                {
                                    "line": 53,
                                    "code": "df_merged = pd.merge(df_reg, df_adv, how=\"inner\", on=[\"Player\", \"Year\"])"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "Returns the combined and cleaned DataFrame",
                            "codeSegments": [
                                {
                                    "line": 55,
                                    "code": "return df_merged"
                                }
                            ]
                        }
                    ]
                }
            }
        },
        "timestamp": "2025-08-16 22:53:43.000",
        "id": "2OY6a3AbyBiJJQEtCgnQ"
    },
    {
        "source": "frontend",
        "event": "autotransit_section",
        "data": {
            "before_section_id": "94e232d8-8f75-4045-a81c-fb03a7b3aacc",
            "after_section_id": "124b9b5f-6151-450a-9107-101530543ad5"
        },
        "timestamp": "2025-08-16 22:53:43.000",
        "id": "4nmiVHNhdIwID2NvLQbh"
    },
    {
        "source": "backend",
        "event": "map_summary_code",
        "data": {
            "summary": "• Constructs the URL for NBA per-game stats for the given year\n• Reads the first table from the webpage using pandas' read_html\n• Cleans the DataFrame:\n  ◦ Removes rows where the 'Player' column is equal to 'Player' (repeated header rows)\n  ◦ Adds a 'Year' column with the specified year\n• Selects only the relevant columns:\n  ◦ 'Player', 'Year', 'PTS', 'AST', 'TRB', 'FG%'\n• Drops rows with missing values in any of the key stat columns\n• Retrieves advanced stats (PER, TS%, USG% if available) from a separate table:\n  ◦ Removes repeated header rows and adds the year column\n  ◦ Selects only available advanced stat columns\n  ◦ Drops rows with missing advanced stats\n• Merges the per-game and advanced stats DataFrames on 'Player' and 'Year'\n• Returns the resulting DataFrame with cleaned and filtered player statistics, now including both per-game and advanced stats for that year",
            "mapping": [
                {
                    "summaryComponent": "Constructs the URL for NBA per-game stats for the given year",
                    "codeSegments": [
                        {
                            "line": 23,
                            "code": "base_url_reg = ("
                        },
                        {
                            "line": 24,
                            "code": "f\"https://www.basketball-reference.com/leagues/NBA_{year}_per_game.html\""
                        }
                    ]
                },
                {
                    "summaryComponent": "Reads the first table from the webpage using pandas' read_html",
                    "codeSegments": [
                        {
                            "line": 30,
                            "code": "df_reg = pd.read_html(base_url_reg, header=0)[0]"
                        }
                    ]
                },
                {
                    "summaryComponent": "Removes rows where the 'Player' column is equal to 'Player' (repeated header rows)",
                    "codeSegments": [
                        {
                            "line": 31,
                            "code": "df_reg = df_reg[df_reg[\"Player\"] != \"Player\"]  # remove repeated header rows"
                        }
                    ]
                },
                {
                    "summaryComponent": "Adds a 'Year' column with the specified year",
                    "codeSegments": [
                        {
                            "line": 32,
                            "code": "df_reg[\"Year\"] = year"
                        }
                    ]
                },
                {
                    "summaryComponent": "Selects only the relevant columns:",
                    "codeSegments": [
                        {
                            "line": 33,
                            "code": "df_reg = df_reg["
                        },
                        {
                            "line": 34,
                            "code": "[\"Player\", \"Year\", \"PTS\", \"AST\", \"TRB\", \"FG%\"]"
                        }
                    ]
                },
                {
                    "summaryComponent": "Drops rows with missing values in any of the key stat columns",
                    "codeSegments": [
                        {
                            "line": 36,
                            "code": "df_reg = df_reg.dropna("
                        },
                        {
                            "line": 37,
                            "code": "subset=[\"PTS\", \"AST\", \"TRB\", \"FG%\"]"
                        }
                    ]
                },
                {
                    "summaryComponent": "Retrieves advanced stats (PER, TS%, USG% if available) from a separate table:",
                    "codeSegments": [
                        {
                            "line": 26,
                            "code": "base_url_adv = ("
                        },
                        {
                            "line": 27,
                            "code": "f\"https://www.basketball-reference.com/leagues/NBA_{year}_advanced.html\""
                        },
                        {
                            "line": 41,
                            "code": "df_adv = pd.read_html(base_url_adv, header=0)[0]"
                        }
                    ]
                },
                {
                    "summaryComponent": "Removes repeated header rows and adds the year column",
                    "codeSegments": [
                        {
                            "line": 42,
                            "code": "df_adv = df_adv[df_adv[\"Player\"] != \"Player\"]  # remove repeated header rows"
                        },
                        {
                            "line": 43,
                            "code": "df_adv[\"Year\"] = year"
                        }
                    ]
                },
                {
                    "summaryComponent": "Selects only available advanced stat columns",
                    "codeSegments": [
                        {
                            "line": 45,
                            "code": "adv_cols = [\"Player\", \"Year\"]"
                        },
                        {
                            "line": 46,
                            "code": "for col in [\"PER\", \"TS%\", \"USG%\"]:"
                        },
                        {
                            "line": 47,
                            "code": "if col in df_adv.columns:"
                        },
                        {
                            "line": 48,
                            "code": "adv_cols.append(col)"
                        },
                        {
                            "line": 49,
                            "code": "df_adv = df_adv[adv_cols]"
                        }
                    ]
                },
                {
                    "summaryComponent": "Drops rows with missing advanced stats",
                    "codeSegments": [
                        {
                            "line": 50,
                            "code": "df_adv = df_adv.dropna(subset=adv_cols[2:])  # Drop rows with missing advanced stats"
                        }
                    ]
                },
                {
                    "summaryComponent": "Merges the per-game and advanced stats DataFrames on 'Player' and 'Year'",
                    "codeSegments": [
                        {
                            "line": 53,
                            "code": "df_merged = pd.merge(df_reg, df_adv, how=\"inner\", on=[\"Player\", \"Year\"])"
                        }
                    ]
                },
                {
                    "summaryComponent": "Returns the resulting DataFrame with cleaned and filtered player statistics, now including both per-game and advanced stats for that year",
                    "codeSegments": [
                        {
                            "line": 55,
                            "code": "return df_merged"
                        }
                    ]
                }
            ],
            "code": "22: def scrape_season_stats(year):\n23:     base_url_reg = (\n24:         f\"https://www.basketball-reference.com/leagues/NBA_{year}_per_game.html\"\n25:     )\n26:     base_url_adv = (\n27:         f\"https://www.basketball-reference.com/leagues/NBA_{year}_advanced.html\"\n28:     )\n29:     # Scrape regular per-game stats\n30:     df_reg = pd.read_html(base_url_reg, header=0)[0]\n31:     df_reg = df_reg[df_reg[\"Player\"] != \"Player\"]  # remove repeated header rows\n32:     df_reg[\"Year\"] = year\n33:     df_reg = df_reg[\n34:         [\"Player\", \"Year\", \"PTS\", \"AST\", \"TRB\", \"FG%\"]\n35:     ]  # Keep only specified columns\n36:     df_reg = df_reg.dropna(\n37:         subset=[\"PTS\", \"AST\", \"TRB\", \"FG%\"]\n38:     )  # Ensure key stats aren't invalid\n39: \n40:     # Scrape advanced stats\n41:     df_adv = pd.read_html(base_url_adv, header=0)[0]\n42:     df_adv = df_adv[df_adv[\"Player\"] != \"Player\"]  # remove repeated header rows\n43:     df_adv[\"Year\"] = year\n44:     # Keep only relevant advanced stats columns (example: \"Player\", \"PER\", \"TS%\", \"USG%\")\n45:     adv_cols = [\"Player\", \"Year\"]\n46:     for col in [\"PER\", \"TS%\", \"USG%\"]:\n47:         if col in df_adv.columns:\n48:             adv_cols.append(col)\n49:     df_adv = df_adv[adv_cols]\n50:     df_adv = df_adv.dropna(subset=adv_cols[2:])  # Drop rows with missing advanced stats\n51: \n52:     # Merge per-game and advanced stats on Player and Year\n53:     df_merged = pd.merge(df_reg, df_adv, how=\"inner\", on=[\"Player\", \"Year\"])\n54: \n55:     return df_merged"
        },
        "timestamp": "2025-08-16 22:53:43.000",
        "id": "ApM9Sjk7EWnPZghyjScb"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "124b9b5f-6151-450a-9107-101530543ad5",
            "mapping_index": 3,
            "structured_type": "unstructured",
            "detail_level": "medium"
        },
        "timestamp": "2025-08-16 22:54:49.000",
        "id": "LoFexqNtkBHjBgCzXITM"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "124b9b5f-6151-450a-9107-101530543ad5",
            "detail_level": "medium",
            "structured_type": "unstructured"
        },
        "timestamp": "2025-08-16 22:54:49.000",
        "id": "Xkyupfk5C40eNGAPTzFU"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "124b9b5f-6151-450a-9107-101530543ad5",
            "mapping_index": 2,
            "structured_type": "unstructured",
            "detail_level": "medium"
        },
        "timestamp": "2025-08-16 22:54:49.000",
        "id": "zc3DrvmPnsLyCsFUfRlj"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "124b9b5f-6151-450a-9107-101530543ad5",
            "mapping_index": 2,
            "structured_type": "unstructured",
            "detail_level": "medium"
        },
        "timestamp": "2025-08-16 22:54:50.000",
        "id": "52iNIHzOiqYNyN7gdGL6"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "124b9b5f-6151-450a-9107-101530543ad5",
            "detail_level": "medium",
            "structured_type": "unstructured"
        },
        "timestamp": "2025-08-16 22:54:50.000",
        "id": "D7aIH180tiWYK1Mr7WOb"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "124b9b5f-6151-450a-9107-101530543ad5",
            "mapping_index": 0,
            "structured_type": "unstructured",
            "detail_level": "medium"
        },
        "timestamp": "2025-08-16 22:54:50.000",
        "id": "JNzagi7xd6sszGHhYGm1"
    },
    {
        "source": "frontend",
        "event": "click_summarize_code",
        "data": {},
        "timestamp": "2025-08-16 22:54:50.000",
        "id": "LofWMhW2CrwHLqb9KCR9"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "124b9b5f-6151-450a-9107-101530543ad5",
            "detail_level": "medium",
            "structured_type": "unstructured"
        },
        "timestamp": "2025-08-16 22:54:50.000",
        "id": "cwmOQ7FwHltVN9uWcYvl"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "124b9b5f-6151-450a-9107-101530543ad5",
            "mapping_index": 3,
            "structured_type": "unstructured",
            "detail_level": "medium"
        },
        "timestamp": "2025-08-16 22:54:50.000",
        "id": "drlreqENy5YbceoChm3Q"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "124b9b5f-6151-450a-9107-101530543ad5",
            "detail_level": "medium",
            "structured_type": "unstructured"
        },
        "timestamp": "2025-08-16 22:54:50.000",
        "id": "lI98WLByOaNCqItJVc0S"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "124b9b5f-6151-450a-9107-101530543ad5",
            "mapping_index": 5,
            "structured_type": "unstructured",
            "detail_level": "medium"
        },
        "timestamp": "2025-08-16 22:54:50.000",
        "id": "mMM92qTjSfH1acg48cre"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "124b9b5f-6151-450a-9107-101530543ad5",
            "detail_level": "medium",
            "structured_type": "unstructured"
        },
        "timestamp": "2025-08-16 22:54:50.000",
        "id": "n4mbzbjV1Fo86loZuQnV"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "124b9b5f-6151-450a-9107-101530543ad5",
            "mapping_index": 0,
            "structured_type": "unstructured",
            "detail_level": "medium"
        },
        "timestamp": "2025-08-16 22:54:50.000",
        "id": "ohZaOlofhWB6f24cugQe"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "124b9b5f-6151-450a-9107-101530543ad5",
            "detail_level": "medium",
            "structured_type": "unstructured"
        },
        "timestamp": "2025-08-16 22:54:50.000",
        "id": "xSQER1i5nVx03ze2ucdf"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "124b9b5f-6151-450a-9107-101530543ad5",
            "detail_level": "medium",
            "structured_type": "unstructured"
        },
        "timestamp": "2025-08-16 22:54:51.000",
        "id": "yaBekXFBmQaoBEBunyZG"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "124b9b5f-6151-450a-9107-101530543ad5",
            "detail_level": "medium",
            "structured_type": "unstructured"
        },
        "timestamp": "2025-08-16 22:54:56.000",
        "id": "1yrYPXj0zJEVRZ84VCSE"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "124b9b5f-6151-450a-9107-101530543ad5",
            "mapping_index": 3,
            "structured_type": "unstructured",
            "detail_level": "medium"
        },
        "timestamp": "2025-08-16 22:54:56.000",
        "id": "90Hu5MWuL2QHZFA1TXGm"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "124b9b5f-6151-450a-9107-101530543ad5",
            "mapping_index": 4,
            "structured_type": "unstructured",
            "detail_level": "medium"
        },
        "timestamp": "2025-08-16 22:54:56.000",
        "id": "GRkqo67aqZJBybqBDXLs"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "124b9b5f-6151-450a-9107-101530543ad5",
            "detail_level": "medium",
            "structured_type": "unstructured"
        },
        "timestamp": "2025-08-16 22:54:56.000",
        "id": "GxTmUlQXgxRpNJPNS3jA"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "124b9b5f-6151-450a-9107-101530543ad5",
            "mapping_index": 7,
            "structured_type": "unstructured",
            "detail_level": "medium"
        },
        "timestamp": "2025-08-16 22:54:56.000",
        "id": "PrbYd6aDYGceJvLOzbV1"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "124b9b5f-6151-450a-9107-101530543ad5",
            "detail_level": "medium",
            "structured_type": "unstructured"
        },
        "timestamp": "2025-08-16 22:54:56.000",
        "id": "V2TLJrLzuhXVDEDjzHyN"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "124b9b5f-6151-450a-9107-101530543ad5",
            "detail_level": "medium",
            "structured_type": "unstructured"
        },
        "timestamp": "2025-08-16 22:54:56.000",
        "id": "bAbNtq4CYTvKo3760mOF"
    },
    {
        "source": "backend",
        "event": "summarize_selected_code",
        "data": {
            "selected_code": "    # Scrape advanced stats\n    df_adv = pd.read_html(base_url_adv, header=0)[0]\n    df_adv = df_adv[df_adv[\"Player\"] != \"Player\"]  # remove repeated header rows\n    df_adv[\"Year\"] = year\n    # Keep only relevant advanced stats columns (example: \"Player\", \"PER\", \"TS%\", \"USG%\")\n    adv_cols = [\"Player\", \"Year\"]\n    for col in [\"PER\", \"TS%\", \"USG%\"]:\n        if col in df_adv.columns:\n            adv_cols.append(col)\n    df_adv = df_adv[adv_cols]\n    df_adv = df_adv.dropna(subset=adv_cols[2:])  # Drop rows with missing advanced stats\n\n    # Merge per-game and advanced stats on Player and Year\n    df_merged = pd.merge(df_reg, df_adv, how=\"inner\", on=[\"Player\", \"Year\"])\n",
            "summary": {
                "low_structured": "• Scrapes advanced stats from a webpage\n• Filters and cleans the data\n• Merges with per-game stats",
                "high_unstructured": "This code segment scrapes the advanced statistics table for NBA players from a given season's basketball-reference webpage, ensuring repeated header rows are removed and the season year is recorded. It dynamically selects only the relevant advanced stats columns (Player, Year, PER, TS%, USG%) that are present, and filters out any rows with missing advanced statistics to maintain data integrity. The cleaned advanced stats DataFrame is then merged with the previously scraped per-game stats DataFrame using an inner join on Player and Year, so only players with complete data in both datasets are included. This process results in a comprehensive, season-specific dataset combining both per-game and advanced player statistics.",
                "medium_unstructured": "The code reads advanced player statistics from a basketball-reference webpage, filters out repeated headers, and keeps only key columns like PER, TS%, and USG% if present. It removes rows with missing advanced stats and merges this cleaned data with per-game stats on Player and Year. This ensures that only players with complete advanced and per-game stats are included in the final merged dataset.",
                "high_structured": "• Reads the advanced stats table from the basketball-reference URL for the specified year\n• Cleans the DataFrame:\n  ◦ Removes any repeated header rows\n  ◦ Adds a 'Year' column to tag each row with the season\n• Dynamically selects columns:\n  ◦ Always includes 'Player' and 'Year'\n  ◦ Adds 'PER', 'TS%', and 'USG%' if they exist in the table\n• Filters out any rows with missing values in the advanced stats columns\n• Merges the cleaned advanced stats DataFrame with the per-game stats DataFrame (df_reg):\n  ◦ Uses an inner join on 'Player' and 'Year'\n  ◦ Ensures only players with complete data in both tables are included\n• Produces a merged DataFrame containing both per-game and advanced stats for each player and season",
                "title": "Scraping and Merging Advanced NBA Player Statistics",
                "low_unstructured": "This code scrapes advanced NBA player stats for a season, filters relevant columns, removes incomplete data, and merges them with per-game stats.",
                "medium_structured": "• Reads advanced stats table from a specified URL\n• Cleans the data by removing repeated header rows\n• Selects only relevant columns (Player, Year, and available advanced stats)\n•  Removes rows with missing advanced stats\n• Merges the cleaned advanced stats with per-game stats based on Player and Year"
            }
        },
        "timestamp": "2025-08-16 22:54:56.000",
        "id": "r3WzdnShuPf7BWJE4m7l"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "124b9b5f-6151-450a-9107-101530543ad5",
            "mapping_index": 4,
            "structured_type": "unstructured",
            "detail_level": "medium"
        },
        "timestamp": "2025-08-16 22:54:56.000",
        "id": "sX1hv4eBJfcUvXfxNjoC"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "124b9b5f-6151-450a-9107-101530543ad5",
            "mapping_index": 4,
            "structured_type": "unstructured",
            "detail_level": "medium"
        },
        "timestamp": "2025-08-16 22:54:56.000",
        "id": "xUFNLiw3WLxwXrFSCqED"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "124b9b5f-6151-450a-9107-101530543ad5",
            "mapping_index": 3,
            "structured_type": "unstructured",
            "detail_level": "medium"
        },
        "timestamp": "2025-08-16 22:54:57.000",
        "id": "W5Ktb9w8Stmbh6D8S46o"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "124b9b5f-6151-450a-9107-101530543ad5",
            "mapping_index": 4,
            "structured_type": "unstructured",
            "detail_level": "medium"
        },
        "timestamp": "2025-08-16 22:54:57.000",
        "id": "bCLuI1BKPUIi546JAVnp"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "124b9b5f-6151-450a-9107-101530543ad5",
            "detail_level": "medium",
            "structured_type": "unstructured"
        },
        "timestamp": "2025-08-16 22:54:57.000",
        "id": "gFGmTByxLj65YbnNQL67"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "124b9b5f-6151-450a-9107-101530543ad5",
            "detail_level": "medium",
            "structured_type": "unstructured"
        },
        "timestamp": "2025-08-16 22:54:57.000",
        "id": "nNZJ9Rx2aTtp7i9Nphra"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "124b9b5f-6151-450a-9107-101530543ad5",
            "detail_level": "medium",
            "structured_type": "unstructured"
        },
        "timestamp": "2025-08-16 22:54:58.000",
        "id": "2tgYZ33cH4zMOzHk51Jm"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "124b9b5f-6151-450a-9107-101530543ad5",
            "mapping_index": 4,
            "structured_type": "unstructured",
            "detail_level": "medium"
        },
        "timestamp": "2025-08-16 22:54:58.000",
        "id": "7tgQPn1Fo1xmbYEWIoy0"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "124b9b5f-6151-450a-9107-101530543ad5",
            "detail_level": "medium",
            "structured_type": "unstructured"
        },
        "timestamp": "2025-08-16 22:54:58.000",
        "id": "8oq6kod3Cw8nrLo1DDu6"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "124b9b5f-6151-450a-9107-101530543ad5",
            "mapping_index": 6,
            "structured_type": "unstructured",
            "detail_level": "medium"
        },
        "timestamp": "2025-08-16 22:54:58.000",
        "id": "Aw1ghmmOnsDzzOnlPu96"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "124b9b5f-6151-450a-9107-101530543ad5",
            "mapping_index": 3,
            "structured_type": "unstructured",
            "detail_level": "medium"
        },
        "timestamp": "2025-08-16 22:54:58.000",
        "id": "C5p6dCl5qjOegl74y8Hz"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "124b9b5f-6151-450a-9107-101530543ad5",
            "mapping_index": 1,
            "structured_type": "unstructured",
            "detail_level": "medium"
        },
        "timestamp": "2025-08-16 22:54:58.000",
        "id": "EmIVbhG34qeCeqTNLKOm"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "124b9b5f-6151-450a-9107-101530543ad5",
            "mapping_index": 4,
            "structured_type": "unstructured",
            "detail_level": "medium"
        },
        "timestamp": "2025-08-16 22:54:58.000",
        "id": "GNSS3R4iSqjyEcceTNlf"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "124b9b5f-6151-450a-9107-101530543ad5",
            "detail_level": "medium",
            "structured_type": "unstructured"
        },
        "timestamp": "2025-08-16 22:54:58.000",
        "id": "IrFVeTt398VfoccuQ47q"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "124b9b5f-6151-450a-9107-101530543ad5",
            "detail_level": "medium",
            "structured_type": "unstructured"
        },
        "timestamp": "2025-08-16 22:54:58.000",
        "id": "KHy6P2wZLfhZL0arG5v6"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "124b9b5f-6151-450a-9107-101530543ad5",
            "detail_level": "medium",
            "structured_type": "unstructured"
        },
        "timestamp": "2025-08-16 22:54:58.000",
        "id": "NeDiuq9jB7z7fRvfWwrr"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "124b9b5f-6151-450a-9107-101530543ad5",
            "detail_level": "medium",
            "structured_type": "unstructured"
        },
        "timestamp": "2025-08-16 22:54:58.000",
        "id": "RfTKj3nfJRzEX73UYMCv"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "124b9b5f-6151-450a-9107-101530543ad5",
            "mapping_index": 4,
            "structured_type": "unstructured",
            "detail_level": "medium"
        },
        "timestamp": "2025-08-16 22:54:58.000",
        "id": "SdKCj12MQg0rg5di70og"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "124b9b5f-6151-450a-9107-101530543ad5",
            "detail_level": "medium",
            "structured_type": "unstructured"
        },
        "timestamp": "2025-08-16 22:54:58.000",
        "id": "W9KXnJXrwMLMDBu5yFey"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "124b9b5f-6151-450a-9107-101530543ad5",
            "mapping_index": 6,
            "structured_type": "unstructured",
            "detail_level": "medium"
        },
        "timestamp": "2025-08-16 22:54:58.000",
        "id": "WApQKM0WQRnW1GhUjloi"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "124b9b5f-6151-450a-9107-101530543ad5",
            "mapping_index": 1,
            "structured_type": "unstructured",
            "detail_level": "medium"
        },
        "timestamp": "2025-08-16 22:54:58.000",
        "id": "Wzo8vNZbp6mYmgTr8wBc"
    },
    {
        "source": "backend",
        "event": "map_summary_code",
        "data": {
            "summary": "• Reads advanced stats table from a specified URL\n• Cleans the data by removing repeated header rows\n• Selects only relevant columns (Player, Year, and available advanced stats)\n•  Removes rows with missing advanced stats\n• Merges the cleaned advanced stats with per-game stats based on Player and Year",
            "mapping": [
                {
                    "summaryComponent": "Reads advanced stats table from a specified URL",
                    "codeSegments": [
                        {
                            "line": 41,
                            "code": "df_adv = pd.read_html(base_url_adv, header=0)[0]"
                        }
                    ]
                },
                {
                    "summaryComponent": "Cleans the data by removing repeated header rows",
                    "codeSegments": [
                        {
                            "line": 42,
                            "code": "df_adv = df_adv[df_adv[\"Player\"] != \"Player\"]  # remove repeated header rows"
                        }
                    ]
                },
                {
                    "summaryComponent": "Selects only relevant columns (Player, Year, and available advanced stats)",
                    "codeSegments": [
                        {
                            "line": 45,
                            "code": "adv_cols = [\"Player\", \"Year\"]"
                        },
                        {
                            "line": 46,
                            "code": "for col in [\"PER\", \"TS%\", \"USG%\"]:"
                        },
                        {
                            "line": 47,
                            "code": "if col in df_adv.columns:"
                        },
                        {
                            "line": 48,
                            "code": "adv_cols.append(col)"
                        },
                        {
                            "line": 49,
                            "code": "df_adv = df_adv[adv_cols]"
                        }
                    ]
                },
                {
                    "summaryComponent": "Removes rows with missing advanced stats",
                    "codeSegments": [
                        {
                            "line": 50,
                            "code": "df_adv = df_adv.dropna(subset=adv_cols[2:])  # Drop rows with missing advanced stats"
                        }
                    ]
                },
                {
                    "summaryComponent": "Merges the cleaned advanced stats with per-game stats based on Player and Year",
                    "codeSegments": [
                        {
                            "line": 53,
                            "code": "df_merged = pd.merge(df_reg, df_adv, how=\"inner\", on=[\"Player\", \"Year\"])"
                        }
                    ]
                }
            ],
            "code": "40:     # Scrape advanced stats\n41:     df_adv = pd.read_html(base_url_adv, header=0)[0]\n42:     df_adv = df_adv[df_adv[\"Player\"] != \"Player\"]  # remove repeated header rows\n43:     df_adv[\"Year\"] = year\n44:     # Keep only relevant advanced stats columns (example: \"Player\", \"PER\", \"TS%\", \"USG%\")\n45:     adv_cols = [\"Player\", \"Year\"]\n46:     for col in [\"PER\", \"TS%\", \"USG%\"]:\n47:         if col in df_adv.columns:\n48:             adv_cols.append(col)\n49:     df_adv = df_adv[adv_cols]\n50:     df_adv = df_adv.dropna(subset=adv_cols[2:])  # Drop rows with missing advanced stats\n51: \n52:     # Merge per-game and advanced stats on Player and Year\n53:     df_merged = pd.merge(df_reg, df_adv, how=\"inner\", on=[\"Player\", \"Year\"])\n54: "
        },
        "timestamp": "2025-08-16 22:54:58.000",
        "id": "dSnO9EU6jh9CsDDr9C1p"
    },
    {
        "source": "backend",
        "event": "map_summary_code",
        "data": {
            "summary": "This code scrapes advanced NBA player stats for a season, filters relevant columns, removes incomplete data, and merges them with per-game stats.",
            "mapping": [
                {
                    "summaryComponent": "scrapes advanced NBA player stats for a season",
                    "codeSegments": [
                        {
                            "line": 41,
                            "code": "df_adv = pd.read_html(base_url_adv, header=0)[0]"
                        },
                        {
                            "line": 43,
                            "code": "df_adv[\"Year\"] = year"
                        }
                    ]
                },
                {
                    "summaryComponent": "filters relevant columns",
                    "codeSegments": [
                        {
                            "line": 45,
                            "code": "adv_cols = [\"Player\", \"Year\"]"
                        },
                        {
                            "line": 46,
                            "code": "for col in [\"PER\", \"TS%\", \"USG%\"]:"
                        },
                        {
                            "line": 47,
                            "code": "if col in df_adv.columns:"
                        },
                        {
                            "line": 48,
                            "code": "adv_cols.append(col)"
                        },
                        {
                            "line": 49,
                            "code": "df_adv = df_adv[adv_cols]"
                        }
                    ]
                },
                {
                    "summaryComponent": "removes incomplete data",
                    "codeSegments": [
                        {
                            "line": 50,
                            "code": "df_adv = df_adv.dropna(subset=adv_cols[2:])  # Drop rows with missing advanced stats"
                        }
                    ]
                },
                {
                    "summaryComponent": "merges them with per-game stats",
                    "codeSegments": [
                        {
                            "line": 53,
                            "code": "df_merged = pd.merge(df_reg, df_adv, how=\"inner\", on=[\"Player\", \"Year\"])"
                        }
                    ]
                }
            ],
            "code": "40:     # Scrape advanced stats\n41:     df_adv = pd.read_html(base_url_adv, header=0)[0]\n42:     df_adv = df_adv[df_adv[\"Player\"] != \"Player\"]  # remove repeated header rows\n43:     df_adv[\"Year\"] = year\n44:     # Keep only relevant advanced stats columns (example: \"Player\", \"PER\", \"TS%\", \"USG%\")\n45:     adv_cols = [\"Player\", \"Year\"]\n46:     for col in [\"PER\", \"TS%\", \"USG%\"]:\n47:         if col in df_adv.columns:\n48:             adv_cols.append(col)\n49:     df_adv = df_adv[adv_cols]\n50:     df_adv = df_adv.dropna(subset=adv_cols[2:])  # Drop rows with missing advanced stats\n51: \n52:     # Merge per-game and advanced stats on Player and Year\n53:     df_merged = pd.merge(df_reg, df_adv, how=\"inner\", on=[\"Player\", \"Year\"])\n54: "
        },
        "timestamp": "2025-08-16 22:54:58.000",
        "id": "kJltNfIhR1EpOU78JoFL"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "124b9b5f-6151-450a-9107-101530543ad5",
            "detail_level": "medium",
            "structured_type": "unstructured"
        },
        "timestamp": "2025-08-16 22:54:58.000",
        "id": "kQzT6STm7eep5JtRC9Ca"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "124b9b5f-6151-450a-9107-101530543ad5",
            "detail_level": "medium",
            "structured_type": "unstructured"
        },
        "timestamp": "2025-08-16 22:54:58.000",
        "id": "liw1lc6cfpCZGIOcevJb"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "124b9b5f-6151-450a-9107-101530543ad5",
            "mapping_index": 6,
            "structured_type": "unstructured",
            "detail_level": "medium"
        },
        "timestamp": "2025-08-16 22:54:58.000",
        "id": "vK8avLBilIrobt8S8vJ8"
    },
    {
        "source": "backend",
        "event": "map_summary_code",
        "data": {
            "summary": "• Scrapes advanced stats from a webpage\n• Filters and cleans the data\n• Merges with per-game stats",
            "mapping": [
                {
                    "summaryComponent": "Scrapes advanced stats from a webpage",
                    "codeSegments": [
                        {
                            "line": 41,
                            "code": "df_adv = pd.read_html(base_url_adv, header=0)[0]"
                        }
                    ]
                },
                {
                    "summaryComponent": "Filters and cleans the data",
                    "codeSegments": [
                        {
                            "line": 42,
                            "code": "df_adv = df_adv[df_adv[\"Player\"] != \"Player\"]  # remove repeated header rows"
                        },
                        {
                            "line": 43,
                            "code": "df_adv[\"Year\"] = year"
                        },
                        {
                            "line": 45,
                            "code": "adv_cols = [\"Player\", \"Year\"]"
                        },
                        {
                            "line": 46,
                            "code": "for col in [\"PER\", \"TS%\", \"USG%\"]:"
                        },
                        {
                            "line": 47,
                            "code": "if col in df_adv.columns:"
                        },
                        {
                            "line": 48,
                            "code": "adv_cols.append(col)"
                        },
                        {
                            "line": 49,
                            "code": "df_adv = df_adv[adv_cols]"
                        },
                        {
                            "line": 50,
                            "code": "df_adv = df_adv.dropna(subset=adv_cols[2:])  # Drop rows with missing advanced stats"
                        }
                    ]
                },
                {
                    "summaryComponent": "Merges with per-game stats",
                    "codeSegments": [
                        {
                            "line": 53,
                            "code": "df_merged = pd.merge(df_reg, df_adv, how=\"inner\", on=[\"Player\", \"Year\"])"
                        }
                    ]
                }
            ],
            "code": "40:     # Scrape advanced stats\n41:     df_adv = pd.read_html(base_url_adv, header=0)[0]\n42:     df_adv = df_adv[df_adv[\"Player\"] != \"Player\"]  # remove repeated header rows\n43:     df_adv[\"Year\"] = year\n44:     # Keep only relevant advanced stats columns (example: \"Player\", \"PER\", \"TS%\", \"USG%\")\n45:     adv_cols = [\"Player\", \"Year\"]\n46:     for col in [\"PER\", \"TS%\", \"USG%\"]:\n47:         if col in df_adv.columns:\n48:             adv_cols.append(col)\n49:     df_adv = df_adv[adv_cols]\n50:     df_adv = df_adv.dropna(subset=adv_cols[2:])  # Drop rows with missing advanced stats\n51: \n52:     # Merge per-game and advanced stats on Player and Year\n53:     df_merged = pd.merge(df_reg, df_adv, how=\"inner\", on=[\"Player\", \"Year\"])\n54: "
        },
        "timestamp": "2025-08-16 22:54:58.000",
        "id": "zjAYx0C0zTGANEwnVdkn"
    },
    {
        "source": "backend",
        "event": "map_summary_code",
        "data": {
            "summary": "The code reads advanced player statistics from a basketball-reference webpage, filters out repeated headers, and keeps only key columns like PER, TS%, and USG% if present. It removes rows with missing advanced stats and merges this cleaned data with per-game stats on Player and Year. This ensures that only players with complete advanced and per-game stats are included in the final merged dataset.",
            "mapping": [
                {
                    "summaryComponent": "reads advanced player statistics from a basketball-reference webpage",
                    "codeSegments": [
                        {
                            "line": 41,
                            "code": "df_adv = pd.read_html(base_url_adv, header=0)[0]"
                        }
                    ]
                },
                {
                    "summaryComponent": "filters out repeated headers",
                    "codeSegments": [
                        {
                            "line": 42,
                            "code": "df_adv = df_adv[df_adv[\"Player\"] != \"Player\"]  # remove repeated header rows"
                        }
                    ]
                },
                {
                    "summaryComponent": "keeps only key columns like PER, TS%, and USG% if present",
                    "codeSegments": [
                        {
                            "line": 45,
                            "code": "adv_cols = [\"Player\", \"Year\"]"
                        },
                        {
                            "line": 46,
                            "code": "for col in [\"PER\", \"TS%\", \"USG%\"]:"
                        },
                        {
                            "line": 47,
                            "code": "if col in df_adv.columns:"
                        },
                        {
                            "line": 48,
                            "code": "adv_cols.append(col)"
                        },
                        {
                            "line": 49,
                            "code": "df_adv = df_adv[adv_cols]"
                        }
                    ]
                },
                {
                    "summaryComponent": "removes rows with missing advanced stats",
                    "codeSegments": [
                        {
                            "line": 50,
                            "code": "df_adv = df_adv.dropna(subset=adv_cols[2:])  # Drop rows with missing advanced stats"
                        }
                    ]
                },
                {
                    "summaryComponent": "merges this cleaned data with per-game stats on Player and Year",
                    "codeSegments": [
                        {
                            "line": 53,
                            "code": "df_merged = pd.merge(df_reg, df_adv, how=\"inner\", on=[\"Player\", \"Year\"])"
                        }
                    ]
                },
                {
                    "summaryComponent": "ensures that only players with complete advanced and per-game stats are included in the final merged dataset",
                    "codeSegments": [
                        {
                            "line": 53,
                            "code": "df_merged = pd.merge(df_reg, df_adv, how=\"inner\", on=[\"Player\", \"Year\"])"
                        }
                    ]
                }
            ],
            "code": "40:     # Scrape advanced stats\n41:     df_adv = pd.read_html(base_url_adv, header=0)[0]\n42:     df_adv = df_adv[df_adv[\"Player\"] != \"Player\"]  # remove repeated header rows\n43:     df_adv[\"Year\"] = year\n44:     # Keep only relevant advanced stats columns (example: \"Player\", \"PER\", \"TS%\", \"USG%\")\n45:     adv_cols = [\"Player\", \"Year\"]\n46:     for col in [\"PER\", \"TS%\", \"USG%\"]:\n47:         if col in df_adv.columns:\n48:             adv_cols.append(col)\n49:     df_adv = df_adv[adv_cols]\n50:     df_adv = df_adv.dropna(subset=adv_cols[2:])  # Drop rows with missing advanced stats\n51: \n52:     # Merge per-game and advanced stats on Player and Year\n53:     df_merged = pd.merge(df_reg, df_adv, how=\"inner\", on=[\"Player\", \"Year\"])\n54: "
        },
        "timestamp": "2025-08-16 22:54:59.000",
        "id": "FpRgOxXRjQtTBeZJZ4Iv"
    },
    {
        "source": "frontend",
        "event": "create_new_section",
        "data": {
            "section_id": "42bebc2d-3a7e-4f91-bc59-75819564c02f",
            "section_data": {
                "editPromptDetailLevel": null,
                "selectedStructured": "unstructured",
                "createdAt": 1755370500000,
                "lines": [
                    40,
                    54
                ],
                "editPromptStructured": null,
                "summaryData": {
                    "low_structured": "• Scrapes advanced stats from a webpage\n• Filters and cleans the data\n• Merges with per-game stats",
                    "high_unstructured": "This code segment scrapes the advanced statistics table for NBA players from a given season's basketball-reference webpage, ensuring repeated header rows are removed and the season year is recorded. It dynamically selects only the relevant advanced stats columns (Player, Year, PER, TS%, USG%) that are present, and filters out any rows with missing advanced statistics to maintain data integrity. The cleaned advanced stats DataFrame is then merged with the previously scraped per-game stats DataFrame using an inner join on Player and Year, so only players with complete data in both datasets are included. This process results in a comprehensive, season-specific dataset combining both per-game and advanced player statistics.",
                    "medium_unstructured": "The code reads advanced player statistics from a basketball-reference webpage, filters out repeated headers, and keeps only key columns like PER, TS%, and USG% if present. It removes rows with missing advanced stats and merges this cleaned data with per-game stats on Player and Year. This ensures that only players with complete advanced and per-game stats are included in the final merged dataset.",
                    "high_structured": "• Reads the advanced stats table from the basketball-reference URL for the specified year\n• Cleans the DataFrame:\n  ◦ Removes any repeated header rows\n  ◦ Adds a 'Year' column to tag each row with the season\n• Dynamically selects columns:\n  ◦ Always includes 'Player' and 'Year'\n  ◦ Adds 'PER', 'TS%', and 'USG%' if they exist in the table\n• Filters out any rows with missing values in the advanced stats columns\n• Merges the cleaned advanced stats DataFrame with the per-game stats DataFrame (df_reg):\n  ◦ Uses an inner join on 'Player' and 'Year'\n  ◦ Ensures only players with complete data in both tables are included\n• Produces a merged DataFrame containing both per-game and advanced stats for each player and season",
                    "title": "Scraping and Merging Advanced NBA Player Statistics",
                    "low_unstructured": "This code scrapes advanced NBA player stats for a season, filters relevant columns, removes incomplete data, and merges them with per-game stats.",
                    "medium_structured": "• Reads advanced stats table from a specified URL\n• Cleans the data by removing repeated header rows\n• Selects only relevant columns (Player, Year, and available advanced stats)\n•  Removes rows with missing advanced stats\n• Merges the cleaned advanced stats with per-game stats based on Player and Year"
                },
                "selectedDetailLevel": "medium",
                "metadata": {
                    "originalCode": "    # Scrape advanced stats\n    df_adv = pd.read_html(base_url_adv, header=0)[0]\n    df_adv = df_adv[df_adv[\"Player\"] != \"Player\"]  # remove repeated header rows\n    df_adv[\"Year\"] = year\n    # Keep only relevant advanced stats columns (example: \"Player\", \"PER\", \"TS%\", \"USG%\")\n    adv_cols = [\"Player\", \"Year\"]\n    for col in [\"PER\", \"TS%\", \"USG%\"]:\n        if col in df_adv.columns:\n            adv_cols.append(col)\n    df_adv = df_adv[adv_cols]\n    df_adv = df_adv.dropna(subset=adv_cols[2:])  # Drop rows with missing advanced stats\n\n    # Merge per-game and advanced stats on Player and Year\n    df_merged = pd.merge(df_reg, df_adv, how=\"inner\", on=[\"Player\", \"Year\"])\n",
                    "fullPath": "/project/workspace/scraper.py",
                    "id": "42bebc2d-3a7e-4f91-bc59-75819564c02f",
                    "offset": 1322,
                    "filename": "scraper.py"
                },
                "editPromptValue": "",
                "title": "Scraping and Merging Advanced NBA Player Statistics",
                "summaryMappings": {
                    "high_unstructured": [
                        {
                            "summaryComponent": "scrapes the advanced statistics table for NBA players from a given season's basketball-reference webpage",
                            "codeSegments": [
                                {
                                    "line": 41,
                                    "code": "df_adv = pd.read_html(base_url_adv, header=0)[0]"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "ensuring repeated header rows are removed",
                            "codeSegments": [
                                {
                                    "line": 42,
                                    "code": "df_adv = df_adv[df_adv[\"Player\"] != \"Player\"]  # remove repeated header rows"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "the season year is recorded",
                            "codeSegments": [
                                {
                                    "line": 43,
                                    "code": "df_adv[\"Year\"] = year"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "dynamically selects only the relevant advanced stats columns (Player, Year, PER, TS%, USG%) that are present",
                            "codeSegments": [
                                {
                                    "line": 45,
                                    "code": "adv_cols = [\"Player\", \"Year\"]"
                                },
                                {
                                    "line": 46,
                                    "code": "for col in [\"PER\", \"TS%\", \"USG%\"]:"
                                },
                                {
                                    "line": 47,
                                    "code": "if col in df_adv.columns:"
                                },
                                {
                                    "line": 48,
                                    "code": "adv_cols.append(col)"
                                },
                                {
                                    "line": 49,
                                    "code": "df_adv = df_adv[adv_cols]"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "filters out any rows with missing advanced statistics to maintain data integrity",
                            "codeSegments": [
                                {
                                    "line": 50,
                                    "code": "df_adv = df_adv.dropna(subset=adv_cols[2:])  # Drop rows with missing advanced stats"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "The cleaned advanced stats DataFrame is then merged with the previously scraped per-game stats DataFrame using an inner join on Player and Year",
                            "codeSegments": [
                                {
                                    "line": 53,
                                    "code": "df_merged = pd.merge(df_reg, df_adv, how=\"inner\", on=[\"Player\", \"Year\"])"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "so only players with complete data in both datasets are included",
                            "codeSegments": [
                                {
                                    "line": 53,
                                    "code": "how=\"inner\""
                                }
                            ]
                        },
                        {
                            "summaryComponent": "results in a comprehensive, season-specific dataset combining both per-game and advanced player statistics",
                            "codeSegments": [
                                {
                                    "line": 53,
                                    "code": "df_merged = pd.merge(df_reg, df_adv, how=\"inner\", on=[\"Player\", \"Year\"])"
                                }
                            ]
                        }
                    ],
                    "medium_unstructured": [
                        {
                            "summaryComponent": "reads advanced player statistics from a basketball-reference webpage",
                            "codeSegments": [
                                {
                                    "line": 41,
                                    "code": "df_adv = pd.read_html(base_url_adv, header=0)[0]"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "filters out repeated headers",
                            "codeSegments": [
                                {
                                    "line": 42,
                                    "code": "df_adv = df_adv[df_adv[\"Player\"] != \"Player\"]  # remove repeated header rows"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "keeps only key columns like PER, TS%, and USG% if present",
                            "codeSegments": [
                                {
                                    "line": 45,
                                    "code": "adv_cols = [\"Player\", \"Year\"]"
                                },
                                {
                                    "line": 46,
                                    "code": "for col in [\"PER\", \"TS%\", \"USG%\"]:"
                                },
                                {
                                    "line": 47,
                                    "code": "if col in df_adv.columns:"
                                },
                                {
                                    "line": 48,
                                    "code": "adv_cols.append(col)"
                                },
                                {
                                    "line": 49,
                                    "code": "df_adv = df_adv[adv_cols]"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "removes rows with missing advanced stats",
                            "codeSegments": [
                                {
                                    "line": 50,
                                    "code": "df_adv = df_adv.dropna(subset=adv_cols[2:])  # Drop rows with missing advanced stats"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "merges this cleaned data with per-game stats on Player and Year",
                            "codeSegments": [
                                {
                                    "line": 53,
                                    "code": "df_merged = pd.merge(df_reg, df_adv, how=\"inner\", on=[\"Player\", \"Year\"])"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "ensures that only players with complete advanced and per-game stats are included in the final merged dataset",
                            "codeSegments": [
                                {
                                    "line": 53,
                                    "code": "df_merged = pd.merge(df_reg, df_adv, how=\"inner\", on=[\"Player\", \"Year\"])"
                                }
                            ]
                        }
                    ],
                    "high_structured": [
                        {
                            "summaryComponent": "Reads the advanced stats table from the basketball-reference URL for the specified year",
                            "codeSegments": [
                                {
                                    "line": 41,
                                    "code": "df_adv = pd.read_html(base_url_adv, header=0)[0]"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "Removes any repeated header rows",
                            "codeSegments": [
                                {
                                    "line": 42,
                                    "code": "df_adv = df_adv[df_adv[\"Player\"] != \"Player\"]  # remove repeated header rows"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "Adds a 'Year' column to tag each row with the season",
                            "codeSegments": [
                                {
                                    "line": 43,
                                    "code": "df_adv[\"Year\"] = year"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "Always includes 'Player' and 'Year'",
                            "codeSegments": [
                                {
                                    "line": 45,
                                    "code": "adv_cols = [\"Player\", \"Year\"]"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "Adds 'PER', 'TS%', and 'USG%' if they exist in the table",
                            "codeSegments": [
                                {
                                    "line": 46,
                                    "code": "for col in [\"PER\", \"TS%\", \"USG%\"]:"
                                },
                                {
                                    "line": 47,
                                    "code": "if col in df_adv.columns:"
                                },
                                {
                                    "line": 48,
                                    "code": "adv_cols.append(col)"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "Filters out any rows with missing values in the advanced stats columns",
                            "codeSegments": [
                                {
                                    "line": 50,
                                    "code": "df_adv = df_adv.dropna(subset=adv_cols[2:])  # Drop rows with missing advanced stats"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "Merges the cleaned advanced stats DataFrame with the per-game stats DataFrame (df_reg)",
                            "codeSegments": [
                                {
                                    "line": 53,
                                    "code": "df_merged = pd.merge(df_reg, df_adv, how=\"inner\", on=[\"Player\", \"Year\"])"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "Uses an inner join on 'Player' and 'Year'",
                            "codeSegments": [
                                {
                                    "line": 53,
                                    "code": "df_merged = pd.merge(df_reg, df_adv, how=\"inner\", on=[\"Player\", \"Year\"])"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "Ensures only players with complete data in both tables are included",
                            "codeSegments": [
                                {
                                    "line": 53,
                                    "code": "df_merged = pd.merge(df_reg, df_adv, how=\"inner\", on=[\"Player\", \"Year\"])"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "Produces a merged DataFrame containing both per-game and advanced stats for each player and season",
                            "codeSegments": [
                                {
                                    "line": 53,
                                    "code": "df_merged = pd.merge(df_reg, df_adv, how=\"inner\", on=[\"Player\", \"Year\"])"
                                }
                            ]
                        }
                    ],
                    "low_unstructured": [
                        {
                            "summaryComponent": "scrapes advanced NBA player stats for a season",
                            "codeSegments": [
                                {
                                    "line": 41,
                                    "code": "df_adv = pd.read_html(base_url_adv, header=0)[0]"
                                },
                                {
                                    "line": 43,
                                    "code": "df_adv[\"Year\"] = year"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "filters relevant columns",
                            "codeSegments": [
                                {
                                    "line": 45,
                                    "code": "adv_cols = [\"Player\", \"Year\"]"
                                },
                                {
                                    "line": 46,
                                    "code": "for col in [\"PER\", \"TS%\", \"USG%\"]:"
                                },
                                {
                                    "line": 47,
                                    "code": "if col in df_adv.columns:"
                                },
                                {
                                    "line": 48,
                                    "code": "adv_cols.append(col)"
                                },
                                {
                                    "line": 49,
                                    "code": "df_adv = df_adv[adv_cols]"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "removes incomplete data",
                            "codeSegments": [
                                {
                                    "line": 50,
                                    "code": "df_adv = df_adv.dropna(subset=adv_cols[2:])  # Drop rows with missing advanced stats"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "merges them with per-game stats",
                            "codeSegments": [
                                {
                                    "line": 53,
                                    "code": "df_merged = pd.merge(df_reg, df_adv, how=\"inner\", on=[\"Player\", \"Year\"])"
                                }
                            ]
                        }
                    ],
                    "low_structured": [
                        {
                            "summaryComponent": "Scrapes advanced stats from a webpage",
                            "codeSegments": [
                                {
                                    "line": 41,
                                    "code": "df_adv = pd.read_html(base_url_adv, header=0)[0]"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "Filters and cleans the data",
                            "codeSegments": [
                                {
                                    "line": 42,
                                    "code": "df_adv = df_adv[df_adv[\"Player\"] != \"Player\"]  # remove repeated header rows"
                                },
                                {
                                    "line": 43,
                                    "code": "df_adv[\"Year\"] = year"
                                },
                                {
                                    "line": 45,
                                    "code": "adv_cols = [\"Player\", \"Year\"]"
                                },
                                {
                                    "line": 46,
                                    "code": "for col in [\"PER\", \"TS%\", \"USG%\"]:"
                                },
                                {
                                    "line": 47,
                                    "code": "if col in df_adv.columns:"
                                },
                                {
                                    "line": 48,
                                    "code": "adv_cols.append(col)"
                                },
                                {
                                    "line": 49,
                                    "code": "df_adv = df_adv[adv_cols]"
                                },
                                {
                                    "line": 50,
                                    "code": "df_adv = df_adv.dropna(subset=adv_cols[2:])  # Drop rows with missing advanced stats"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "Merges with per-game stats",
                            "codeSegments": [
                                {
                                    "line": 53,
                                    "code": "df_merged = pd.merge(df_reg, df_adv, how=\"inner\", on=[\"Player\", \"Year\"])"
                                }
                            ]
                        }
                    ],
                    "medium_structured": [
                        {
                            "summaryComponent": "Reads advanced stats table from a specified URL",
                            "codeSegments": [
                                {
                                    "line": 41,
                                    "code": "df_adv = pd.read_html(base_url_adv, header=0)[0]"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "Cleans the data by removing repeated header rows",
                            "codeSegments": [
                                {
                                    "line": 42,
                                    "code": "df_adv = df_adv[df_adv[\"Player\"] != \"Player\"]  # remove repeated header rows"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "Selects only relevant columns (Player, Year, and available advanced stats)",
                            "codeSegments": [
                                {
                                    "line": 45,
                                    "code": "adv_cols = [\"Player\", \"Year\"]"
                                },
                                {
                                    "line": 46,
                                    "code": "for col in [\"PER\", \"TS%\", \"USG%\"]:"
                                },
                                {
                                    "line": 47,
                                    "code": "if col in df_adv.columns:"
                                },
                                {
                                    "line": 48,
                                    "code": "adv_cols.append(col)"
                                },
                                {
                                    "line": 49,
                                    "code": "df_adv = df_adv[adv_cols]"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "Removes rows with missing advanced stats",
                            "codeSegments": [
                                {
                                    "line": 50,
                                    "code": "df_adv = df_adv.dropna(subset=adv_cols[2:])  # Drop rows with missing advanced stats"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "Merges the cleaned advanced stats with per-game stats based on Player and Year",
                            "codeSegments": [
                                {
                                    "line": 53,
                                    "code": "df_merged = pd.merge(df_reg, df_adv, how=\"inner\", on=[\"Player\", \"Year\"])"
                                }
                            ]
                        }
                    ]
                }
            }
        },
        "timestamp": "2025-08-16 22:55:00.000",
        "id": "CRVSidWfm02CkD1XNRgR"
    },
    {
        "source": "frontend",
        "event": "autotransit_section",
        "data": {
            "before_section_id": "124b9b5f-6151-450a-9107-101530543ad5",
            "after_section_id": "42bebc2d-3a7e-4f91-bc59-75819564c02f"
        },
        "timestamp": "2025-08-16 22:55:00.000",
        "id": "Tr748MNZ9nM3hEg37LXj"
    },
    {
        "source": "backend",
        "event": "map_summary_code",
        "data": {
            "summary": "This code segment scrapes the advanced statistics table for NBA players from a given season's basketball-reference webpage, ensuring repeated header rows are removed and the season year is recorded. It dynamically selects only the relevant advanced stats columns (Player, Year, PER, TS%, USG%) that are present, and filters out any rows with missing advanced statistics to maintain data integrity. The cleaned advanced stats DataFrame is then merged with the previously scraped per-game stats DataFrame using an inner join on Player and Year, so only players with complete data in both datasets are included. This process results in a comprehensive, season-specific dataset combining both per-game and advanced player statistics.",
            "mapping": [
                {
                    "summaryComponent": "scrapes the advanced statistics table for NBA players from a given season's basketball-reference webpage",
                    "codeSegments": [
                        {
                            "line": 41,
                            "code": "df_adv = pd.read_html(base_url_adv, header=0)[0]"
                        }
                    ]
                },
                {
                    "summaryComponent": "ensuring repeated header rows are removed",
                    "codeSegments": [
                        {
                            "line": 42,
                            "code": "df_adv = df_adv[df_adv[\"Player\"] != \"Player\"]  # remove repeated header rows"
                        }
                    ]
                },
                {
                    "summaryComponent": "the season year is recorded",
                    "codeSegments": [
                        {
                            "line": 43,
                            "code": "df_adv[\"Year\"] = year"
                        }
                    ]
                },
                {
                    "summaryComponent": "dynamically selects only the relevant advanced stats columns (Player, Year, PER, TS%, USG%) that are present",
                    "codeSegments": [
                        {
                            "line": 45,
                            "code": "adv_cols = [\"Player\", \"Year\"]"
                        },
                        {
                            "line": 46,
                            "code": "for col in [\"PER\", \"TS%\", \"USG%\"]:"
                        },
                        {
                            "line": 47,
                            "code": "if col in df_adv.columns:"
                        },
                        {
                            "line": 48,
                            "code": "adv_cols.append(col)"
                        },
                        {
                            "line": 49,
                            "code": "df_adv = df_adv[adv_cols]"
                        }
                    ]
                },
                {
                    "summaryComponent": "filters out any rows with missing advanced statistics to maintain data integrity",
                    "codeSegments": [
                        {
                            "line": 50,
                            "code": "df_adv = df_adv.dropna(subset=adv_cols[2:])  # Drop rows with missing advanced stats"
                        }
                    ]
                },
                {
                    "summaryComponent": "The cleaned advanced stats DataFrame is then merged with the previously scraped per-game stats DataFrame using an inner join on Player and Year",
                    "codeSegments": [
                        {
                            "line": 53,
                            "code": "df_merged = pd.merge(df_reg, df_adv, how=\"inner\", on=[\"Player\", \"Year\"])"
                        }
                    ]
                },
                {
                    "summaryComponent": "so only players with complete data in both datasets are included",
                    "codeSegments": [
                        {
                            "line": 53,
                            "code": "how=\"inner\""
                        }
                    ]
                },
                {
                    "summaryComponent": "results in a comprehensive, season-specific dataset combining both per-game and advanced player statistics",
                    "codeSegments": [
                        {
                            "line": 53,
                            "code": "df_merged = pd.merge(df_reg, df_adv, how=\"inner\", on=[\"Player\", \"Year\"])"
                        }
                    ]
                }
            ],
            "code": "40:     # Scrape advanced stats\n41:     df_adv = pd.read_html(base_url_adv, header=0)[0]\n42:     df_adv = df_adv[df_adv[\"Player\"] != \"Player\"]  # remove repeated header rows\n43:     df_adv[\"Year\"] = year\n44:     # Keep only relevant advanced stats columns (example: \"Player\", \"PER\", \"TS%\", \"USG%\")\n45:     adv_cols = [\"Player\", \"Year\"]\n46:     for col in [\"PER\", \"TS%\", \"USG%\"]:\n47:         if col in df_adv.columns:\n48:             adv_cols.append(col)\n49:     df_adv = df_adv[adv_cols]\n50:     df_adv = df_adv.dropna(subset=adv_cols[2:])  # Drop rows with missing advanced stats\n51: \n52:     # Merge per-game and advanced stats on Player and Year\n53:     df_merged = pd.merge(df_reg, df_adv, how=\"inner\", on=[\"Player\", \"Year\"])\n54: "
        },
        "timestamp": "2025-08-16 22:55:00.000",
        "id": "VpS6gzwM6SBLo2vS1YIP"
    },
    {
        "source": "backend",
        "event": "map_summary_code",
        "data": {
            "summary": "• Reads the advanced stats table from the basketball-reference URL for the specified year\n• Cleans the DataFrame:\n  ◦ Removes any repeated header rows\n  ◦ Adds a 'Year' column to tag each row with the season\n• Dynamically selects columns:\n  ◦ Always includes 'Player' and 'Year'\n  ◦ Adds 'PER', 'TS%', and 'USG%' if they exist in the table\n• Filters out any rows with missing values in the advanced stats columns\n• Merges the cleaned advanced stats DataFrame with the per-game stats DataFrame (df_reg):\n  ◦ Uses an inner join on 'Player' and 'Year'\n  ◦ Ensures only players with complete data in both tables are included\n• Produces a merged DataFrame containing both per-game and advanced stats for each player and season",
            "mapping": [
                {
                    "summaryComponent": "Reads the advanced stats table from the basketball-reference URL for the specified year",
                    "codeSegments": [
                        {
                            "line": 41,
                            "code": "df_adv = pd.read_html(base_url_adv, header=0)[0]"
                        }
                    ]
                },
                {
                    "summaryComponent": "Removes any repeated header rows",
                    "codeSegments": [
                        {
                            "line": 42,
                            "code": "df_adv = df_adv[df_adv[\"Player\"] != \"Player\"]  # remove repeated header rows"
                        }
                    ]
                },
                {
                    "summaryComponent": "Adds a 'Year' column to tag each row with the season",
                    "codeSegments": [
                        {
                            "line": 43,
                            "code": "df_adv[\"Year\"] = year"
                        }
                    ]
                },
                {
                    "summaryComponent": "Always includes 'Player' and 'Year'",
                    "codeSegments": [
                        {
                            "line": 45,
                            "code": "adv_cols = [\"Player\", \"Year\"]"
                        }
                    ]
                },
                {
                    "summaryComponent": "Adds 'PER', 'TS%', and 'USG%' if they exist in the table",
                    "codeSegments": [
                        {
                            "line": 46,
                            "code": "for col in [\"PER\", \"TS%\", \"USG%\"]:"
                        },
                        {
                            "line": 47,
                            "code": "if col in df_adv.columns:"
                        },
                        {
                            "line": 48,
                            "code": "adv_cols.append(col)"
                        }
                    ]
                },
                {
                    "summaryComponent": "Filters out any rows with missing values in the advanced stats columns",
                    "codeSegments": [
                        {
                            "line": 50,
                            "code": "df_adv = df_adv.dropna(subset=adv_cols[2:])  # Drop rows with missing advanced stats"
                        }
                    ]
                },
                {
                    "summaryComponent": "Merges the cleaned advanced stats DataFrame with the per-game stats DataFrame (df_reg)",
                    "codeSegments": [
                        {
                            "line": 53,
                            "code": "df_merged = pd.merge(df_reg, df_adv, how=\"inner\", on=[\"Player\", \"Year\"])"
                        }
                    ]
                },
                {
                    "summaryComponent": "Uses an inner join on 'Player' and 'Year'",
                    "codeSegments": [
                        {
                            "line": 53,
                            "code": "df_merged = pd.merge(df_reg, df_adv, how=\"inner\", on=[\"Player\", \"Year\"])"
                        }
                    ]
                },
                {
                    "summaryComponent": "Ensures only players with complete data in both tables are included",
                    "codeSegments": [
                        {
                            "line": 53,
                            "code": "df_merged = pd.merge(df_reg, df_adv, how=\"inner\", on=[\"Player\", \"Year\"])"
                        }
                    ]
                },
                {
                    "summaryComponent": "Produces a merged DataFrame containing both per-game and advanced stats for each player and season",
                    "codeSegments": [
                        {
                            "line": 53,
                            "code": "df_merged = pd.merge(df_reg, df_adv, how=\"inner\", on=[\"Player\", \"Year\"])"
                        }
                    ]
                }
            ],
            "code": "40:     # Scrape advanced stats\n41:     df_adv = pd.read_html(base_url_adv, header=0)[0]\n42:     df_adv = df_adv[df_adv[\"Player\"] != \"Player\"]  # remove repeated header rows\n43:     df_adv[\"Year\"] = year\n44:     # Keep only relevant advanced stats columns (example: \"Player\", \"PER\", \"TS%\", \"USG%\")\n45:     adv_cols = [\"Player\", \"Year\"]\n46:     for col in [\"PER\", \"TS%\", \"USG%\"]:\n47:         if col in df_adv.columns:\n48:             adv_cols.append(col)\n49:     df_adv = df_adv[adv_cols]\n50:     df_adv = df_adv.dropna(subset=adv_cols[2:])  # Drop rows with missing advanced stats\n51: \n52:     # Merge per-game and advanced stats on Player and Year\n53:     df_merged = pd.merge(df_reg, df_adv, how=\"inner\", on=[\"Player\", \"Year\"])\n54: "
        },
        "timestamp": "2025-08-16 22:55:00.000",
        "id": "oipcyaBPi9P5woNGQ34q"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "124b9b5f-6151-450a-9107-101530543ad5",
            "mapping_index": 6,
            "structured_type": "unstructured",
            "detail_level": "medium"
        },
        "timestamp": "2025-08-16 22:55:00.000",
        "id": "xVVtTzAzS1J0SbwpyWMj"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "124b9b5f-6151-450a-9107-101530543ad5",
            "detail_level": "medium",
            "structured_type": "unstructured"
        },
        "timestamp": "2025-08-16 22:55:00.000",
        "id": "z2i2W4aPW1Tw1L6O3CZ2"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "42bebc2d-3a7e-4f91-bc59-75819564c02f",
            "detail_level": "medium",
            "structured_type": "unstructured"
        },
        "timestamp": "2025-08-16 22:55:02.000",
        "id": "1A0TMwtJycKHyBEDpm17"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "42bebc2d-3a7e-4f91-bc59-75819564c02f",
            "mapping_index": 4,
            "structured_type": "unstructured",
            "detail_level": "medium"
        },
        "timestamp": "2025-08-16 22:55:02.000",
        "id": "1ftlp93YNW6YSOd0la7d"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "42bebc2d-3a7e-4f91-bc59-75819564c02f",
            "mapping_index": 2,
            "structured_type": "unstructured",
            "detail_level": "medium"
        },
        "timestamp": "2025-08-16 22:55:02.000",
        "id": "8LhQJDVm22irEX8aZd3N"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "42bebc2d-3a7e-4f91-bc59-75819564c02f",
            "mapping_index": 3,
            "structured_type": "unstructured",
            "detail_level": "medium"
        },
        "timestamp": "2025-08-16 22:55:03.000",
        "id": "D6r6jZ1t8opSjCmE9MlG"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "42bebc2d-3a7e-4f91-bc59-75819564c02f",
            "mapping_index": 4,
            "structured_type": "unstructured",
            "detail_level": "medium"
        },
        "timestamp": "2025-08-16 22:55:03.000",
        "id": "IXdoobJOxAKbZtIAaX93"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "42bebc2d-3a7e-4f91-bc59-75819564c02f",
            "detail_level": "medium",
            "structured_type": "unstructured"
        },
        "timestamp": "2025-08-16 22:55:03.000",
        "id": "Nv4mi4w1WaCVQVAsXwXL"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "42bebc2d-3a7e-4f91-bc59-75819564c02f",
            "detail_level": "medium",
            "structured_type": "unstructured"
        },
        "timestamp": "2025-08-16 22:55:03.000",
        "id": "SJLdDpBka1i1YbeXQYSX"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "42bebc2d-3a7e-4f91-bc59-75819564c02f",
            "detail_level": "medium",
            "structured_type": "unstructured"
        },
        "timestamp": "2025-08-16 22:55:04.000",
        "id": "YUlICNUv4Khqu4WxYz0B"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "42bebc2d-3a7e-4f91-bc59-75819564c02f",
            "mapping_index": 2,
            "structured_type": "unstructured",
            "detail_level": "medium"
        },
        "timestamp": "2025-08-16 22:55:04.000",
        "id": "kFq1szFIdKpp5yRqGKae"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "42bebc2d-3a7e-4f91-bc59-75819564c02f",
            "detail_level": "medium",
            "structured_type": "unstructured"
        },
        "timestamp": "2025-08-16 22:55:04.000",
        "id": "rUHX1BvCtmpWY1gN7vaB"
    },
    {
        "source": "frontend",
        "event": "click_edit_in_prompt",
        "data": {
            "section_id": "42bebc2d-3a7e-4f91-bc59-75819564c02f",
            "summary": "The code reads advanced player statistics from a basketball-reference webpage, filters out repeated headers, and keeps only key columns like PER, TS%, and USG% if present. It removes rows with missing advanced stats and merges this cleaned data with per-game stats on Player and Year. This ensures that only players with complete advanced and per-game stats are included in the final merged dataset.",
            "detail_level": "medium",
            "structured": "unstructured"
        },
        "timestamp": "2025-08-16 22:55:05.000",
        "id": "B6hhOaQLUZxB69zI2KJU"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "42bebc2d-3a7e-4f91-bc59-75819564c02f",
            "mapping_index": 2,
            "structured_type": "unstructured",
            "detail_level": "medium"
        },
        "timestamp": "2025-08-16 22:55:05.000",
        "id": "KcoFh5T0lNpnCuFtGrRV"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "42bebc2d-3a7e-4f91-bc59-75819564c02f",
            "detail_level": "medium",
            "structured_type": "unstructured"
        },
        "timestamp": "2025-08-16 22:55:05.000",
        "id": "NMJzOihbPPPQyGGYlzRg"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "42bebc2d-3a7e-4f91-bc59-75819564c02f",
            "detail_level": "medium",
            "structured_type": "unstructured"
        },
        "timestamp": "2025-08-16 22:55:05.000",
        "id": "YrQwiLoj2Xh8knU72jgi"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "42bebc2d-3a7e-4f91-bc59-75819564c02f",
            "mapping_index": 5,
            "structured_type": "unstructured",
            "detail_level": "medium"
        },
        "timestamp": "2025-08-16 22:55:05.000",
        "id": "gYhWB9XDqnKI6Hi6Ybcz"
    },
    {
        "source": "frontend",
        "event": "commit_modified_summary",
        "data": {
            "section_id": "42bebc2d-3a7e-4f91-bc59-75819564c02f",
            "edited_summary": "The code reads advanced player statistics from a basketball-reference webpage, filters out repeated headers, and keeps only key columns like BPM, WS/48, TS%, VORP, WS, PER if present. It removes rows with missing advanced stats and merges this cleaned data with per-game stats on Player and Year. This ensures that only players with complete advanced and per-game stats are included in the final merged dataset.",
            "detail_level": "medium",
            "original_summary": "The code reads advanced player statistics from a basketball-reference webpage, filters out repeated headers, and keeps only key columns like PER, TS%, and USG% if present. It removes rows with missing advanced stats and merges this cleaned data with per-game stats on Player and Year. This ensures that only players with complete advanced and per-game stats are included in the final merged dataset.",
            "structured": "unstructured"
        },
        "timestamp": "2025-08-16 22:55:46.000",
        "id": "jEWcA2IErRW8xJRcC7h3"
    },
    {
        "source": "backend",
        "event": "modify_summary_mediation",
        "data": {
            "original_code": "    # Scrape advanced stats\n    df_adv = pd.read_html(base_url_adv, header=0)[0]\n    df_adv = df_adv[df_adv[\"Player\"] != \"Player\"]  # remove repeated header rows\n    df_adv[\"Year\"] = year\n    # Keep only relevant advanced stats columns (example: \"Player\", \"PER\", \"TS%\", \"USG%\")\n    adv_cols = [\"Player\", \"Year\"]\n    for col in [\"PER\", \"TS%\", \"USG%\"]:\n        if col in df_adv.columns:\n            adv_cols.append(col)\n    df_adv = df_adv[adv_cols]\n    df_adv = df_adv.dropna(subset=adv_cols[2:])  # Drop rows with missing advanced stats\n\n    # Merge per-game and advanced stats on Player and Year\n    df_merged = pd.merge(df_reg, df_adv, how=\"inner\", on=[\"Player\", \"Year\"])\n",
            "original_summary": "The code reads advanced player statistics from a basketball-reference webpage, filters out repeated headers, and keeps only key columns like PER, TS%, and USG% if present. It removes rows with missing advanced stats and merges this cleaned data with per-game stats on Player and Year. This ensures that only players with complete advanced and per-game stats are included in the final merged dataset.",
            "edited_summary": "The code reads advanced player statistics from a basketball-reference webpage, filters out repeated headers, and keeps only key columns like BPM, WS/48, TS%, VORP, WS, PER if present. It removes rows with missing advanced stats and merges this cleaned data with per-game stats on Player and Year. This ensures that only players with complete advanced and per-game stats are included in the final merged dataset.",
            "structured_type": "unstructured",
            "detail_level": "medium",
            "updated_code": "# Scrape advanced stats\n    df_adv = pd.read_html(base_url_adv, header=0)[0]\n    df_adv = df_adv[df_adv[\"Player\"] != \"Player\"]  # remove repeated header rows\n    df_adv[\"Year\"] = year\n    # Keep only relevant advanced stats columns (example: \"Player\", \"BPM\", \"WS/48\", \"TS%\", \"VORP\", \"WS\", \"PER\")\n    adv_cols = [\"Player\", \"Year\"]\n    for col in [\"BPM\", \"WS/48\", \"TS%\", \"VORP\", \"WS\", \"PER\"]:\n        if col in df_adv.columns:\n            adv_cols.append(col)\n    df_adv = df_adv[adv_cols]\n    df_adv = df_adv.dropna(subset=adv_cols[2:])  # Drop rows with missing advanced stats\n\n    # Merge per-game and advanced stats on Player and Year\n    df_merged = pd.merge(df_reg, df_adv, how=\"inner\", on=[\"Player\", \"Year\"])"
        },
        "timestamp": "2025-08-16 22:55:48.000",
        "id": "Ibq6N28hu0kLHLvWcNG6"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "42bebc2d-3a7e-4f91-bc59-75819564c02f",
            "mapping_index": 5,
            "structured_type": "unstructured",
            "detail_level": "medium"
        },
        "timestamp": "2025-08-16 22:55:53.000",
        "id": "4dAN90mfs0zxSbUkcAwS"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "42bebc2d-3a7e-4f91-bc59-75819564c02f",
            "mapping_index": 0,
            "structured_type": "unstructured",
            "detail_level": "medium"
        },
        "timestamp": "2025-08-16 22:55:53.000",
        "id": "LFoly9mAbUKa4BPZYsO7"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "42bebc2d-3a7e-4f91-bc59-75819564c02f",
            "detail_level": "medium",
            "structured_type": "unstructured"
        },
        "timestamp": "2025-08-16 22:55:53.000",
        "id": "VanR0ryD2xc3tqQgUReo"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "42bebc2d-3a7e-4f91-bc59-75819564c02f",
            "detail_level": "medium",
            "structured_type": "unstructured"
        },
        "timestamp": "2025-08-16 22:55:53.000",
        "id": "g8Hl02jjI4fLnQ7WWdoy"
    },
    {
        "source": "backend",
        "event": "summarize_modified_code",
        "data": {
            "new_code": "    # Scrape advanced stats\n    df_adv = pd.read_html(base_url_adv, header=0)[0]\n    df_adv = df_adv[df_adv[\"Player\"] != \"Player\"]  # remove repeated header rows\n    df_adv[\"Year\"] = year\n    # Keep only relevant advanced stats columns (example: \"Player\", \"BPM\", \"WS/48\", \"TS%\", \"VORP\", \"WS\", \"PER\")\n    adv_cols = [\"Player\", \"Year\"]\n    for col in [\"BPM\", \"WS/48\", \"TS%\", \"VORP\", \"WS\", \"PER\"]:\n        if col in df_adv.columns:\n            adv_cols.append(col)\n    df_adv = df_adv[adv_cols]\n    df_adv = df_adv.dropna(subset=adv_cols[2:])  # Drop rows with missing advanced stats\n\n    # Merge per-game and advanced stats on Player and Year\n    df_merged = pd.merge(df_reg, df_adv, how=\"inner\", on=[\"Player\", \"Year\"])",
            "original_code": "    # Scrape advanced stats\n    df_adv = pd.read_html(base_url_adv, header=0)[0]\n    df_adv = df_adv[df_adv[\"Player\"] != \"Player\"]  # remove repeated header rows\n    df_adv[\"Year\"] = year\n    # Keep only relevant advanced stats columns (example: \"Player\", \"BPM\", \"WS/48\", \"TS%\", \"VORP\", \"WS\", \"PER\")\n    adv_cols = [\"Player\", \"Year\"]\n    for col in [\"BPM\", \"WS/48\", \"TS%\", \"VORP\", \"WS\", \"PER\"]:\n        if col in df_adv.columns:\n            adv_cols.append(col)\n    df_adv = df_adv[adv_cols]\n    df_adv = df_adv.dropna(subset=adv_cols[2:])  # Drop rows with missing advanced stats\n\n    # Merge per-game and advanced stats on Player and Year\n    df_merged = pd.merge(df_reg, df_adv, how=\"inner\", on=[\"Player\", \"Year\"])",
            "old_summary": {
                "low_structured": "• Scrapes advanced stats from a webpage\n• Filters and cleans the data\n• Merges with per-game stats",
                "high_unstructured": "This code segment scrapes the advanced statistics table for NBA players from a given season's basketball-reference webpage, ensuring repeated header rows are removed and the season year is recorded. It dynamically selects only the relevant advanced stats columns (Player, Year, PER, TS%, USG%) that are present, and filters out any rows with missing advanced statistics to maintain data integrity. The cleaned advanced stats DataFrame is then merged with the previously scraped per-game stats DataFrame using an inner join on Player and Year, so only players with complete data in both datasets are included. This process results in a comprehensive, season-specific dataset combining both per-game and advanced player statistics.",
                "medium_unstructured": "The code reads advanced player statistics from a basketball-reference webpage, filters out repeated headers, and keeps only key columns like PER, TS%, and USG% if present. It removes rows with missing advanced stats and merges this cleaned data with per-game stats on Player and Year. This ensures that only players with complete advanced and per-game stats are included in the final merged dataset.",
                "high_structured": "• Reads the advanced stats table from the basketball-reference URL for the specified year\n• Cleans the DataFrame:\n  ◦ Removes any repeated header rows\n  ◦ Adds a 'Year' column to tag each row with the season\n• Dynamically selects columns:\n  ◦ Always includes 'Player' and 'Year'\n  ◦ Adds 'PER', 'TS%', and 'USG%' if they exist in the table\n• Filters out any rows with missing values in the advanced stats columns\n• Merges the cleaned advanced stats DataFrame with the per-game stats DataFrame (df_reg):\n  ◦ Uses an inner join on 'Player' and 'Year'\n  ◦ Ensures only players with complete data in both tables are included\n• Produces a merged DataFrame containing both per-game and advanced stats for each player and season",
                "title": "Scraping and Merging Advanced NBA Player Statistics",
                "low_unstructured": "This code scrapes advanced NBA player stats for a season, filters relevant columns, removes incomplete data, and merges them with per-game stats.",
                "medium_structured": "• Reads advanced stats table from a specified URL\n• Cleans the data by removing repeated header rows\n• Selects only relevant columns (Player, Year, and available advanced stats)\n•  Removes rows with missing advanced stats\n• Merges the cleaned advanced stats with per-game stats based on Player and Year"
            },
            "new_summary": {
                "low_structured": "• Scrapes advanced stats from a webpage, now considering BPM, WS/48, VORP, and WS columns\n• Filters and cleans the data\n• Merges with per-game stats",
                "high_unstructured": "This code segment scrapes the advanced statistics table for NBA players from a given season's basketball-reference webpage, ensuring repeated header rows are removed and the season year is recorded. It dynamically selects only the relevant advanced stats columns (Player, Year, PER, TS%, BPM, WS/48, VORP, WS) that are present, and filters out any rows with missing advanced statistics to maintain data integrity. The cleaned advanced stats DataFrame is then merged with the previously scraped per-game stats DataFrame using an inner join on Player and Year, so only players with complete data in both datasets are included. This process results in a comprehensive, season-specific dataset combining both per-game and advanced player statistics.",
                "medium_unstructured": "The code reads advanced player statistics from a basketball-reference webpage, filters out repeated headers, and now keeps only key columns like PER, TS%, BPM, WS/48, VORP, and WS if present. It removes rows with missing advanced stats and merges this cleaned data with per-game stats on Player and Year. This ensures that only players with complete advanced and per-game stats are included in the final merged dataset.",
                "high_structured": "• Reads the advanced stats table from the basketball-reference URL for the specified year\n• Cleans the DataFrame:\n  ◦ Removes any repeated header rows\n  ◦ Adds a 'Year' column to tag each row with the season\n• Dynamically selects columns:\n  ◦ Always includes 'Player' and 'Year'\n  ◦ Adds 'PER', 'TS%', 'BPM', 'WS/48', 'VORP', and 'WS' if they exist in the table\n• Filters out any rows with missing values in the advanced stats columns\n• Merges the cleaned advanced stats DataFrame with the per-game stats DataFrame (df_reg):\n  ◦ Uses an inner join on 'Player' and 'Year'\n  ◦ Ensures only players with complete data in both tables are included\n• Produces a merged DataFrame containing both per-game and advanced stats for each player and season",
                "title": "Scraping and Merging Advanced NBA Player Statistics (Now with BPM, WS/48, VORP, and WS Columns)",
                "low_unstructured": "This code scrapes advanced NBA player stats for a season, now including columns such as BPM, WS/48, VORP, and WS in addition to PER and TS% if present, filters relevant columns, removes incomplete data, and merges them with per-game stats.",
                "medium_structured": "• Reads advanced stats table from a specified URL\n• Cleans the data by removing repeated header rows\n• Selects only relevant columns (Player, Year, and available advanced stats including BPM, WS/48, VORP, and WS)\n•  Removes rows with missing advanced stats\n• Merges the cleaned advanced stats with per-game stats based on Player and Year"
            }
        },
        "timestamp": "2025-08-16 22:55:53.000",
        "id": "isnrulpCc3OGOvlstmj5"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "42bebc2d-3a7e-4f91-bc59-75819564c02f",
            "mapping_index": 3,
            "structured_type": "unstructured",
            "detail_level": "medium"
        },
        "timestamp": "2025-08-16 22:55:53.000",
        "id": "mTO200UIoarLLLbUXvD4"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "42bebc2d-3a7e-4f91-bc59-75819564c02f",
            "mapping_index": 2,
            "structured_type": "unstructured",
            "detail_level": "medium"
        },
        "timestamp": "2025-08-16 22:55:54.000",
        "id": "0dBaCfGcCJNVE6iVnSVl"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "42bebc2d-3a7e-4f91-bc59-75819564c02f",
            "detail_level": "medium",
            "structured_type": "unstructured"
        },
        "timestamp": "2025-08-16 22:55:54.000",
        "id": "8BrTztbWyZc3IKo389JC"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "42bebc2d-3a7e-4f91-bc59-75819564c02f",
            "mapping_index": 5,
            "structured_type": "unstructured",
            "detail_level": "medium"
        },
        "timestamp": "2025-08-16 22:55:54.000",
        "id": "8IVkDyKLTNe1taHYt14t"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "42bebc2d-3a7e-4f91-bc59-75819564c02f",
            "detail_level": "medium",
            "structured_type": "unstructured"
        },
        "timestamp": "2025-08-16 22:55:54.000",
        "id": "fTThLvW9lXJrQ5o4aKiK"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "42bebc2d-3a7e-4f91-bc59-75819564c02f",
            "detail_level": "medium",
            "structured_type": "unstructured"
        },
        "timestamp": "2025-08-16 22:55:54.000",
        "id": "gm7c3Gs64uDf2wAicqoD"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "42bebc2d-3a7e-4f91-bc59-75819564c02f",
            "detail_level": "medium",
            "structured_type": "unstructured"
        },
        "timestamp": "2025-08-16 22:55:54.000",
        "id": "lag031w2zrhvEowXKq7V"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "42bebc2d-3a7e-4f91-bc59-75819564c02f",
            "mapping_index": 2,
            "structured_type": "unstructured",
            "detail_level": "medium"
        },
        "timestamp": "2025-08-16 22:55:54.000",
        "id": "peoJC290fCtu9Xk9FIUQ"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "42bebc2d-3a7e-4f91-bc59-75819564c02f",
            "mapping_index": 1,
            "structured_type": "unstructured",
            "detail_level": "medium"
        },
        "timestamp": "2025-08-16 22:55:54.000",
        "id": "wUzVuOBkPs9n28AMQOqO"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "42bebc2d-3a7e-4f91-bc59-75819564c02f",
            "detail_level": "medium",
            "structured_type": "unstructured"
        },
        "timestamp": "2025-08-16 22:55:54.000",
        "id": "ydJ4ot9fXHYSaxYMzTG9"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "42bebc2d-3a7e-4f91-bc59-75819564c02f",
            "mapping_index": 5,
            "structured_type": "unstructured",
            "detail_level": "medium"
        },
        "timestamp": "2025-08-16 22:55:55.000",
        "id": "6EDrNUG25GliBYgApxUj"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "42bebc2d-3a7e-4f91-bc59-75819564c02f",
            "detail_level": "medium",
            "structured_type": "unstructured"
        },
        "timestamp": "2025-08-16 22:55:55.000",
        "id": "7mKnLEiWDjkxDV8YIGFH"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "42bebc2d-3a7e-4f91-bc59-75819564c02f",
            "detail_level": "medium",
            "structured_type": "unstructured"
        },
        "timestamp": "2025-08-16 22:55:55.000",
        "id": "8YvGf5LnYLnEagGG8tNF"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "42bebc2d-3a7e-4f91-bc59-75819564c02f",
            "mapping_index": 0,
            "structured_type": "unstructured",
            "detail_level": "medium"
        },
        "timestamp": "2025-08-16 22:55:55.000",
        "id": "DT9DtfYbuwtrl3Upps1X"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "42bebc2d-3a7e-4f91-bc59-75819564c02f",
            "detail_level": "medium",
            "structured_type": "unstructured"
        },
        "timestamp": "2025-08-16 22:55:55.000",
        "id": "F4TQ7Ogygz2WVnitT4KL"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "42bebc2d-3a7e-4f91-bc59-75819564c02f",
            "mapping_index": 3,
            "structured_type": "unstructured",
            "detail_level": "medium"
        },
        "timestamp": "2025-08-16 22:55:55.000",
        "id": "PjTVbifxiK2LCTc3eFJa"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "42bebc2d-3a7e-4f91-bc59-75819564c02f",
            "mapping_index": 0,
            "structured_type": "unstructured",
            "detail_level": "medium"
        },
        "timestamp": "2025-08-16 22:55:55.000",
        "id": "UE3JRmWTgIaOtf0FQxTj"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "42bebc2d-3a7e-4f91-bc59-75819564c02f",
            "mapping_index": 0,
            "structured_type": "unstructured",
            "detail_level": "medium"
        },
        "timestamp": "2025-08-16 22:55:55.000",
        "id": "gsFPx3Gn0Kl5OO3gfMka"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "42bebc2d-3a7e-4f91-bc59-75819564c02f",
            "detail_level": "medium",
            "structured_type": "unstructured"
        },
        "timestamp": "2025-08-16 22:55:55.000",
        "id": "qKts4dSd27ZxC9eqzvQl"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "42bebc2d-3a7e-4f91-bc59-75819564c02f",
            "detail_level": "medium",
            "structured_type": "unstructured"
        },
        "timestamp": "2025-08-16 22:55:55.000",
        "id": "sGfZIMmrfQpATPb6DshS"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "42bebc2d-3a7e-4f91-bc59-75819564c02f",
            "detail_level": "medium",
            "structured_type": "unstructured"
        },
        "timestamp": "2025-08-16 22:55:56.000",
        "id": "6rTzyNhbLrBwBLvKcw8z"
    },
    {
        "source": "backend",
        "event": "map_summary_code",
        "data": {
            "summary": "This code scrapes advanced NBA player stats for a season, now including columns such as BPM, WS/48, VORP, and WS in addition to PER and TS% if present, filters relevant columns, removes incomplete data, and merges them with per-game stats.",
            "mapping": [
                {
                    "summaryComponent": "scrapes advanced NBA player stats for a season",
                    "codeSegments": [
                        {
                            "line": 41,
                            "code": "df_adv = pd.read_html(base_url_adv, header=0)[0]"
                        },
                        {
                            "line": 43,
                            "code": "df_adv[\"Year\"] = year"
                        }
                    ]
                },
                {
                    "summaryComponent": "now including columns such as BPM, WS/48, VORP, and WS in addition to PER and TS% if present",
                    "codeSegments": [
                        {
                            "line": 46,
                            "code": "for col in [\"BPM\", \"WS/48\", \"TS%\", \"VORP\", \"WS\", \"PER\"]:"
                        },
                        {
                            "line": 47,
                            "code": "if col in df_adv.columns:"
                        },
                        {
                            "line": 48,
                            "code": "adv_cols.append(col)"
                        }
                    ]
                },
                {
                    "summaryComponent": "filters relevant columns",
                    "codeSegments": [
                        {
                            "line": 49,
                            "code": "df_adv = df_adv[adv_cols]"
                        }
                    ]
                },
                {
                    "summaryComponent": "removes incomplete data",
                    "codeSegments": [
                        {
                            "line": 50,
                            "code": "df_adv = df_adv.dropna(subset=adv_cols[2:])  # Drop rows with missing advanced stats"
                        }
                    ]
                },
                {
                    "summaryComponent": "merges them with per-game stats",
                    "codeSegments": [
                        {
                            "line": 53,
                            "code": "df_merged = pd.merge(df_reg, df_adv, how=\"inner\", on=[\"Player\", \"Year\"])"
                        }
                    ]
                }
            ],
            "code": "40:     # Scrape advanced stats\n41:     df_adv = pd.read_html(base_url_adv, header=0)[0]\n42:     df_adv = df_adv[df_adv[\"Player\"] != \"Player\"]  # remove repeated header rows\n43:     df_adv[\"Year\"] = year\n44:     # Keep only relevant advanced stats columns (example: \"Player\", \"BPM\", \"WS/48\", \"TS%\", \"VORP\", \"WS\", \"PER\")\n45:     adv_cols = [\"Player\", \"Year\"]\n46:     for col in [\"BPM\", \"WS/48\", \"TS%\", \"VORP\", \"WS\", \"PER\"]:\n47:         if col in df_adv.columns:\n48:             adv_cols.append(col)\n49:     df_adv = df_adv[adv_cols]\n50:     df_adv = df_adv.dropna(subset=adv_cols[2:])  # Drop rows with missing advanced stats\n51: \n52:     # Merge per-game and advanced stats on Player and Year\n53:     df_merged = pd.merge(df_reg, df_adv, how=\"inner\", on=[\"Player\", \"Year\"])"
        },
        "timestamp": "2025-08-16 22:55:56.000",
        "id": "RundBddxt7LrLntaCEvF"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "42bebc2d-3a7e-4f91-bc59-75819564c02f",
            "detail_level": "medium",
            "structured_type": "unstructured"
        },
        "timestamp": "2025-08-16 22:55:56.000",
        "id": "SMYmqlLnCcy1jvdJbW4D"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "42bebc2d-3a7e-4f91-bc59-75819564c02f",
            "detail_level": "medium",
            "structured_type": "unstructured"
        },
        "timestamp": "2025-08-16 22:55:56.000",
        "id": "anEzTSsEHoN8u3TB513m"
    },
    {
        "source": "backend",
        "event": "map_summary_code",
        "data": {
            "summary": "• Reads advanced stats table from a specified URL\n• Cleans the data by removing repeated header rows\n• Selects only relevant columns (Player, Year, and available advanced stats including BPM, WS/48, VORP, and WS)\n•  Removes rows with missing advanced stats\n• Merges the cleaned advanced stats with per-game stats based on Player and Year",
            "mapping": [
                {
                    "summaryComponent": "Reads advanced stats table from a specified URL",
                    "codeSegments": [
                        {
                            "line": 41,
                            "code": "df_adv = pd.read_html(base_url_adv, header=0)[0]"
                        }
                    ]
                },
                {
                    "summaryComponent": "Cleans the data by removing repeated header rows",
                    "codeSegments": [
                        {
                            "line": 42,
                            "code": "df_adv = df_adv[df_adv[\"Player\"] != \"Player\"]  # remove repeated header rows"
                        }
                    ]
                },
                {
                    "summaryComponent": "Selects only relevant columns (Player, Year, and available advanced stats including BPM, WS/48, VORP, and WS)",
                    "codeSegments": [
                        {
                            "line": 45,
                            "code": "adv_cols = [\"Player\", \"Year\"]"
                        },
                        {
                            "line": 46,
                            "code": "for col in [\"BPM\", \"WS/48\", \"TS%\", \"VORP\", \"WS\", \"PER\"]:"
                        },
                        {
                            "line": 47,
                            "code": "if col in df_adv.columns:"
                        },
                        {
                            "line": 48,
                            "code": "adv_cols.append(col)"
                        },
                        {
                            "line": 49,
                            "code": "df_adv = df_adv[adv_cols]"
                        }
                    ]
                },
                {
                    "summaryComponent": "Removes rows with missing advanced stats",
                    "codeSegments": [
                        {
                            "line": 50,
                            "code": "df_adv = df_adv.dropna(subset=adv_cols[2:])  # Drop rows with missing advanced stats"
                        }
                    ]
                },
                {
                    "summaryComponent": "Merges the cleaned advanced stats with per-game stats based on Player and Year",
                    "codeSegments": [
                        {
                            "line": 53,
                            "code": "df_merged = pd.merge(df_reg, df_adv, how=\"inner\", on=[\"Player\", \"Year\"])"
                        }
                    ]
                }
            ],
            "code": "40:     # Scrape advanced stats\n41:     df_adv = pd.read_html(base_url_adv, header=0)[0]\n42:     df_adv = df_adv[df_adv[\"Player\"] != \"Player\"]  # remove repeated header rows\n43:     df_adv[\"Year\"] = year\n44:     # Keep only relevant advanced stats columns (example: \"Player\", \"BPM\", \"WS/48\", \"TS%\", \"VORP\", \"WS\", \"PER\")\n45:     adv_cols = [\"Player\", \"Year\"]\n46:     for col in [\"BPM\", \"WS/48\", \"TS%\", \"VORP\", \"WS\", \"PER\"]:\n47:         if col in df_adv.columns:\n48:             adv_cols.append(col)\n49:     df_adv = df_adv[adv_cols]\n50:     df_adv = df_adv.dropna(subset=adv_cols[2:])  # Drop rows with missing advanced stats\n51: \n52:     # Merge per-game and advanced stats on Player and Year\n53:     df_merged = pd.merge(df_reg, df_adv, how=\"inner\", on=[\"Player\", \"Year\"])"
        },
        "timestamp": "2025-08-16 22:55:56.000",
        "id": "dCyV7V7DHj2JuyYm3vNp"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "42bebc2d-3a7e-4f91-bc59-75819564c02f",
            "mapping_index": 4,
            "structured_type": "unstructured",
            "detail_level": "medium"
        },
        "timestamp": "2025-08-16 22:55:56.000",
        "id": "fbzDSnKOFmYJKNG9HaRr"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "42bebc2d-3a7e-4f91-bc59-75819564c02f",
            "mapping_index": 0,
            "structured_type": "unstructured",
            "detail_level": "medium"
        },
        "timestamp": "2025-08-16 22:55:56.000",
        "id": "tpsaBseML2rYRi6pS6Np"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "42bebc2d-3a7e-4f91-bc59-75819564c02f",
            "mapping_index": 2,
            "structured_type": "unstructured",
            "detail_level": "medium"
        },
        "timestamp": "2025-08-16 22:55:56.000",
        "id": "zJRrp8XCjqe7hbLt0B6k"
    },
    {
        "source": "backend",
        "event": "map_summary_code",
        "data": {
            "summary": "• Scrapes advanced stats from a webpage, now considering BPM, WS/48, VORP, and WS columns\n• Filters and cleans the data\n• Merges with per-game stats",
            "mapping": [
                {
                    "summaryComponent": "Scrapes advanced stats from a webpage",
                    "codeSegments": [
                        {
                            "line": 41,
                            "code": "df_adv = pd.read_html(base_url_adv, header=0)[0]"
                        }
                    ]
                },
                {
                    "summaryComponent": "now considering BPM, WS/48, VORP, and WS columns",
                    "codeSegments": [
                        {
                            "line": 46,
                            "code": "for col in [\"BPM\", \"WS/48\", \"TS%\", \"VORP\", \"WS\", \"PER\"]:"
                        }
                    ]
                },
                {
                    "summaryComponent": "Filters and cleans the data",
                    "codeSegments": [
                        {
                            "line": 42,
                            "code": "df_adv = df_adv[df_adv[\"Player\"] != \"Player\"]  # remove repeated header rows"
                        },
                        {
                            "line": 50,
                            "code": "df_adv = df_adv.dropna(subset=adv_cols[2:])  # Drop rows with missing advanced stats"
                        }
                    ]
                },
                {
                    "summaryComponent": "Merges with per-game stats",
                    "codeSegments": [
                        {
                            "line": 53,
                            "code": "df_merged = pd.merge(df_reg, df_adv, how=\"inner\", on=[\"Player\", \"Year\"])"
                        }
                    ]
                }
            ],
            "code": "40:     # Scrape advanced stats\n41:     df_adv = pd.read_html(base_url_adv, header=0)[0]\n42:     df_adv = df_adv[df_adv[\"Player\"] != \"Player\"]  # remove repeated header rows\n43:     df_adv[\"Year\"] = year\n44:     # Keep only relevant advanced stats columns (example: \"Player\", \"BPM\", \"WS/48\", \"TS%\", \"VORP\", \"WS\", \"PER\")\n45:     adv_cols = [\"Player\", \"Year\"]\n46:     for col in [\"BPM\", \"WS/48\", \"TS%\", \"VORP\", \"WS\", \"PER\"]:\n47:         if col in df_adv.columns:\n48:             adv_cols.append(col)\n49:     df_adv = df_adv[adv_cols]\n50:     df_adv = df_adv.dropna(subset=adv_cols[2:])  # Drop rows with missing advanced stats\n51: \n52:     # Merge per-game and advanced stats on Player and Year\n53:     df_merged = pd.merge(df_reg, df_adv, how=\"inner\", on=[\"Player\", \"Year\"])"
        },
        "timestamp": "2025-08-16 22:55:57.000",
        "id": "BEfEY3T7zTPgU3jtFZ1U"
    },
    {
        "source": "backend",
        "event": "map_summary_code",
        "data": {
            "summary": "The code reads advanced player statistics from a basketball-reference webpage, filters out repeated headers, and now keeps only key columns like PER, TS%, BPM, WS/48, VORP, and WS if present. It removes rows with missing advanced stats and merges this cleaned data with per-game stats on Player and Year. This ensures that only players with complete advanced and per-game stats are included in the final merged dataset.",
            "mapping": [
                {
                    "summaryComponent": "reads advanced player statistics from a basketball-reference webpage",
                    "codeSegments": [
                        {
                            "line": 41,
                            "code": "df_adv = pd.read_html(base_url_adv, header=0)[0]"
                        }
                    ]
                },
                {
                    "summaryComponent": "filters out repeated headers",
                    "codeSegments": [
                        {
                            "line": 42,
                            "code": "df_adv = df_adv[df_adv[\"Player\"] != \"Player\"]  # remove repeated header rows"
                        }
                    ]
                },
                {
                    "summaryComponent": "now keeps only key columns like PER, TS%, BPM, WS/48, VORP, and WS if present",
                    "codeSegments": [
                        {
                            "line": 45,
                            "code": "adv_cols = [\"Player\", \"Year\"]"
                        },
                        {
                            "line": 46,
                            "code": "for col in [\"BPM\", \"WS/48\", \"TS%\", \"VORP\", \"WS\", \"PER\"]:"
                        },
                        {
                            "line": 47,
                            "code": "if col in df_adv.columns:"
                        },
                        {
                            "line": 48,
                            "code": "adv_cols.append(col)"
                        },
                        {
                            "line": 49,
                            "code": "df_adv = df_adv[adv_cols]"
                        }
                    ]
                },
                {
                    "summaryComponent": "removes rows with missing advanced stats",
                    "codeSegments": [
                        {
                            "line": 50,
                            "code": "df_adv = df_adv.dropna(subset=adv_cols[2:])  # Drop rows with missing advanced stats"
                        }
                    ]
                },
                {
                    "summaryComponent": "merges this cleaned data with per-game stats on Player and Year",
                    "codeSegments": [
                        {
                            "line": 53,
                            "code": "df_merged = pd.merge(df_reg, df_adv, how=\"inner\", on=[\"Player\", \"Year\"])"
                        }
                    ]
                },
                {
                    "summaryComponent": "only players with complete advanced and per-game stats are included in the final merged dataset",
                    "codeSegments": [
                        {
                            "line": 53,
                            "code": "df_merged = pd.merge(df_reg, df_adv, how=\"inner\", on=[\"Player\", \"Year\"])"
                        }
                    ]
                }
            ],
            "code": "40:     # Scrape advanced stats\n41:     df_adv = pd.read_html(base_url_adv, header=0)[0]\n42:     df_adv = df_adv[df_adv[\"Player\"] != \"Player\"]  # remove repeated header rows\n43:     df_adv[\"Year\"] = year\n44:     # Keep only relevant advanced stats columns (example: \"Player\", \"BPM\", \"WS/48\", \"TS%\", \"VORP\", \"WS\", \"PER\")\n45:     adv_cols = [\"Player\", \"Year\"]\n46:     for col in [\"BPM\", \"WS/48\", \"TS%\", \"VORP\", \"WS\", \"PER\"]:\n47:         if col in df_adv.columns:\n48:             adv_cols.append(col)\n49:     df_adv = df_adv[adv_cols]\n50:     df_adv = df_adv.dropna(subset=adv_cols[2:])  # Drop rows with missing advanced stats\n51: \n52:     # Merge per-game and advanced stats on Player and Year\n53:     df_merged = pd.merge(df_reg, df_adv, how=\"inner\", on=[\"Player\", \"Year\"])"
        },
        "timestamp": "2025-08-16 22:55:58.000",
        "id": "Q5Vyd9CXYMY381TZydC4"
    },
    {
        "source": "backend",
        "event": "map_summary_code",
        "data": {
            "summary": "• Reads the advanced stats table from the basketball-reference URL for the specified year\n• Cleans the DataFrame:\n  ◦ Removes any repeated header rows\n  ◦ Adds a 'Year' column to tag each row with the season\n• Dynamically selects columns:\n  ◦ Always includes 'Player' and 'Year'\n  ◦ Adds 'PER', 'TS%', 'BPM', 'WS/48', 'VORP', and 'WS' if they exist in the table\n• Filters out any rows with missing values in the advanced stats columns\n• Merges the cleaned advanced stats DataFrame with the per-game stats DataFrame (df_reg):\n  ◦ Uses an inner join on 'Player' and 'Year'\n  ◦ Ensures only players with complete data in both tables are included\n• Produces a merged DataFrame containing both per-game and advanced stats for each player and season",
            "mapping": [
                {
                    "summaryComponent": "Reads the advanced stats table from the basketball-reference URL for the specified year",
                    "codeSegments": [
                        {
                            "line": 41,
                            "code": "df_adv = pd.read_html(base_url_adv, header=0)[0]"
                        }
                    ]
                },
                {
                    "summaryComponent": "Removes any repeated header rows",
                    "codeSegments": [
                        {
                            "line": 42,
                            "code": "df_adv = df_adv[df_adv[\"Player\"] != \"Player\"]  # remove repeated header rows"
                        }
                    ]
                },
                {
                    "summaryComponent": "Adds a 'Year' column to tag each row with the season",
                    "codeSegments": [
                        {
                            "line": 43,
                            "code": "df_adv[\"Year\"] = year"
                        }
                    ]
                },
                {
                    "summaryComponent": "Always includes 'Player' and 'Year'",
                    "codeSegments": [
                        {
                            "line": 45,
                            "code": "adv_cols = [\"Player\", \"Year\"]"
                        }
                    ]
                },
                {
                    "summaryComponent": "Adds 'PER', 'TS%', 'BPM', 'WS/48', 'VORP', and 'WS' if they exist in the table",
                    "codeSegments": [
                        {
                            "line": 46,
                            "code": "for col in [\"BPM\", \"WS/48\", \"TS%\", \"VORP\", \"WS\", \"PER\"]:"
                        },
                        {
                            "line": 47,
                            "code": "if col in df_adv.columns:"
                        },
                        {
                            "line": 48,
                            "code": "adv_cols.append(col)"
                        }
                    ]
                },
                {
                    "summaryComponent": "Filters out any rows with missing values in the advanced stats columns",
                    "codeSegments": [
                        {
                            "line": 50,
                            "code": "df_adv = df_adv.dropna(subset=adv_cols[2:])  # Drop rows with missing advanced stats"
                        }
                    ]
                },
                {
                    "summaryComponent": "Merges the cleaned advanced stats DataFrame with the per-game stats DataFrame (df_reg)",
                    "codeSegments": [
                        {
                            "line": 53,
                            "code": "df_merged = pd.merge(df_reg, df_adv, how=\"inner\", on=[\"Player\", \"Year\"])"
                        }
                    ]
                },
                {
                    "summaryComponent": "Uses an inner join on 'Player' and 'Year'",
                    "codeSegments": [
                        {
                            "line": 53,
                            "code": "how=\"inner\""
                        },
                        {
                            "line": 53,
                            "code": "on=[\"Player\", \"Year\"]"
                        }
                    ]
                },
                {
                    "summaryComponent": "Ensures only players with complete data in both tables are included",
                    "codeSegments": [
                        {
                            "line": 53,
                            "code": "df_merged = pd.merge(df_reg, df_adv, how=\"inner\", on=[\"Player\", \"Year\"])"
                        }
                    ]
                },
                {
                    "summaryComponent": "Produces a merged DataFrame containing both per-game and advanced stats for each player and season",
                    "codeSegments": [
                        {
                            "line": 53,
                            "code": "df_merged = pd.merge(df_reg, df_adv, how=\"inner\", on=[\"Player\", \"Year\"])"
                        }
                    ]
                }
            ],
            "code": "40:     # Scrape advanced stats\n41:     df_adv = pd.read_html(base_url_adv, header=0)[0]\n42:     df_adv = df_adv[df_adv[\"Player\"] != \"Player\"]  # remove repeated header rows\n43:     df_adv[\"Year\"] = year\n44:     # Keep only relevant advanced stats columns (example: \"Player\", \"BPM\", \"WS/48\", \"TS%\", \"VORP\", \"WS\", \"PER\")\n45:     adv_cols = [\"Player\", \"Year\"]\n46:     for col in [\"BPM\", \"WS/48\", \"TS%\", \"VORP\", \"WS\", \"PER\"]:\n47:         if col in df_adv.columns:\n48:             adv_cols.append(col)\n49:     df_adv = df_adv[adv_cols]\n50:     df_adv = df_adv.dropna(subset=adv_cols[2:])  # Drop rows with missing advanced stats\n51: \n52:     # Merge per-game and advanced stats on Player and Year\n53:     df_merged = pd.merge(df_reg, df_adv, how=\"inner\", on=[\"Player\", \"Year\"])"
        },
        "timestamp": "2025-08-16 22:55:58.000",
        "id": "bAyRdfxwiC8QRARC2i5q"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "42bebc2d-3a7e-4f91-bc59-75819564c02f",
            "mapping_index": 4,
            "structured_type": "unstructured",
            "detail_level": "medium"
        },
        "timestamp": "2025-08-16 22:55:59.000",
        "id": "5OZKTmU8UFlpN7uXepoE"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "e8b317d3-b7db-42c1-8de7-82d2a7424f0b",
            "detail_level": "medium",
            "structured_type": "unstructured"
        },
        "timestamp": "2025-08-16 22:55:59.000",
        "id": "Gc2t85spIA3QwI7CwMkT"
    },
    {
        "source": "frontend",
        "event": "create_new_section",
        "data": {
            "section_id": "e8b317d3-b7db-42c1-8de7-82d2a7424f0b",
            "section_data": {
                "editPromptDetailLevel": null,
                "selectedStructured": "unstructured",
                "createdAt": 1755370559000,
                "lines": [
                    40,
                    53
                ],
                "editPromptStructured": null,
                "summaryData": {
                    "low_structured": "• Scrapes advanced stats from a webpage, now considering BPM, WS/48, VORP, and WS columns\n• Filters and cleans the data\n• Merges with per-game stats",
                    "high_unstructured": "This code segment scrapes the advanced statistics table for NBA players from a given season's basketball-reference webpage, ensuring repeated header rows are removed and the season year is recorded. It dynamically selects only the relevant advanced stats columns (Player, Year, PER, TS%, BPM, WS/48, VORP, WS) that are present, and filters out any rows with missing advanced statistics to maintain data integrity. The cleaned advanced stats DataFrame is then merged with the previously scraped per-game stats DataFrame using an inner join on Player and Year, so only players with complete data in both datasets are included. This process results in a comprehensive, season-specific dataset combining both per-game and advanced player statistics.",
                    "medium_unstructured": "The code reads advanced player statistics from a basketball-reference webpage, filters out repeated headers, and now keeps only key columns like PER, TS%, BPM, WS/48, VORP, and WS if present. It removes rows with missing advanced stats and merges this cleaned data with per-game stats on Player and Year. This ensures that only players with complete advanced and per-game stats are included in the final merged dataset.",
                    "high_structured": "• Reads the advanced stats table from the basketball-reference URL for the specified year\n• Cleans the DataFrame:\n  ◦ Removes any repeated header rows\n  ◦ Adds a 'Year' column to tag each row with the season\n• Dynamically selects columns:\n  ◦ Always includes 'Player' and 'Year'\n  ◦ Adds 'PER', 'TS%', 'BPM', 'WS/48', 'VORP', and 'WS' if they exist in the table\n• Filters out any rows with missing values in the advanced stats columns\n• Merges the cleaned advanced stats DataFrame with the per-game stats DataFrame (df_reg):\n  ◦ Uses an inner join on 'Player' and 'Year'\n  ◦ Ensures only players with complete data in both tables are included\n• Produces a merged DataFrame containing both per-game and advanced stats for each player and season",
                    "title": "Scraping and Merging Advanced NBA Player Statistics (Now with BPM, WS/48, VORP, and WS Columns)",
                    "low_unstructured": "This code scrapes advanced NBA player stats for a season, now including columns such as BPM, WS/48, VORP, and WS in addition to PER and TS% if present, filters relevant columns, removes incomplete data, and merges them with per-game stats.",
                    "medium_structured": "• Reads advanced stats table from a specified URL\n• Cleans the data by removing repeated header rows\n• Selects only relevant columns (Player, Year, and available advanced stats including BPM, WS/48, VORP, and WS)\n•  Removes rows with missing advanced stats\n• Merges the cleaned advanced stats with per-game stats based on Player and Year"
                },
                "selectedDetailLevel": "medium",
                "oldSummaryData": {
                    "low_structured": "• Scrapes advanced stats from a webpage\n• Filters and cleans the data\n• Merges with per-game stats",
                    "high_unstructured": "This code segment scrapes the advanced statistics table for NBA players from a given season's basketball-reference webpage, ensuring repeated header rows are removed and the season year is recorded. It dynamically selects only the relevant advanced stats columns (Player, Year, PER, TS%, USG%) that are present, and filters out any rows with missing advanced statistics to maintain data integrity. The cleaned advanced stats DataFrame is then merged with the previously scraped per-game stats DataFrame using an inner join on Player and Year, so only players with complete data in both datasets are included. This process results in a comprehensive, season-specific dataset combining both per-game and advanced player statistics.",
                    "medium_unstructured": "The code reads advanced player statistics from a basketball-reference webpage, filters out repeated headers, and keeps only key columns like PER, TS%, and USG% if present. It removes rows with missing advanced stats and merges this cleaned data with per-game stats on Player and Year. This ensures that only players with complete advanced and per-game stats are included in the final merged dataset.",
                    "high_structured": "• Reads the advanced stats table from the basketball-reference URL for the specified year\n• Cleans the DataFrame:\n  ◦ Removes any repeated header rows\n  ◦ Adds a 'Year' column to tag each row with the season\n• Dynamically selects columns:\n  ◦ Always includes 'Player' and 'Year'\n  ◦ Adds 'PER', 'TS%', and 'USG%' if they exist in the table\n• Filters out any rows with missing values in the advanced stats columns\n• Merges the cleaned advanced stats DataFrame with the per-game stats DataFrame (df_reg):\n  ◦ Uses an inner join on 'Player' and 'Year'\n  ◦ Ensures only players with complete data in both tables are included\n• Produces a merged DataFrame containing both per-game and advanced stats for each player and season",
                    "title": "Scraping and Merging Advanced NBA Player Statistics",
                    "low_unstructured": "This code scrapes advanced NBA player stats for a season, filters relevant columns, removes incomplete data, and merges them with per-game stats.",
                    "medium_structured": "• Reads advanced stats table from a specified URL\n• Cleans the data by removing repeated header rows\n• Selects only relevant columns (Player, Year, and available advanced stats)\n•  Removes rows with missing advanced stats\n• Merges the cleaned advanced stats with per-game stats based on Player and Year"
                },
                "metadata": {
                    "originalCode": "    # Scrape advanced stats\n    df_adv = pd.read_html(base_url_adv, header=0)[0]\n    df_adv = df_adv[df_adv[\"Player\"] != \"Player\"]  # remove repeated header rows\n    df_adv[\"Year\"] = year\n    # Keep only relevant advanced stats columns (example: \"Player\", \"BPM\", \"WS/48\", \"TS%\", \"VORP\", \"WS\", \"PER\")\n    adv_cols = [\"Player\", \"Year\"]\n    for col in [\"BPM\", \"WS/48\", \"TS%\", \"VORP\", \"WS\", \"PER\"]:\n        if col in df_adv.columns:\n            adv_cols.append(col)\n    df_adv = df_adv[adv_cols]\n    df_adv = df_adv.dropna(subset=adv_cols[2:])  # Drop rows with missing advanced stats\n\n    # Merge per-game and advanced stats on Player and Year\n    df_merged = pd.merge(df_reg, df_adv, how=\"inner\", on=[\"Player\", \"Year\"])",
                    "fullPath": "/project/workspace/scraper.py",
                    "id": "e8b317d3-b7db-42c1-8de7-82d2a7424f0b",
                    "offset": 1322,
                    "filename": "scraper.py"
                },
                "editPromptValue": "",
                "title": "Scraping and Merging Advanced NBA Player Statistics (Now with BPM, WS/48, VORP, and WS Columns)",
                "summaryMappings": {
                    "high_unstructured": [
                        {
                            "summaryComponent": "scrapes the advanced statistics table for NBA players from a given season's basketball-reference webpage",
                            "codeSegments": [
                                {
                                    "line": 41,
                                    "code": "df_adv = pd.read_html(base_url_adv, header=0)[0]"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "ensuring repeated header rows are removed",
                            "codeSegments": [
                                {
                                    "line": 42,
                                    "code": "df_adv = df_adv[df_adv[\"Player\"] != \"Player\"]  # remove repeated header rows"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "the season year is recorded",
                            "codeSegments": [
                                {
                                    "line": 43,
                                    "code": "df_adv[\"Year\"] = year"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "dynamically selects only the relevant advanced stats columns (Player, Year, PER, TS%, BPM, WS/48, VORP, WS) that are present",
                            "codeSegments": [
                                {
                                    "line": 45,
                                    "code": "adv_cols = [\"Player\", \"Year\"]"
                                },
                                {
                                    "line": 46,
                                    "code": "for col in [\"BPM\", \"WS/48\", \"TS%\", \"VORP\", \"WS\", \"PER\"]:"
                                },
                                {
                                    "line": 47,
                                    "code": "if col in df_adv.columns:"
                                },
                                {
                                    "line": 48,
                                    "code": "adv_cols.append(col)"
                                },
                                {
                                    "line": 49,
                                    "code": "df_adv = df_adv[adv_cols]"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "filters out any rows with missing advanced statistics to maintain data integrity",
                            "codeSegments": [
                                {
                                    "line": 50,
                                    "code": "df_adv = df_adv.dropna(subset=adv_cols[2:])  # Drop rows with missing advanced stats"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "The cleaned advanced stats DataFrame is then merged with the previously scraped per-game stats DataFrame using an inner join on Player and Year",
                            "codeSegments": [
                                {
                                    "line": 53,
                                    "code": "df_merged = pd.merge(df_reg, df_adv, how=\"inner\", on=[\"Player\", \"Year\"])"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "so only players with complete data in both datasets are included",
                            "codeSegments": [
                                {
                                    "line": 53,
                                    "code": "how=\"inner\""
                                }
                            ]
                        },
                        {
                            "summaryComponent": "results in a comprehensive, season-specific dataset combining both per-game and advanced player statistics",
                            "codeSegments": [
                                {
                                    "line": 53,
                                    "code": "df_merged = pd.merge(df_reg, df_adv, how=\"inner\", on=[\"Player\", \"Year\"])"
                                }
                            ]
                        }
                    ],
                    "medium_unstructured": [
                        {
                            "summaryComponent": "reads advanced player statistics from a basketball-reference webpage",
                            "codeSegments": [
                                {
                                    "line": 41,
                                    "code": "df_adv = pd.read_html(base_url_adv, header=0)[0]"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "filters out repeated headers",
                            "codeSegments": [
                                {
                                    "line": 42,
                                    "code": "df_adv = df_adv[df_adv[\"Player\"] != \"Player\"]  # remove repeated header rows"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "now keeps only key columns like PER, TS%, BPM, WS/48, VORP, and WS if present",
                            "codeSegments": [
                                {
                                    "line": 45,
                                    "code": "adv_cols = [\"Player\", \"Year\"]"
                                },
                                {
                                    "line": 46,
                                    "code": "for col in [\"BPM\", \"WS/48\", \"TS%\", \"VORP\", \"WS\", \"PER\"]:"
                                },
                                {
                                    "line": 47,
                                    "code": "if col in df_adv.columns:"
                                },
                                {
                                    "line": 48,
                                    "code": "adv_cols.append(col)"
                                },
                                {
                                    "line": 49,
                                    "code": "df_adv = df_adv[adv_cols]"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "removes rows with missing advanced stats",
                            "codeSegments": [
                                {
                                    "line": 50,
                                    "code": "df_adv = df_adv.dropna(subset=adv_cols[2:])  # Drop rows with missing advanced stats"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "merges this cleaned data with per-game stats on Player and Year",
                            "codeSegments": [
                                {
                                    "line": 53,
                                    "code": "df_merged = pd.merge(df_reg, df_adv, how=\"inner\", on=[\"Player\", \"Year\"])"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "only players with complete advanced and per-game stats are included in the final merged dataset",
                            "codeSegments": [
                                {
                                    "line": 53,
                                    "code": "df_merged = pd.merge(df_reg, df_adv, how=\"inner\", on=[\"Player\", \"Year\"])"
                                }
                            ]
                        }
                    ],
                    "high_structured": [
                        {
                            "summaryComponent": "Reads the advanced stats table from the basketball-reference URL for the specified year",
                            "codeSegments": [
                                {
                                    "line": 41,
                                    "code": "df_adv = pd.read_html(base_url_adv, header=0)[0]"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "Removes any repeated header rows",
                            "codeSegments": [
                                {
                                    "line": 42,
                                    "code": "df_adv = df_adv[df_adv[\"Player\"] != \"Player\"]  # remove repeated header rows"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "Adds a 'Year' column to tag each row with the season",
                            "codeSegments": [
                                {
                                    "line": 43,
                                    "code": "df_adv[\"Year\"] = year"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "Always includes 'Player' and 'Year'",
                            "codeSegments": [
                                {
                                    "line": 45,
                                    "code": "adv_cols = [\"Player\", \"Year\"]"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "Adds 'PER', 'TS%', 'BPM', 'WS/48', 'VORP', and 'WS' if they exist in the table",
                            "codeSegments": [
                                {
                                    "line": 46,
                                    "code": "for col in [\"BPM\", \"WS/48\", \"TS%\", \"VORP\", \"WS\", \"PER\"]:"
                                },
                                {
                                    "line": 47,
                                    "code": "if col in df_adv.columns:"
                                },
                                {
                                    "line": 48,
                                    "code": "adv_cols.append(col)"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "Filters out any rows with missing values in the advanced stats columns",
                            "codeSegments": [
                                {
                                    "line": 50,
                                    "code": "df_adv = df_adv.dropna(subset=adv_cols[2:])  # Drop rows with missing advanced stats"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "Merges the cleaned advanced stats DataFrame with the per-game stats DataFrame (df_reg)",
                            "codeSegments": [
                                {
                                    "line": 53,
                                    "code": "df_merged = pd.merge(df_reg, df_adv, how=\"inner\", on=[\"Player\", \"Year\"])"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "Uses an inner join on 'Player' and 'Year'",
                            "codeSegments": [
                                {
                                    "line": 53,
                                    "code": "how=\"inner\""
                                },
                                {
                                    "line": 53,
                                    "code": "on=[\"Player\", \"Year\"]"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "Ensures only players with complete data in both tables are included",
                            "codeSegments": [
                                {
                                    "line": 53,
                                    "code": "df_merged = pd.merge(df_reg, df_adv, how=\"inner\", on=[\"Player\", \"Year\"])"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "Produces a merged DataFrame containing both per-game and advanced stats for each player and season",
                            "codeSegments": [
                                {
                                    "line": 53,
                                    "code": "df_merged = pd.merge(df_reg, df_adv, how=\"inner\", on=[\"Player\", \"Year\"])"
                                }
                            ]
                        }
                    ],
                    "low_unstructured": [
                        {
                            "summaryComponent": "scrapes advanced NBA player stats for a season",
                            "codeSegments": [
                                {
                                    "line": 41,
                                    "code": "df_adv = pd.read_html(base_url_adv, header=0)[0]"
                                },
                                {
                                    "line": 43,
                                    "code": "df_adv[\"Year\"] = year"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "now including columns such as BPM, WS/48, VORP, and WS in addition to PER and TS% if present",
                            "codeSegments": [
                                {
                                    "line": 46,
                                    "code": "for col in [\"BPM\", \"WS/48\", \"TS%\", \"VORP\", \"WS\", \"PER\"]:"
                                },
                                {
                                    "line": 47,
                                    "code": "if col in df_adv.columns:"
                                },
                                {
                                    "line": 48,
                                    "code": "adv_cols.append(col)"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "filters relevant columns",
                            "codeSegments": [
                                {
                                    "line": 49,
                                    "code": "df_adv = df_adv[adv_cols]"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "removes incomplete data",
                            "codeSegments": [
                                {
                                    "line": 50,
                                    "code": "df_adv = df_adv.dropna(subset=adv_cols[2:])  # Drop rows with missing advanced stats"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "merges them with per-game stats",
                            "codeSegments": [
                                {
                                    "line": 53,
                                    "code": "df_merged = pd.merge(df_reg, df_adv, how=\"inner\", on=[\"Player\", \"Year\"])"
                                }
                            ]
                        }
                    ],
                    "low_structured": [
                        {
                            "summaryComponent": "Scrapes advanced stats from a webpage",
                            "codeSegments": [
                                {
                                    "line": 41,
                                    "code": "df_adv = pd.read_html(base_url_adv, header=0)[0]"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "now considering BPM, WS/48, VORP, and WS columns",
                            "codeSegments": [
                                {
                                    "line": 46,
                                    "code": "for col in [\"BPM\", \"WS/48\", \"TS%\", \"VORP\", \"WS\", \"PER\"]:"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "Filters and cleans the data",
                            "codeSegments": [
                                {
                                    "line": 42,
                                    "code": "df_adv = df_adv[df_adv[\"Player\"] != \"Player\"]  # remove repeated header rows"
                                },
                                {
                                    "line": 50,
                                    "code": "df_adv = df_adv.dropna(subset=adv_cols[2:])  # Drop rows with missing advanced stats"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "Merges with per-game stats",
                            "codeSegments": [
                                {
                                    "line": 53,
                                    "code": "df_merged = pd.merge(df_reg, df_adv, how=\"inner\", on=[\"Player\", \"Year\"])"
                                }
                            ]
                        }
                    ],
                    "medium_structured": [
                        {
                            "summaryComponent": "Reads advanced stats table from a specified URL",
                            "codeSegments": [
                                {
                                    "line": 41,
                                    "code": "df_adv = pd.read_html(base_url_adv, header=0)[0]"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "Cleans the data by removing repeated header rows",
                            "codeSegments": [
                                {
                                    "line": 42,
                                    "code": "df_adv = df_adv[df_adv[\"Player\"] != \"Player\"]  # remove repeated header rows"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "Selects only relevant columns (Player, Year, and available advanced stats including BPM, WS/48, VORP, and WS)",
                            "codeSegments": [
                                {
                                    "line": 45,
                                    "code": "adv_cols = [\"Player\", \"Year\"]"
                                },
                                {
                                    "line": 46,
                                    "code": "for col in [\"BPM\", \"WS/48\", \"TS%\", \"VORP\", \"WS\", \"PER\"]:"
                                },
                                {
                                    "line": 47,
                                    "code": "if col in df_adv.columns:"
                                },
                                {
                                    "line": 48,
                                    "code": "adv_cols.append(col)"
                                },
                                {
                                    "line": 49,
                                    "code": "df_adv = df_adv[adv_cols]"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "Removes rows with missing advanced stats",
                            "codeSegments": [
                                {
                                    "line": 50,
                                    "code": "df_adv = df_adv.dropna(subset=adv_cols[2:])  # Drop rows with missing advanced stats"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "Merges the cleaned advanced stats with per-game stats based on Player and Year",
                            "codeSegments": [
                                {
                                    "line": 53,
                                    "code": "df_merged = pd.merge(df_reg, df_adv, how=\"inner\", on=[\"Player\", \"Year\"])"
                                }
                            ]
                        }
                    ]
                }
            }
        },
        "timestamp": "2025-08-16 22:55:59.000",
        "id": "OzhN7ZZOTj8CYF79hGRt"
    },
    {
        "source": "frontend",
        "event": "autotransit_section",
        "data": {
            "before_section_id": "42bebc2d-3a7e-4f91-bc59-75819564c02f",
            "after_section_id": "e8b317d3-b7db-42c1-8de7-82d2a7424f0b"
        },
        "timestamp": "2025-08-16 22:55:59.000",
        "id": "QbInRmo7EkICaomGnhMn"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "e8b317d3-b7db-42c1-8de7-82d2a7424f0b",
            "mapping_index": 2,
            "structured_type": "unstructured",
            "detail_level": "medium"
        },
        "timestamp": "2025-08-16 22:55:59.000",
        "id": "aIIgYxzLH0CKeR5Dv9Aq"
    },
    {
        "source": "backend",
        "event": "map_summary_code",
        "data": {
            "summary": "This code segment scrapes the advanced statistics table for NBA players from a given season's basketball-reference webpage, ensuring repeated header rows are removed and the season year is recorded. It dynamically selects only the relevant advanced stats columns (Player, Year, PER, TS%, BPM, WS/48, VORP, WS) that are present, and filters out any rows with missing advanced statistics to maintain data integrity. The cleaned advanced stats DataFrame is then merged with the previously scraped per-game stats DataFrame using an inner join on Player and Year, so only players with complete data in both datasets are included. This process results in a comprehensive, season-specific dataset combining both per-game and advanced player statistics.",
            "mapping": [
                {
                    "summaryComponent": "scrapes the advanced statistics table for NBA players from a given season's basketball-reference webpage",
                    "codeSegments": [
                        {
                            "line": 41,
                            "code": "df_adv = pd.read_html(base_url_adv, header=0)[0]"
                        }
                    ]
                },
                {
                    "summaryComponent": "ensuring repeated header rows are removed",
                    "codeSegments": [
                        {
                            "line": 42,
                            "code": "df_adv = df_adv[df_adv[\"Player\"] != \"Player\"]  # remove repeated header rows"
                        }
                    ]
                },
                {
                    "summaryComponent": "the season year is recorded",
                    "codeSegments": [
                        {
                            "line": 43,
                            "code": "df_adv[\"Year\"] = year"
                        }
                    ]
                },
                {
                    "summaryComponent": "dynamically selects only the relevant advanced stats columns (Player, Year, PER, TS%, BPM, WS/48, VORP, WS) that are present",
                    "codeSegments": [
                        {
                            "line": 45,
                            "code": "adv_cols = [\"Player\", \"Year\"]"
                        },
                        {
                            "line": 46,
                            "code": "for col in [\"BPM\", \"WS/48\", \"TS%\", \"VORP\", \"WS\", \"PER\"]:"
                        },
                        {
                            "line": 47,
                            "code": "if col in df_adv.columns:"
                        },
                        {
                            "line": 48,
                            "code": "adv_cols.append(col)"
                        },
                        {
                            "line": 49,
                            "code": "df_adv = df_adv[adv_cols]"
                        }
                    ]
                },
                {
                    "summaryComponent": "filters out any rows with missing advanced statistics to maintain data integrity",
                    "codeSegments": [
                        {
                            "line": 50,
                            "code": "df_adv = df_adv.dropna(subset=adv_cols[2:])  # Drop rows with missing advanced stats"
                        }
                    ]
                },
                {
                    "summaryComponent": "The cleaned advanced stats DataFrame is then merged with the previously scraped per-game stats DataFrame using an inner join on Player and Year",
                    "codeSegments": [
                        {
                            "line": 53,
                            "code": "df_merged = pd.merge(df_reg, df_adv, how=\"inner\", on=[\"Player\", \"Year\"])"
                        }
                    ]
                },
                {
                    "summaryComponent": "so only players with complete data in both datasets are included",
                    "codeSegments": [
                        {
                            "line": 53,
                            "code": "how=\"inner\""
                        }
                    ]
                },
                {
                    "summaryComponent": "results in a comprehensive, season-specific dataset combining both per-game and advanced player statistics",
                    "codeSegments": [
                        {
                            "line": 53,
                            "code": "df_merged = pd.merge(df_reg, df_adv, how=\"inner\", on=[\"Player\", \"Year\"])"
                        }
                    ]
                }
            ],
            "code": "40:     # Scrape advanced stats\n41:     df_adv = pd.read_html(base_url_adv, header=0)[0]\n42:     df_adv = df_adv[df_adv[\"Player\"] != \"Player\"]  # remove repeated header rows\n43:     df_adv[\"Year\"] = year\n44:     # Keep only relevant advanced stats columns (example: \"Player\", \"BPM\", \"WS/48\", \"TS%\", \"VORP\", \"WS\", \"PER\")\n45:     adv_cols = [\"Player\", \"Year\"]\n46:     for col in [\"BPM\", \"WS/48\", \"TS%\", \"VORP\", \"WS\", \"PER\"]:\n47:         if col in df_adv.columns:\n48:             adv_cols.append(col)\n49:     df_adv = df_adv[adv_cols]\n50:     df_adv = df_adv.dropna(subset=adv_cols[2:])  # Drop rows with missing advanced stats\n51: \n52:     # Merge per-game and advanced stats on Player and Year\n53:     df_merged = pd.merge(df_reg, df_adv, how=\"inner\", on=[\"Player\", \"Year\"])"
        },
        "timestamp": "2025-08-16 22:55:59.000",
        "id": "fSoqEVlvaNqoYCDrlnnq"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "42bebc2d-3a7e-4f91-bc59-75819564c02f",
            "mapping_index": 5,
            "structured_type": "unstructured",
            "detail_level": "medium"
        },
        "timestamp": "2025-08-16 22:55:59.000",
        "id": "h2PUd3kbReGQoXMZOCca"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "e8b317d3-b7db-42c1-8de7-82d2a7424f0b",
            "mapping_index": 0,
            "structured_type": "unstructured",
            "detail_level": "medium"
        },
        "timestamp": "2025-08-16 22:55:59.000",
        "id": "iO2FzTwtpt1MEiF0McYo"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "42bebc2d-3a7e-4f91-bc59-75819564c02f",
            "detail_level": "medium",
            "structured_type": "unstructured"
        },
        "timestamp": "2025-08-16 22:55:59.000",
        "id": "zw7cCzw0QjXeXgTnQC0B"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "e8b317d3-b7db-42c1-8de7-82d2a7424f0b",
            "detail_level": "medium",
            "structured_type": "unstructured"
        },
        "timestamp": "2025-08-16 22:56:00.000",
        "id": "GAWN25hXFeZNHld0yEN6"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "e8b317d3-b7db-42c1-8de7-82d2a7424f0b",
            "mapping_index": 4,
            "structured_type": "unstructured",
            "detail_level": "medium"
        },
        "timestamp": "2025-08-16 22:56:00.000",
        "id": "N9aZkjuuVBlMlJGFSOGS"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "e8b317d3-b7db-42c1-8de7-82d2a7424f0b",
            "detail_level": "medium",
            "structured_type": "unstructured"
        },
        "timestamp": "2025-08-16 22:56:00.000",
        "id": "g8zurcpkqmLdOkettl75"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "e8b317d3-b7db-42c1-8de7-82d2a7424f0b",
            "detail_level": "medium",
            "structured_type": "unstructured"
        },
        "timestamp": "2025-08-16 22:56:00.000",
        "id": "i8oEuDC1iBHpRDwYmPwL"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "e8b317d3-b7db-42c1-8de7-82d2a7424f0b",
            "mapping_index": 2,
            "structured_type": "unstructured",
            "detail_level": "medium"
        },
        "timestamp": "2025-08-16 22:56:00.000",
        "id": "o2DHAABPuuKeIuGKr9lK"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "e8b317d3-b7db-42c1-8de7-82d2a7424f0b",
            "mapping_index": 2,
            "structured_type": "unstructured",
            "detail_level": "medium"
        },
        "timestamp": "2025-08-16 22:56:02.000",
        "id": "0yaykO15LacoXB214n6y"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "e8b317d3-b7db-42c1-8de7-82d2a7424f0b",
            "mapping_index": 4,
            "structured_type": "unstructured",
            "detail_level": "medium"
        },
        "timestamp": "2025-08-16 22:56:02.000",
        "id": "A672YVj4vcsGG8jniy4Y"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "e8b317d3-b7db-42c1-8de7-82d2a7424f0b",
            "detail_level": "medium",
            "structured_type": "unstructured"
        },
        "timestamp": "2025-08-16 22:56:02.000",
        "id": "BizLpClw5B57nGNHcQJl"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "e8b317d3-b7db-42c1-8de7-82d2a7424f0b",
            "detail_level": "medium",
            "structured_type": "unstructured"
        },
        "timestamp": "2025-08-16 22:56:02.000",
        "id": "CeOfnWRdrDkuHZvqcDNY"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "e8b317d3-b7db-42c1-8de7-82d2a7424f0b",
            "mapping_index": 0,
            "structured_type": "unstructured",
            "detail_level": "medium"
        },
        "timestamp": "2025-08-16 22:56:02.000",
        "id": "E3ZatJiyOQd7R87J3vUb"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "e8b317d3-b7db-42c1-8de7-82d2a7424f0b",
            "detail_level": "medium",
            "structured_type": "unstructured"
        },
        "timestamp": "2025-08-16 22:56:02.000",
        "id": "LwzfQzLK06OdniCsLh0F"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "e8b317d3-b7db-42c1-8de7-82d2a7424f0b",
            "mapping_index": 0,
            "structured_type": "unstructured",
            "detail_level": "medium"
        },
        "timestamp": "2025-08-16 22:56:02.000",
        "id": "c5w636U7ItimNsRvhTzX"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "e8b317d3-b7db-42c1-8de7-82d2a7424f0b",
            "mapping_index": 5,
            "structured_type": "unstructured",
            "detail_level": "medium"
        },
        "timestamp": "2025-08-16 22:56:02.000",
        "id": "oKfNz4u4dTfIL6qZuuEP"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "e8b317d3-b7db-42c1-8de7-82d2a7424f0b",
            "detail_level": "medium",
            "structured_type": "unstructured"
        },
        "timestamp": "2025-08-16 22:56:02.000",
        "id": "xz9BIWLFMda8PpPPfinS"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "e8b317d3-b7db-42c1-8de7-82d2a7424f0b",
            "mapping_index": 2,
            "structured_type": "unstructured",
            "detail_level": "medium"
        },
        "timestamp": "2025-08-16 22:56:04.000",
        "id": "2I4SZNwaBpbLVY7135CP"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "e8b317d3-b7db-42c1-8de7-82d2a7424f0b",
            "detail_level": "medium",
            "structured_type": "unstructured"
        },
        "timestamp": "2025-08-16 22:56:04.000",
        "id": "NhDwQftjzAqFBqDUTVva"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "e8b317d3-b7db-42c1-8de7-82d2a7424f0b",
            "detail_level": "medium",
            "structured_type": "unstructured"
        },
        "timestamp": "2025-08-16 22:56:06.000",
        "id": "P0wdgnTgwFV1ZKBfWwfS"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "e8b317d3-b7db-42c1-8de7-82d2a7424f0b",
            "detail_level": "medium",
            "structured_type": "unstructured"
        },
        "timestamp": "2025-08-16 22:56:06.000",
        "id": "QrhPVls3HAtxK9RJad1Y"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "e8b317d3-b7db-42c1-8de7-82d2a7424f0b",
            "mapping_index": 2,
            "structured_type": "unstructured",
            "detail_level": "medium"
        },
        "timestamp": "2025-08-16 22:56:06.000",
        "id": "hO1z4blj6j1Si8zv8YDg"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "e8b317d3-b7db-42c1-8de7-82d2a7424f0b",
            "mapping_index": 0,
            "structured_type": "unstructured",
            "detail_level": "medium"
        },
        "timestamp": "2025-08-16 22:56:06.000",
        "id": "scA5w3gNWR0KQoU9vTAv"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "e8b317d3-b7db-42c1-8de7-82d2a7424f0b",
            "mapping_index": 4,
            "structured_type": "unstructured",
            "detail_level": "medium"
        },
        "timestamp": "2025-08-16 22:56:08.000",
        "id": "YjwaqIEvtGy8VcoGYeJe"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "e8b317d3-b7db-42c1-8de7-82d2a7424f0b",
            "detail_level": "medium",
            "structured_type": "unstructured"
        },
        "timestamp": "2025-08-16 22:56:08.000",
        "id": "oPyqTSxPriNL3nDXJnla"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "e8b317d3-b7db-42c1-8de7-82d2a7424f0b",
            "detail_level": "medium",
            "structured_type": "unstructured"
        },
        "timestamp": "2025-08-16 22:56:09.000",
        "id": "t58cHJe4T3UR7Yc6UZFc"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "e8b317d3-b7db-42c1-8de7-82d2a7424f0b",
            "mapping_index": 2,
            "structured_type": "unstructured",
            "detail_level": "medium"
        },
        "timestamp": "2025-08-16 22:56:09.000",
        "id": "tJ46nAciQPDXgTGnYFfm"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "e8b317d3-b7db-42c1-8de7-82d2a7424f0b",
            "detail_level": "medium",
            "structured_type": "unstructured"
        },
        "timestamp": "2025-08-16 22:56:10.000",
        "id": "l2hMLbAHLCUYwWWAxiT8"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "e8b317d3-b7db-42c1-8de7-82d2a7424f0b",
            "mapping_index": 0,
            "structured_type": "unstructured",
            "detail_level": "medium"
        },
        "timestamp": "2025-08-16 22:56:10.000",
        "id": "mqSNSYWxXdPIXAwAa7jR"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "e8b317d3-b7db-42c1-8de7-82d2a7424f0b",
            "mapping_index": 4,
            "structured_type": "unstructured",
            "detail_level": "medium"
        },
        "timestamp": "2025-08-16 22:56:11.000",
        "id": "1JGtV2j7USTuk1fejjmI"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "e8b317d3-b7db-42c1-8de7-82d2a7424f0b",
            "mapping_index": 5,
            "structured_type": "unstructured",
            "detail_level": "medium"
        },
        "timestamp": "2025-08-16 22:56:11.000",
        "id": "3QkyaCwRMTWKZRnj9Fo8"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "e8b317d3-b7db-42c1-8de7-82d2a7424f0b",
            "detail_level": "medium",
            "structured_type": "unstructured"
        },
        "timestamp": "2025-08-16 22:56:11.000",
        "id": "5wte5OB6eJyxski44CXU"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "e8b317d3-b7db-42c1-8de7-82d2a7424f0b",
            "detail_level": "medium",
            "structured_type": "unstructured"
        },
        "timestamp": "2025-08-16 22:56:11.000",
        "id": "ZKkIdXvTt7a6CMkzUvxF"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "e8b317d3-b7db-42c1-8de7-82d2a7424f0b",
            "detail_level": "medium",
            "structured_type": "unstructured"
        },
        "timestamp": "2025-08-16 22:56:11.000",
        "id": "hqirwnVmfeQcET4Bgzjc"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "e8b317d3-b7db-42c1-8de7-82d2a7424f0b",
            "detail_level": "medium",
            "structured_type": "unstructured"
        },
        "timestamp": "2025-08-16 22:56:11.000",
        "id": "nZWU0bfWhg09OmDViJXF"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "e8b317d3-b7db-42c1-8de7-82d2a7424f0b",
            "mapping_index": 2,
            "structured_type": "unstructured",
            "detail_level": "medium"
        },
        "timestamp": "2025-08-16 22:56:11.000",
        "id": "yw4IwdS7pbSyazqQalHq"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "e8b317d3-b7db-42c1-8de7-82d2a7424f0b",
            "mapping_index": 2,
            "structured_type": "unstructured",
            "detail_level": "medium"
        },
        "timestamp": "2025-08-16 22:56:14.000",
        "id": "3nxQuCtCI33cmwr3noJl"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "e8b317d3-b7db-42c1-8de7-82d2a7424f0b",
            "mapping_index": 4,
            "structured_type": "unstructured",
            "detail_level": "medium"
        },
        "timestamp": "2025-08-16 22:56:14.000",
        "id": "UAnOLE7ynSZVWGCx6HSj"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "e8b317d3-b7db-42c1-8de7-82d2a7424f0b",
            "detail_level": "medium",
            "structured_type": "unstructured"
        },
        "timestamp": "2025-08-16 22:56:14.000",
        "id": "dy2tGQAt5gekXHl75xiy"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "e8b317d3-b7db-42c1-8de7-82d2a7424f0b",
            "mapping_index": 5,
            "structured_type": "unstructured",
            "detail_level": "medium"
        },
        "timestamp": "2025-08-16 22:56:14.000",
        "id": "f3Z0d944Z3c4vQ4aRp6l"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "e8b317d3-b7db-42c1-8de7-82d2a7424f0b",
            "detail_level": "medium",
            "structured_type": "unstructured"
        },
        "timestamp": "2025-08-16 22:56:14.000",
        "id": "s98xkfheqM4HuI5MG6Mo"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "e8b317d3-b7db-42c1-8de7-82d2a7424f0b",
            "mapping_index": 4,
            "structured_type": "unstructured",
            "detail_level": "medium"
        },
        "timestamp": "2025-08-16 22:56:16.000",
        "id": "2fmcYFUpn3gRZ2opfNF5"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "e8b317d3-b7db-42c1-8de7-82d2a7424f0b",
            "detail_level": "medium",
            "structured_type": "unstructured"
        },
        "timestamp": "2025-08-16 22:56:16.000",
        "id": "dElBm1eUt6Of1Trv3JyJ"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "e8b317d3-b7db-42c1-8de7-82d2a7424f0b",
            "detail_level": "medium",
            "structured_type": "unstructured"
        },
        "timestamp": "2025-08-16 22:56:17.000",
        "id": "AODK7BUDHNJf3tFDtjbF"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "e8b317d3-b7db-42c1-8de7-82d2a7424f0b",
            "mapping_index": 2,
            "structured_type": "unstructured",
            "detail_level": "medium"
        },
        "timestamp": "2025-08-16 22:56:17.000",
        "id": "V5Vh7BablKH32SyE3qvm"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "e8b317d3-b7db-42c1-8de7-82d2a7424f0b",
            "detail_level": "medium",
            "structured_type": "unstructured"
        },
        "timestamp": "2025-08-16 22:56:19.000",
        "id": "LHjfIf0XWDGjbdvYI0Ji"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "e8b317d3-b7db-42c1-8de7-82d2a7424f0b",
            "detail_level": "medium",
            "structured_type": "unstructured"
        },
        "timestamp": "2025-08-16 22:56:19.000",
        "id": "U7fPRF9cJuO0vMlaDOwB"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "e8b317d3-b7db-42c1-8de7-82d2a7424f0b",
            "mapping_index": 5,
            "structured_type": "unstructured",
            "detail_level": "medium"
        },
        "timestamp": "2025-08-16 22:56:19.000",
        "id": "l7deo8NNtIzwMwlFajcC"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "e8b317d3-b7db-42c1-8de7-82d2a7424f0b",
            "mapping_index": 5,
            "structured_type": "unstructured",
            "detail_level": "medium"
        },
        "timestamp": "2025-08-16 22:56:23.000",
        "id": "UWTf0cFk3xgaT9IwKMXO"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "e8b317d3-b7db-42c1-8de7-82d2a7424f0b",
            "mapping_index": 4,
            "structured_type": "unstructured",
            "detail_level": "medium"
        },
        "timestamp": "2025-08-16 22:56:26.000",
        "id": "abhROC2lXgXaI9pBmITR"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "e8b317d3-b7db-42c1-8de7-82d2a7424f0b",
            "detail_level": "medium",
            "structured_type": "unstructured"
        },
        "timestamp": "2025-08-16 22:56:26.000",
        "id": "pfBWwwy2Qyht2OINJ5YL"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "e8b317d3-b7db-42c1-8de7-82d2a7424f0b",
            "mapping_index": 0,
            "structured_type": "unstructured",
            "detail_level": "medium"
        },
        "timestamp": "2025-08-16 22:56:27.000",
        "id": "G51owvvTRuLapVFWUL7R"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "e8b317d3-b7db-42c1-8de7-82d2a7424f0b",
            "detail_level": "medium",
            "structured_type": "unstructured"
        },
        "timestamp": "2025-08-16 22:56:27.000",
        "id": "L4N2rAHXFu7nDC0n7yPA"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "e8b317d3-b7db-42c1-8de7-82d2a7424f0b",
            "mapping_index": 2,
            "structured_type": "unstructured",
            "detail_level": "medium"
        },
        "timestamp": "2025-08-16 22:56:27.000",
        "id": "Mz0ptPg3AmoRvrBUkM6L"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "e8b317d3-b7db-42c1-8de7-82d2a7424f0b",
            "detail_level": "medium",
            "structured_type": "unstructured"
        },
        "timestamp": "2025-08-16 22:56:27.000",
        "id": "ybW6molT5kitqiYeC6Wi"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "e8b317d3-b7db-42c1-8de7-82d2a7424f0b",
            "detail_level": "medium",
            "structured_type": "unstructured"
        },
        "timestamp": "2025-08-16 22:56:27.000",
        "id": "z1uAFDDWJA8SAeTWoJSW"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "e8b317d3-b7db-42c1-8de7-82d2a7424f0b",
            "mapping_index": 0,
            "structured_type": "unstructured",
            "detail_level": "high"
        },
        "timestamp": "2025-08-16 22:56:28.000",
        "id": "HBdBa3vzNJuN3olpsJA7"
    },
    {
        "source": "frontend",
        "event": "change_summary_level",
        "data": {
            "before_detail_level": "medium",
            "section_id": "e8b317d3-b7db-42c1-8de7-82d2a7424f0b",
            "before_structured": "unstructured",
            "after_structured": "unstructured",
            "after_detail_level": "high"
        },
        "timestamp": "2025-08-16 22:56:28.000",
        "id": "IYgjbb564sl8vBMR8M56"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "e8b317d3-b7db-42c1-8de7-82d2a7424f0b",
            "detail_level": "high",
            "structured_type": "unstructured"
        },
        "timestamp": "2025-08-16 22:56:29.000",
        "id": "DAvCj8S2lG3sBxKkwFZJ"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "e8b317d3-b7db-42c1-8de7-82d2a7424f0b",
            "detail_level": "high",
            "structured_type": "unstructured"
        },
        "timestamp": "2025-08-16 22:56:29.000",
        "id": "HkK30PyCIMGlJnWMU97Q"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "e8b317d3-b7db-42c1-8de7-82d2a7424f0b",
            "mapping_index": 4,
            "structured_type": "unstructured",
            "detail_level": "high"
        },
        "timestamp": "2025-08-16 22:56:29.000",
        "id": "KXXgJyghAWpOR4dgy9NC"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "e8b317d3-b7db-42c1-8de7-82d2a7424f0b",
            "mapping_index": 1,
            "structured_type": "unstructured",
            "detail_level": "high"
        },
        "timestamp": "2025-08-16 22:56:29.000",
        "id": "Na4wHf0NPOKzXkPnEe9f"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "e8b317d3-b7db-42c1-8de7-82d2a7424f0b",
            "mapping_index": 5,
            "structured_type": "unstructured",
            "detail_level": "high"
        },
        "timestamp": "2025-08-16 22:56:29.000",
        "id": "Tz4YyBK31F8apYmGCId7"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "e8b317d3-b7db-42c1-8de7-82d2a7424f0b",
            "detail_level": "high",
            "structured_type": "unstructured"
        },
        "timestamp": "2025-08-16 22:56:29.000",
        "id": "XSlFczDuER0q8YWk5nUK"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "e8b317d3-b7db-42c1-8de7-82d2a7424f0b",
            "mapping_index": 3,
            "structured_type": "unstructured",
            "detail_level": "high"
        },
        "timestamp": "2025-08-16 22:56:29.000",
        "id": "Y3GZJjNyeT1M4oRYDeam"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "e8b317d3-b7db-42c1-8de7-82d2a7424f0b",
            "detail_level": "high",
            "structured_type": "unstructured"
        },
        "timestamp": "2025-08-16 22:56:29.000",
        "id": "refYXhXBcyWuHbxKCIME"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "e8b317d3-b7db-42c1-8de7-82d2a7424f0b",
            "detail_level": "high",
            "structured_type": "unstructured"
        },
        "timestamp": "2025-08-16 22:56:30.000",
        "id": "KnyitzzSRzDnICCL8UK9"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "e8b317d3-b7db-42c1-8de7-82d2a7424f0b",
            "mapping_index": 4,
            "structured_type": "unstructured",
            "detail_level": "high"
        },
        "timestamp": "2025-08-16 22:56:30.000",
        "id": "kSOeKQKvrp5sUuFxUHRS"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "e8b317d3-b7db-42c1-8de7-82d2a7424f0b",
            "mapping_index": 3,
            "structured_type": "unstructured",
            "detail_level": "high"
        },
        "timestamp": "2025-08-16 22:56:31.000",
        "id": "0ng2ECWa3HvT6ZzFou9G"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "e8b317d3-b7db-42c1-8de7-82d2a7424f0b",
            "detail_level": "high",
            "structured_type": "unstructured"
        },
        "timestamp": "2025-08-16 22:56:31.000",
        "id": "c4pU9sDQ5d1EG6JMSplU"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "e8b317d3-b7db-42c1-8de7-82d2a7424f0b",
            "detail_level": "high",
            "structured_type": "unstructured"
        },
        "timestamp": "2025-08-16 22:56:32.000",
        "id": "rJNP56gA7TKw3EXXW8MU"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "e8b317d3-b7db-42c1-8de7-82d2a7424f0b",
            "mapping_index": 5,
            "structured_type": "unstructured",
            "detail_level": "high"
        },
        "timestamp": "2025-08-16 22:56:32.000",
        "id": "zu9f55XOiND1b1zh3gcS"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "e8b317d3-b7db-42c1-8de7-82d2a7424f0b",
            "mapping_index": 3,
            "structured_type": "unstructured",
            "detail_level": "high"
        },
        "timestamp": "2025-08-16 22:56:33.000",
        "id": "Sm6gwlCOtyF0875jGjEG"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "e8b317d3-b7db-42c1-8de7-82d2a7424f0b",
            "detail_level": "high",
            "structured_type": "unstructured"
        },
        "timestamp": "2025-08-16 22:56:33.000",
        "id": "xmWfNBQwyFLxYQRutXKQ"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "e8b317d3-b7db-42c1-8de7-82d2a7424f0b",
            "detail_level": "high",
            "structured_type": "unstructured"
        },
        "timestamp": "2025-08-16 22:56:34.000",
        "id": "7znj9y9Jlop5rgKRixpS"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "e8b317d3-b7db-42c1-8de7-82d2a7424f0b",
            "mapping_index": 5,
            "structured_type": "unstructured",
            "detail_level": "high"
        },
        "timestamp": "2025-08-16 22:56:34.000",
        "id": "TT1I2CkAZNSHplMxfizF"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "e8b317d3-b7db-42c1-8de7-82d2a7424f0b",
            "detail_level": "high",
            "structured_type": "unstructured"
        },
        "timestamp": "2025-08-16 22:56:35.000",
        "id": "4mn3WwGSJH5ySDy62Qaa"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "e8b317d3-b7db-42c1-8de7-82d2a7424f0b",
            "detail_level": "high",
            "structured_type": "unstructured"
        },
        "timestamp": "2025-08-16 22:56:35.000",
        "id": "Eiy7wr7cxztAdPpyR0Bi"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "e8b317d3-b7db-42c1-8de7-82d2a7424f0b",
            "mapping_index": 3,
            "structured_type": "unstructured",
            "detail_level": "high"
        },
        "timestamp": "2025-08-16 22:56:35.000",
        "id": "ic4gpSSA6Ip7lqRFUozm"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "e8b317d3-b7db-42c1-8de7-82d2a7424f0b",
            "detail_level": "high",
            "structured_type": "unstructured"
        },
        "timestamp": "2025-08-16 22:56:36.000",
        "id": "Af0UAoTDou93niVd83Ko"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "e8b317d3-b7db-42c1-8de7-82d2a7424f0b",
            "detail_level": "high",
            "structured_type": "unstructured"
        },
        "timestamp": "2025-08-16 22:56:36.000",
        "id": "KBh6geqUTBay7icVCWcC"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "e8b317d3-b7db-42c1-8de7-82d2a7424f0b",
            "mapping_index": 5,
            "structured_type": "unstructured",
            "detail_level": "high"
        },
        "timestamp": "2025-08-16 22:56:36.000",
        "id": "jNnyLOOsqxOvlZwxiyym"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "e8b317d3-b7db-42c1-8de7-82d2a7424f0b",
            "mapping_index": 4,
            "structured_type": "unstructured",
            "detail_level": "high"
        },
        "timestamp": "2025-08-16 22:56:36.000",
        "id": "mfAXUsr4YdP9CJycUHZ5"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "e8b317d3-b7db-42c1-8de7-82d2a7424f0b",
            "mapping_index": 4,
            "structured_type": "unstructured",
            "detail_level": "high"
        },
        "timestamp": "2025-08-16 22:56:36.000",
        "id": "x9OU2viTUWIwGsFuf8ur"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "e8b317d3-b7db-42c1-8de7-82d2a7424f0b",
            "mapping_index": 3,
            "structured_type": "unstructured",
            "detail_level": "high"
        },
        "timestamp": "2025-08-16 22:56:38.000",
        "id": "P4xVrkWgd21ikrF4yNLn"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "e8b317d3-b7db-42c1-8de7-82d2a7424f0b",
            "detail_level": "high",
            "structured_type": "unstructured"
        },
        "timestamp": "2025-08-16 22:56:38.000",
        "id": "Qj9DD6QCuCr200QG66tg"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "e8b317d3-b7db-42c1-8de7-82d2a7424f0b",
            "mapping_index": 2,
            "structured_type": "unstructured",
            "detail_level": "high"
        },
        "timestamp": "2025-08-16 22:56:42.000",
        "id": "YF93Whv3oAw1NUKw3rc0"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "e8b317d3-b7db-42c1-8de7-82d2a7424f0b",
            "detail_level": "high",
            "structured_type": "unstructured"
        },
        "timestamp": "2025-08-16 22:56:42.000",
        "id": "uAWcGDJlFWc7NYBv62zy"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "e8b317d3-b7db-42c1-8de7-82d2a7424f0b",
            "detail_level": "high",
            "structured_type": "unstructured"
        },
        "timestamp": "2025-08-16 22:56:43.000",
        "id": "AWQyv0GfCcpcbtwhi7Yw"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "e8b317d3-b7db-42c1-8de7-82d2a7424f0b",
            "detail_level": "high",
            "structured_type": "unstructured"
        },
        "timestamp": "2025-08-16 22:56:43.000",
        "id": "ApI3FbjbLCCDISmHhEkq"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "e8b317d3-b7db-42c1-8de7-82d2a7424f0b",
            "mapping_index": 5,
            "structured_type": "unstructured",
            "detail_level": "high"
        },
        "timestamp": "2025-08-16 22:56:43.000",
        "id": "EC4ZzFMGnTkqOdtvIpOH"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "e8b317d3-b7db-42c1-8de7-82d2a7424f0b",
            "mapping_index": 6,
            "structured_type": "unstructured",
            "detail_level": "high"
        },
        "timestamp": "2025-08-16 22:56:43.000",
        "id": "VVe5Pw3FsAwO02kfdmN9"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "e8b317d3-b7db-42c1-8de7-82d2a7424f0b",
            "mapping_index": 3,
            "structured_type": "unstructured",
            "detail_level": "high"
        },
        "timestamp": "2025-08-16 22:56:43.000",
        "id": "aO7FOMtSkHlMHqbxKe3a"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "e8b317d3-b7db-42c1-8de7-82d2a7424f0b",
            "detail_level": "high",
            "structured_type": "unstructured"
        },
        "timestamp": "2025-08-16 22:56:43.000",
        "id": "kk0yzPBMX09teKlQA324"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "e8b317d3-b7db-42c1-8de7-82d2a7424f0b",
            "detail_level": "high",
            "structured_type": "unstructured"
        },
        "timestamp": "2025-08-16 22:56:44.000",
        "id": "EQv2hSCNQ4b7bH1i9shC"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "e8b317d3-b7db-42c1-8de7-82d2a7424f0b",
            "mapping_index": 5,
            "structured_type": "unstructured",
            "detail_level": "high"
        },
        "timestamp": "2025-08-16 22:56:44.000",
        "id": "GzQMjeQWfFLiuIiTONzH"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "e8b317d3-b7db-42c1-8de7-82d2a7424f0b",
            "mapping_index": 4,
            "structured_type": "unstructured",
            "detail_level": "high"
        },
        "timestamp": "2025-08-16 22:56:45.000",
        "id": "Qiyin8BRUmb6ATJctjYQ"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "e8b317d3-b7db-42c1-8de7-82d2a7424f0b",
            "detail_level": "high",
            "structured_type": "unstructured"
        },
        "timestamp": "2025-08-16 22:56:45.000",
        "id": "dYo9mU4SdlYtn6ffV5Cu"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "e8b317d3-b7db-42c1-8de7-82d2a7424f0b",
            "mapping_index": 5,
            "structured_type": "unstructured",
            "detail_level": "high"
        },
        "timestamp": "2025-08-16 22:56:46.000",
        "id": "amMut5A54aSYNrXaOEvg"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "e8b317d3-b7db-42c1-8de7-82d2a7424f0b",
            "detail_level": "high",
            "structured_type": "unstructured"
        },
        "timestamp": "2025-08-16 22:56:46.000",
        "id": "ha9fpRxtqvl4xTOLI7Tx"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "e8b317d3-b7db-42c1-8de7-82d2a7424f0b",
            "mapping_index": 6,
            "structured_type": "unstructured",
            "detail_level": "high"
        },
        "timestamp": "2025-08-16 22:56:47.000",
        "id": "IcKc5pF1yLZCk9yFxSjP"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "e8b317d3-b7db-42c1-8de7-82d2a7424f0b",
            "detail_level": "high",
            "structured_type": "unstructured"
        },
        "timestamp": "2025-08-16 22:56:47.000",
        "id": "SpgBnDskMbFJgAv6cavH"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "e8b317d3-b7db-42c1-8de7-82d2a7424f0b",
            "detail_level": "high",
            "structured_type": "unstructured"
        },
        "timestamp": "2025-08-16 22:56:48.000",
        "id": "5P31F5XjXYExldedqN0q"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "e8b317d3-b7db-42c1-8de7-82d2a7424f0b",
            "mapping_index": 7,
            "structured_type": "unstructured",
            "detail_level": "high"
        },
        "timestamp": "2025-08-16 22:56:48.000",
        "id": "yngOgYAYkna925bilIYL"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "e8b317d3-b7db-42c1-8de7-82d2a7424f0b",
            "detail_level": "high",
            "structured_type": "unstructured"
        },
        "timestamp": "2025-08-16 22:56:49.000",
        "id": "3RuUVLpdqcGursfEuynO"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "e8b317d3-b7db-42c1-8de7-82d2a7424f0b",
            "mapping_index": 0,
            "structured_type": "unstructured",
            "detail_level": "high"
        },
        "timestamp": "2025-08-16 22:56:49.000",
        "id": "43aTu9NTQ8WIJSbQ1vuS"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "e8b317d3-b7db-42c1-8de7-82d2a7424f0b",
            "mapping_index": 2,
            "structured_type": "unstructured",
            "detail_level": "high"
        },
        "timestamp": "2025-08-16 22:56:49.000",
        "id": "F1Asdn58tY9eIr3u3cem"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "e8b317d3-b7db-42c1-8de7-82d2a7424f0b",
            "mapping_index": 5,
            "structured_type": "unstructured",
            "detail_level": "high"
        },
        "timestamp": "2025-08-16 22:56:49.000",
        "id": "IS30kbRRe3owZRw01ejv"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "e8b317d3-b7db-42c1-8de7-82d2a7424f0b",
            "detail_level": "high",
            "structured_type": "unstructured"
        },
        "timestamp": "2025-08-16 22:56:49.000",
        "id": "RMzL5lB2BTB6DyasQ9JR"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "e8b317d3-b7db-42c1-8de7-82d2a7424f0b",
            "mapping_index": 6,
            "structured_type": "unstructured",
            "detail_level": "high"
        },
        "timestamp": "2025-08-16 22:56:49.000",
        "id": "ZZvaVi4TK74vKHNg8gS1"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "e8b317d3-b7db-42c1-8de7-82d2a7424f0b",
            "detail_level": "high",
            "structured_type": "unstructured"
        },
        "timestamp": "2025-08-16 22:56:49.000",
        "id": "i5nSWZmvxIPTeZ9Jpdu3"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "e8b317d3-b7db-42c1-8de7-82d2a7424f0b",
            "detail_level": "high",
            "structured_type": "unstructured"
        },
        "timestamp": "2025-08-16 22:56:49.000",
        "id": "urROSLqYMNhk0vM0KhhV"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "e8b317d3-b7db-42c1-8de7-82d2a7424f0b",
            "detail_level": "high",
            "structured_type": "unstructured"
        },
        "timestamp": "2025-08-16 22:56:49.000",
        "id": "zPHQEdD5CZxLKv0rE6bJ"
    },
    {
        "source": "frontend",
        "event": "change_summary_level",
        "data": {
            "before_detail_level": "high",
            "section_id": "e8b317d3-b7db-42c1-8de7-82d2a7424f0b",
            "before_structured": "unstructured",
            "after_structured": "structured",
            "after_detail_level": "high"
        },
        "timestamp": "2025-08-16 22:56:50.000",
        "id": "2fyzjtiLGBR3Dcg42KcV"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "e8b317d3-b7db-42c1-8de7-82d2a7424f0b",
            "detail_level": "high",
            "structured_type": "structured"
        },
        "timestamp": "2025-08-16 22:56:51.000",
        "id": "Dnai2Ttk0N6IIUfkTTbJ"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "e8b317d3-b7db-42c1-8de7-82d2a7424f0b",
            "detail_level": "high",
            "structured_type": "structured"
        },
        "timestamp": "2025-08-16 22:56:51.000",
        "id": "MdJX8m4MZ6KPjAf1t6lv"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "e8b317d3-b7db-42c1-8de7-82d2a7424f0b",
            "mapping_index": 0,
            "structured_type": "structured",
            "detail_level": "high"
        },
        "timestamp": "2025-08-16 22:56:51.000",
        "id": "Pmv7idiJ2GzIN2ZG3iEJ"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "e8b317d3-b7db-42c1-8de7-82d2a7424f0b",
            "mapping_index": 2,
            "structured_type": "structured",
            "detail_level": "high"
        },
        "timestamp": "2025-08-16 22:56:51.000",
        "id": "cEvpgKsYJO2KMrtrfjNO"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "e8b317d3-b7db-42c1-8de7-82d2a7424f0b",
            "mapping_index": 1,
            "structured_type": "structured",
            "detail_level": "high"
        },
        "timestamp": "2025-08-16 22:56:51.000",
        "id": "lmtjYw1ps952DW4WjCpe"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "e8b317d3-b7db-42c1-8de7-82d2a7424f0b",
            "mapping_index": 3,
            "structured_type": "structured",
            "detail_level": "high"
        },
        "timestamp": "2025-08-16 22:56:51.000",
        "id": "mA4EHHks0ocBavHaQCgB"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "e8b317d3-b7db-42c1-8de7-82d2a7424f0b",
            "detail_level": "high",
            "structured_type": "structured"
        },
        "timestamp": "2025-08-16 22:56:51.000",
        "id": "xxEJjGuDlDsYpJGgp3be"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "e8b317d3-b7db-42c1-8de7-82d2a7424f0b",
            "detail_level": "high",
            "structured_type": "structured"
        },
        "timestamp": "2025-08-16 22:56:52.000",
        "id": "JiE6HaVctBml4iwokBEx"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "e8b317d3-b7db-42c1-8de7-82d2a7424f0b",
            "mapping_index": 4,
            "structured_type": "structured",
            "detail_level": "high"
        },
        "timestamp": "2025-08-16 22:56:52.000",
        "id": "b0EDiZal0XQAG4TYkD2t"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "e8b317d3-b7db-42c1-8de7-82d2a7424f0b",
            "detail_level": "high",
            "structured_type": "structured"
        },
        "timestamp": "2025-08-16 22:56:53.000",
        "id": "TNFy1gIFWmza6ggiVjGu"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "e8b317d3-b7db-42c1-8de7-82d2a7424f0b",
            "mapping_index": 3,
            "structured_type": "structured",
            "detail_level": "high"
        },
        "timestamp": "2025-08-16 22:56:53.000",
        "id": "hXhaehD5UlMfXcqn0xlM"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "e8b317d3-b7db-42c1-8de7-82d2a7424f0b",
            "detail_level": "high",
            "structured_type": "structured"
        },
        "timestamp": "2025-08-16 22:56:55.000",
        "id": "HeytKRG0lWTk83Zc9mPv"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "e8b317d3-b7db-42c1-8de7-82d2a7424f0b",
            "mapping_index": 3,
            "structured_type": "structured",
            "detail_level": "high"
        },
        "timestamp": "2025-08-16 22:56:55.000",
        "id": "PjIAjGJOealPANVXBV4c"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "e8b317d3-b7db-42c1-8de7-82d2a7424f0b",
            "mapping_index": 4,
            "structured_type": "structured",
            "detail_level": "high"
        },
        "timestamp": "2025-08-16 22:56:56.000",
        "id": "GYVYrzGckioyRi2M2rRN"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "e8b317d3-b7db-42c1-8de7-82d2a7424f0b",
            "detail_level": "high",
            "structured_type": "structured"
        },
        "timestamp": "2025-08-16 22:56:56.000",
        "id": "qN9VFiG5LxFVG476TGdE"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "e8b317d3-b7db-42c1-8de7-82d2a7424f0b",
            "mapping_index": 5,
            "structured_type": "structured",
            "detail_level": "high"
        },
        "timestamp": "2025-08-16 22:56:57.000",
        "id": "62UbY67mMKOG42AM2KWa"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "e8b317d3-b7db-42c1-8de7-82d2a7424f0b",
            "detail_level": "high",
            "structured_type": "structured"
        },
        "timestamp": "2025-08-16 22:56:57.000",
        "id": "WtJmNh6OlKw6dY5RiXSk"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "e8b317d3-b7db-42c1-8de7-82d2a7424f0b",
            "mapping_index": 4,
            "structured_type": "structured",
            "detail_level": "high"
        },
        "timestamp": "2025-08-16 22:56:58.000",
        "id": "ubt6sSSkKkyyTPMACWvP"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "e8b317d3-b7db-42c1-8de7-82d2a7424f0b",
            "detail_level": "high",
            "structured_type": "structured"
        },
        "timestamp": "2025-08-16 22:56:58.000",
        "id": "wT3ZSBD1UbLr3seR9KN3"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "e8b317d3-b7db-42c1-8de7-82d2a7424f0b",
            "detail_level": "high",
            "structured_type": "structured"
        },
        "timestamp": "2025-08-16 22:56:59.000",
        "id": "9pFHT8uVbAlidJf8iYEz"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "e8b317d3-b7db-42c1-8de7-82d2a7424f0b",
            "detail_level": "high",
            "structured_type": "structured"
        },
        "timestamp": "2025-08-16 22:56:59.000",
        "id": "DE6YWyh8QfwrduMzhRNl"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "e8b317d3-b7db-42c1-8de7-82d2a7424f0b",
            "mapping_index": 5,
            "structured_type": "structured",
            "detail_level": "high"
        },
        "timestamp": "2025-08-16 22:56:59.000",
        "id": "QVYU5DDomkEfqKdUyAqt"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "e8b317d3-b7db-42c1-8de7-82d2a7424f0b",
            "mapping_index": 4,
            "structured_type": "structured",
            "detail_level": "high"
        },
        "timestamp": "2025-08-16 22:56:59.000",
        "id": "TpEv9BUPBDSFmRrtHFYa"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "e8b317d3-b7db-42c1-8de7-82d2a7424f0b",
            "mapping_index": 3,
            "structured_type": "structured",
            "detail_level": "high"
        },
        "timestamp": "2025-08-16 22:57:00.000",
        "id": "1BpndQI8ZWVVY1juKgu5"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "e8b317d3-b7db-42c1-8de7-82d2a7424f0b",
            "detail_level": "high",
            "structured_type": "structured"
        },
        "timestamp": "2025-08-16 22:57:00.000",
        "id": "AEY6uk59bhSux2DQ3BZe"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "e8b317d3-b7db-42c1-8de7-82d2a7424f0b",
            "detail_level": "high",
            "structured_type": "structured"
        },
        "timestamp": "2025-08-16 22:57:00.000",
        "id": "W1XxKyVYPJTVzMchFKJR"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "e8b317d3-b7db-42c1-8de7-82d2a7424f0b",
            "mapping_index": 4,
            "structured_type": "structured",
            "detail_level": "high"
        },
        "timestamp": "2025-08-16 22:57:01.000",
        "id": "7OCIakxxxPGJ1UPQEsZ6"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "e8b317d3-b7db-42c1-8de7-82d2a7424f0b",
            "mapping_index": 5,
            "structured_type": "structured",
            "detail_level": "high"
        },
        "timestamp": "2025-08-16 22:57:01.000",
        "id": "OkQ5y2R6I4EVbFzDDupE"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "e8b317d3-b7db-42c1-8de7-82d2a7424f0b",
            "mapping_index": 3,
            "structured_type": "structured",
            "detail_level": "high"
        },
        "timestamp": "2025-08-16 22:57:01.000",
        "id": "up6kcNX5HO4qIfiyW0rN"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "e8b317d3-b7db-42c1-8de7-82d2a7424f0b",
            "detail_level": "high",
            "structured_type": "structured"
        },
        "timestamp": "2025-08-16 22:57:01.000",
        "id": "xKojgrIUHzOce7JOpIXm"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "e8b317d3-b7db-42c1-8de7-82d2a7424f0b",
            "detail_level": "high",
            "structured_type": "structured"
        },
        "timestamp": "2025-08-16 22:57:01.000",
        "id": "yqMGnWy8U8uOjeAWGvUo"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "e8b317d3-b7db-42c1-8de7-82d2a7424f0b",
            "mapping_index": 6,
            "structured_type": "structured",
            "detail_level": "high"
        },
        "timestamp": "2025-08-16 22:57:05.000",
        "id": "lBVejy72SrOkaZGnx7NB"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "e8b317d3-b7db-42c1-8de7-82d2a7424f0b",
            "detail_level": "high",
            "structured_type": "structured"
        },
        "timestamp": "2025-08-16 22:57:05.000",
        "id": "t624oCh0pQQvtOarbxNp"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "e8b317d3-b7db-42c1-8de7-82d2a7424f0b",
            "mapping_index": 7,
            "structured_type": "structured",
            "detail_level": "high"
        },
        "timestamp": "2025-08-16 22:57:07.000",
        "id": "7W6daYmnZFZSlhF6pCx7"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "e8b317d3-b7db-42c1-8de7-82d2a7424f0b",
            "detail_level": "high",
            "structured_type": "structured"
        },
        "timestamp": "2025-08-16 22:57:07.000",
        "id": "mtuoEE8N2oZku07I9wZB"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "e8b317d3-b7db-42c1-8de7-82d2a7424f0b",
            "detail_level": "high",
            "structured_type": "structured"
        },
        "timestamp": "2025-08-16 22:57:08.000",
        "id": "3ua2n8qag80ZGY2sgdwS"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "e8b317d3-b7db-42c1-8de7-82d2a7424f0b",
            "mapping_index": 8,
            "structured_type": "structured",
            "detail_level": "high"
        },
        "timestamp": "2025-08-16 22:57:08.000",
        "id": "sBMEBYt5fY24KP3EbBWf"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "e8b317d3-b7db-42c1-8de7-82d2a7424f0b",
            "mapping_index": 7,
            "structured_type": "structured",
            "detail_level": "high"
        },
        "timestamp": "2025-08-16 22:57:10.000",
        "id": "7Gj8fcmjjU9yHerdlUHK"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "e8b317d3-b7db-42c1-8de7-82d2a7424f0b",
            "detail_level": "high",
            "structured_type": "structured"
        },
        "timestamp": "2025-08-16 22:57:10.000",
        "id": "FEeKYmJQ2eRcug4WnuYx"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "e8b317d3-b7db-42c1-8de7-82d2a7424f0b",
            "detail_level": "high",
            "structured_type": "structured"
        },
        "timestamp": "2025-08-16 22:57:10.000",
        "id": "PfIrib4E4CLC5VXff4lb"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "e8b317d3-b7db-42c1-8de7-82d2a7424f0b",
            "mapping_index": 7,
            "structured_type": "structured",
            "detail_level": "high"
        },
        "timestamp": "2025-08-16 22:57:10.000",
        "id": "nq5LgcCq8LsSr98r5QPY"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "e8b317d3-b7db-42c1-8de7-82d2a7424f0b",
            "mapping_index": 6,
            "structured_type": "structured",
            "detail_level": "high"
        },
        "timestamp": "2025-08-16 22:57:10.000",
        "id": "qgwZTVZPJ2MK7tm3l4jC"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "e8b317d3-b7db-42c1-8de7-82d2a7424f0b",
            "detail_level": "high",
            "structured_type": "structured"
        },
        "timestamp": "2025-08-16 22:57:10.000",
        "id": "tyyZN9fHoMqcjMaplrpc"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "e8b317d3-b7db-42c1-8de7-82d2a7424f0b",
            "mapping_index": 9,
            "structured_type": "structured",
            "detail_level": "high"
        },
        "timestamp": "2025-08-16 22:57:11.000",
        "id": "8607YfYevjbwrG4rH93Y"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "e8b317d3-b7db-42c1-8de7-82d2a7424f0b",
            "detail_level": "high",
            "structured_type": "structured"
        },
        "timestamp": "2025-08-16 22:57:11.000",
        "id": "CNU04Fie3DNaJs7l6Lmn"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "e8b317d3-b7db-42c1-8de7-82d2a7424f0b",
            "detail_level": "high",
            "structured_type": "structured"
        },
        "timestamp": "2025-08-16 22:57:11.000",
        "id": "HrTYBIQNxuPMy5qUbRkp"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "e8b317d3-b7db-42c1-8de7-82d2a7424f0b",
            "mapping_index": 6,
            "structured_type": "structured",
            "detail_level": "high"
        },
        "timestamp": "2025-08-16 22:57:11.000",
        "id": "KqWBtHmE7Sp6tpuk5vEV"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "e8b317d3-b7db-42c1-8de7-82d2a7424f0b",
            "mapping_index": 8,
            "structured_type": "structured",
            "detail_level": "high"
        },
        "timestamp": "2025-08-16 22:57:11.000",
        "id": "M6XvzgD3T8QxqJNy48YE"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "e8b317d3-b7db-42c1-8de7-82d2a7424f0b",
            "mapping_index": 5,
            "structured_type": "structured",
            "detail_level": "high"
        },
        "timestamp": "2025-08-16 22:57:11.000",
        "id": "V1vzbTkT6YC9L83fCGa3"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "e8b317d3-b7db-42c1-8de7-82d2a7424f0b",
            "mapping_index": 8,
            "structured_type": "structured",
            "detail_level": "high"
        },
        "timestamp": "2025-08-16 22:57:11.000",
        "id": "c0pWVtmQ4R5Z4imvFIgN"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "e8b317d3-b7db-42c1-8de7-82d2a7424f0b",
            "detail_level": "high",
            "structured_type": "structured"
        },
        "timestamp": "2025-08-16 22:57:11.000",
        "id": "iKsjfNl7gOxeNvobhlWP"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "e8b317d3-b7db-42c1-8de7-82d2a7424f0b",
            "mapping_index": 4,
            "structured_type": "structured",
            "detail_level": "high"
        },
        "timestamp": "2025-08-16 22:57:11.000",
        "id": "mEHPE377YtWynLIhDtTO"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "e8b317d3-b7db-42c1-8de7-82d2a7424f0b",
            "detail_level": "high",
            "structured_type": "structured"
        },
        "timestamp": "2025-08-16 22:57:11.000",
        "id": "rEl8pBSOfdSaz02GEkiC"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "e8b317d3-b7db-42c1-8de7-82d2a7424f0b",
            "detail_level": "high",
            "structured_type": "structured"
        },
        "timestamp": "2025-08-16 22:57:11.000",
        "id": "rwmK4zGDqji55YmA05sO"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "e8b317d3-b7db-42c1-8de7-82d2a7424f0b",
            "detail_level": "high",
            "structured_type": "structured"
        },
        "timestamp": "2025-08-16 22:57:11.000",
        "id": "wOw9uEbc0t5GSJQiZwW1"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "e8b317d3-b7db-42c1-8de7-82d2a7424f0b",
            "mapping_index": 7,
            "structured_type": "structured",
            "detail_level": "high"
        },
        "timestamp": "2025-08-16 22:57:11.000",
        "id": "xsZezSKERfBgzWBZUqXb"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "e8b317d3-b7db-42c1-8de7-82d2a7424f0b",
            "detail_level": "high",
            "structured_type": "structured"
        },
        "timestamp": "2025-08-16 22:57:11.000",
        "id": "yMy2Vjfgh8Atl2vtRvDz"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "e8b317d3-b7db-42c1-8de7-82d2a7424f0b",
            "detail_level": "high",
            "structured_type": "structured"
        },
        "timestamp": "2025-08-16 22:57:12.000",
        "id": "1X4GTaHtI3C1ejes5oz9"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "e8b317d3-b7db-42c1-8de7-82d2a7424f0b",
            "mapping_index": 2,
            "structured_type": "structured",
            "detail_level": "high"
        },
        "timestamp": "2025-08-16 22:57:12.000",
        "id": "kIOCy58sMmrooU9nt5tE"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "e8b317d3-b7db-42c1-8de7-82d2a7424f0b",
            "mapping_index": 3,
            "structured_type": "structured",
            "detail_level": "high"
        },
        "timestamp": "2025-08-16 22:57:12.000",
        "id": "nvMYOxbILV3uhDUzzlYB"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "e8b317d3-b7db-42c1-8de7-82d2a7424f0b",
            "detail_level": "high",
            "structured_type": "structured"
        },
        "timestamp": "2025-08-16 22:57:12.000",
        "id": "oDWN6v8ToRdziQIM3yjR"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "e8b317d3-b7db-42c1-8de7-82d2a7424f0b",
            "mapping_index": 1,
            "structured_type": "structured",
            "detail_level": "high"
        },
        "timestamp": "2025-08-16 22:57:13.000",
        "id": "0OVfPUdYFmHb5Jhwwmo4"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "e8b317d3-b7db-42c1-8de7-82d2a7424f0b",
            "detail_level": "high",
            "structured_type": "structured"
        },
        "timestamp": "2025-08-16 22:57:13.000",
        "id": "F53HmYWD6HxWhrzksDSw"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "e8b317d3-b7db-42c1-8de7-82d2a7424f0b",
            "detail_level": "high",
            "structured_type": "structured"
        },
        "timestamp": "2025-08-16 22:57:15.000",
        "id": "QdG4rly4n5cgA9juvYzV"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "e8b317d3-b7db-42c1-8de7-82d2a7424f0b",
            "detail_level": "high",
            "structured_type": "structured"
        },
        "timestamp": "2025-08-16 22:57:16.000",
        "id": "DYxNLupTAiwafUzaajNH"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "e8b317d3-b7db-42c1-8de7-82d2a7424f0b",
            "detail_level": "high",
            "structured_type": "structured"
        },
        "timestamp": "2025-08-16 22:57:16.000",
        "id": "nXDsmg3lDBcJHtXw1zsR"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "e8b317d3-b7db-42c1-8de7-82d2a7424f0b",
            "mapping_index": 2,
            "structured_type": "structured",
            "detail_level": "high"
        },
        "timestamp": "2025-08-16 22:57:16.000",
        "id": "vWC6xVK0WrWaDTB2jfi0"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "e8b317d3-b7db-42c1-8de7-82d2a7424f0b",
            "mapping_index": 1,
            "structured_type": "structured",
            "detail_level": "high"
        },
        "timestamp": "2025-08-16 22:57:16.000",
        "id": "wVBypcmDwSdiDoWkJf9D"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "e8b317d3-b7db-42c1-8de7-82d2a7424f0b",
            "mapping_index": 1,
            "structured_type": "structured",
            "detail_level": "high"
        },
        "timestamp": "2025-08-16 22:57:16.000",
        "id": "y03jPDO47dSUtOubs08r"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "e8b317d3-b7db-42c1-8de7-82d2a7424f0b",
            "detail_level": "high",
            "structured_type": "structured"
        },
        "timestamp": "2025-08-16 22:57:17.000",
        "id": "iRqRfJOTlaYSZeqJvkEp"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "e8b317d3-b7db-42c1-8de7-82d2a7424f0b",
            "detail_level": "high",
            "structured_type": "structured"
        },
        "timestamp": "2025-08-16 22:57:18.000",
        "id": "2Fol58B0cm1SDrcXFqKQ"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "e8b317d3-b7db-42c1-8de7-82d2a7424f0b",
            "mapping_index": 2,
            "structured_type": "structured",
            "detail_level": "high"
        },
        "timestamp": "2025-08-16 22:57:18.000",
        "id": "NBoo3TyUm28DpPnW9QAV"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "e8b317d3-b7db-42c1-8de7-82d2a7424f0b",
            "mapping_index": 1,
            "structured_type": "structured",
            "detail_level": "high"
        },
        "timestamp": "2025-08-16 22:57:18.000",
        "id": "SL2fH7lFMsNxD6VCV26E"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "e8b317d3-b7db-42c1-8de7-82d2a7424f0b",
            "detail_level": "high",
            "structured_type": "structured"
        },
        "timestamp": "2025-08-16 22:57:18.000",
        "id": "hmWeXFcktrLXNFLR7WwH"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "e8b317d3-b7db-42c1-8de7-82d2a7424f0b",
            "detail_level": "high",
            "structured_type": "structured"
        },
        "timestamp": "2025-08-16 22:57:19.000",
        "id": "B2UYYiWhPlLWwKeGVry0"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "e8b317d3-b7db-42c1-8de7-82d2a7424f0b",
            "mapping_index": 4,
            "structured_type": "structured",
            "detail_level": "high"
        },
        "timestamp": "2025-08-16 22:57:19.000",
        "id": "J2F4Hjeg6vkQ8f4GiVLv"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "e8b317d3-b7db-42c1-8de7-82d2a7424f0b",
            "mapping_index": 3,
            "structured_type": "structured",
            "detail_level": "high"
        },
        "timestamp": "2025-08-16 22:57:19.000",
        "id": "K29vdXONDbxGEAWe3kQx"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "e8b317d3-b7db-42c1-8de7-82d2a7424f0b",
            "detail_level": "high",
            "structured_type": "structured"
        },
        "timestamp": "2025-08-16 22:57:19.000",
        "id": "ZMBLkwCNS0Vx4IgAygdX"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "e8b317d3-b7db-42c1-8de7-82d2a7424f0b",
            "mapping_index": 5,
            "structured_type": "structured",
            "detail_level": "high"
        },
        "timestamp": "2025-08-16 22:57:19.000",
        "id": "lnamqQANIx97bI45Po62"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "e8b317d3-b7db-42c1-8de7-82d2a7424f0b",
            "detail_level": "high",
            "structured_type": "structured"
        },
        "timestamp": "2025-08-16 22:57:21.000",
        "id": "5mbcvrSaAbBAqtwTVECp"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "e8b317d3-b7db-42c1-8de7-82d2a7424f0b",
            "mapping_index": 6,
            "structured_type": "structured",
            "detail_level": "high"
        },
        "timestamp": "2025-08-16 22:57:21.000",
        "id": "fp6STZONM7cBrZqUafJl"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "e8b317d3-b7db-42c1-8de7-82d2a7424f0b",
            "detail_level": "high",
            "structured_type": "structured"
        },
        "timestamp": "2025-08-16 22:57:22.000",
        "id": "eTC7EhbfLQEjpDLSxWNC"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "e8b317d3-b7db-42c1-8de7-82d2a7424f0b",
            "mapping_index": 7,
            "structured_type": "structured",
            "detail_level": "high"
        },
        "timestamp": "2025-08-16 22:57:22.000",
        "id": "iEI2CsXBKUCrRzsmOQv5"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "e8b317d3-b7db-42c1-8de7-82d2a7424f0b",
            "mapping_index": 9,
            "structured_type": "structured",
            "detail_level": "high"
        },
        "timestamp": "2025-08-16 22:57:22.000",
        "id": "lcgvdKiX7ONyzhfAREmV"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "e8b317d3-b7db-42c1-8de7-82d2a7424f0b",
            "detail_level": "high",
            "structured_type": "structured"
        },
        "timestamp": "2025-08-16 22:57:22.000",
        "id": "meIewtQc6dIU3zFg4hhW"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "e8b317d3-b7db-42c1-8de7-82d2a7424f0b",
            "detail_level": "high",
            "structured_type": "structured"
        },
        "timestamp": "2025-08-16 22:57:22.000",
        "id": "pzdGItTH75ieoRzRwKt1"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "e8b317d3-b7db-42c1-8de7-82d2a7424f0b",
            "mapping_index": 1,
            "structured_type": "structured",
            "detail_level": "high"
        },
        "timestamp": "2025-08-16 22:58:39.000",
        "id": "3V4KGWpznPad35QYXxiP"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "e8b317d3-b7db-42c1-8de7-82d2a7424f0b",
            "detail_level": "high",
            "structured_type": "structured"
        },
        "timestamp": "2025-08-16 22:58:39.000",
        "id": "3bKl1PMoeACjXw8dTP0R"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "e8b317d3-b7db-42c1-8de7-82d2a7424f0b",
            "mapping_index": 2,
            "structured_type": "structured",
            "detail_level": "high"
        },
        "timestamp": "2025-08-16 22:58:39.000",
        "id": "5LjKgqFbiCs5xcLamzVz"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "e8b317d3-b7db-42c1-8de7-82d2a7424f0b",
            "mapping_index": 0,
            "structured_type": "structured",
            "detail_level": "high"
        },
        "timestamp": "2025-08-16 22:58:39.000",
        "id": "G5JItyXXZiUDNaban2Yk"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "e8b317d3-b7db-42c1-8de7-82d2a7424f0b",
            "detail_level": "high",
            "structured_type": "structured"
        },
        "timestamp": "2025-08-16 22:58:39.000",
        "id": "LS7OGKteHO7ySq64rX8I"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "e8b317d3-b7db-42c1-8de7-82d2a7424f0b",
            "detail_level": "high",
            "structured_type": "structured"
        },
        "timestamp": "2025-08-16 22:58:39.000",
        "id": "PUJoBW0pls0mP6i2CTjT"
    },
    {
        "source": "frontend",
        "event": "click_summarize_code",
        "data": {},
        "timestamp": "2025-08-16 22:58:39.000",
        "id": "tOO1abD6uMKz5suFjxki"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "e8b317d3-b7db-42c1-8de7-82d2a7424f0b",
            "detail_level": "high",
            "structured_type": "structured"
        },
        "timestamp": "2025-08-16 22:58:45.000",
        "id": "4c4gkFJsVesbUXfDEWDK"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "e8b317d3-b7db-42c1-8de7-82d2a7424f0b",
            "mapping_index": 2,
            "structured_type": "structured",
            "detail_level": "high"
        },
        "timestamp": "2025-08-16 22:58:45.000",
        "id": "9g4pIDXzre53AS3LpkLA"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "e8b317d3-b7db-42c1-8de7-82d2a7424f0b",
            "mapping_index": 0,
            "structured_type": "structured",
            "detail_level": "high"
        },
        "timestamp": "2025-08-16 22:58:45.000",
        "id": "Kj1z2uoEdmsYP8iDQkF2"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "e8b317d3-b7db-42c1-8de7-82d2a7424f0b",
            "detail_level": "high",
            "structured_type": "structured"
        },
        "timestamp": "2025-08-16 22:58:45.000",
        "id": "wO2wylh50NMtF2ACeZfC"
    },
    {
        "source": "backend",
        "event": "summarize_selected_code",
        "data": {
            "selected_code": "def load_data(path=\"data/merged_data.csv\"):\n    df = pd.read_csv(path)\n\n    # Features to use\n    feature_cols = [\n        \"PTS\",\n        \"AST\",\n        \"TRB\",\n        \"FG%\",\n        \"BPM\",\n        \"WS/48\",\n        \"TS%\",\n        \"VORP\",\n        \"WS\",\n        \"PER\",\n    ]\n    feature_cols = [\n        col for col in feature_cols if col in df.columns\n    ]  # only keep existing features\n    df = df.dropna(subset=feature_cols + [\"Rank\"])\n\n    # Sort by Year and Rank for consistency\n    df = df.sort_values(by=[\"Year\", \"Rank\"])\n\n    X = df[feature_cols]\n    y = df[\"Rank\"]\n    groups = df.groupby(\"Year\").size().to_numpy()\n\n    return X, y, groups, df\n\n\ndef evaluate_ndcg(y_true, y_pred, group_sizes):\n    scores = []\n    start = 0\n    for size in group_sizes:\n        true_ranks = y_true[start : start + size]\n        true_relevance = (max(true_ranks) + 1) - true_ranks\n        pred_scores = y_pred[start : start + size]\n        scores.append(ndcg_score([true_relevance], [pred_scores]))\n        start += size\n    return np.mean(scores)\n\n\ndef xgboost_ranker(X, y, groups):\n    model = XGBRanker(\n        objective=\"rank:pairwise\",\n        learning_rate=0.1,\n        n_estimators=100,\n        max_depth=6,\n        random_state=42,\n    )\n\n    print(\"Training XGBoostRanker...\")\n    model.fit(X, y, group=groups)\n\n    return model\n\n\ndef plot_ranking_predictions(df, year):\n    \"\"\"\n    Plot prediction error for a specific year.\n\n    Args:\n        df: DataFrame containing prediction results\n        year: Year to plot prediction errors for\n    \"\"\"\n    df[\"RankError\"] = df[\"PredictedRank\"] - df[\"Rank\"]\n    year_df = df[df[\"Year\"] == year].copy()\n    year_df.sort_values(\"Rank\", inplace=True)\n\n    plt.figure(figsize=(12, 6))\n    sns.barplot(x=\"Name\", y=\"RankError\", data=year_df, hue=\"Name\", palette=\"coolwarm\")\n    plt.axhline(0, color=\"black\", linestyle=\"--\")\n    plt.xticks(rotation=45, ha=\"right\")\n    plt.ylabel(\"Predicted Rank - True Rank\")\n    plt.title(f\"MVP Ranking Predictions ({year})\")\n    plt.tight_layout()\n    plt.savefig(f\"data/ranking_predictions_{year}.png\")\n\n\ndef main():\n    X, y, group, df = load_data()\n\n    # Train-test split on years\n    unique_years = df[\"Year\"].unique()\n    train_years, test_years = (\n        unique_years[:-2],  # train: 2015-2023\n        unique_years[-2:],  # test: 2024-2025\n    )\n\n    train_idx = df[\"Year\"].isin(train_years)\n    test_idx = df[\"Year\"].isin(test_years)\n\n    X_train, X_test = X[train_idx], X[test_idx]\n    y_train, y_test = y[train_idx], y[test_idx]\n\n    # Group sizes\n    train_groups = df[train_idx].groupby(\"Year\").size().to_numpy()\n    test_groups = df[test_idx].groupby(\"Year\").size().to_numpy()\n\n    # Model\n    model = XGBRanker(\n        objective=\"rank:pairwise\",\n        learning_rate=0.1,\n        n_estimators=100,\n        max_depth=4,\n        random_state=42,\n    )\n\n    print(\"Training XGBoostRanker...\")\n    model.fit(X_train, y_train, group=train_groups)\n\n    # Predict, sort, and evaluate\n    y_pred = model.predict(X_test)\n    df.loc[test_idx, \"PredictedScore\"] = y_pred\n    df.loc[test_idx, \"PredictedRank\"] = (\n        df.loc[test_idx]\n        .groupby(\"Year\")[\"PredictedScore\"]\n        .rank(ascending=False, method=\"first\")\n    )\n\n    ndcg = evaluate_ndcg(y_test.to_numpy(), y_pred, test_groups)\n    print(f\"NDCG Score on test years {test_years.tolist()}: {ndcg:.4f}\")\n\n    # Show results\n    print(df[test_idx][[\"Year\", \"Name\", \"Rank\", \"PredictedScore\", \"PredictedRank\"]])\n    plot_ranking_predictions(df, 2024)\n    plot_ranking_predictions(df, 2025)\n\n\nif __name__ == \"__main__\":\n    main()\n",
            "summary": {
                "low_structured": "• Loads and processes basketball data\n• Trains and evaluates an XGBoost ranking model\n• Plots and displays ranking prediction results",
                "high_unstructured": "This code snippet includes several functions for a basketball MVP ranking pipeline. The load_data function reads a CSV, selects relevant statistical features, removes rows with missing data, sorts by year and rank, and prepares feature matrices and group labels. The evaluate_ndcg function computes the mean NDCG score for grouped ranking predictions, while xgboost_ranker initializes and fits an XGBoost ranker using pairwise ranking loss. The plot_ranking_predictions function visualizes the difference between predicted and true ranks for a given year using a bar plot. The main function ties everything together: it loads and splits the data by year, trains the model, predicts and ranks players, evaluates with NDCG, prints results, and generates plots for recent years.",
                "medium_unstructured": "The code defines functions to load and preprocess basketball player data, evaluate ranking predictions using NDCG, train an XGBoost ranking model, and visualize prediction errors for specific years. The main function orchestrates the workflow, including splitting data by year, training the model, making predictions, evaluating performance, and plotting results. This setup enables automated model training and evaluation for MVP ranking predictions.",
                "high_structured": "• load_data function:\n  ◦ Reads a CSV file of basketball player stats\n  ◦ Selects a set of statistical features, filters out rows with missing data, and sorts by year and rank\n  ◦ Returns feature matrix, target ranks, group sizes per year, and the full DataFrame\n• evaluate_ndcg function:\n  ◦ Calculates mean NDCG score for ranking predictions grouped by year\n  ◦ Converts ranks to relevance scores and aggregates NDCG across groups\n• xgboost_ranker function:\n  ◦ Initializes an XGBoostRanker with pairwise ranking objective and specific hyperparameters\n  ◦ Trains the model on the provided data and groups\n• plot_ranking_predictions function:\n  ◦ Computes prediction errors (PredictedRank - True Rank) for a given year\n  ◦ Plots these errors as a bar plot, saving the figure for each year\n• main function:\n  ◦ Loads and splits data into training and test sets based on year\n  ◦ Trains the XGBoost ranker, predicts scores and ranks for test data\n  ◦ Evaluates predictions using NDCG, prints results, and generates error plots for the latest years",
                "title": "Summaries for Data Loading, Evaluation, Ranking, Plotting, and Main Workflow Functions",
                "low_unstructured": "This code provides functions for loading basketball data, evaluating ranking predictions, training an XGBoost ranker, plotting prediction errors, and running the full model workflow.",
                "medium_structured": "• Loads and cleans basketball player statistics data\n• Provides an NDCG-based evaluation for ranking predictions\n• Trains an XGBoost ranker on grouped data\n• Plots prediction errors for selected years\n• Main function manages data splitting, model training, prediction, evaluation, and visualization"
            }
        },
        "timestamp": "2025-08-16 22:58:47.000",
        "id": "3nmRenWRZKSH3Udy8MJo"
    },
    {
        "source": "backend",
        "event": "map_summary_code",
        "data": {
            "summary": "This code provides functions for loading basketball data, evaluating ranking predictions, training an XGBoost ranker, plotting prediction errors, and running the full model workflow.",
            "mapping": [
                {
                    "summaryComponent": "functions for loading basketball data",
                    "codeSegments": [
                        {
                            "line": 9,
                            "code": "def load_data(path=\"data/merged_data.csv\"):"
                        }
                    ]
                },
                {
                    "summaryComponent": "evaluating ranking predictions",
                    "codeSegments": [
                        {
                            "line": 40,
                            "code": "def evaluate_ndcg(y_true, y_pred, group_sizes):"
                        }
                    ]
                },
                {
                    "summaryComponent": "training an XGBoost ranker",
                    "codeSegments": [
                        {
                            "line": 52,
                            "code": "def xgboost_ranker(X, y, groups):"
                        },
                        {
                            "line": 53,
                            "code": "model = XGBRanker("
                        }
                    ]
                },
                {
                    "summaryComponent": "plotting prediction errors",
                    "codeSegments": [
                        {
                            "line": 67,
                            "code": "def plot_ranking_predictions(df, year):"
                        }
                    ]
                },
                {
                    "summaryComponent": "running the full model workflow",
                    "codeSegments": [
                        {
                            "line": 89,
                            "code": "def main():"
                        },
                        {
                            "line": 139,
                            "code": "if __name__ == \"__main__\":"
                        },
                        {
                            "line": 140,
                            "code": "main()"
                        }
                    ]
                }
            ],
            "code": "9: def load_data(path=\"data/merged_data.csv\"):\n10:     df = pd.read_csv(path)\n11: \n12:     # Features to use\n13:     feature_cols = [\n14:         \"PTS\",\n15:         \"AST\",\n16:         \"TRB\",\n17:         \"FG%\",\n18:         \"BPM\",\n19:         \"WS/48\",\n20:         \"TS%\",\n21:         \"VORP\",\n22:         \"WS\",\n23:         \"PER\",\n24:     ]\n25:     feature_cols = [\n26:         col for col in feature_cols if col in df.columns\n27:     ]  # only keep existing features\n28:     df = df.dropna(subset=feature_cols + [\"Rank\"])\n29: \n30:     # Sort by Year and Rank for consistency\n31:     df = df.sort_values(by=[\"Year\", \"Rank\"])\n32: \n33:     X = df[feature_cols]\n34:     y = df[\"Rank\"]\n35:     groups = df.groupby(\"Year\").size().to_numpy()\n36: \n37:     return X, y, groups, df\n38: \n39: \n40: def evaluate_ndcg(y_true, y_pred, group_sizes):\n41:     scores = []\n42:     start = 0\n43:     for size in group_sizes:\n44:         true_ranks = y_true[start : start + size]\n45:         true_relevance = (max(true_ranks) + 1) - true_ranks\n46:         pred_scores = y_pred[start : start + size]\n47:         scores.append(ndcg_score([true_relevance], [pred_scores]))\n48:         start += size\n49:     return np.mean(scores)\n50: \n51: \n52: def xgboost_ranker(X, y, groups):\n53:     model = XGBRanker(\n54:         objective=\"rank:pairwise\",\n55:         learning_rate=0.1,\n56:         n_estimators=100,\n57:         max_depth=6,\n58:         random_state=42,\n59:     )\n60: \n61:     print(\"Training XGBoostRanker...\")\n62:     model.fit(X, y, group=groups)\n63: \n64:     return model\n65: \n66: \n67: def plot_ranking_predictions(df, year):\n68:     \"\"\"\n69:     Plot prediction error for a specific year.\n70: \n71:     Args:\n72:         df: DataFrame containing prediction results\n73:         year: Year to plot prediction errors for\n74:     \"\"\"\n75:     df[\"RankError\"] = df[\"PredictedRank\"] - df[\"Rank\"]\n76:     year_df = df[df[\"Year\"] == year].copy()\n77:     year_df.sort_values(\"Rank\", inplace=True)\n78: \n79:     plt.figure(figsize=(12, 6))\n80:     sns.barplot(x=\"Name\", y=\"RankError\", data=year_df, hue=\"Name\", palette=\"coolwarm\")\n81:     plt.axhline(0, color=\"black\", linestyle=\"--\")\n82:     plt.xticks(rotation=45, ha=\"right\")\n83:     plt.ylabel(\"Predicted Rank - True Rank\")\n84:     plt.title(f\"MVP Ranking Predictions ({year})\")\n85:     plt.tight_layout()\n86:     plt.savefig(f\"data/ranking_predictions_{year}.png\")\n87: \n88: \n89: def main():\n90:     X, y, group, df = load_data()\n91: \n92:     # Train-test split on years\n93:     unique_years = df[\"Year\"].unique()\n94:     train_years, test_years = (\n95:         unique_years[:-2],  # train: 2015-2023\n96:         unique_years[-2:],  # test: 2024-2025\n97:     )\n98: \n99:     train_idx = df[\"Year\"].isin(train_years)\n100:     test_idx = df[\"Year\"].isin(test_years)\n101: \n102:     X_train, X_test = X[train_idx], X[test_idx]\n103:     y_train, y_test = y[train_idx], y[test_idx]\n104: \n105:     # Group sizes\n106:     train_groups = df[train_idx].groupby(\"Year\").size().to_numpy()\n107:     test_groups = df[test_idx].groupby(\"Year\").size().to_numpy()\n108: \n109:     # Model\n110:     model = XGBRanker(\n111:         objective=\"rank:pairwise\",\n112:         learning_rate=0.1,\n113:         n_estimators=100,\n114:         max_depth=4,\n115:         random_state=42,\n116:     )\n117: \n118:     print(\"Training XGBoostRanker...\")\n119:     model.fit(X_train, y_train, group=train_groups)\n120: \n121:     # Predict, sort, and evaluate\n122:     y_pred = model.predict(X_test)\n123:     df.loc[test_idx, \"PredictedScore\"] = y_pred\n124:     df.loc[test_idx, \"PredictedRank\"] = (\n125:         df.loc[test_idx]\n126:         .groupby(\"Year\")[\"PredictedScore\"]\n127:         .rank(ascending=False, method=\"first\")\n128:     )\n129: \n130:     ndcg = evaluate_ndcg(y_test.to_numpy(), y_pred, test_groups)\n131:     print(f\"NDCG Score on test years {test_years.tolist()}: {ndcg:.4f}\")\n132: \n133:     # Show results\n134:     print(df[test_idx][[\"Year\", \"Name\", \"Rank\", \"PredictedScore\", \"PredictedRank\"]])\n135:     plot_ranking_predictions(df, 2024)\n136:     plot_ranking_predictions(df, 2025)\n137: \n138: \n139: if __name__ == \"__main__\":\n140:     main()\n141: "
        },
        "timestamp": "2025-08-16 22:58:49.000",
        "id": "ROSnOozRLg5tcxx9Lad2"
    },
    {
        "source": "backend",
        "event": "map_summary_code",
        "data": {
            "summary": "• Loads and processes basketball data\n• Trains and evaluates an XGBoost ranking model\n• Plots and displays ranking prediction results",
            "mapping": [
                {
                    "summaryComponent": "Loads and processes basketball data",
                    "codeSegments": [
                        {
                            "line": 9,
                            "code": "def load_data(path=\"data/merged_data.csv\"):"
                        },
                        {
                            "line": 10,
                            "code": "df = pd.read_csv(path)"
                        },
                        {
                            "line": 13,
                            "code": "feature_cols = ["
                        },
                        {
                            "line": 28,
                            "code": "df = df.dropna(subset=feature_cols + [\"Rank\"])"
                        },
                        {
                            "line": 31,
                            "code": "df = df.sort_values(by=[\"Year\", \"Rank\"])"
                        }
                    ]
                },
                {
                    "summaryComponent": "Trains and evaluates an XGBoost ranking model",
                    "codeSegments": [
                        {
                            "line": 110,
                            "code": "model = XGBRanker("
                        },
                        {
                            "line": 119,
                            "code": "model.fit(X_train, y_train, group=train_groups)"
                        },
                        {
                            "line": 122,
                            "code": "y_pred = model.predict(X_test)"
                        },
                        {
                            "line": 130,
                            "code": "ndcg = evaluate_ndcg(y_test.to_numpy(), y_pred, test_groups)"
                        }
                    ]
                },
                {
                    "summaryComponent": "Plots and displays ranking prediction results",
                    "codeSegments": [
                        {
                            "line": 135,
                            "code": "plot_ranking_predictions(df, 2024)"
                        },
                        {
                            "line": 136,
                            "code": "plot_ranking_predictions(df, 2025)"
                        },
                        {
                            "line": 134,
                            "code": "print(df[test_idx][[\"Year\", \"Name\", \"Rank\", \"PredictedScore\", \"PredictedRank\"]])"
                        }
                    ]
                }
            ],
            "code": "9: def load_data(path=\"data/merged_data.csv\"):\n10:     df = pd.read_csv(path)\n11: \n12:     # Features to use\n13:     feature_cols = [\n14:         \"PTS\",\n15:         \"AST\",\n16:         \"TRB\",\n17:         \"FG%\",\n18:         \"BPM\",\n19:         \"WS/48\",\n20:         \"TS%\",\n21:         \"VORP\",\n22:         \"WS\",\n23:         \"PER\",\n24:     ]\n25:     feature_cols = [\n26:         col for col in feature_cols if col in df.columns\n27:     ]  # only keep existing features\n28:     df = df.dropna(subset=feature_cols + [\"Rank\"])\n29: \n30:     # Sort by Year and Rank for consistency\n31:     df = df.sort_values(by=[\"Year\", \"Rank\"])\n32: \n33:     X = df[feature_cols]\n34:     y = df[\"Rank\"]\n35:     groups = df.groupby(\"Year\").size().to_numpy()\n36: \n37:     return X, y, groups, df\n38: \n39: \n40: def evaluate_ndcg(y_true, y_pred, group_sizes):\n41:     scores = []\n42:     start = 0\n43:     for size in group_sizes:\n44:         true_ranks = y_true[start : start + size]\n45:         true_relevance = (max(true_ranks) + 1) - true_ranks\n46:         pred_scores = y_pred[start : start + size]\n47:         scores.append(ndcg_score([true_relevance], [pred_scores]))\n48:         start += size\n49:     return np.mean(scores)\n50: \n51: \n52: def xgboost_ranker(X, y, groups):\n53:     model = XGBRanker(\n54:         objective=\"rank:pairwise\",\n55:         learning_rate=0.1,\n56:         n_estimators=100,\n57:         max_depth=6,\n58:         random_state=42,\n59:     )\n60: \n61:     print(\"Training XGBoostRanker...\")\n62:     model.fit(X, y, group=groups)\n63: \n64:     return model\n65: \n66: \n67: def plot_ranking_predictions(df, year):\n68:     \"\"\"\n69:     Plot prediction error for a specific year.\n70: \n71:     Args:\n72:         df: DataFrame containing prediction results\n73:         year: Year to plot prediction errors for\n74:     \"\"\"\n75:     df[\"RankError\"] = df[\"PredictedRank\"] - df[\"Rank\"]\n76:     year_df = df[df[\"Year\"] == year].copy()\n77:     year_df.sort_values(\"Rank\", inplace=True)\n78: \n79:     plt.figure(figsize=(12, 6))\n80:     sns.barplot(x=\"Name\", y=\"RankError\", data=year_df, hue=\"Name\", palette=\"coolwarm\")\n81:     plt.axhline(0, color=\"black\", linestyle=\"--\")\n82:     plt.xticks(rotation=45, ha=\"right\")\n83:     plt.ylabel(\"Predicted Rank - True Rank\")\n84:     plt.title(f\"MVP Ranking Predictions ({year})\")\n85:     plt.tight_layout()\n86:     plt.savefig(f\"data/ranking_predictions_{year}.png\")\n87: \n88: \n89: def main():\n90:     X, y, group, df = load_data()\n91: \n92:     # Train-test split on years\n93:     unique_years = df[\"Year\"].unique()\n94:     train_years, test_years = (\n95:         unique_years[:-2],  # train: 2015-2023\n96:         unique_years[-2:],  # test: 2024-2025\n97:     )\n98: \n99:     train_idx = df[\"Year\"].isin(train_years)\n100:     test_idx = df[\"Year\"].isin(test_years)\n101: \n102:     X_train, X_test = X[train_idx], X[test_idx]\n103:     y_train, y_test = y[train_idx], y[test_idx]\n104: \n105:     # Group sizes\n106:     train_groups = df[train_idx].groupby(\"Year\").size().to_numpy()\n107:     test_groups = df[test_idx].groupby(\"Year\").size().to_numpy()\n108: \n109:     # Model\n110:     model = XGBRanker(\n111:         objective=\"rank:pairwise\",\n112:         learning_rate=0.1,\n113:         n_estimators=100,\n114:         max_depth=4,\n115:         random_state=42,\n116:     )\n117: \n118:     print(\"Training XGBoostRanker...\")\n119:     model.fit(X_train, y_train, group=train_groups)\n120: \n121:     # Predict, sort, and evaluate\n122:     y_pred = model.predict(X_test)\n123:     df.loc[test_idx, \"PredictedScore\"] = y_pred\n124:     df.loc[test_idx, \"PredictedRank\"] = (\n125:         df.loc[test_idx]\n126:         .groupby(\"Year\")[\"PredictedScore\"]\n127:         .rank(ascending=False, method=\"first\")\n128:     )\n129: \n130:     ndcg = evaluate_ndcg(y_test.to_numpy(), y_pred, test_groups)\n131:     print(f\"NDCG Score on test years {test_years.tolist()}: {ndcg:.4f}\")\n132: \n133:     # Show results\n134:     print(df[test_idx][[\"Year\", \"Name\", \"Rank\", \"PredictedScore\", \"PredictedRank\"]])\n135:     plot_ranking_predictions(df, 2024)\n136:     plot_ranking_predictions(df, 2025)\n137: \n138: \n139: if __name__ == \"__main__\":\n140:     main()\n141: "
        },
        "timestamp": "2025-08-16 22:58:49.000",
        "id": "XFD1gdW1haBn9YxNW4Bj"
    },
    {
        "source": "backend",
        "event": "map_summary_code",
        "data": {
            "summary": "• Loads and cleans basketball player statistics data\n• Provides an NDCG-based evaluation for ranking predictions\n• Trains an XGBoost ranker on grouped data\n• Plots prediction errors for selected years\n• Main function manages data splitting, model training, prediction, evaluation, and visualization",
            "mapping": [
                {
                    "summaryComponent": "Loads and cleans basketball player statistics data",
                    "codeSegments": [
                        {
                            "line": 9,
                            "code": "def load_data(path=\"data/merged_data.csv\"):"
                        },
                        {
                            "line": 10,
                            "code": "df = pd.read_csv(path)"
                        },
                        {
                            "line": 13,
                            "code": "feature_cols = ["
                        },
                        {
                            "line": 25,
                            "code": "feature_cols = [\n    col for col in feature_cols if col in df.columns\n]  # only keep existing features"
                        },
                        {
                            "line": 28,
                            "code": "df = df.dropna(subset=feature_cols + [\"Rank\"])"
                        }
                    ]
                },
                {
                    "summaryComponent": "Provides an NDCG-based evaluation for ranking predictions",
                    "codeSegments": [
                        {
                            "line": 40,
                            "code": "def evaluate_ndcg(y_true, y_pred, group_sizes):"
                        },
                        {
                            "line": 47,
                            "code": "scores.append(ndcg_score([true_relevance], [pred_scores]))"
                        }
                    ]
                },
                {
                    "summaryComponent": "Trains an XGBoost ranker on grouped data",
                    "codeSegments": [
                        {
                            "line": 52,
                            "code": "def xgboost_ranker(X, y, groups):"
                        },
                        {
                            "line": 53,
                            "code": "model = XGBRanker("
                        },
                        {
                            "line": 62,
                            "code": "model.fit(X, y, group=groups)"
                        }
                    ]
                },
                {
                    "summaryComponent": "Plots prediction errors for selected years",
                    "codeSegments": [
                        {
                            "line": 67,
                            "code": "def plot_ranking_predictions(df, year):"
                        },
                        {
                            "line": 75,
                            "code": "df[\"RankError\"] = df[\"PredictedRank\"] - df[\"Rank\"]"
                        }
                    ]
                },
                {
                    "summaryComponent": "Main function manages data splitting, model training, prediction, evaluation, and visualization",
                    "codeSegments": [
                        {
                            "line": 89,
                            "code": "def main():"
                        },
                        {
                            "line": 90,
                            "code": "X, y, group, df = load_data()"
                        },
                        {
                            "line": 99,
                            "code": "train_idx = df[\"Year\"].isin(train_years)"
                        },
                        {
                            "line": 100,
                            "code": "test_idx = df[\"Year\"].isin(test_years)"
                        },
                        {
                            "line": 119,
                            "code": "model.fit(X_train, y_train, group=train_groups)"
                        },
                        {
                            "line": 122,
                            "code": "y_pred = model.predict(X_test)"
                        },
                        {
                            "line": 130,
                            "code": "ndcg = evaluate_ndcg(y_test.to_numpy(), y_pred, test_groups)"
                        },
                        {
                            "line": 135,
                            "code": "plot_ranking_predictions(df, 2024)"
                        },
                        {
                            "line": 136,
                            "code": "plot_ranking_predictions(df, 2025)"
                        }
                    ]
                }
            ],
            "code": "9: def load_data(path=\"data/merged_data.csv\"):\n10:     df = pd.read_csv(path)\n11: \n12:     # Features to use\n13:     feature_cols = [\n14:         \"PTS\",\n15:         \"AST\",\n16:         \"TRB\",\n17:         \"FG%\",\n18:         \"BPM\",\n19:         \"WS/48\",\n20:         \"TS%\",\n21:         \"VORP\",\n22:         \"WS\",\n23:         \"PER\",\n24:     ]\n25:     feature_cols = [\n26:         col for col in feature_cols if col in df.columns\n27:     ]  # only keep existing features\n28:     df = df.dropna(subset=feature_cols + [\"Rank\"])\n29: \n30:     # Sort by Year and Rank for consistency\n31:     df = df.sort_values(by=[\"Year\", \"Rank\"])\n32: \n33:     X = df[feature_cols]\n34:     y = df[\"Rank\"]\n35:     groups = df.groupby(\"Year\").size().to_numpy()\n36: \n37:     return X, y, groups, df\n38: \n39: \n40: def evaluate_ndcg(y_true, y_pred, group_sizes):\n41:     scores = []\n42:     start = 0\n43:     for size in group_sizes:\n44:         true_ranks = y_true[start : start + size]\n45:         true_relevance = (max(true_ranks) + 1) - true_ranks\n46:         pred_scores = y_pred[start : start + size]\n47:         scores.append(ndcg_score([true_relevance], [pred_scores]))\n48:         start += size\n49:     return np.mean(scores)\n50: \n51: \n52: def xgboost_ranker(X, y, groups):\n53:     model = XGBRanker(\n54:         objective=\"rank:pairwise\",\n55:         learning_rate=0.1,\n56:         n_estimators=100,\n57:         max_depth=6,\n58:         random_state=42,\n59:     )\n60: \n61:     print(\"Training XGBoostRanker...\")\n62:     model.fit(X, y, group=groups)\n63: \n64:     return model\n65: \n66: \n67: def plot_ranking_predictions(df, year):\n68:     \"\"\"\n69:     Plot prediction error for a specific year.\n70: \n71:     Args:\n72:         df: DataFrame containing prediction results\n73:         year: Year to plot prediction errors for\n74:     \"\"\"\n75:     df[\"RankError\"] = df[\"PredictedRank\"] - df[\"Rank\"]\n76:     year_df = df[df[\"Year\"] == year].copy()\n77:     year_df.sort_values(\"Rank\", inplace=True)\n78: \n79:     plt.figure(figsize=(12, 6))\n80:     sns.barplot(x=\"Name\", y=\"RankError\", data=year_df, hue=\"Name\", palette=\"coolwarm\")\n81:     plt.axhline(0, color=\"black\", linestyle=\"--\")\n82:     plt.xticks(rotation=45, ha=\"right\")\n83:     plt.ylabel(\"Predicted Rank - True Rank\")\n84:     plt.title(f\"MVP Ranking Predictions ({year})\")\n85:     plt.tight_layout()\n86:     plt.savefig(f\"data/ranking_predictions_{year}.png\")\n87: \n88: \n89: def main():\n90:     X, y, group, df = load_data()\n91: \n92:     # Train-test split on years\n93:     unique_years = df[\"Year\"].unique()\n94:     train_years, test_years = (\n95:         unique_years[:-2],  # train: 2015-2023\n96:         unique_years[-2:],  # test: 2024-2025\n97:     )\n98: \n99:     train_idx = df[\"Year\"].isin(train_years)\n100:     test_idx = df[\"Year\"].isin(test_years)\n101: \n102:     X_train, X_test = X[train_idx], X[test_idx]\n103:     y_train, y_test = y[train_idx], y[test_idx]\n104: \n105:     # Group sizes\n106:     train_groups = df[train_idx].groupby(\"Year\").size().to_numpy()\n107:     test_groups = df[test_idx].groupby(\"Year\").size().to_numpy()\n108: \n109:     # Model\n110:     model = XGBRanker(\n111:         objective=\"rank:pairwise\",\n112:         learning_rate=0.1,\n113:         n_estimators=100,\n114:         max_depth=4,\n115:         random_state=42,\n116:     )\n117: \n118:     print(\"Training XGBoostRanker...\")\n119:     model.fit(X_train, y_train, group=train_groups)\n120: \n121:     # Predict, sort, and evaluate\n122:     y_pred = model.predict(X_test)\n123:     df.loc[test_idx, \"PredictedScore\"] = y_pred\n124:     df.loc[test_idx, \"PredictedRank\"] = (\n125:         df.loc[test_idx]\n126:         .groupby(\"Year\")[\"PredictedScore\"]\n127:         .rank(ascending=False, method=\"first\")\n128:     )\n129: \n130:     ndcg = evaluate_ndcg(y_test.to_numpy(), y_pred, test_groups)\n131:     print(f\"NDCG Score on test years {test_years.tolist()}: {ndcg:.4f}\")\n132: \n133:     # Show results\n134:     print(df[test_idx][[\"Year\", \"Name\", \"Rank\", \"PredictedScore\", \"PredictedRank\"]])\n135:     plot_ranking_predictions(df, 2024)\n136:     plot_ranking_predictions(df, 2025)\n137: \n138: \n139: if __name__ == \"__main__\":\n140:     main()\n141: "
        },
        "timestamp": "2025-08-16 22:58:51.000",
        "id": "7yV0KkbgrfysKtjx9xdx"
    },
    {
        "source": "backend",
        "event": "map_summary_code",
        "data": {
            "summary": "This code snippet includes several functions for a basketball MVP ranking pipeline. The load_data function reads a CSV, selects relevant statistical features, removes rows with missing data, sorts by year and rank, and prepares feature matrices and group labels. The evaluate_ndcg function computes the mean NDCG score for grouped ranking predictions, while xgboost_ranker initializes and fits an XGBoost ranker using pairwise ranking loss. The plot_ranking_predictions function visualizes the difference between predicted and true ranks for a given year using a bar plot. The main function ties everything together: it loads and splits the data by year, trains the model, predicts and ranks players, evaluates with NDCG, prints results, and generates plots for recent years.",
            "mapping": [
                {
                    "summaryComponent": "several functions for a basketball MVP ranking pipeline",
                    "codeSegments": [
                        {
                            "line": 9,
                            "code": "def load_data(path=\"data/merged_data.csv\"):"
                        },
                        {
                            "line": 40,
                            "code": "def evaluate_ndcg(y_true, y_pred, group_sizes):"
                        },
                        {
                            "line": 52,
                            "code": "def xgboost_ranker(X, y, groups):"
                        },
                        {
                            "line": 67,
                            "code": "def plot_ranking_predictions(df, year):"
                        },
                        {
                            "line": 89,
                            "code": "def main():"
                        }
                    ]
                },
                {
                    "summaryComponent": "The load_data function reads a CSV",
                    "codeSegments": [
                        {
                            "line": 9,
                            "code": "def load_data(path=\"data/merged_data.csv\"):"
                        },
                        {
                            "line": 10,
                            "code": "df = pd.read_csv(path)"
                        }
                    ]
                },
                {
                    "summaryComponent": "selects relevant statistical features",
                    "codeSegments": [
                        {
                            "line": 13,
                            "code": "feature_cols = ["
                        },
                        {
                            "line": 26,
                            "code": "col for col in feature_cols if col in df.columns"
                        }
                    ]
                },
                {
                    "summaryComponent": "removes rows with missing data",
                    "codeSegments": [
                        {
                            "line": 28,
                            "code": "df = df.dropna(subset=feature_cols + [\"Rank\"])"
                        }
                    ]
                },
                {
                    "summaryComponent": "sorts by year and rank",
                    "codeSegments": [
                        {
                            "line": 31,
                            "code": "df = df.sort_values(by=[\"Year\", \"Rank\"])"
                        }
                    ]
                },
                {
                    "summaryComponent": "prepares feature matrices and group labels",
                    "codeSegments": [
                        {
                            "line": 33,
                            "code": "X = df[feature_cols]"
                        },
                        {
                            "line": 34,
                            "code": "y = df[\"Rank\"]"
                        },
                        {
                            "line": 35,
                            "code": "groups = df.groupby(\"Year\").size().to_numpy()"
                        }
                    ]
                },
                {
                    "summaryComponent": "The evaluate_ndcg function computes the mean NDCG score for grouped ranking predictions",
                    "codeSegments": [
                        {
                            "line": 40,
                            "code": "def evaluate_ndcg(y_true, y_pred, group_sizes):"
                        },
                        {
                            "line": 49,
                            "code": "return np.mean(scores)"
                        }
                    ]
                },
                {
                    "summaryComponent": "xgboost_ranker initializes and fits an XGBoost ranker using pairwise ranking loss",
                    "codeSegments": [
                        {
                            "line": 52,
                            "code": "def xgboost_ranker(X, y, groups):"
                        },
                        {
                            "line": 53,
                            "code": "model = XGBRanker("
                        },
                        {
                            "line": 54,
                            "code": "objective=\"rank:pairwise\","
                        },
                        {
                            "line": 62,
                            "code": "model.fit(X, y, group=groups)"
                        }
                    ]
                },
                {
                    "summaryComponent": "The plot_ranking_predictions function visualizes the difference between predicted and true ranks for a given year using a bar plot",
                    "codeSegments": [
                        {
                            "line": 67,
                            "code": "def plot_ranking_predictions(df, year):"
                        },
                        {
                            "line": 75,
                            "code": "df[\"RankError\"] = df[\"PredictedRank\"] - df[\"Rank\"]"
                        },
                        {
                            "line": 80,
                            "code": "sns.barplot(x=\"Name\", y=\"RankError\", data=year_df, hue=\"Name\", palette=\"coolwarm\")"
                        }
                    ]
                },
                {
                    "summaryComponent": "The main function ties everything together: it loads and splits the data by year, trains the model, predicts and ranks players, evaluates with NDCG, prints results, and generates plots for recent years.",
                    "codeSegments": [
                        {
                            "line": 89,
                            "code": "def main():"
                        },
                        {
                            "line": 90,
                            "code": "X, y, group, df = load_data()"
                        },
                        {
                            "line": 94,
                            "code": "train_years, test_years = ("
                        },
                        {
                            "line": 119,
                            "code": "model.fit(X_train, y_train, group=train_groups)"
                        },
                        {
                            "line": 122,
                            "code": "y_pred = model.predict(X_test)"
                        },
                        {
                            "line": 124,
                            "code": "df.loc[test_idx, \"PredictedRank\"] = ("
                        },
                        {
                            "line": 130,
                            "code": "ndcg = evaluate_ndcg(y_test.to_numpy(), y_pred, test_groups)"
                        },
                        {
                            "line": 134,
                            "code": "print(df[test_idx][[\"Year\", \"Name\", \"Rank\", \"PredictedScore\", \"PredictedRank\"]])"
                        },
                        {
                            "line": 135,
                            "code": "plot_ranking_predictions(df, 2024)"
                        },
                        {
                            "line": 136,
                            "code": "plot_ranking_predictions(df, 2025)"
                        }
                    ]
                }
            ],
            "code": "9: def load_data(path=\"data/merged_data.csv\"):\n10:     df = pd.read_csv(path)\n11: \n12:     # Features to use\n13:     feature_cols = [\n14:         \"PTS\",\n15:         \"AST\",\n16:         \"TRB\",\n17:         \"FG%\",\n18:         \"BPM\",\n19:         \"WS/48\",\n20:         \"TS%\",\n21:         \"VORP\",\n22:         \"WS\",\n23:         \"PER\",\n24:     ]\n25:     feature_cols = [\n26:         col for col in feature_cols if col in df.columns\n27:     ]  # only keep existing features\n28:     df = df.dropna(subset=feature_cols + [\"Rank\"])\n29: \n30:     # Sort by Year and Rank for consistency\n31:     df = df.sort_values(by=[\"Year\", \"Rank\"])\n32: \n33:     X = df[feature_cols]\n34:     y = df[\"Rank\"]\n35:     groups = df.groupby(\"Year\").size().to_numpy()\n36: \n37:     return X, y, groups, df\n38: \n39: \n40: def evaluate_ndcg(y_true, y_pred, group_sizes):\n41:     scores = []\n42:     start = 0\n43:     for size in group_sizes:\n44:         true_ranks = y_true[start : start + size]\n45:         true_relevance = (max(true_ranks) + 1) - true_ranks\n46:         pred_scores = y_pred[start : start + size]\n47:         scores.append(ndcg_score([true_relevance], [pred_scores]))\n48:         start += size\n49:     return np.mean(scores)\n50: \n51: \n52: def xgboost_ranker(X, y, groups):\n53:     model = XGBRanker(\n54:         objective=\"rank:pairwise\",\n55:         learning_rate=0.1,\n56:         n_estimators=100,\n57:         max_depth=6,\n58:         random_state=42,\n59:     )\n60: \n61:     print(\"Training XGBoostRanker...\")\n62:     model.fit(X, y, group=groups)\n63: \n64:     return model\n65: \n66: \n67: def plot_ranking_predictions(df, year):\n68:     \"\"\"\n69:     Plot prediction error for a specific year.\n70: \n71:     Args:\n72:         df: DataFrame containing prediction results\n73:         year: Year to plot prediction errors for\n74:     \"\"\"\n75:     df[\"RankError\"] = df[\"PredictedRank\"] - df[\"Rank\"]\n76:     year_df = df[df[\"Year\"] == year].copy()\n77:     year_df.sort_values(\"Rank\", inplace=True)\n78: \n79:     plt.figure(figsize=(12, 6))\n80:     sns.barplot(x=\"Name\", y=\"RankError\", data=year_df, hue=\"Name\", palette=\"coolwarm\")\n81:     plt.axhline(0, color=\"black\", linestyle=\"--\")\n82:     plt.xticks(rotation=45, ha=\"right\")\n83:     plt.ylabel(\"Predicted Rank - True Rank\")\n84:     plt.title(f\"MVP Ranking Predictions ({year})\")\n85:     plt.tight_layout()\n86:     plt.savefig(f\"data/ranking_predictions_{year}.png\")\n87: \n88: \n89: def main():\n90:     X, y, group, df = load_data()\n91: \n92:     # Train-test split on years\n93:     unique_years = df[\"Year\"].unique()\n94:     train_years, test_years = (\n95:         unique_years[:-2],  # train: 2015-2023\n96:         unique_years[-2:],  # test: 2024-2025\n97:     )\n98: \n99:     train_idx = df[\"Year\"].isin(train_years)\n100:     test_idx = df[\"Year\"].isin(test_years)\n101: \n102:     X_train, X_test = X[train_idx], X[test_idx]\n103:     y_train, y_test = y[train_idx], y[test_idx]\n104: \n105:     # Group sizes\n106:     train_groups = df[train_idx].groupby(\"Year\").size().to_numpy()\n107:     test_groups = df[test_idx].groupby(\"Year\").size().to_numpy()\n108: \n109:     # Model\n110:     model = XGBRanker(\n111:         objective=\"rank:pairwise\",\n112:         learning_rate=0.1,\n113:         n_estimators=100,\n114:         max_depth=4,\n115:         random_state=42,\n116:     )\n117: \n118:     print(\"Training XGBoostRanker...\")\n119:     model.fit(X_train, y_train, group=train_groups)\n120: \n121:     # Predict, sort, and evaluate\n122:     y_pred = model.predict(X_test)\n123:     df.loc[test_idx, \"PredictedScore\"] = y_pred\n124:     df.loc[test_idx, \"PredictedRank\"] = (\n125:         df.loc[test_idx]\n126:         .groupby(\"Year\")[\"PredictedScore\"]\n127:         .rank(ascending=False, method=\"first\")\n128:     )\n129: \n130:     ndcg = evaluate_ndcg(y_test.to_numpy(), y_pred, test_groups)\n131:     print(f\"NDCG Score on test years {test_years.tolist()}: {ndcg:.4f}\")\n132: \n133:     # Show results\n134:     print(df[test_idx][[\"Year\", \"Name\", \"Rank\", \"PredictedScore\", \"PredictedRank\"]])\n135:     plot_ranking_predictions(df, 2024)\n136:     plot_ranking_predictions(df, 2025)\n137: \n138: \n139: if __name__ == \"__main__\":\n140:     main()\n141: "
        },
        "timestamp": "2025-08-16 22:58:53.000",
        "id": "LiEB1XIlfrTQwEdB2ZRx"
    },
    {
        "source": "backend",
        "event": "map_summary_code",
        "data": {
            "summary": "• load_data function:\n  ◦ Reads a CSV file of basketball player stats\n  ◦ Selects a set of statistical features, filters out rows with missing data, and sorts by year and rank\n  ◦ Returns feature matrix, target ranks, group sizes per year, and the full DataFrame\n• evaluate_ndcg function:\n  ◦ Calculates mean NDCG score for ranking predictions grouped by year\n  ◦ Converts ranks to relevance scores and aggregates NDCG across groups\n• xgboost_ranker function:\n  ◦ Initializes an XGBoostRanker with pairwise ranking objective and specific hyperparameters\n  ◦ Trains the model on the provided data and groups\n• plot_ranking_predictions function:\n  ◦ Computes prediction errors (PredictedRank - True Rank) for a given year\n  ◦ Plots these errors as a bar plot, saving the figure for each year\n• main function:\n  ◦ Loads and splits data into training and test sets based on year\n  ◦ Trains the XGBoost ranker, predicts scores and ranks for test data\n  ◦ Evaluates predictions using NDCG, prints results, and generates error plots for the latest years",
            "mapping": [
                {
                    "summaryComponent": "Reads a CSV file of basketball player stats",
                    "codeSegments": [
                        {
                            "line": 10,
                            "code": "df = pd.read_csv(path)"
                        }
                    ]
                },
                {
                    "summaryComponent": "Selects a set of statistical features, filters out rows with missing data, and sorts by year and rank",
                    "codeSegments": [
                        {
                            "line": 13,
                            "code": "feature_cols = ["
                        },
                        {
                            "line": 25,
                            "code": "feature_cols = ["
                        },
                        {
                            "line": 28,
                            "code": "df = df.dropna(subset=feature_cols + [\"Rank\"])"
                        },
                        {
                            "line": 31,
                            "code": "df = df.sort_values(by=[\"Year\", \"Rank\"])"
                        }
                    ]
                },
                {
                    "summaryComponent": "Returns feature matrix, target ranks, group sizes per year, and the full DataFrame",
                    "codeSegments": [
                        {
                            "line": 37,
                            "code": "return X, y, groups, df"
                        }
                    ]
                },
                {
                    "summaryComponent": "Calculates mean NDCG score for ranking predictions grouped by year",
                    "codeSegments": [
                        {
                            "line": 40,
                            "code": "def evaluate_ndcg(y_true, y_pred, group_sizes):"
                        },
                        {
                            "line": 49,
                            "code": "return np.mean(scores)"
                        }
                    ]
                },
                {
                    "summaryComponent": "Converts ranks to relevance scores and aggregates NDCG across groups",
                    "codeSegments": [
                        {
                            "line": 45,
                            "code": "true_relevance = (max(true_ranks) + 1) - true_ranks"
                        },
                        {
                            "line": 47,
                            "code": "scores.append(ndcg_score([true_relevance], [pred_scores]))"
                        }
                    ]
                },
                {
                    "summaryComponent": "Initializes an XGBoostRanker with pairwise ranking objective and specific hyperparameters",
                    "codeSegments": [
                        {
                            "line": 53,
                            "code": "model = XGBRanker("
                        },
                        {
                            "line": 54,
                            "code": "objective=\"rank:pairwise\","
                        },
                        {
                            "line": 55,
                            "code": "learning_rate=0.1,"
                        },
                        {
                            "line": 56,
                            "code": "n_estimators=100,"
                        },
                        {
                            "line": 57,
                            "code": "max_depth=6,"
                        },
                        {
                            "line": 58,
                            "code": "random_state=42,"
                        }
                    ]
                },
                {
                    "summaryComponent": "Trains the model on the provided data and groups",
                    "codeSegments": [
                        {
                            "line": 62,
                            "code": "model.fit(X, y, group=groups)"
                        }
                    ]
                },
                {
                    "summaryComponent": "Computes prediction errors (PredictedRank - True Rank) for a given year",
                    "codeSegments": [
                        {
                            "line": 75,
                            "code": "df[\"RankError\"] = df[\"PredictedRank\"] - df[\"Rank\"]"
                        }
                    ]
                },
                {
                    "summaryComponent": "Plots these errors as a bar plot, saving the figure for each year",
                    "codeSegments": [
                        {
                            "line": 80,
                            "code": "sns.barplot(x=\"Name\", y=\"RankError\", data=year_df, hue=\"Name\", palette=\"coolwarm\")"
                        },
                        {
                            "line": 86,
                            "code": "plt.savefig(f\"data/ranking_predictions_{year}.png\")"
                        }
                    ]
                },
                {
                    "summaryComponent": "Loads and splits data into training and test sets based on year",
                    "codeSegments": [
                        {
                            "line": 90,
                            "code": "X, y, group, df = load_data()"
                        },
                        {
                            "line": 93,
                            "code": "unique_years = df[\"Year\"].unique()"
                        },
                        {
                            "line": 94,
                            "code": "train_years, test_years = ("
                        },
                        {
                            "line": 99,
                            "code": "train_idx = df[\"Year\"].isin(train_years)"
                        },
                        {
                            "line": 100,
                            "code": "test_idx = df[\"Year\"].isin(test_years)"
                        },
                        {
                            "line": 102,
                            "code": "X_train, X_test = X[train_idx], X[test_idx]"
                        },
                        {
                            "line": 103,
                            "code": "y_train, y_test = y[train_idx], y[test_idx]"
                        }
                    ]
                }
            ],
            "code": "9: def load_data(path=\"data/merged_data.csv\"):\n10:     df = pd.read_csv(path)\n11: \n12:     # Features to use\n13:     feature_cols = [\n14:         \"PTS\",\n15:         \"AST\",\n16:         \"TRB\",\n17:         \"FG%\",\n18:         \"BPM\",\n19:         \"WS/48\",\n20:         \"TS%\",\n21:         \"VORP\",\n22:         \"WS\",\n23:         \"PER\",\n24:     ]\n25:     feature_cols = [\n26:         col for col in feature_cols if col in df.columns\n27:     ]  # only keep existing features\n28:     df = df.dropna(subset=feature_cols + [\"Rank\"])\n29: \n30:     # Sort by Year and Rank for consistency\n31:     df = df.sort_values(by=[\"Year\", \"Rank\"])\n32: \n33:     X = df[feature_cols]\n34:     y = df[\"Rank\"]\n35:     groups = df.groupby(\"Year\").size().to_numpy()\n36: \n37:     return X, y, groups, df\n38: \n39: \n40: def evaluate_ndcg(y_true, y_pred, group_sizes):\n41:     scores = []\n42:     start = 0\n43:     for size in group_sizes:\n44:         true_ranks = y_true[start : start + size]\n45:         true_relevance = (max(true_ranks) + 1) - true_ranks\n46:         pred_scores = y_pred[start : start + size]\n47:         scores.append(ndcg_score([true_relevance], [pred_scores]))\n48:         start += size\n49:     return np.mean(scores)\n50: \n51: \n52: def xgboost_ranker(X, y, groups):\n53:     model = XGBRanker(\n54:         objective=\"rank:pairwise\",\n55:         learning_rate=0.1,\n56:         n_estimators=100,\n57:         max_depth=6,\n58:         random_state=42,\n59:     )\n60: \n61:     print(\"Training XGBoostRanker...\")\n62:     model.fit(X, y, group=groups)\n63: \n64:     return model\n65: \n66: \n67: def plot_ranking_predictions(df, year):\n68:     \"\"\"\n69:     Plot prediction error for a specific year.\n70: \n71:     Args:\n72:         df: DataFrame containing prediction results\n73:         year: Year to plot prediction errors for\n74:     \"\"\"\n75:     df[\"RankError\"] = df[\"PredictedRank\"] - df[\"Rank\"]\n76:     year_df = df[df[\"Year\"] == year].copy()\n77:     year_df.sort_values(\"Rank\", inplace=True)\n78: \n79:     plt.figure(figsize=(12, 6))\n80:     sns.barplot(x=\"Name\", y=\"RankError\", data=year_df, hue=\"Name\", palette=\"coolwarm\")\n81:     plt.axhline(0, color=\"black\", linestyle=\"--\")\n82:     plt.xticks(rotation=45, ha=\"right\")\n83:     plt.ylabel(\"Predicted Rank - True Rank\")\n84:     plt.title(f\"MVP Ranking Predictions ({year})\")\n85:     plt.tight_layout()\n86:     plt.savefig(f\"data/ranking_predictions_{year}.png\")\n87: \n88: \n89: def main():\n90:     X, y, group, df = load_data()\n91: \n92:     # Train-test split on years\n93:     unique_years = df[\"Year\"].unique()\n94:     train_years, test_years = (\n95:         unique_years[:-2],  # train: 2015-2023\n96:         unique_years[-2:],  # test: 2024-2025\n97:     )\n98: \n99:     train_idx = df[\"Year\"].isin(train_years)\n100:     test_idx = df[\"Year\"].isin(test_years)\n101: \n102:     X_train, X_test = X[train_idx], X[test_idx]\n103:     y_train, y_test = y[train_idx], y[test_idx]\n104: \n105:     # Group sizes\n106:     train_groups = df[train_idx].groupby(\"Year\").size().to_numpy()\n107:     test_groups = df[test_idx].groupby(\"Year\").size().to_numpy()\n108: \n109:     # Model\n110:     model = XGBRanker(\n111:         objective=\"rank:pairwise\",\n112:         learning_rate=0.1,\n113:         n_estimators=100,\n114:         max_depth=4,\n115:         random_state=42,\n116:     )\n117: \n118:     print(\"Training XGBoostRanker...\")\n119:     model.fit(X_train, y_train, group=train_groups)\n120: \n121:     # Predict, sort, and evaluate\n122:     y_pred = model.predict(X_test)\n123:     df.loc[test_idx, \"PredictedScore\"] = y_pred\n124:     df.loc[test_idx, \"PredictedRank\"] = (\n125:         df.loc[test_idx]\n126:         .groupby(\"Year\")[\"PredictedScore\"]\n127:         .rank(ascending=False, method=\"first\")\n128:     )\n129: \n130:     ndcg = evaluate_ndcg(y_test.to_numpy(), y_pred, test_groups)\n131:     print(f\"NDCG Score on test years {test_years.tolist()}: {ndcg:.4f}\")\n132: \n133:     # Show results\n134:     print(df[test_idx][[\"Year\", \"Name\", \"Rank\", \"PredictedScore\", \"PredictedRank\"]])\n135:     plot_ranking_predictions(df, 2024)\n136:     plot_ranking_predictions(df, 2025)\n137: \n138: \n139: if __name__ == \"__main__\":\n140:     main()\n141: "
        },
        "timestamp": "2025-08-16 22:58:53.000",
        "id": "ZgbYIyWHV4TcO1b6pByb"
    },
    {
        "source": "backend",
        "event": "map_summary_code",
        "data": {
            "summary": "The code defines functions to load and preprocess basketball player data, evaluate ranking predictions using NDCG, train an XGBoost ranking model, and visualize prediction errors for specific years. The main function orchestrates the workflow, including splitting data by year, training the model, making predictions, evaluating performance, and plotting results. This setup enables automated model training and evaluation for MVP ranking predictions.",
            "mapping": [
                {
                    "summaryComponent": "load and preprocess basketball player data",
                    "codeSegments": [
                        {
                            "line": 9,
                            "code": "def load_data(path=\"data/merged_data.csv\"):"
                        },
                        {
                            "line": 10,
                            "code": "df = pd.read_csv(path)"
                        },
                        {
                            "line": 13,
                            "code": "feature_cols = ["
                        },
                        {
                            "line": 28,
                            "code": "df = df.dropna(subset=feature_cols + [\"Rank\"])"
                        },
                        {
                            "line": 31,
                            "code": "df = df.sort_values(by=[\"Year\", \"Rank\"])"
                        }
                    ]
                },
                {
                    "summaryComponent": "evaluate ranking predictions using NDCG",
                    "codeSegments": [
                        {
                            "line": 40,
                            "code": "def evaluate_ndcg(y_true, y_pred, group_sizes):"
                        },
                        {
                            "line": 47,
                            "code": "scores.append(ndcg_score([true_relevance], [pred_scores]))"
                        }
                    ]
                },
                {
                    "summaryComponent": "train an XGBoost ranking model",
                    "codeSegments": [
                        {
                            "line": 52,
                            "code": "def xgboost_ranker(X, y, groups):"
                        },
                        {
                            "line": 53,
                            "code": "model = XGBRanker("
                        },
                        {
                            "line": 62,
                            "code": "model.fit(X, y, group=groups)"
                        }
                    ]
                },
                {
                    "summaryComponent": "visualize prediction errors for specific years",
                    "codeSegments": [
                        {
                            "line": 67,
                            "code": "def plot_ranking_predictions(df, year):"
                        },
                        {
                            "line": 75,
                            "code": "df[\"RankError\"] = df[\"PredictedRank\"] - df[\"Rank\"]"
                        },
                        {
                            "line": 80,
                            "code": "sns.barplot(x=\"Name\", y=\"RankError\", data=year_df, hue=\"Name\", palette=\"coolwarm\")"
                        }
                    ]
                },
                {
                    "summaryComponent": "main function orchestrates the workflow",
                    "codeSegments": [
                        {
                            "line": 89,
                            "code": "def main():"
                        }
                    ]
                },
                {
                    "summaryComponent": "splitting data by year",
                    "codeSegments": [
                        {
                            "line": 93,
                            "code": "unique_years = df[\"Year\"].unique()"
                        },
                        {
                            "line": 94,
                            "code": "train_years, test_years = ("
                        },
                        {
                            "line": 99,
                            "code": "train_idx = df[\"Year\"].isin(train_years)"
                        },
                        {
                            "line": 100,
                            "code": "test_idx = df[\"Year\"].isin(test_years)"
                        }
                    ]
                },
                {
                    "summaryComponent": "training the model",
                    "codeSegments": [
                        {
                            "line": 119,
                            "code": "model.fit(X_train, y_train, group=train_groups)"
                        }
                    ]
                },
                {
                    "summaryComponent": "making predictions",
                    "codeSegments": [
                        {
                            "line": 122,
                            "code": "y_pred = model.predict(X_test)"
                        }
                    ]
                },
                {
                    "summaryComponent": "evaluating performance",
                    "codeSegments": [
                        {
                            "line": 130,
                            "code": "ndcg = evaluate_ndcg(y_test.to_numpy(), y_pred, test_groups)"
                        },
                        {
                            "line": 131,
                            "code": "print(f\"NDCG Score on test years {test_years.tolist()}: {ndcg:.4f}\")"
                        }
                    ]
                },
                {
                    "summaryComponent": "plotting results",
                    "codeSegments": [
                        {
                            "line": 135,
                            "code": "plot_ranking_predictions(df, 2024)"
                        },
                        {
                            "line": 136,
                            "code": "plot_ranking_predictions(df, 2025)"
                        }
                    ]
                }
            ],
            "code": "9: def load_data(path=\"data/merged_data.csv\"):\n10:     df = pd.read_csv(path)\n11: \n12:     # Features to use\n13:     feature_cols = [\n14:         \"PTS\",\n15:         \"AST\",\n16:         \"TRB\",\n17:         \"FG%\",\n18:         \"BPM\",\n19:         \"WS/48\",\n20:         \"TS%\",\n21:         \"VORP\",\n22:         \"WS\",\n23:         \"PER\",\n24:     ]\n25:     feature_cols = [\n26:         col for col in feature_cols if col in df.columns\n27:     ]  # only keep existing features\n28:     df = df.dropna(subset=feature_cols + [\"Rank\"])\n29: \n30:     # Sort by Year and Rank for consistency\n31:     df = df.sort_values(by=[\"Year\", \"Rank\"])\n32: \n33:     X = df[feature_cols]\n34:     y = df[\"Rank\"]\n35:     groups = df.groupby(\"Year\").size().to_numpy()\n36: \n37:     return X, y, groups, df\n38: \n39: \n40: def evaluate_ndcg(y_true, y_pred, group_sizes):\n41:     scores = []\n42:     start = 0\n43:     for size in group_sizes:\n44:         true_ranks = y_true[start : start + size]\n45:         true_relevance = (max(true_ranks) + 1) - true_ranks\n46:         pred_scores = y_pred[start : start + size]\n47:         scores.append(ndcg_score([true_relevance], [pred_scores]))\n48:         start += size\n49:     return np.mean(scores)\n50: \n51: \n52: def xgboost_ranker(X, y, groups):\n53:     model = XGBRanker(\n54:         objective=\"rank:pairwise\",\n55:         learning_rate=0.1,\n56:         n_estimators=100,\n57:         max_depth=6,\n58:         random_state=42,\n59:     )\n60: \n61:     print(\"Training XGBoostRanker...\")\n62:     model.fit(X, y, group=groups)\n63: \n64:     return model\n65: \n66: \n67: def plot_ranking_predictions(df, year):\n68:     \"\"\"\n69:     Plot prediction error for a specific year.\n70: \n71:     Args:\n72:         df: DataFrame containing prediction results\n73:         year: Year to plot prediction errors for\n74:     \"\"\"\n75:     df[\"RankError\"] = df[\"PredictedRank\"] - df[\"Rank\"]\n76:     year_df = df[df[\"Year\"] == year].copy()\n77:     year_df.sort_values(\"Rank\", inplace=True)\n78: \n79:     plt.figure(figsize=(12, 6))\n80:     sns.barplot(x=\"Name\", y=\"RankError\", data=year_df, hue=\"Name\", palette=\"coolwarm\")\n81:     plt.axhline(0, color=\"black\", linestyle=\"--\")\n82:     plt.xticks(rotation=45, ha=\"right\")\n83:     plt.ylabel(\"Predicted Rank - True Rank\")\n84:     plt.title(f\"MVP Ranking Predictions ({year})\")\n85:     plt.tight_layout()\n86:     plt.savefig(f\"data/ranking_predictions_{year}.png\")\n87: \n88: \n89: def main():\n90:     X, y, group, df = load_data()\n91: \n92:     # Train-test split on years\n93:     unique_years = df[\"Year\"].unique()\n94:     train_years, test_years = (\n95:         unique_years[:-2],  # train: 2015-2023\n96:         unique_years[-2:],  # test: 2024-2025\n97:     )\n98: \n99:     train_idx = df[\"Year\"].isin(train_years)\n100:     test_idx = df[\"Year\"].isin(test_years)\n101: \n102:     X_train, X_test = X[train_idx], X[test_idx]\n103:     y_train, y_test = y[train_idx], y[test_idx]\n104: \n105:     # Group sizes\n106:     train_groups = df[train_idx].groupby(\"Year\").size().to_numpy()\n107:     test_groups = df[test_idx].groupby(\"Year\").size().to_numpy()\n108: \n109:     # Model\n110:     model = XGBRanker(\n111:         objective=\"rank:pairwise\",\n112:         learning_rate=0.1,\n113:         n_estimators=100,\n114:         max_depth=4,\n115:         random_state=42,\n116:     )\n117: \n118:     print(\"Training XGBoostRanker...\")\n119:     model.fit(X_train, y_train, group=train_groups)\n120: \n121:     # Predict, sort, and evaluate\n122:     y_pred = model.predict(X_test)\n123:     df.loc[test_idx, \"PredictedScore\"] = y_pred\n124:     df.loc[test_idx, \"PredictedRank\"] = (\n125:         df.loc[test_idx]\n126:         .groupby(\"Year\")[\"PredictedScore\"]\n127:         .rank(ascending=False, method=\"first\")\n128:     )\n129: \n130:     ndcg = evaluate_ndcg(y_test.to_numpy(), y_pred, test_groups)\n131:     print(f\"NDCG Score on test years {test_years.tolist()}: {ndcg:.4f}\")\n132: \n133:     # Show results\n134:     print(df[test_idx][[\"Year\", \"Name\", \"Rank\", \"PredictedScore\", \"PredictedRank\"]])\n135:     plot_ranking_predictions(df, 2024)\n136:     plot_ranking_predictions(df, 2025)\n137: \n138: \n139: if __name__ == \"__main__\":\n140:     main()\n141: "
        },
        "timestamp": "2025-08-16 22:58:58.000",
        "id": "BzU2cwVQ08L91scPN0rv"
    },
    {
        "source": "frontend",
        "event": "autotransit_section",
        "data": {
            "before_section_id": "e8b317d3-b7db-42c1-8de7-82d2a7424f0b",
            "after_section_id": "08eddcdf-1f27-46f4-b67f-b7a27c5f02e0"
        },
        "timestamp": "2025-08-16 22:58:59.000",
        "id": "RfTtYumpXorhhX1FZ2O5"
    },
    {
        "source": "frontend",
        "event": "create_new_section",
        "data": {
            "section_id": "08eddcdf-1f27-46f4-b67f-b7a27c5f02e0",
            "section_data": {
                "editPromptDetailLevel": null,
                "selectedStructured": "unstructured",
                "createdAt": 1755370738000,
                "lines": [
                    9,
                    141
                ],
                "editPromptStructured": null,
                "summaryData": {
                    "low_structured": "• Loads and processes basketball data\n• Trains and evaluates an XGBoost ranking model\n• Plots and displays ranking prediction results",
                    "high_unstructured": "This code snippet includes several functions for a basketball MVP ranking pipeline. The load_data function reads a CSV, selects relevant statistical features, removes rows with missing data, sorts by year and rank, and prepares feature matrices and group labels. The evaluate_ndcg function computes the mean NDCG score for grouped ranking predictions, while xgboost_ranker initializes and fits an XGBoost ranker using pairwise ranking loss. The plot_ranking_predictions function visualizes the difference between predicted and true ranks for a given year using a bar plot. The main function ties everything together: it loads and splits the data by year, trains the model, predicts and ranks players, evaluates with NDCG, prints results, and generates plots for recent years.",
                    "medium_unstructured": "The code defines functions to load and preprocess basketball player data, evaluate ranking predictions using NDCG, train an XGBoost ranking model, and visualize prediction errors for specific years. The main function orchestrates the workflow, including splitting data by year, training the model, making predictions, evaluating performance, and plotting results. This setup enables automated model training and evaluation for MVP ranking predictions.",
                    "high_structured": "• load_data function:\n  ◦ Reads a CSV file of basketball player stats\n  ◦ Selects a set of statistical features, filters out rows with missing data, and sorts by year and rank\n  ◦ Returns feature matrix, target ranks, group sizes per year, and the full DataFrame\n• evaluate_ndcg function:\n  ◦ Calculates mean NDCG score for ranking predictions grouped by year\n  ◦ Converts ranks to relevance scores and aggregates NDCG across groups\n• xgboost_ranker function:\n  ◦ Initializes an XGBoostRanker with pairwise ranking objective and specific hyperparameters\n  ◦ Trains the model on the provided data and groups\n• plot_ranking_predictions function:\n  ◦ Computes prediction errors (PredictedRank - True Rank) for a given year\n  ◦ Plots these errors as a bar plot, saving the figure for each year\n• main function:\n  ◦ Loads and splits data into training and test sets based on year\n  ◦ Trains the XGBoost ranker, predicts scores and ranks for test data\n  ◦ Evaluates predictions using NDCG, prints results, and generates error plots for the latest years",
                    "title": "Summaries for Data Loading, Evaluation, Ranking, Plotting, and Main Workflow Functions",
                    "low_unstructured": "This code provides functions for loading basketball data, evaluating ranking predictions, training an XGBoost ranker, plotting prediction errors, and running the full model workflow.",
                    "medium_structured": "• Loads and cleans basketball player statistics data\n• Provides an NDCG-based evaluation for ranking predictions\n• Trains an XGBoost ranker on grouped data\n• Plots prediction errors for selected years\n• Main function manages data splitting, model training, prediction, evaluation, and visualization"
                },
                "selectedDetailLevel": "medium",
                "metadata": {
                    "originalCode": "def load_data(path=\"data/merged_data.csv\"):\n    df = pd.read_csv(path)\n\n    # Features to use\n    feature_cols = [\n        \"PTS\",\n        \"AST\",\n        \"TRB\",\n        \"FG%\",\n        \"BPM\",\n        \"WS/48\",\n        \"TS%\",\n        \"VORP\",\n        \"WS\",\n        \"PER\",\n    ]\n    feature_cols = [\n        col for col in feature_cols if col in df.columns\n    ]  # only keep existing features\n    df = df.dropna(subset=feature_cols + [\"Rank\"])\n\n    # Sort by Year and Rank for consistency\n    df = df.sort_values(by=[\"Year\", \"Rank\"])\n\n    X = df[feature_cols]\n    y = df[\"Rank\"]\n    groups = df.groupby(\"Year\").size().to_numpy()\n\n    return X, y, groups, df\n\n\ndef evaluate_ndcg(y_true, y_pred, group_sizes):\n    scores = []\n    start = 0\n    for size in group_sizes:\n        true_ranks = y_true[start : start + size]\n        true_relevance = (max(true_ranks) + 1) - true_ranks\n        pred_scores = y_pred[start : start + size]\n        scores.append(ndcg_score([true_relevance], [pred_scores]))\n        start += size\n    return np.mean(scores)\n\n\ndef xgboost_ranker(X, y, groups):\n    model = XGBRanker(\n        objective=\"rank:pairwise\",\n        learning_rate=0.1,\n        n_estimators=100,\n        max_depth=6,\n        random_state=42,\n    )\n\n    print(\"Training XGBoostRanker...\")\n    model.fit(X, y, group=groups)\n\n    return model\n\n\ndef plot_ranking_predictions(df, year):\n    \"\"\"\n    Plot prediction error for a specific year.\n\n    Args:\n        df: DataFrame containing prediction results\n        year: Year to plot prediction errors for\n    \"\"\"\n    df[\"RankError\"] = df[\"PredictedRank\"] - df[\"Rank\"]\n    year_df = df[df[\"Year\"] == year].copy()\n    year_df.sort_values(\"Rank\", inplace=True)\n\n    plt.figure(figsize=(12, 6))\n    sns.barplot(x=\"Name\", y=\"RankError\", data=year_df, hue=\"Name\", palette=\"coolwarm\")\n    plt.axhline(0, color=\"black\", linestyle=\"--\")\n    plt.xticks(rotation=45, ha=\"right\")\n    plt.ylabel(\"Predicted Rank - True Rank\")\n    plt.title(f\"MVP Ranking Predictions ({year})\")\n    plt.tight_layout()\n    plt.savefig(f\"data/ranking_predictions_{year}.png\")\n\n\ndef main():\n    X, y, group, df = load_data()\n\n    # Train-test split on years\n    unique_years = df[\"Year\"].unique()\n    train_years, test_years = (\n        unique_years[:-2],  # train: 2015-2023\n        unique_years[-2:],  # test: 2024-2025\n    )\n\n    train_idx = df[\"Year\"].isin(train_years)\n    test_idx = df[\"Year\"].isin(test_years)\n\n    X_train, X_test = X[train_idx], X[test_idx]\n    y_train, y_test = y[train_idx], y[test_idx]\n\n    # Group sizes\n    train_groups = df[train_idx].groupby(\"Year\").size().to_numpy()\n    test_groups = df[test_idx].groupby(\"Year\").size().to_numpy()\n\n    # Model\n    model = XGBRanker(\n        objective=\"rank:pairwise\",\n        learning_rate=0.1,\n        n_estimators=100,\n        max_depth=4,\n        random_state=42,\n    )\n\n    print(\"Training XGBoostRanker...\")\n    model.fit(X_train, y_train, group=train_groups)\n\n    # Predict, sort, and evaluate\n    y_pred = model.predict(X_test)\n    df.loc[test_idx, \"PredictedScore\"] = y_pred\n    df.loc[test_idx, \"PredictedRank\"] = (\n        df.loc[test_idx]\n        .groupby(\"Year\")[\"PredictedScore\"]\n        .rank(ascending=False, method=\"first\")\n    )\n\n    ndcg = evaluate_ndcg(y_test.to_numpy(), y_pred, test_groups)\n    print(f\"NDCG Score on test years {test_years.tolist()}: {ndcg:.4f}\")\n\n    # Show results\n    print(df[test_idx][[\"Year\", \"Name\", \"Rank\", \"PredictedScore\", \"PredictedRank\"]])\n    plot_ranking_predictions(df, 2024)\n    plot_ranking_predictions(df, 2025)\n\n\nif __name__ == \"__main__\":\n    main()\n",
                    "fullPath": "/project/workspace/rank_model.py",
                    "id": "08eddcdf-1f27-46f4-b67f-b7a27c5f02e0",
                    "offset": 164,
                    "filename": "rank_model.py"
                },
                "editPromptValue": "",
                "title": "Summaries for Data Loading, Evaluation, Ranking, Plotting, and Main Workflow Functions",
                "summaryMappings": {
                    "high_unstructured": [
                        {
                            "summaryComponent": "several functions for a basketball MVP ranking pipeline",
                            "codeSegments": [
                                {
                                    "line": 9,
                                    "code": "def load_data(path=\"data/merged_data.csv\"):"
                                },
                                {
                                    "line": 40,
                                    "code": "def evaluate_ndcg(y_true, y_pred, group_sizes):"
                                },
                                {
                                    "line": 52,
                                    "code": "def xgboost_ranker(X, y, groups):"
                                },
                                {
                                    "line": 67,
                                    "code": "def plot_ranking_predictions(df, year):"
                                },
                                {
                                    "line": 89,
                                    "code": "def main():"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "The load_data function reads a CSV",
                            "codeSegments": [
                                {
                                    "line": 9,
                                    "code": "def load_data(path=\"data/merged_data.csv\"):"
                                },
                                {
                                    "line": 10,
                                    "code": "df = pd.read_csv(path)"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "selects relevant statistical features",
                            "codeSegments": [
                                {
                                    "line": 13,
                                    "code": "feature_cols = ["
                                },
                                {
                                    "line": 26,
                                    "code": "col for col in feature_cols if col in df.columns"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "removes rows with missing data",
                            "codeSegments": [
                                {
                                    "line": 28,
                                    "code": "df = df.dropna(subset=feature_cols + [\"Rank\"])"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "sorts by year and rank",
                            "codeSegments": [
                                {
                                    "line": 31,
                                    "code": "df = df.sort_values(by=[\"Year\", \"Rank\"])"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "prepares feature matrices and group labels",
                            "codeSegments": [
                                {
                                    "line": 33,
                                    "code": "X = df[feature_cols]"
                                },
                                {
                                    "line": 34,
                                    "code": "y = df[\"Rank\"]"
                                },
                                {
                                    "line": 35,
                                    "code": "groups = df.groupby(\"Year\").size().to_numpy()"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "The evaluate_ndcg function computes the mean NDCG score for grouped ranking predictions",
                            "codeSegments": [
                                {
                                    "line": 40,
                                    "code": "def evaluate_ndcg(y_true, y_pred, group_sizes):"
                                },
                                {
                                    "line": 49,
                                    "code": "return np.mean(scores)"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "xgboost_ranker initializes and fits an XGBoost ranker using pairwise ranking loss",
                            "codeSegments": [
                                {
                                    "line": 52,
                                    "code": "def xgboost_ranker(X, y, groups):"
                                },
                                {
                                    "line": 53,
                                    "code": "model = XGBRanker("
                                },
                                {
                                    "line": 54,
                                    "code": "objective=\"rank:pairwise\","
                                },
                                {
                                    "line": 62,
                                    "code": "model.fit(X, y, group=groups)"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "The plot_ranking_predictions function visualizes the difference between predicted and true ranks for a given year using a bar plot",
                            "codeSegments": [
                                {
                                    "line": 67,
                                    "code": "def plot_ranking_predictions(df, year):"
                                },
                                {
                                    "line": 75,
                                    "code": "df[\"RankError\"] = df[\"PredictedRank\"] - df[\"Rank\"]"
                                },
                                {
                                    "line": 80,
                                    "code": "sns.barplot(x=\"Name\", y=\"RankError\", data=year_df, hue=\"Name\", palette=\"coolwarm\")"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "The main function ties everything together: it loads and splits the data by year, trains the model, predicts and ranks players, evaluates with NDCG, prints results, and generates plots for recent years.",
                            "codeSegments": [
                                {
                                    "line": 89,
                                    "code": "def main():"
                                },
                                {
                                    "line": 90,
                                    "code": "X, y, group, df = load_data()"
                                },
                                {
                                    "line": 94,
                                    "code": "train_years, test_years = ("
                                },
                                {
                                    "line": 119,
                                    "code": "model.fit(X_train, y_train, group=train_groups)"
                                },
                                {
                                    "line": 122,
                                    "code": "y_pred = model.predict(X_test)"
                                },
                                {
                                    "line": 124,
                                    "code": "df.loc[test_idx, \"PredictedRank\"] = ("
                                },
                                {
                                    "line": 130,
                                    "code": "ndcg = evaluate_ndcg(y_test.to_numpy(), y_pred, test_groups)"
                                },
                                {
                                    "line": 134,
                                    "code": "print(df[test_idx][[\"Year\", \"Name\", \"Rank\", \"PredictedScore\", \"PredictedRank\"]])"
                                },
                                {
                                    "line": 135,
                                    "code": "plot_ranking_predictions(df, 2024)"
                                },
                                {
                                    "line": 136,
                                    "code": "plot_ranking_predictions(df, 2025)"
                                }
                            ]
                        }
                    ],
                    "medium_unstructured": [
                        {
                            "summaryComponent": "load and preprocess basketball player data",
                            "codeSegments": [
                                {
                                    "line": 9,
                                    "code": "def load_data(path=\"data/merged_data.csv\"):"
                                },
                                {
                                    "line": 10,
                                    "code": "df = pd.read_csv(path)"
                                },
                                {
                                    "line": 13,
                                    "code": "feature_cols = ["
                                },
                                {
                                    "line": 28,
                                    "code": "df = df.dropna(subset=feature_cols + [\"Rank\"])"
                                },
                                {
                                    "line": 31,
                                    "code": "df = df.sort_values(by=[\"Year\", \"Rank\"])"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "evaluate ranking predictions using NDCG",
                            "codeSegments": [
                                {
                                    "line": 40,
                                    "code": "def evaluate_ndcg(y_true, y_pred, group_sizes):"
                                },
                                {
                                    "line": 47,
                                    "code": "scores.append(ndcg_score([true_relevance], [pred_scores]))"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "train an XGBoost ranking model",
                            "codeSegments": [
                                {
                                    "line": 52,
                                    "code": "def xgboost_ranker(X, y, groups):"
                                },
                                {
                                    "line": 53,
                                    "code": "model = XGBRanker("
                                },
                                {
                                    "line": 62,
                                    "code": "model.fit(X, y, group=groups)"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "visualize prediction errors for specific years",
                            "codeSegments": [
                                {
                                    "line": 67,
                                    "code": "def plot_ranking_predictions(df, year):"
                                },
                                {
                                    "line": 75,
                                    "code": "df[\"RankError\"] = df[\"PredictedRank\"] - df[\"Rank\"]"
                                },
                                {
                                    "line": 80,
                                    "code": "sns.barplot(x=\"Name\", y=\"RankError\", data=year_df, hue=\"Name\", palette=\"coolwarm\")"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "main function orchestrates the workflow",
                            "codeSegments": [
                                {
                                    "line": 89,
                                    "code": "def main():"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "splitting data by year",
                            "codeSegments": [
                                {
                                    "line": 93,
                                    "code": "unique_years = df[\"Year\"].unique()"
                                },
                                {
                                    "line": 94,
                                    "code": "train_years, test_years = ("
                                },
                                {
                                    "line": 99,
                                    "code": "train_idx = df[\"Year\"].isin(train_years)"
                                },
                                {
                                    "line": 100,
                                    "code": "test_idx = df[\"Year\"].isin(test_years)"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "training the model",
                            "codeSegments": [
                                {
                                    "line": 119,
                                    "code": "model.fit(X_train, y_train, group=train_groups)"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "making predictions",
                            "codeSegments": [
                                {
                                    "line": 122,
                                    "code": "y_pred = model.predict(X_test)"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "evaluating performance",
                            "codeSegments": [
                                {
                                    "line": 130,
                                    "code": "ndcg = evaluate_ndcg(y_test.to_numpy(), y_pred, test_groups)"
                                },
                                {
                                    "line": 131,
                                    "code": "print(f\"NDCG Score on test years {test_years.tolist()}: {ndcg:.4f}\")"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "plotting results",
                            "codeSegments": [
                                {
                                    "line": 135,
                                    "code": "plot_ranking_predictions(df, 2024)"
                                },
                                {
                                    "line": 136,
                                    "code": "plot_ranking_predictions(df, 2025)"
                                }
                            ]
                        }
                    ],
                    "high_structured": [
                        {
                            "summaryComponent": "Reads a CSV file of basketball player stats",
                            "codeSegments": [
                                {
                                    "line": 10,
                                    "code": "df = pd.read_csv(path)"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "Selects a set of statistical features, filters out rows with missing data, and sorts by year and rank",
                            "codeSegments": [
                                {
                                    "line": 13,
                                    "code": "feature_cols = ["
                                },
                                {
                                    "line": 25,
                                    "code": "feature_cols = ["
                                },
                                {
                                    "line": 28,
                                    "code": "df = df.dropna(subset=feature_cols + [\"Rank\"])"
                                },
                                {
                                    "line": 31,
                                    "code": "df = df.sort_values(by=[\"Year\", \"Rank\"])"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "Returns feature matrix, target ranks, group sizes per year, and the full DataFrame",
                            "codeSegments": [
                                {
                                    "line": 37,
                                    "code": "return X, y, groups, df"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "Calculates mean NDCG score for ranking predictions grouped by year",
                            "codeSegments": [
                                {
                                    "line": 40,
                                    "code": "def evaluate_ndcg(y_true, y_pred, group_sizes):"
                                },
                                {
                                    "line": 49,
                                    "code": "return np.mean(scores)"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "Converts ranks to relevance scores and aggregates NDCG across groups",
                            "codeSegments": [
                                {
                                    "line": 45,
                                    "code": "true_relevance = (max(true_ranks) + 1) - true_ranks"
                                },
                                {
                                    "line": 47,
                                    "code": "scores.append(ndcg_score([true_relevance], [pred_scores]))"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "Initializes an XGBoostRanker with pairwise ranking objective and specific hyperparameters",
                            "codeSegments": [
                                {
                                    "line": 53,
                                    "code": "model = XGBRanker("
                                },
                                {
                                    "line": 54,
                                    "code": "objective=\"rank:pairwise\","
                                },
                                {
                                    "line": 55,
                                    "code": "learning_rate=0.1,"
                                },
                                {
                                    "line": 56,
                                    "code": "n_estimators=100,"
                                },
                                {
                                    "line": 57,
                                    "code": "max_depth=6,"
                                },
                                {
                                    "line": 58,
                                    "code": "random_state=42,"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "Trains the model on the provided data and groups",
                            "codeSegments": [
                                {
                                    "line": 62,
                                    "code": "model.fit(X, y, group=groups)"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "Computes prediction errors (PredictedRank - True Rank) for a given year",
                            "codeSegments": [
                                {
                                    "line": 75,
                                    "code": "df[\"RankError\"] = df[\"PredictedRank\"] - df[\"Rank\"]"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "Plots these errors as a bar plot, saving the figure for each year",
                            "codeSegments": [
                                {
                                    "line": 80,
                                    "code": "sns.barplot(x=\"Name\", y=\"RankError\", data=year_df, hue=\"Name\", palette=\"coolwarm\")"
                                },
                                {
                                    "line": 86,
                                    "code": "plt.savefig(f\"data/ranking_predictions_{year}.png\")"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "Loads and splits data into training and test sets based on year",
                            "codeSegments": [
                                {
                                    "line": 90,
                                    "code": "X, y, group, df = load_data()"
                                },
                                {
                                    "line": 93,
                                    "code": "unique_years = df[\"Year\"].unique()"
                                },
                                {
                                    "line": 94,
                                    "code": "train_years, test_years = ("
                                },
                                {
                                    "line": 99,
                                    "code": "train_idx = df[\"Year\"].isin(train_years)"
                                },
                                {
                                    "line": 100,
                                    "code": "test_idx = df[\"Year\"].isin(test_years)"
                                },
                                {
                                    "line": 102,
                                    "code": "X_train, X_test = X[train_idx], X[test_idx]"
                                },
                                {
                                    "line": 103,
                                    "code": "y_train, y_test = y[train_idx], y[test_idx]"
                                }
                            ]
                        }
                    ],
                    "low_unstructured": [
                        {
                            "summaryComponent": "functions for loading basketball data",
                            "codeSegments": [
                                {
                                    "line": 9,
                                    "code": "def load_data(path=\"data/merged_data.csv\"):"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "evaluating ranking predictions",
                            "codeSegments": [
                                {
                                    "line": 40,
                                    "code": "def evaluate_ndcg(y_true, y_pred, group_sizes):"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "training an XGBoost ranker",
                            "codeSegments": [
                                {
                                    "line": 52,
                                    "code": "def xgboost_ranker(X, y, groups):"
                                },
                                {
                                    "line": 53,
                                    "code": "model = XGBRanker("
                                }
                            ]
                        },
                        {
                            "summaryComponent": "plotting prediction errors",
                            "codeSegments": [
                                {
                                    "line": 67,
                                    "code": "def plot_ranking_predictions(df, year):"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "running the full model workflow",
                            "codeSegments": [
                                {
                                    "line": 89,
                                    "code": "def main():"
                                },
                                {
                                    "line": 139,
                                    "code": "if __name__ == \"__main__\":"
                                },
                                {
                                    "line": 140,
                                    "code": "main()"
                                }
                            ]
                        }
                    ],
                    "low_structured": [
                        {
                            "summaryComponent": "Loads and processes basketball data",
                            "codeSegments": [
                                {
                                    "line": 9,
                                    "code": "def load_data(path=\"data/merged_data.csv\"):"
                                },
                                {
                                    "line": 10,
                                    "code": "df = pd.read_csv(path)"
                                },
                                {
                                    "line": 13,
                                    "code": "feature_cols = ["
                                },
                                {
                                    "line": 28,
                                    "code": "df = df.dropna(subset=feature_cols + [\"Rank\"])"
                                },
                                {
                                    "line": 31,
                                    "code": "df = df.sort_values(by=[\"Year\", \"Rank\"])"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "Trains and evaluates an XGBoost ranking model",
                            "codeSegments": [
                                {
                                    "line": 110,
                                    "code": "model = XGBRanker("
                                },
                                {
                                    "line": 119,
                                    "code": "model.fit(X_train, y_train, group=train_groups)"
                                },
                                {
                                    "line": 122,
                                    "code": "y_pred = model.predict(X_test)"
                                },
                                {
                                    "line": 130,
                                    "code": "ndcg = evaluate_ndcg(y_test.to_numpy(), y_pred, test_groups)"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "Plots and displays ranking prediction results",
                            "codeSegments": [
                                {
                                    "line": 135,
                                    "code": "plot_ranking_predictions(df, 2024)"
                                },
                                {
                                    "line": 136,
                                    "code": "plot_ranking_predictions(df, 2025)"
                                },
                                {
                                    "line": 134,
                                    "code": "print(df[test_idx][[\"Year\", \"Name\", \"Rank\", \"PredictedScore\", \"PredictedRank\"]])"
                                }
                            ]
                        }
                    ],
                    "medium_structured": [
                        {
                            "summaryComponent": "Loads and cleans basketball player statistics data",
                            "codeSegments": [
                                {
                                    "line": 9,
                                    "code": "def load_data(path=\"data/merged_data.csv\"):"
                                },
                                {
                                    "line": 10,
                                    "code": "df = pd.read_csv(path)"
                                },
                                {
                                    "line": 13,
                                    "code": "feature_cols = ["
                                },
                                {
                                    "line": 25,
                                    "code": "feature_cols = [\n    col for col in feature_cols if col in df.columns\n]  # only keep existing features"
                                },
                                {
                                    "line": 28,
                                    "code": "df = df.dropna(subset=feature_cols + [\"Rank\"])"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "Provides an NDCG-based evaluation for ranking predictions",
                            "codeSegments": [
                                {
                                    "line": 40,
                                    "code": "def evaluate_ndcg(y_true, y_pred, group_sizes):"
                                },
                                {
                                    "line": 47,
                                    "code": "scores.append(ndcg_score([true_relevance], [pred_scores]))"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "Trains an XGBoost ranker on grouped data",
                            "codeSegments": [
                                {
                                    "line": 52,
                                    "code": "def xgboost_ranker(X, y, groups):"
                                },
                                {
                                    "line": 53,
                                    "code": "model = XGBRanker("
                                },
                                {
                                    "line": 62,
                                    "code": "model.fit(X, y, group=groups)"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "Plots prediction errors for selected years",
                            "codeSegments": [
                                {
                                    "line": 67,
                                    "code": "def plot_ranking_predictions(df, year):"
                                },
                                {
                                    "line": 75,
                                    "code": "df[\"RankError\"] = df[\"PredictedRank\"] - df[\"Rank\"]"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "Main function manages data splitting, model training, prediction, evaluation, and visualization",
                            "codeSegments": [
                                {
                                    "line": 89,
                                    "code": "def main():"
                                },
                                {
                                    "line": 90,
                                    "code": "X, y, group, df = load_data()"
                                },
                                {
                                    "line": 99,
                                    "code": "train_idx = df[\"Year\"].isin(train_years)"
                                },
                                {
                                    "line": 100,
                                    "code": "test_idx = df[\"Year\"].isin(test_years)"
                                },
                                {
                                    "line": 119,
                                    "code": "model.fit(X_train, y_train, group=train_groups)"
                                },
                                {
                                    "line": 122,
                                    "code": "y_pred = model.predict(X_test)"
                                },
                                {
                                    "line": 130,
                                    "code": "ndcg = evaluate_ndcg(y_test.to_numpy(), y_pred, test_groups)"
                                },
                                {
                                    "line": 135,
                                    "code": "plot_ranking_predictions(df, 2024)"
                                },
                                {
                                    "line": 136,
                                    "code": "plot_ranking_predictions(df, 2025)"
                                }
                            ]
                        }
                    ]
                }
            }
        },
        "timestamp": "2025-08-16 22:58:59.000",
        "id": "q1ZheTrKPx1gv1Adrbka"
    },
    {
        "source": "frontend",
        "event": "change_summary_level",
        "data": {
            "before_detail_level": "medium",
            "section_id": "08eddcdf-1f27-46f4-b67f-b7a27c5f02e0",
            "before_structured": "unstructured",
            "after_structured": "unstructured",
            "after_detail_level": "low"
        },
        "timestamp": "2025-08-16 22:59:02.000",
        "id": "CH8PIVEIDlcrU0am6RLZ"
    },
    {
        "source": "frontend",
        "event": "change_summary_level",
        "data": {
            "before_detail_level": "high",
            "section_id": "08eddcdf-1f27-46f4-b67f-b7a27c5f02e0",
            "before_structured": "unstructured",
            "after_structured": "unstructured",
            "after_detail_level": "medium"
        },
        "timestamp": "2025-08-16 22:59:02.000",
        "id": "GiHJvuBYt6OJj7werCFh"
    },
    {
        "source": "frontend",
        "event": "change_summary_level",
        "data": {
            "before_detail_level": "medium",
            "section_id": "08eddcdf-1f27-46f4-b67f-b7a27c5f02e0",
            "before_structured": "unstructured",
            "after_structured": "unstructured",
            "after_detail_level": "high"
        },
        "timestamp": "2025-08-16 22:59:02.000",
        "id": "V36yi9MfkqG8aY9ivruG"
    },
    {
        "source": "frontend",
        "event": "change_summary_level",
        "data": {
            "before_detail_level": "low",
            "section_id": "08eddcdf-1f27-46f4-b67f-b7a27c5f02e0",
            "before_structured": "unstructured",
            "after_structured": "unstructured",
            "after_detail_level": "medium"
        },
        "timestamp": "2025-08-16 22:59:03.000",
        "id": "YwjtArJVpDU9hlU123Hw"
    },
    {
        "source": "frontend",
        "event": "change_summary_level",
        "data": {
            "before_detail_level": "medium",
            "section_id": "08eddcdf-1f27-46f4-b67f-b7a27c5f02e0",
            "before_structured": "unstructured",
            "after_structured": "unstructured",
            "after_detail_level": "low"
        },
        "timestamp": "2025-08-16 22:59:04.000",
        "id": "0Rt8IKxwduaW4ZTEEpg0"
    },
    {
        "source": "frontend",
        "event": "change_summary_level",
        "data": {
            "before_detail_level": "low",
            "section_id": "08eddcdf-1f27-46f4-b67f-b7a27c5f02e0",
            "before_structured": "unstructured",
            "after_structured": "structured",
            "after_detail_level": "low"
        },
        "timestamp": "2025-08-16 22:59:05.000",
        "id": "lfy50UT2sYZnMFi4ykYS"
    },
    {
        "source": "frontend",
        "event": "change_summary_level",
        "data": {
            "before_detail_level": "low",
            "section_id": "08eddcdf-1f27-46f4-b67f-b7a27c5f02e0",
            "before_structured": "structured",
            "after_structured": "structured",
            "after_detail_level": "medium"
        },
        "timestamp": "2025-08-16 22:59:06.000",
        "id": "JrlnBUWDMQRCIQXMdGsb"
    },
    {
        "source": "frontend",
        "event": "change_summary_level",
        "data": {
            "before_detail_level": "medium",
            "section_id": "08eddcdf-1f27-46f4-b67f-b7a27c5f02e0",
            "before_structured": "structured",
            "after_structured": "structured",
            "after_detail_level": "low"
        },
        "timestamp": "2025-08-16 22:59:07.000",
        "id": "KCitTVoObOKLbob5CPFu"
    },
    {
        "source": "frontend",
        "event": "change_summary_level",
        "data": {
            "before_detail_level": "low",
            "section_id": "08eddcdf-1f27-46f4-b67f-b7a27c5f02e0",
            "before_structured": "structured",
            "after_structured": "structured",
            "after_detail_level": "medium"
        },
        "timestamp": "2025-08-16 22:59:07.000",
        "id": "jIfP3xMsfoFiwph9qPVX"
    },
    {
        "source": "frontend",
        "event": "change_summary_level",
        "data": {
            "before_detail_level": "medium",
            "section_id": "08eddcdf-1f27-46f4-b67f-b7a27c5f02e0",
            "before_structured": "structured",
            "after_structured": "structured",
            "after_detail_level": "low"
        },
        "timestamp": "2025-08-16 22:59:08.000",
        "id": "nzHMlRPV6gkiDYFwiTYK"
    },
    {
        "source": "frontend",
        "event": "change_summary_level",
        "data": {
            "before_detail_level": "low",
            "section_id": "08eddcdf-1f27-46f4-b67f-b7a27c5f02e0",
            "before_structured": "structured",
            "after_structured": "structured",
            "after_detail_level": "medium"
        },
        "timestamp": "2025-08-16 22:59:09.000",
        "id": "cbueNXbFjxfwjnt9pvck"
    },
    {
        "source": "frontend",
        "event": "change_summary_level",
        "data": {
            "before_detail_level": "medium",
            "section_id": "08eddcdf-1f27-46f4-b67f-b7a27c5f02e0",
            "before_structured": "structured",
            "after_structured": "structured",
            "after_detail_level": "high"
        },
        "timestamp": "2025-08-16 22:59:09.000",
        "id": "hca34Nsctt9JcApZsLSo"
    },
    {
        "source": "frontend",
        "event": "change_summary_level",
        "data": {
            "before_detail_level": "high",
            "section_id": "08eddcdf-1f27-46f4-b67f-b7a27c5f02e0",
            "before_structured": "structured",
            "after_structured": "structured",
            "after_detail_level": "medium"
        },
        "timestamp": "2025-08-16 22:59:10.000",
        "id": "NEfN75J7tMMZG2mf2Wqp"
    },
    {
        "source": "frontend",
        "event": "change_summary_level",
        "data": {
            "before_detail_level": "medium",
            "section_id": "08eddcdf-1f27-46f4-b67f-b7a27c5f02e0",
            "before_structured": "structured",
            "after_structured": "structured",
            "after_detail_level": "low"
        },
        "timestamp": "2025-08-16 22:59:10.000",
        "id": "UNtqMcLIizWdXYqoGnjp"
    },
    {
        "source": "frontend",
        "event": "change_summary_level",
        "data": {
            "before_detail_level": "low",
            "section_id": "08eddcdf-1f27-46f4-b67f-b7a27c5f02e0",
            "before_structured": "structured",
            "after_structured": "structured",
            "after_detail_level": "medium"
        },
        "timestamp": "2025-08-16 22:59:11.000",
        "id": "cIPU6qBaCX5h6qvBxjKi"
    },
    {
        "source": "frontend",
        "event": "change_summary_level",
        "data": {
            "before_detail_level": "high",
            "section_id": "08eddcdf-1f27-46f4-b67f-b7a27c5f02e0",
            "before_structured": "structured",
            "after_structured": "structured",
            "after_detail_level": "medium"
        },
        "timestamp": "2025-08-16 22:59:11.000",
        "id": "dh1X8SW2d6WoM9sjvQoX"
    },
    {
        "source": "frontend",
        "event": "change_summary_level",
        "data": {
            "before_detail_level": "medium",
            "section_id": "08eddcdf-1f27-46f4-b67f-b7a27c5f02e0",
            "before_structured": "structured",
            "after_structured": "structured",
            "after_detail_level": "high"
        },
        "timestamp": "2025-08-16 22:59:11.000",
        "id": "iEMbOG0IgZK9mBs5shAj"
    },
    {
        "source": "frontend",
        "event": "change_summary_level",
        "data": {
            "before_detail_level": "high",
            "section_id": "08eddcdf-1f27-46f4-b67f-b7a27c5f02e0",
            "before_structured": "structured",
            "after_structured": "structured",
            "after_detail_level": "medium"
        },
        "timestamp": "2025-08-16 22:59:12.000",
        "id": "33GQixe4xXUzdv1YRclz"
    },
    {
        "source": "frontend",
        "event": "change_summary_level",
        "data": {
            "before_detail_level": "medium",
            "section_id": "08eddcdf-1f27-46f4-b67f-b7a27c5f02e0",
            "before_structured": "structured",
            "after_structured": "structured",
            "after_detail_level": "high"
        },
        "timestamp": "2025-08-16 22:59:12.000",
        "id": "Ryp8eWNl9z2Xw0BxQRrn"
    },
    {
        "source": "frontend",
        "event": "change_summary_level",
        "data": {
            "before_detail_level": "medium",
            "section_id": "08eddcdf-1f27-46f4-b67f-b7a27c5f02e0",
            "before_structured": "structured",
            "after_structured": "structured",
            "after_detail_level": "high"
        },
        "timestamp": "2025-08-16 22:59:13.000",
        "id": "G3vaSFCstgSFZ5ZNqmZe"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "08eddcdf-1f27-46f4-b67f-b7a27c5f02e0",
            "detail_level": "high",
            "structured_type": "structured"
        },
        "timestamp": "2025-08-16 22:59:15.000",
        "id": "SoDGGoDAE9sCpShfyklE"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "08eddcdf-1f27-46f4-b67f-b7a27c5f02e0",
            "mapping_index": 0,
            "structured_type": "structured",
            "detail_level": "high"
        },
        "timestamp": "2025-08-16 22:59:15.000",
        "id": "fOQ8UiJxM9uxBC0i9GEd"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "08eddcdf-1f27-46f4-b67f-b7a27c5f02e0",
            "mapping_index": 0,
            "structured_type": "structured",
            "detail_level": "high"
        },
        "timestamp": "2025-08-16 22:59:17.000",
        "id": "A4DExlsz8ppt2SpMJ7Xl"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "08eddcdf-1f27-46f4-b67f-b7a27c5f02e0",
            "mapping_index": 0,
            "structured_type": "structured",
            "detail_level": "high"
        },
        "timestamp": "2025-08-16 22:59:18.000",
        "id": "Ll5yjndQLhG1IHVUpIUA"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "08eddcdf-1f27-46f4-b67f-b7a27c5f02e0",
            "detail_level": "high",
            "structured_type": "structured"
        },
        "timestamp": "2025-08-16 22:59:18.000",
        "id": "jtMgYKtyRRvrgMabdch3"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "08eddcdf-1f27-46f4-b67f-b7a27c5f02e0",
            "detail_level": "high",
            "structured_type": "structured"
        },
        "timestamp": "2025-08-16 22:59:19.000",
        "id": "5zup5hISTVdyIvuc1XfE"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "08eddcdf-1f27-46f4-b67f-b7a27c5f02e0",
            "detail_level": "high",
            "structured_type": "structured"
        },
        "timestamp": "2025-08-16 22:59:19.000",
        "id": "9BUzbDnEATiQO2Zwr638"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "08eddcdf-1f27-46f4-b67f-b7a27c5f02e0",
            "mapping_index": 1,
            "structured_type": "structured",
            "detail_level": "high"
        },
        "timestamp": "2025-08-16 22:59:19.000",
        "id": "AjIFwVVslouercLUXvxz"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "08eddcdf-1f27-46f4-b67f-b7a27c5f02e0",
            "detail_level": "high",
            "structured_type": "structured"
        },
        "timestamp": "2025-08-16 22:59:19.000",
        "id": "SsJM5W20r3MG2Y4JJY9V"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "08eddcdf-1f27-46f4-b67f-b7a27c5f02e0",
            "detail_level": "high",
            "structured_type": "structured"
        },
        "timestamp": "2025-08-16 22:59:19.000",
        "id": "Y2ewpG1zIUnb0YVCxDH7"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "08eddcdf-1f27-46f4-b67f-b7a27c5f02e0",
            "mapping_index": 2,
            "structured_type": "structured",
            "detail_level": "high"
        },
        "timestamp": "2025-08-16 22:59:19.000",
        "id": "ai5U60m61thawA8FlCmD"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "08eddcdf-1f27-46f4-b67f-b7a27c5f02e0",
            "detail_level": "high",
            "structured_type": "structured"
        },
        "timestamp": "2025-08-16 22:59:19.000",
        "id": "gaoEYPCSWnYmrEw68HKr"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "08eddcdf-1f27-46f4-b67f-b7a27c5f02e0",
            "mapping_index": 0,
            "structured_type": "structured",
            "detail_level": "high"
        },
        "timestamp": "2025-08-16 22:59:19.000",
        "id": "sD6qowWmNPPhyy8hb6Hv"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "08eddcdf-1f27-46f4-b67f-b7a27c5f02e0",
            "mapping_index": 1,
            "structured_type": "structured",
            "detail_level": "high"
        },
        "timestamp": "2025-08-16 22:59:19.000",
        "id": "yEfDHt5lemvHtHXKWQLc"
    },
    {
        "source": "frontend",
        "event": "change_summary_level",
        "data": {
            "before_detail_level": "high",
            "section_id": "08eddcdf-1f27-46f4-b67f-b7a27c5f02e0",
            "before_structured": "structured",
            "after_structured": "structured",
            "after_detail_level": "medium"
        },
        "timestamp": "2025-08-16 22:59:20.000",
        "id": "WKeF753RrOh8fvKkdJag"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "08eddcdf-1f27-46f4-b67f-b7a27c5f02e0",
            "mapping_index": 0,
            "structured_type": "structured",
            "detail_level": "medium"
        },
        "timestamp": "2025-08-16 22:59:20.000",
        "id": "qMhnkfXD7dxoEn2ea6Fm"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "08eddcdf-1f27-46f4-b67f-b7a27c5f02e0",
            "detail_level": "medium",
            "structured_type": "structured"
        },
        "timestamp": "2025-08-16 22:59:22.000",
        "id": "PpAQU9hP5wIiOK6Mw4EG"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "08eddcdf-1f27-46f4-b67f-b7a27c5f02e0",
            "mapping_index": 1,
            "structured_type": "structured",
            "detail_level": "medium"
        },
        "timestamp": "2025-08-16 22:59:22.000",
        "id": "sXC5P9uQtJeyAy7RAEtB"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "08eddcdf-1f27-46f4-b67f-b7a27c5f02e0",
            "detail_level": "medium",
            "structured_type": "structured"
        },
        "timestamp": "2025-08-16 22:59:27.000",
        "id": "RL3gSZM4nNOL09Q5UcBy"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "08eddcdf-1f27-46f4-b67f-b7a27c5f02e0",
            "mapping_index": 2,
            "structured_type": "structured",
            "detail_level": "medium"
        },
        "timestamp": "2025-08-16 22:59:27.000",
        "id": "abms1QYr9TdbLLjmE8Lq"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "08eddcdf-1f27-46f4-b67f-b7a27c5f02e0",
            "detail_level": "medium",
            "structured_type": "structured"
        },
        "timestamp": "2025-08-16 22:59:32.000",
        "id": "9XZeBi46WcnHYeJSrBrh"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "08eddcdf-1f27-46f4-b67f-b7a27c5f02e0",
            "detail_level": "medium",
            "structured_type": "structured"
        },
        "timestamp": "2025-08-16 22:59:32.000",
        "id": "YxN5FSo00wuQj2D6YDJc"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "08eddcdf-1f27-46f4-b67f-b7a27c5f02e0",
            "mapping_index": 1,
            "structured_type": "structured",
            "detail_level": "medium"
        },
        "timestamp": "2025-08-16 22:59:32.000",
        "id": "hicQI5rgg5Ac0zG8ay7V"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "08eddcdf-1f27-46f4-b67f-b7a27c5f02e0",
            "detail_level": "medium",
            "structured_type": "structured"
        },
        "timestamp": "2025-08-16 22:59:32.000",
        "id": "iBnroen8bdxrbKIwWg2a"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "08eddcdf-1f27-46f4-b67f-b7a27c5f02e0",
            "mapping_index": 0,
            "structured_type": "structured",
            "detail_level": "medium"
        },
        "timestamp": "2025-08-16 22:59:32.000",
        "id": "qZznyrejFiOzuAUbBSVM"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "08eddcdf-1f27-46f4-b67f-b7a27c5f02e0",
            "mapping_index": 3,
            "structured_type": "structured",
            "detail_level": "medium"
        },
        "timestamp": "2025-08-16 22:59:33.000",
        "id": "16xOl0UpMBwitlgI7QKw"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "08eddcdf-1f27-46f4-b67f-b7a27c5f02e0",
            "detail_level": "medium",
            "structured_type": "structured"
        },
        "timestamp": "2025-08-16 22:59:33.000",
        "id": "2D9xCWIzT1k4Sixmlp83"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "08eddcdf-1f27-46f4-b67f-b7a27c5f02e0",
            "mapping_index": 4,
            "structured_type": "structured",
            "detail_level": "medium"
        },
        "timestamp": "2025-08-16 22:59:33.000",
        "id": "Drygj0IRR7yJ6EaueoWo"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "08eddcdf-1f27-46f4-b67f-b7a27c5f02e0",
            "mapping_index": 1,
            "structured_type": "structured",
            "detail_level": "medium"
        },
        "timestamp": "2025-08-16 22:59:33.000",
        "id": "FmJx9mymUNBj3mrSmoiX"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "08eddcdf-1f27-46f4-b67f-b7a27c5f02e0",
            "detail_level": "medium",
            "structured_type": "structured"
        },
        "timestamp": "2025-08-16 22:59:33.000",
        "id": "LdEaA6nde0Zi19ZXlDyZ"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "08eddcdf-1f27-46f4-b67f-b7a27c5f02e0",
            "mapping_index": 3,
            "structured_type": "structured",
            "detail_level": "medium"
        },
        "timestamp": "2025-08-16 22:59:33.000",
        "id": "SFSQCDEGGmv0aauksfow"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "08eddcdf-1f27-46f4-b67f-b7a27c5f02e0",
            "mapping_index": 2,
            "structured_type": "structured",
            "detail_level": "medium"
        },
        "timestamp": "2025-08-16 22:59:33.000",
        "id": "UvAF2iIoyAENiWKcHBAK"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "08eddcdf-1f27-46f4-b67f-b7a27c5f02e0",
            "detail_level": "medium",
            "structured_type": "structured"
        },
        "timestamp": "2025-08-16 22:59:33.000",
        "id": "YghwKtJeEid4f4ybhUNG"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "08eddcdf-1f27-46f4-b67f-b7a27c5f02e0",
            "detail_level": "medium",
            "structured_type": "structured"
        },
        "timestamp": "2025-08-16 22:59:33.000",
        "id": "Z3bek4K9cjeFrlI5RClb"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "08eddcdf-1f27-46f4-b67f-b7a27c5f02e0",
            "mapping_index": 0,
            "structured_type": "structured",
            "detail_level": "medium"
        },
        "timestamp": "2025-08-16 22:59:33.000",
        "id": "aVxDrkei113V4VpeYGGI"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "08eddcdf-1f27-46f4-b67f-b7a27c5f02e0",
            "mapping_index": 2,
            "structured_type": "structured",
            "detail_level": "medium"
        },
        "timestamp": "2025-08-16 22:59:33.000",
        "id": "b30RjZURcweUCR55ZF4j"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "08eddcdf-1f27-46f4-b67f-b7a27c5f02e0",
            "detail_level": "medium",
            "structured_type": "structured"
        },
        "timestamp": "2025-08-16 22:59:33.000",
        "id": "gObIBt12jSTULSFD00cP"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "08eddcdf-1f27-46f4-b67f-b7a27c5f02e0",
            "detail_level": "medium",
            "structured_type": "structured"
        },
        "timestamp": "2025-08-16 22:59:33.000",
        "id": "ioaCyOXqEqsOhhpKt8tm"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "08eddcdf-1f27-46f4-b67f-b7a27c5f02e0",
            "detail_level": "medium",
            "structured_type": "structured"
        },
        "timestamp": "2025-08-16 22:59:33.000",
        "id": "tt6hu1Rrv5OsHoLpJcUU"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "08eddcdf-1f27-46f4-b67f-b7a27c5f02e0",
            "mapping_index": 3,
            "structured_type": "structured",
            "detail_level": "medium"
        },
        "timestamp": "2025-08-16 22:59:34.000",
        "id": "7sJUmZBYXdACjXw2cfxM"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "08eddcdf-1f27-46f4-b67f-b7a27c5f02e0",
            "detail_level": "medium",
            "structured_type": "structured"
        },
        "timestamp": "2025-08-16 22:59:34.000",
        "id": "ASFWlPRW5ZwG8OipHP4v"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "08eddcdf-1f27-46f4-b67f-b7a27c5f02e0",
            "detail_level": "medium",
            "structured_type": "structured"
        },
        "timestamp": "2025-08-16 22:59:34.000",
        "id": "YH6KXr5jyOAAAlfxvk15"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "08eddcdf-1f27-46f4-b67f-b7a27c5f02e0",
            "mapping_index": 4,
            "structured_type": "structured",
            "detail_level": "medium"
        },
        "timestamp": "2025-08-16 22:59:34.000",
        "id": "ZcSUtcsL0zDps2BC7Pa8"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "08eddcdf-1f27-46f4-b67f-b7a27c5f02e0",
            "mapping_index": 2,
            "structured_type": "structured",
            "detail_level": "medium"
        },
        "timestamp": "2025-08-16 22:59:34.000",
        "id": "mXXQNVICGYE9YMOWoNjm"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "08eddcdf-1f27-46f4-b67f-b7a27c5f02e0",
            "mapping_index": 2,
            "structured_type": "structured",
            "detail_level": "medium"
        },
        "timestamp": "2025-08-16 22:59:35.000",
        "id": "5NxyW15DYM2oP4inOk99"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "08eddcdf-1f27-46f4-b67f-b7a27c5f02e0",
            "mapping_index": 1,
            "structured_type": "structured",
            "detail_level": "medium"
        },
        "timestamp": "2025-08-16 22:59:35.000",
        "id": "UBvVCgoJ5SAeTqezQTfp"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "08eddcdf-1f27-46f4-b67f-b7a27c5f02e0",
            "detail_level": "medium",
            "structured_type": "structured"
        },
        "timestamp": "2025-08-16 22:59:35.000",
        "id": "bU6V4WzVNwfU5u3cNai1"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "08eddcdf-1f27-46f4-b67f-b7a27c5f02e0",
            "detail_level": "medium",
            "structured_type": "structured"
        },
        "timestamp": "2025-08-16 22:59:35.000",
        "id": "tx7o5euZUXfdkLWytYtS"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "08eddcdf-1f27-46f4-b67f-b7a27c5f02e0",
            "mapping_index": 2,
            "structured_type": "structured",
            "detail_level": "medium"
        },
        "timestamp": "2025-08-16 22:59:38.000",
        "id": "5Vj5epFmhbhAdoQpD248"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "08eddcdf-1f27-46f4-b67f-b7a27c5f02e0",
            "detail_level": "medium",
            "structured_type": "structured"
        },
        "timestamp": "2025-08-16 22:59:38.000",
        "id": "BtYQ2KsLLd7cEZA2lr47"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "08eddcdf-1f27-46f4-b67f-b7a27c5f02e0",
            "detail_level": "medium",
            "structured_type": "structured"
        },
        "timestamp": "2025-08-16 22:59:38.000",
        "id": "PFwI9Z5bWHWbML2vQzKn"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "08eddcdf-1f27-46f4-b67f-b7a27c5f02e0",
            "mapping_index": 3,
            "structured_type": "structured",
            "detail_level": "medium"
        },
        "timestamp": "2025-08-16 22:59:38.000",
        "id": "uStpq5U4jAV15A0F3hs4"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "08eddcdf-1f27-46f4-b67f-b7a27c5f02e0",
            "detail_level": "medium",
            "structured_type": "structured"
        },
        "timestamp": "2025-08-16 22:59:39.000",
        "id": "PccxAwJqmDrtUvi8oHPp"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "08eddcdf-1f27-46f4-b67f-b7a27c5f02e0",
            "mapping_index": 3,
            "structured_type": "structured",
            "detail_level": "medium"
        },
        "timestamp": "2025-08-16 22:59:39.000",
        "id": "RCQuCZKbLWGqsbhtabwT"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "08eddcdf-1f27-46f4-b67f-b7a27c5f02e0",
            "mapping_index": 4,
            "structured_type": "structured",
            "detail_level": "medium"
        },
        "timestamp": "2025-08-16 22:59:39.000",
        "id": "Z9PkV8M5aRGaCLAAImXM"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "08eddcdf-1f27-46f4-b67f-b7a27c5f02e0",
            "detail_level": "medium",
            "structured_type": "structured"
        },
        "timestamp": "2025-08-16 22:59:39.000",
        "id": "cvO5Kk0QmL1NP4GR1tkM"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "08eddcdf-1f27-46f4-b67f-b7a27c5f02e0",
            "detail_level": "medium",
            "structured_type": "structured"
        },
        "timestamp": "2025-08-16 22:59:39.000",
        "id": "zWBWPENL5uPVfEvU9YyN"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "08eddcdf-1f27-46f4-b67f-b7a27c5f02e0",
            "mapping_index": 4,
            "structured_type": "structured",
            "detail_level": "medium"
        },
        "timestamp": "2025-08-16 22:59:42.000",
        "id": "fngdt2RWquE32qfOsDHB"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "08eddcdf-1f27-46f4-b67f-b7a27c5f02e0",
            "detail_level": "medium",
            "structured_type": "structured"
        },
        "timestamp": "2025-08-16 22:59:43.000",
        "id": "3XbvOH4F9aTL2Lo63iJ0"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "08eddcdf-1f27-46f4-b67f-b7a27c5f02e0",
            "mapping_index": 0,
            "structured_type": "structured",
            "detail_level": "medium"
        },
        "timestamp": "2025-08-16 22:59:43.000",
        "id": "41VwgjiQ5CplktzP3bN2"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "08eddcdf-1f27-46f4-b67f-b7a27c5f02e0",
            "detail_level": "medium",
            "structured_type": "structured"
        },
        "timestamp": "2025-08-16 22:59:43.000",
        "id": "9C30XdlkwIoN7jwTpSNv"
    },
    {
        "source": "frontend",
        "event": "change_summary_level",
        "data": {
            "before_detail_level": "medium",
            "section_id": "08eddcdf-1f27-46f4-b67f-b7a27c5f02e0",
            "before_structured": "structured",
            "after_structured": "structured",
            "after_detail_level": "high"
        },
        "timestamp": "2025-08-16 22:59:43.000",
        "id": "9n4zxBMSWivqhtc1afAP"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "08eddcdf-1f27-46f4-b67f-b7a27c5f02e0",
            "mapping_index": 2,
            "structured_type": "structured",
            "detail_level": "medium"
        },
        "timestamp": "2025-08-16 22:59:43.000",
        "id": "I3RDTySABCb0Ty73drMJ"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "08eddcdf-1f27-46f4-b67f-b7a27c5f02e0",
            "mapping_index": 3,
            "structured_type": "structured",
            "detail_level": "medium"
        },
        "timestamp": "2025-08-16 22:59:43.000",
        "id": "P9Mlw7KM9nL9FyxfmgZR"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "08eddcdf-1f27-46f4-b67f-b7a27c5f02e0",
            "detail_level": "medium",
            "structured_type": "structured"
        },
        "timestamp": "2025-08-16 22:59:43.000",
        "id": "Q6bT3LlxgeEGV8algVT0"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "08eddcdf-1f27-46f4-b67f-b7a27c5f02e0",
            "detail_level": "medium",
            "structured_type": "structured"
        },
        "timestamp": "2025-08-16 22:59:43.000",
        "id": "QE0LkJ7ZTjw01hPBnFY5"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "08eddcdf-1f27-46f4-b67f-b7a27c5f02e0",
            "detail_level": "medium",
            "structured_type": "structured"
        },
        "timestamp": "2025-08-16 22:59:43.000",
        "id": "cRgffjjwpfvl0AzUQT65"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "08eddcdf-1f27-46f4-b67f-b7a27c5f02e0",
            "mapping_index": 1,
            "structured_type": "structured",
            "detail_level": "medium"
        },
        "timestamp": "2025-08-16 22:59:43.000",
        "id": "pHjiHifvkOZBiiPxscf9"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "08eddcdf-1f27-46f4-b67f-b7a27c5f02e0",
            "mapping_index": 1,
            "structured_type": "structured",
            "detail_level": "high"
        },
        "timestamp": "2025-08-16 22:59:47.000",
        "id": "BAdvZuSGpfBpF1qYtmmN"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "08eddcdf-1f27-46f4-b67f-b7a27c5f02e0",
            "detail_level": "high",
            "structured_type": "structured"
        },
        "timestamp": "2025-08-16 22:59:47.000",
        "id": "EC5TxdYuDDSxTgQZDpyN"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "08eddcdf-1f27-46f4-b67f-b7a27c5f02e0",
            "mapping_index": 2,
            "structured_type": "structured",
            "detail_level": "high"
        },
        "timestamp": "2025-08-16 22:59:47.000",
        "id": "J3ohWwmPsjBpLSolsii9"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "08eddcdf-1f27-46f4-b67f-b7a27c5f02e0",
            "mapping_index": 3,
            "structured_type": "structured",
            "detail_level": "high"
        },
        "timestamp": "2025-08-16 22:59:47.000",
        "id": "Ty7gCjsDWPgdmtq1YFx8"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "08eddcdf-1f27-46f4-b67f-b7a27c5f02e0",
            "mapping_index": 4,
            "structured_type": "structured",
            "detail_level": "high"
        },
        "timestamp": "2025-08-16 22:59:47.000",
        "id": "UNdJj8pcM7OpTUXQzH9D"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "08eddcdf-1f27-46f4-b67f-b7a27c5f02e0",
            "mapping_index": 5,
            "structured_type": "structured",
            "detail_level": "high"
        },
        "timestamp": "2025-08-16 22:59:47.000",
        "id": "dCoNUgE57IsNoRt4n2wa"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "08eddcdf-1f27-46f4-b67f-b7a27c5f02e0",
            "detail_level": "high",
            "structured_type": "structured"
        },
        "timestamp": "2025-08-16 22:59:47.000",
        "id": "gCKGDEz4jj4xSbxA8tyX"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "08eddcdf-1f27-46f4-b67f-b7a27c5f02e0",
            "detail_level": "high",
            "structured_type": "structured"
        },
        "timestamp": "2025-08-16 22:59:47.000",
        "id": "jt6CyzsDLnP1lSJ0ip6a"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "08eddcdf-1f27-46f4-b67f-b7a27c5f02e0",
            "detail_level": "high",
            "structured_type": "structured"
        },
        "timestamp": "2025-08-16 22:59:47.000",
        "id": "khtfYTS3OlMYBRbxbCsr"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "08eddcdf-1f27-46f4-b67f-b7a27c5f02e0",
            "detail_level": "high",
            "structured_type": "structured"
        },
        "timestamp": "2025-08-16 22:59:49.000",
        "id": "M43iPN5iOrQFk78tQUWq"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "08eddcdf-1f27-46f4-b67f-b7a27c5f02e0",
            "mapping_index": 6,
            "structured_type": "structured",
            "detail_level": "high"
        },
        "timestamp": "2025-08-16 22:59:49.000",
        "id": "QtsZokuRXvs63DhC3APV"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "08eddcdf-1f27-46f4-b67f-b7a27c5f02e0",
            "mapping_index": 5,
            "structured_type": "structured",
            "detail_level": "high"
        },
        "timestamp": "2025-08-16 22:59:50.000",
        "id": "8C5fZCwO8dwWPisRdMPi"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "08eddcdf-1f27-46f4-b67f-b7a27c5f02e0",
            "detail_level": "high",
            "structured_type": "structured"
        },
        "timestamp": "2025-08-16 22:59:50.000",
        "id": "9C5pI8SNJJkiBJ9Cznut"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "08eddcdf-1f27-46f4-b67f-b7a27c5f02e0",
            "detail_level": "high",
            "structured_type": "structured"
        },
        "timestamp": "2025-08-16 22:59:50.000",
        "id": "Aha8OEv7xeXCO0Vhr4bw"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "08eddcdf-1f27-46f4-b67f-b7a27c5f02e0",
            "mapping_index": 5,
            "structured_type": "structured",
            "detail_level": "high"
        },
        "timestamp": "2025-08-16 22:59:51.000",
        "id": "NwCK7E4CUUXXxVJX8t2w"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "08eddcdf-1f27-46f4-b67f-b7a27c5f02e0",
            "mapping_index": 5,
            "structured_type": "structured",
            "detail_level": "high"
        },
        "timestamp": "2025-08-16 22:59:52.000",
        "id": "7q4mt3zLn2LIfPUcAzhv"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "08eddcdf-1f27-46f4-b67f-b7a27c5f02e0",
            "detail_level": "high",
            "structured_type": "structured"
        },
        "timestamp": "2025-08-16 22:59:52.000",
        "id": "diMkKFyyOW58RWcmAvaD"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "08eddcdf-1f27-46f4-b67f-b7a27c5f02e0",
            "mapping_index": 6,
            "structured_type": "structured",
            "detail_level": "high"
        },
        "timestamp": "2025-08-16 22:59:53.000",
        "id": "2Yu0mscwfQeLpAfm7Snp"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "08eddcdf-1f27-46f4-b67f-b7a27c5f02e0",
            "detail_level": "high",
            "structured_type": "structured"
        },
        "timestamp": "2025-08-16 22:59:53.000",
        "id": "JTXOQTZme4Z5vHNi76gR"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "08eddcdf-1f27-46f4-b67f-b7a27c5f02e0",
            "detail_level": "high",
            "structured_type": "structured"
        },
        "timestamp": "2025-08-16 22:59:53.000",
        "id": "XetFbicLcjaSzmXGEGXv"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "08eddcdf-1f27-46f4-b67f-b7a27c5f02e0",
            "detail_level": "high",
            "structured_type": "structured"
        },
        "timestamp": "2025-08-16 22:59:54.000",
        "id": "aKpL59IJLKzWgvWS9OG8"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "08eddcdf-1f27-46f4-b67f-b7a27c5f02e0",
            "detail_level": "high",
            "structured_type": "structured"
        },
        "timestamp": "2025-08-16 22:59:54.000",
        "id": "dNP9dbw4IComkLKshl2g"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "08eddcdf-1f27-46f4-b67f-b7a27c5f02e0",
            "mapping_index": 5,
            "structured_type": "structured",
            "detail_level": "high"
        },
        "timestamp": "2025-08-16 22:59:54.000",
        "id": "maohy7IDat3Gj5KxVq1Q"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "08eddcdf-1f27-46f4-b67f-b7a27c5f02e0",
            "mapping_index": 5,
            "structured_type": "structured",
            "detail_level": "high"
        },
        "timestamp": "2025-08-16 22:59:54.000",
        "id": "vKXzMBlCp98Ln3OKKgCT"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "08eddcdf-1f27-46f4-b67f-b7a27c5f02e0",
            "mapping_index": 6,
            "structured_type": "structured",
            "detail_level": "high"
        },
        "timestamp": "2025-08-16 22:59:54.000",
        "id": "xxjkfV8kQ9s7KIulxQN3"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "08eddcdf-1f27-46f4-b67f-b7a27c5f02e0",
            "mapping_index": 7,
            "structured_type": "structured",
            "detail_level": "high"
        },
        "timestamp": "2025-08-16 22:59:55.000",
        "id": "0hygRHcn5fYQKGRWigB4"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "08eddcdf-1f27-46f4-b67f-b7a27c5f02e0",
            "detail_level": "high",
            "structured_type": "structured"
        },
        "timestamp": "2025-08-16 22:59:55.000",
        "id": "64egDdhaEhXK3aMfQxMA"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "08eddcdf-1f27-46f4-b67f-b7a27c5f02e0",
            "detail_level": "high",
            "structured_type": "structured"
        },
        "timestamp": "2025-08-16 22:59:55.000",
        "id": "9MoUBYqIfib7354JfB7G"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "08eddcdf-1f27-46f4-b67f-b7a27c5f02e0",
            "detail_level": "high",
            "structured_type": "structured"
        },
        "timestamp": "2025-08-16 22:59:55.000",
        "id": "MdPkeTsHjNcv8WaxB5DW"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "08eddcdf-1f27-46f4-b67f-b7a27c5f02e0",
            "mapping_index": 6,
            "structured_type": "structured",
            "detail_level": "high"
        },
        "timestamp": "2025-08-16 22:59:55.000",
        "id": "pFAQYLhbhklArNfaLMC3"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "08eddcdf-1f27-46f4-b67f-b7a27c5f02e0",
            "mapping_index": 7,
            "structured_type": "structured",
            "detail_level": "high"
        },
        "timestamp": "2025-08-16 22:59:56.000",
        "id": "1xWbZBGiYYKRKZcad5HD"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "08eddcdf-1f27-46f4-b67f-b7a27c5f02e0",
            "mapping_index": 5,
            "structured_type": "structured",
            "detail_level": "high"
        },
        "timestamp": "2025-08-16 22:59:56.000",
        "id": "CjBcEmoaJpwUJw9Lc0LV"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "08eddcdf-1f27-46f4-b67f-b7a27c5f02e0",
            "mapping_index": 6,
            "structured_type": "structured",
            "detail_level": "high"
        },
        "timestamp": "2025-08-16 22:59:56.000",
        "id": "InalSUEeY860DNlCDKSn"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "08eddcdf-1f27-46f4-b67f-b7a27c5f02e0",
            "detail_level": "high",
            "structured_type": "structured"
        },
        "timestamp": "2025-08-16 22:59:56.000",
        "id": "g02s3KcYJvLMYyt8bQCL"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "08eddcdf-1f27-46f4-b67f-b7a27c5f02e0",
            "detail_level": "high",
            "structured_type": "structured"
        },
        "timestamp": "2025-08-16 22:59:56.000",
        "id": "saBsjOpckVQwmPuJo1CC"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "08eddcdf-1f27-46f4-b67f-b7a27c5f02e0",
            "detail_level": "high",
            "structured_type": "structured"
        },
        "timestamp": "2025-08-16 22:59:57.000",
        "id": "1VJpjJ1ueBj1xY2RniEp"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "08eddcdf-1f27-46f4-b67f-b7a27c5f02e0",
            "mapping_index": 6,
            "structured_type": "structured",
            "detail_level": "high"
        },
        "timestamp": "2025-08-16 22:59:57.000",
        "id": "91ksjBA3IlyquI1rAwfh"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "08eddcdf-1f27-46f4-b67f-b7a27c5f02e0",
            "detail_level": "high",
            "structured_type": "structured"
        },
        "timestamp": "2025-08-16 22:59:57.000",
        "id": "DtqkV5WzQ3eVNRNAKkys"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "08eddcdf-1f27-46f4-b67f-b7a27c5f02e0",
            "detail_level": "high",
            "structured_type": "structured"
        },
        "timestamp": "2025-08-16 22:59:57.000",
        "id": "GYBY6Sjhba3bGl0qB0OC"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "08eddcdf-1f27-46f4-b67f-b7a27c5f02e0",
            "mapping_index": 8,
            "structured_type": "structured",
            "detail_level": "high"
        },
        "timestamp": "2025-08-16 22:59:57.000",
        "id": "N08Ynhi22TLPGYWszByT"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "08eddcdf-1f27-46f4-b67f-b7a27c5f02e0",
            "detail_level": "high",
            "structured_type": "structured"
        },
        "timestamp": "2025-08-16 22:59:57.000",
        "id": "U3PDsOTLQgwRYSCcPU53"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "08eddcdf-1f27-46f4-b67f-b7a27c5f02e0",
            "mapping_index": 5,
            "structured_type": "structured",
            "detail_level": "high"
        },
        "timestamp": "2025-08-16 22:59:57.000",
        "id": "derTQC0cXkSj2TkeTvDK"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "08eddcdf-1f27-46f4-b67f-b7a27c5f02e0",
            "mapping_index": 7,
            "structured_type": "structured",
            "detail_level": "high"
        },
        "timestamp": "2025-08-16 22:59:57.000",
        "id": "hG1MMGInfpIcYSvovWBz"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "08eddcdf-1f27-46f4-b67f-b7a27c5f02e0",
            "detail_level": "high",
            "structured_type": "structured"
        },
        "timestamp": "2025-08-16 22:59:57.000",
        "id": "lzaqWMx93CpdoVU2JFFL"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "08eddcdf-1f27-46f4-b67f-b7a27c5f02e0",
            "mapping_index": 8,
            "structured_type": "structured",
            "detail_level": "high"
        },
        "timestamp": "2025-08-16 23:00:01.000",
        "id": "dI28YYzNF9uIHojAepAR"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "08eddcdf-1f27-46f4-b67f-b7a27c5f02e0",
            "detail_level": "high",
            "structured_type": "structured"
        },
        "timestamp": "2025-08-16 23:00:02.000",
        "id": "D4XvIDy3UOcglodjmOyD"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "08eddcdf-1f27-46f4-b67f-b7a27c5f02e0",
            "detail_level": "high",
            "structured_type": "structured"
        },
        "timestamp": "2025-08-16 23:00:02.000",
        "id": "ZIkt854ytlBAT0n7DOGn"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "08eddcdf-1f27-46f4-b67f-b7a27c5f02e0",
            "mapping_index": 6,
            "structured_type": "structured",
            "detail_level": "high"
        },
        "timestamp": "2025-08-16 23:00:02.000",
        "id": "cT4o0hBUuyqRsWg1X2vI"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "08eddcdf-1f27-46f4-b67f-b7a27c5f02e0",
            "mapping_index": 7,
            "structured_type": "structured",
            "detail_level": "high"
        },
        "timestamp": "2025-08-16 23:00:02.000",
        "id": "h1MIPthcguMuR67F4ioh"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "08eddcdf-1f27-46f4-b67f-b7a27c5f02e0",
            "detail_level": "high",
            "structured_type": "structured"
        },
        "timestamp": "2025-08-16 23:00:02.000",
        "id": "xGBL1v8LFXBd0HYO5yAV"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "08eddcdf-1f27-46f4-b67f-b7a27c5f02e0",
            "mapping_index": 5,
            "structured_type": "structured",
            "detail_level": "high"
        },
        "timestamp": "2025-08-16 23:00:02.000",
        "id": "xySRkED3XfSx223PdED5"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "08eddcdf-1f27-46f4-b67f-b7a27c5f02e0",
            "detail_level": "high",
            "structured_type": "structured"
        },
        "timestamp": "2025-08-16 23:00:05.000",
        "id": "3PHFn6XEP1zlZRpgqH3L"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "08eddcdf-1f27-46f4-b67f-b7a27c5f02e0",
            "mapping_index": 6,
            "structured_type": "structured",
            "detail_level": "high"
        },
        "timestamp": "2025-08-16 23:00:05.000",
        "id": "3Z4ZNAq2j5yLCoks3qkT"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "08eddcdf-1f27-46f4-b67f-b7a27c5f02e0",
            "detail_level": "high",
            "structured_type": "structured"
        },
        "timestamp": "2025-08-16 23:00:05.000",
        "id": "GFksqaDT3Nmf696gPXUM"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "08eddcdf-1f27-46f4-b67f-b7a27c5f02e0",
            "mapping_index": 5,
            "structured_type": "structured",
            "detail_level": "high"
        },
        "timestamp": "2025-08-16 23:00:05.000",
        "id": "mtqsMMi8robGopg3oOjG"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "08eddcdf-1f27-46f4-b67f-b7a27c5f02e0",
            "detail_level": "high",
            "structured_type": "structured"
        },
        "timestamp": "2025-08-16 23:00:06.000",
        "id": "OrMlJogfM2P9yqVmXsCj"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "08eddcdf-1f27-46f4-b67f-b7a27c5f02e0",
            "detail_level": "high",
            "structured_type": "structured"
        },
        "timestamp": "2025-08-16 23:00:06.000",
        "id": "ZDhhFtOPR7bHBPTapcCx"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "08eddcdf-1f27-46f4-b67f-b7a27c5f02e0",
            "mapping_index": 6,
            "structured_type": "structured",
            "detail_level": "high"
        },
        "timestamp": "2025-08-16 23:00:06.000",
        "id": "ojD2lJapU8qIgT7uQP47"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "08eddcdf-1f27-46f4-b67f-b7a27c5f02e0",
            "detail_level": "high",
            "structured_type": "structured"
        },
        "timestamp": "2025-08-16 23:00:36.000",
        "id": "D0DvAfnO5peOpWvHUBx7"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "08eddcdf-1f27-46f4-b67f-b7a27c5f02e0",
            "mapping_index": 9,
            "structured_type": "structured",
            "detail_level": "high"
        },
        "timestamp": "2025-08-16 23:00:36.000",
        "id": "gyKo5ABr7WkRbVmgjjef"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "08eddcdf-1f27-46f4-b67f-b7a27c5f02e0",
            "detail_level": "high",
            "structured_type": "structured"
        },
        "timestamp": "2025-08-16 23:00:37.000",
        "id": "1NqadeAT95egGwIboOyZ"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "08eddcdf-1f27-46f4-b67f-b7a27c5f02e0",
            "mapping_index": 6,
            "structured_type": "structured",
            "detail_level": "high"
        },
        "timestamp": "2025-08-16 23:00:37.000",
        "id": "1QppATFzVljNBVQBLyYN"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "08eddcdf-1f27-46f4-b67f-b7a27c5f02e0",
            "mapping_index": 5,
            "structured_type": "structured",
            "detail_level": "high"
        },
        "timestamp": "2025-08-16 23:00:37.000",
        "id": "1lQhmQSRp4HNoqASjqeY"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "08eddcdf-1f27-46f4-b67f-b7a27c5f02e0",
            "detail_level": "high",
            "structured_type": "structured"
        },
        "timestamp": "2025-08-16 23:00:37.000",
        "id": "2nY7x9sfqoCQPNtpFbXj"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "08eddcdf-1f27-46f4-b67f-b7a27c5f02e0",
            "mapping_index": 9,
            "structured_type": "structured",
            "detail_level": "high"
        },
        "timestamp": "2025-08-16 23:00:37.000",
        "id": "9UFoWiF3gyThHz1VQm1C"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "08eddcdf-1f27-46f4-b67f-b7a27c5f02e0",
            "mapping_index": 3,
            "structured_type": "structured",
            "detail_level": "high"
        },
        "timestamp": "2025-08-16 23:00:37.000",
        "id": "K3HNgU2j7Zlc7zsqW7Mz"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "08eddcdf-1f27-46f4-b67f-b7a27c5f02e0",
            "detail_level": "high",
            "structured_type": "structured"
        },
        "timestamp": "2025-08-16 23:00:37.000",
        "id": "LgDtQzCJa228oXhl95lK"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "08eddcdf-1f27-46f4-b67f-b7a27c5f02e0",
            "mapping_index": 1,
            "structured_type": "structured",
            "detail_level": "high"
        },
        "timestamp": "2025-08-16 23:00:37.000",
        "id": "Mkvg5saKpeskFggF0kh3"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "08eddcdf-1f27-46f4-b67f-b7a27c5f02e0",
            "mapping_index": 7,
            "structured_type": "structured",
            "detail_level": "high"
        },
        "timestamp": "2025-08-16 23:00:37.000",
        "id": "MtNQzvIZfJ5XfzgOKxzz"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "08eddcdf-1f27-46f4-b67f-b7a27c5f02e0",
            "detail_level": "high",
            "structured_type": "structured"
        },
        "timestamp": "2025-08-16 23:00:37.000",
        "id": "RQ5GAm7rsSvqM7aUPqdt"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "08eddcdf-1f27-46f4-b67f-b7a27c5f02e0",
            "detail_level": "high",
            "structured_type": "structured"
        },
        "timestamp": "2025-08-16 23:00:37.000",
        "id": "SL86DYTj2Kn2NbpT7ezC"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "08eddcdf-1f27-46f4-b67f-b7a27c5f02e0",
            "detail_level": "high",
            "structured_type": "structured"
        },
        "timestamp": "2025-08-16 23:00:37.000",
        "id": "SS1N8K2198WIKOQdDhLX"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "08eddcdf-1f27-46f4-b67f-b7a27c5f02e0",
            "detail_level": "high",
            "structured_type": "structured"
        },
        "timestamp": "2025-08-16 23:00:37.000",
        "id": "TR4xmMFxxfn8lLxY0xkG"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "08eddcdf-1f27-46f4-b67f-b7a27c5f02e0",
            "detail_level": "high",
            "structured_type": "structured"
        },
        "timestamp": "2025-08-16 23:00:37.000",
        "id": "WWbHMBKOxvtIjlO97URk"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "08eddcdf-1f27-46f4-b67f-b7a27c5f02e0",
            "mapping_index": 0,
            "structured_type": "structured",
            "detail_level": "high"
        },
        "timestamp": "2025-08-16 23:00:37.000",
        "id": "a47QMU9dsnrqyWdsalLL"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "08eddcdf-1f27-46f4-b67f-b7a27c5f02e0",
            "mapping_index": 8,
            "structured_type": "structured",
            "detail_level": "high"
        },
        "timestamp": "2025-08-16 23:00:37.000",
        "id": "a9SGYKhH1xSch1d04xvU"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "08eddcdf-1f27-46f4-b67f-b7a27c5f02e0",
            "detail_level": "high",
            "structured_type": "structured"
        },
        "timestamp": "2025-08-16 23:00:37.000",
        "id": "g302bcQkfbbgEa120VaO"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "08eddcdf-1f27-46f4-b67f-b7a27c5f02e0",
            "detail_level": "high",
            "structured_type": "structured"
        },
        "timestamp": "2025-08-16 23:00:37.000",
        "id": "jd3o7U8DMzp0uUlaF8Ki"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "08eddcdf-1f27-46f4-b67f-b7a27c5f02e0",
            "mapping_index": 4,
            "structured_type": "structured",
            "detail_level": "high"
        },
        "timestamp": "2025-08-16 23:00:37.000",
        "id": "sHbE9qXH9V7VgkVz5sL9"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "08eddcdf-1f27-46f4-b67f-b7a27c5f02e0",
            "mapping_index": 2,
            "structured_type": "structured",
            "detail_level": "high"
        },
        "timestamp": "2025-08-16 23:00:37.000",
        "id": "uoIM8STTJf7al6dRcMsG"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "08eddcdf-1f27-46f4-b67f-b7a27c5f02e0",
            "mapping_index": 2,
            "structured_type": "structured",
            "detail_level": "high"
        },
        "timestamp": "2025-08-16 23:00:39.000",
        "id": "Bj6bJHyoxmjZZrr7lQfH"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "08eddcdf-1f27-46f4-b67f-b7a27c5f02e0",
            "detail_level": "high",
            "structured_type": "structured"
        },
        "timestamp": "2025-08-16 23:00:39.000",
        "id": "EYnqsx7vSObPsxlQWHrE"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "08eddcdf-1f27-46f4-b67f-b7a27c5f02e0",
            "mapping_index": 1,
            "structured_type": "structured",
            "detail_level": "high"
        },
        "timestamp": "2025-08-16 23:00:39.000",
        "id": "NpMeZhafFT6j42G9nh76"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "08eddcdf-1f27-46f4-b67f-b7a27c5f02e0",
            "mapping_index": 0,
            "structured_type": "structured",
            "detail_level": "high"
        },
        "timestamp": "2025-08-16 23:00:39.000",
        "id": "PdZfgOrcBmAq8hyzeAqK"
    },
    {
        "source": "frontend",
        "event": "change_summary_level",
        "data": {
            "before_detail_level": "medium",
            "section_id": "08eddcdf-1f27-46f4-b67f-b7a27c5f02e0",
            "before_structured": "structured",
            "after_structured": "structured",
            "after_detail_level": "high"
        },
        "timestamp": "2025-08-16 23:00:39.000",
        "id": "hbfYiYM9vSTmuko63sax"
    },
    {
        "source": "frontend",
        "event": "change_summary_level",
        "data": {
            "before_detail_level": "high",
            "section_id": "08eddcdf-1f27-46f4-b67f-b7a27c5f02e0",
            "before_structured": "structured",
            "after_structured": "structured",
            "after_detail_level": "medium"
        },
        "timestamp": "2025-08-16 23:00:39.000",
        "id": "iopu2cqRdIl3DObr74C1"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "08eddcdf-1f27-46f4-b67f-b7a27c5f02e0",
            "detail_level": "high",
            "structured_type": "structured"
        },
        "timestamp": "2025-08-16 23:00:39.000",
        "id": "qH4pwWVyS6nnDYWcfrZV"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "08eddcdf-1f27-46f4-b67f-b7a27c5f02e0",
            "detail_level": "high",
            "structured_type": "structured"
        },
        "timestamp": "2025-08-16 23:00:39.000",
        "id": "yLeJUb4z8NFfBkM03ZYK"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "08eddcdf-1f27-46f4-b67f-b7a27c5f02e0",
            "detail_level": "high",
            "structured_type": "structured"
        },
        "timestamp": "2025-08-16 23:00:45.000",
        "id": "DVJInpA4jDSnCuB7OmHz"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "08eddcdf-1f27-46f4-b67f-b7a27c5f02e0",
            "mapping_index": 9,
            "structured_type": "structured",
            "detail_level": "high"
        },
        "timestamp": "2025-08-16 23:00:45.000",
        "id": "YPrtCDOwL3CP8eWo8J2n"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "08eddcdf-1f27-46f4-b67f-b7a27c5f02e0",
            "detail_level": "high",
            "structured_type": "structured"
        },
        "timestamp": "2025-08-16 23:00:48.000",
        "id": "3DTo9MDMxYe8ma9qZwcd"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "08eddcdf-1f27-46f4-b67f-b7a27c5f02e0",
            "detail_level": "high",
            "structured_type": "structured"
        },
        "timestamp": "2025-08-16 23:00:48.000",
        "id": "5ORXia4RELCtuuzeVqq1"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "08eddcdf-1f27-46f4-b67f-b7a27c5f02e0",
            "detail_level": "high",
            "structured_type": "structured"
        },
        "timestamp": "2025-08-16 23:00:48.000",
        "id": "EGYBTwz33diHcJfJi9tX"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "08eddcdf-1f27-46f4-b67f-b7a27c5f02e0",
            "mapping_index": 4,
            "structured_type": "structured",
            "detail_level": "high"
        },
        "timestamp": "2025-08-16 23:00:48.000",
        "id": "HMSRPNI25hUWAurxOzB0"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "08eddcdf-1f27-46f4-b67f-b7a27c5f02e0",
            "detail_level": "high",
            "structured_type": "structured"
        },
        "timestamp": "2025-08-16 23:00:48.000",
        "id": "Ibc3k7xIETXZelMCk2qq"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "08eddcdf-1f27-46f4-b67f-b7a27c5f02e0",
            "mapping_index": 3,
            "structured_type": "structured",
            "detail_level": "high"
        },
        "timestamp": "2025-08-16 23:00:48.000",
        "id": "K1Gc7R3pg9TklhXxnkkl"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "08eddcdf-1f27-46f4-b67f-b7a27c5f02e0",
            "detail_level": "high",
            "structured_type": "structured"
        },
        "timestamp": "2025-08-16 23:00:48.000",
        "id": "LLmvlKrwnX8ojURq8bo5"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "08eddcdf-1f27-46f4-b67f-b7a27c5f02e0",
            "detail_level": "high",
            "structured_type": "structured"
        },
        "timestamp": "2025-08-16 23:00:48.000",
        "id": "OAla415sbijQXVX0WAjT"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "08eddcdf-1f27-46f4-b67f-b7a27c5f02e0",
            "detail_level": "high",
            "structured_type": "structured"
        },
        "timestamp": "2025-08-16 23:00:48.000",
        "id": "Uoh0XvJBQQyDnClOT1Bp"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "08eddcdf-1f27-46f4-b67f-b7a27c5f02e0",
            "mapping_index": 0,
            "structured_type": "structured",
            "detail_level": "high"
        },
        "timestamp": "2025-08-16 23:00:48.000",
        "id": "Y13El5ZsJ5y091NITzYD"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "08eddcdf-1f27-46f4-b67f-b7a27c5f02e0",
            "mapping_index": 9,
            "structured_type": "structured",
            "detail_level": "high"
        },
        "timestamp": "2025-08-16 23:00:48.000",
        "id": "ZbQKD0IB1To8C1e1R9bo"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "08eddcdf-1f27-46f4-b67f-b7a27c5f02e0",
            "detail_level": "high",
            "structured_type": "structured"
        },
        "timestamp": "2025-08-16 23:00:48.000",
        "id": "bjt9Y18Xd8k9ji4QFvZa"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "08eddcdf-1f27-46f4-b67f-b7a27c5f02e0",
            "mapping_index": 8,
            "structured_type": "structured",
            "detail_level": "high"
        },
        "timestamp": "2025-08-16 23:00:48.000",
        "id": "dcvV6HCLjFgc9p9PsYE2"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "08eddcdf-1f27-46f4-b67f-b7a27c5f02e0",
            "mapping_index": 2,
            "structured_type": "structured",
            "detail_level": "high"
        },
        "timestamp": "2025-08-16 23:00:48.000",
        "id": "df6K0iP0C8hxpuOPIV6l"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "08eddcdf-1f27-46f4-b67f-b7a27c5f02e0",
            "mapping_index": 5,
            "structured_type": "structured",
            "detail_level": "high"
        },
        "timestamp": "2025-08-16 23:00:48.000",
        "id": "hwkyvxBuAE8GQAyGCgE4"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "08eddcdf-1f27-46f4-b67f-b7a27c5f02e0",
            "detail_level": "high",
            "structured_type": "structured"
        },
        "timestamp": "2025-08-16 23:00:48.000",
        "id": "kniXducTBg1mPntlQlwl"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "08eddcdf-1f27-46f4-b67f-b7a27c5f02e0",
            "mapping_index": 7,
            "structured_type": "structured",
            "detail_level": "high"
        },
        "timestamp": "2025-08-16 23:00:48.000",
        "id": "oRadoqc7aVNPJqK35t9y"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "08eddcdf-1f27-46f4-b67f-b7a27c5f02e0",
            "mapping_index": 6,
            "structured_type": "structured",
            "detail_level": "high"
        },
        "timestamp": "2025-08-16 23:00:48.000",
        "id": "wqpeQnTtbZZTuBsdFudq"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "08eddcdf-1f27-46f4-b67f-b7a27c5f02e0",
            "detail_level": "high",
            "structured_type": "structured"
        },
        "timestamp": "2025-08-16 23:00:48.000",
        "id": "xBs6ybFkTrQ2tFq4tG1G"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "08eddcdf-1f27-46f4-b67f-b7a27c5f02e0",
            "mapping_index": 1,
            "structured_type": "structured",
            "detail_level": "high"
        },
        "timestamp": "2025-08-16 23:00:48.000",
        "id": "z6bNYsLrYdthoNGzKyIb"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "08eddcdf-1f27-46f4-b67f-b7a27c5f02e0",
            "mapping_index": 3,
            "structured_type": "structured",
            "detail_level": "medium"
        },
        "timestamp": "2025-08-16 23:00:49.000",
        "id": "0M2umMAE05ik1IPTXpmi"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "08eddcdf-1f27-46f4-b67f-b7a27c5f02e0",
            "detail_level": "medium",
            "structured_type": "structured"
        },
        "timestamp": "2025-08-16 23:00:49.000",
        "id": "7pSuUoSivxOPR9qYJuHU"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "08eddcdf-1f27-46f4-b67f-b7a27c5f02e0",
            "mapping_index": 2,
            "structured_type": "structured",
            "detail_level": "medium"
        },
        "timestamp": "2025-08-16 23:00:49.000",
        "id": "ETHgUlqaRdUmp6rSQKcA"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "08eddcdf-1f27-46f4-b67f-b7a27c5f02e0",
            "detail_level": "medium",
            "structured_type": "structured"
        },
        "timestamp": "2025-08-16 23:00:49.000",
        "id": "KKbZmKXCcdkGqmL3HxHx"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "08eddcdf-1f27-46f4-b67f-b7a27c5f02e0",
            "mapping_index": 4,
            "structured_type": "structured",
            "detail_level": "medium"
        },
        "timestamp": "2025-08-16 23:00:49.000",
        "id": "NN3f6oPzCeAtvmmOoxiF"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "08eddcdf-1f27-46f4-b67f-b7a27c5f02e0",
            "detail_level": "medium",
            "structured_type": "structured"
        },
        "timestamp": "2025-08-16 23:00:49.000",
        "id": "ZomuiSvl7TT463Ob1Oyl"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "08eddcdf-1f27-46f4-b67f-b7a27c5f02e0",
            "mapping_index": 0,
            "structured_type": "structured",
            "detail_level": "medium"
        },
        "timestamp": "2025-08-16 23:00:49.000",
        "id": "eDYT8fXnOoBbKpyL0Fvl"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "08eddcdf-1f27-46f4-b67f-b7a27c5f02e0",
            "mapping_index": 1,
            "structured_type": "structured",
            "detail_level": "medium"
        },
        "timestamp": "2025-08-16 23:00:49.000",
        "id": "hf66fndEGxJgEHVwfH7j"
    },
    {
        "source": "frontend",
        "event": "change_summary_level",
        "data": {
            "before_detail_level": "high",
            "section_id": "08eddcdf-1f27-46f4-b67f-b7a27c5f02e0",
            "before_structured": "structured",
            "after_structured": "structured",
            "after_detail_level": "medium"
        },
        "timestamp": "2025-08-16 23:00:49.000",
        "id": "npE2twcBqce7H2JWoRKB"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "08eddcdf-1f27-46f4-b67f-b7a27c5f02e0",
            "detail_level": "medium",
            "structured_type": "structured"
        },
        "timestamp": "2025-08-16 23:00:49.000",
        "id": "wk1r3K2acwTRUb1bDM9u"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "08eddcdf-1f27-46f4-b67f-b7a27c5f02e0",
            "mapping_index": 3,
            "structured_type": "structured",
            "detail_level": "medium"
        },
        "timestamp": "2025-08-16 23:00:51.000",
        "id": "AdJfSI9DdyA1CtHh0qAR"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "08eddcdf-1f27-46f4-b67f-b7a27c5f02e0",
            "detail_level": "medium",
            "structured_type": "structured"
        },
        "timestamp": "2025-08-16 23:00:51.000",
        "id": "GnLVBQjiFQXYNtE0TxJ5"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "08eddcdf-1f27-46f4-b67f-b7a27c5f02e0",
            "detail_level": "medium",
            "structured_type": "structured"
        },
        "timestamp": "2025-08-16 23:00:51.000",
        "id": "YhNA2qQcyEFPiulHFC4G"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "08eddcdf-1f27-46f4-b67f-b7a27c5f02e0",
            "mapping_index": 0,
            "structured_type": "structured",
            "detail_level": "medium"
        },
        "timestamp": "2025-08-16 23:00:51.000",
        "id": "boSgXbZcLvuDwt7b5d6b"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "08eddcdf-1f27-46f4-b67f-b7a27c5f02e0",
            "detail_level": "medium",
            "structured_type": "structured"
        },
        "timestamp": "2025-08-16 23:00:51.000",
        "id": "dkgxdwSInSbidfrktImk"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "08eddcdf-1f27-46f4-b67f-b7a27c5f02e0",
            "detail_level": "medium",
            "structured_type": "structured"
        },
        "timestamp": "2025-08-16 23:00:51.000",
        "id": "eG7H50zecOYrJRcyp3mk"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "08eddcdf-1f27-46f4-b67f-b7a27c5f02e0",
            "detail_level": "medium",
            "structured_type": "structured"
        },
        "timestamp": "2025-08-16 23:00:51.000",
        "id": "mbryNuW3Pon0FKQZ76FE"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "08eddcdf-1f27-46f4-b67f-b7a27c5f02e0",
            "mapping_index": 2,
            "structured_type": "structured",
            "detail_level": "medium"
        },
        "timestamp": "2025-08-16 23:00:51.000",
        "id": "neNGehe3YMwR45qrilAa"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "08eddcdf-1f27-46f4-b67f-b7a27c5f02e0",
            "mapping_index": 1,
            "structured_type": "structured",
            "detail_level": "medium"
        },
        "timestamp": "2025-08-16 23:00:51.000",
        "id": "yYSwtuZJTacdXsDF0nio"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "08eddcdf-1f27-46f4-b67f-b7a27c5f02e0",
            "detail_level": "high",
            "structured_type": "structured"
        },
        "timestamp": "2025-08-16 23:00:52.000",
        "id": "0H0wV9eoHYs3vaoGeUdT"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "08eddcdf-1f27-46f4-b67f-b7a27c5f02e0",
            "mapping_index": 2,
            "structured_type": "structured",
            "detail_level": "high"
        },
        "timestamp": "2025-08-16 23:00:52.000",
        "id": "0v7hUIokLrBwOCkj3U3N"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "08eddcdf-1f27-46f4-b67f-b7a27c5f02e0",
            "detail_level": "high",
            "structured_type": "structured"
        },
        "timestamp": "2025-08-16 23:00:52.000",
        "id": "4UzuzwqBT4cuvWdZckZH"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "08eddcdf-1f27-46f4-b67f-b7a27c5f02e0",
            "detail_level": "high",
            "structured_type": "structured"
        },
        "timestamp": "2025-08-16 23:00:52.000",
        "id": "4aDNDlcDmzP1QljVm17k"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "08eddcdf-1f27-46f4-b67f-b7a27c5f02e0",
            "mapping_index": 0,
            "structured_type": "structured",
            "detail_level": "high"
        },
        "timestamp": "2025-08-16 23:00:52.000",
        "id": "6Nmgvr9IFrgmpehgY2dJ"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "08eddcdf-1f27-46f4-b67f-b7a27c5f02e0",
            "mapping_index": 9,
            "structured_type": "structured",
            "detail_level": "high"
        },
        "timestamp": "2025-08-16 23:00:52.000",
        "id": "6OWKgQ221M3vt1UPjsVW"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "08eddcdf-1f27-46f4-b67f-b7a27c5f02e0",
            "detail_level": "high",
            "structured_type": "structured"
        },
        "timestamp": "2025-08-16 23:00:52.000",
        "id": "91kfmdThC1idiVVNhxEW"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "08eddcdf-1f27-46f4-b67f-b7a27c5f02e0",
            "detail_level": "high",
            "structured_type": "structured"
        },
        "timestamp": "2025-08-16 23:00:52.000",
        "id": "Cqw8NUjCpF3vqYWxDdpz"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "08eddcdf-1f27-46f4-b67f-b7a27c5f02e0",
            "detail_level": "high",
            "structured_type": "structured"
        },
        "timestamp": "2025-08-16 23:00:52.000",
        "id": "DbY5K4si35cRTLra7QJm"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "08eddcdf-1f27-46f4-b67f-b7a27c5f02e0",
            "detail_level": "high",
            "structured_type": "structured"
        },
        "timestamp": "2025-08-16 23:00:52.000",
        "id": "FkvtDG8Hd0PapYXhvDzd"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "08eddcdf-1f27-46f4-b67f-b7a27c5f02e0",
            "mapping_index": 6,
            "structured_type": "structured",
            "detail_level": "high"
        },
        "timestamp": "2025-08-16 23:00:52.000",
        "id": "KldIopGRLt9kvDUlHdPL"
    },
    {
        "source": "frontend",
        "event": "change_summary_level",
        "data": {
            "before_detail_level": "medium",
            "section_id": "08eddcdf-1f27-46f4-b67f-b7a27c5f02e0",
            "before_structured": "structured",
            "after_structured": "structured",
            "after_detail_level": "high"
        },
        "timestamp": "2025-08-16 23:00:52.000",
        "id": "N6IQmLwpM4ZLvrUlLrIE"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "08eddcdf-1f27-46f4-b67f-b7a27c5f02e0",
            "detail_level": "high",
            "structured_type": "structured"
        },
        "timestamp": "2025-08-16 23:00:52.000",
        "id": "TUNLRRdO32EKWOxEZ1O2"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "08eddcdf-1f27-46f4-b67f-b7a27c5f02e0",
            "mapping_index": 5,
            "structured_type": "structured",
            "detail_level": "high"
        },
        "timestamp": "2025-08-16 23:00:52.000",
        "id": "W11HjbODO6j8xPiMi8KK"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "08eddcdf-1f27-46f4-b67f-b7a27c5f02e0",
            "mapping_index": 3,
            "structured_type": "structured",
            "detail_level": "high"
        },
        "timestamp": "2025-08-16 23:00:52.000",
        "id": "avT7aOWIJ1TKvdJfxVIV"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "08eddcdf-1f27-46f4-b67f-b7a27c5f02e0",
            "mapping_index": 8,
            "structured_type": "structured",
            "detail_level": "high"
        },
        "timestamp": "2025-08-16 23:00:52.000",
        "id": "dSZEfg7bdLAacwntXzyi"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "08eddcdf-1f27-46f4-b67f-b7a27c5f02e0",
            "detail_level": "high",
            "structured_type": "structured"
        },
        "timestamp": "2025-08-16 23:00:52.000",
        "id": "kONhU13IMYZ6OfojMTyt"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "08eddcdf-1f27-46f4-b67f-b7a27c5f02e0",
            "mapping_index": 1,
            "structured_type": "structured",
            "detail_level": "high"
        },
        "timestamp": "2025-08-16 23:00:52.000",
        "id": "ouzMnXC0h4bZ0YCgbanE"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "08eddcdf-1f27-46f4-b67f-b7a27c5f02e0",
            "mapping_index": 4,
            "structured_type": "structured",
            "detail_level": "high"
        },
        "timestamp": "2025-08-16 23:00:52.000",
        "id": "ybGVbnXoPh5CIl1m4K2S"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "08eddcdf-1f27-46f4-b67f-b7a27c5f02e0",
            "mapping_index": 7,
            "structured_type": "structured",
            "detail_level": "high"
        },
        "timestamp": "2025-08-16 23:00:52.000",
        "id": "zj2Xeq7cz20XIt043UXk"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "08eddcdf-1f27-46f4-b67f-b7a27c5f02e0",
            "detail_level": "high",
            "structured_type": "structured"
        },
        "timestamp": "2025-08-16 23:00:53.000",
        "id": "tYy2MIUY0Ctu6bHcMmNn"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "08eddcdf-1f27-46f4-b67f-b7a27c5f02e0",
            "mapping_index": 2,
            "structured_type": "structured",
            "detail_level": "high"
        },
        "timestamp": "2025-08-16 23:01:03.000",
        "id": "Fc0SZtldAu6aW3RupdvH"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "08eddcdf-1f27-46f4-b67f-b7a27c5f02e0",
            "detail_level": "high",
            "structured_type": "structured"
        },
        "timestamp": "2025-08-16 23:01:03.000",
        "id": "HQQ4hXxXbi9EYwQdfWK1"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "08eddcdf-1f27-46f4-b67f-b7a27c5f02e0",
            "detail_level": "high",
            "structured_type": "structured"
        },
        "timestamp": "2025-08-16 23:01:03.000",
        "id": "SHONTSHKfOgRoFOYbw42"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "08eddcdf-1f27-46f4-b67f-b7a27c5f02e0",
            "detail_level": "high",
            "structured_type": "structured"
        },
        "timestamp": "2025-08-16 23:01:03.000",
        "id": "VshaRaJu47cnC4lwoQLo"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "08eddcdf-1f27-46f4-b67f-b7a27c5f02e0",
            "mapping_index": 2,
            "structured_type": "structured",
            "detail_level": "high"
        },
        "timestamp": "2025-08-16 23:01:03.000",
        "id": "Xwog27qZTlN5CHeHMzRZ"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "08eddcdf-1f27-46f4-b67f-b7a27c5f02e0",
            "mapping_index": 0,
            "structured_type": "structured",
            "detail_level": "high"
        },
        "timestamp": "2025-08-16 23:01:03.000",
        "id": "hmrAzltRde464D2qzeB7"
    },
    {
        "source": "frontend",
        "event": "click_summarize_code",
        "data": {},
        "timestamp": "2025-08-16 23:01:07.000",
        "id": "a9gDKjPzRXgpxc8SCewj"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "08eddcdf-1f27-46f4-b67f-b7a27c5f02e0",
            "mapping_index": 6,
            "structured_type": "structured",
            "detail_level": "high"
        },
        "timestamp": "2025-08-16 23:01:08.000",
        "id": "1Htalo0zkQ5Nwg3Fbxuc"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "08eddcdf-1f27-46f4-b67f-b7a27c5f02e0",
            "mapping_index": 0,
            "structured_type": "structured",
            "detail_level": "high"
        },
        "timestamp": "2025-08-16 23:01:08.000",
        "id": "2236527yW6oeQY5rKqKi"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "08eddcdf-1f27-46f4-b67f-b7a27c5f02e0",
            "detail_level": "high",
            "structured_type": "structured"
        },
        "timestamp": "2025-08-16 23:01:08.000",
        "id": "4NjwpuHZ4Ib6W5eknS1w"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "08eddcdf-1f27-46f4-b67f-b7a27c5f02e0",
            "mapping_index": 6,
            "structured_type": "structured",
            "detail_level": "high"
        },
        "timestamp": "2025-08-16 23:01:08.000",
        "id": "4qXKnYeBPbDv2IySOi7O"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "08eddcdf-1f27-46f4-b67f-b7a27c5f02e0",
            "detail_level": "high",
            "structured_type": "structured"
        },
        "timestamp": "2025-08-16 23:01:08.000",
        "id": "6a7YmeCjT19CAV5KdXyD"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "08eddcdf-1f27-46f4-b67f-b7a27c5f02e0",
            "mapping_index": 5,
            "structured_type": "structured",
            "detail_level": "high"
        },
        "timestamp": "2025-08-16 23:01:08.000",
        "id": "7Hw0e9t5lLGOmKe3XWEJ"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "08eddcdf-1f27-46f4-b67f-b7a27c5f02e0",
            "detail_level": "high",
            "structured_type": "structured"
        },
        "timestamp": "2025-08-16 23:01:08.000",
        "id": "7UGBGmEpoanHVKYcOKJZ"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "08eddcdf-1f27-46f4-b67f-b7a27c5f02e0",
            "detail_level": "high",
            "structured_type": "structured"
        },
        "timestamp": "2025-08-16 23:01:08.000",
        "id": "GBs7RXDyva6lip911aTS"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "08eddcdf-1f27-46f4-b67f-b7a27c5f02e0",
            "mapping_index": 3,
            "structured_type": "structured",
            "detail_level": "high"
        },
        "timestamp": "2025-08-16 23:01:08.000",
        "id": "ITFIXcVLiorZAJSMPUul"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "08eddcdf-1f27-46f4-b67f-b7a27c5f02e0",
            "mapping_index": 3,
            "structured_type": "structured",
            "detail_level": "high"
        },
        "timestamp": "2025-08-16 23:01:08.000",
        "id": "Jj8tGfxiufFeAWEFswLq"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "08eddcdf-1f27-46f4-b67f-b7a27c5f02e0",
            "mapping_index": 1,
            "structured_type": "structured",
            "detail_level": "high"
        },
        "timestamp": "2025-08-16 23:01:08.000",
        "id": "LFc1kZ4mzgsApX3rYGB2"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "08eddcdf-1f27-46f4-b67f-b7a27c5f02e0",
            "detail_level": "high",
            "structured_type": "structured"
        },
        "timestamp": "2025-08-16 23:01:08.000",
        "id": "QpAT7rvYDSCvvdmi32ym"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "08eddcdf-1f27-46f4-b67f-b7a27c5f02e0",
            "mapping_index": 4,
            "structured_type": "structured",
            "detail_level": "high"
        },
        "timestamp": "2025-08-16 23:01:08.000",
        "id": "Rzrub8yBhdlCR82A2Jeh"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "08eddcdf-1f27-46f4-b67f-b7a27c5f02e0",
            "detail_level": "high",
            "structured_type": "structured"
        },
        "timestamp": "2025-08-16 23:01:08.000",
        "id": "XaQYZfFoCDpw01KMxYmy"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "08eddcdf-1f27-46f4-b67f-b7a27c5f02e0",
            "detail_level": "high",
            "structured_type": "structured"
        },
        "timestamp": "2025-08-16 23:01:08.000",
        "id": "bkh4Y4LWsCM2d6UofguX"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "08eddcdf-1f27-46f4-b67f-b7a27c5f02e0",
            "detail_level": "high",
            "structured_type": "structured"
        },
        "timestamp": "2025-08-16 23:01:08.000",
        "id": "gEDXorTIQ2yYTwEItgSq"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "08eddcdf-1f27-46f4-b67f-b7a27c5f02e0",
            "mapping_index": 2,
            "structured_type": "structured",
            "detail_level": "high"
        },
        "timestamp": "2025-08-16 23:01:08.000",
        "id": "lfB3fNWCUr5ANWZpl5Zh"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "08eddcdf-1f27-46f4-b67f-b7a27c5f02e0",
            "mapping_index": 2,
            "structured_type": "structured",
            "detail_level": "high"
        },
        "timestamp": "2025-08-16 23:01:08.000",
        "id": "mTBayJ0dSVT54S61L7vF"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "08eddcdf-1f27-46f4-b67f-b7a27c5f02e0",
            "detail_level": "high",
            "structured_type": "structured"
        },
        "timestamp": "2025-08-16 23:01:08.000",
        "id": "nogSC0f9au8gJhqCIDwx"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "08eddcdf-1f27-46f4-b67f-b7a27c5f02e0",
            "detail_level": "high",
            "structured_type": "structured"
        },
        "timestamp": "2025-08-16 23:01:08.000",
        "id": "u2T7w9Jq1ejl7YxMnPjM"
    },
    {
        "source": "frontend",
        "event": "toggle_section",
        "data": {
            "before_section_id": "08eddcdf-1f27-46f4-b67f-b7a27c5f02e0",
            "after_section_id": null
        },
        "timestamp": "2025-08-16 23:01:10.000",
        "id": "sXdC4VmWTA68YpEaOgrC"
    },
    {
        "source": "backend",
        "event": "summarize_selected_code",
        "data": {
            "selected_code": "def main():\n    X, y, group, df = load_data()\n\n    # Train-test split on years\n    unique_years = df[\"Year\"].unique()\n    train_years, test_years = (\n        unique_years[:-2],  # train: 2015-2023\n        unique_years[-2:],  # test: 2024-2025\n    )\n\n    train_idx = df[\"Year\"].isin(train_years)\n    test_idx = df[\"Year\"].isin(test_years)\n\n    X_train, X_test = X[train_idx], X[test_idx]\n    y_train, y_test = y[train_idx], y[test_idx]\n\n    # Group sizes\n    train_groups = df[train_idx].groupby(\"Year\").size().to_numpy()\n    test_groups = df[test_idx].groupby(\"Year\").size().to_numpy()\n\n    # Model\n    model = XGBRanker(\n        objective=\"rank:pairwise\",\n        learning_rate=0.1,\n        n_estimators=100,\n        max_depth=4,\n        random_state=42,\n    )\n\n    print(\"Training XGBoostRanker...\")\n    model.fit(X_train, y_train, group=train_groups)\n\n    # Predict, sort, and evaluate\n    y_pred = model.predict(X_test)\n    df.loc[test_idx, \"PredictedScore\"] = y_pred\n    df.loc[test_idx, \"PredictedRank\"] = (\n        df.loc[test_idx]\n        .groupby(\"Year\")[\"PredictedScore\"]\n        .rank(ascending=False, method=\"first\")\n    )\n\n    ndcg = evaluate_ndcg(y_test.to_numpy(), y_pred, test_groups)\n    print(f\"NDCG Score on test years {test_years.tolist()}: {ndcg:.4f}\")\n\n    # Show results\n    print(df[test_idx][[\"Year\", \"Name\", \"Rank\", \"PredictedScore\", \"PredictedRank\"]])\n    plot_ranking_predictions(df, 2024)\n    plot_ranking_predictions(df, 2025)\n",
            "summary": {
                "low_structured": "• Loads data and splits it into training and test sets\n• Trains an XGBoost ranking model\n• Evaluates and visualizes predictions for test years",
                "high_unstructured": "The main() function orchestrates the MVP ranking prediction workflow. It first loads the dataset and splits it into training and test sets based on year, with the last two years reserved for testing. The function then trains an XGBoostRanker model using group-wise ranking objectives, predicts scores for the test set, and computes predicted ranks within each year. Model performance is evaluated using the NDCG metric, and detailed results, including predicted and true ranks, are printed for the test years. Finally, the function generates and saves bar plots visualizing the prediction errors for each test year.",
                "medium_unstructured": "The main() function loads MVP data, splits it into training and test sets based on years, and trains an XGBoost ranking model on the training data. It predicts rankings for the test years, evaluates the model using NDCG score, and prints the results. Finally, it generates bar plots to visualize prediction errors for the test years.",
                "high_structured": "• Loads the dataset and extracts features, target ranks, group information, and the full DataFrame\n• Splits data into training (all years except the last two) and test sets (last two years)\n  ◦ Determines train/test indices and separates features and targets accordingly\n  ◦ Computes group sizes for each year in both splits\n• Initializes and trains an XGBoostRanker model with specified hyperparameters on the training data\n• Predicts ranking scores for the test set\n  ◦ Assigns predicted scores and computes predicted ranks within each test year\n• Evaluates model performance using the NDCG score on the test set\n• Prints a summary table with year, player name, true rank, predicted score, and predicted rank for the test years\n• Generates and saves bar plots visualizing prediction errors for each of the test years",
                "title": "Summary of the main() Function for MVP Ranking Prediction",
                "low_unstructured": "This function loads data, trains an XGBoost ranking model, evaluates its performance, and visualizes prediction results for recent years.",
                "medium_structured": "• Loads data and splits it into training (all but last two years) and test sets (last two years)\n• Trains an XGBoostRanker model on the training data\n• Predicts scores and ranks for the test set\n• Evaluates model performance using NDCG score\n• Visualizes prediction errors for each test year with bar plots"
            }
        },
        "timestamp": "2025-08-16 23:01:14.000",
        "id": "u7u1RyJX3uTkD4oa7IMq"
    },
    {
        "source": "backend",
        "event": "map_summary_code",
        "data": {
            "summary": "This function loads data, trains an XGBoost ranking model, evaluates its performance, and visualizes prediction results for recent years.",
            "mapping": [
                {
                    "summaryComponent": "loads data",
                    "codeSegments": [
                        {
                            "line": 90,
                            "code": "X, y, group, df = load_data()"
                        }
                    ]
                },
                {
                    "summaryComponent": "trains an XGBoost ranking model",
                    "codeSegments": [
                        {
                            "line": 110,
                            "code": "model = XGBRanker("
                        },
                        {
                            "line": 119,
                            "code": "model.fit(X_train, y_train, group=train_groups)"
                        }
                    ]
                },
                {
                    "summaryComponent": "evaluates its performance",
                    "codeSegments": [
                        {
                            "line": 130,
                            "code": "ndcg = evaluate_ndcg(y_test.to_numpy(), y_pred, test_groups)"
                        },
                        {
                            "line": 131,
                            "code": "print(f\"NDCG Score on test years {test_years.tolist()}: {ndcg:.4f}\")"
                        }
                    ]
                },
                {
                    "summaryComponent": "visualizes prediction results for recent years",
                    "codeSegments": [
                        {
                            "line": 135,
                            "code": "plot_ranking_predictions(df, 2024)"
                        },
                        {
                            "line": 136,
                            "code": "plot_ranking_predictions(df, 2025)"
                        }
                    ]
                }
            ],
            "code": "89: def main():\n90:     X, y, group, df = load_data()\n91: \n92:     # Train-test split on years\n93:     unique_years = df[\"Year\"].unique()\n94:     train_years, test_years = (\n95:         unique_years[:-2],  # train: 2015-2023\n96:         unique_years[-2:],  # test: 2024-2025\n97:     )\n98: \n99:     train_idx = df[\"Year\"].isin(train_years)\n100:     test_idx = df[\"Year\"].isin(test_years)\n101: \n102:     X_train, X_test = X[train_idx], X[test_idx]\n103:     y_train, y_test = y[train_idx], y[test_idx]\n104: \n105:     # Group sizes\n106:     train_groups = df[train_idx].groupby(\"Year\").size().to_numpy()\n107:     test_groups = df[test_idx].groupby(\"Year\").size().to_numpy()\n108: \n109:     # Model\n110:     model = XGBRanker(\n111:         objective=\"rank:pairwise\",\n112:         learning_rate=0.1,\n113:         n_estimators=100,\n114:         max_depth=4,\n115:         random_state=42,\n116:     )\n117: \n118:     print(\"Training XGBoostRanker...\")\n119:     model.fit(X_train, y_train, group=train_groups)\n120: \n121:     # Predict, sort, and evaluate\n122:     y_pred = model.predict(X_test)\n123:     df.loc[test_idx, \"PredictedScore\"] = y_pred\n124:     df.loc[test_idx, \"PredictedRank\"] = (\n125:         df.loc[test_idx]\n126:         .groupby(\"Year\")[\"PredictedScore\"]\n127:         .rank(ascending=False, method=\"first\")\n128:     )\n129: \n130:     ndcg = evaluate_ndcg(y_test.to_numpy(), y_pred, test_groups)\n131:     print(f\"NDCG Score on test years {test_years.tolist()}: {ndcg:.4f}\")\n132: \n133:     # Show results\n134:     print(df[test_idx][[\"Year\", \"Name\", \"Rank\", \"PredictedScore\", \"PredictedRank\"]])\n135:     plot_ranking_predictions(df, 2024)\n136:     plot_ranking_predictions(df, 2025)\n137: "
        },
        "timestamp": "2025-08-16 23:01:15.000",
        "id": "3viT9FgiGITQL0rvuww9"
    },
    {
        "source": "backend",
        "event": "map_summary_code",
        "data": {
            "summary": "• Loads data and splits it into training and test sets\n• Trains an XGBoost ranking model\n• Evaluates and visualizes predictions for test years",
            "mapping": [
                {
                    "summaryComponent": "Loads data and splits it into training and test sets",
                    "codeSegments": [
                        {
                            "line": 90,
                            "code": "X, y, group, df = load_data()"
                        },
                        {
                            "line": 99,
                            "code": "train_idx = df[\"Year\"].isin(train_years)"
                        },
                        {
                            "line": 100,
                            "code": "test_idx = df[\"Year\"].isin(test_years)"
                        },
                        {
                            "line": 102,
                            "code": "X_train, X_test = X[train_idx], X[test_idx]"
                        },
                        {
                            "line": 103,
                            "code": "y_train, y_test = y[train_idx], y[test_idx]"
                        }
                    ]
                },
                {
                    "summaryComponent": "Trains an XGBoost ranking model",
                    "codeSegments": [
                        {
                            "line": 110,
                            "code": "model = XGBRanker("
                        },
                        {
                            "line": 119,
                            "code": "model.fit(X_train, y_train, group=train_groups)"
                        }
                    ]
                },
                {
                    "summaryComponent": "Evaluates and visualizes predictions for test years",
                    "codeSegments": [
                        {
                            "line": 130,
                            "code": "ndcg = evaluate_ndcg(y_test.to_numpy(), y_pred, test_groups)"
                        },
                        {
                            "line": 135,
                            "code": "plot_ranking_predictions(df, 2024)"
                        },
                        {
                            "line": 136,
                            "code": "plot_ranking_predictions(df, 2025)"
                        }
                    ]
                }
            ],
            "code": "89: def main():\n90:     X, y, group, df = load_data()\n91: \n92:     # Train-test split on years\n93:     unique_years = df[\"Year\"].unique()\n94:     train_years, test_years = (\n95:         unique_years[:-2],  # train: 2015-2023\n96:         unique_years[-2:],  # test: 2024-2025\n97:     )\n98: \n99:     train_idx = df[\"Year\"].isin(train_years)\n100:     test_idx = df[\"Year\"].isin(test_years)\n101: \n102:     X_train, X_test = X[train_idx], X[test_idx]\n103:     y_train, y_test = y[train_idx], y[test_idx]\n104: \n105:     # Group sizes\n106:     train_groups = df[train_idx].groupby(\"Year\").size().to_numpy()\n107:     test_groups = df[test_idx].groupby(\"Year\").size().to_numpy()\n108: \n109:     # Model\n110:     model = XGBRanker(\n111:         objective=\"rank:pairwise\",\n112:         learning_rate=0.1,\n113:         n_estimators=100,\n114:         max_depth=4,\n115:         random_state=42,\n116:     )\n117: \n118:     print(\"Training XGBoostRanker...\")\n119:     model.fit(X_train, y_train, group=train_groups)\n120: \n121:     # Predict, sort, and evaluate\n122:     y_pred = model.predict(X_test)\n123:     df.loc[test_idx, \"PredictedScore\"] = y_pred\n124:     df.loc[test_idx, \"PredictedRank\"] = (\n125:         df.loc[test_idx]\n126:         .groupby(\"Year\")[\"PredictedScore\"]\n127:         .rank(ascending=False, method=\"first\")\n128:     )\n129: \n130:     ndcg = evaluate_ndcg(y_test.to_numpy(), y_pred, test_groups)\n131:     print(f\"NDCG Score on test years {test_years.tolist()}: {ndcg:.4f}\")\n132: \n133:     # Show results\n134:     print(df[test_idx][[\"Year\", \"Name\", \"Rank\", \"PredictedScore\", \"PredictedRank\"]])\n135:     plot_ranking_predictions(df, 2024)\n136:     plot_ranking_predictions(df, 2025)\n137: "
        },
        "timestamp": "2025-08-16 23:01:16.000",
        "id": "4zjMp8SV1orImG8XuAqL"
    },
    {
        "source": "backend",
        "event": "map_summary_code",
        "data": {
            "summary": "The main() function loads MVP data, splits it into training and test sets based on years, and trains an XGBoost ranking model on the training data. It predicts rankings for the test years, evaluates the model using NDCG score, and prints the results. Finally, it generates bar plots to visualize prediction errors for the test years.",
            "mapping": [
                {
                    "summaryComponent": "loads MVP data",
                    "codeSegments": [
                        {
                            "line": 90,
                            "code": "X, y, group, df = load_data()"
                        }
                    ]
                },
                {
                    "summaryComponent": "splits it into training and test sets based on years",
                    "codeSegments": [
                        {
                            "line": 93,
                            "code": "unique_years = df[\"Year\"].unique()"
                        },
                        {
                            "line": 94,
                            "code": "train_years, test_years = ("
                        },
                        {
                            "line": 95,
                            "code": "unique_years[:-2],  # train: 2015-2023"
                        },
                        {
                            "line": 96,
                            "code": "unique_years[-2:],  # test: 2024-2025"
                        },
                        {
                            "line": 99,
                            "code": "train_idx = df[\"Year\"].isin(train_years)"
                        },
                        {
                            "line": 100,
                            "code": "test_idx = df[\"Year\"].isin(test_years)"
                        },
                        {
                            "line": 102,
                            "code": "X_train, X_test = X[train_idx], X[test_idx]"
                        },
                        {
                            "line": 103,
                            "code": "y_train, y_test = y[train_idx], y[test_idx]"
                        }
                    ]
                },
                {
                    "summaryComponent": "trains an XGBoost ranking model on the training data",
                    "codeSegments": [
                        {
                            "line": 110,
                            "code": "model = XGBRanker("
                        },
                        {
                            "line": 119,
                            "code": "model.fit(X_train, y_train, group=train_groups)"
                        }
                    ]
                },
                {
                    "summaryComponent": "predicts rankings for the test years",
                    "codeSegments": [
                        {
                            "line": 122,
                            "code": "y_pred = model.predict(X_test)"
                        },
                        {
                            "line": 123,
                            "code": "df.loc[test_idx, \"PredictedScore\"] = y_pred"
                        },
                        {
                            "line": 124,
                            "code": "df.loc[test_idx, \"PredictedRank\"] = ("
                        }
                    ]
                },
                {
                    "summaryComponent": "evaluates the model using NDCG score",
                    "codeSegments": [
                        {
                            "line": 130,
                            "code": "ndcg = evaluate_ndcg(y_test.to_numpy(), y_pred, test_groups)"
                        }
                    ]
                },
                {
                    "summaryComponent": "prints the results",
                    "codeSegments": [
                        {
                            "line": 131,
                            "code": "print(f\"NDCG Score on test years {test_years.tolist()}: {ndcg:.4f}\")"
                        },
                        {
                            "line": 134,
                            "code": "print(df[test_idx][[\"Year\", \"Name\", \"Rank\", \"PredictedScore\", \"PredictedRank\"]])"
                        }
                    ]
                },
                {
                    "summaryComponent": "generates bar plots to visualize prediction errors for the test years",
                    "codeSegments": [
                        {
                            "line": 135,
                            "code": "plot_ranking_predictions(df, 2024)"
                        },
                        {
                            "line": 136,
                            "code": "plot_ranking_predictions(df, 2025)"
                        }
                    ]
                }
            ],
            "code": "89: def main():\n90:     X, y, group, df = load_data()\n91: \n92:     # Train-test split on years\n93:     unique_years = df[\"Year\"].unique()\n94:     train_years, test_years = (\n95:         unique_years[:-2],  # train: 2015-2023\n96:         unique_years[-2:],  # test: 2024-2025\n97:     )\n98: \n99:     train_idx = df[\"Year\"].isin(train_years)\n100:     test_idx = df[\"Year\"].isin(test_years)\n101: \n102:     X_train, X_test = X[train_idx], X[test_idx]\n103:     y_train, y_test = y[train_idx], y[test_idx]\n104: \n105:     # Group sizes\n106:     train_groups = df[train_idx].groupby(\"Year\").size().to_numpy()\n107:     test_groups = df[test_idx].groupby(\"Year\").size().to_numpy()\n108: \n109:     # Model\n110:     model = XGBRanker(\n111:         objective=\"rank:pairwise\",\n112:         learning_rate=0.1,\n113:         n_estimators=100,\n114:         max_depth=4,\n115:         random_state=42,\n116:     )\n117: \n118:     print(\"Training XGBoostRanker...\")\n119:     model.fit(X_train, y_train, group=train_groups)\n120: \n121:     # Predict, sort, and evaluate\n122:     y_pred = model.predict(X_test)\n123:     df.loc[test_idx, \"PredictedScore\"] = y_pred\n124:     df.loc[test_idx, \"PredictedRank\"] = (\n125:         df.loc[test_idx]\n126:         .groupby(\"Year\")[\"PredictedScore\"]\n127:         .rank(ascending=False, method=\"first\")\n128:     )\n129: \n130:     ndcg = evaluate_ndcg(y_test.to_numpy(), y_pred, test_groups)\n131:     print(f\"NDCG Score on test years {test_years.tolist()}: {ndcg:.4f}\")\n132: \n133:     # Show results\n134:     print(df[test_idx][[\"Year\", \"Name\", \"Rank\", \"PredictedScore\", \"PredictedRank\"]])\n135:     plot_ranking_predictions(df, 2024)\n136:     plot_ranking_predictions(df, 2025)\n137: "
        },
        "timestamp": "2025-08-16 23:01:17.000",
        "id": "6NaA7nWbnHTWOXSj2Jwx"
    },
    {
        "source": "backend",
        "event": "map_summary_code",
        "data": {
            "summary": "• Loads data and splits it into training (all but last two years) and test sets (last two years)\n• Trains an XGBoostRanker model on the training data\n• Predicts scores and ranks for the test set\n• Evaluates model performance using NDCG score\n• Visualizes prediction errors for each test year with bar plots",
            "mapping": [
                {
                    "summaryComponent": "Loads data and splits it into training (all but last two years) and test sets (last two years)",
                    "codeSegments": [
                        {
                            "line": 90,
                            "code": "X, y, group, df = load_data()"
                        },
                        {
                            "line": 93,
                            "code": "unique_years = df[\"Year\"].unique()"
                        },
                        {
                            "line": 94,
                            "code": "train_years, test_years = ("
                        },
                        {
                            "line": 95,
                            "code": "unique_years[:-2],  # train: 2015-2023"
                        },
                        {
                            "line": 96,
                            "code": "unique_years[-2:],  # test: 2024-2025"
                        },
                        {
                            "line": 99,
                            "code": "train_idx = df[\"Year\"].isin(train_years)"
                        },
                        {
                            "line": 100,
                            "code": "test_idx = df[\"Year\"].isin(test_years)"
                        },
                        {
                            "line": 102,
                            "code": "X_train, X_test = X[train_idx], X[test_idx]"
                        },
                        {
                            "line": 103,
                            "code": "y_train, y_test = y[train_idx], y[test_idx]"
                        }
                    ]
                },
                {
                    "summaryComponent": "Trains an XGBoostRanker model on the training data",
                    "codeSegments": [
                        {
                            "line": 110,
                            "code": "model = XGBRanker("
                        },
                        {
                            "line": 119,
                            "code": "model.fit(X_train, y_train, group=train_groups)"
                        }
                    ]
                },
                {
                    "summaryComponent": "Predicts scores and ranks for the test set",
                    "codeSegments": [
                        {
                            "line": 122,
                            "code": "y_pred = model.predict(X_test)"
                        },
                        {
                            "line": 123,
                            "code": "df.loc[test_idx, \"PredictedScore\"] = y_pred"
                        },
                        {
                            "line": 124,
                            "code": "df.loc[test_idx, \"PredictedRank\"] = ("
                        },
                        {
                            "line": 125,
                            "code": "df.loc[test_idx]\n        .groupby(\"Year\")[\"PredictedScore\"]\n        .rank(ascending=False, method=\"first\")"
                        }
                    ]
                },
                {
                    "summaryComponent": "Evaluates model performance using NDCG score",
                    "codeSegments": [
                        {
                            "line": 130,
                            "code": "ndcg = evaluate_ndcg(y_test.to_numpy(), y_pred, test_groups)"
                        },
                        {
                            "line": 131,
                            "code": "print(f\"NDCG Score on test years {test_years.tolist()}: {ndcg:.4f}\")"
                        }
                    ]
                },
                {
                    "summaryComponent": "Visualizes prediction errors for each test year with bar plots",
                    "codeSegments": [
                        {
                            "line": 135,
                            "code": "plot_ranking_predictions(df, 2024)"
                        },
                        {
                            "line": 136,
                            "code": "plot_ranking_predictions(df, 2025)"
                        }
                    ]
                }
            ],
            "code": "89: def main():\n90:     X, y, group, df = load_data()\n91: \n92:     # Train-test split on years\n93:     unique_years = df[\"Year\"].unique()\n94:     train_years, test_years = (\n95:         unique_years[:-2],  # train: 2015-2023\n96:         unique_years[-2:],  # test: 2024-2025\n97:     )\n98: \n99:     train_idx = df[\"Year\"].isin(train_years)\n100:     test_idx = df[\"Year\"].isin(test_years)\n101: \n102:     X_train, X_test = X[train_idx], X[test_idx]\n103:     y_train, y_test = y[train_idx], y[test_idx]\n104: \n105:     # Group sizes\n106:     train_groups = df[train_idx].groupby(\"Year\").size().to_numpy()\n107:     test_groups = df[test_idx].groupby(\"Year\").size().to_numpy()\n108: \n109:     # Model\n110:     model = XGBRanker(\n111:         objective=\"rank:pairwise\",\n112:         learning_rate=0.1,\n113:         n_estimators=100,\n114:         max_depth=4,\n115:         random_state=42,\n116:     )\n117: \n118:     print(\"Training XGBoostRanker...\")\n119:     model.fit(X_train, y_train, group=train_groups)\n120: \n121:     # Predict, sort, and evaluate\n122:     y_pred = model.predict(X_test)\n123:     df.loc[test_idx, \"PredictedScore\"] = y_pred\n124:     df.loc[test_idx, \"PredictedRank\"] = (\n125:         df.loc[test_idx]\n126:         .groupby(\"Year\")[\"PredictedScore\"]\n127:         .rank(ascending=False, method=\"first\")\n128:     )\n129: \n130:     ndcg = evaluate_ndcg(y_test.to_numpy(), y_pred, test_groups)\n131:     print(f\"NDCG Score on test years {test_years.tolist()}: {ndcg:.4f}\")\n132: \n133:     # Show results\n134:     print(df[test_idx][[\"Year\", \"Name\", \"Rank\", \"PredictedScore\", \"PredictedRank\"]])\n135:     plot_ranking_predictions(df, 2024)\n136:     plot_ranking_predictions(df, 2025)\n137: "
        },
        "timestamp": "2025-08-16 23:01:17.000",
        "id": "VUGQgN8ALlhhH33OiLqi"
    },
    {
        "source": "backend",
        "event": "map_summary_code",
        "data": {
            "summary": "The main() function orchestrates the MVP ranking prediction workflow. It first loads the dataset and splits it into training and test sets based on year, with the last two years reserved for testing. The function then trains an XGBoostRanker model using group-wise ranking objectives, predicts scores for the test set, and computes predicted ranks within each year. Model performance is evaluated using the NDCG metric, and detailed results, including predicted and true ranks, are printed for the test years. Finally, the function generates and saves bar plots visualizing the prediction errors for each test year.",
            "mapping": [
                {
                    "summaryComponent": "The main() function orchestrates the MVP ranking prediction workflow.",
                    "codeSegments": [
                        {
                            "line": 89,
                            "code": "def main():"
                        }
                    ]
                },
                {
                    "summaryComponent": "and splits it into training and test sets based on year, with the last two years reserved for testing.",
                    "codeSegments": [
                        {
                            "line": 93,
                            "code": "unique_years = df[\"Year\"].unique()"
                        },
                        {
                            "line": 94,
                            "code": "train_years, test_years = ("
                        },
                        {
                            "line": 95,
                            "code": "    unique_years[:-2],  # train: 2015-2023"
                        },
                        {
                            "line": 96,
                            "code": "    unique_years[-2:],  # test: 2024-2025"
                        },
                        {
                            "line": 97,
                            "code": ")"
                        }
                    ]
                },
                {
                    "summaryComponent": "The function then trains an XGBoostRanker model using group-wise ranking objectives",
                    "codeSegments": [
                        {
                            "line": 110,
                            "code": "model = XGBRanker("
                        },
                        {
                            "line": 111,
                            "code": "    objective=\"rank:pairwise\","
                        },
                        {
                            "line": 119,
                            "code": "model.fit(X_train, y_train, group=train_groups)"
                        }
                    ]
                },
                {
                    "summaryComponent": "predicts scores for the test set",
                    "codeSegments": [
                        {
                            "line": 122,
                            "code": "y_pred = model.predict(X_test)"
                        }
                    ]
                },
                {
                    "summaryComponent": "and computes predicted ranks within each year.",
                    "codeSegments": [
                        {
                            "line": 124,
                            "code": "df.loc[test_idx, \"PredictedRank\"] = ("
                        },
                        {
                            "line": 125,
                            "code": "    df.loc[test_idx]"
                        },
                        {
                            "line": 126,
                            "code": "    .groupby(\"Year\")[\"PredictedScore\"]"
                        },
                        {
                            "line": 127,
                            "code": "    .rank(ascending=False, method=\"first\")"
                        }
                    ]
                },
                {
                    "summaryComponent": "Model performance is evaluated using the NDCG metric",
                    "codeSegments": [
                        {
                            "line": 130,
                            "code": "ndcg = evaluate_ndcg(y_test.to_numpy(), y_pred, test_groups)"
                        }
                    ]
                },
                {
                    "summaryComponent": "and detailed results, including predicted and true ranks, are printed for the test years.",
                    "codeSegments": [
                        {
                            "line": 134,
                            "code": "print(df[test_idx][[\"Year\", \"Name\", \"Rank\", \"PredictedScore\", \"PredictedRank\"]])"
                        }
                    ]
                },
                {
                    "summaryComponent": "Finally, the function generates and saves bar plots visualizing the prediction errors for each test year.",
                    "codeSegments": [
                        {
                            "line": 135,
                            "code": "plot_ranking_predictions(df, 2024)"
                        },
                        {
                            "line": 136,
                            "code": "plot_ranking_predictions(df, 2025)"
                        }
                    ]
                }
            ],
            "code": "89: def main():\n90:     X, y, group, df = load_data()\n91: \n92:     # Train-test split on years\n93:     unique_years = df[\"Year\"].unique()\n94:     train_years, test_years = (\n95:         unique_years[:-2],  # train: 2015-2023\n96:         unique_years[-2:],  # test: 2024-2025\n97:     )\n98: \n99:     train_idx = df[\"Year\"].isin(train_years)\n100:     test_idx = df[\"Year\"].isin(test_years)\n101: \n102:     X_train, X_test = X[train_idx], X[test_idx]\n103:     y_train, y_test = y[train_idx], y[test_idx]\n104: \n105:     # Group sizes\n106:     train_groups = df[train_idx].groupby(\"Year\").size().to_numpy()\n107:     test_groups = df[test_idx].groupby(\"Year\").size().to_numpy()\n108: \n109:     # Model\n110:     model = XGBRanker(\n111:         objective=\"rank:pairwise\",\n112:         learning_rate=0.1,\n113:         n_estimators=100,\n114:         max_depth=4,\n115:         random_state=42,\n116:     )\n117: \n118:     print(\"Training XGBoostRanker...\")\n119:     model.fit(X_train, y_train, group=train_groups)\n120: \n121:     # Predict, sort, and evaluate\n122:     y_pred = model.predict(X_test)\n123:     df.loc[test_idx, \"PredictedScore\"] = y_pred\n124:     df.loc[test_idx, \"PredictedRank\"] = (\n125:         df.loc[test_idx]\n126:         .groupby(\"Year\")[\"PredictedScore\"]\n127:         .rank(ascending=False, method=\"first\")\n128:     )\n129: \n130:     ndcg = evaluate_ndcg(y_test.to_numpy(), y_pred, test_groups)\n131:     print(f\"NDCG Score on test years {test_years.tolist()}: {ndcg:.4f}\")\n132: \n133:     # Show results\n134:     print(df[test_idx][[\"Year\", \"Name\", \"Rank\", \"PredictedScore\", \"PredictedRank\"]])\n135:     plot_ranking_predictions(df, 2024)\n136:     plot_ranking_predictions(df, 2025)\n137: "
        },
        "timestamp": "2025-08-16 23:01:18.000",
        "id": "wyzyEHRsMaHTbrBsSf8W"
    },
    {
        "source": "frontend",
        "event": "autotransit_section",
        "data": {
            "before_section_id": null,
            "after_section_id": "2d68092b-4e4d-488b-be65-3ac6f1fcf33c"
        },
        "timestamp": "2025-08-16 23:01:19.000",
        "id": "AzG9UX7tzB0YCjjtPpcj"
    },
    {
        "source": "backend",
        "event": "map_summary_code",
        "data": {
            "summary": "• Loads the dataset and extracts features, target ranks, group information, and the full DataFrame\n• Splits data into training (all years except the last two) and test sets (last two years)\n  ◦ Determines train/test indices and separates features and targets accordingly\n  ◦ Computes group sizes for each year in both splits\n• Initializes and trains an XGBoostRanker model with specified hyperparameters on the training data\n• Predicts ranking scores for the test set\n  ◦ Assigns predicted scores and computes predicted ranks within each test year\n• Evaluates model performance using the NDCG score on the test set\n• Prints a summary table with year, player name, true rank, predicted score, and predicted rank for the test years\n• Generates and saves bar plots visualizing prediction errors for each of the test years",
            "mapping": [
                {
                    "summaryComponent": "Loads the dataset and extracts features, target ranks, group information, and the full DataFrame",
                    "codeSegments": [
                        {
                            "line": 90,
                            "code": "X, y, group, df = load_data()"
                        }
                    ]
                },
                {
                    "summaryComponent": "Splits data into training (all years except the last two) and test sets (last two years)",
                    "codeSegments": [
                        {
                            "line": 93,
                            "code": "unique_years = df[\"Year\"].unique()"
                        },
                        {
                            "line": 94,
                            "code": "train_years, test_years = ("
                        },
                        {
                            "line": 95,
                            "code": "unique_years[:-2],  # train: 2015-2023"
                        },
                        {
                            "line": 96,
                            "code": "unique_years[-2:],  # test: 2024-2025"
                        }
                    ]
                },
                {
                    "summaryComponent": "Determines train/test indices and separates features and targets accordingly",
                    "codeSegments": [
                        {
                            "line": 99,
                            "code": "train_idx = df[\"Year\"].isin(train_years)"
                        },
                        {
                            "line": 100,
                            "code": "test_idx = df[\"Year\"].isin(test_years)"
                        },
                        {
                            "line": 102,
                            "code": "X_train, X_test = X[train_idx], X[test_idx]"
                        },
                        {
                            "line": 103,
                            "code": "y_train, y_test = y[train_idx], y[test_idx]"
                        }
                    ]
                },
                {
                    "summaryComponent": "Computes group sizes for each year in both splits",
                    "codeSegments": [
                        {
                            "line": 106,
                            "code": "train_groups = df[train_idx].groupby(\"Year\").size().to_numpy()"
                        },
                        {
                            "line": 107,
                            "code": "test_groups = df[test_idx].groupby(\"Year\").size().to_numpy()"
                        }
                    ]
                },
                {
                    "summaryComponent": "Initializes and trains an XGBoostRanker model with specified hyperparameters on the training data",
                    "codeSegments": [
                        {
                            "line": 110,
                            "code": "model = XGBRanker("
                        },
                        {
                            "line": 111,
                            "code": "objective=\"rank:pairwise\","
                        },
                        {
                            "line": 112,
                            "code": "learning_rate=0.1,"
                        },
                        {
                            "line": 113,
                            "code": "n_estimators=100,"
                        },
                        {
                            "line": 114,
                            "code": "max_depth=4,"
                        },
                        {
                            "line": 115,
                            "code": "random_state=42,"
                        },
                        {
                            "line": 119,
                            "code": "model.fit(X_train, y_train, group=train_groups)"
                        }
                    ]
                },
                {
                    "summaryComponent": "Predicts ranking scores for the test set",
                    "codeSegments": [
                        {
                            "line": 122,
                            "code": "y_pred = model.predict(X_test)"
                        }
                    ]
                },
                {
                    "summaryComponent": "Assigns predicted scores and computes predicted ranks within each test year",
                    "codeSegments": [
                        {
                            "line": 123,
                            "code": "df.loc[test_idx, \"PredictedScore\"] = y_pred"
                        },
                        {
                            "line": 124,
                            "code": "df.loc[test_idx, \"PredictedRank\"] = ("
                        },
                        {
                            "line": 125,
                            "code": "df.loc[test_idx]"
                        },
                        {
                            "line": 126,
                            "code": ".groupby(\"Year\")[\"PredictedScore\"]"
                        },
                        {
                            "line": 127,
                            "code": ".rank(ascending=False, method=\"first\")"
                        }
                    ]
                },
                {
                    "summaryComponent": "Evaluates model performance using the NDCG score on the test set",
                    "codeSegments": [
                        {
                            "line": 130,
                            "code": "ndcg = evaluate_ndcg(y_test.to_numpy(), y_pred, test_groups)"
                        }
                    ]
                },
                {
                    "summaryComponent": "Prints a summary table with year, player name, true rank, predicted score, and predicted rank for the test years",
                    "codeSegments": [
                        {
                            "line": 134,
                            "code": "print(df[test_idx][[\"Year\", \"Name\", \"Rank\", \"PredictedScore\", \"PredictedRank\"]])"
                        }
                    ]
                },
                {
                    "summaryComponent": "Generates and saves bar plots visualizing prediction errors for each of the test years",
                    "codeSegments": [
                        {
                            "line": 135,
                            "code": "plot_ranking_predictions(df, 2024)"
                        },
                        {
                            "line": 136,
                            "code": "plot_ranking_predictions(df, 2025)"
                        }
                    ]
                }
            ],
            "code": "89: def main():\n90:     X, y, group, df = load_data()\n91: \n92:     # Train-test split on years\n93:     unique_years = df[\"Year\"].unique()\n94:     train_years, test_years = (\n95:         unique_years[:-2],  # train: 2015-2023\n96:         unique_years[-2:],  # test: 2024-2025\n97:     )\n98: \n99:     train_idx = df[\"Year\"].isin(train_years)\n100:     test_idx = df[\"Year\"].isin(test_years)\n101: \n102:     X_train, X_test = X[train_idx], X[test_idx]\n103:     y_train, y_test = y[train_idx], y[test_idx]\n104: \n105:     # Group sizes\n106:     train_groups = df[train_idx].groupby(\"Year\").size().to_numpy()\n107:     test_groups = df[test_idx].groupby(\"Year\").size().to_numpy()\n108: \n109:     # Model\n110:     model = XGBRanker(\n111:         objective=\"rank:pairwise\",\n112:         learning_rate=0.1,\n113:         n_estimators=100,\n114:         max_depth=4,\n115:         random_state=42,\n116:     )\n117: \n118:     print(\"Training XGBoostRanker...\")\n119:     model.fit(X_train, y_train, group=train_groups)\n120: \n121:     # Predict, sort, and evaluate\n122:     y_pred = model.predict(X_test)\n123:     df.loc[test_idx, \"PredictedScore\"] = y_pred\n124:     df.loc[test_idx, \"PredictedRank\"] = (\n125:         df.loc[test_idx]\n126:         .groupby(\"Year\")[\"PredictedScore\"]\n127:         .rank(ascending=False, method=\"first\")\n128:     )\n129: \n130:     ndcg = evaluate_ndcg(y_test.to_numpy(), y_pred, test_groups)\n131:     print(f\"NDCG Score on test years {test_years.tolist()}: {ndcg:.4f}\")\n132: \n133:     # Show results\n134:     print(df[test_idx][[\"Year\", \"Name\", \"Rank\", \"PredictedScore\", \"PredictedRank\"]])\n135:     plot_ranking_predictions(df, 2024)\n136:     plot_ranking_predictions(df, 2025)\n137: "
        },
        "timestamp": "2025-08-16 23:01:19.000",
        "id": "B4e3elfZgznxk6kMzxRL"
    },
    {
        "source": "frontend",
        "event": "create_new_section",
        "data": {
            "section_id": "2d68092b-4e4d-488b-be65-3ac6f1fcf33c",
            "section_data": {
                "editPromptDetailLevel": null,
                "selectedStructured": "unstructured",
                "createdAt": 1755370879000,
                "lines": [
                    89,
                    137
                ],
                "editPromptStructured": null,
                "summaryData": {
                    "low_structured": "• Loads data and splits it into training and test sets\n• Trains an XGBoost ranking model\n• Evaluates and visualizes predictions for test years",
                    "high_unstructured": "The main() function orchestrates the MVP ranking prediction workflow. It first loads the dataset and splits it into training and test sets based on year, with the last two years reserved for testing. The function then trains an XGBoostRanker model using group-wise ranking objectives, predicts scores for the test set, and computes predicted ranks within each year. Model performance is evaluated using the NDCG metric, and detailed results, including predicted and true ranks, are printed for the test years. Finally, the function generates and saves bar plots visualizing the prediction errors for each test year.",
                    "medium_unstructured": "The main() function loads MVP data, splits it into training and test sets based on years, and trains an XGBoost ranking model on the training data. It predicts rankings for the test years, evaluates the model using NDCG score, and prints the results. Finally, it generates bar plots to visualize prediction errors for the test years.",
                    "high_structured": "• Loads the dataset and extracts features, target ranks, group information, and the full DataFrame\n• Splits data into training (all years except the last two) and test sets (last two years)\n  ◦ Determines train/test indices and separates features and targets accordingly\n  ◦ Computes group sizes for each year in both splits\n• Initializes and trains an XGBoostRanker model with specified hyperparameters on the training data\n• Predicts ranking scores for the test set\n  ◦ Assigns predicted scores and computes predicted ranks within each test year\n• Evaluates model performance using the NDCG score on the test set\n• Prints a summary table with year, player name, true rank, predicted score, and predicted rank for the test years\n• Generates and saves bar plots visualizing prediction errors for each of the test years",
                    "title": "Summary of the main() Function for MVP Ranking Prediction",
                    "low_unstructured": "This function loads data, trains an XGBoost ranking model, evaluates its performance, and visualizes prediction results for recent years.",
                    "medium_structured": "• Loads data and splits it into training (all but last two years) and test sets (last two years)\n• Trains an XGBoostRanker model on the training data\n• Predicts scores and ranks for the test set\n• Evaluates model performance using NDCG score\n• Visualizes prediction errors for each test year with bar plots"
                },
                "selectedDetailLevel": "medium",
                "metadata": {
                    "originalCode": "def main():\n    X, y, group, df = load_data()\n\n    # Train-test split on years\n    unique_years = df[\"Year\"].unique()\n    train_years, test_years = (\n        unique_years[:-2],  # train: 2015-2023\n        unique_years[-2:],  # test: 2024-2025\n    )\n\n    train_idx = df[\"Year\"].isin(train_years)\n    test_idx = df[\"Year\"].isin(test_years)\n\n    X_train, X_test = X[train_idx], X[test_idx]\n    y_train, y_test = y[train_idx], y[test_idx]\n\n    # Group sizes\n    train_groups = df[train_idx].groupby(\"Year\").size().to_numpy()\n    test_groups = df[test_idx].groupby(\"Year\").size().to_numpy()\n\n    # Model\n    model = XGBRanker(\n        objective=\"rank:pairwise\",\n        learning_rate=0.1,\n        n_estimators=100,\n        max_depth=4,\n        random_state=42,\n    )\n\n    print(\"Training XGBoostRanker...\")\n    model.fit(X_train, y_train, group=train_groups)\n\n    # Predict, sort, and evaluate\n    y_pred = model.predict(X_test)\n    df.loc[test_idx, \"PredictedScore\"] = y_pred\n    df.loc[test_idx, \"PredictedRank\"] = (\n        df.loc[test_idx]\n        .groupby(\"Year\")[\"PredictedScore\"]\n        .rank(ascending=False, method=\"first\")\n    )\n\n    ndcg = evaluate_ndcg(y_test.to_numpy(), y_pred, test_groups)\n    print(f\"NDCG Score on test years {test_years.tolist()}: {ndcg:.4f}\")\n\n    # Show results\n    print(df[test_idx][[\"Year\", \"Name\", \"Rank\", \"PredictedScore\", \"PredictedRank\"]])\n    plot_ranking_predictions(df, 2024)\n    plot_ranking_predictions(df, 2025)\n",
                    "fullPath": "/project/workspace/rank_model.py",
                    "id": "2d68092b-4e4d-488b-be65-3ac6f1fcf33c",
                    "offset": 2243,
                    "filename": "rank_model.py"
                },
                "editPromptValue": "",
                "title": "Summary of the main() Function for MVP Ranking Prediction",
                "summaryMappings": {
                    "high_unstructured": [
                        {
                            "summaryComponent": "The main() function orchestrates the MVP ranking prediction workflow.",
                            "codeSegments": [
                                {
                                    "line": 89,
                                    "code": "def main():"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "and splits it into training and test sets based on year, with the last two years reserved for testing.",
                            "codeSegments": [
                                {
                                    "line": 93,
                                    "code": "unique_years = df[\"Year\"].unique()"
                                },
                                {
                                    "line": 94,
                                    "code": "train_years, test_years = ("
                                },
                                {
                                    "line": 95,
                                    "code": "    unique_years[:-2],  # train: 2015-2023"
                                },
                                {
                                    "line": 96,
                                    "code": "    unique_years[-2:],  # test: 2024-2025"
                                },
                                {
                                    "line": 97,
                                    "code": ")"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "The function then trains an XGBoostRanker model using group-wise ranking objectives",
                            "codeSegments": [
                                {
                                    "line": 110,
                                    "code": "model = XGBRanker("
                                },
                                {
                                    "line": 111,
                                    "code": "    objective=\"rank:pairwise\","
                                },
                                {
                                    "line": 119,
                                    "code": "model.fit(X_train, y_train, group=train_groups)"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "predicts scores for the test set",
                            "codeSegments": [
                                {
                                    "line": 122,
                                    "code": "y_pred = model.predict(X_test)"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "and computes predicted ranks within each year.",
                            "codeSegments": [
                                {
                                    "line": 124,
                                    "code": "df.loc[test_idx, \"PredictedRank\"] = ("
                                },
                                {
                                    "line": 125,
                                    "code": "    df.loc[test_idx]"
                                },
                                {
                                    "line": 126,
                                    "code": "    .groupby(\"Year\")[\"PredictedScore\"]"
                                },
                                {
                                    "line": 127,
                                    "code": "    .rank(ascending=False, method=\"first\")"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "Model performance is evaluated using the NDCG metric",
                            "codeSegments": [
                                {
                                    "line": 130,
                                    "code": "ndcg = evaluate_ndcg(y_test.to_numpy(), y_pred, test_groups)"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "and detailed results, including predicted and true ranks, are printed for the test years.",
                            "codeSegments": [
                                {
                                    "line": 134,
                                    "code": "print(df[test_idx][[\"Year\", \"Name\", \"Rank\", \"PredictedScore\", \"PredictedRank\"]])"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "Finally, the function generates and saves bar plots visualizing the prediction errors for each test year.",
                            "codeSegments": [
                                {
                                    "line": 135,
                                    "code": "plot_ranking_predictions(df, 2024)"
                                },
                                {
                                    "line": 136,
                                    "code": "plot_ranking_predictions(df, 2025)"
                                }
                            ]
                        }
                    ],
                    "medium_unstructured": [
                        {
                            "summaryComponent": "loads MVP data",
                            "codeSegments": [
                                {
                                    "line": 90,
                                    "code": "X, y, group, df = load_data()"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "splits it into training and test sets based on years",
                            "codeSegments": [
                                {
                                    "line": 93,
                                    "code": "unique_years = df[\"Year\"].unique()"
                                },
                                {
                                    "line": 94,
                                    "code": "train_years, test_years = ("
                                },
                                {
                                    "line": 95,
                                    "code": "unique_years[:-2],  # train: 2015-2023"
                                },
                                {
                                    "line": 96,
                                    "code": "unique_years[-2:],  # test: 2024-2025"
                                },
                                {
                                    "line": 99,
                                    "code": "train_idx = df[\"Year\"].isin(train_years)"
                                },
                                {
                                    "line": 100,
                                    "code": "test_idx = df[\"Year\"].isin(test_years)"
                                },
                                {
                                    "line": 102,
                                    "code": "X_train, X_test = X[train_idx], X[test_idx]"
                                },
                                {
                                    "line": 103,
                                    "code": "y_train, y_test = y[train_idx], y[test_idx]"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "trains an XGBoost ranking model on the training data",
                            "codeSegments": [
                                {
                                    "line": 110,
                                    "code": "model = XGBRanker("
                                },
                                {
                                    "line": 119,
                                    "code": "model.fit(X_train, y_train, group=train_groups)"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "predicts rankings for the test years",
                            "codeSegments": [
                                {
                                    "line": 122,
                                    "code": "y_pred = model.predict(X_test)"
                                },
                                {
                                    "line": 123,
                                    "code": "df.loc[test_idx, \"PredictedScore\"] = y_pred"
                                },
                                {
                                    "line": 124,
                                    "code": "df.loc[test_idx, \"PredictedRank\"] = ("
                                }
                            ]
                        },
                        {
                            "summaryComponent": "evaluates the model using NDCG score",
                            "codeSegments": [
                                {
                                    "line": 130,
                                    "code": "ndcg = evaluate_ndcg(y_test.to_numpy(), y_pred, test_groups)"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "prints the results",
                            "codeSegments": [
                                {
                                    "line": 131,
                                    "code": "print(f\"NDCG Score on test years {test_years.tolist()}: {ndcg:.4f}\")"
                                },
                                {
                                    "line": 134,
                                    "code": "print(df[test_idx][[\"Year\", \"Name\", \"Rank\", \"PredictedScore\", \"PredictedRank\"]])"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "generates bar plots to visualize prediction errors for the test years",
                            "codeSegments": [
                                {
                                    "line": 135,
                                    "code": "plot_ranking_predictions(df, 2024)"
                                },
                                {
                                    "line": 136,
                                    "code": "plot_ranking_predictions(df, 2025)"
                                }
                            ]
                        }
                    ],
                    "high_structured": [
                        {
                            "summaryComponent": "Loads the dataset and extracts features, target ranks, group information, and the full DataFrame",
                            "codeSegments": [
                                {
                                    "line": 90,
                                    "code": "X, y, group, df = load_data()"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "Splits data into training (all years except the last two) and test sets (last two years)",
                            "codeSegments": [
                                {
                                    "line": 93,
                                    "code": "unique_years = df[\"Year\"].unique()"
                                },
                                {
                                    "line": 94,
                                    "code": "train_years, test_years = ("
                                },
                                {
                                    "line": 95,
                                    "code": "unique_years[:-2],  # train: 2015-2023"
                                },
                                {
                                    "line": 96,
                                    "code": "unique_years[-2:],  # test: 2024-2025"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "Determines train/test indices and separates features and targets accordingly",
                            "codeSegments": [
                                {
                                    "line": 99,
                                    "code": "train_idx = df[\"Year\"].isin(train_years)"
                                },
                                {
                                    "line": 100,
                                    "code": "test_idx = df[\"Year\"].isin(test_years)"
                                },
                                {
                                    "line": 102,
                                    "code": "X_train, X_test = X[train_idx], X[test_idx]"
                                },
                                {
                                    "line": 103,
                                    "code": "y_train, y_test = y[train_idx], y[test_idx]"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "Computes group sizes for each year in both splits",
                            "codeSegments": [
                                {
                                    "line": 106,
                                    "code": "train_groups = df[train_idx].groupby(\"Year\").size().to_numpy()"
                                },
                                {
                                    "line": 107,
                                    "code": "test_groups = df[test_idx].groupby(\"Year\").size().to_numpy()"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "Initializes and trains an XGBoostRanker model with specified hyperparameters on the training data",
                            "codeSegments": [
                                {
                                    "line": 110,
                                    "code": "model = XGBRanker("
                                },
                                {
                                    "line": 111,
                                    "code": "objective=\"rank:pairwise\","
                                },
                                {
                                    "line": 112,
                                    "code": "learning_rate=0.1,"
                                },
                                {
                                    "line": 113,
                                    "code": "n_estimators=100,"
                                },
                                {
                                    "line": 114,
                                    "code": "max_depth=4,"
                                },
                                {
                                    "line": 115,
                                    "code": "random_state=42,"
                                },
                                {
                                    "line": 119,
                                    "code": "model.fit(X_train, y_train, group=train_groups)"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "Predicts ranking scores for the test set",
                            "codeSegments": [
                                {
                                    "line": 122,
                                    "code": "y_pred = model.predict(X_test)"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "Assigns predicted scores and computes predicted ranks within each test year",
                            "codeSegments": [
                                {
                                    "line": 123,
                                    "code": "df.loc[test_idx, \"PredictedScore\"] = y_pred"
                                },
                                {
                                    "line": 124,
                                    "code": "df.loc[test_idx, \"PredictedRank\"] = ("
                                },
                                {
                                    "line": 125,
                                    "code": "df.loc[test_idx]"
                                },
                                {
                                    "line": 126,
                                    "code": ".groupby(\"Year\")[\"PredictedScore\"]"
                                },
                                {
                                    "line": 127,
                                    "code": ".rank(ascending=False, method=\"first\")"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "Evaluates model performance using the NDCG score on the test set",
                            "codeSegments": [
                                {
                                    "line": 130,
                                    "code": "ndcg = evaluate_ndcg(y_test.to_numpy(), y_pred, test_groups)"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "Prints a summary table with year, player name, true rank, predicted score, and predicted rank for the test years",
                            "codeSegments": [
                                {
                                    "line": 134,
                                    "code": "print(df[test_idx][[\"Year\", \"Name\", \"Rank\", \"PredictedScore\", \"PredictedRank\"]])"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "Generates and saves bar plots visualizing prediction errors for each of the test years",
                            "codeSegments": [
                                {
                                    "line": 135,
                                    "code": "plot_ranking_predictions(df, 2024)"
                                },
                                {
                                    "line": 136,
                                    "code": "plot_ranking_predictions(df, 2025)"
                                }
                            ]
                        }
                    ],
                    "low_unstructured": [
                        {
                            "summaryComponent": "loads data",
                            "codeSegments": [
                                {
                                    "line": 90,
                                    "code": "X, y, group, df = load_data()"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "trains an XGBoost ranking model",
                            "codeSegments": [
                                {
                                    "line": 110,
                                    "code": "model = XGBRanker("
                                },
                                {
                                    "line": 119,
                                    "code": "model.fit(X_train, y_train, group=train_groups)"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "evaluates its performance",
                            "codeSegments": [
                                {
                                    "line": 130,
                                    "code": "ndcg = evaluate_ndcg(y_test.to_numpy(), y_pred, test_groups)"
                                },
                                {
                                    "line": 131,
                                    "code": "print(f\"NDCG Score on test years {test_years.tolist()}: {ndcg:.4f}\")"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "visualizes prediction results for recent years",
                            "codeSegments": [
                                {
                                    "line": 135,
                                    "code": "plot_ranking_predictions(df, 2024)"
                                },
                                {
                                    "line": 136,
                                    "code": "plot_ranking_predictions(df, 2025)"
                                }
                            ]
                        }
                    ],
                    "low_structured": [
                        {
                            "summaryComponent": "Loads data and splits it into training and test sets",
                            "codeSegments": [
                                {
                                    "line": 90,
                                    "code": "X, y, group, df = load_data()"
                                },
                                {
                                    "line": 99,
                                    "code": "train_idx = df[\"Year\"].isin(train_years)"
                                },
                                {
                                    "line": 100,
                                    "code": "test_idx = df[\"Year\"].isin(test_years)"
                                },
                                {
                                    "line": 102,
                                    "code": "X_train, X_test = X[train_idx], X[test_idx]"
                                },
                                {
                                    "line": 103,
                                    "code": "y_train, y_test = y[train_idx], y[test_idx]"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "Trains an XGBoost ranking model",
                            "codeSegments": [
                                {
                                    "line": 110,
                                    "code": "model = XGBRanker("
                                },
                                {
                                    "line": 119,
                                    "code": "model.fit(X_train, y_train, group=train_groups)"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "Evaluates and visualizes predictions for test years",
                            "codeSegments": [
                                {
                                    "line": 130,
                                    "code": "ndcg = evaluate_ndcg(y_test.to_numpy(), y_pred, test_groups)"
                                },
                                {
                                    "line": 135,
                                    "code": "plot_ranking_predictions(df, 2024)"
                                },
                                {
                                    "line": 136,
                                    "code": "plot_ranking_predictions(df, 2025)"
                                }
                            ]
                        }
                    ],
                    "medium_structured": [
                        {
                            "summaryComponent": "Loads data and splits it into training (all but last two years) and test sets (last two years)",
                            "codeSegments": [
                                {
                                    "line": 90,
                                    "code": "X, y, group, df = load_data()"
                                },
                                {
                                    "line": 93,
                                    "code": "unique_years = df[\"Year\"].unique()"
                                },
                                {
                                    "line": 94,
                                    "code": "train_years, test_years = ("
                                },
                                {
                                    "line": 95,
                                    "code": "unique_years[:-2],  # train: 2015-2023"
                                },
                                {
                                    "line": 96,
                                    "code": "unique_years[-2:],  # test: 2024-2025"
                                },
                                {
                                    "line": 99,
                                    "code": "train_idx = df[\"Year\"].isin(train_years)"
                                },
                                {
                                    "line": 100,
                                    "code": "test_idx = df[\"Year\"].isin(test_years)"
                                },
                                {
                                    "line": 102,
                                    "code": "X_train, X_test = X[train_idx], X[test_idx]"
                                },
                                {
                                    "line": 103,
                                    "code": "y_train, y_test = y[train_idx], y[test_idx]"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "Trains an XGBoostRanker model on the training data",
                            "codeSegments": [
                                {
                                    "line": 110,
                                    "code": "model = XGBRanker("
                                },
                                {
                                    "line": 119,
                                    "code": "model.fit(X_train, y_train, group=train_groups)"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "Predicts scores and ranks for the test set",
                            "codeSegments": [
                                {
                                    "line": 122,
                                    "code": "y_pred = model.predict(X_test)"
                                },
                                {
                                    "line": 123,
                                    "code": "df.loc[test_idx, \"PredictedScore\"] = y_pred"
                                },
                                {
                                    "line": 124,
                                    "code": "df.loc[test_idx, \"PredictedRank\"] = ("
                                },
                                {
                                    "line": 125,
                                    "code": "df.loc[test_idx]\n        .groupby(\"Year\")[\"PredictedScore\"]\n        .rank(ascending=False, method=\"first\")"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "Evaluates model performance using NDCG score",
                            "codeSegments": [
                                {
                                    "line": 130,
                                    "code": "ndcg = evaluate_ndcg(y_test.to_numpy(), y_pred, test_groups)"
                                },
                                {
                                    "line": 131,
                                    "code": "print(f\"NDCG Score on test years {test_years.tolist()}: {ndcg:.4f}\")"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "Visualizes prediction errors for each test year with bar plots",
                            "codeSegments": [
                                {
                                    "line": 135,
                                    "code": "plot_ranking_predictions(df, 2024)"
                                },
                                {
                                    "line": 136,
                                    "code": "plot_ranking_predictions(df, 2025)"
                                }
                            ]
                        }
                    ]
                }
            }
        },
        "timestamp": "2025-08-16 23:01:19.000",
        "id": "bPf2yKW8AnatUr1iD1Qu"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "2d68092b-4e4d-488b-be65-3ac6f1fcf33c",
            "mapping_index": 4,
            "structured_type": "unstructured",
            "detail_level": "medium"
        },
        "timestamp": "2025-08-16 23:01:22.000",
        "id": "d7F6RszDYAwRjjJAMB9p"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "2d68092b-4e4d-488b-be65-3ac6f1fcf33c",
            "mapping_index": 6,
            "structured_type": "unstructured",
            "detail_level": "medium"
        },
        "timestamp": "2025-08-16 23:01:24.000",
        "id": "H6XF0Xz9E95MBJbmFyZI"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "2d68092b-4e4d-488b-be65-3ac6f1fcf33c",
            "detail_level": "medium",
            "structured_type": "unstructured"
        },
        "timestamp": "2025-08-16 23:01:24.000",
        "id": "jHoI4vVXA3H9RYezkTux"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "2d68092b-4e4d-488b-be65-3ac6f1fcf33c",
            "detail_level": "medium",
            "structured_type": "unstructured"
        },
        "timestamp": "2025-08-16 23:01:25.000",
        "id": "8KPhQmjrMm2pvP4AWu88"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "2d68092b-4e4d-488b-be65-3ac6f1fcf33c",
            "detail_level": "medium",
            "structured_type": "unstructured"
        },
        "timestamp": "2025-08-16 23:01:25.000",
        "id": "cbsn0yu13Bj2hHp930xx"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "2d68092b-4e4d-488b-be65-3ac6f1fcf33c",
            "detail_level": "medium",
            "structured_type": "unstructured"
        },
        "timestamp": "2025-08-16 23:01:25.000",
        "id": "gwdTBny76QqUWPmj6dns"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "2d68092b-4e4d-488b-be65-3ac6f1fcf33c",
            "mapping_index": 4,
            "structured_type": "unstructured",
            "detail_level": "medium"
        },
        "timestamp": "2025-08-16 23:01:25.000",
        "id": "hppJLicR6wz0qoBsuVFB"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "2d68092b-4e4d-488b-be65-3ac6f1fcf33c",
            "mapping_index": 1,
            "structured_type": "unstructured",
            "detail_level": "medium"
        },
        "timestamp": "2025-08-16 23:01:25.000",
        "id": "zTGUV9XvtftOCoVVBkGR"
    },
    {
        "source": "frontend",
        "event": "change_summary_level",
        "data": {
            "before_detail_level": "medium",
            "section_id": "2d68092b-4e4d-488b-be65-3ac6f1fcf33c",
            "before_structured": "unstructured",
            "after_structured": "unstructured",
            "after_detail_level": "low"
        },
        "timestamp": "2025-08-16 23:01:26.000",
        "id": "IxH796gjYSRiDUB6YrqR"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "2d68092b-4e4d-488b-be65-3ac6f1fcf33c",
            "mapping_index": 1,
            "structured_type": "unstructured",
            "detail_level": "low"
        },
        "timestamp": "2025-08-16 23:01:27.000",
        "id": "yMSgFPqT5bGqVQfxN4Z5"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "2d68092b-4e4d-488b-be65-3ac6f1fcf33c",
            "detail_level": "low",
            "structured_type": "unstructured"
        },
        "timestamp": "2025-08-16 23:01:30.000",
        "id": "rVlTjI8MEBi2eq3Tubbt"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "2d68092b-4e4d-488b-be65-3ac6f1fcf33c",
            "detail_level": "low",
            "structured_type": "unstructured"
        },
        "timestamp": "2025-08-16 23:01:38.000",
        "id": "FdEk5zHEXuj7G1y6YpkV"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "2d68092b-4e4d-488b-be65-3ac6f1fcf33c",
            "mapping_index": 1,
            "structured_type": "unstructured",
            "detail_level": "low"
        },
        "timestamp": "2025-08-16 23:01:38.000",
        "id": "rwLtSCsyDEekva1jnmUu"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "2d68092b-4e4d-488b-be65-3ac6f1fcf33c",
            "mapping_index": 3,
            "structured_type": "unstructured",
            "detail_level": "low"
        },
        "timestamp": "2025-08-16 23:01:38.000",
        "id": "wayFi8FYolNDUWD7kZRq"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "2d68092b-4e4d-488b-be65-3ac6f1fcf33c",
            "detail_level": "low",
            "structured_type": "unstructured"
        },
        "timestamp": "2025-08-16 23:01:38.000",
        "id": "x5JOfZ72DRXpVRD5A1fg"
    },
    {
        "source": "frontend",
        "event": "change_summary_level",
        "data": {
            "before_detail_level": "low",
            "section_id": "2d68092b-4e4d-488b-be65-3ac6f1fcf33c",
            "before_structured": "unstructured",
            "after_structured": "unstructured",
            "after_detail_level": "medium"
        },
        "timestamp": "2025-08-16 23:01:39.000",
        "id": "0oDNaBP3Zn1Cg4U2idUY"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "2d68092b-4e4d-488b-be65-3ac6f1fcf33c",
            "detail_level": "medium",
            "structured_type": "structured"
        },
        "timestamp": "2025-08-16 23:01:41.000",
        "id": "BpLMPuveag6PayJ6XMcJ"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "2d68092b-4e4d-488b-be65-3ac6f1fcf33c",
            "detail_level": "medium",
            "structured_type": "structured"
        },
        "timestamp": "2025-08-16 23:01:41.000",
        "id": "GypUorkaVddlH9FbNV6x"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "2d68092b-4e4d-488b-be65-3ac6f1fcf33c",
            "detail_level": "medium",
            "structured_type": "structured"
        },
        "timestamp": "2025-08-16 23:01:41.000",
        "id": "ITf0BtX1nJaAekGhNZpX"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "2d68092b-4e4d-488b-be65-3ac6f1fcf33c",
            "mapping_index": 3,
            "structured_type": "structured",
            "detail_level": "medium"
        },
        "timestamp": "2025-08-16 23:01:41.000",
        "id": "QiNBVMOPdFCv9N0qQzCT"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "2d68092b-4e4d-488b-be65-3ac6f1fcf33c",
            "mapping_index": 0,
            "structured_type": "structured",
            "detail_level": "medium"
        },
        "timestamp": "2025-08-16 23:01:41.000",
        "id": "V5BdAX70tMzHInJfJDfy"
    },
    {
        "source": "frontend",
        "event": "change_summary_level",
        "data": {
            "before_detail_level": "medium",
            "section_id": "2d68092b-4e4d-488b-be65-3ac6f1fcf33c",
            "before_structured": "unstructured",
            "after_structured": "structured",
            "after_detail_level": "medium"
        },
        "timestamp": "2025-08-16 23:01:41.000",
        "id": "ejcNaFmXCYto7VX63TNg"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "2d68092b-4e4d-488b-be65-3ac6f1fcf33c",
            "mapping_index": 1,
            "structured_type": "structured",
            "detail_level": "medium"
        },
        "timestamp": "2025-08-16 23:01:41.000",
        "id": "lU0YrLWwGgggh39leEZN"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "2d68092b-4e4d-488b-be65-3ac6f1fcf33c",
            "mapping_index": 2,
            "structured_type": "structured",
            "detail_level": "medium"
        },
        "timestamp": "2025-08-16 23:01:41.000",
        "id": "poTb8Blqs05nRlU6GlMh"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "2d68092b-4e4d-488b-be65-3ac6f1fcf33c",
            "detail_level": "medium",
            "structured_type": "structured"
        },
        "timestamp": "2025-08-16 23:01:43.000",
        "id": "DCtWzghLAmcziZX7rYwA"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "2d68092b-4e4d-488b-be65-3ac6f1fcf33c",
            "detail_level": "medium",
            "structured_type": "structured"
        },
        "timestamp": "2025-08-16 23:01:43.000",
        "id": "Io5nlILa05KvqnDTqFCA"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "2d68092b-4e4d-488b-be65-3ac6f1fcf33c",
            "mapping_index": 4,
            "structured_type": "structured",
            "detail_level": "medium"
        },
        "timestamp": "2025-08-16 23:01:43.000",
        "id": "m7J3E3IFiSk7Ir7vIPQm"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "2d68092b-4e4d-488b-be65-3ac6f1fcf33c",
            "mapping_index": 3,
            "structured_type": "structured",
            "detail_level": "medium"
        },
        "timestamp": "2025-08-16 23:01:49.000",
        "id": "rQ0repVIJjYTyquCVPiY"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "2d68092b-4e4d-488b-be65-3ac6f1fcf33c",
            "mapping_index": 2,
            "structured_type": "structured",
            "detail_level": "medium"
        },
        "timestamp": "2025-08-16 23:01:50.000",
        "id": "4gDJzfL0gRKsqGup8OZa"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "2d68092b-4e4d-488b-be65-3ac6f1fcf33c",
            "detail_level": "medium",
            "structured_type": "structured"
        },
        "timestamp": "2025-08-16 23:01:50.000",
        "id": "vIxUBxGZ2Ms9EDJ6M5Qz"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "2d68092b-4e4d-488b-be65-3ac6f1fcf33c",
            "detail_level": "medium",
            "structured_type": "structured"
        },
        "timestamp": "2025-08-16 23:01:51.000",
        "id": "8NW4IEHMHy5gssItPj5H"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "2d68092b-4e4d-488b-be65-3ac6f1fcf33c",
            "detail_level": "medium",
            "structured_type": "structured"
        },
        "timestamp": "2025-08-16 23:01:51.000",
        "id": "EkShHSspsmeG0RATuahu"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "2d68092b-4e4d-488b-be65-3ac6f1fcf33c",
            "mapping_index": 3,
            "structured_type": "structured",
            "detail_level": "medium"
        },
        "timestamp": "2025-08-16 23:01:51.000",
        "id": "FxOps0jiUog8NgxLvTxM"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "2d68092b-4e4d-488b-be65-3ac6f1fcf33c",
            "detail_level": "medium",
            "structured_type": "structured"
        },
        "timestamp": "2025-08-16 23:01:51.000",
        "id": "KFpvqVwkRr7okfeLZAUt"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "2d68092b-4e4d-488b-be65-3ac6f1fcf33c",
            "mapping_index": 2,
            "structured_type": "structured",
            "detail_level": "medium"
        },
        "timestamp": "2025-08-16 23:01:51.000",
        "id": "MdkN2kniO4LUgyd3qaPY"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "2d68092b-4e4d-488b-be65-3ac6f1fcf33c",
            "detail_level": "medium",
            "structured_type": "structured"
        },
        "timestamp": "2025-08-16 23:01:51.000",
        "id": "aTiVpC7bkMTy1m96y46Z"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "2d68092b-4e4d-488b-be65-3ac6f1fcf33c",
            "mapping_index": 0,
            "structured_type": "structured",
            "detail_level": "medium"
        },
        "timestamp": "2025-08-16 23:01:51.000",
        "id": "kwMCMhUbtoxtADguM08i"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "2d68092b-4e4d-488b-be65-3ac6f1fcf33c",
            "detail_level": "medium",
            "structured_type": "structured"
        },
        "timestamp": "2025-08-16 23:01:51.000",
        "id": "n7TDybOyxanxlJpTmI8o"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "2d68092b-4e4d-488b-be65-3ac6f1fcf33c",
            "mapping_index": 1,
            "structured_type": "structured",
            "detail_level": "medium"
        },
        "timestamp": "2025-08-16 23:01:51.000",
        "id": "ptLcyrDgeluCHNSdVAkZ"
    },
    {
        "source": "frontend",
        "event": "change_summary_level",
        "data": {
            "before_detail_level": "medium",
            "section_id": "2d68092b-4e4d-488b-be65-3ac6f1fcf33c",
            "before_structured": "structured",
            "after_structured": "structured",
            "after_detail_level": "high"
        },
        "timestamp": "2025-08-16 23:01:53.000",
        "id": "o17GetKdUQ2ard1Zx78F"
    },
    {
        "source": "frontend",
        "event": "change_summary_level",
        "data": {
            "before_detail_level": "medium",
            "section_id": "2d68092b-4e4d-488b-be65-3ac6f1fcf33c",
            "before_structured": "structured",
            "after_structured": "structured",
            "after_detail_level": "low"
        },
        "timestamp": "2025-08-16 23:01:56.000",
        "id": "MPv9hsDmtqJXnsQ5GaWk"
    },
    {
        "source": "frontend",
        "event": "change_summary_level",
        "data": {
            "before_detail_level": "high",
            "section_id": "2d68092b-4e4d-488b-be65-3ac6f1fcf33c",
            "before_structured": "structured",
            "after_structured": "structured",
            "after_detail_level": "medium"
        },
        "timestamp": "2025-08-16 23:01:56.000",
        "id": "g3FrAhH7T8l8vKjT1ai5"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "2d68092b-4e4d-488b-be65-3ac6f1fcf33c",
            "detail_level": "medium",
            "structured_type": "structured"
        },
        "timestamp": "2025-08-16 23:01:58.000",
        "id": "FZGvkyPARs4qORnrDBr8"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "2d68092b-4e4d-488b-be65-3ac6f1fcf33c",
            "mapping_index": 0,
            "structured_type": "structured",
            "detail_level": "medium"
        },
        "timestamp": "2025-08-16 23:01:58.000",
        "id": "XUsTPh23ZSOn5NDcc8Q8"
    },
    {
        "source": "frontend",
        "event": "change_summary_level",
        "data": {
            "before_detail_level": "low",
            "section_id": "2d68092b-4e4d-488b-be65-3ac6f1fcf33c",
            "before_structured": "structured",
            "after_structured": "structured",
            "after_detail_level": "medium"
        },
        "timestamp": "2025-08-16 23:01:58.000",
        "id": "sfWN3ygzGadeedG2lUQU"
    },
    {
        "source": "frontend",
        "event": "click_edit_in_prompt",
        "data": {
            "section_id": "2d68092b-4e4d-488b-be65-3ac6f1fcf33c",
            "summary": "• Loads data and splits it into training (all but last two years) and test sets (last two years)\n• Trains an XGBoostRanker model on the training data\n• Predicts scores and ranks for the test set\n• Evaluates model performance using NDCG score\n• Visualizes prediction errors for each test year with bar plots",
            "detail_level": "medium",
            "structured": "structured"
        },
        "timestamp": "2025-08-16 23:01:59.000",
        "id": "za67tf4oxese5lbhYggC"
    },
    {
        "source": "frontend",
        "event": "apply_instruction_summary",
        "data": {
            "section_id": "2d68092b-4e4d-488b-be65-3ac6f1fcf33c",
            "instruction": "during training, use three configurations with parameter \"n_estimator\" 100, 1000, 2000. then. evaluate these configs using NDCG Score, and find the best model",
            "detail_level": "medium",
            "original_summary": "• Loads data and splits it into training (all but last two years) and test sets (last two years)\n• Trains an XGBoostRanker model on the training data\n• Predicts scores and ranks for the test set\n• Evaluates model performance using NDCG score\n• Visualizes prediction errors for each test year with bar plots",
            "structured": "structured"
        },
        "timestamp": "2025-08-16 23:03:07.000",
        "id": "9uvVvQhb1lePGNleRkZR"
    },
    {
        "source": "backend",
        "event": "apply_instruction_summary",
        "data": {
            "original_code": "def main():\n    X, y, group, df = load_data()\n\n    # Train-test split on years\n    unique_years = df[\"Year\"].unique()\n    train_years, test_years = (\n        unique_years[:-2],  # train: 2015-2023\n        unique_years[-2:],  # test: 2024-2025\n    )\n\n    train_idx = df[\"Year\"].isin(train_years)\n    test_idx = df[\"Year\"].isin(test_years)\n\n    X_train, X_test = X[train_idx], X[test_idx]\n    y_train, y_test = y[train_idx], y[test_idx]\n\n    # Group sizes\n    train_groups = df[train_idx].groupby(\"Year\").size().to_numpy()\n    test_groups = df[test_idx].groupby(\"Year\").size().to_numpy()\n\n    # Model\n    model = XGBRanker(\n        objective=\"rank:pairwise\",\n        learning_rate=0.1,\n        n_estimators=100,\n        max_depth=4,\n        random_state=42,\n    )\n\n    print(\"Training XGBoostRanker...\")\n    model.fit(X_train, y_train, group=train_groups)\n\n    # Predict, sort, and evaluate\n    y_pred = model.predict(X_test)\n    df.loc[test_idx, \"PredictedScore\"] = y_pred\n    df.loc[test_idx, \"PredictedRank\"] = (\n        df.loc[test_idx]\n        .groupby(\"Year\")[\"PredictedScore\"]\n        .rank(ascending=False, method=\"first\")\n    )\n\n    ndcg = evaluate_ndcg(y_test.to_numpy(), y_pred, test_groups)\n    print(f\"NDCG Score on test years {test_years.tolist()}: {ndcg:.4f}\")\n\n    # Show results\n    print(df[test_idx][[\"Year\", \"Name\", \"Rank\", \"PredictedScore\", \"PredictedRank\"]])\n    plot_ranking_predictions(df, 2024)\n    plot_ranking_predictions(df, 2025)\n",
            "original_summary": "• Loads data and splits it into training (all but last two years) and test sets (last two years)\n• Trains an XGBoostRanker model on the training data\n• Predicts scores and ranks for the test set\n• Evaluates model performance using NDCG score\n• Visualizes prediction errors for each test year with bar plots",
            "instruction": "during training, use three configurations with parameter \"n_estimator\" 100, 1000, 2000. then. evaluate these configs using NDCG Score, and find the best model",
            "updated_summary": "• Loads data and splits it into training (all but last two years) and test sets (last two years)  \n• Trains three XGBoostRanker models on the training data, each with a different \"n_estimators\" parameter value: 100, 1000, and 2000  \n• Evaluates each model's performance on the test set using NDCG score, and selects the best model based on the highest NDCG score  \n• Predicts scores and ranks for the test set using the best model  \n• Visualizes prediction errors for each test year with bar plots"
        },
        "timestamp": "2025-08-16 23:03:08.000",
        "id": "GabtQudzUCEg3CgMi72Q"
    },
    {
        "source": "frontend",
        "event": "commit_modified_summary",
        "data": {
            "section_id": "2d68092b-4e4d-488b-be65-3ac6f1fcf33c",
            "edited_summary": "• Loads data and splits it into training (all but last two years) and test sets (last two years)  \n• Trains three XGBoostRanker models on the training data, each with a different \"n_estimators\" parameter value: 100, 1000, and 2000  \n• Evaluates each model's performance on the test set using NDCG score, and selects the best model based on the highest NDCG score  \n• Predicts scores and ranks for the test set using the best model  \n• Visualizes prediction errors for each test year with bar plots",
            "detail_level": "medium",
            "original_summary": "• Loads data and splits it into training (all but last two years) and test sets (last two years)\n• Trains an XGBoostRanker model on the training data\n• Predicts scores and ranks for the test set\n• Evaluates model performance using NDCG score\n• Visualizes prediction errors for each test year with bar plots",
            "structured": "structured"
        },
        "timestamp": "2025-08-16 23:03:16.000",
        "id": "oFc9Cj5gV5CwUMxtsjI4"
    },
    {
        "source": "backend",
        "event": "modify_summary_mediation",
        "data": {
            "original_code": "def main():\n    X, y, group, df = load_data()\n\n    # Train-test split on years\n    unique_years = df[\"Year\"].unique()\n    train_years, test_years = (\n        unique_years[:-2],  # train: 2015-2023\n        unique_years[-2:],  # test: 2024-2025\n    )\n\n    train_idx = df[\"Year\"].isin(train_years)\n    test_idx = df[\"Year\"].isin(test_years)\n\n    X_train, X_test = X[train_idx], X[test_idx]\n    y_train, y_test = y[train_idx], y[test_idx]\n\n    # Group sizes\n    train_groups = df[train_idx].groupby(\"Year\").size().to_numpy()\n    test_groups = df[test_idx].groupby(\"Year\").size().to_numpy()\n\n    # Model\n    model = XGBRanker(\n        objective=\"rank:pairwise\",\n        learning_rate=0.1,\n        n_estimators=100,\n        max_depth=4,\n        random_state=42,\n    )\n\n    print(\"Training XGBoostRanker...\")\n    model.fit(X_train, y_train, group=train_groups)\n\n    # Predict, sort, and evaluate\n    y_pred = model.predict(X_test)\n    df.loc[test_idx, \"PredictedScore\"] = y_pred\n    df.loc[test_idx, \"PredictedRank\"] = (\n        df.loc[test_idx]\n        .groupby(\"Year\")[\"PredictedScore\"]\n        .rank(ascending=False, method=\"first\")\n    )\n\n    ndcg = evaluate_ndcg(y_test.to_numpy(), y_pred, test_groups)\n    print(f\"NDCG Score on test years {test_years.tolist()}: {ndcg:.4f}\")\n\n    # Show results\n    print(df[test_idx][[\"Year\", \"Name\", \"Rank\", \"PredictedScore\", \"PredictedRank\"]])\n    plot_ranking_predictions(df, 2024)\n    plot_ranking_predictions(df, 2025)\n",
            "original_summary": "• Loads data and splits it into training (all but last two years) and test sets (last two years)\n• Trains an XGBoostRanker model on the training data\n• Predicts scores and ranks for the test set\n• Evaluates model performance using NDCG score\n• Visualizes prediction errors for each test year with bar plots",
            "edited_summary": "• Loads data and splits it into training (all but last two years) and test sets (last two years)  \n• Trains three XGBoostRanker models on the training data, each with a different \"n_estimators\" parameter value: 100, 1000, and 2000  \n• Evaluates each model's performance on the test set using NDCG score, and selects the best model based on the highest NDCG score  \n• Predicts scores and ranks for the test set using the best model  \n• Visualizes prediction errors for each test year with bar plots",
            "structured_type": "structured",
            "detail_level": "medium",
            "updated_code": "def main():\n    X, y, group, df = load_data()\n\n    # Train-test split on years\n    unique_years = df[\"Year\"].unique()\n    train_years, test_years = (\n        unique_years[:-2],  # train: 2015-2023\n        unique_years[-2:],  # test: 2024-2025\n    )\n\n    train_idx = df[\"Year\"].isin(train_years)\n    test_idx = df[\"Year\"].isin(test_years)\n\n    X_train, X_test = X[train_idx], X[test_idx]\n    y_train, y_test = y[train_idx], y[test_idx]\n\n    # Group sizes\n    train_groups = df[train_idx].groupby(\"Year\").size().to_numpy()\n    test_groups = df[test_idx].groupby(\"Year\").size().to_numpy()\n\n    # Train three models with different n_estimators\n    n_estimators_list = [100, 1000, 2000]\n    models = []\n    ndcg_scores = []\n\n    for n_estimators in n_estimators_list:\n        model = XGBRanker(\n            objective=\"rank:pairwise\",\n            learning_rate=0.1,\n            n_estimators=n_estimators,\n            max_depth=4,\n            random_state=42,\n        )\n        print(f\"Training XGBoostRanker with n_estimators={n_estimators}...\")\n        model.fit(X_train, y_train, group=train_groups)\n        y_pred = model.predict(X_test)\n        ndcg = evaluate_ndcg(y_test.to_numpy(), y_pred, test_groups)\n        print(f\"NDCG Score (n_estimators={n_estimators}): {ndcg:.4f}\")\n        models.append(model)\n        ndcg_scores.append(ndcg)\n\n    # Select the best model based on NDCG score\n    best_idx = int(np.argmax(ndcg_scores))\n    best_model = models[best_idx]\n    best_n_estimators = n_estimators_list[best_idx]\n    print(f\"Best model n_estimators={best_n_estimators} with NDCG={ndcg_scores[best_idx]:.4f}\")\n\n    # Predict, sort, and evaluate using the best model\n    y_pred = best_model.predict(X_test)\n    df.loc[test_idx, \"PredictedScore\"] = y_pred\n    df.loc[test_idx, \"PredictedRank\"] = (\n        df.loc[test_idx]\n        .groupby(\"Year\")[\"PredictedScore\"]\n        .rank(ascending=False, method=\"first\")\n    )\n\n    ndcg = evaluate_ndcg(y_test.to_numpy(), y_pred, test_groups)\n    print(f\"NDCG Score on test years {test_years.tolist()} (best model): {ndcg:.4f}\")\n\n    # Show results\n    print(df[test_idx][[\"Year\", \"Name\", \"Rank\", \"PredictedScore\", \"PredictedRank\"]])\n    plot_ranking_predictions(df, 2024)\n    plot_ranking_predictions(df, 2025)"
        },
        "timestamp": "2025-08-16 23:03:20.000",
        "id": "xiwjDJu0XCAYjh0bpefv"
    },
    {
        "source": "backend",
        "event": "summarize_modified_code",
        "data": {
            "new_code": "def main():\n    X, y, group, df = load_data()\n\n    # Train-test split on years\n    unique_years = df[\"Year\"].unique()\n    train_years, test_years = (\n        unique_years[:-2],  # train: 2015-2023\n        unique_years[-2:],  # test: 2024-2025\n    )\n\n    train_idx = df[\"Year\"].isin(train_years)\n    test_idx = df[\"Year\"].isin(test_years)\n\n    X_train, X_test = X[train_idx], X[test_idx]\n    y_train, y_test = y[train_idx], y[test_idx]\n\n    # Group sizes\n    train_groups = df[train_idx].groupby(\"Year\").size().to_numpy()\n    test_groups = df[test_idx].groupby(\"Year\").size().to_numpy()\n\n    # Train three models with different n_estimators\n    n_estimators_list = [100, 1000, 2000]\n    models = []\n    ndcg_scores = []\n\n    for n_estimators in n_estimators_list:\n        model = XGBRanker(\n            objective=\"rank:pairwise\",\n            learning_rate=0.1,\n            n_estimators=n_estimators,\n            max_depth=4,\n            random_state=42,\n        )\n        print(f\"Training XGBoostRanker with n_estimators={n_estimators}...\")\n        model.fit(X_train, y_train, group=train_groups)\n        y_pred = model.predict(X_test)\n        ndcg = evaluate_ndcg(y_test.to_numpy(), y_pred, test_groups)\n        print(f\"NDCG Score (n_estimators={n_estimators}): {ndcg:.4f}\")\n        models.append(model)\n        ndcg_scores.append(ndcg)\n\n    # Select the best model based on NDCG score\n    best_idx = int(np.argmax(ndcg_scores))\n    best_model = models[best_idx]\n    best_n_estimators = n_estimators_list[best_idx]\n    print(f\"Best model n_estimators={best_n_estimators} with NDCG={ndcg_scores[best_idx]:.4f}\")\n\n    # Predict, sort, and evaluate using the best model\n    y_pred = best_model.predict(X_test)\n    df.loc[test_idx, \"PredictedScore\"] = y_pred\n    df.loc[test_idx, \"PredictedRank\"] = (\n        df.loc[test_idx]\n        .groupby(\"Year\")[\"PredictedScore\"]\n        .rank(ascending=False, method=\"first\")\n    )\n\n    ndcg = evaluate_ndcg(y_test.to_numpy(), y_pred, test_groups)\n    print(f\"NDCG Score on test years {test_years.tolist()} (best model): {ndcg:.4f}\")\n\n    # Show results\n    print(df[test_idx][[\"Year\", \"Name\", \"Rank\", \"PredictedScore\", \"PredictedRank\"]])\n    plot_ranking_predictions(df, 2024)\n    plot_ranking_predictions(df, 2025)",
            "original_code": "def main():\n    X, y, group, df = load_data()\n\n    # Train-test split on years\n    unique_years = df[\"Year\"].unique()\n    train_years, test_years = (\n        unique_years[:-2],  # train: 2015-2023\n        unique_years[-2:],  # test: 2024-2025\n    )\n\n    train_idx = df[\"Year\"].isin(train_years)\n    test_idx = df[\"Year\"].isin(test_years)\n\n    X_train, X_test = X[train_idx], X[test_idx]\n    y_train, y_test = y[train_idx], y[test_idx]\n\n    # Group sizes\n    train_groups = df[train_idx].groupby(\"Year\").size().to_numpy()\n    test_groups = df[test_idx].groupby(\"Year\").size().to_numpy()\n\n    # Train three models with different n_estimators\n    n_estimators_list = [100, 1000, 2000]\n    models = []\n    ndcg_scores = []\n\n    for n_estimators in n_estimators_list:\n        model = XGBRanker(\n            objective=\"rank:pairwise\",\n            learning_rate=0.1,\n            n_estimators=n_estimators,\n            max_depth=4,\n            random_state=42,\n        )\n        print(f\"Training XGBoostRanker with n_estimators={n_estimators}...\")\n        model.fit(X_train, y_train, group=train_groups)\n        y_pred = model.predict(X_test)\n        ndcg = evaluate_ndcg(y_test.to_numpy(), y_pred, test_groups)\n        print(f\"NDCG Score (n_estimators={n_estimators}): {ndcg:.4f}\")\n        models.append(model)\n        ndcg_scores.append(ndcg)\n\n    # Select the best model based on NDCG score\n    best_idx = int(np.argmax(ndcg_scores))\n    best_model = models[best_idx]\n    best_n_estimators = n_estimators_list[best_idx]\n    print(f\"Best model n_estimators={best_n_estimators} with NDCG={ndcg_scores[best_idx]:.4f}\")\n\n    # Predict, sort, and evaluate using the best model\n    y_pred = best_model.predict(X_test)\n    df.loc[test_idx, \"PredictedScore\"] = y_pred\n    df.loc[test_idx, \"PredictedRank\"] = (\n        df.loc[test_idx]\n        .groupby(\"Year\")[\"PredictedScore\"]\n        .rank(ascending=False, method=\"first\")\n    )\n\n    ndcg = evaluate_ndcg(y_test.to_numpy(), y_pred, test_groups)\n    print(f\"NDCG Score on test years {test_years.tolist()} (best model): {ndcg:.4f}\")\n\n    # Show results\n    print(df[test_idx][[\"Year\", \"Name\", \"Rank\", \"PredictedScore\", \"PredictedRank\"]])\n    plot_ranking_predictions(df, 2024)\n    plot_ranking_predictions(df, 2025)",
            "old_summary": {
                "low_structured": "• Loads data and splits it into training and test sets\n• Trains an XGBoost ranking model\n• Evaluates and visualizes predictions for test years",
                "high_unstructured": "The main() function orchestrates the MVP ranking prediction workflow. It first loads the dataset and splits it into training and test sets based on year, with the last two years reserved for testing. The function then trains an XGBoostRanker model using group-wise ranking objectives, predicts scores for the test set, and computes predicted ranks within each year. Model performance is evaluated using the NDCG metric, and detailed results, including predicted and true ranks, are printed for the test years. Finally, the function generates and saves bar plots visualizing the prediction errors for each test year.",
                "medium_unstructured": "The main() function loads MVP data, splits it into training and test sets based on years, and trains an XGBoost ranking model on the training data. It predicts rankings for the test years, evaluates the model using NDCG score, and prints the results. Finally, it generates bar plots to visualize prediction errors for the test years.",
                "high_structured": "• Loads the dataset and extracts features, target ranks, group information, and the full DataFrame\n• Splits data into training (all years except the last two) and test sets (last two years)\n  ◦ Determines train/test indices and separates features and targets accordingly\n  ◦ Computes group sizes for each year in both splits\n• Initializes and trains an XGBoostRanker model with specified hyperparameters on the training data\n• Predicts ranking scores for the test set\n  ◦ Assigns predicted scores and computes predicted ranks within each test year\n• Evaluates model performance using the NDCG score on the test set\n• Prints a summary table with year, player name, true rank, predicted score, and predicted rank for the test years\n• Generates and saves bar plots visualizing prediction errors for each of the test years",
                "title": "Summary of the main() Function for MVP Ranking Prediction",
                "low_unstructured": "This function loads data, trains an XGBoost ranking model, evaluates its performance, and visualizes prediction results for recent years.",
                "medium_structured": "• Loads data and splits it into training (all but last two years) and test sets (last two years)\n• Trains an XGBoostRanker model on the training data\n• Predicts scores and ranks for the test set\n• Evaluates model performance using NDCG score\n• Visualizes prediction errors for each test year with bar plots"
            },
            "new_summary": {
                "low_structured": "• Loads data and splits it into training and test sets\n• Trains multiple XGBoost ranking models with varying n_estimators and selects the best based on NDCG score\n• Evaluates and visualizes predictions for test years",
                "high_unstructured": "The main() function orchestrates the MVP ranking prediction workflow. It first loads the dataset and splits it into training and test sets based on year, with the last two years reserved for testing. The function then trains three XGBoostRanker models with different n_estimators using group-wise ranking objectives, selects the best model based on the highest NDCG score, predicts scores for the test set with this model, and computes predicted ranks within each year. Model performance is evaluated using the NDCG metric, and detailed results, including predicted and true ranks, are printed for the test years. Finally, the function generates and saves bar plots visualizing the prediction errors for each test year.",
                "medium_unstructured": "The main() function loads MVP data, splits it into training and test sets based on years, and trains three XGBoost ranking models on the training data with different n_estimators values. It selects the best model according to the NDCG score, predicts rankings for the test years using this model, evaluates the model using NDCG score, and prints the results. Finally, it generates bar plots to visualize prediction errors for the test years.",
                "high_structured": "• Loads the dataset and extracts features, target ranks, group information, and the full DataFrame\n• Splits data into training (all years except the last two) and test sets (last two years)\n  ◦ Determines train/test indices and separates features and targets accordingly\n  ◦ Computes group sizes for each year in both splits\n• Initializes and trains three XGBoostRanker models with different n_estimators on the training data\n  ◦ Evaluates each model's performance using NDCG score on the test set\n  ◦ Selects the best model based on the highest NDCG score\n• Predicts ranking scores for the test set using the best model\n  ◦ Assigns predicted scores and computes predicted ranks within each test year\n• Evaluates model performance using the NDCG score on the test set\n• Prints a summary table with year, player name, true rank, predicted score, and predicted rank for the test years\n• Generates and saves bar plots visualizing prediction errors for each of the test years",
                "title": "Summary of the main() Function for MVP Ranking Prediction (with Model Selection Enhancement)",
                "low_unstructured": "This function loads data, trains multiple XGBoost ranking models with different n_estimators, selects the best model based on NDCG score, evaluates its performance, and visualizes prediction results for recent years.",
                "medium_structured": "• Loads data and splits it into training (all but last two years) and test sets (last two years)\n• Trains three XGBoostRanker models on the training data with different n_estimators values\n• Selects the best model based on NDCG score\n• Predicts scores and ranks for the test set using the best model\n• Evaluates model performance using NDCG score\n• Visualizes prediction errors for each test year with bar plots"
            }
        },
        "timestamp": "2025-08-16 23:03:33.000",
        "id": "PxiLNP4ig8ZFr7S3s9h1"
    },
    {
        "source": "backend",
        "event": "map_summary_code",
        "data": {
            "summary": "• Loads data and splits it into training and test sets\n• Trains multiple XGBoost ranking models with varying n_estimators and selects the best based on NDCG score\n• Evaluates and visualizes predictions for test years",
            "mapping": [
                {
                    "summaryComponent": "Loads data and splits it into training and test sets",
                    "codeSegments": [
                        {
                            "line": 90,
                            "code": "X, y, group, df = load_data()"
                        },
                        {
                            "line": 93,
                            "code": "unique_years = df[\"Year\"].unique()"
                        },
                        {
                            "line": 94,
                            "code": "train_years, test_years = (\n    unique_years[:-2],  # train: 2015-2023\n    unique_years[-2:],  # test: 2024-2025\n)"
                        },
                        {
                            "line": 99,
                            "code": "train_idx = df[\"Year\"].isin(train_years)"
                        },
                        {
                            "line": 100,
                            "code": "test_idx = df[\"Year\"].isin(test_years)"
                        },
                        {
                            "line": 102,
                            "code": "X_train, X_test = X[train_idx], X[test_idx]"
                        },
                        {
                            "line": 103,
                            "code": "y_train, y_test = y[train_idx], y[test_idx]"
                        }
                    ]
                },
                {
                    "summaryComponent": "Trains multiple XGBoost ranking models with varying n_estimators and selects the best based on NDCG score",
                    "codeSegments": [
                        {
                            "line": 110,
                            "code": "n_estimators_list = [100, 1000, 2000]"
                        },
                        {
                            "line": 114,
                            "code": "for n_estimators in n_estimators_list:"
                        },
                        {
                            "line": 115,
                            "code": "model = XGBRanker("
                        },
                        {
                            "line": 123,
                            "code": "model.fit(X_train, y_train, group=train_groups)"
                        },
                        {
                            "line": 125,
                            "code": "ndcg = evaluate_ndcg(y_test.to_numpy(), y_pred, test_groups)"
                        },
                        {
                            "line": 127,
                            "code": "models.append(model)"
                        },
                        {
                            "line": 128,
                            "code": "ndcg_scores.append(ndcg)"
                        },
                        {
                            "line": 131,
                            "code": "best_idx = int(np.argmax(ndcg_scores))"
                        },
                        {
                            "line": 132,
                            "code": "best_model = models[best_idx]"
                        },
                        {
                            "line": 133,
                            "code": "best_n_estimators = n_estimators_list[best_idx]"
                        }
                    ]
                },
                {
                    "summaryComponent": "Evaluates and visualizes predictions for test years",
                    "codeSegments": [
                        {
                            "line": 137,
                            "code": "y_pred = best_model.predict(X_test)"
                        },
                        {
                            "line": 138,
                            "code": "df.loc[test_idx, \"PredictedScore\"] = y_pred"
                        },
                        {
                            "line": 145,
                            "code": "ndcg = evaluate_ndcg(y_test.to_numpy(), y_pred, test_groups)"
                        },
                        {
                            "line": 149,
                            "code": "print(df[test_idx][[\"Year\", \"Name\", \"Rank\", \"PredictedScore\", \"PredictedRank\"]])"
                        },
                        {
                            "line": 150,
                            "code": "plot_ranking_predictions(df, 2024)"
                        },
                        {
                            "line": 151,
                            "code": "plot_ranking_predictions(df, 2025)"
                        }
                    ]
                }
            ],
            "code": "89: def main():\n90:     X, y, group, df = load_data()\n91: \n92:     # Train-test split on years\n93:     unique_years = df[\"Year\"].unique()\n94:     train_years, test_years = (\n95:         unique_years[:-2],  # train: 2015-2023\n96:         unique_years[-2:],  # test: 2024-2025\n97:     )\n98: \n99:     train_idx = df[\"Year\"].isin(train_years)\n100:     test_idx = df[\"Year\"].isin(test_years)\n101: \n102:     X_train, X_test = X[train_idx], X[test_idx]\n103:     y_train, y_test = y[train_idx], y[test_idx]\n104: \n105:     # Group sizes\n106:     train_groups = df[train_idx].groupby(\"Year\").size().to_numpy()\n107:     test_groups = df[test_idx].groupby(\"Year\").size().to_numpy()\n108: \n109:     # Train three models with different n_estimators\n110:     n_estimators_list = [100, 1000, 2000]\n111:     models = []\n112:     ndcg_scores = []\n113: \n114:     for n_estimators in n_estimators_list:\n115:         model = XGBRanker(\n116:             objective=\"rank:pairwise\",\n117:             learning_rate=0.1,\n118:             n_estimators=n_estimators,\n119:             max_depth=4,\n120:             random_state=42,\n121:         )\n122:         print(f\"Training XGBoostRanker with n_estimators={n_estimators}...\")\n123:         model.fit(X_train, y_train, group=train_groups)\n124:         y_pred = model.predict(X_test)\n125:         ndcg = evaluate_ndcg(y_test.to_numpy(), y_pred, test_groups)\n126:         print(f\"NDCG Score (n_estimators={n_estimators}): {ndcg:.4f}\")\n127:         models.append(model)\n128:         ndcg_scores.append(ndcg)\n129: \n130:     # Select the best model based on NDCG score\n131:     best_idx = int(np.argmax(ndcg_scores))\n132:     best_model = models[best_idx]\n133:     best_n_estimators = n_estimators_list[best_idx]\n134:     print(f\"Best model n_estimators={best_n_estimators} with NDCG={ndcg_scores[best_idx]:.4f}\")\n135: \n136:     # Predict, sort, and evaluate using the best model\n137:     y_pred = best_model.predict(X_test)\n138:     df.loc[test_idx, \"PredictedScore\"] = y_pred\n139:     df.loc[test_idx, \"PredictedRank\"] = (\n140:         df.loc[test_idx]\n141:         .groupby(\"Year\")[\"PredictedScore\"]\n142:         .rank(ascending=False, method=\"first\")\n143:     )\n144: \n145:     ndcg = evaluate_ndcg(y_test.to_numpy(), y_pred, test_groups)\n146:     print(f\"NDCG Score on test years {test_years.tolist()} (best model): {ndcg:.4f}\")\n147: \n148:     # Show results\n149:     print(df[test_idx][[\"Year\", \"Name\", \"Rank\", \"PredictedScore\", \"PredictedRank\"]])\n150:     plot_ranking_predictions(df, 2024)\n151:     plot_ranking_predictions(df, 2025)"
        },
        "timestamp": "2025-08-16 23:03:36.000",
        "id": "mmDWv7lDXwh2tgkoNW2M"
    },
    {
        "source": "backend",
        "event": "map_summary_code",
        "data": {
            "summary": "This function loads data, trains multiple XGBoost ranking models with different n_estimators, selects the best model based on NDCG score, evaluates its performance, and visualizes prediction results for recent years.",
            "mapping": [
                {
                    "summaryComponent": "loads data",
                    "codeSegments": [
                        {
                            "line": 90,
                            "code": "X, y, group, df = load_data()"
                        }
                    ]
                },
                {
                    "summaryComponent": "trains multiple XGBoost ranking models",
                    "codeSegments": [
                        {
                            "line": 114,
                            "code": "for n_estimators in n_estimators_list:"
                        },
                        {
                            "line": 115,
                            "code": "model = XGBRanker("
                        },
                        {
                            "line": 123,
                            "code": "model.fit(X_train, y_train, group=train_groups)"
                        }
                    ]
                },
                {
                    "summaryComponent": "with different n_estimators",
                    "codeSegments": [
                        {
                            "line": 110,
                            "code": "n_estimators_list = [100, 1000, 2000]"
                        },
                        {
                            "line": 114,
                            "code": "for n_estimators in n_estimators_list:"
                        }
                    ]
                },
                {
                    "summaryComponent": "selects the best model based on NDCG score",
                    "codeSegments": [
                        {
                            "line": 131,
                            "code": "best_idx = int(np.argmax(ndcg_scores))"
                        },
                        {
                            "line": 132,
                            "code": "best_model = models[best_idx]"
                        },
                        {
                            "line": 133,
                            "code": "best_n_estimators = n_estimators_list[best_idx]"
                        }
                    ]
                },
                {
                    "summaryComponent": "evaluates its performance",
                    "codeSegments": [
                        {
                            "line": 145,
                            "code": "ndcg = evaluate_ndcg(y_test.to_numpy(), y_pred, test_groups)"
                        },
                        {
                            "line": 146,
                            "code": "print(f\"NDCG Score on test years {test_years.tolist()} (best model): {ndcg:.4f}\")"
                        }
                    ]
                },
                {
                    "summaryComponent": "visualizes prediction results for recent years",
                    "codeSegments": [
                        {
                            "line": 150,
                            "code": "plot_ranking_predictions(df, 2024)"
                        },
                        {
                            "line": 151,
                            "code": "plot_ranking_predictions(df, 2025)"
                        }
                    ]
                }
            ],
            "code": "89: def main():\n90:     X, y, group, df = load_data()\n91: \n92:     # Train-test split on years\n93:     unique_years = df[\"Year\"].unique()\n94:     train_years, test_years = (\n95:         unique_years[:-2],  # train: 2015-2023\n96:         unique_years[-2:],  # test: 2024-2025\n97:     )\n98: \n99:     train_idx = df[\"Year\"].isin(train_years)\n100:     test_idx = df[\"Year\"].isin(test_years)\n101: \n102:     X_train, X_test = X[train_idx], X[test_idx]\n103:     y_train, y_test = y[train_idx], y[test_idx]\n104: \n105:     # Group sizes\n106:     train_groups = df[train_idx].groupby(\"Year\").size().to_numpy()\n107:     test_groups = df[test_idx].groupby(\"Year\").size().to_numpy()\n108: \n109:     # Train three models with different n_estimators\n110:     n_estimators_list = [100, 1000, 2000]\n111:     models = []\n112:     ndcg_scores = []\n113: \n114:     for n_estimators in n_estimators_list:\n115:         model = XGBRanker(\n116:             objective=\"rank:pairwise\",\n117:             learning_rate=0.1,\n118:             n_estimators=n_estimators,\n119:             max_depth=4,\n120:             random_state=42,\n121:         )\n122:         print(f\"Training XGBoostRanker with n_estimators={n_estimators}...\")\n123:         model.fit(X_train, y_train, group=train_groups)\n124:         y_pred = model.predict(X_test)\n125:         ndcg = evaluate_ndcg(y_test.to_numpy(), y_pred, test_groups)\n126:         print(f\"NDCG Score (n_estimators={n_estimators}): {ndcg:.4f}\")\n127:         models.append(model)\n128:         ndcg_scores.append(ndcg)\n129: \n130:     # Select the best model based on NDCG score\n131:     best_idx = int(np.argmax(ndcg_scores))\n132:     best_model = models[best_idx]\n133:     best_n_estimators = n_estimators_list[best_idx]\n134:     print(f\"Best model n_estimators={best_n_estimators} with NDCG={ndcg_scores[best_idx]:.4f}\")\n135: \n136:     # Predict, sort, and evaluate using the best model\n137:     y_pred = best_model.predict(X_test)\n138:     df.loc[test_idx, \"PredictedScore\"] = y_pred\n139:     df.loc[test_idx, \"PredictedRank\"] = (\n140:         df.loc[test_idx]\n141:         .groupby(\"Year\")[\"PredictedScore\"]\n142:         .rank(ascending=False, method=\"first\")\n143:     )\n144: \n145:     ndcg = evaluate_ndcg(y_test.to_numpy(), y_pred, test_groups)\n146:     print(f\"NDCG Score on test years {test_years.tolist()} (best model): {ndcg:.4f}\")\n147: \n148:     # Show results\n149:     print(df[test_idx][[\"Year\", \"Name\", \"Rank\", \"PredictedScore\", \"PredictedRank\"]])\n150:     plot_ranking_predictions(df, 2024)\n151:     plot_ranking_predictions(df, 2025)"
        },
        "timestamp": "2025-08-16 23:03:36.000",
        "id": "oQkvqyfHTTvJnXhN37xa"
    },
    {
        "source": "backend",
        "event": "map_summary_code",
        "data": {
            "summary": "• Loads data and splits it into training (all but last two years) and test sets (last two years)\n• Trains three XGBoostRanker models on the training data with different n_estimators values\n• Selects the best model based on NDCG score\n• Predicts scores and ranks for the test set using the best model\n• Evaluates model performance using NDCG score\n• Visualizes prediction errors for each test year with bar plots",
            "mapping": [
                {
                    "summaryComponent": "Loads data and splits it into training (all but last two years) and test sets (last two years)",
                    "codeSegments": [
                        {
                            "line": 90,
                            "code": "X, y, group, df = load_data()"
                        },
                        {
                            "line": 93,
                            "code": "unique_years = df[\"Year\"].unique()"
                        },
                        {
                            "line": 94,
                            "code": "train_years, test_years = (\n    unique_years[:-2],  # train: 2015-2023\n    unique_years[-2:],  # test: 2024-2025\n)"
                        },
                        {
                            "line": 99,
                            "code": "train_idx = df[\"Year\"].isin(train_years)"
                        },
                        {
                            "line": 100,
                            "code": "test_idx = df[\"Year\"].isin(test_years)"
                        },
                        {
                            "line": 102,
                            "code": "X_train, X_test = X[train_idx], X[test_idx]"
                        },
                        {
                            "line": 103,
                            "code": "y_train, y_test = y[train_idx], y[test_idx]"
                        }
                    ]
                },
                {
                    "summaryComponent": "Trains three XGBoostRanker models on the training data with different n_estimators values",
                    "codeSegments": [
                        {
                            "line": 110,
                            "code": "n_estimators_list = [100, 1000, 2000]"
                        },
                        {
                            "line": 114,
                            "code": "for n_estimators in n_estimators_list:"
                        },
                        {
                            "line": 115,
                            "code": "model = XGBRanker(\n    objective=\"rank:pairwise\",\n    learning_rate=0.1,\n    n_estimators=n_estimators,\n    max_depth=4,\n    random_state=42,\n)"
                        },
                        {
                            "line": 123,
                            "code": "model.fit(X_train, y_train, group=train_groups)"
                        }
                    ]
                },
                {
                    "summaryComponent": "Selects the best model based on NDCG score",
                    "codeSegments": [
                        {
                            "line": 128,
                            "code": "ndcg_scores.append(ndcg)"
                        },
                        {
                            "line": 131,
                            "code": "best_idx = int(np.argmax(ndcg_scores))"
                        },
                        {
                            "line": 132,
                            "code": "best_model = models[best_idx]"
                        },
                        {
                            "line": 133,
                            "code": "best_n_estimators = n_estimators_list[best_idx]"
                        }
                    ]
                },
                {
                    "summaryComponent": "Predicts scores and ranks for the test set using the best model",
                    "codeSegments": [
                        {
                            "line": 137,
                            "code": "y_pred = best_model.predict(X_test)"
                        },
                        {
                            "line": 138,
                            "code": "df.loc[test_idx, \"PredictedScore\"] = y_pred"
                        },
                        {
                            "line": 139,
                            "code": "df.loc[test_idx, \"PredictedRank\"] = (\n    df.loc[test_idx]\n    .groupby(\"Year\")[\"PredictedScore\"]\n    .rank(ascending=False, method=\"first\")\n)"
                        }
                    ]
                },
                {
                    "summaryComponent": "Evaluates model performance using NDCG score",
                    "codeSegments": [
                        {
                            "line": 145,
                            "code": "ndcg = evaluate_ndcg(y_test.to_numpy(), y_pred, test_groups)"
                        },
                        {
                            "line": 146,
                            "code": "print(f\"NDCG Score on test years {test_years.tolist()} (best model): {ndcg:.4f}\")"
                        }
                    ]
                },
                {
                    "summaryComponent": "Visualizes prediction errors for each test year with bar plots",
                    "codeSegments": [
                        {
                            "line": 150,
                            "code": "plot_ranking_predictions(df, 2024)"
                        },
                        {
                            "line": 151,
                            "code": "plot_ranking_predictions(df, 2025)"
                        }
                    ]
                }
            ],
            "code": "89: def main():\n90:     X, y, group, df = load_data()\n91: \n92:     # Train-test split on years\n93:     unique_years = df[\"Year\"].unique()\n94:     train_years, test_years = (\n95:         unique_years[:-2],  # train: 2015-2023\n96:         unique_years[-2:],  # test: 2024-2025\n97:     )\n98: \n99:     train_idx = df[\"Year\"].isin(train_years)\n100:     test_idx = df[\"Year\"].isin(test_years)\n101: \n102:     X_train, X_test = X[train_idx], X[test_idx]\n103:     y_train, y_test = y[train_idx], y[test_idx]\n104: \n105:     # Group sizes\n106:     train_groups = df[train_idx].groupby(\"Year\").size().to_numpy()\n107:     test_groups = df[test_idx].groupby(\"Year\").size().to_numpy()\n108: \n109:     # Train three models with different n_estimators\n110:     n_estimators_list = [100, 1000, 2000]\n111:     models = []\n112:     ndcg_scores = []\n113: \n114:     for n_estimators in n_estimators_list:\n115:         model = XGBRanker(\n116:             objective=\"rank:pairwise\",\n117:             learning_rate=0.1,\n118:             n_estimators=n_estimators,\n119:             max_depth=4,\n120:             random_state=42,\n121:         )\n122:         print(f\"Training XGBoostRanker with n_estimators={n_estimators}...\")\n123:         model.fit(X_train, y_train, group=train_groups)\n124:         y_pred = model.predict(X_test)\n125:         ndcg = evaluate_ndcg(y_test.to_numpy(), y_pred, test_groups)\n126:         print(f\"NDCG Score (n_estimators={n_estimators}): {ndcg:.4f}\")\n127:         models.append(model)\n128:         ndcg_scores.append(ndcg)\n129: \n130:     # Select the best model based on NDCG score\n131:     best_idx = int(np.argmax(ndcg_scores))\n132:     best_model = models[best_idx]\n133:     best_n_estimators = n_estimators_list[best_idx]\n134:     print(f\"Best model n_estimators={best_n_estimators} with NDCG={ndcg_scores[best_idx]:.4f}\")\n135: \n136:     # Predict, sort, and evaluate using the best model\n137:     y_pred = best_model.predict(X_test)\n138:     df.loc[test_idx, \"PredictedScore\"] = y_pred\n139:     df.loc[test_idx, \"PredictedRank\"] = (\n140:         df.loc[test_idx]\n141:         .groupby(\"Year\")[\"PredictedScore\"]\n142:         .rank(ascending=False, method=\"first\")\n143:     )\n144: \n145:     ndcg = evaluate_ndcg(y_test.to_numpy(), y_pred, test_groups)\n146:     print(f\"NDCG Score on test years {test_years.tolist()} (best model): {ndcg:.4f}\")\n147: \n148:     # Show results\n149:     print(df[test_idx][[\"Year\", \"Name\", \"Rank\", \"PredictedScore\", \"PredictedRank\"]])\n150:     plot_ranking_predictions(df, 2024)\n151:     plot_ranking_predictions(df, 2025)"
        },
        "timestamp": "2025-08-16 23:03:37.000",
        "id": "9xmcP4386FGjgxVCRhAF"
    },
    {
        "source": "backend",
        "event": "map_summary_code",
        "data": {
            "summary": "The main() function loads MVP data, splits it into training and test sets based on years, and trains three XGBoost ranking models on the training data with different n_estimators values. It selects the best model according to the NDCG score, predicts rankings for the test years using this model, evaluates the model using NDCG score, and prints the results. Finally, it generates bar plots to visualize prediction errors for the test years.",
            "mapping": [
                {
                    "summaryComponent": "loads MVP data",
                    "codeSegments": [
                        {
                            "line": 90,
                            "code": "X, y, group, df = load_data()"
                        }
                    ]
                },
                {
                    "summaryComponent": "splits it into training and test sets based on years",
                    "codeSegments": [
                        {
                            "line": 93,
                            "code": "unique_years = df[\"Year\"].unique()"
                        },
                        {
                            "line": 94,
                            "code": "train_years, test_years = ("
                        },
                        {
                            "line": 99,
                            "code": "train_idx = df[\"Year\"].isin(train_years)"
                        },
                        {
                            "line": 100,
                            "code": "test_idx = df[\"Year\"].isin(test_years)"
                        },
                        {
                            "line": 102,
                            "code": "X_train, X_test = X[train_idx], X[test_idx]"
                        },
                        {
                            "line": 103,
                            "code": "y_train, y_test = y[train_idx], y[test_idx]"
                        }
                    ]
                },
                {
                    "summaryComponent": "trains three XGBoost ranking models on the training data with different n_estimators values",
                    "codeSegments": [
                        {
                            "line": 110,
                            "code": "n_estimators_list = [100, 1000, 2000]"
                        },
                        {
                            "line": 114,
                            "code": "for n_estimators in n_estimators_list:"
                        },
                        {
                            "line": 115,
                            "code": "model = XGBRanker("
                        },
                        {
                            "line": 123,
                            "code": "model.fit(X_train, y_train, group=train_groups)"
                        }
                    ]
                },
                {
                    "summaryComponent": "selects the best model according to the NDCG score",
                    "codeSegments": [
                        {
                            "line": 128,
                            "code": "ndcg_scores.append(ndcg)"
                        },
                        {
                            "line": 131,
                            "code": "best_idx = int(np.argmax(ndcg_scores))"
                        },
                        {
                            "line": 132,
                            "code": "best_model = models[best_idx]"
                        }
                    ]
                },
                {
                    "summaryComponent": "predicts rankings for the test years using this model",
                    "codeSegments": [
                        {
                            "line": 137,
                            "code": "y_pred = best_model.predict(X_test)"
                        },
                        {
                            "line": 138,
                            "code": "df.loc[test_idx, \"PredictedScore\"] = y_pred"
                        },
                        {
                            "line": 139,
                            "code": "df.loc[test_idx, \"PredictedRank\"] = ("
                        }
                    ]
                },
                {
                    "summaryComponent": "evaluates the model using NDCG score",
                    "codeSegments": [
                        {
                            "line": 145,
                            "code": "ndcg = evaluate_ndcg(y_test.to_numpy(), y_pred, test_groups)"
                        },
                        {
                            "line": 146,
                            "code": "print(f\"NDCG Score on test years {test_years.tolist()} (best model): {ndcg:.4f}\")"
                        }
                    ]
                },
                {
                    "summaryComponent": "prints the results",
                    "codeSegments": [
                        {
                            "line": 149,
                            "code": "print(df[test_idx][[\"Year\", \"Name\", \"Rank\", \"PredictedScore\", \"PredictedRank\"]])"
                        }
                    ]
                },
                {
                    "summaryComponent": "generates bar plots to visualize prediction errors for the test years",
                    "codeSegments": [
                        {
                            "line": 150,
                            "code": "plot_ranking_predictions(df, 2024)"
                        },
                        {
                            "line": 151,
                            "code": "plot_ranking_predictions(df, 2025)"
                        }
                    ]
                }
            ],
            "code": "89: def main():\n90:     X, y, group, df = load_data()\n91: \n92:     # Train-test split on years\n93:     unique_years = df[\"Year\"].unique()\n94:     train_years, test_years = (\n95:         unique_years[:-2],  # train: 2015-2023\n96:         unique_years[-2:],  # test: 2024-2025\n97:     )\n98: \n99:     train_idx = df[\"Year\"].isin(train_years)\n100:     test_idx = df[\"Year\"].isin(test_years)\n101: \n102:     X_train, X_test = X[train_idx], X[test_idx]\n103:     y_train, y_test = y[train_idx], y[test_idx]\n104: \n105:     # Group sizes\n106:     train_groups = df[train_idx].groupby(\"Year\").size().to_numpy()\n107:     test_groups = df[test_idx].groupby(\"Year\").size().to_numpy()\n108: \n109:     # Train three models with different n_estimators\n110:     n_estimators_list = [100, 1000, 2000]\n111:     models = []\n112:     ndcg_scores = []\n113: \n114:     for n_estimators in n_estimators_list:\n115:         model = XGBRanker(\n116:             objective=\"rank:pairwise\",\n117:             learning_rate=0.1,\n118:             n_estimators=n_estimators,\n119:             max_depth=4,\n120:             random_state=42,\n121:         )\n122:         print(f\"Training XGBoostRanker with n_estimators={n_estimators}...\")\n123:         model.fit(X_train, y_train, group=train_groups)\n124:         y_pred = model.predict(X_test)\n125:         ndcg = evaluate_ndcg(y_test.to_numpy(), y_pred, test_groups)\n126:         print(f\"NDCG Score (n_estimators={n_estimators}): {ndcg:.4f}\")\n127:         models.append(model)\n128:         ndcg_scores.append(ndcg)\n129: \n130:     # Select the best model based on NDCG score\n131:     best_idx = int(np.argmax(ndcg_scores))\n132:     best_model = models[best_idx]\n133:     best_n_estimators = n_estimators_list[best_idx]\n134:     print(f\"Best model n_estimators={best_n_estimators} with NDCG={ndcg_scores[best_idx]:.4f}\")\n135: \n136:     # Predict, sort, and evaluate using the best model\n137:     y_pred = best_model.predict(X_test)\n138:     df.loc[test_idx, \"PredictedScore\"] = y_pred\n139:     df.loc[test_idx, \"PredictedRank\"] = (\n140:         df.loc[test_idx]\n141:         .groupby(\"Year\")[\"PredictedScore\"]\n142:         .rank(ascending=False, method=\"first\")\n143:     )\n144: \n145:     ndcg = evaluate_ndcg(y_test.to_numpy(), y_pred, test_groups)\n146:     print(f\"NDCG Score on test years {test_years.tolist()} (best model): {ndcg:.4f}\")\n147: \n148:     # Show results\n149:     print(df[test_idx][[\"Year\", \"Name\", \"Rank\", \"PredictedScore\", \"PredictedRank\"]])\n150:     plot_ranking_predictions(df, 2024)\n151:     plot_ranking_predictions(df, 2025)"
        },
        "timestamp": "2025-08-16 23:03:37.000",
        "id": "aFzCDCAhUbLExg0dRUKQ"
    },
    {
        "source": "backend",
        "event": "map_summary_code",
        "data": {
            "summary": "The main() function orchestrates the MVP ranking prediction workflow. It first loads the dataset and splits it into training and test sets based on year, with the last two years reserved for testing. The function then trains three XGBoostRanker models with different n_estimators using group-wise ranking objectives, selects the best model based on the highest NDCG score, predicts scores for the test set with this model, and computes predicted ranks within each year. Model performance is evaluated using the NDCG metric, and detailed results, including predicted and true ranks, are printed for the test years. Finally, the function generates and saves bar plots visualizing the prediction errors for each test year.",
            "mapping": [
                {
                    "summaryComponent": "The main() function orchestrates the MVP ranking prediction workflow.",
                    "codeSegments": [
                        {
                            "line": 89,
                            "code": "def main():"
                        }
                    ]
                },
                {
                    "summaryComponent": "The function then trains three XGBoostRanker models with different n_estimators using group-wise ranking objectives,",
                    "codeSegments": [
                        {
                            "line": 110,
                            "code": "n_estimators_list = [100, 1000, 2000]"
                        },
                        {
                            "line": 114,
                            "code": "for n_estimators in n_estimators_list:"
                        },
                        {
                            "line": 115,
                            "code": "model = XGBRanker("
                        },
                        {
                            "line": 116,
                            "code": "objective=\"rank:pairwise\","
                        },
                        {
                            "line": 123,
                            "code": "model.fit(X_train, y_train, group=train_groups)"
                        }
                    ]
                },
                {
                    "summaryComponent": "selects the best model based on the highest NDCG score,",
                    "codeSegments": [
                        {
                            "line": 128,
                            "code": "ndcg_scores.append(ndcg)"
                        },
                        {
                            "line": 131,
                            "code": "best_idx = int(np.argmax(ndcg_scores))"
                        },
                        {
                            "line": 132,
                            "code": "best_model = models[best_idx]"
                        }
                    ]
                },
                {
                    "summaryComponent": "predicts scores for the test set with this model,",
                    "codeSegments": [
                        {
                            "line": 137,
                            "code": "y_pred = best_model.predict(X_test)"
                        }
                    ]
                },
                {
                    "summaryComponent": "and computes predicted ranks within each year.",
                    "codeSegments": [
                        {
                            "line": 138,
                            "code": "df.loc[test_idx, \"PredictedScore\"] = y_pred"
                        },
                        {
                            "line": 139,
                            "code": "df.loc[test_idx, \"PredictedRank\"] = ("
                        },
                        {
                            "line": 140,
                            "code": "df.loc[test_idx]"
                        },
                        {
                            "line": 141,
                            "code": ".groupby(\"Year\")[\"PredictedScore\"]"
                        },
                        {
                            "line": 142,
                            "code": ".rank(ascending=False, method=\"first\")"
                        }
                    ]
                },
                {
                    "summaryComponent": "Model performance is evaluated using the NDCG metric,",
                    "codeSegments": [
                        {
                            "line": 145,
                            "code": "ndcg = evaluate_ndcg(y_test.to_numpy(), y_pred, test_groups)"
                        }
                    ]
                },
                {
                    "summaryComponent": "and detailed results, including predicted and true ranks, are printed for the test years.",
                    "codeSegments": [
                        {
                            "line": 149,
                            "code": "print(df[test_idx][[\"Year\", \"Name\", \"Rank\", \"PredictedScore\", \"PredictedRank\"]])"
                        }
                    ]
                },
                {
                    "summaryComponent": "Finally, the function generates and saves bar plots visualizing the prediction errors for each test year.",
                    "codeSegments": [
                        {
                            "line": 150,
                            "code": "plot_ranking_predictions(df, 2024)"
                        },
                        {
                            "line": 151,
                            "code": "plot_ranking_predictions(df, 2025)"
                        }
                    ]
                }
            ],
            "code": "89: def main():\n90:     X, y, group, df = load_data()\n91: \n92:     # Train-test split on years\n93:     unique_years = df[\"Year\"].unique()\n94:     train_years, test_years = (\n95:         unique_years[:-2],  # train: 2015-2023\n96:         unique_years[-2:],  # test: 2024-2025\n97:     )\n98: \n99:     train_idx = df[\"Year\"].isin(train_years)\n100:     test_idx = df[\"Year\"].isin(test_years)\n101: \n102:     X_train, X_test = X[train_idx], X[test_idx]\n103:     y_train, y_test = y[train_idx], y[test_idx]\n104: \n105:     # Group sizes\n106:     train_groups = df[train_idx].groupby(\"Year\").size().to_numpy()\n107:     test_groups = df[test_idx].groupby(\"Year\").size().to_numpy()\n108: \n109:     # Train three models with different n_estimators\n110:     n_estimators_list = [100, 1000, 2000]\n111:     models = []\n112:     ndcg_scores = []\n113: \n114:     for n_estimators in n_estimators_list:\n115:         model = XGBRanker(\n116:             objective=\"rank:pairwise\",\n117:             learning_rate=0.1,\n118:             n_estimators=n_estimators,\n119:             max_depth=4,\n120:             random_state=42,\n121:         )\n122:         print(f\"Training XGBoostRanker with n_estimators={n_estimators}...\")\n123:         model.fit(X_train, y_train, group=train_groups)\n124:         y_pred = model.predict(X_test)\n125:         ndcg = evaluate_ndcg(y_test.to_numpy(), y_pred, test_groups)\n126:         print(f\"NDCG Score (n_estimators={n_estimators}): {ndcg:.4f}\")\n127:         models.append(model)\n128:         ndcg_scores.append(ndcg)\n129: \n130:     # Select the best model based on NDCG score\n131:     best_idx = int(np.argmax(ndcg_scores))\n132:     best_model = models[best_idx]\n133:     best_n_estimators = n_estimators_list[best_idx]\n134:     print(f\"Best model n_estimators={best_n_estimators} with NDCG={ndcg_scores[best_idx]:.4f}\")\n135: \n136:     # Predict, sort, and evaluate using the best model\n137:     y_pred = best_model.predict(X_test)\n138:     df.loc[test_idx, \"PredictedScore\"] = y_pred\n139:     df.loc[test_idx, \"PredictedRank\"] = (\n140:         df.loc[test_idx]\n141:         .groupby(\"Year\")[\"PredictedScore\"]\n142:         .rank(ascending=False, method=\"first\")\n143:     )\n144: \n145:     ndcg = evaluate_ndcg(y_test.to_numpy(), y_pred, test_groups)\n146:     print(f\"NDCG Score on test years {test_years.tolist()} (best model): {ndcg:.4f}\")\n147: \n148:     # Show results\n149:     print(df[test_idx][[\"Year\", \"Name\", \"Rank\", \"PredictedScore\", \"PredictedRank\"]])\n150:     plot_ranking_predictions(df, 2024)\n151:     plot_ranking_predictions(df, 2025)"
        },
        "timestamp": "2025-08-16 23:03:38.000",
        "id": "dGCKnQcnMDUaoePZikpf"
    },
    {
        "source": "backend",
        "event": "map_summary_code",
        "data": {
            "summary": "• Loads the dataset and extracts features, target ranks, group information, and the full DataFrame\n• Splits data into training (all years except the last two) and test sets (last two years)\n  ◦ Determines train/test indices and separates features and targets accordingly\n  ◦ Computes group sizes for each year in both splits\n• Initializes and trains three XGBoostRanker models with different n_estimators on the training data\n  ◦ Evaluates each model's performance using NDCG score on the test set\n  ◦ Selects the best model based on the highest NDCG score\n• Predicts ranking scores for the test set using the best model\n  ◦ Assigns predicted scores and computes predicted ranks within each test year\n• Evaluates model performance using the NDCG score on the test set\n• Prints a summary table with year, player name, true rank, predicted score, and predicted rank for the test years\n• Generates and saves bar plots visualizing prediction errors for each of the test years",
            "mapping": [
                {
                    "summaryComponent": "Loads the dataset and extracts features, target ranks, group information, and the full DataFrame",
                    "codeSegments": [
                        {
                            "line": 90,
                            "code": "X, y, group, df = load_data()"
                        }
                    ]
                },
                {
                    "summaryComponent": "Splits data into training (all years except the last two) and test sets (last two years)",
                    "codeSegments": [
                        {
                            "line": 93,
                            "code": "unique_years = df[\"Year\"].unique()"
                        },
                        {
                            "line": 94,
                            "code": "train_years, test_years = ("
                        },
                        {
                            "line": 95,
                            "code": "unique_years[:-2],  # train: 2015-2023"
                        },
                        {
                            "line": 96,
                            "code": "unique_years[-2:],  # test: 2024-2025"
                        }
                    ]
                },
                {
                    "summaryComponent": "Determines train/test indices and separates features and targets accordingly",
                    "codeSegments": [
                        {
                            "line": 99,
                            "code": "train_idx = df[\"Year\"].isin(train_years)"
                        },
                        {
                            "line": 100,
                            "code": "test_idx = df[\"Year\"].isin(test_years)"
                        },
                        {
                            "line": 102,
                            "code": "X_train, X_test = X[train_idx], X[test_idx]"
                        },
                        {
                            "line": 103,
                            "code": "y_train, y_test = y[train_idx], y[test_idx]"
                        }
                    ]
                },
                {
                    "summaryComponent": "Computes group sizes for each year in both splits",
                    "codeSegments": [
                        {
                            "line": 106,
                            "code": "train_groups = df[train_idx].groupby(\"Year\").size().to_numpy()"
                        },
                        {
                            "line": 107,
                            "code": "test_groups = df[test_idx].groupby(\"Year\").size().to_numpy()"
                        }
                    ]
                },
                {
                    "summaryComponent": "Initializes and trains three XGBoostRanker models with different n_estimators on the training data",
                    "codeSegments": [
                        {
                            "line": 110,
                            "code": "n_estimators_list = [100, 1000, 2000]"
                        },
                        {
                            "line": 114,
                            "code": "for n_estimators in n_estimators_list:"
                        },
                        {
                            "line": 115,
                            "code": "model = XGBRanker("
                        },
                        {
                            "line": 123,
                            "code": "model.fit(X_train, y_train, group=train_groups)"
                        }
                    ]
                },
                {
                    "summaryComponent": "Evaluates each model's performance using NDCG score on the test set",
                    "codeSegments": [
                        {
                            "line": 124,
                            "code": "y_pred = model.predict(X_test)"
                        },
                        {
                            "line": 125,
                            "code": "ndcg = evaluate_ndcg(y_test.to_numpy(), y_pred, test_groups)"
                        },
                        {
                            "line": 126,
                            "code": "print(f\"NDCG Score (n_estimators={n_estimators}): {ndcg:.4f}\")"
                        }
                    ]
                },
                {
                    "summaryComponent": "Selects the best model based on the highest NDCG score",
                    "codeSegments": [
                        {
                            "line": 131,
                            "code": "best_idx = int(np.argmax(ndcg_scores))"
                        },
                        {
                            "line": 132,
                            "code": "best_model = models[best_idx]"
                        },
                        {
                            "line": 133,
                            "code": "best_n_estimators = n_estimators_list[best_idx]"
                        },
                        {
                            "line": 134,
                            "code": "print(f\"Best model n_estimators={best_n_estimators} with NDCG={ndcg_scores[best_idx]:.4f}\")"
                        }
                    ]
                },
                {
                    "summaryComponent": "Predicts ranking scores for the test set using the best model",
                    "codeSegments": [
                        {
                            "line": 137,
                            "code": "y_pred = best_model.predict(X_test)"
                        }
                    ]
                },
                {
                    "summaryComponent": "Assigns predicted scores and computes predicted ranks within each test year",
                    "codeSegments": [
                        {
                            "line": 138,
                            "code": "df.loc[test_idx, \"PredictedScore\"] = y_pred"
                        },
                        {
                            "line": 139,
                            "code": "df.loc[test_idx, \"PredictedRank\"] = ("
                        },
                        {
                            "line": 140,
                            "code": "df.loc[test_idx]"
                        },
                        {
                            "line": 141,
                            "code": ".groupby(\"Year\")[\"PredictedScore\"]"
                        },
                        {
                            "line": 142,
                            "code": ".rank(ascending=False, method=\"first\")"
                        }
                    ]
                },
                {
                    "summaryComponent": "Evaluates model performance using the NDCG score on the test set",
                    "codeSegments": [
                        {
                            "line": 145,
                            "code": "ndcg = evaluate_ndcg(y_test.to_numpy(), y_pred, test_groups)"
                        },
                        {
                            "line": 146,
                            "code": "print(f\"NDCG Score on test years {test_years.tolist()} (best model): {ndcg:.4f}\")"
                        }
                    ]
                },
                {
                    "summaryComponent": "Prints a summary table with year, player name, true rank, predicted score, and predicted rank for the test years",
                    "codeSegments": [
                        {
                            "line": 149,
                            "code": "print(df[test_idx][[\"Year\", \"Name\", \"Rank\", \"PredictedScore\", \"PredictedRank\"]])"
                        }
                    ]
                },
                {
                    "summaryComponent": "Generates and saves bar plots visualizing prediction errors for each of the test years",
                    "codeSegments": [
                        {
                            "line": 150,
                            "code": "plot_ranking_predictions(df, 2024)"
                        },
                        {
                            "line": 151,
                            "code": "plot_ranking_predictions(df, 2025)"
                        }
                    ]
                }
            ],
            "code": "89: def main():\n90:     X, y, group, df = load_data()\n91: \n92:     # Train-test split on years\n93:     unique_years = df[\"Year\"].unique()\n94:     train_years, test_years = (\n95:         unique_years[:-2],  # train: 2015-2023\n96:         unique_years[-2:],  # test: 2024-2025\n97:     )\n98: \n99:     train_idx = df[\"Year\"].isin(train_years)\n100:     test_idx = df[\"Year\"].isin(test_years)\n101: \n102:     X_train, X_test = X[train_idx], X[test_idx]\n103:     y_train, y_test = y[train_idx], y[test_idx]\n104: \n105:     # Group sizes\n106:     train_groups = df[train_idx].groupby(\"Year\").size().to_numpy()\n107:     test_groups = df[test_idx].groupby(\"Year\").size().to_numpy()\n108: \n109:     # Train three models with different n_estimators\n110:     n_estimators_list = [100, 1000, 2000]\n111:     models = []\n112:     ndcg_scores = []\n113: \n114:     for n_estimators in n_estimators_list:\n115:         model = XGBRanker(\n116:             objective=\"rank:pairwise\",\n117:             learning_rate=0.1,\n118:             n_estimators=n_estimators,\n119:             max_depth=4,\n120:             random_state=42,\n121:         )\n122:         print(f\"Training XGBoostRanker with n_estimators={n_estimators}...\")\n123:         model.fit(X_train, y_train, group=train_groups)\n124:         y_pred = model.predict(X_test)\n125:         ndcg = evaluate_ndcg(y_test.to_numpy(), y_pred, test_groups)\n126:         print(f\"NDCG Score (n_estimators={n_estimators}): {ndcg:.4f}\")\n127:         models.append(model)\n128:         ndcg_scores.append(ndcg)\n129: \n130:     # Select the best model based on NDCG score\n131:     best_idx = int(np.argmax(ndcg_scores))\n132:     best_model = models[best_idx]\n133:     best_n_estimators = n_estimators_list[best_idx]\n134:     print(f\"Best model n_estimators={best_n_estimators} with NDCG={ndcg_scores[best_idx]:.4f}\")\n135: \n136:     # Predict, sort, and evaluate using the best model\n137:     y_pred = best_model.predict(X_test)\n138:     df.loc[test_idx, \"PredictedScore\"] = y_pred\n139:     df.loc[test_idx, \"PredictedRank\"] = (\n140:         df.loc[test_idx]\n141:         .groupby(\"Year\")[\"PredictedScore\"]\n142:         .rank(ascending=False, method=\"first\")\n143:     )\n144: \n145:     ndcg = evaluate_ndcg(y_test.to_numpy(), y_pred, test_groups)\n146:     print(f\"NDCG Score on test years {test_years.tolist()} (best model): {ndcg:.4f}\")\n147: \n148:     # Show results\n149:     print(df[test_idx][[\"Year\", \"Name\", \"Rank\", \"PredictedScore\", \"PredictedRank\"]])\n150:     plot_ranking_predictions(df, 2024)\n151:     plot_ranking_predictions(df, 2025)"
        },
        "timestamp": "2025-08-16 23:03:39.000",
        "id": "0BGjXdKhdUXUCXnPzzxT"
    },
    {
        "source": "frontend",
        "event": "create_new_section",
        "data": {
            "section_id": "d36650a7-ba7a-4b56-9484-7b316e17b625",
            "section_data": {
                "editPromptDetailLevel": null,
                "selectedStructured": "unstructured",
                "createdAt": 1755371019000,
                "lines": [
                    89,
                    151
                ],
                "editPromptStructured": null,
                "summaryData": {
                    "low_structured": "• Loads data and splits it into training and test sets\n• Trains multiple XGBoost ranking models with varying n_estimators and selects the best based on NDCG score\n• Evaluates and visualizes predictions for test years",
                    "high_unstructured": "The main() function orchestrates the MVP ranking prediction workflow. It first loads the dataset and splits it into training and test sets based on year, with the last two years reserved for testing. The function then trains three XGBoostRanker models with different n_estimators using group-wise ranking objectives, selects the best model based on the highest NDCG score, predicts scores for the test set with this model, and computes predicted ranks within each year. Model performance is evaluated using the NDCG metric, and detailed results, including predicted and true ranks, are printed for the test years. Finally, the function generates and saves bar plots visualizing the prediction errors for each test year.",
                    "medium_unstructured": "The main() function loads MVP data, splits it into training and test sets based on years, and trains three XGBoost ranking models on the training data with different n_estimators values. It selects the best model according to the NDCG score, predicts rankings for the test years using this model, evaluates the model using NDCG score, and prints the results. Finally, it generates bar plots to visualize prediction errors for the test years.",
                    "high_structured": "• Loads the dataset and extracts features, target ranks, group information, and the full DataFrame\n• Splits data into training (all years except the last two) and test sets (last two years)\n  ◦ Determines train/test indices and separates features and targets accordingly\n  ◦ Computes group sizes for each year in both splits\n• Initializes and trains three XGBoostRanker models with different n_estimators on the training data\n  ◦ Evaluates each model's performance using NDCG score on the test set\n  ◦ Selects the best model based on the highest NDCG score\n• Predicts ranking scores for the test set using the best model\n  ◦ Assigns predicted scores and computes predicted ranks within each test year\n• Evaluates model performance using the NDCG score on the test set\n• Prints a summary table with year, player name, true rank, predicted score, and predicted rank for the test years\n• Generates and saves bar plots visualizing prediction errors for each of the test years",
                    "title": "Summary of the main() Function for MVP Ranking Prediction (with Model Selection Enhancement)",
                    "low_unstructured": "This function loads data, trains multiple XGBoost ranking models with different n_estimators, selects the best model based on NDCG score, evaluates its performance, and visualizes prediction results for recent years.",
                    "medium_structured": "• Loads data and splits it into training (all but last two years) and test sets (last two years)\n• Trains three XGBoostRanker models on the training data with different n_estimators values\n• Selects the best model based on NDCG score\n• Predicts scores and ranks for the test set using the best model\n• Evaluates model performance using NDCG score\n• Visualizes prediction errors for each test year with bar plots"
                },
                "selectedDetailLevel": "medium",
                "oldSummaryData": {
                    "low_structured": "• Loads data and splits it into training and test sets\n• Trains an XGBoost ranking model\n• Evaluates and visualizes predictions for test years",
                    "high_unstructured": "The main() function orchestrates the MVP ranking prediction workflow. It first loads the dataset and splits it into training and test sets based on year, with the last two years reserved for testing. The function then trains an XGBoostRanker model using group-wise ranking objectives, predicts scores for the test set, and computes predicted ranks within each year. Model performance is evaluated using the NDCG metric, and detailed results, including predicted and true ranks, are printed for the test years. Finally, the function generates and saves bar plots visualizing the prediction errors for each test year.",
                    "medium_unstructured": "The main() function loads MVP data, splits it into training and test sets based on years, and trains an XGBoost ranking model on the training data. It predicts rankings for the test years, evaluates the model using NDCG score, and prints the results. Finally, it generates bar plots to visualize prediction errors for the test years.",
                    "high_structured": "• Loads the dataset and extracts features, target ranks, group information, and the full DataFrame\n• Splits data into training (all years except the last two) and test sets (last two years)\n  ◦ Determines train/test indices and separates features and targets accordingly\n  ◦ Computes group sizes for each year in both splits\n• Initializes and trains an XGBoostRanker model with specified hyperparameters on the training data\n• Predicts ranking scores for the test set\n  ◦ Assigns predicted scores and computes predicted ranks within each test year\n• Evaluates model performance using the NDCG score on the test set\n• Prints a summary table with year, player name, true rank, predicted score, and predicted rank for the test years\n• Generates and saves bar plots visualizing prediction errors for each of the test years",
                    "title": "Summary of the main() Function for MVP Ranking Prediction",
                    "low_unstructured": "This function loads data, trains an XGBoost ranking model, evaluates its performance, and visualizes prediction results for recent years.",
                    "medium_structured": "• Loads data and splits it into training (all but last two years) and test sets (last two years)\n• Trains an XGBoostRanker model on the training data\n• Predicts scores and ranks for the test set\n• Evaluates model performance using NDCG score\n• Visualizes prediction errors for each test year with bar plots"
                },
                "metadata": {
                    "originalCode": "def main():\n    X, y, group, df = load_data()\n\n    # Train-test split on years\n    unique_years = df[\"Year\"].unique()\n    train_years, test_years = (\n        unique_years[:-2],  # train: 2015-2023\n        unique_years[-2:],  # test: 2024-2025\n    )\n\n    train_idx = df[\"Year\"].isin(train_years)\n    test_idx = df[\"Year\"].isin(test_years)\n\n    X_train, X_test = X[train_idx], X[test_idx]\n    y_train, y_test = y[train_idx], y[test_idx]\n\n    # Group sizes\n    train_groups = df[train_idx].groupby(\"Year\").size().to_numpy()\n    test_groups = df[test_idx].groupby(\"Year\").size().to_numpy()\n\n    # Train three models with different n_estimators\n    n_estimators_list = [100, 1000, 2000]\n    models = []\n    ndcg_scores = []\n\n    for n_estimators in n_estimators_list:\n        model = XGBRanker(\n            objective=\"rank:pairwise\",\n            learning_rate=0.1,\n            n_estimators=n_estimators,\n            max_depth=4,\n            random_state=42,\n        )\n        print(f\"Training XGBoostRanker with n_estimators={n_estimators}...\")\n        model.fit(X_train, y_train, group=train_groups)\n        y_pred = model.predict(X_test)\n        ndcg = evaluate_ndcg(y_test.to_numpy(), y_pred, test_groups)\n        print(f\"NDCG Score (n_estimators={n_estimators}): {ndcg:.4f}\")\n        models.append(model)\n        ndcg_scores.append(ndcg)\n\n    # Select the best model based on NDCG score\n    best_idx = int(np.argmax(ndcg_scores))\n    best_model = models[best_idx]\n    best_n_estimators = n_estimators_list[best_idx]\n    print(f\"Best model n_estimators={best_n_estimators} with NDCG={ndcg_scores[best_idx]:.4f}\")\n\n    # Predict, sort, and evaluate using the best model\n    y_pred = best_model.predict(X_test)\n    df.loc[test_idx, \"PredictedScore\"] = y_pred\n    df.loc[test_idx, \"PredictedRank\"] = (\n        df.loc[test_idx]\n        .groupby(\"Year\")[\"PredictedScore\"]\n        .rank(ascending=False, method=\"first\")\n    )\n\n    ndcg = evaluate_ndcg(y_test.to_numpy(), y_pred, test_groups)\n    print(f\"NDCG Score on test years {test_years.tolist()} (best model): {ndcg:.4f}\")\n\n    # Show results\n    print(df[test_idx][[\"Year\", \"Name\", \"Rank\", \"PredictedScore\", \"PredictedRank\"]])\n    plot_ranking_predictions(df, 2024)\n    plot_ranking_predictions(df, 2025)",
                    "fullPath": "/project/workspace/rank_model.py",
                    "id": "d36650a7-ba7a-4b56-9484-7b316e17b625",
                    "offset": 2243,
                    "filename": "rank_model.py"
                },
                "editPromptValue": "",
                "title": "Summary of the main() Function for MVP Ranking Prediction (with Model Selection Enhancement)",
                "summaryMappings": {
                    "high_unstructured": [
                        {
                            "summaryComponent": "The main() function orchestrates the MVP ranking prediction workflow.",
                            "codeSegments": [
                                {
                                    "line": 89,
                                    "code": "def main():"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "The function then trains three XGBoostRanker models with different n_estimators using group-wise ranking objectives,",
                            "codeSegments": [
                                {
                                    "line": 110,
                                    "code": "n_estimators_list = [100, 1000, 2000]"
                                },
                                {
                                    "line": 114,
                                    "code": "for n_estimators in n_estimators_list:"
                                },
                                {
                                    "line": 115,
                                    "code": "model = XGBRanker("
                                },
                                {
                                    "line": 116,
                                    "code": "objective=\"rank:pairwise\","
                                },
                                {
                                    "line": 123,
                                    "code": "model.fit(X_train, y_train, group=train_groups)"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "selects the best model based on the highest NDCG score,",
                            "codeSegments": [
                                {
                                    "line": 128,
                                    "code": "ndcg_scores.append(ndcg)"
                                },
                                {
                                    "line": 131,
                                    "code": "best_idx = int(np.argmax(ndcg_scores))"
                                },
                                {
                                    "line": 132,
                                    "code": "best_model = models[best_idx]"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "predicts scores for the test set with this model,",
                            "codeSegments": [
                                {
                                    "line": 137,
                                    "code": "y_pred = best_model.predict(X_test)"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "and computes predicted ranks within each year.",
                            "codeSegments": [
                                {
                                    "line": 138,
                                    "code": "df.loc[test_idx, \"PredictedScore\"] = y_pred"
                                },
                                {
                                    "line": 139,
                                    "code": "df.loc[test_idx, \"PredictedRank\"] = ("
                                },
                                {
                                    "line": 140,
                                    "code": "df.loc[test_idx]"
                                },
                                {
                                    "line": 141,
                                    "code": ".groupby(\"Year\")[\"PredictedScore\"]"
                                },
                                {
                                    "line": 142,
                                    "code": ".rank(ascending=False, method=\"first\")"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "Model performance is evaluated using the NDCG metric,",
                            "codeSegments": [
                                {
                                    "line": 145,
                                    "code": "ndcg = evaluate_ndcg(y_test.to_numpy(), y_pred, test_groups)"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "and detailed results, including predicted and true ranks, are printed for the test years.",
                            "codeSegments": [
                                {
                                    "line": 149,
                                    "code": "print(df[test_idx][[\"Year\", \"Name\", \"Rank\", \"PredictedScore\", \"PredictedRank\"]])"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "Finally, the function generates and saves bar plots visualizing the prediction errors for each test year.",
                            "codeSegments": [
                                {
                                    "line": 150,
                                    "code": "plot_ranking_predictions(df, 2024)"
                                },
                                {
                                    "line": 151,
                                    "code": "plot_ranking_predictions(df, 2025)"
                                }
                            ]
                        }
                    ],
                    "medium_unstructured": [
                        {
                            "summaryComponent": "loads MVP data",
                            "codeSegments": [
                                {
                                    "line": 90,
                                    "code": "X, y, group, df = load_data()"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "splits it into training and test sets based on years",
                            "codeSegments": [
                                {
                                    "line": 93,
                                    "code": "unique_years = df[\"Year\"].unique()"
                                },
                                {
                                    "line": 94,
                                    "code": "train_years, test_years = ("
                                },
                                {
                                    "line": 99,
                                    "code": "train_idx = df[\"Year\"].isin(train_years)"
                                },
                                {
                                    "line": 100,
                                    "code": "test_idx = df[\"Year\"].isin(test_years)"
                                },
                                {
                                    "line": 102,
                                    "code": "X_train, X_test = X[train_idx], X[test_idx]"
                                },
                                {
                                    "line": 103,
                                    "code": "y_train, y_test = y[train_idx], y[test_idx]"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "trains three XGBoost ranking models on the training data with different n_estimators values",
                            "codeSegments": [
                                {
                                    "line": 110,
                                    "code": "n_estimators_list = [100, 1000, 2000]"
                                },
                                {
                                    "line": 114,
                                    "code": "for n_estimators in n_estimators_list:"
                                },
                                {
                                    "line": 115,
                                    "code": "model = XGBRanker("
                                },
                                {
                                    "line": 123,
                                    "code": "model.fit(X_train, y_train, group=train_groups)"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "selects the best model according to the NDCG score",
                            "codeSegments": [
                                {
                                    "line": 128,
                                    "code": "ndcg_scores.append(ndcg)"
                                },
                                {
                                    "line": 131,
                                    "code": "best_idx = int(np.argmax(ndcg_scores))"
                                },
                                {
                                    "line": 132,
                                    "code": "best_model = models[best_idx]"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "predicts rankings for the test years using this model",
                            "codeSegments": [
                                {
                                    "line": 137,
                                    "code": "y_pred = best_model.predict(X_test)"
                                },
                                {
                                    "line": 138,
                                    "code": "df.loc[test_idx, \"PredictedScore\"] = y_pred"
                                },
                                {
                                    "line": 139,
                                    "code": "df.loc[test_idx, \"PredictedRank\"] = ("
                                }
                            ]
                        },
                        {
                            "summaryComponent": "evaluates the model using NDCG score",
                            "codeSegments": [
                                {
                                    "line": 145,
                                    "code": "ndcg = evaluate_ndcg(y_test.to_numpy(), y_pred, test_groups)"
                                },
                                {
                                    "line": 146,
                                    "code": "print(f\"NDCG Score on test years {test_years.tolist()} (best model): {ndcg:.4f}\")"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "prints the results",
                            "codeSegments": [
                                {
                                    "line": 149,
                                    "code": "print(df[test_idx][[\"Year\", \"Name\", \"Rank\", \"PredictedScore\", \"PredictedRank\"]])"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "generates bar plots to visualize prediction errors for the test years",
                            "codeSegments": [
                                {
                                    "line": 150,
                                    "code": "plot_ranking_predictions(df, 2024)"
                                },
                                {
                                    "line": 151,
                                    "code": "plot_ranking_predictions(df, 2025)"
                                }
                            ]
                        }
                    ],
                    "high_structured": [
                        {
                            "summaryComponent": "Loads the dataset and extracts features, target ranks, group information, and the full DataFrame",
                            "codeSegments": [
                                {
                                    "line": 90,
                                    "code": "X, y, group, df = load_data()"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "Splits data into training (all years except the last two) and test sets (last two years)",
                            "codeSegments": [
                                {
                                    "line": 93,
                                    "code": "unique_years = df[\"Year\"].unique()"
                                },
                                {
                                    "line": 94,
                                    "code": "train_years, test_years = ("
                                },
                                {
                                    "line": 95,
                                    "code": "unique_years[:-2],  # train: 2015-2023"
                                },
                                {
                                    "line": 96,
                                    "code": "unique_years[-2:],  # test: 2024-2025"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "Determines train/test indices and separates features and targets accordingly",
                            "codeSegments": [
                                {
                                    "line": 99,
                                    "code": "train_idx = df[\"Year\"].isin(train_years)"
                                },
                                {
                                    "line": 100,
                                    "code": "test_idx = df[\"Year\"].isin(test_years)"
                                },
                                {
                                    "line": 102,
                                    "code": "X_train, X_test = X[train_idx], X[test_idx]"
                                },
                                {
                                    "line": 103,
                                    "code": "y_train, y_test = y[train_idx], y[test_idx]"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "Computes group sizes for each year in both splits",
                            "codeSegments": [
                                {
                                    "line": 106,
                                    "code": "train_groups = df[train_idx].groupby(\"Year\").size().to_numpy()"
                                },
                                {
                                    "line": 107,
                                    "code": "test_groups = df[test_idx].groupby(\"Year\").size().to_numpy()"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "Initializes and trains three XGBoostRanker models with different n_estimators on the training data",
                            "codeSegments": [
                                {
                                    "line": 110,
                                    "code": "n_estimators_list = [100, 1000, 2000]"
                                },
                                {
                                    "line": 114,
                                    "code": "for n_estimators in n_estimators_list:"
                                },
                                {
                                    "line": 115,
                                    "code": "model = XGBRanker("
                                },
                                {
                                    "line": 123,
                                    "code": "model.fit(X_train, y_train, group=train_groups)"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "Evaluates each model's performance using NDCG score on the test set",
                            "codeSegments": [
                                {
                                    "line": 124,
                                    "code": "y_pred = model.predict(X_test)"
                                },
                                {
                                    "line": 125,
                                    "code": "ndcg = evaluate_ndcg(y_test.to_numpy(), y_pred, test_groups)"
                                },
                                {
                                    "line": 126,
                                    "code": "print(f\"NDCG Score (n_estimators={n_estimators}): {ndcg:.4f}\")"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "Selects the best model based on the highest NDCG score",
                            "codeSegments": [
                                {
                                    "line": 131,
                                    "code": "best_idx = int(np.argmax(ndcg_scores))"
                                },
                                {
                                    "line": 132,
                                    "code": "best_model = models[best_idx]"
                                },
                                {
                                    "line": 133,
                                    "code": "best_n_estimators = n_estimators_list[best_idx]"
                                },
                                {
                                    "line": 134,
                                    "code": "print(f\"Best model n_estimators={best_n_estimators} with NDCG={ndcg_scores[best_idx]:.4f}\")"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "Predicts ranking scores for the test set using the best model",
                            "codeSegments": [
                                {
                                    "line": 137,
                                    "code": "y_pred = best_model.predict(X_test)"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "Assigns predicted scores and computes predicted ranks within each test year",
                            "codeSegments": [
                                {
                                    "line": 138,
                                    "code": "df.loc[test_idx, \"PredictedScore\"] = y_pred"
                                },
                                {
                                    "line": 139,
                                    "code": "df.loc[test_idx, \"PredictedRank\"] = ("
                                },
                                {
                                    "line": 140,
                                    "code": "df.loc[test_idx]"
                                },
                                {
                                    "line": 141,
                                    "code": ".groupby(\"Year\")[\"PredictedScore\"]"
                                },
                                {
                                    "line": 142,
                                    "code": ".rank(ascending=False, method=\"first\")"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "Evaluates model performance using the NDCG score on the test set",
                            "codeSegments": [
                                {
                                    "line": 145,
                                    "code": "ndcg = evaluate_ndcg(y_test.to_numpy(), y_pred, test_groups)"
                                },
                                {
                                    "line": 146,
                                    "code": "print(f\"NDCG Score on test years {test_years.tolist()} (best model): {ndcg:.4f}\")"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "Prints a summary table with year, player name, true rank, predicted score, and predicted rank for the test years",
                            "codeSegments": [
                                {
                                    "line": 149,
                                    "code": "print(df[test_idx][[\"Year\", \"Name\", \"Rank\", \"PredictedScore\", \"PredictedRank\"]])"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "Generates and saves bar plots visualizing prediction errors for each of the test years",
                            "codeSegments": [
                                {
                                    "line": 150,
                                    "code": "plot_ranking_predictions(df, 2024)"
                                },
                                {
                                    "line": 151,
                                    "code": "plot_ranking_predictions(df, 2025)"
                                }
                            ]
                        }
                    ],
                    "low_unstructured": [
                        {
                            "summaryComponent": "loads data",
                            "codeSegments": [
                                {
                                    "line": 90,
                                    "code": "X, y, group, df = load_data()"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "trains multiple XGBoost ranking models",
                            "codeSegments": [
                                {
                                    "line": 114,
                                    "code": "for n_estimators in n_estimators_list:"
                                },
                                {
                                    "line": 115,
                                    "code": "model = XGBRanker("
                                },
                                {
                                    "line": 123,
                                    "code": "model.fit(X_train, y_train, group=train_groups)"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "with different n_estimators",
                            "codeSegments": [
                                {
                                    "line": 110,
                                    "code": "n_estimators_list = [100, 1000, 2000]"
                                },
                                {
                                    "line": 114,
                                    "code": "for n_estimators in n_estimators_list:"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "selects the best model based on NDCG score",
                            "codeSegments": [
                                {
                                    "line": 131,
                                    "code": "best_idx = int(np.argmax(ndcg_scores))"
                                },
                                {
                                    "line": 132,
                                    "code": "best_model = models[best_idx]"
                                },
                                {
                                    "line": 133,
                                    "code": "best_n_estimators = n_estimators_list[best_idx]"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "evaluates its performance",
                            "codeSegments": [
                                {
                                    "line": 145,
                                    "code": "ndcg = evaluate_ndcg(y_test.to_numpy(), y_pred, test_groups)"
                                },
                                {
                                    "line": 146,
                                    "code": "print(f\"NDCG Score on test years {test_years.tolist()} (best model): {ndcg:.4f}\")"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "visualizes prediction results for recent years",
                            "codeSegments": [
                                {
                                    "line": 150,
                                    "code": "plot_ranking_predictions(df, 2024)"
                                },
                                {
                                    "line": 151,
                                    "code": "plot_ranking_predictions(df, 2025)"
                                }
                            ]
                        }
                    ],
                    "low_structured": [
                        {
                            "summaryComponent": "Loads data and splits it into training and test sets",
                            "codeSegments": [
                                {
                                    "line": 90,
                                    "code": "X, y, group, df = load_data()"
                                },
                                {
                                    "line": 93,
                                    "code": "unique_years = df[\"Year\"].unique()"
                                },
                                {
                                    "line": 94,
                                    "code": "train_years, test_years = (\n    unique_years[:-2],  # train: 2015-2023\n    unique_years[-2:],  # test: 2024-2025\n)"
                                },
                                {
                                    "line": 99,
                                    "code": "train_idx = df[\"Year\"].isin(train_years)"
                                },
                                {
                                    "line": 100,
                                    "code": "test_idx = df[\"Year\"].isin(test_years)"
                                },
                                {
                                    "line": 102,
                                    "code": "X_train, X_test = X[train_idx], X[test_idx]"
                                },
                                {
                                    "line": 103,
                                    "code": "y_train, y_test = y[train_idx], y[test_idx]"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "Trains multiple XGBoost ranking models with varying n_estimators and selects the best based on NDCG score",
                            "codeSegments": [
                                {
                                    "line": 110,
                                    "code": "n_estimators_list = [100, 1000, 2000]"
                                },
                                {
                                    "line": 114,
                                    "code": "for n_estimators in n_estimators_list:"
                                },
                                {
                                    "line": 115,
                                    "code": "model = XGBRanker("
                                },
                                {
                                    "line": 123,
                                    "code": "model.fit(X_train, y_train, group=train_groups)"
                                },
                                {
                                    "line": 125,
                                    "code": "ndcg = evaluate_ndcg(y_test.to_numpy(), y_pred, test_groups)"
                                },
                                {
                                    "line": 127,
                                    "code": "models.append(model)"
                                },
                                {
                                    "line": 128,
                                    "code": "ndcg_scores.append(ndcg)"
                                },
                                {
                                    "line": 131,
                                    "code": "best_idx = int(np.argmax(ndcg_scores))"
                                },
                                {
                                    "line": 132,
                                    "code": "best_model = models[best_idx]"
                                },
                                {
                                    "line": 133,
                                    "code": "best_n_estimators = n_estimators_list[best_idx]"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "Evaluates and visualizes predictions for test years",
                            "codeSegments": [
                                {
                                    "line": 137,
                                    "code": "y_pred = best_model.predict(X_test)"
                                },
                                {
                                    "line": 138,
                                    "code": "df.loc[test_idx, \"PredictedScore\"] = y_pred"
                                },
                                {
                                    "line": 145,
                                    "code": "ndcg = evaluate_ndcg(y_test.to_numpy(), y_pred, test_groups)"
                                },
                                {
                                    "line": 149,
                                    "code": "print(df[test_idx][[\"Year\", \"Name\", \"Rank\", \"PredictedScore\", \"PredictedRank\"]])"
                                },
                                {
                                    "line": 150,
                                    "code": "plot_ranking_predictions(df, 2024)"
                                },
                                {
                                    "line": 151,
                                    "code": "plot_ranking_predictions(df, 2025)"
                                }
                            ]
                        }
                    ],
                    "medium_structured": [
                        {
                            "summaryComponent": "Loads data and splits it into training (all but last two years) and test sets (last two years)",
                            "codeSegments": [
                                {
                                    "line": 90,
                                    "code": "X, y, group, df = load_data()"
                                },
                                {
                                    "line": 93,
                                    "code": "unique_years = df[\"Year\"].unique()"
                                },
                                {
                                    "line": 94,
                                    "code": "train_years, test_years = (\n    unique_years[:-2],  # train: 2015-2023\n    unique_years[-2:],  # test: 2024-2025\n)"
                                },
                                {
                                    "line": 99,
                                    "code": "train_idx = df[\"Year\"].isin(train_years)"
                                },
                                {
                                    "line": 100,
                                    "code": "test_idx = df[\"Year\"].isin(test_years)"
                                },
                                {
                                    "line": 102,
                                    "code": "X_train, X_test = X[train_idx], X[test_idx]"
                                },
                                {
                                    "line": 103,
                                    "code": "y_train, y_test = y[train_idx], y[test_idx]"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "Trains three XGBoostRanker models on the training data with different n_estimators values",
                            "codeSegments": [
                                {
                                    "line": 110,
                                    "code": "n_estimators_list = [100, 1000, 2000]"
                                },
                                {
                                    "line": 114,
                                    "code": "for n_estimators in n_estimators_list:"
                                },
                                {
                                    "line": 115,
                                    "code": "model = XGBRanker(\n    objective=\"rank:pairwise\",\n    learning_rate=0.1,\n    n_estimators=n_estimators,\n    max_depth=4,\n    random_state=42,\n)"
                                },
                                {
                                    "line": 123,
                                    "code": "model.fit(X_train, y_train, group=train_groups)"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "Selects the best model based on NDCG score",
                            "codeSegments": [
                                {
                                    "line": 128,
                                    "code": "ndcg_scores.append(ndcg)"
                                },
                                {
                                    "line": 131,
                                    "code": "best_idx = int(np.argmax(ndcg_scores))"
                                },
                                {
                                    "line": 132,
                                    "code": "best_model = models[best_idx]"
                                },
                                {
                                    "line": 133,
                                    "code": "best_n_estimators = n_estimators_list[best_idx]"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "Predicts scores and ranks for the test set using the best model",
                            "codeSegments": [
                                {
                                    "line": 137,
                                    "code": "y_pred = best_model.predict(X_test)"
                                },
                                {
                                    "line": 138,
                                    "code": "df.loc[test_idx, \"PredictedScore\"] = y_pred"
                                },
                                {
                                    "line": 139,
                                    "code": "df.loc[test_idx, \"PredictedRank\"] = (\n    df.loc[test_idx]\n    .groupby(\"Year\")[\"PredictedScore\"]\n    .rank(ascending=False, method=\"first\")\n)"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "Evaluates model performance using NDCG score",
                            "codeSegments": [
                                {
                                    "line": 145,
                                    "code": "ndcg = evaluate_ndcg(y_test.to_numpy(), y_pred, test_groups)"
                                },
                                {
                                    "line": 146,
                                    "code": "print(f\"NDCG Score on test years {test_years.tolist()} (best model): {ndcg:.4f}\")"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "Visualizes prediction errors for each test year with bar plots",
                            "codeSegments": [
                                {
                                    "line": 150,
                                    "code": "plot_ranking_predictions(df, 2024)"
                                },
                                {
                                    "line": 151,
                                    "code": "plot_ranking_predictions(df, 2025)"
                                }
                            ]
                        }
                    ]
                }
            }
        },
        "timestamp": "2025-08-16 23:03:39.000",
        "id": "F2NA5t7GrEq3yQaliPwF"
    },
    {
        "source": "frontend",
        "event": "autotransit_section",
        "data": {
            "before_section_id": "2d68092b-4e4d-488b-be65-3ac6f1fcf33c",
            "after_section_id": "d36650a7-ba7a-4b56-9484-7b316e17b625"
        },
        "timestamp": "2025-08-16 23:03:39.000",
        "id": "h9Oa97PqN45BfZteLfF3"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "d36650a7-ba7a-4b56-9484-7b316e17b625",
            "detail_level": "medium",
            "structured_type": "unstructured"
        },
        "timestamp": "2025-08-16 23:03:40.000",
        "id": "0l9kbMurFy3faEPAlGLo"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "d36650a7-ba7a-4b56-9484-7b316e17b625",
            "mapping_index": 4,
            "structured_type": "unstructured",
            "detail_level": "medium"
        },
        "timestamp": "2025-08-16 23:03:40.000",
        "id": "3NQViKysLWiVbW70vteq"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "d36650a7-ba7a-4b56-9484-7b316e17b625",
            "mapping_index": 7,
            "structured_type": "unstructured",
            "detail_level": "medium"
        },
        "timestamp": "2025-08-16 23:03:40.000",
        "id": "51iUOx9JQb5vhiS8vlqY"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "d36650a7-ba7a-4b56-9484-7b316e17b625",
            "mapping_index": 2,
            "structured_type": "unstructured",
            "detail_level": "medium"
        },
        "timestamp": "2025-08-16 23:03:40.000",
        "id": "b0rvqF8o2ld2htEGw6W7"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "d36650a7-ba7a-4b56-9484-7b316e17b625",
            "mapping_index": 0,
            "structured_type": "unstructured",
            "detail_level": "medium"
        },
        "timestamp": "2025-08-16 23:03:40.000",
        "id": "hCHQtwPp3d0aXVzDR8Is"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "d36650a7-ba7a-4b56-9484-7b316e17b625",
            "detail_level": "medium",
            "structured_type": "unstructured"
        },
        "timestamp": "2025-08-16 23:03:40.000",
        "id": "iGPGyfkEyQUXYFFAB8p3"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "d36650a7-ba7a-4b56-9484-7b316e17b625",
            "detail_level": "medium",
            "structured_type": "unstructured"
        },
        "timestamp": "2025-08-16 23:03:40.000",
        "id": "l1KvtPmYpiEqzbrC3zW2"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "d36650a7-ba7a-4b56-9484-7b316e17b625",
            "detail_level": "medium",
            "structured_type": "unstructured"
        },
        "timestamp": "2025-08-16 23:03:40.000",
        "id": "ujWtSSkWlCpjqkyiNMv3"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "d36650a7-ba7a-4b56-9484-7b316e17b625",
            "detail_level": "medium",
            "structured_type": "unstructured"
        },
        "timestamp": "2025-08-16 23:03:41.000",
        "id": "MEWNVIcOoHXwwq0FtEuR"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "d36650a7-ba7a-4b56-9484-7b316e17b625",
            "detail_level": "medium",
            "structured_type": "unstructured"
        },
        "timestamp": "2025-08-16 23:03:41.000",
        "id": "PobqP3ZP2EaicWSiDKPk"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "d36650a7-ba7a-4b56-9484-7b316e17b625",
            "detail_level": "medium",
            "structured_type": "unstructured"
        },
        "timestamp": "2025-08-16 23:03:41.000",
        "id": "U1hhmQoEkRYvZSD2FFVK"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "d36650a7-ba7a-4b56-9484-7b316e17b625",
            "mapping_index": 1,
            "structured_type": "unstructured",
            "detail_level": "medium"
        },
        "timestamp": "2025-08-16 23:03:41.000",
        "id": "VaPDdsFYLE8ivLPjuGNv"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "d36650a7-ba7a-4b56-9484-7b316e17b625",
            "mapping_index": 2,
            "structured_type": "unstructured",
            "detail_level": "medium"
        },
        "timestamp": "2025-08-16 23:03:41.000",
        "id": "X1QZ9xXHzfrkfmlMIdis"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "d36650a7-ba7a-4b56-9484-7b316e17b625",
            "mapping_index": 2,
            "structured_type": "unstructured",
            "detail_level": "medium"
        },
        "timestamp": "2025-08-16 23:03:41.000",
        "id": "bRC6z0dsjVW6eT7SvN83"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "d36650a7-ba7a-4b56-9484-7b316e17b625",
            "mapping_index": 5,
            "structured_type": "unstructured",
            "detail_level": "medium"
        },
        "timestamp": "2025-08-16 23:03:41.000",
        "id": "oqpM8XoO2Xf29gNlPTml"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "d36650a7-ba7a-4b56-9484-7b316e17b625",
            "detail_level": "medium",
            "structured_type": "unstructured"
        },
        "timestamp": "2025-08-16 23:03:41.000",
        "id": "pUfh4IcKQhAnAAwzUEXM"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "d36650a7-ba7a-4b56-9484-7b316e17b625",
            "detail_level": "medium",
            "structured_type": "unstructured"
        },
        "timestamp": "2025-08-16 23:03:41.000",
        "id": "r9CKCHC2Yfz1BGrZHps7"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "d36650a7-ba7a-4b56-9484-7b316e17b625",
            "mapping_index": 3,
            "structured_type": "unstructured",
            "detail_level": "medium"
        },
        "timestamp": "2025-08-16 23:03:41.000",
        "id": "wa9JUf9PNSUH2DrYkm6g"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "d36650a7-ba7a-4b56-9484-7b316e17b625",
            "mapping_index": 4,
            "structured_type": "unstructured",
            "detail_level": "medium"
        },
        "timestamp": "2025-08-16 23:03:41.000",
        "id": "wiCS6HPC1doga6UKQGqu"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "d36650a7-ba7a-4b56-9484-7b316e17b625",
            "mapping_index": 2,
            "structured_type": "unstructured",
            "detail_level": "medium"
        },
        "timestamp": "2025-08-16 23:03:42.000",
        "id": "1ADQH6cujL7DcBSIA5UD"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "d36650a7-ba7a-4b56-9484-7b316e17b625",
            "mapping_index": 6,
            "structured_type": "unstructured",
            "detail_level": "medium"
        },
        "timestamp": "2025-08-16 23:03:42.000",
        "id": "5CGBN0HiddZVMyVW9KMt"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "d36650a7-ba7a-4b56-9484-7b316e17b625",
            "detail_level": "medium",
            "structured_type": "unstructured"
        },
        "timestamp": "2025-08-16 23:03:42.000",
        "id": "5MJX3N05B9iK2b03Ecvc"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "d36650a7-ba7a-4b56-9484-7b316e17b625",
            "detail_level": "medium",
            "structured_type": "unstructured"
        },
        "timestamp": "2025-08-16 23:03:42.000",
        "id": "6UTukXTJn1dzRtuT0Hbt"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "d36650a7-ba7a-4b56-9484-7b316e17b625",
            "detail_level": "medium",
            "structured_type": "unstructured"
        },
        "timestamp": "2025-08-16 23:03:42.000",
        "id": "Ht8rnWUQXBNyV72i0voy"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "d36650a7-ba7a-4b56-9484-7b316e17b625",
            "mapping_index": 5,
            "structured_type": "unstructured",
            "detail_level": "medium"
        },
        "timestamp": "2025-08-16 23:03:42.000",
        "id": "QT00YsecUOJMa8RUELSd"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "d36650a7-ba7a-4b56-9484-7b316e17b625",
            "mapping_index": 3,
            "structured_type": "unstructured",
            "detail_level": "medium"
        },
        "timestamp": "2025-08-16 23:03:42.000",
        "id": "bMSUtlw1EvHR6N2TFNDw"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "d36650a7-ba7a-4b56-9484-7b316e17b625",
            "detail_level": "medium",
            "structured_type": "unstructured"
        },
        "timestamp": "2025-08-16 23:03:42.000",
        "id": "ppFrdcqy1SZemSQOnyDY"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "d36650a7-ba7a-4b56-9484-7b316e17b625",
            "detail_level": "medium",
            "structured_type": "unstructured"
        },
        "timestamp": "2025-08-16 23:03:43.000",
        "id": "FO9mevAYjyGP0qgE9snZ"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "d36650a7-ba7a-4b56-9484-7b316e17b625",
            "mapping_index": 3,
            "structured_type": "unstructured",
            "detail_level": "medium"
        },
        "timestamp": "2025-08-16 23:03:43.000",
        "id": "H3oyOQbKkflpMF5cQCN2"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "d36650a7-ba7a-4b56-9484-7b316e17b625",
            "mapping_index": 4,
            "structured_type": "unstructured",
            "detail_level": "medium"
        },
        "timestamp": "2025-08-16 23:03:44.000",
        "id": "5puI5KeFgV3iDaCdiDnl"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "d36650a7-ba7a-4b56-9484-7b316e17b625",
            "mapping_index": 6,
            "structured_type": "unstructured",
            "detail_level": "medium"
        },
        "timestamp": "2025-08-16 23:03:44.000",
        "id": "Q37CpjlV7Nh1ckIvPwLM"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "d36650a7-ba7a-4b56-9484-7b316e17b625",
            "mapping_index": 7,
            "structured_type": "unstructured",
            "detail_level": "medium"
        },
        "timestamp": "2025-08-16 23:03:44.000",
        "id": "WgIa9Uf5w8M7K1Gckd7e"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "d36650a7-ba7a-4b56-9484-7b316e17b625",
            "detail_level": "medium",
            "structured_type": "unstructured"
        },
        "timestamp": "2025-08-16 23:03:44.000",
        "id": "ckSqjsMHZ5HH3AhXC99m"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "d36650a7-ba7a-4b56-9484-7b316e17b625",
            "detail_level": "medium",
            "structured_type": "unstructured"
        },
        "timestamp": "2025-08-16 23:03:44.000",
        "id": "jdW8i82qn7jYkIIjU7ia"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "d36650a7-ba7a-4b56-9484-7b316e17b625",
            "detail_level": "medium",
            "structured_type": "unstructured"
        },
        "timestamp": "2025-08-16 23:03:44.000",
        "id": "k3gAXFyRgXmhOcjV3V75"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "d36650a7-ba7a-4b56-9484-7b316e17b625",
            "detail_level": "medium",
            "structured_type": "unstructured"
        },
        "timestamp": "2025-08-16 23:03:44.000",
        "id": "tvVSXxAnIu7U8ozqSoEQ"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "d36650a7-ba7a-4b56-9484-7b316e17b625",
            "detail_level": "medium",
            "structured_type": "unstructured"
        },
        "timestamp": "2025-08-16 23:03:45.000",
        "id": "BoDCefMkrZeEcCaUPrrK"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "d36650a7-ba7a-4b56-9484-7b316e17b625",
            "mapping_index": 2,
            "structured_type": "unstructured",
            "detail_level": "medium"
        },
        "timestamp": "2025-08-16 23:03:45.000",
        "id": "IBH7GsO6z0aSTbvGlvT7"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "d36650a7-ba7a-4b56-9484-7b316e17b625",
            "detail_level": "medium",
            "structured_type": "unstructured"
        },
        "timestamp": "2025-08-16 23:03:45.000",
        "id": "LvqirLwGAHXce1RIO474"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "d36650a7-ba7a-4b56-9484-7b316e17b625",
            "detail_level": "medium",
            "structured_type": "unstructured"
        },
        "timestamp": "2025-08-16 23:03:45.000",
        "id": "dKns4z1XDcVWv9uK0Z9I"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "d36650a7-ba7a-4b56-9484-7b316e17b625",
            "mapping_index": 7,
            "structured_type": "unstructured",
            "detail_level": "medium"
        },
        "timestamp": "2025-08-16 23:03:45.000",
        "id": "kvIs5O87yH9grWdMNmHr"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "d36650a7-ba7a-4b56-9484-7b316e17b625",
            "mapping_index": 4,
            "structured_type": "unstructured",
            "detail_level": "medium"
        },
        "timestamp": "2025-08-16 23:03:45.000",
        "id": "q9HUA32YWolWXeZcwbkb"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "d36650a7-ba7a-4b56-9484-7b316e17b625",
            "mapping_index": 0,
            "structured_type": "structured",
            "detail_level": "medium"
        },
        "timestamp": "2025-08-16 23:03:46.000",
        "id": "0mLdDsISYi0ATOwObeCH"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "d36650a7-ba7a-4b56-9484-7b316e17b625",
            "detail_level": "medium",
            "structured_type": "structured"
        },
        "timestamp": "2025-08-16 23:03:46.000",
        "id": "3kqeinj1znaiW0PKJMNC"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "d36650a7-ba7a-4b56-9484-7b316e17b625",
            "mapping_index": 1,
            "structured_type": "structured",
            "detail_level": "medium"
        },
        "timestamp": "2025-08-16 23:03:46.000",
        "id": "5zrUjG7WfFvtqjyIQZDU"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "d36650a7-ba7a-4b56-9484-7b316e17b625",
            "mapping_index": 2,
            "structured_type": "structured",
            "detail_level": "medium"
        },
        "timestamp": "2025-08-16 23:03:46.000",
        "id": "afkeMuo0Abp2dPA7O9lP"
    },
    {
        "source": "frontend",
        "event": "change_summary_level",
        "data": {
            "before_detail_level": "medium",
            "section_id": "d36650a7-ba7a-4b56-9484-7b316e17b625",
            "before_structured": "unstructured",
            "after_structured": "structured",
            "after_detail_level": "medium"
        },
        "timestamp": "2025-08-16 23:03:46.000",
        "id": "slB8is9sSLDXb54VjTiG"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "d36650a7-ba7a-4b56-9484-7b316e17b625",
            "detail_level": "medium",
            "structured_type": "structured"
        },
        "timestamp": "2025-08-16 23:03:46.000",
        "id": "y9FCWLemys43qRVQX5fs"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "d36650a7-ba7a-4b56-9484-7b316e17b625",
            "detail_level": "medium",
            "structured_type": "structured"
        },
        "timestamp": "2025-08-16 23:03:47.000",
        "id": "2mCdQZrGGIPpnu4fd4hp"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "d36650a7-ba7a-4b56-9484-7b316e17b625",
            "mapping_index": 3,
            "structured_type": "structured",
            "detail_level": "medium"
        },
        "timestamp": "2025-08-16 23:03:47.000",
        "id": "9undDQhm7dV0GENmV4Vr"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "d36650a7-ba7a-4b56-9484-7b316e17b625",
            "mapping_index": 3,
            "structured_type": "structured",
            "detail_level": "medium"
        },
        "timestamp": "2025-08-16 23:03:47.000",
        "id": "CMiErB1g3XAwupXehuVc"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "d36650a7-ba7a-4b56-9484-7b316e17b625",
            "detail_level": "medium",
            "structured_type": "structured"
        },
        "timestamp": "2025-08-16 23:03:47.000",
        "id": "YPq7ufghiJ9wNwoDLyP0"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "d36650a7-ba7a-4b56-9484-7b316e17b625",
            "mapping_index": 4,
            "structured_type": "structured",
            "detail_level": "medium"
        },
        "timestamp": "2025-08-16 23:03:47.000",
        "id": "YsFqfxZtsmEWxKE0qkUK"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "d36650a7-ba7a-4b56-9484-7b316e17b625",
            "detail_level": "medium",
            "structured_type": "structured"
        },
        "timestamp": "2025-08-16 23:03:47.000",
        "id": "ZWZ2uf5Dk1waaWpE4KxV"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "d36650a7-ba7a-4b56-9484-7b316e17b625",
            "detail_level": "medium",
            "structured_type": "structured"
        },
        "timestamp": "2025-08-16 23:03:47.000",
        "id": "aS06x9oe6UMMyhynqO8C"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "d36650a7-ba7a-4b56-9484-7b316e17b625",
            "mapping_index": 5,
            "structured_type": "structured",
            "detail_level": "medium"
        },
        "timestamp": "2025-08-16 23:03:47.000",
        "id": "zUlcsWhsQtyoeqJDRtXo"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "d36650a7-ba7a-4b56-9484-7b316e17b625",
            "mapping_index": 2,
            "structured_type": "structured",
            "detail_level": "medium"
        },
        "timestamp": "2025-08-16 23:03:48.000",
        "id": "09A8jEn02fhiQcSYfzY3"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "d36650a7-ba7a-4b56-9484-7b316e17b625",
            "detail_level": "medium",
            "structured_type": "structured"
        },
        "timestamp": "2025-08-16 23:03:48.000",
        "id": "17s1MpMDnxXKErLyDH8l"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "d36650a7-ba7a-4b56-9484-7b316e17b625",
            "detail_level": "medium",
            "structured_type": "structured"
        },
        "timestamp": "2025-08-16 23:03:49.000",
        "id": "SCNYMcLodi0WER1GXYhk"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "d36650a7-ba7a-4b56-9484-7b316e17b625",
            "mapping_index": 3,
            "structured_type": "structured",
            "detail_level": "medium"
        },
        "timestamp": "2025-08-16 23:03:49.000",
        "id": "XYFEKzHY0LcX5pXrQtz1"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "d36650a7-ba7a-4b56-9484-7b316e17b625",
            "mapping_index": 4,
            "structured_type": "structured",
            "detail_level": "medium"
        },
        "timestamp": "2025-08-16 23:03:49.000",
        "id": "gFVZzngOkHuRz8Imsr4r"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "d36650a7-ba7a-4b56-9484-7b316e17b625",
            "detail_level": "medium",
            "structured_type": "structured"
        },
        "timestamp": "2025-08-16 23:03:49.000",
        "id": "muLXHrX2hwUoWMMAatJF"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "d36650a7-ba7a-4b56-9484-7b316e17b625",
            "detail_level": "medium",
            "structured_type": "structured"
        },
        "timestamp": "2025-08-16 23:03:49.000",
        "id": "rvJxq2sG7IwMZZur71Uw"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "d36650a7-ba7a-4b56-9484-7b316e17b625",
            "detail_level": "medium",
            "structured_type": "structured"
        },
        "timestamp": "2025-08-16 23:03:50.000",
        "id": "2ojru7Vpg0TOSkTrcj8d"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "d36650a7-ba7a-4b56-9484-7b316e17b625",
            "detail_level": "medium",
            "structured_type": "structured"
        },
        "timestamp": "2025-08-16 23:03:50.000",
        "id": "3FUjdwPAqkFzXfCYoPTL"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "d36650a7-ba7a-4b56-9484-7b316e17b625",
            "detail_level": "medium",
            "structured_type": "structured"
        },
        "timestamp": "2025-08-16 23:03:50.000",
        "id": "4hPa5oxlISa2pqTU4KSt"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "d36650a7-ba7a-4b56-9484-7b316e17b625",
            "mapping_index": 0,
            "structured_type": "structured",
            "detail_level": "medium"
        },
        "timestamp": "2025-08-16 23:03:50.000",
        "id": "5YRHC2qdHTdxEdkQNcEX"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "d36650a7-ba7a-4b56-9484-7b316e17b625",
            "detail_level": "medium",
            "structured_type": "structured"
        },
        "timestamp": "2025-08-16 23:03:50.000",
        "id": "A5FDumS2Z0EU3vL44UNP"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "d36650a7-ba7a-4b56-9484-7b316e17b625",
            "detail_level": "medium",
            "structured_type": "structured"
        },
        "timestamp": "2025-08-16 23:03:50.000",
        "id": "RJCNmPkcaFUhRjOENqhm"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "d36650a7-ba7a-4b56-9484-7b316e17b625",
            "mapping_index": 5,
            "structured_type": "structured",
            "detail_level": "medium"
        },
        "timestamp": "2025-08-16 23:03:50.000",
        "id": "WkHlUEF79HOkA5q5ou7g"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "d36650a7-ba7a-4b56-9484-7b316e17b625",
            "mapping_index": 4,
            "structured_type": "structured",
            "detail_level": "medium"
        },
        "timestamp": "2025-08-16 23:03:50.000",
        "id": "aAQ1XMVCW1pZ7VHPIwZC"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "d36650a7-ba7a-4b56-9484-7b316e17b625",
            "detail_level": "medium",
            "structured_type": "structured"
        },
        "timestamp": "2025-08-16 23:03:50.000",
        "id": "egCP26bBwIY7YLs9kgND"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "d36650a7-ba7a-4b56-9484-7b316e17b625",
            "mapping_index": 3,
            "structured_type": "structured",
            "detail_level": "medium"
        },
        "timestamp": "2025-08-16 23:03:50.000",
        "id": "g27IzO4og9WC1aAcOekr"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "d36650a7-ba7a-4b56-9484-7b316e17b625",
            "mapping_index": 1,
            "structured_type": "structured",
            "detail_level": "medium"
        },
        "timestamp": "2025-08-16 23:03:50.000",
        "id": "mEhY4GndFAOFKVVS0g89"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "d36650a7-ba7a-4b56-9484-7b316e17b625",
            "mapping_index": 2,
            "structured_type": "structured",
            "detail_level": "medium"
        },
        "timestamp": "2025-08-16 23:03:50.000",
        "id": "x1CQTeAye1B1U4xPfcPR"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "d36650a7-ba7a-4b56-9484-7b316e17b625",
            "mapping_index": 1,
            "structured_type": "structured",
            "detail_level": "medium"
        },
        "timestamp": "2025-08-16 23:03:50.000",
        "id": "z6KgDaC9JEitoaD4KTvw"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "d36650a7-ba7a-4b56-9484-7b316e17b625",
            "mapping_index": 1,
            "structured_type": "structured",
            "detail_level": "medium"
        },
        "timestamp": "2025-08-16 23:03:52.000",
        "id": "6l2PGsgje4qaf0GJshQN"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "d36650a7-ba7a-4b56-9484-7b316e17b625",
            "mapping_index": 2,
            "structured_type": "structured",
            "detail_level": "medium"
        },
        "timestamp": "2025-08-16 23:03:52.000",
        "id": "EMBpiF4UcaplNpU67QGN"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "d36650a7-ba7a-4b56-9484-7b316e17b625",
            "detail_level": "medium",
            "structured_type": "structured"
        },
        "timestamp": "2025-08-16 23:03:52.000",
        "id": "FjTSjg1v8iYlpDxl1pnO"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "d36650a7-ba7a-4b56-9484-7b316e17b625",
            "detail_level": "medium",
            "structured_type": "structured"
        },
        "timestamp": "2025-08-16 23:03:52.000",
        "id": "M8mHjSteskbXxO3ngkHm"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "d36650a7-ba7a-4b56-9484-7b316e17b625",
            "detail_level": "medium",
            "structured_type": "structured"
        },
        "timestamp": "2025-08-16 23:03:52.000",
        "id": "ffx7j7H3c0CTthw0Ag6V"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "d36650a7-ba7a-4b56-9484-7b316e17b625",
            "mapping_index": 0,
            "structured_type": "structured",
            "detail_level": "medium"
        },
        "timestamp": "2025-08-16 23:03:52.000",
        "id": "huvtNbPsV6XobZZnBXZ8"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "d36650a7-ba7a-4b56-9484-7b316e17b625",
            "detail_level": "medium",
            "structured_type": "structured"
        },
        "timestamp": "2025-08-16 23:03:52.000",
        "id": "iOPt68NndNlCnUa5OKRy"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "d36650a7-ba7a-4b56-9484-7b316e17b625",
            "detail_level": "low",
            "structured_type": "structured"
        },
        "timestamp": "2025-08-16 23:03:53.000",
        "id": "04w0MAOE57PaOWHS91bs"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "d36650a7-ba7a-4b56-9484-7b316e17b625",
            "mapping_index": 0,
            "structured_type": "structured",
            "detail_level": "low"
        },
        "timestamp": "2025-08-16 23:03:53.000",
        "id": "9gikzy4ofip9GXORP7Ph"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "d36650a7-ba7a-4b56-9484-7b316e17b625",
            "mapping_index": 1,
            "structured_type": "structured",
            "detail_level": "low"
        },
        "timestamp": "2025-08-16 23:03:53.000",
        "id": "AZluGPYrkVPBjfilbtb6"
    },
    {
        "source": "frontend",
        "event": "change_summary_level",
        "data": {
            "before_detail_level": "medium",
            "section_id": "d36650a7-ba7a-4b56-9484-7b316e17b625",
            "before_structured": "structured",
            "after_structured": "structured",
            "after_detail_level": "low"
        },
        "timestamp": "2025-08-16 23:03:53.000",
        "id": "VfJk4vUXFe1SnXxRCza0"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "d36650a7-ba7a-4b56-9484-7b316e17b625",
            "detail_level": "low",
            "structured_type": "structured"
        },
        "timestamp": "2025-08-16 23:03:53.000",
        "id": "k6BTYU71wo4a3JeDqsmM"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "d36650a7-ba7a-4b56-9484-7b316e17b625",
            "mapping_index": 0,
            "structured_type": "structured",
            "detail_level": "low"
        },
        "timestamp": "2025-08-16 23:03:53.000",
        "id": "vCxDF6LxiuR4Yrl31lNn"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "d36650a7-ba7a-4b56-9484-7b316e17b625",
            "mapping_index": 1,
            "structured_type": "structured",
            "detail_level": "low"
        },
        "timestamp": "2025-08-16 23:03:54.000",
        "id": "T0RREPns6nIZ9Wk9jAx1"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "d36650a7-ba7a-4b56-9484-7b316e17b625",
            "detail_level": "low",
            "structured_type": "structured"
        },
        "timestamp": "2025-08-16 23:03:54.000",
        "id": "ss3aJmZJ0WaMHdjPk8i2"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "d36650a7-ba7a-4b56-9484-7b316e17b625",
            "mapping_index": 2,
            "structured_type": "structured",
            "detail_level": "low"
        },
        "timestamp": "2025-08-16 23:03:55.000",
        "id": "1y5x2PYAbTQcdppRkAnE"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "d36650a7-ba7a-4b56-9484-7b316e17b625",
            "detail_level": "low",
            "structured_type": "structured"
        },
        "timestamp": "2025-08-16 23:03:55.000",
        "id": "UQt11q3VEOsz8IamOokz"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "d36650a7-ba7a-4b56-9484-7b316e17b625",
            "mapping_index": 1,
            "structured_type": "structured",
            "detail_level": "low"
        },
        "timestamp": "2025-08-16 23:03:56.000",
        "id": "E0aIcKlz4ujvq4tpQ8Ve"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "d36650a7-ba7a-4b56-9484-7b316e17b625",
            "detail_level": "low",
            "structured_type": "structured"
        },
        "timestamp": "2025-08-16 23:03:56.000",
        "id": "LZgA9DQiG6FCbIaU2pSq"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "d36650a7-ba7a-4b56-9484-7b316e17b625",
            "detail_level": "low",
            "structured_type": "structured"
        },
        "timestamp": "2025-08-16 23:03:58.000",
        "id": "Ieht6DMw1nSL554DNEln"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "d36650a7-ba7a-4b56-9484-7b316e17b625",
            "mapping_index": 2,
            "structured_type": "structured",
            "detail_level": "low"
        },
        "timestamp": "2025-08-16 23:03:58.000",
        "id": "TTXED3GmpIjGlyuk7ELm"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "d36650a7-ba7a-4b56-9484-7b316e17b625",
            "detail_level": "low",
            "structured_type": "structured"
        },
        "timestamp": "2025-08-16 23:03:58.000",
        "id": "VP7cKp1nEkriTtpOS4MD"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "d36650a7-ba7a-4b56-9484-7b316e17b625",
            "detail_level": "low",
            "structured_type": "structured"
        },
        "timestamp": "2025-08-16 23:05:06.000",
        "id": "fLN45Hw76YPVe6otj5Ui"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "d36650a7-ba7a-4b56-9484-7b316e17b625",
            "mapping_index": 0,
            "structured_type": "structured",
            "detail_level": "low"
        },
        "timestamp": "2025-08-16 23:05:06.000",
        "id": "rsCoYA74fybd2WhJdHLT"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "d36650a7-ba7a-4b56-9484-7b316e17b625",
            "mapping_index": 0,
            "structured_type": "structured",
            "detail_level": "low"
        },
        "timestamp": "2025-08-16 23:05:08.000",
        "id": "VJyET4eXzo0zUIafpYDk"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "d36650a7-ba7a-4b56-9484-7b316e17b625",
            "detail_level": "low",
            "structured_type": "structured"
        },
        "timestamp": "2025-08-16 23:05:08.000",
        "id": "azyrcUPP5xphmsG0AcFU"
    },
    {
        "source": "frontend",
        "event": "click_summarize_code",
        "data": {},
        "timestamp": "2025-08-16 23:05:08.000",
        "id": "rdP05rkB1IDxBMhaHr6r"
    },
    {
        "source": "backend",
        "event": "summarize_selected_code",
        "data": {
            "selected_code": "def plot_ranking_predictions(df, year):\n    \"\"\"\n    Plot prediction error for a specific year.\n\n    Args:\n        df: DataFrame containing prediction results\n        year: Year to plot prediction errors for\n    \"\"\"\n    df[\"RankError\"] = df[\"PredictedRank\"] - df[\"Rank\"]\n    year_df = df[df[\"Year\"] == year].copy()\n    year_df.sort_values(\"Rank\", inplace=True)\n\n    plt.figure(figsize=(12, 6))\n    sns.barplot(x=\"Name\", y=\"RankError\", data=year_df, hue=\"Name\", palette=\"coolwarm\")\n    plt.axhline(0, color=\"black\", linestyle=\"--\")\n    plt.xticks(rotation=45, ha=\"right\")\n    plt.ylabel(\"Predicted Rank - True Rank\")\n    plt.title(f\"MVP Ranking Predictions ({year})\")\n    plt.tight_layout()\n    plt.savefig(f\"data/ranking_predictions_{year}.png\")",
            "summary": {
                "low_structured": "• Plots prediction errors for a given year\n• Saves the plot as an image file",
                "high_unstructured": "The plot_ranking_predictions function generates a bar plot to visualize the prediction error (PredictedRank minus actual Rank) for each player in a specified year. It first computes the rank error, filters the DataFrame for the given year, and sorts the data by true rank to ensure a consistent order. Using Seaborn, it creates a colored bar plot with player names on the x-axis and prediction errors on the y-axis, adding a horizontal line at zero for reference. The plot is formatted for readability and saved as a PNG file named according to the year.",
                "medium_unstructured": "The plot_ranking_predictions function visualizes the difference between predicted and actual ranks for each player in a specified year. It creates a bar plot showing these errors and saves the resulting image to a file. The plot includes player names, error values, and a reference line at zero.",
                "high_structured": "• Computes the 'RankError' column as the difference between 'PredictedRank' and 'Rank' for each entry\n• Filters the DataFrame to include only rows from the specified year and sorts them by actual rank\n• Sets up a matplotlib figure with a specific size\n• Creates a Seaborn bar plot:\n  ◦ x-axis: Player names\n  ◦ y-axis: RankError values\n  ◦ Hue: Player names for color distinction\n  ◦ Palette: 'coolwarm' for visual contrast\n• Adds a horizontal dashed line at y=0 to indicate no error\n• Rotates x-axis labels for better readability\n• Sets axis labels and a descriptive plot title indicating the year\n• Adjusts layout for clarity and saves the figure as 'data/ranking_predictions_{year}.png'",
                "title": "Function: plot_ranking_predictions",
                "low_unstructured": "This function plots and saves the prediction errors for player rankings in a specified year.",
                "medium_structured": "• Calculates prediction error as the difference between predicted and actual ranks\n• Filters data for the specified year and sorts by true rank\n• Creates a bar plot of prediction errors for each player\n  ◦ Uses player names as labels and colors\n• Adds a horizontal reference line and saves the plot as a PNG file"
            }
        },
        "timestamp": "2025-08-16 23:05:13.000",
        "id": "Hm2utW884lQfsM3KR0Pu"
    },
    {
        "source": "backend",
        "event": "map_summary_code",
        "data": {
            "summary": "• Plots prediction errors for a given year\n• Saves the plot as an image file",
            "mapping": [
                {
                    "summaryComponent": "Plots prediction errors for a given year",
                    "codeSegments": [
                        {
                            "line": 67,
                            "code": "def plot_ranking_predictions(df, year):"
                        },
                        {
                            "line": 75,
                            "code": "df[\"RankError\"] = df[\"PredictedRank\"] - df[\"Rank\"]"
                        },
                        {
                            "line": 76,
                            "code": "year_df = df[df[\"Year\"] == year].copy()"
                        },
                        {
                            "line": 80,
                            "code": "sns.barplot(x=\"Name\", y=\"RankError\", data=year_df, hue=\"Name\", palette=\"coolwarm\")"
                        }
                    ]
                },
                {
                    "summaryComponent": "Saves the plot as an image file",
                    "codeSegments": [
                        {
                            "line": 86,
                            "code": "plt.savefig(f\"data/ranking_predictions_{year}.png\")"
                        }
                    ]
                }
            ],
            "code": "67: def plot_ranking_predictions(df, year):\n68:     \"\"\"\n69:     Plot prediction error for a specific year.\n70: \n71:     Args:\n72:         df: DataFrame containing prediction results\n73:         year: Year to plot prediction errors for\n74:     \"\"\"\n75:     df[\"RankError\"] = df[\"PredictedRank\"] - df[\"Rank\"]\n76:     year_df = df[df[\"Year\"] == year].copy()\n77:     year_df.sort_values(\"Rank\", inplace=True)\n78: \n79:     plt.figure(figsize=(12, 6))\n80:     sns.barplot(x=\"Name\", y=\"RankError\", data=year_df, hue=\"Name\", palette=\"coolwarm\")\n81:     plt.axhline(0, color=\"black\", linestyle=\"--\")\n82:     plt.xticks(rotation=45, ha=\"right\")\n83:     plt.ylabel(\"Predicted Rank - True Rank\")\n84:     plt.title(f\"MVP Ranking Predictions ({year})\")\n85:     plt.tight_layout()\n86:     plt.savefig(f\"data/ranking_predictions_{year}.png\")"
        },
        "timestamp": "2025-08-16 23:05:15.000",
        "id": "6ax0hdjb0SzCqIz6yJ2W"
    },
    {
        "source": "backend",
        "event": "map_summary_code",
        "data": {
            "summary": "• Calculates prediction error as the difference between predicted and actual ranks\n• Filters data for the specified year and sorts by true rank\n• Creates a bar plot of prediction errors for each player\n  ◦ Uses player names as labels and colors\n• Adds a horizontal reference line and saves the plot as a PNG file",
            "mapping": [
                {
                    "summaryComponent": "Calculates prediction error as the difference between predicted and actual ranks",
                    "codeSegments": [
                        {
                            "line": 75,
                            "code": "df[\"RankError\"] = df[\"PredictedRank\"] - df[\"Rank\"]"
                        }
                    ]
                },
                {
                    "summaryComponent": "Filters data for the specified year and sorts by true rank",
                    "codeSegments": [
                        {
                            "line": 76,
                            "code": "year_df = df[df[\"Year\"] == year].copy()"
                        },
                        {
                            "line": 77,
                            "code": "year_df.sort_values(\"Rank\", inplace=True)"
                        }
                    ]
                },
                {
                    "summaryComponent": "Creates a bar plot of prediction errors for each player",
                    "codeSegments": [
                        {
                            "line": 80,
                            "code": "sns.barplot(x=\"Name\", y=\"RankError\", data=year_df, hue=\"Name\", palette=\"coolwarm\")"
                        }
                    ]
                },
                {
                    "summaryComponent": "Uses player names as labels and colors",
                    "codeSegments": [
                        {
                            "line": 80,
                            "code": "sns.barplot(x=\"Name\", y=\"RankError\", data=year_df, hue=\"Name\", palette=\"coolwarm\")"
                        }
                    ]
                },
                {
                    "summaryComponent": "Adds a horizontal reference line and saves the plot as a PNG file",
                    "codeSegments": [
                        {
                            "line": 81,
                            "code": "plt.axhline(0, color=\"black\", linestyle=\"--\")"
                        },
                        {
                            "line": 86,
                            "code": "plt.savefig(f\"data/ranking_predictions_{year}.png\")"
                        }
                    ]
                }
            ],
            "code": "67: def plot_ranking_predictions(df, year):\n68:     \"\"\"\n69:     Plot prediction error for a specific year.\n70: \n71:     Args:\n72:         df: DataFrame containing prediction results\n73:         year: Year to plot prediction errors for\n74:     \"\"\"\n75:     df[\"RankError\"] = df[\"PredictedRank\"] - df[\"Rank\"]\n76:     year_df = df[df[\"Year\"] == year].copy()\n77:     year_df.sort_values(\"Rank\", inplace=True)\n78: \n79:     plt.figure(figsize=(12, 6))\n80:     sns.barplot(x=\"Name\", y=\"RankError\", data=year_df, hue=\"Name\", palette=\"coolwarm\")\n81:     plt.axhline(0, color=\"black\", linestyle=\"--\")\n82:     plt.xticks(rotation=45, ha=\"right\")\n83:     plt.ylabel(\"Predicted Rank - True Rank\")\n84:     plt.title(f\"MVP Ranking Predictions ({year})\")\n85:     plt.tight_layout()\n86:     plt.savefig(f\"data/ranking_predictions_{year}.png\")"
        },
        "timestamp": "2025-08-16 23:05:15.000",
        "id": "XZcZajkD4uwq6xDFCxK2"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "d36650a7-ba7a-4b56-9484-7b316e17b625",
            "detail_level": "low",
            "structured_type": "structured"
        },
        "timestamp": "2025-08-16 23:05:16.000",
        "id": "d8rIGcbQ1XqKlr9Jx8uE"
    },
    {
        "source": "backend",
        "event": "map_summary_code",
        "data": {
            "summary": "The plot_ranking_predictions function visualizes the difference between predicted and actual ranks for each player in a specified year. It creates a bar plot showing these errors and saves the resulting image to a file. The plot includes player names, error values, and a reference line at zero.",
            "mapping": [
                {
                    "summaryComponent": "The plot_ranking_predictions function",
                    "codeSegments": [
                        {
                            "line": 67,
                            "code": "def plot_ranking_predictions(df, year):"
                        }
                    ]
                },
                {
                    "summaryComponent": "visualizes the difference between predicted and actual ranks",
                    "codeSegments": [
                        {
                            "line": 75,
                            "code": "df[\"RankError\"] = df[\"PredictedRank\"] - df[\"Rank\"]"
                        }
                    ]
                },
                {
                    "summaryComponent": "for each player in a specified year",
                    "codeSegments": [
                        {
                            "line": 76,
                            "code": "year_df = df[df[\"Year\"] == year].copy()"
                        }
                    ]
                },
                {
                    "summaryComponent": "It creates a bar plot showing these errors",
                    "codeSegments": [
                        {
                            "line": 80,
                            "code": "sns.barplot(x=\"Name\", y=\"RankError\", data=year_df, hue=\"Name\", palette=\"coolwarm\")"
                        }
                    ]
                },
                {
                    "summaryComponent": "and saves the resulting image to a file",
                    "codeSegments": [
                        {
                            "line": 86,
                            "code": "plt.savefig(f\"data/ranking_predictions_{year}.png\")"
                        }
                    ]
                },
                {
                    "summaryComponent": "The plot includes player names",
                    "codeSegments": [
                        {
                            "line": 80,
                            "code": "sns.barplot(x=\"Name\", y=\"RankError\", data=year_df, hue=\"Name\", palette=\"coolwarm\")"
                        }
                    ]
                },
                {
                    "summaryComponent": "error values",
                    "codeSegments": [
                        {
                            "line": 80,
                            "code": "sns.barplot(x=\"Name\", y=\"RankError\", data=year_df, hue=\"Name\", palette=\"coolwarm\")"
                        }
                    ]
                },
                {
                    "summaryComponent": "and a reference line at zero",
                    "codeSegments": [
                        {
                            "line": 81,
                            "code": "plt.axhline(0, color=\"black\", linestyle=\"--\")"
                        }
                    ]
                }
            ],
            "code": "67: def plot_ranking_predictions(df, year):\n68:     \"\"\"\n69:     Plot prediction error for a specific year.\n70: \n71:     Args:\n72:         df: DataFrame containing prediction results\n73:         year: Year to plot prediction errors for\n74:     \"\"\"\n75:     df[\"RankError\"] = df[\"PredictedRank\"] - df[\"Rank\"]\n76:     year_df = df[df[\"Year\"] == year].copy()\n77:     year_df.sort_values(\"Rank\", inplace=True)\n78: \n79:     plt.figure(figsize=(12, 6))\n80:     sns.barplot(x=\"Name\", y=\"RankError\", data=year_df, hue=\"Name\", palette=\"coolwarm\")\n81:     plt.axhline(0, color=\"black\", linestyle=\"--\")\n82:     plt.xticks(rotation=45, ha=\"right\")\n83:     plt.ylabel(\"Predicted Rank - True Rank\")\n84:     plt.title(f\"MVP Ranking Predictions ({year})\")\n85:     plt.tight_layout()\n86:     plt.savefig(f\"data/ranking_predictions_{year}.png\")"
        },
        "timestamp": "2025-08-16 23:05:16.000",
        "id": "kpTSM73MZp6Dvq3mYpMf"
    },
    {
        "source": "backend",
        "event": "map_summary_code",
        "data": {
            "summary": "This function plots and saves the prediction errors for player rankings in a specified year.",
            "mapping": [
                {
                    "summaryComponent": "plots",
                    "codeSegments": [
                        {
                            "line": 79,
                            "code": "plt.figure(figsize=(12, 6))"
                        },
                        {
                            "line": 80,
                            "code": "sns.barplot(x=\"Name\", y=\"RankError\", data=year_df, hue=\"Name\", palette=\"coolwarm\")"
                        },
                        {
                            "line": 81,
                            "code": "plt.axhline(0, color=\"black\", linestyle=\"--\")"
                        },
                        {
                            "line": 82,
                            "code": "plt.xticks(rotation=45, ha=\"right\")"
                        },
                        {
                            "line": 83,
                            "code": "plt.ylabel(\"Predicted Rank - True Rank\")"
                        },
                        {
                            "line": 84,
                            "code": "plt.title(f\"MVP Ranking Predictions ({year})\")"
                        },
                        {
                            "line": 85,
                            "code": "plt.tight_layout()"
                        }
                    ]
                },
                {
                    "summaryComponent": "saves",
                    "codeSegments": [
                        {
                            "line": 86,
                            "code": "plt.savefig(f\"data/ranking_predictions_{year}.png\")"
                        }
                    ]
                },
                {
                    "summaryComponent": "the prediction errors",
                    "codeSegments": [
                        {
                            "line": 75,
                            "code": "df[\"RankError\"] = df[\"PredictedRank\"] - df[\"Rank\"]"
                        }
                    ]
                },
                {
                    "summaryComponent": "for player rankings",
                    "codeSegments": [
                        {
                            "line": 75,
                            "code": "df[\"RankError\"] = df[\"PredictedRank\"] - df[\"Rank\"]"
                        },
                        {
                            "line": 77,
                            "code": "year_df.sort_values(\"Rank\", inplace=True)"
                        }
                    ]
                },
                {
                    "summaryComponent": "in a specified year",
                    "codeSegments": [
                        {
                            "line": 76,
                            "code": "year_df = df[df[\"Year\"] == year].copy()"
                        }
                    ]
                }
            ],
            "code": "67: def plot_ranking_predictions(df, year):\n68:     \"\"\"\n69:     Plot prediction error for a specific year.\n70: \n71:     Args:\n72:         df: DataFrame containing prediction results\n73:         year: Year to plot prediction errors for\n74:     \"\"\"\n75:     df[\"RankError\"] = df[\"PredictedRank\"] - df[\"Rank\"]\n76:     year_df = df[df[\"Year\"] == year].copy()\n77:     year_df.sort_values(\"Rank\", inplace=True)\n78: \n79:     plt.figure(figsize=(12, 6))\n80:     sns.barplot(x=\"Name\", y=\"RankError\", data=year_df, hue=\"Name\", palette=\"coolwarm\")\n81:     plt.axhline(0, color=\"black\", linestyle=\"--\")\n82:     plt.xticks(rotation=45, ha=\"right\")\n83:     plt.ylabel(\"Predicted Rank - True Rank\")\n84:     plt.title(f\"MVP Ranking Predictions ({year})\")\n85:     plt.tight_layout()\n86:     plt.savefig(f\"data/ranking_predictions_{year}.png\")"
        },
        "timestamp": "2025-08-16 23:05:16.000",
        "id": "xVtS2pFDTZwblmhhSKlM"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "d36650a7-ba7a-4b56-9484-7b316e17b625",
            "mapping_index": 1,
            "structured_type": "structured",
            "detail_level": "low"
        },
        "timestamp": "2025-08-16 23:05:16.000",
        "id": "y5vtEy5nU1tOVxh8aPLU"
    },
    {
        "source": "backend",
        "event": "map_summary_code",
        "data": {
            "summary": "The plot_ranking_predictions function generates a bar plot to visualize the prediction error (PredictedRank minus actual Rank) for each player in a specified year. It first computes the rank error, filters the DataFrame for the given year, and sorts the data by true rank to ensure a consistent order. Using Seaborn, it creates a colored bar plot with player names on the x-axis and prediction errors on the y-axis, adding a horizontal line at zero for reference. The plot is formatted for readability and saved as a PNG file named according to the year.",
            "mapping": [
                {
                    "summaryComponent": "The plot_ranking_predictions function generates a bar plot to visualize the prediction error (PredictedRank minus actual Rank) for each player in a specified year.",
                    "codeSegments": [
                        {
                            "line": 67,
                            "code": "def plot_ranking_predictions(df, year):"
                        },
                        {
                            "line": 79,
                            "code": "plt.figure(figsize=(12, 6))"
                        },
                        {
                            "line": 80,
                            "code": "sns.barplot(x=\"Name\", y=\"RankError\", data=year_df, hue=\"Name\", palette=\"coolwarm\")"
                        }
                    ]
                },
                {
                    "summaryComponent": "It first computes the rank error,",
                    "codeSegments": [
                        {
                            "line": 75,
                            "code": "df[\"RankError\"] = df[\"PredictedRank\"] - df[\"Rank\"]"
                        }
                    ]
                },
                {
                    "summaryComponent": "filters the DataFrame for the given year,",
                    "codeSegments": [
                        {
                            "line": 76,
                            "code": "year_df = df[df[\"Year\"] == year].copy()"
                        }
                    ]
                },
                {
                    "summaryComponent": "and sorts the data by true rank to ensure a consistent order.",
                    "codeSegments": [
                        {
                            "line": 77,
                            "code": "year_df.sort_values(\"Rank\", inplace=True)"
                        }
                    ]
                },
                {
                    "summaryComponent": "Using Seaborn, it creates a colored bar plot with player names on the x-axis and prediction errors on the y-axis,",
                    "codeSegments": [
                        {
                            "line": 80,
                            "code": "sns.barplot(x=\"Name\", y=\"RankError\", data=year_df, hue=\"Name\", palette=\"coolwarm\")"
                        }
                    ]
                },
                {
                    "summaryComponent": "adding a horizontal line at zero for reference.",
                    "codeSegments": [
                        {
                            "line": 81,
                            "code": "plt.axhline(0, color=\"black\", linestyle=\"--\")"
                        }
                    ]
                },
                {
                    "summaryComponent": "The plot is formatted for readability",
                    "codeSegments": [
                        {
                            "line": 82,
                            "code": "plt.xticks(rotation=45, ha=\"right\")"
                        },
                        {
                            "line": 83,
                            "code": "plt.ylabel(\"Predicted Rank - True Rank\")"
                        },
                        {
                            "line": 84,
                            "code": "plt.title(f\"MVP Ranking Predictions ({year})\")"
                        },
                        {
                            "line": 85,
                            "code": "plt.tight_layout()"
                        }
                    ]
                },
                {
                    "summaryComponent": "and saved as a PNG file named according to the year.",
                    "codeSegments": [
                        {
                            "line": 86,
                            "code": "plt.savefig(f\"data/ranking_predictions_{year}.png\")"
                        }
                    ]
                }
            ],
            "code": "67: def plot_ranking_predictions(df, year):\n68:     \"\"\"\n69:     Plot prediction error for a specific year.\n70: \n71:     Args:\n72:         df: DataFrame containing prediction results\n73:         year: Year to plot prediction errors for\n74:     \"\"\"\n75:     df[\"RankError\"] = df[\"PredictedRank\"] - df[\"Rank\"]\n76:     year_df = df[df[\"Year\"] == year].copy()\n77:     year_df.sort_values(\"Rank\", inplace=True)\n78: \n79:     plt.figure(figsize=(12, 6))\n80:     sns.barplot(x=\"Name\", y=\"RankError\", data=year_df, hue=\"Name\", palette=\"coolwarm\")\n81:     plt.axhline(0, color=\"black\", linestyle=\"--\")\n82:     plt.xticks(rotation=45, ha=\"right\")\n83:     plt.ylabel(\"Predicted Rank - True Rank\")\n84:     plt.title(f\"MVP Ranking Predictions ({year})\")\n85:     plt.tight_layout()\n86:     plt.savefig(f\"data/ranking_predictions_{year}.png\")"
        },
        "timestamp": "2025-08-16 23:05:17.000",
        "id": "BfeRjyWUzhzVTa8zPoC6"
    },
    {
        "source": "backend",
        "event": "map_summary_code",
        "data": {
            "summary": "• Computes the 'RankError' column as the difference between 'PredictedRank' and 'Rank' for each entry\n• Filters the DataFrame to include only rows from the specified year and sorts them by actual rank\n• Sets up a matplotlib figure with a specific size\n• Creates a Seaborn bar plot:\n  ◦ x-axis: Player names\n  ◦ y-axis: RankError values\n  ◦ Hue: Player names for color distinction\n  ◦ Palette: 'coolwarm' for visual contrast\n• Adds a horizontal dashed line at y=0 to indicate no error\n• Rotates x-axis labels for better readability\n• Sets axis labels and a descriptive plot title indicating the year\n• Adjusts layout for clarity and saves the figure as 'data/ranking_predictions_{year}.png'",
            "mapping": [
                {
                    "summaryComponent": "Computes the 'RankError' column as the difference between 'PredictedRank' and 'Rank' for each entry",
                    "codeSegments": [
                        {
                            "line": 75,
                            "code": "df[\"RankError\"] = df[\"PredictedRank\"] - df[\"Rank\"]"
                        }
                    ]
                },
                {
                    "summaryComponent": "Filters the DataFrame to include only rows from the specified year and sorts them by actual rank",
                    "codeSegments": [
                        {
                            "line": 76,
                            "code": "year_df = df[df[\"Year\"] == year].copy()"
                        },
                        {
                            "line": 77,
                            "code": "year_df.sort_values(\"Rank\", inplace=True)"
                        }
                    ]
                },
                {
                    "summaryComponent": "Sets up a matplotlib figure with a specific size",
                    "codeSegments": [
                        {
                            "line": 79,
                            "code": "plt.figure(figsize=(12, 6))"
                        }
                    ]
                },
                {
                    "summaryComponent": "Creates a Seaborn bar plot:",
                    "codeSegments": [
                        {
                            "line": 80,
                            "code": "sns.barplot(x=\"Name\", y=\"RankError\", data=year_df, hue=\"Name\", palette=\"coolwarm\")"
                        }
                    ]
                },
                {
                    "summaryComponent": "x-axis: Player names",
                    "codeSegments": [
                        {
                            "line": 80,
                            "code": "x=\"Name\""
                        }
                    ]
                },
                {
                    "summaryComponent": "y-axis: RankError values",
                    "codeSegments": [
                        {
                            "line": 80,
                            "code": "y=\"RankError\""
                        }
                    ]
                },
                {
                    "summaryComponent": "Hue: Player names for color distinction",
                    "codeSegments": [
                        {
                            "line": 80,
                            "code": "hue=\"Name\""
                        }
                    ]
                },
                {
                    "summaryComponent": "Palette: 'coolwarm' for visual contrast",
                    "codeSegments": [
                        {
                            "line": 80,
                            "code": "palette=\"coolwarm\""
                        }
                    ]
                },
                {
                    "summaryComponent": "Adds a horizontal dashed line at y=0 to indicate no error",
                    "codeSegments": [
                        {
                            "line": 81,
                            "code": "plt.axhline(0, color=\"black\", linestyle=\"--\")"
                        }
                    ]
                },
                {
                    "summaryComponent": "Rotates x-axis labels for better readability",
                    "codeSegments": [
                        {
                            "line": 82,
                            "code": "plt.xticks(rotation=45, ha=\"right\")"
                        }
                    ]
                },
                {
                    "summaryComponent": "Sets axis labels and a descriptive plot title indicating the year",
                    "codeSegments": [
                        {
                            "line": 83,
                            "code": "plt.ylabel(\"Predicted Rank - True Rank\")"
                        },
                        {
                            "line": 84,
                            "code": "plt.title(f\"MVP Ranking Predictions ({year})\")"
                        }
                    ]
                },
                {
                    "summaryComponent": "Adjusts layout for clarity and saves the figure as 'data/ranking_predictions_{year}.png'",
                    "codeSegments": [
                        {
                            "line": 85,
                            "code": "plt.tight_layout()"
                        },
                        {
                            "line": 86,
                            "code": "plt.savefig(f\"data/ranking_predictions_{year}.png\")"
                        }
                    ]
                }
            ],
            "code": "67: def plot_ranking_predictions(df, year):\n68:     \"\"\"\n69:     Plot prediction error for a specific year.\n70: \n71:     Args:\n72:         df: DataFrame containing prediction results\n73:         year: Year to plot prediction errors for\n74:     \"\"\"\n75:     df[\"RankError\"] = df[\"PredictedRank\"] - df[\"Rank\"]\n76:     year_df = df[df[\"Year\"] == year].copy()\n77:     year_df.sort_values(\"Rank\", inplace=True)\n78: \n79:     plt.figure(figsize=(12, 6))\n80:     sns.barplot(x=\"Name\", y=\"RankError\", data=year_df, hue=\"Name\", palette=\"coolwarm\")\n81:     plt.axhline(0, color=\"black\", linestyle=\"--\")\n82:     plt.xticks(rotation=45, ha=\"right\")\n83:     plt.ylabel(\"Predicted Rank - True Rank\")\n84:     plt.title(f\"MVP Ranking Predictions ({year})\")\n85:     plt.tight_layout()\n86:     plt.savefig(f\"data/ranking_predictions_{year}.png\")"
        },
        "timestamp": "2025-08-16 23:05:17.000",
        "id": "EUzHral66Mb8Bs8DHqLy"
    },
    {
        "source": "frontend",
        "event": "create_new_section",
        "data": {
            "section_id": "fafe9b2f-8214-4a1e-9e99-50227b490c4d",
            "section_data": {
                "editPromptDetailLevel": null,
                "selectedStructured": "unstructured",
                "createdAt": 1755371117000,
                "lines": [
                    67,
                    86
                ],
                "editPromptStructured": null,
                "summaryData": {
                    "low_structured": "• Plots prediction errors for a given year\n• Saves the plot as an image file",
                    "high_unstructured": "The plot_ranking_predictions function generates a bar plot to visualize the prediction error (PredictedRank minus actual Rank) for each player in a specified year. It first computes the rank error, filters the DataFrame for the given year, and sorts the data by true rank to ensure a consistent order. Using Seaborn, it creates a colored bar plot with player names on the x-axis and prediction errors on the y-axis, adding a horizontal line at zero for reference. The plot is formatted for readability and saved as a PNG file named according to the year.",
                    "medium_unstructured": "The plot_ranking_predictions function visualizes the difference between predicted and actual ranks for each player in a specified year. It creates a bar plot showing these errors and saves the resulting image to a file. The plot includes player names, error values, and a reference line at zero.",
                    "high_structured": "• Computes the 'RankError' column as the difference between 'PredictedRank' and 'Rank' for each entry\n• Filters the DataFrame to include only rows from the specified year and sorts them by actual rank\n• Sets up a matplotlib figure with a specific size\n• Creates a Seaborn bar plot:\n  ◦ x-axis: Player names\n  ◦ y-axis: RankError values\n  ◦ Hue: Player names for color distinction\n  ◦ Palette: 'coolwarm' for visual contrast\n• Adds a horizontal dashed line at y=0 to indicate no error\n• Rotates x-axis labels for better readability\n• Sets axis labels and a descriptive plot title indicating the year\n• Adjusts layout for clarity and saves the figure as 'data/ranking_predictions_{year}.png'",
                    "title": "Function: plot_ranking_predictions",
                    "low_unstructured": "This function plots and saves the prediction errors for player rankings in a specified year.",
                    "medium_structured": "• Calculates prediction error as the difference between predicted and actual ranks\n• Filters data for the specified year and sorts by true rank\n• Creates a bar plot of prediction errors for each player\n  ◦ Uses player names as labels and colors\n• Adds a horizontal reference line and saves the plot as a PNG file"
                },
                "selectedDetailLevel": "medium",
                "metadata": {
                    "originalCode": "def plot_ranking_predictions(df, year):\n    \"\"\"\n    Plot prediction error for a specific year.\n\n    Args:\n        df: DataFrame containing prediction results\n        year: Year to plot prediction errors for\n    \"\"\"\n    df[\"RankError\"] = df[\"PredictedRank\"] - df[\"Rank\"]\n    year_df = df[df[\"Year\"] == year].copy()\n    year_df.sort_values(\"Rank\", inplace=True)\n\n    plt.figure(figsize=(12, 6))\n    sns.barplot(x=\"Name\", y=\"RankError\", data=year_df, hue=\"Name\", palette=\"coolwarm\")\n    plt.axhline(0, color=\"black\", linestyle=\"--\")\n    plt.xticks(rotation=45, ha=\"right\")\n    plt.ylabel(\"Predicted Rank - True Rank\")\n    plt.title(f\"MVP Ranking Predictions ({year})\")\n    plt.tight_layout()\n    plt.savefig(f\"data/ranking_predictions_{year}.png\")",
                    "fullPath": "/project/workspace/rank_model.py",
                    "id": "fafe9b2f-8214-4a1e-9e99-50227b490c4d",
                    "offset": 1496,
                    "filename": "rank_model.py"
                },
                "editPromptValue": "",
                "title": "Function: plot_ranking_predictions",
                "summaryMappings": {
                    "high_unstructured": [
                        {
                            "summaryComponent": "The plot_ranking_predictions function generates a bar plot to visualize the prediction error (PredictedRank minus actual Rank) for each player in a specified year.",
                            "codeSegments": [
                                {
                                    "line": 67,
                                    "code": "def plot_ranking_predictions(df, year):"
                                },
                                {
                                    "line": 79,
                                    "code": "plt.figure(figsize=(12, 6))"
                                },
                                {
                                    "line": 80,
                                    "code": "sns.barplot(x=\"Name\", y=\"RankError\", data=year_df, hue=\"Name\", palette=\"coolwarm\")"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "It first computes the rank error,",
                            "codeSegments": [
                                {
                                    "line": 75,
                                    "code": "df[\"RankError\"] = df[\"PredictedRank\"] - df[\"Rank\"]"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "filters the DataFrame for the given year,",
                            "codeSegments": [
                                {
                                    "line": 76,
                                    "code": "year_df = df[df[\"Year\"] == year].copy()"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "and sorts the data by true rank to ensure a consistent order.",
                            "codeSegments": [
                                {
                                    "line": 77,
                                    "code": "year_df.sort_values(\"Rank\", inplace=True)"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "Using Seaborn, it creates a colored bar plot with player names on the x-axis and prediction errors on the y-axis,",
                            "codeSegments": [
                                {
                                    "line": 80,
                                    "code": "sns.barplot(x=\"Name\", y=\"RankError\", data=year_df, hue=\"Name\", palette=\"coolwarm\")"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "adding a horizontal line at zero for reference.",
                            "codeSegments": [
                                {
                                    "line": 81,
                                    "code": "plt.axhline(0, color=\"black\", linestyle=\"--\")"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "The plot is formatted for readability",
                            "codeSegments": [
                                {
                                    "line": 82,
                                    "code": "plt.xticks(rotation=45, ha=\"right\")"
                                },
                                {
                                    "line": 83,
                                    "code": "plt.ylabel(\"Predicted Rank - True Rank\")"
                                },
                                {
                                    "line": 84,
                                    "code": "plt.title(f\"MVP Ranking Predictions ({year})\")"
                                },
                                {
                                    "line": 85,
                                    "code": "plt.tight_layout()"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "and saved as a PNG file named according to the year.",
                            "codeSegments": [
                                {
                                    "line": 86,
                                    "code": "plt.savefig(f\"data/ranking_predictions_{year}.png\")"
                                }
                            ]
                        }
                    ],
                    "medium_unstructured": [
                        {
                            "summaryComponent": "The plot_ranking_predictions function",
                            "codeSegments": [
                                {
                                    "line": 67,
                                    "code": "def plot_ranking_predictions(df, year):"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "visualizes the difference between predicted and actual ranks",
                            "codeSegments": [
                                {
                                    "line": 75,
                                    "code": "df[\"RankError\"] = df[\"PredictedRank\"] - df[\"Rank\"]"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "for each player in a specified year",
                            "codeSegments": [
                                {
                                    "line": 76,
                                    "code": "year_df = df[df[\"Year\"] == year].copy()"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "It creates a bar plot showing these errors",
                            "codeSegments": [
                                {
                                    "line": 80,
                                    "code": "sns.barplot(x=\"Name\", y=\"RankError\", data=year_df, hue=\"Name\", palette=\"coolwarm\")"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "and saves the resulting image to a file",
                            "codeSegments": [
                                {
                                    "line": 86,
                                    "code": "plt.savefig(f\"data/ranking_predictions_{year}.png\")"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "The plot includes player names",
                            "codeSegments": [
                                {
                                    "line": 80,
                                    "code": "sns.barplot(x=\"Name\", y=\"RankError\", data=year_df, hue=\"Name\", palette=\"coolwarm\")"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "error values",
                            "codeSegments": [
                                {
                                    "line": 80,
                                    "code": "sns.barplot(x=\"Name\", y=\"RankError\", data=year_df, hue=\"Name\", palette=\"coolwarm\")"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "and a reference line at zero",
                            "codeSegments": [
                                {
                                    "line": 81,
                                    "code": "plt.axhline(0, color=\"black\", linestyle=\"--\")"
                                }
                            ]
                        }
                    ],
                    "high_structured": [
                        {
                            "summaryComponent": "Computes the 'RankError' column as the difference between 'PredictedRank' and 'Rank' for each entry",
                            "codeSegments": [
                                {
                                    "line": 75,
                                    "code": "df[\"RankError\"] = df[\"PredictedRank\"] - df[\"Rank\"]"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "Filters the DataFrame to include only rows from the specified year and sorts them by actual rank",
                            "codeSegments": [
                                {
                                    "line": 76,
                                    "code": "year_df = df[df[\"Year\"] == year].copy()"
                                },
                                {
                                    "line": 77,
                                    "code": "year_df.sort_values(\"Rank\", inplace=True)"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "Sets up a matplotlib figure with a specific size",
                            "codeSegments": [
                                {
                                    "line": 79,
                                    "code": "plt.figure(figsize=(12, 6))"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "Creates a Seaborn bar plot:",
                            "codeSegments": [
                                {
                                    "line": 80,
                                    "code": "sns.barplot(x=\"Name\", y=\"RankError\", data=year_df, hue=\"Name\", palette=\"coolwarm\")"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "x-axis: Player names",
                            "codeSegments": [
                                {
                                    "line": 80,
                                    "code": "x=\"Name\""
                                }
                            ]
                        },
                        {
                            "summaryComponent": "y-axis: RankError values",
                            "codeSegments": [
                                {
                                    "line": 80,
                                    "code": "y=\"RankError\""
                                }
                            ]
                        },
                        {
                            "summaryComponent": "Hue: Player names for color distinction",
                            "codeSegments": [
                                {
                                    "line": 80,
                                    "code": "hue=\"Name\""
                                }
                            ]
                        },
                        {
                            "summaryComponent": "Palette: 'coolwarm' for visual contrast",
                            "codeSegments": [
                                {
                                    "line": 80,
                                    "code": "palette=\"coolwarm\""
                                }
                            ]
                        },
                        {
                            "summaryComponent": "Adds a horizontal dashed line at y=0 to indicate no error",
                            "codeSegments": [
                                {
                                    "line": 81,
                                    "code": "plt.axhline(0, color=\"black\", linestyle=\"--\")"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "Rotates x-axis labels for better readability",
                            "codeSegments": [
                                {
                                    "line": 82,
                                    "code": "plt.xticks(rotation=45, ha=\"right\")"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "Sets axis labels and a descriptive plot title indicating the year",
                            "codeSegments": [
                                {
                                    "line": 83,
                                    "code": "plt.ylabel(\"Predicted Rank - True Rank\")"
                                },
                                {
                                    "line": 84,
                                    "code": "plt.title(f\"MVP Ranking Predictions ({year})\")"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "Adjusts layout for clarity and saves the figure as 'data/ranking_predictions_{year}.png'",
                            "codeSegments": [
                                {
                                    "line": 85,
                                    "code": "plt.tight_layout()"
                                },
                                {
                                    "line": 86,
                                    "code": "plt.savefig(f\"data/ranking_predictions_{year}.png\")"
                                }
                            ]
                        }
                    ],
                    "low_unstructured": [
                        {
                            "summaryComponent": "plots",
                            "codeSegments": [
                                {
                                    "line": 79,
                                    "code": "plt.figure(figsize=(12, 6))"
                                },
                                {
                                    "line": 80,
                                    "code": "sns.barplot(x=\"Name\", y=\"RankError\", data=year_df, hue=\"Name\", palette=\"coolwarm\")"
                                },
                                {
                                    "line": 81,
                                    "code": "plt.axhline(0, color=\"black\", linestyle=\"--\")"
                                },
                                {
                                    "line": 82,
                                    "code": "plt.xticks(rotation=45, ha=\"right\")"
                                },
                                {
                                    "line": 83,
                                    "code": "plt.ylabel(\"Predicted Rank - True Rank\")"
                                },
                                {
                                    "line": 84,
                                    "code": "plt.title(f\"MVP Ranking Predictions ({year})\")"
                                },
                                {
                                    "line": 85,
                                    "code": "plt.tight_layout()"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "saves",
                            "codeSegments": [
                                {
                                    "line": 86,
                                    "code": "plt.savefig(f\"data/ranking_predictions_{year}.png\")"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "the prediction errors",
                            "codeSegments": [
                                {
                                    "line": 75,
                                    "code": "df[\"RankError\"] = df[\"PredictedRank\"] - df[\"Rank\"]"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "for player rankings",
                            "codeSegments": [
                                {
                                    "line": 75,
                                    "code": "df[\"RankError\"] = df[\"PredictedRank\"] - df[\"Rank\"]"
                                },
                                {
                                    "line": 77,
                                    "code": "year_df.sort_values(\"Rank\", inplace=True)"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "in a specified year",
                            "codeSegments": [
                                {
                                    "line": 76,
                                    "code": "year_df = df[df[\"Year\"] == year].copy()"
                                }
                            ]
                        }
                    ],
                    "low_structured": [
                        {
                            "summaryComponent": "Plots prediction errors for a given year",
                            "codeSegments": [
                                {
                                    "line": 67,
                                    "code": "def plot_ranking_predictions(df, year):"
                                },
                                {
                                    "line": 75,
                                    "code": "df[\"RankError\"] = df[\"PredictedRank\"] - df[\"Rank\"]"
                                },
                                {
                                    "line": 76,
                                    "code": "year_df = df[df[\"Year\"] == year].copy()"
                                },
                                {
                                    "line": 80,
                                    "code": "sns.barplot(x=\"Name\", y=\"RankError\", data=year_df, hue=\"Name\", palette=\"coolwarm\")"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "Saves the plot as an image file",
                            "codeSegments": [
                                {
                                    "line": 86,
                                    "code": "plt.savefig(f\"data/ranking_predictions_{year}.png\")"
                                }
                            ]
                        }
                    ],
                    "medium_structured": [
                        {
                            "summaryComponent": "Calculates prediction error as the difference between predicted and actual ranks",
                            "codeSegments": [
                                {
                                    "line": 75,
                                    "code": "df[\"RankError\"] = df[\"PredictedRank\"] - df[\"Rank\"]"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "Filters data for the specified year and sorts by true rank",
                            "codeSegments": [
                                {
                                    "line": 76,
                                    "code": "year_df = df[df[\"Year\"] == year].copy()"
                                },
                                {
                                    "line": 77,
                                    "code": "year_df.sort_values(\"Rank\", inplace=True)"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "Creates a bar plot of prediction errors for each player",
                            "codeSegments": [
                                {
                                    "line": 80,
                                    "code": "sns.barplot(x=\"Name\", y=\"RankError\", data=year_df, hue=\"Name\", palette=\"coolwarm\")"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "Uses player names as labels and colors",
                            "codeSegments": [
                                {
                                    "line": 80,
                                    "code": "sns.barplot(x=\"Name\", y=\"RankError\", data=year_df, hue=\"Name\", palette=\"coolwarm\")"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "Adds a horizontal reference line and saves the plot as a PNG file",
                            "codeSegments": [
                                {
                                    "line": 81,
                                    "code": "plt.axhline(0, color=\"black\", linestyle=\"--\")"
                                },
                                {
                                    "line": 86,
                                    "code": "plt.savefig(f\"data/ranking_predictions_{year}.png\")"
                                }
                            ]
                        }
                    ]
                }
            }
        },
        "timestamp": "2025-08-16 23:05:18.000",
        "id": "7hYWWhe4yodgxVLQJume"
    },
    {
        "source": "frontend",
        "event": "autotransit_section",
        "data": {
            "before_section_id": "d36650a7-ba7a-4b56-9484-7b316e17b625",
            "after_section_id": "fafe9b2f-8214-4a1e-9e99-50227b490c4d"
        },
        "timestamp": "2025-08-16 23:05:18.000",
        "id": "akujPHbo4kE7mXlxjzzW"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "fafe9b2f-8214-4a1e-9e99-50227b490c4d",
            "mapping_index": 4,
            "structured_type": "unstructured",
            "detail_level": "medium"
        },
        "timestamp": "2025-08-16 23:05:19.000",
        "id": "NQgp5pw3s2T3mVWNZges"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "fafe9b2f-8214-4a1e-9e99-50227b490c4d",
            "mapping_index": 1,
            "structured_type": "unstructured",
            "detail_level": "medium"
        },
        "timestamp": "2025-08-16 23:05:19.000",
        "id": "TpNK3ddMZNyLJLdcaVUE"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "fafe9b2f-8214-4a1e-9e99-50227b490c4d",
            "detail_level": "medium",
            "structured_type": "unstructured"
        },
        "timestamp": "2025-08-16 23:05:19.000",
        "id": "sTq7UJis4Ao2MeEB0nwS"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "fafe9b2f-8214-4a1e-9e99-50227b490c4d",
            "mapping_index": 5,
            "structured_type": "unstructured",
            "detail_level": "medium"
        },
        "timestamp": "2025-08-16 23:05:20.000",
        "id": "5003oQT49FCzEEa1xRLK"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "fafe9b2f-8214-4a1e-9e99-50227b490c4d",
            "detail_level": "medium",
            "structured_type": "unstructured"
        },
        "timestamp": "2025-08-16 23:05:20.000",
        "id": "WHIOnjuloh1iQaqiteqI"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "fafe9b2f-8214-4a1e-9e99-50227b490c4d",
            "mapping_index": 2,
            "structured_type": "unstructured",
            "detail_level": "medium"
        },
        "timestamp": "2025-08-16 23:05:20.000",
        "id": "hWvNga7dMZpBNgBYKdCS"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "fafe9b2f-8214-4a1e-9e99-50227b490c4d",
            "detail_level": "medium",
            "structured_type": "unstructured"
        },
        "timestamp": "2025-08-16 23:05:20.000",
        "id": "v5mTFa8L7WuvVHIEuTU9"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "fafe9b2f-8214-4a1e-9e99-50227b490c4d",
            "detail_level": "medium",
            "structured_type": "unstructured"
        },
        "timestamp": "2025-08-16 23:05:21.000",
        "id": "3Vp4BV9DAcFEbbXsGLTo"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "fafe9b2f-8214-4a1e-9e99-50227b490c4d",
            "detail_level": "medium",
            "structured_type": "unstructured"
        },
        "timestamp": "2025-08-16 23:05:22.000",
        "id": "3fohb3TuuHeGDDaR2PWA"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "fafe9b2f-8214-4a1e-9e99-50227b490c4d",
            "mapping_index": 4,
            "structured_type": "unstructured",
            "detail_level": "medium"
        },
        "timestamp": "2025-08-16 23:05:22.000",
        "id": "VjdqewYopdY1KrkoSnP5"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "fafe9b2f-8214-4a1e-9e99-50227b490c4d",
            "mapping_index": 1,
            "structured_type": "unstructured",
            "detail_level": "medium"
        },
        "timestamp": "2025-08-16 23:05:22.000",
        "id": "ZBGsiNWOw0lBsVAaFmRP"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "fafe9b2f-8214-4a1e-9e99-50227b490c4d",
            "detail_level": "medium",
            "structured_type": "unstructured"
        },
        "timestamp": "2025-08-16 23:05:22.000",
        "id": "uAY12tpC2w0sa3aaRK2b"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "fafe9b2f-8214-4a1e-9e99-50227b490c4d",
            "mapping_index": 1,
            "structured_type": "unstructured",
            "detail_level": "medium"
        },
        "timestamp": "2025-08-16 23:05:23.000",
        "id": "QR59l7UYcEHZWUFkUx9O"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "fafe9b2f-8214-4a1e-9e99-50227b490c4d",
            "mapping_index": 0,
            "structured_type": "unstructured",
            "detail_level": "medium"
        },
        "timestamp": "2025-08-16 23:05:24.000",
        "id": "8gkrJcOJD2bER0R4qUpI"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "fafe9b2f-8214-4a1e-9e99-50227b490c4d",
            "detail_level": "medium",
            "structured_type": "unstructured"
        },
        "timestamp": "2025-08-16 23:05:24.000",
        "id": "QRxilnP4Hc9zxYuZ5AtT"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "fafe9b2f-8214-4a1e-9e99-50227b490c4d",
            "detail_level": "medium",
            "structured_type": "unstructured"
        },
        "timestamp": "2025-08-16 23:05:24.000",
        "id": "RPE5X2VqvGSzPvJ0mbI5"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "fafe9b2f-8214-4a1e-9e99-50227b490c4d",
            "detail_level": "medium",
            "structured_type": "unstructured"
        },
        "timestamp": "2025-08-16 23:05:24.000",
        "id": "VadpdLnOpeaJ2uwQHAeY"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "fafe9b2f-8214-4a1e-9e99-50227b490c4d",
            "detail_level": "medium",
            "structured_type": "unstructured"
        },
        "timestamp": "2025-08-16 23:05:24.000",
        "id": "aJatXKAOiRJs1TnyNzCs"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "fafe9b2f-8214-4a1e-9e99-50227b490c4d",
            "mapping_index": 3,
            "structured_type": "unstructured",
            "detail_level": "medium"
        },
        "timestamp": "2025-08-16 23:05:24.000",
        "id": "ix1cEtFwrIqnQQx87ioi"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "fafe9b2f-8214-4a1e-9e99-50227b490c4d",
            "mapping_index": 1,
            "structured_type": "unstructured",
            "detail_level": "medium"
        },
        "timestamp": "2025-08-16 23:05:24.000",
        "id": "sBwEeylcc2RxDLfsPemR"
    },
    {
        "source": "frontend",
        "event": "change_summary_level",
        "data": {
            "before_detail_level": "medium",
            "section_id": "fafe9b2f-8214-4a1e-9e99-50227b490c4d",
            "before_structured": "unstructured",
            "after_structured": "structured",
            "after_detail_level": "medium"
        },
        "timestamp": "2025-08-16 23:05:25.000",
        "id": "k26KA1Bf1lfSPLovn2gW"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "fafe9b2f-8214-4a1e-9e99-50227b490c4d",
            "detail_level": "medium",
            "structured_type": "structured"
        },
        "timestamp": "2025-08-16 23:05:26.000",
        "id": "6bNSQaGcBFY2A5gNfgQO"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "fafe9b2f-8214-4a1e-9e99-50227b490c4d",
            "mapping_index": 0,
            "structured_type": "structured",
            "detail_level": "medium"
        },
        "timestamp": "2025-08-16 23:05:26.000",
        "id": "PvtjfGXAXcxqbsEUJYq6"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "fafe9b2f-8214-4a1e-9e99-50227b490c4d",
            "detail_level": "medium",
            "structured_type": "structured"
        },
        "timestamp": "2025-08-16 23:05:26.000",
        "id": "X5yk1ESkX2QEq8OMm87H"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "fafe9b2f-8214-4a1e-9e99-50227b490c4d",
            "mapping_index": 2,
            "structured_type": "structured",
            "detail_level": "medium"
        },
        "timestamp": "2025-08-16 23:05:26.000",
        "id": "bNC9d0mhYvw93Lqh3XPl"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "fafe9b2f-8214-4a1e-9e99-50227b490c4d",
            "mapping_index": 1,
            "structured_type": "structured",
            "detail_level": "medium"
        },
        "timestamp": "2025-08-16 23:05:26.000",
        "id": "gtRNupB9ttBLdDv8C6i2"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "fafe9b2f-8214-4a1e-9e99-50227b490c4d",
            "mapping_index": 1,
            "structured_type": "structured",
            "detail_level": "medium"
        },
        "timestamp": "2025-08-16 23:05:28.000",
        "id": "GurP3RuzuFzpqdR2No3O"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "fafe9b2f-8214-4a1e-9e99-50227b490c4d",
            "mapping_index": 0,
            "structured_type": "structured",
            "detail_level": "medium"
        },
        "timestamp": "2025-08-16 23:05:28.000",
        "id": "HvU4SN6i7nHgfvxlPWfG"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "fafe9b2f-8214-4a1e-9e99-50227b490c4d",
            "detail_level": "medium",
            "structured_type": "structured"
        },
        "timestamp": "2025-08-16 23:05:28.000",
        "id": "I6eBtDBcgUR6HLFhbf6y"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "fafe9b2f-8214-4a1e-9e99-50227b490c4d",
            "detail_level": "medium",
            "structured_type": "structured"
        },
        "timestamp": "2025-08-16 23:05:28.000",
        "id": "N5G9XXW8Vl16X2kXDmrq"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "fafe9b2f-8214-4a1e-9e99-50227b490c4d",
            "detail_level": "medium",
            "structured_type": "structured"
        },
        "timestamp": "2025-08-16 23:05:28.000",
        "id": "Uh2XjF2WCgb42JfBCKpi"
    },
    {
        "source": "frontend",
        "event": "change_summary_level",
        "data": {
            "before_detail_level": "medium",
            "section_id": "fafe9b2f-8214-4a1e-9e99-50227b490c4d",
            "before_structured": "structured",
            "after_structured": "structured",
            "after_detail_level": "low"
        },
        "timestamp": "2025-08-16 23:05:29.000",
        "id": "QUHNvuWC8BdoH4USVqyg"
    },
    {
        "source": "frontend",
        "event": "change_summary_level",
        "data": {
            "before_detail_level": "low",
            "section_id": "fafe9b2f-8214-4a1e-9e99-50227b490c4d",
            "before_structured": "structured",
            "after_structured": "structured",
            "after_detail_level": "medium"
        },
        "timestamp": "2025-08-16 23:05:29.000",
        "id": "cOCC8yggu10Bdipl8nuK"
    },
    {
        "source": "frontend",
        "event": "change_summary_level",
        "data": {
            "before_detail_level": "medium",
            "section_id": "fafe9b2f-8214-4a1e-9e99-50227b490c4d",
            "before_structured": "structured",
            "after_structured": "structured",
            "after_detail_level": "high"
        },
        "timestamp": "2025-08-16 23:05:30.000",
        "id": "qYqimWk9diw1ER8Gqh7A"
    },
    {
        "source": "frontend",
        "event": "change_summary_level",
        "data": {
            "before_detail_level": "high",
            "section_id": "fafe9b2f-8214-4a1e-9e99-50227b490c4d",
            "before_structured": "structured",
            "after_structured": "structured",
            "after_detail_level": "medium"
        },
        "timestamp": "2025-08-16 23:05:34.000",
        "id": "24eL8yqIyAbQKR9lpAKP"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "fafe9b2f-8214-4a1e-9e99-50227b490c4d",
            "mapping_index": 0,
            "structured_type": "unstructured",
            "detail_level": "medium"
        },
        "timestamp": "2025-08-16 23:05:36.000",
        "id": "3o6uSYtesT46YsS2bpRc"
    },
    {
        "source": "frontend",
        "event": "change_summary_level",
        "data": {
            "before_detail_level": "medium",
            "section_id": "fafe9b2f-8214-4a1e-9e99-50227b490c4d",
            "before_structured": "structured",
            "after_structured": "unstructured",
            "after_detail_level": "medium"
        },
        "timestamp": "2025-08-16 23:05:36.000",
        "id": "RAd9OuNW2YVNsZI2GkiK"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "fafe9b2f-8214-4a1e-9e99-50227b490c4d",
            "detail_level": "medium",
            "structured_type": "unstructured"
        },
        "timestamp": "2025-08-16 23:05:36.000",
        "id": "iFjCkLV0z9czQXmPQA4w"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "fafe9b2f-8214-4a1e-9e99-50227b490c4d",
            "mapping_index": 2,
            "structured_type": "unstructured",
            "detail_level": "medium"
        },
        "timestamp": "2025-08-16 23:05:36.000",
        "id": "jK84OL7go8Cj5bDfb1bk"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "fafe9b2f-8214-4a1e-9e99-50227b490c4d",
            "detail_level": "medium",
            "structured_type": "unstructured"
        },
        "timestamp": "2025-08-16 23:05:37.000",
        "id": "10xh1xNo3aHFbYh1rvZm"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "fafe9b2f-8214-4a1e-9e99-50227b490c4d",
            "mapping_index": 6,
            "structured_type": "unstructured",
            "detail_level": "medium"
        },
        "timestamp": "2025-08-16 23:05:37.000",
        "id": "8ihpxFRzwgI1Q8sxihCw"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "fafe9b2f-8214-4a1e-9e99-50227b490c4d",
            "mapping_index": 3,
            "structured_type": "unstructured",
            "detail_level": "medium"
        },
        "timestamp": "2025-08-16 23:05:37.000",
        "id": "FY6MOTIJwIdywysSiqIZ"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "fafe9b2f-8214-4a1e-9e99-50227b490c4d",
            "detail_level": "medium",
            "structured_type": "unstructured"
        },
        "timestamp": "2025-08-16 23:05:37.000",
        "id": "NVk2mKRNzb0V0bDRVOdr"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "fafe9b2f-8214-4a1e-9e99-50227b490c4d",
            "mapping_index": 0,
            "structured_type": "unstructured",
            "detail_level": "medium"
        },
        "timestamp": "2025-08-16 23:05:37.000",
        "id": "XMrVaPxmCm2etvH1fxDs"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "fafe9b2f-8214-4a1e-9e99-50227b490c4d",
            "detail_level": "medium",
            "structured_type": "unstructured"
        },
        "timestamp": "2025-08-16 23:05:37.000",
        "id": "tK6Iw6F19mwnabmbk6nZ"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "fafe9b2f-8214-4a1e-9e99-50227b490c4d",
            "detail_level": "medium",
            "structured_type": "unstructured"
        },
        "timestamp": "2025-08-16 23:05:38.000",
        "id": "7K35iLtaSgLwrYZjD0Z9"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "fafe9b2f-8214-4a1e-9e99-50227b490c4d",
            "mapping_index": 1,
            "structured_type": "unstructured",
            "detail_level": "medium"
        },
        "timestamp": "2025-08-16 23:05:38.000",
        "id": "tv068sP7hY49hA4yr5Wp"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "fafe9b2f-8214-4a1e-9e99-50227b490c4d",
            "detail_level": "medium",
            "structured_type": "unstructured"
        },
        "timestamp": "2025-08-16 23:05:40.000",
        "id": "6cleLGmpKHMQs7YkEs3B"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "fafe9b2f-8214-4a1e-9e99-50227b490c4d",
            "mapping_index": 1,
            "structured_type": "unstructured",
            "detail_level": "medium"
        },
        "timestamp": "2025-08-16 23:05:40.000",
        "id": "BC8SBeekz19GjhkvapcG"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "fafe9b2f-8214-4a1e-9e99-50227b490c4d",
            "detail_level": "medium",
            "structured_type": "unstructured"
        },
        "timestamp": "2025-08-16 23:05:40.000",
        "id": "OCuV3qOXhXNcLfcgHd0g"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "fafe9b2f-8214-4a1e-9e99-50227b490c4d",
            "detail_level": "medium",
            "structured_type": "unstructured"
        },
        "timestamp": "2025-08-16 23:05:40.000",
        "id": "Uyo1z7SUCvhJHdLQo5kn"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "fafe9b2f-8214-4a1e-9e99-50227b490c4d",
            "mapping_index": 3,
            "structured_type": "unstructured",
            "detail_level": "medium"
        },
        "timestamp": "2025-08-16 23:05:40.000",
        "id": "WlvnVj2jvPStAzrHkxgy"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "fafe9b2f-8214-4a1e-9e99-50227b490c4d",
            "mapping_index": 4,
            "structured_type": "unstructured",
            "detail_level": "medium"
        },
        "timestamp": "2025-08-16 23:05:40.000",
        "id": "hWinJNgtbCw8kxhRT5Sz"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "fafe9b2f-8214-4a1e-9e99-50227b490c4d",
            "detail_level": "medium",
            "structured_type": "unstructured"
        },
        "timestamp": "2025-08-16 23:05:41.000",
        "id": "79ku2SRJmUqvSBvEndsx"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "fafe9b2f-8214-4a1e-9e99-50227b490c4d",
            "mapping_index": 5,
            "structured_type": "unstructured",
            "detail_level": "medium"
        },
        "timestamp": "2025-08-16 23:05:41.000",
        "id": "Bdh017iIQVtknFwxkPKH"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "fafe9b2f-8214-4a1e-9e99-50227b490c4d",
            "detail_level": "medium",
            "structured_type": "unstructured"
        },
        "timestamp": "2025-08-16 23:05:41.000",
        "id": "HMpokS6Evc6EyJ1M2AWm"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "fafe9b2f-8214-4a1e-9e99-50227b490c4d",
            "detail_level": "medium",
            "structured_type": "unstructured"
        },
        "timestamp": "2025-08-16 23:05:41.000",
        "id": "LTi0aF3Uf1zlWRyc2sO7"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "fafe9b2f-8214-4a1e-9e99-50227b490c4d",
            "mapping_index": 2,
            "structured_type": "unstructured",
            "detail_level": "medium"
        },
        "timestamp": "2025-08-16 23:05:41.000",
        "id": "os9R3VarPBONiM6ZA7BW"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "fafe9b2f-8214-4a1e-9e99-50227b490c4d",
            "mapping_index": 4,
            "structured_type": "unstructured",
            "detail_level": "medium"
        },
        "timestamp": "2025-08-16 23:05:41.000",
        "id": "wr7KKDdkZ2PbQLY9boQc"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "fafe9b2f-8214-4a1e-9e99-50227b490c4d",
            "mapping_index": 4,
            "structured_type": "unstructured",
            "detail_level": "medium"
        },
        "timestamp": "2025-08-16 23:05:42.000",
        "id": "DOGcbqU0z5vuUmfOUnwb"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "fafe9b2f-8214-4a1e-9e99-50227b490c4d",
            "detail_level": "medium",
            "structured_type": "unstructured"
        },
        "timestamp": "2025-08-16 23:05:42.000",
        "id": "ECZFmdfGcurRCuGsAyzh"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "fafe9b2f-8214-4a1e-9e99-50227b490c4d",
            "detail_level": "medium",
            "structured_type": "unstructured"
        },
        "timestamp": "2025-08-16 23:05:42.000",
        "id": "FTqNfRhrcOvJXV2eV5kC"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "fafe9b2f-8214-4a1e-9e99-50227b490c4d",
            "mapping_index": 2,
            "structured_type": "unstructured",
            "detail_level": "medium"
        },
        "timestamp": "2025-08-16 23:05:42.000",
        "id": "acSiK18JFRr3yTHXeEiW"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "fafe9b2f-8214-4a1e-9e99-50227b490c4d",
            "detail_level": "medium",
            "structured_type": "unstructured"
        },
        "timestamp": "2025-08-16 23:05:42.000",
        "id": "hm7BfAqbJPYKKERhKVId"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "fafe9b2f-8214-4a1e-9e99-50227b490c4d",
            "mapping_index": 3,
            "structured_type": "unstructured",
            "detail_level": "medium"
        },
        "timestamp": "2025-08-16 23:05:42.000",
        "id": "mH4gnyR14kqzw9RnsHd3"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "fafe9b2f-8214-4a1e-9e99-50227b490c4d",
            "mapping_index": 1,
            "structured_type": "unstructured",
            "detail_level": "medium"
        },
        "timestamp": "2025-08-16 23:05:42.000",
        "id": "qV03hNUpWC5LQNGe6ibi"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "fafe9b2f-8214-4a1e-9e99-50227b490c4d",
            "detail_level": "medium",
            "structured_type": "unstructured"
        },
        "timestamp": "2025-08-16 23:05:42.000",
        "id": "xXJ4Dt3VfGLXNr3hScJx"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "fafe9b2f-8214-4a1e-9e99-50227b490c4d",
            "detail_level": "medium",
            "structured_type": "unstructured"
        },
        "timestamp": "2025-08-16 23:05:42.000",
        "id": "yGUFwKlXhnNfVYVW4k1V"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "fafe9b2f-8214-4a1e-9e99-50227b490c4d",
            "mapping_index": 2,
            "structured_type": "unstructured",
            "detail_level": "medium"
        },
        "timestamp": "2025-08-16 23:05:45.000",
        "id": "Cxe4jsx3SNVN9fx54oaW"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "fafe9b2f-8214-4a1e-9e99-50227b490c4d",
            "mapping_index": 5,
            "structured_type": "unstructured",
            "detail_level": "medium"
        },
        "timestamp": "2025-08-16 23:05:45.000",
        "id": "GYFxRArGPuDQuVKBOtXi"
    },
    {
        "source": "frontend",
        "event": "click_edit_in_prompt",
        "data": {
            "section_id": "fafe9b2f-8214-4a1e-9e99-50227b490c4d",
            "summary": "The plot_ranking_predictions function visualizes the difference between predicted and actual ranks for each player in a specified year. It creates a bar plot showing these errors and saves the resulting image to a file. The plot includes player names, error values, and a reference line at zero.",
            "detail_level": "medium",
            "structured": "unstructured"
        },
        "timestamp": "2025-08-16 23:05:45.000",
        "id": "J1nUKM2x8jZttktmT8WK"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "fafe9b2f-8214-4a1e-9e99-50227b490c4d",
            "detail_level": "medium",
            "structured_type": "unstructured"
        },
        "timestamp": "2025-08-16 23:05:45.000",
        "id": "NgBTlJU9a2fq62VxFW73"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "fafe9b2f-8214-4a1e-9e99-50227b490c4d",
            "detail_level": "medium",
            "structured_type": "unstructured"
        },
        "timestamp": "2025-08-16 23:05:45.000",
        "id": "fojXZrCJo0Vcw6pxemmB"
    },
    {
        "source": "frontend",
        "event": "apply_instruction_summary",
        "data": {
            "section_id": "fafe9b2f-8214-4a1e-9e99-50227b490c4d",
            "instruction": "change regular bar chart to grouped bar chart (color palette \"coolwarm\")",
            "detail_level": "medium",
            "original_summary": "The plot_ranking_predictions function visualizes the difference between predicted and actual ranks for each player in a specified year. It creates a bar plot showing these errors and saves the resulting image to a file. The plot includes player names, error values, and a reference line at zero.",
            "structured": "unstructured"
        },
        "timestamp": "2025-08-16 23:06:06.000",
        "id": "h9Dj3fSsddq8V0v8AIIf"
    },
    {
        "source": "backend",
        "event": "apply_instruction_summary",
        "data": {
            "original_code": "def plot_ranking_predictions(df, year):\n    \"\"\"\n    Plot prediction error for a specific year.\n\n    Args:\n        df: DataFrame containing prediction results\n        year: Year to plot prediction errors for\n    \"\"\"\n    df[\"RankError\"] = df[\"PredictedRank\"] - df[\"Rank\"]\n    year_df = df[df[\"Year\"] == year].copy()\n    year_df.sort_values(\"Rank\", inplace=True)\n\n    plt.figure(figsize=(12, 6))\n    sns.barplot(x=\"Name\", y=\"RankError\", data=year_df, hue=\"Name\", palette=\"coolwarm\")\n    plt.axhline(0, color=\"black\", linestyle=\"--\")\n    plt.xticks(rotation=45, ha=\"right\")\n    plt.ylabel(\"Predicted Rank - True Rank\")\n    plt.title(f\"MVP Ranking Predictions ({year})\")\n    plt.tight_layout()\n    plt.savefig(f\"data/ranking_predictions_{year}.png\")",
            "original_summary": "The plot_ranking_predictions function visualizes the difference between predicted and actual ranks for each player in a specified year. It creates a bar plot showing these errors and saves the resulting image to a file. The plot includes player names, error values, and a reference line at zero.",
            "instruction": "change regular bar chart to grouped bar chart (color palette \"coolwarm\")",
            "updated_summary": "The plot_ranking_predictions function visualizes the difference between predicted and actual ranks for each player in a specified year. It creates a grouped bar plot using the \"coolwarm\" color palette to show these errors and saves the resulting image to a file. The plot includes player names, error values, and a reference line at zero."
        },
        "timestamp": "2025-08-16 23:06:07.000",
        "id": "IOYwPcPuDEBXPq55MtPo"
    },
    {
        "source": "frontend",
        "event": "commit_modified_summary",
        "data": {
            "section_id": "fafe9b2f-8214-4a1e-9e99-50227b490c4d",
            "edited_summary": "The plot_ranking_predictions function visualizes the difference between predicted and actual ranks for each player in a specified year. It creates a grouped bar plot using the \"coolwarm\" color palette to show these errors and saves the resulting image to a file. The plot includes player names, error values, and a reference line at zero.",
            "detail_level": "medium",
            "original_summary": "The plot_ranking_predictions function visualizes the difference between predicted and actual ranks for each player in a specified year. It creates a bar plot showing these errors and saves the resulting image to a file. The plot includes player names, error values, and a reference line at zero.",
            "structured": "unstructured"
        },
        "timestamp": "2025-08-16 23:06:12.000",
        "id": "pePTZrLxZioBlRWWx3Nz"
    },
    {
        "source": "backend",
        "event": "modify_summary_mediation",
        "data": {
            "original_code": "def plot_ranking_predictions(df, year):\n    \"\"\"\n    Plot prediction error for a specific year.\n\n    Args:\n        df: DataFrame containing prediction results\n        year: Year to plot prediction errors for\n    \"\"\"\n    df[\"RankError\"] = df[\"PredictedRank\"] - df[\"Rank\"]\n    year_df = df[df[\"Year\"] == year].copy()\n    year_df.sort_values(\"Rank\", inplace=True)\n\n    plt.figure(figsize=(12, 6))\n    sns.barplot(x=\"Name\", y=\"RankError\", data=year_df, hue=\"Name\", palette=\"coolwarm\")\n    plt.axhline(0, color=\"black\", linestyle=\"--\")\n    plt.xticks(rotation=45, ha=\"right\")\n    plt.ylabel(\"Predicted Rank - True Rank\")\n    plt.title(f\"MVP Ranking Predictions ({year})\")\n    plt.tight_layout()\n    plt.savefig(f\"data/ranking_predictions_{year}.png\")",
            "original_summary": "The plot_ranking_predictions function visualizes the difference between predicted and actual ranks for each player in a specified year. It creates a bar plot showing these errors and saves the resulting image to a file. The plot includes player names, error values, and a reference line at zero.",
            "edited_summary": "The plot_ranking_predictions function visualizes the difference between predicted and actual ranks for each player in a specified year. It creates a grouped bar plot using the \"coolwarm\" color palette to show these errors and saves the resulting image to a file. The plot includes player names, error values, and a reference line at zero.",
            "structured_type": "unstructured",
            "detail_level": "medium",
            "updated_code": "def plot_ranking_predictions(df, year):\n    \"\"\"\n    Plot prediction error for a specific year.\n\n    Args:\n        df: DataFrame containing prediction results\n        year: Year to plot prediction errors for\n    \"\"\"\n    df[\"RankError\"] = df[\"PredictedRank\"] - df[\"Rank\"]\n    year_df = df[df[\"Year\"] == year].copy()\n    year_df.sort_values(\"Rank\", inplace=True)\n\n    plt.figure(figsize=(12, 6))\n    sns.barplot(x=\"Name\", y=\"RankError\", data=year_df, hue=\"Name\", palette=\"coolwarm\", dodge=True)\n    plt.axhline(0, color=\"black\", linestyle=\"--\")\n    plt.xticks(rotation=45, ha=\"right\")\n    plt.ylabel(\"Predicted Rank - True Rank\")\n    plt.title(f\"MVP Ranking Predictions ({year})\")\n    plt.tight_layout()\n    plt.savefig(f\"data/ranking_predictions_{year}.png\")"
        },
        "timestamp": "2025-08-16 23:06:14.000",
        "id": "tqHn63g7NuYCslQzxjhO"
    },
    {
        "source": "backend",
        "event": "summarize_modified_code",
        "data": {
            "new_code": "def plot_ranking_predictions(df, year):\n    \"\"\"\n    Plot prediction error for a specific year.\n\n    Args:\n        df: DataFrame containing prediction results\n        year: Year to plot prediction errors for\n    \"\"\"\n    df[\"RankError\"] = df[\"PredictedRank\"] - df[\"Rank\"]\n    year_df = df[df[\"Year\"] == year].copy()\n    year_df.sort_values(\"Rank\", inplace=True)\n\n    plt.figure(figsize=(12, 6))\n    sns.barplot(x=\"Name\", y=\"RankError\", data=year_df, hue=\"Name\", palette=\"coolwarm\", dodge=True)\n    plt.axhline(0, color=\"black\", linestyle=\"--\")\n    plt.xticks(rotation=45, ha=\"right\")\n    plt.ylabel(\"Predicted Rank - True Rank\")\n    plt.title(f\"MVP Ranking Predictions ({year})\")\n    plt.tight_layout()\n    plt.savefig(f\"data/ranking_predictions_{year}.png\")",
            "original_code": "def plot_ranking_predictions(df, year):\n    \"\"\"\n    Plot prediction error for a specific year.\n\n    Args:\n        df: DataFrame containing prediction results\n        year: Year to plot prediction errors for\n    \"\"\"\n    df[\"RankError\"] = df[\"PredictedRank\"] - df[\"Rank\"]\n    year_df = df[df[\"Year\"] == year].copy()\n    year_df.sort_values(\"Rank\", inplace=True)\n\n    plt.figure(figsize=(12, 6))\n    sns.barplot(x=\"Name\", y=\"RankError\", data=year_df, hue=\"Name\", palette=\"coolwarm\", dodge=True)\n    plt.axhline(0, color=\"black\", linestyle=\"--\")\n    plt.xticks(rotation=45, ha=\"right\")\n    plt.ylabel(\"Predicted Rank - True Rank\")\n    plt.title(f\"MVP Ranking Predictions ({year})\")\n    plt.tight_layout()\n    plt.savefig(f\"data/ranking_predictions_{year}.png\")",
            "old_summary": {
                "low_structured": "• Plots prediction errors for a given year\n• Saves the plot as an image file",
                "high_unstructured": "The plot_ranking_predictions function generates a bar plot to visualize the prediction error (PredictedRank minus actual Rank) for each player in a specified year. It first computes the rank error, filters the DataFrame for the given year, and sorts the data by true rank to ensure a consistent order. Using Seaborn, it creates a colored bar plot with player names on the x-axis and prediction errors on the y-axis, adding a horizontal line at zero for reference. The plot is formatted for readability and saved as a PNG file named according to the year.",
                "medium_unstructured": "The plot_ranking_predictions function visualizes the difference between predicted and actual ranks for each player in a specified year. It creates a bar plot showing these errors and saves the resulting image to a file. The plot includes player names, error values, and a reference line at zero.",
                "high_structured": "• Computes the 'RankError' column as the difference between 'PredictedRank' and 'Rank' for each entry\n• Filters the DataFrame to include only rows from the specified year and sorts them by actual rank\n• Sets up a matplotlib figure with a specific size\n• Creates a Seaborn bar plot:\n  ◦ x-axis: Player names\n  ◦ y-axis: RankError values\n  ◦ Hue: Player names for color distinction\n  ◦ Palette: 'coolwarm' for visual contrast\n• Adds a horizontal dashed line at y=0 to indicate no error\n• Rotates x-axis labels for better readability\n• Sets axis labels and a descriptive plot title indicating the year\n• Adjusts layout for clarity and saves the figure as 'data/ranking_predictions_{year}.png'",
                "title": "Function: plot_ranking_predictions",
                "low_unstructured": "This function plots and saves the prediction errors for player rankings in a specified year.",
                "medium_structured": "• Calculates prediction error as the difference between predicted and actual ranks\n• Filters data for the specified year and sorts by true rank\n• Creates a bar plot of prediction errors for each player\n  ◦ Uses player names as labels and colors\n• Adds a horizontal reference line and saves the plot as a PNG file"
            },
            "new_summary": {
                "low_structured": "• Plots prediction errors for a given year\n• Saves the plot as an image file\n• (No changes were made to the function.)",
                "high_unstructured": "The plot_ranking_predictions function generates a bar plot to visualize the prediction error (PredictedRank minus actual Rank) for each player in a specified year. It first computes the rank error, filters the DataFrame for the given year, and sorts the data by true rank to ensure a consistent order. Using Seaborn, it creates a colored bar plot with player names on the x-axis and prediction errors on the y-axis, adding a horizontal line at zero for reference. The plot is formatted for readability and saved as a PNG file named according to the year. (No changes were made to the function.)",
                "medium_unstructured": "The plot_ranking_predictions function visualizes the difference between predicted and actual ranks for each player in a specified year. It creates a bar plot showing these errors and saves the resulting image to a file. The plot includes player names, error values, and a reference line at zero. (There are no changes from the previous version.)",
                "high_structured": "• Computes the 'RankError' column as the difference between 'PredictedRank' and 'Rank' for each entry\n• Filters the DataFrame to include only rows from the specified year and sorts them by actual rank\n• Sets up a matplotlib figure with a specific size\n• Creates a Seaborn bar plot:\n  ◦ x-axis: Player names\n  ◦ y-axis: RankError values\n  ◦ Hue: Player names for color distinction\n  ◦ Palette: 'coolwarm' for visual contrast\n• Adds a horizontal dashed line at y=0 to indicate no error\n• Rotates x-axis labels for better readability\n• Sets axis labels and a descriptive plot title indicating the year\n• Adjusts layout for clarity and saves the figure as 'data/ranking_predictions_{year}.png'\n• (No changes were made to the function.)",
                "title": "Function: plot_ranking_predictions",
                "low_unstructured": "This function plots and saves the prediction errors for player rankings in a specified year. (No changes were made to the function.)",
                "medium_structured": "• Calculates prediction error as the difference between predicted and actual ranks\n• Filters data for the specified year and sorts by true rank\n• Creates a bar plot of prediction errors for each player\n  ◦ Uses player names as labels and colors\n• Adds a horizontal reference line and saves the plot as a PNG file\n• (No changes were made to the function.)"
            }
        },
        "timestamp": "2025-08-16 23:06:19.000",
        "id": "RZnRGCa9jOAwxRNmMynG"
    },
    {
        "source": "backend",
        "event": "map_summary_code",
        "data": {
            "summary": "• Plots prediction errors for a given year\n• Saves the plot as an image file\n• (No changes were made to the function.)",
            "mapping": [
                {
                    "summaryComponent": "Plots prediction errors for a given year",
                    "codeSegments": [
                        {
                            "line": 67,
                            "code": "def plot_ranking_predictions(df, year):"
                        },
                        {
                            "line": 76,
                            "code": "year_df = df[df[\"Year\"] == year].copy()"
                        },
                        {
                            "line": 80,
                            "code": "sns.barplot(x=\"Name\", y=\"RankError\", data=year_df, hue=\"Name\", palette=\"coolwarm\", dodge=True)"
                        }
                    ]
                },
                {
                    "summaryComponent": "Saves the plot as an image file",
                    "codeSegments": [
                        {
                            "line": 86,
                            "code": "plt.savefig(f\"data/ranking_predictions_{year}.png\")"
                        }
                    ]
                },
                {
                    "summaryComponent": "(No changes were made to the function.)",
                    "codeSegments": []
                }
            ],
            "code": "67: def plot_ranking_predictions(df, year):\n68:     \"\"\"\n69:     Plot prediction error for a specific year.\n70: \n71:     Args:\n72:         df: DataFrame containing prediction results\n73:         year: Year to plot prediction errors for\n74:     \"\"\"\n75:     df[\"RankError\"] = df[\"PredictedRank\"] - df[\"Rank\"]\n76:     year_df = df[df[\"Year\"] == year].copy()\n77:     year_df.sort_values(\"Rank\", inplace=True)\n78: \n79:     plt.figure(figsize=(12, 6))\n80:     sns.barplot(x=\"Name\", y=\"RankError\", data=year_df, hue=\"Name\", palette=\"coolwarm\", dodge=True)\n81:     plt.axhline(0, color=\"black\", linestyle=\"--\")\n82:     plt.xticks(rotation=45, ha=\"right\")\n83:     plt.ylabel(\"Predicted Rank - True Rank\")\n84:     plt.title(f\"MVP Ranking Predictions ({year})\")\n85:     plt.tight_layout()\n86:     plt.savefig(f\"data/ranking_predictions_{year}.png\")"
        },
        "timestamp": "2025-08-16 23:06:20.000",
        "id": "WChGWh3traOFXx04A4L8"
    },
    {
        "source": "backend",
        "event": "map_summary_code",
        "data": {
            "summary": "This function plots and saves the prediction errors for player rankings in a specified year. (No changes were made to the function.)",
            "mapping": [
                {
                    "summaryComponent": "plots and saves the prediction errors",
                    "codeSegments": [
                        {
                            "line": 79,
                            "code": "plt.figure(figsize=(12, 6))"
                        },
                        {
                            "line": 80,
                            "code": "sns.barplot(x=\"Name\", y=\"RankError\", data=year_df, hue=\"Name\", palette=\"coolwarm\", dodge=True)"
                        },
                        {
                            "line": 86,
                            "code": "plt.savefig(f\"data/ranking_predictions_{year}.png\")"
                        }
                    ]
                },
                {
                    "summaryComponent": "for player rankings",
                    "codeSegments": [
                        {
                            "line": 75,
                            "code": "df[\"RankError\"] = df[\"PredictedRank\"] - df[\"Rank\"]"
                        },
                        {
                            "line": 77,
                            "code": "year_df.sort_values(\"Rank\", inplace=True)"
                        }
                    ]
                },
                {
                    "summaryComponent": "in a specified year",
                    "codeSegments": [
                        {
                            "line": 76,
                            "code": "year_df = df[df[\"Year\"] == year].copy()"
                        }
                    ]
                }
            ],
            "code": "67: def plot_ranking_predictions(df, year):\n68:     \"\"\"\n69:     Plot prediction error for a specific year.\n70: \n71:     Args:\n72:         df: DataFrame containing prediction results\n73:         year: Year to plot prediction errors for\n74:     \"\"\"\n75:     df[\"RankError\"] = df[\"PredictedRank\"] - df[\"Rank\"]\n76:     year_df = df[df[\"Year\"] == year].copy()\n77:     year_df.sort_values(\"Rank\", inplace=True)\n78: \n79:     plt.figure(figsize=(12, 6))\n80:     sns.barplot(x=\"Name\", y=\"RankError\", data=year_df, hue=\"Name\", palette=\"coolwarm\", dodge=True)\n81:     plt.axhline(0, color=\"black\", linestyle=\"--\")\n82:     plt.xticks(rotation=45, ha=\"right\")\n83:     plt.ylabel(\"Predicted Rank - True Rank\")\n84:     plt.title(f\"MVP Ranking Predictions ({year})\")\n85:     plt.tight_layout()\n86:     plt.savefig(f\"data/ranking_predictions_{year}.png\")"
        },
        "timestamp": "2025-08-16 23:06:20.000",
        "id": "cjIYX9slci1pv4uZshfV"
    },
    {
        "source": "backend",
        "event": "map_summary_code",
        "data": {
            "summary": "• Calculates prediction error as the difference between predicted and actual ranks\n• Filters data for the specified year and sorts by true rank\n• Creates a bar plot of prediction errors for each player\n  ◦ Uses player names as labels and colors\n• Adds a horizontal reference line and saves the plot as a PNG file\n• (No changes were made to the function.)",
            "mapping": [
                {
                    "summaryComponent": "Calculates prediction error as the difference between predicted and actual ranks",
                    "codeSegments": [
                        {
                            "line": 75,
                            "code": "df[\"RankError\"] = df[\"PredictedRank\"] - df[\"Rank\"]"
                        }
                    ]
                },
                {
                    "summaryComponent": "Filters data for the specified year and sorts by true rank",
                    "codeSegments": [
                        {
                            "line": 76,
                            "code": "year_df = df[df[\"Year\"] == year].copy()"
                        },
                        {
                            "line": 77,
                            "code": "year_df.sort_values(\"Rank\", inplace=True)"
                        }
                    ]
                },
                {
                    "summaryComponent": "Creates a bar plot of prediction errors for each player",
                    "codeSegments": [
                        {
                            "line": 80,
                            "code": "sns.barplot(x=\"Name\", y=\"RankError\", data=year_df, hue=\"Name\", palette=\"coolwarm\", dodge=True)"
                        }
                    ]
                },
                {
                    "summaryComponent": "Uses player names as labels and colors",
                    "codeSegments": [
                        {
                            "line": 80,
                            "code": "x=\"Name\""
                        },
                        {
                            "line": 80,
                            "code": "hue=\"Name\""
                        }
                    ]
                },
                {
                    "summaryComponent": "Adds a horizontal reference line and saves the plot as a PNG file",
                    "codeSegments": [
                        {
                            "line": 81,
                            "code": "plt.axhline(0, color=\"black\", linestyle=\"--\")"
                        },
                        {
                            "line": 86,
                            "code": "plt.savefig(f\"data/ranking_predictions_{year}.png\")"
                        }
                    ]
                }
            ],
            "code": "67: def plot_ranking_predictions(df, year):\n68:     \"\"\"\n69:     Plot prediction error for a specific year.\n70: \n71:     Args:\n72:         df: DataFrame containing prediction results\n73:         year: Year to plot prediction errors for\n74:     \"\"\"\n75:     df[\"RankError\"] = df[\"PredictedRank\"] - df[\"Rank\"]\n76:     year_df = df[df[\"Year\"] == year].copy()\n77:     year_df.sort_values(\"Rank\", inplace=True)\n78: \n79:     plt.figure(figsize=(12, 6))\n80:     sns.barplot(x=\"Name\", y=\"RankError\", data=year_df, hue=\"Name\", palette=\"coolwarm\", dodge=True)\n81:     plt.axhline(0, color=\"black\", linestyle=\"--\")\n82:     plt.xticks(rotation=45, ha=\"right\")\n83:     plt.ylabel(\"Predicted Rank - True Rank\")\n84:     plt.title(f\"MVP Ranking Predictions ({year})\")\n85:     plt.tight_layout()\n86:     plt.savefig(f\"data/ranking_predictions_{year}.png\")"
        },
        "timestamp": "2025-08-16 23:06:21.000",
        "id": "nzEu9eaQXM18XQxerGDt"
    },
    {
        "source": "backend",
        "event": "map_summary_code",
        "data": {
            "summary": "The plot_ranking_predictions function visualizes the difference between predicted and actual ranks for each player in a specified year. It creates a bar plot showing these errors and saves the resulting image to a file. The plot includes player names, error values, and a reference line at zero. (There are no changes from the previous version.)",
            "mapping": [
                {
                    "summaryComponent": "The plot_ranking_predictions function",
                    "codeSegments": [
                        {
                            "line": 67,
                            "code": "def plot_ranking_predictions(df, year):"
                        }
                    ]
                },
                {
                    "summaryComponent": "visualizes the difference between predicted and actual ranks",
                    "codeSegments": [
                        {
                            "line": 75,
                            "code": "df[\"RankError\"] = df[\"PredictedRank\"] - df[\"Rank\"]"
                        }
                    ]
                },
                {
                    "summaryComponent": "for each player in a specified year",
                    "codeSegments": [
                        {
                            "line": 76,
                            "code": "year_df = df[df[\"Year\"] == year].copy()"
                        }
                    ]
                },
                {
                    "summaryComponent": "It creates a bar plot showing these errors",
                    "codeSegments": [
                        {
                            "line": 80,
                            "code": "sns.barplot(x=\"Name\", y=\"RankError\", data=year_df, hue=\"Name\", palette=\"coolwarm\", dodge=True)"
                        }
                    ]
                },
                {
                    "summaryComponent": "and saves the resulting image to a file",
                    "codeSegments": [
                        {
                            "line": 86,
                            "code": "plt.savefig(f\"data/ranking_predictions_{year}.png\")"
                        }
                    ]
                },
                {
                    "summaryComponent": "The plot includes player names",
                    "codeSegments": [
                        {
                            "line": 80,
                            "code": "sns.barplot(x=\"Name\", y=\"RankError\", data=year_df, hue=\"Name\", palette=\"coolwarm\", dodge=True)"
                        }
                    ]
                },
                {
                    "summaryComponent": "error values",
                    "codeSegments": [
                        {
                            "line": 80,
                            "code": "sns.barplot(x=\"Name\", y=\"RankError\", data=year_df, hue=\"Name\", palette=\"coolwarm\", dodge=True)"
                        }
                    ]
                },
                {
                    "summaryComponent": "and a reference line at zero",
                    "codeSegments": [
                        {
                            "line": 81,
                            "code": "plt.axhline(0, color=\"black\", linestyle=\"--\")"
                        }
                    ]
                }
            ],
            "code": "67: def plot_ranking_predictions(df, year):\n68:     \"\"\"\n69:     Plot prediction error for a specific year.\n70: \n71:     Args:\n72:         df: DataFrame containing prediction results\n73:         year: Year to plot prediction errors for\n74:     \"\"\"\n75:     df[\"RankError\"] = df[\"PredictedRank\"] - df[\"Rank\"]\n76:     year_df = df[df[\"Year\"] == year].copy()\n77:     year_df.sort_values(\"Rank\", inplace=True)\n78: \n79:     plt.figure(figsize=(12, 6))\n80:     sns.barplot(x=\"Name\", y=\"RankError\", data=year_df, hue=\"Name\", palette=\"coolwarm\", dodge=True)\n81:     plt.axhline(0, color=\"black\", linestyle=\"--\")\n82:     plt.xticks(rotation=45, ha=\"right\")\n83:     plt.ylabel(\"Predicted Rank - True Rank\")\n84:     plt.title(f\"MVP Ranking Predictions ({year})\")\n85:     plt.tight_layout()\n86:     plt.savefig(f\"data/ranking_predictions_{year}.png\")"
        },
        "timestamp": "2025-08-16 23:06:22.000",
        "id": "69N9U8lAJUInXKOinEXz"
    },
    {
        "source": "backend",
        "event": "map_summary_code",
        "data": {
            "summary": "The plot_ranking_predictions function generates a bar plot to visualize the prediction error (PredictedRank minus actual Rank) for each player in a specified year. It first computes the rank error, filters the DataFrame for the given year, and sorts the data by true rank to ensure a consistent order. Using Seaborn, it creates a colored bar plot with player names on the x-axis and prediction errors on the y-axis, adding a horizontal line at zero for reference. The plot is formatted for readability and saved as a PNG file named according to the year. (No changes were made to the function.)",
            "mapping": [
                {
                    "summaryComponent": "The plot_ranking_predictions function generates a bar plot to visualize the prediction error (PredictedRank minus actual Rank) for each player in a specified year.",
                    "codeSegments": [
                        {
                            "line": 67,
                            "code": "def plot_ranking_predictions(df, year):"
                        },
                        {
                            "line": 79,
                            "code": "plt.figure(figsize=(12, 6))"
                        },
                        {
                            "line": 80,
                            "code": "sns.barplot(x=\"Name\", y=\"RankError\", data=year_df, hue=\"Name\", palette=\"coolwarm\", dodge=True)"
                        }
                    ]
                },
                {
                    "summaryComponent": "It first computes the rank error,",
                    "codeSegments": [
                        {
                            "line": 75,
                            "code": "df[\"RankError\"] = df[\"PredictedRank\"] - df[\"Rank\"]"
                        }
                    ]
                },
                {
                    "summaryComponent": "filters the DataFrame for the given year,",
                    "codeSegments": [
                        {
                            "line": 76,
                            "code": "year_df = df[df[\"Year\"] == year].copy()"
                        }
                    ]
                },
                {
                    "summaryComponent": "and sorts the data by true rank to ensure a consistent order.",
                    "codeSegments": [
                        {
                            "line": 77,
                            "code": "year_df.sort_values(\"Rank\", inplace=True)"
                        }
                    ]
                },
                {
                    "summaryComponent": "Using Seaborn, it creates a colored bar plot with player names on the x-axis and prediction errors on the y-axis,",
                    "codeSegments": [
                        {
                            "line": 80,
                            "code": "sns.barplot(x=\"Name\", y=\"RankError\", data=year_df, hue=\"Name\", palette=\"coolwarm\", dodge=True)"
                        }
                    ]
                },
                {
                    "summaryComponent": "adding a horizontal line at zero for reference.",
                    "codeSegments": [
                        {
                            "line": 81,
                            "code": "plt.axhline(0, color=\"black\", linestyle=\"--\")"
                        }
                    ]
                },
                {
                    "summaryComponent": "The plot is formatted for readability",
                    "codeSegments": [
                        {
                            "line": 82,
                            "code": "plt.xticks(rotation=45, ha=\"right\")"
                        },
                        {
                            "line": 83,
                            "code": "plt.ylabel(\"Predicted Rank - True Rank\")"
                        },
                        {
                            "line": 84,
                            "code": "plt.title(f\"MVP Ranking Predictions ({year})\")"
                        },
                        {
                            "line": 85,
                            "code": "plt.tight_layout()"
                        }
                    ]
                },
                {
                    "summaryComponent": "and saved as a PNG file named according to the year.",
                    "codeSegments": [
                        {
                            "line": 86,
                            "code": "plt.savefig(f\"data/ranking_predictions_{year}.png\")"
                        }
                    ]
                }
            ],
            "code": "67: def plot_ranking_predictions(df, year):\n68:     \"\"\"\n69:     Plot prediction error for a specific year.\n70: \n71:     Args:\n72:         df: DataFrame containing prediction results\n73:         year: Year to plot prediction errors for\n74:     \"\"\"\n75:     df[\"RankError\"] = df[\"PredictedRank\"] - df[\"Rank\"]\n76:     year_df = df[df[\"Year\"] == year].copy()\n77:     year_df.sort_values(\"Rank\", inplace=True)\n78: \n79:     plt.figure(figsize=(12, 6))\n80:     sns.barplot(x=\"Name\", y=\"RankError\", data=year_df, hue=\"Name\", palette=\"coolwarm\", dodge=True)\n81:     plt.axhline(0, color=\"black\", linestyle=\"--\")\n82:     plt.xticks(rotation=45, ha=\"right\")\n83:     plt.ylabel(\"Predicted Rank - True Rank\")\n84:     plt.title(f\"MVP Ranking Predictions ({year})\")\n85:     plt.tight_layout()\n86:     plt.savefig(f\"data/ranking_predictions_{year}.png\")"
        },
        "timestamp": "2025-08-16 23:06:22.000",
        "id": "ZP9FucV7i7I29h4X3nt5"
    },
    {
        "source": "frontend",
        "event": "create_new_section",
        "data": {
            "section_id": "97f32543-125b-451c-b300-0d1f845c01bb",
            "section_data": {
                "editPromptDetailLevel": null,
                "selectedStructured": "unstructured",
                "createdAt": 1755371182000,
                "lines": [
                    67,
                    86
                ],
                "editPromptStructured": null,
                "summaryData": {
                    "low_structured": "• Plots prediction errors for a given year\n• Saves the plot as an image file\n• (No changes were made to the function.)",
                    "high_unstructured": "The plot_ranking_predictions function generates a bar plot to visualize the prediction error (PredictedRank minus actual Rank) for each player in a specified year. It first computes the rank error, filters the DataFrame for the given year, and sorts the data by true rank to ensure a consistent order. Using Seaborn, it creates a colored bar plot with player names on the x-axis and prediction errors on the y-axis, adding a horizontal line at zero for reference. The plot is formatted for readability and saved as a PNG file named according to the year. (No changes were made to the function.)",
                    "medium_unstructured": "The plot_ranking_predictions function visualizes the difference between predicted and actual ranks for each player in a specified year. It creates a bar plot showing these errors and saves the resulting image to a file. The plot includes player names, error values, and a reference line at zero. (There are no changes from the previous version.)",
                    "high_structured": "• Computes the 'RankError' column as the difference between 'PredictedRank' and 'Rank' for each entry\n• Filters the DataFrame to include only rows from the specified year and sorts them by actual rank\n• Sets up a matplotlib figure with a specific size\n• Creates a Seaborn bar plot:\n  ◦ x-axis: Player names\n  ◦ y-axis: RankError values\n  ◦ Hue: Player names for color distinction\n  ◦ Palette: 'coolwarm' for visual contrast\n• Adds a horizontal dashed line at y=0 to indicate no error\n• Rotates x-axis labels for better readability\n• Sets axis labels and a descriptive plot title indicating the year\n• Adjusts layout for clarity and saves the figure as 'data/ranking_predictions_{year}.png'\n• (No changes were made to the function.)",
                    "title": "Function: plot_ranking_predictions",
                    "low_unstructured": "This function plots and saves the prediction errors for player rankings in a specified year. (No changes were made to the function.)",
                    "medium_structured": "• Calculates prediction error as the difference between predicted and actual ranks\n• Filters data for the specified year and sorts by true rank\n• Creates a bar plot of prediction errors for each player\n  ◦ Uses player names as labels and colors\n• Adds a horizontal reference line and saves the plot as a PNG file\n• (No changes were made to the function.)"
                },
                "selectedDetailLevel": "medium",
                "oldSummaryData": {
                    "low_structured": "• Plots prediction errors for a given year\n• Saves the plot as an image file",
                    "high_unstructured": "The plot_ranking_predictions function generates a bar plot to visualize the prediction error (PredictedRank minus actual Rank) for each player in a specified year. It first computes the rank error, filters the DataFrame for the given year, and sorts the data by true rank to ensure a consistent order. Using Seaborn, it creates a colored bar plot with player names on the x-axis and prediction errors on the y-axis, adding a horizontal line at zero for reference. The plot is formatted for readability and saved as a PNG file named according to the year.",
                    "medium_unstructured": "The plot_ranking_predictions function visualizes the difference between predicted and actual ranks for each player in a specified year. It creates a bar plot showing these errors and saves the resulting image to a file. The plot includes player names, error values, and a reference line at zero.",
                    "high_structured": "• Computes the 'RankError' column as the difference between 'PredictedRank' and 'Rank' for each entry\n• Filters the DataFrame to include only rows from the specified year and sorts them by actual rank\n• Sets up a matplotlib figure with a specific size\n• Creates a Seaborn bar plot:\n  ◦ x-axis: Player names\n  ◦ y-axis: RankError values\n  ◦ Hue: Player names for color distinction\n  ◦ Palette: 'coolwarm' for visual contrast\n• Adds a horizontal dashed line at y=0 to indicate no error\n• Rotates x-axis labels for better readability\n• Sets axis labels and a descriptive plot title indicating the year\n• Adjusts layout for clarity and saves the figure as 'data/ranking_predictions_{year}.png'",
                    "title": "Function: plot_ranking_predictions",
                    "low_unstructured": "This function plots and saves the prediction errors for player rankings in a specified year.",
                    "medium_structured": "• Calculates prediction error as the difference between predicted and actual ranks\n• Filters data for the specified year and sorts by true rank\n• Creates a bar plot of prediction errors for each player\n  ◦ Uses player names as labels and colors\n• Adds a horizontal reference line and saves the plot as a PNG file"
                },
                "metadata": {
                    "originalCode": "def plot_ranking_predictions(df, year):\n    \"\"\"\n    Plot prediction error for a specific year.\n\n    Args:\n        df: DataFrame containing prediction results\n        year: Year to plot prediction errors for\n    \"\"\"\n    df[\"RankError\"] = df[\"PredictedRank\"] - df[\"Rank\"]\n    year_df = df[df[\"Year\"] == year].copy()\n    year_df.sort_values(\"Rank\", inplace=True)\n\n    plt.figure(figsize=(12, 6))\n    sns.barplot(x=\"Name\", y=\"RankError\", data=year_df, hue=\"Name\", palette=\"coolwarm\", dodge=True)\n    plt.axhline(0, color=\"black\", linestyle=\"--\")\n    plt.xticks(rotation=45, ha=\"right\")\n    plt.ylabel(\"Predicted Rank - True Rank\")\n    plt.title(f\"MVP Ranking Predictions ({year})\")\n    plt.tight_layout()\n    plt.savefig(f\"data/ranking_predictions_{year}.png\")",
                    "fullPath": "/project/workspace/rank_model.py",
                    "id": "97f32543-125b-451c-b300-0d1f845c01bb",
                    "offset": 1496,
                    "filename": "rank_model.py"
                },
                "editPromptValue": "",
                "title": "Function: plot_ranking_predictions",
                "summaryMappings": {
                    "high_unstructured": [
                        {
                            "summaryComponent": "The plot_ranking_predictions function generates a bar plot to visualize the prediction error (PredictedRank minus actual Rank) for each player in a specified year.",
                            "codeSegments": [
                                {
                                    "line": 67,
                                    "code": "def plot_ranking_predictions(df, year):"
                                },
                                {
                                    "line": 79,
                                    "code": "plt.figure(figsize=(12, 6))"
                                },
                                {
                                    "line": 80,
                                    "code": "sns.barplot(x=\"Name\", y=\"RankError\", data=year_df, hue=\"Name\", palette=\"coolwarm\", dodge=True)"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "It first computes the rank error,",
                            "codeSegments": [
                                {
                                    "line": 75,
                                    "code": "df[\"RankError\"] = df[\"PredictedRank\"] - df[\"Rank\"]"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "filters the DataFrame for the given year,",
                            "codeSegments": [
                                {
                                    "line": 76,
                                    "code": "year_df = df[df[\"Year\"] == year].copy()"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "and sorts the data by true rank to ensure a consistent order.",
                            "codeSegments": [
                                {
                                    "line": 77,
                                    "code": "year_df.sort_values(\"Rank\", inplace=True)"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "Using Seaborn, it creates a colored bar plot with player names on the x-axis and prediction errors on the y-axis,",
                            "codeSegments": [
                                {
                                    "line": 80,
                                    "code": "sns.barplot(x=\"Name\", y=\"RankError\", data=year_df, hue=\"Name\", palette=\"coolwarm\", dodge=True)"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "adding a horizontal line at zero for reference.",
                            "codeSegments": [
                                {
                                    "line": 81,
                                    "code": "plt.axhline(0, color=\"black\", linestyle=\"--\")"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "The plot is formatted for readability",
                            "codeSegments": [
                                {
                                    "line": 82,
                                    "code": "plt.xticks(rotation=45, ha=\"right\")"
                                },
                                {
                                    "line": 83,
                                    "code": "plt.ylabel(\"Predicted Rank - True Rank\")"
                                },
                                {
                                    "line": 84,
                                    "code": "plt.title(f\"MVP Ranking Predictions ({year})\")"
                                },
                                {
                                    "line": 85,
                                    "code": "plt.tight_layout()"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "and saved as a PNG file named according to the year.",
                            "codeSegments": [
                                {
                                    "line": 86,
                                    "code": "plt.savefig(f\"data/ranking_predictions_{year}.png\")"
                                }
                            ]
                        }
                    ],
                    "medium_unstructured": [
                        {
                            "summaryComponent": "The plot_ranking_predictions function",
                            "codeSegments": [
                                {
                                    "line": 67,
                                    "code": "def plot_ranking_predictions(df, year):"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "visualizes the difference between predicted and actual ranks",
                            "codeSegments": [
                                {
                                    "line": 75,
                                    "code": "df[\"RankError\"] = df[\"PredictedRank\"] - df[\"Rank\"]"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "for each player in a specified year",
                            "codeSegments": [
                                {
                                    "line": 76,
                                    "code": "year_df = df[df[\"Year\"] == year].copy()"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "It creates a bar plot showing these errors",
                            "codeSegments": [
                                {
                                    "line": 80,
                                    "code": "sns.barplot(x=\"Name\", y=\"RankError\", data=year_df, hue=\"Name\", palette=\"coolwarm\", dodge=True)"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "and saves the resulting image to a file",
                            "codeSegments": [
                                {
                                    "line": 86,
                                    "code": "plt.savefig(f\"data/ranking_predictions_{year}.png\")"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "The plot includes player names",
                            "codeSegments": [
                                {
                                    "line": 80,
                                    "code": "sns.barplot(x=\"Name\", y=\"RankError\", data=year_df, hue=\"Name\", palette=\"coolwarm\", dodge=True)"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "error values",
                            "codeSegments": [
                                {
                                    "line": 80,
                                    "code": "sns.barplot(x=\"Name\", y=\"RankError\", data=year_df, hue=\"Name\", palette=\"coolwarm\", dodge=True)"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "and a reference line at zero",
                            "codeSegments": [
                                {
                                    "line": 81,
                                    "code": "plt.axhline(0, color=\"black\", linestyle=\"--\")"
                                }
                            ]
                        }
                    ],
                    "high_structured": [
                        {
                            "summaryComponent": "Computes the 'RankError' column as the difference between 'PredictedRank' and 'Rank' for each entry",
                            "codeSegments": [
                                {
                                    "line": 75,
                                    "code": "df[\"RankError\"] = df[\"PredictedRank\"] - df[\"Rank\"]"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "Filters the DataFrame to include only rows from the specified year and sorts them by actual rank",
                            "codeSegments": [
                                {
                                    "line": 76,
                                    "code": "year_df = df[df[\"Year\"] == year].copy()"
                                },
                                {
                                    "line": 77,
                                    "code": "year_df.sort_values(\"Rank\", inplace=True)"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "Sets up a matplotlib figure with a specific size",
                            "codeSegments": [
                                {
                                    "line": 79,
                                    "code": "plt.figure(figsize=(12, 6))"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "Creates a Seaborn bar plot:",
                            "codeSegments": [
                                {
                                    "line": 80,
                                    "code": "sns.barplot(x=\"Name\", y=\"RankError\", data=year_df, hue=\"Name\", palette=\"coolwarm\", dodge=True)"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "x-axis: Player names",
                            "codeSegments": [
                                {
                                    "line": 80,
                                    "code": "x=\"Name\""
                                }
                            ]
                        },
                        {
                            "summaryComponent": "y-axis: RankError values",
                            "codeSegments": [
                                {
                                    "line": 80,
                                    "code": "y=\"RankError\""
                                }
                            ]
                        },
                        {
                            "summaryComponent": "Hue: Player names for color distinction",
                            "codeSegments": [
                                {
                                    "line": 80,
                                    "code": "hue=\"Name\""
                                }
                            ]
                        },
                        {
                            "summaryComponent": "Palette: 'coolwarm' for visual contrast",
                            "codeSegments": [
                                {
                                    "line": 80,
                                    "code": "palette=\"coolwarm\""
                                }
                            ]
                        },
                        {
                            "summaryComponent": "Adds a horizontal dashed line at y=0 to indicate no error",
                            "codeSegments": [
                                {
                                    "line": 81,
                                    "code": "plt.axhline(0, color=\"black\", linestyle=\"--\")"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "Rotates x-axis labels for better readability",
                            "codeSegments": [
                                {
                                    "line": 82,
                                    "code": "plt.xticks(rotation=45, ha=\"right\")"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "Sets axis labels and a descriptive plot title indicating the year",
                            "codeSegments": [
                                {
                                    "line": 83,
                                    "code": "plt.ylabel(\"Predicted Rank - True Rank\")"
                                },
                                {
                                    "line": 84,
                                    "code": "plt.title(f\"MVP Ranking Predictions ({year})\")"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "Adjusts layout for clarity and saves the figure as 'data/ranking_predictions_{year}.png'",
                            "codeSegments": [
                                {
                                    "line": 85,
                                    "code": "plt.tight_layout()"
                                },
                                {
                                    "line": 86,
                                    "code": "plt.savefig(f\"data/ranking_predictions_{year}.png\")"
                                }
                            ]
                        }
                    ],
                    "low_unstructured": [
                        {
                            "summaryComponent": "plots and saves the prediction errors",
                            "codeSegments": [
                                {
                                    "line": 79,
                                    "code": "plt.figure(figsize=(12, 6))"
                                },
                                {
                                    "line": 80,
                                    "code": "sns.barplot(x=\"Name\", y=\"RankError\", data=year_df, hue=\"Name\", palette=\"coolwarm\", dodge=True)"
                                },
                                {
                                    "line": 86,
                                    "code": "plt.savefig(f\"data/ranking_predictions_{year}.png\")"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "for player rankings",
                            "codeSegments": [
                                {
                                    "line": 75,
                                    "code": "df[\"RankError\"] = df[\"PredictedRank\"] - df[\"Rank\"]"
                                },
                                {
                                    "line": 77,
                                    "code": "year_df.sort_values(\"Rank\", inplace=True)"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "in a specified year",
                            "codeSegments": [
                                {
                                    "line": 76,
                                    "code": "year_df = df[df[\"Year\"] == year].copy()"
                                }
                            ]
                        }
                    ],
                    "low_structured": [
                        {
                            "summaryComponent": "Plots prediction errors for a given year",
                            "codeSegments": [
                                {
                                    "line": 67,
                                    "code": "def plot_ranking_predictions(df, year):"
                                },
                                {
                                    "line": 76,
                                    "code": "year_df = df[df[\"Year\"] == year].copy()"
                                },
                                {
                                    "line": 80,
                                    "code": "sns.barplot(x=\"Name\", y=\"RankError\", data=year_df, hue=\"Name\", palette=\"coolwarm\", dodge=True)"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "Saves the plot as an image file",
                            "codeSegments": [
                                {
                                    "line": 86,
                                    "code": "plt.savefig(f\"data/ranking_predictions_{year}.png\")"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "(No changes were made to the function.)",
                            "codeSegments": []
                        }
                    ],
                    "medium_structured": [
                        {
                            "summaryComponent": "Calculates prediction error as the difference between predicted and actual ranks",
                            "codeSegments": [
                                {
                                    "line": 75,
                                    "code": "df[\"RankError\"] = df[\"PredictedRank\"] - df[\"Rank\"]"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "Filters data for the specified year and sorts by true rank",
                            "codeSegments": [
                                {
                                    "line": 76,
                                    "code": "year_df = df[df[\"Year\"] == year].copy()"
                                },
                                {
                                    "line": 77,
                                    "code": "year_df.sort_values(\"Rank\", inplace=True)"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "Creates a bar plot of prediction errors for each player",
                            "codeSegments": [
                                {
                                    "line": 80,
                                    "code": "sns.barplot(x=\"Name\", y=\"RankError\", data=year_df, hue=\"Name\", palette=\"coolwarm\", dodge=True)"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "Uses player names as labels and colors",
                            "codeSegments": [
                                {
                                    "line": 80,
                                    "code": "x=\"Name\""
                                },
                                {
                                    "line": 80,
                                    "code": "hue=\"Name\""
                                }
                            ]
                        },
                        {
                            "summaryComponent": "Adds a horizontal reference line and saves the plot as a PNG file",
                            "codeSegments": [
                                {
                                    "line": 81,
                                    "code": "plt.axhline(0, color=\"black\", linestyle=\"--\")"
                                },
                                {
                                    "line": 86,
                                    "code": "plt.savefig(f\"data/ranking_predictions_{year}.png\")"
                                }
                            ]
                        }
                    ]
                }
            }
        },
        "timestamp": "2025-08-16 23:06:22.000",
        "id": "fRdLIPc4HvtDefsdHFyS"
    },
    {
        "source": "backend",
        "event": "map_summary_code",
        "data": {
            "summary": "• Computes the 'RankError' column as the difference between 'PredictedRank' and 'Rank' for each entry\n• Filters the DataFrame to include only rows from the specified year and sorts them by actual rank\n• Sets up a matplotlib figure with a specific size\n• Creates a Seaborn bar plot:\n  ◦ x-axis: Player names\n  ◦ y-axis: RankError values\n  ◦ Hue: Player names for color distinction\n  ◦ Palette: 'coolwarm' for visual contrast\n• Adds a horizontal dashed line at y=0 to indicate no error\n• Rotates x-axis labels for better readability\n• Sets axis labels and a descriptive plot title indicating the year\n• Adjusts layout for clarity and saves the figure as 'data/ranking_predictions_{year}.png'\n• (No changes were made to the function.)",
            "mapping": [
                {
                    "summaryComponent": "Computes the 'RankError' column as the difference between 'PredictedRank' and 'Rank' for each entry",
                    "codeSegments": [
                        {
                            "line": 75,
                            "code": "df[\"RankError\"] = df[\"PredictedRank\"] - df[\"Rank\"]"
                        }
                    ]
                },
                {
                    "summaryComponent": "Filters the DataFrame to include only rows from the specified year and sorts them by actual rank",
                    "codeSegments": [
                        {
                            "line": 76,
                            "code": "year_df = df[df[\"Year\"] == year].copy()"
                        },
                        {
                            "line": 77,
                            "code": "year_df.sort_values(\"Rank\", inplace=True)"
                        }
                    ]
                },
                {
                    "summaryComponent": "Sets up a matplotlib figure with a specific size",
                    "codeSegments": [
                        {
                            "line": 79,
                            "code": "plt.figure(figsize=(12, 6))"
                        }
                    ]
                },
                {
                    "summaryComponent": "Creates a Seaborn bar plot:",
                    "codeSegments": [
                        {
                            "line": 80,
                            "code": "sns.barplot(x=\"Name\", y=\"RankError\", data=year_df, hue=\"Name\", palette=\"coolwarm\", dodge=True)"
                        }
                    ]
                },
                {
                    "summaryComponent": "x-axis: Player names",
                    "codeSegments": [
                        {
                            "line": 80,
                            "code": "x=\"Name\""
                        }
                    ]
                },
                {
                    "summaryComponent": "y-axis: RankError values",
                    "codeSegments": [
                        {
                            "line": 80,
                            "code": "y=\"RankError\""
                        }
                    ]
                },
                {
                    "summaryComponent": "Hue: Player names for color distinction",
                    "codeSegments": [
                        {
                            "line": 80,
                            "code": "hue=\"Name\""
                        }
                    ]
                },
                {
                    "summaryComponent": "Palette: 'coolwarm' for visual contrast",
                    "codeSegments": [
                        {
                            "line": 80,
                            "code": "palette=\"coolwarm\""
                        }
                    ]
                },
                {
                    "summaryComponent": "Adds a horizontal dashed line at y=0 to indicate no error",
                    "codeSegments": [
                        {
                            "line": 81,
                            "code": "plt.axhline(0, color=\"black\", linestyle=\"--\")"
                        }
                    ]
                },
                {
                    "summaryComponent": "Rotates x-axis labels for better readability",
                    "codeSegments": [
                        {
                            "line": 82,
                            "code": "plt.xticks(rotation=45, ha=\"right\")"
                        }
                    ]
                },
                {
                    "summaryComponent": "Sets axis labels and a descriptive plot title indicating the year",
                    "codeSegments": [
                        {
                            "line": 83,
                            "code": "plt.ylabel(\"Predicted Rank - True Rank\")"
                        },
                        {
                            "line": 84,
                            "code": "plt.title(f\"MVP Ranking Predictions ({year})\")"
                        }
                    ]
                },
                {
                    "summaryComponent": "Adjusts layout for clarity and saves the figure as 'data/ranking_predictions_{year}.png'",
                    "codeSegments": [
                        {
                            "line": 85,
                            "code": "plt.tight_layout()"
                        },
                        {
                            "line": 86,
                            "code": "plt.savefig(f\"data/ranking_predictions_{year}.png\")"
                        }
                    ]
                }
            ],
            "code": "67: def plot_ranking_predictions(df, year):\n68:     \"\"\"\n69:     Plot prediction error for a specific year.\n70: \n71:     Args:\n72:         df: DataFrame containing prediction results\n73:         year: Year to plot prediction errors for\n74:     \"\"\"\n75:     df[\"RankError\"] = df[\"PredictedRank\"] - df[\"Rank\"]\n76:     year_df = df[df[\"Year\"] == year].copy()\n77:     year_df.sort_values(\"Rank\", inplace=True)\n78: \n79:     plt.figure(figsize=(12, 6))\n80:     sns.barplot(x=\"Name\", y=\"RankError\", data=year_df, hue=\"Name\", palette=\"coolwarm\", dodge=True)\n81:     plt.axhline(0, color=\"black\", linestyle=\"--\")\n82:     plt.xticks(rotation=45, ha=\"right\")\n83:     plt.ylabel(\"Predicted Rank - True Rank\")\n84:     plt.title(f\"MVP Ranking Predictions ({year})\")\n85:     plt.tight_layout()\n86:     plt.savefig(f\"data/ranking_predictions_{year}.png\")"
        },
        "timestamp": "2025-08-16 23:06:22.000",
        "id": "rOKqcdF9j97qUBssK35l"
    },
    {
        "source": "frontend",
        "event": "autotransit_section",
        "data": {
            "before_section_id": "fafe9b2f-8214-4a1e-9e99-50227b490c4d",
            "after_section_id": "97f32543-125b-451c-b300-0d1f845c01bb"
        },
        "timestamp": "2025-08-16 23:06:22.000",
        "id": "x0IuyXnU6EE3GSxhIMSn"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "97f32543-125b-451c-b300-0d1f845c01bb",
            "mapping_index": 3,
            "structured_type": "unstructured",
            "detail_level": "medium"
        },
        "timestamp": "2025-08-16 23:06:34.000",
        "id": "7Q7CIfBvSaEJAxpFCF6u"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "97f32543-125b-451c-b300-0d1f845c01bb",
            "mapping_index": 7,
            "structured_type": "unstructured",
            "detail_level": "medium"
        },
        "timestamp": "2025-08-16 23:06:34.000",
        "id": "DdS4sZDRmTipk9lc0cHc"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "97f32543-125b-451c-b300-0d1f845c01bb",
            "detail_level": "medium",
            "structured_type": "unstructured"
        },
        "timestamp": "2025-08-16 23:06:34.000",
        "id": "EfSCay0IX42Y5JykZ0gy"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "97f32543-125b-451c-b300-0d1f845c01bb",
            "detail_level": "medium",
            "structured_type": "unstructured"
        },
        "timestamp": "2025-08-16 23:06:34.000",
        "id": "YYN8tdxK0UgTEVlc6eTZ"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "97f32543-125b-451c-b300-0d1f845c01bb",
            "detail_level": "medium",
            "structured_type": "unstructured"
        },
        "timestamp": "2025-08-16 23:06:34.000",
        "id": "kDuIQiW9eSAPvSiZhBhA"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "97f32543-125b-451c-b300-0d1f845c01bb",
            "mapping_index": 0,
            "structured_type": "unstructured",
            "detail_level": "medium"
        },
        "timestamp": "2025-08-16 23:06:34.000",
        "id": "uByIBoKGvwV0Ps9pafpa"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "97f32543-125b-451c-b300-0d1f845c01bb",
            "mapping_index": 3,
            "structured_type": "unstructured",
            "detail_level": "medium"
        },
        "timestamp": "2025-08-16 23:06:36.000",
        "id": "DQLbB1oBTyurMFfMVizL"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "97f32543-125b-451c-b300-0d1f845c01bb",
            "mapping_index": 4,
            "structured_type": "unstructured",
            "detail_level": "medium"
        },
        "timestamp": "2025-08-16 23:06:36.000",
        "id": "IoSoF5ZBRnOOQdJlZscR"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "97f32543-125b-451c-b300-0d1f845c01bb",
            "mapping_index": 3,
            "structured_type": "unstructured",
            "detail_level": "medium"
        },
        "timestamp": "2025-08-16 23:06:36.000",
        "id": "KzNEcxE5DjoXL2JKByOZ"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "97f32543-125b-451c-b300-0d1f845c01bb",
            "detail_level": "medium",
            "structured_type": "unstructured"
        },
        "timestamp": "2025-08-16 23:06:36.000",
        "id": "LLkLpEQMlP4KsokHxr5w"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "97f32543-125b-451c-b300-0d1f845c01bb",
            "mapping_index": 7,
            "structured_type": "unstructured",
            "detail_level": "medium"
        },
        "timestamp": "2025-08-16 23:06:36.000",
        "id": "PdIZRSsVNy4PS5feQdiu"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "97f32543-125b-451c-b300-0d1f845c01bb",
            "detail_level": "medium",
            "structured_type": "unstructured"
        },
        "timestamp": "2025-08-16 23:06:36.000",
        "id": "R8fdK31xC7tvrYc098z8"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "97f32543-125b-451c-b300-0d1f845c01bb",
            "detail_level": "medium",
            "structured_type": "unstructured"
        },
        "timestamp": "2025-08-16 23:06:36.000",
        "id": "Z9d68mXatB5IpQrHa2WR"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "97f32543-125b-451c-b300-0d1f845c01bb",
            "mapping_index": 1,
            "structured_type": "unstructured",
            "detail_level": "medium"
        },
        "timestamp": "2025-08-16 23:06:36.000",
        "id": "bRewQGMyuURBkdfhv1jn"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "97f32543-125b-451c-b300-0d1f845c01bb",
            "mapping_index": 7,
            "structured_type": "unstructured",
            "detail_level": "medium"
        },
        "timestamp": "2025-08-16 23:06:36.000",
        "id": "gb3oHD5HUD5rboPjhplt"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "97f32543-125b-451c-b300-0d1f845c01bb",
            "detail_level": "medium",
            "structured_type": "unstructured"
        },
        "timestamp": "2025-08-16 23:06:36.000",
        "id": "sJ8osRV5dvLI591FdAOK"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "97f32543-125b-451c-b300-0d1f845c01bb",
            "detail_level": "medium",
            "structured_type": "unstructured"
        },
        "timestamp": "2025-08-16 23:06:36.000",
        "id": "wGggiQd9THhR7UKP5pwv"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "97f32543-125b-451c-b300-0d1f845c01bb",
            "mapping_index": 0,
            "structured_type": "unstructured",
            "detail_level": "medium"
        },
        "timestamp": "2025-08-16 23:06:37.000",
        "id": "1fXVMVaOQrw6ZZ3vDqDJ"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "97f32543-125b-451c-b300-0d1f845c01bb",
            "detail_level": "medium",
            "structured_type": "unstructured"
        },
        "timestamp": "2025-08-16 23:06:37.000",
        "id": "CEsu9ITM20zOqvZQtTBp"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "97f32543-125b-451c-b300-0d1f845c01bb",
            "detail_level": "medium",
            "structured_type": "unstructured"
        },
        "timestamp": "2025-08-16 23:06:37.000",
        "id": "LUdQir0ENlppxdNYTv0b"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "97f32543-125b-451c-b300-0d1f845c01bb",
            "detail_level": "medium",
            "structured_type": "unstructured"
        },
        "timestamp": "2025-08-16 23:06:37.000",
        "id": "LeLPvIgIkgGHJ4eOzg3i"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "97f32543-125b-451c-b300-0d1f845c01bb",
            "mapping_index": 1,
            "structured_type": "unstructured",
            "detail_level": "medium"
        },
        "timestamp": "2025-08-16 23:06:37.000",
        "id": "MYvwQOtaEVHLLSwM33cf"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "97f32543-125b-451c-b300-0d1f845c01bb",
            "detail_level": "medium",
            "structured_type": "unstructured"
        },
        "timestamp": "2025-08-16 23:06:37.000",
        "id": "kUmCmI4bXlpBFlS28pfD"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "97f32543-125b-451c-b300-0d1f845c01bb",
            "mapping_index": 4,
            "structured_type": "unstructured",
            "detail_level": "medium"
        },
        "timestamp": "2025-08-16 23:06:37.000",
        "id": "qWCjI6XDOl9F6txIpmTl"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "97f32543-125b-451c-b300-0d1f845c01bb",
            "mapping_index": 7,
            "structured_type": "unstructured",
            "detail_level": "medium"
        },
        "timestamp": "2025-08-16 23:06:45.000",
        "id": "I8vCqIeVAXWFIX5FglKk"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "97f32543-125b-451c-b300-0d1f845c01bb",
            "mapping_index": 1,
            "structured_type": "unstructured",
            "detail_level": "medium"
        },
        "timestamp": "2025-08-16 23:06:45.000",
        "id": "c1JTSewKKCarxaGBZpz9"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "97f32543-125b-451c-b300-0d1f845c01bb",
            "detail_level": "medium",
            "structured_type": "unstructured"
        },
        "timestamp": "2025-08-16 23:06:45.000",
        "id": "lYjY0UxSmt5yYfexYO9N"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "97f32543-125b-451c-b300-0d1f845c01bb",
            "detail_level": "medium",
            "structured_type": "unstructured"
        },
        "timestamp": "2025-08-16 23:06:45.000",
        "id": "tH3eUPnCAUFsOK9i2agQ"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "97f32543-125b-451c-b300-0d1f845c01bb",
            "mapping_index": 3,
            "structured_type": "unstructured",
            "detail_level": "medium"
        },
        "timestamp": "2025-08-16 23:06:45.000",
        "id": "z5BA8GbZmD1OwnqFXLJa"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "97f32543-125b-451c-b300-0d1f845c01bb",
            "detail_level": "medium",
            "structured_type": "unstructured"
        },
        "timestamp": "2025-08-16 23:06:46.000",
        "id": "2kbNWcD4VC1JDHwZr9TS"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "97f32543-125b-451c-b300-0d1f845c01bb",
            "mapping_index": 4,
            "structured_type": "unstructured",
            "detail_level": "medium"
        },
        "timestamp": "2025-08-16 23:06:46.000",
        "id": "D2g3o9ZB9dd1bfo1NeRD"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "97f32543-125b-451c-b300-0d1f845c01bb",
            "mapping_index": 4,
            "structured_type": "unstructured",
            "detail_level": "medium"
        },
        "timestamp": "2025-08-16 23:06:46.000",
        "id": "LXheJSLhOJKpsn2I9tmS"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "97f32543-125b-451c-b300-0d1f845c01bb",
            "detail_level": "medium",
            "structured_type": "unstructured"
        },
        "timestamp": "2025-08-16 23:06:46.000",
        "id": "amPpXlWjxwKAZLzYb8tH"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "97f32543-125b-451c-b300-0d1f845c01bb",
            "mapping_index": 4,
            "structured_type": "unstructured",
            "detail_level": "medium"
        },
        "timestamp": "2025-08-16 23:06:46.000",
        "id": "d7wkreTaejnibe0s6GBB"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "97f32543-125b-451c-b300-0d1f845c01bb",
            "detail_level": "medium",
            "structured_type": "unstructured"
        },
        "timestamp": "2025-08-16 23:06:46.000",
        "id": "dfGM7ebJOgHTiBZG9Eun"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "97f32543-125b-451c-b300-0d1f845c01bb",
            "detail_level": "medium",
            "structured_type": "unstructured"
        },
        "timestamp": "2025-08-16 23:06:46.000",
        "id": "gbrrbDLIcElW8qodnKPa"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "97f32543-125b-451c-b300-0d1f845c01bb",
            "mapping_index": 1,
            "structured_type": "unstructured",
            "detail_level": "medium"
        },
        "timestamp": "2025-08-16 23:06:46.000",
        "id": "wyoF9fijB1QUUb1bAGhz"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "97f32543-125b-451c-b300-0d1f845c01bb",
            "detail_level": "medium",
            "structured_type": "unstructured"
        },
        "timestamp": "2025-08-16 23:06:46.000",
        "id": "zaNXaYNmHIMUHY0P2eVT"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "97f32543-125b-451c-b300-0d1f845c01bb",
            "detail_level": "medium",
            "structured_type": "unstructured"
        },
        "timestamp": "2025-08-16 23:07:17.000",
        "id": "4BpmBjl8UYZzDqAG7lwk"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "97f32543-125b-451c-b300-0d1f845c01bb",
            "detail_level": "medium",
            "structured_type": "unstructured"
        },
        "timestamp": "2025-08-16 23:07:17.000",
        "id": "Q5GpBxwMQfoGQQ8E1l7f"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "97f32543-125b-451c-b300-0d1f845c01bb",
            "mapping_index": 0,
            "structured_type": "unstructured",
            "detail_level": "medium"
        },
        "timestamp": "2025-08-16 23:07:17.000",
        "id": "R3xAnA59pgwWODqgjGFr"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "97f32543-125b-451c-b300-0d1f845c01bb",
            "detail_level": "medium",
            "structured_type": "unstructured"
        },
        "timestamp": "2025-08-16 23:07:17.000",
        "id": "VXPBnpprBI6voUvvbV3R"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "97f32543-125b-451c-b300-0d1f845c01bb",
            "mapping_index": 3,
            "structured_type": "unstructured",
            "detail_level": "medium"
        },
        "timestamp": "2025-08-16 23:07:17.000",
        "id": "jVM5H3KaIpuSXsOXRrJC"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "97f32543-125b-451c-b300-0d1f845c01bb",
            "mapping_index": 7,
            "structured_type": "unstructured",
            "detail_level": "medium"
        },
        "timestamp": "2025-08-16 23:07:17.000",
        "id": "mTQmKppt5H1rDwhSGBjq"
    },
    {
        "source": "frontend",
        "event": "change_summary_level",
        "data": {
            "before_detail_level": "medium",
            "section_id": "97f32543-125b-451c-b300-0d1f845c01bb",
            "before_structured": "unstructured",
            "after_structured": "unstructured",
            "after_detail_level": "high"
        },
        "timestamp": "2025-08-16 23:07:18.000",
        "id": "JPF9pcvPtiOrONHTtmm2"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "97f32543-125b-451c-b300-0d1f845c01bb",
            "mapping_index": 0,
            "structured_type": "unstructured",
            "detail_level": "high"
        },
        "timestamp": "2025-08-16 23:07:19.000",
        "id": "Ys4k888WDZ9eRBqxA7D6"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "97f32543-125b-451c-b300-0d1f845c01bb",
            "detail_level": "high",
            "structured_type": "unstructured"
        },
        "timestamp": "2025-08-16 23:07:20.000",
        "id": "9MlfPxZFwCqpjU5zdEWs"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "97f32543-125b-451c-b300-0d1f845c01bb",
            "detail_level": "high",
            "structured_type": "unstructured"
        },
        "timestamp": "2025-08-16 23:07:20.000",
        "id": "Bd4vmiUB0qsWZsVhnIvp"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "97f32543-125b-451c-b300-0d1f845c01bb",
            "detail_level": "high",
            "structured_type": "unstructured"
        },
        "timestamp": "2025-08-16 23:07:20.000",
        "id": "BxxJYkG73TREMbnNxwCd"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "97f32543-125b-451c-b300-0d1f845c01bb",
            "mapping_index": 4,
            "structured_type": "unstructured",
            "detail_level": "high"
        },
        "timestamp": "2025-08-16 23:07:20.000",
        "id": "ELdHoYOuaGpMnKB1kFzD"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "97f32543-125b-451c-b300-0d1f845c01bb",
            "mapping_index": 1,
            "structured_type": "unstructured",
            "detail_level": "high"
        },
        "timestamp": "2025-08-16 23:07:20.000",
        "id": "ELmdudDAMAmJNL3Em2ew"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "97f32543-125b-451c-b300-0d1f845c01bb",
            "mapping_index": 5,
            "structured_type": "unstructured",
            "detail_level": "high"
        },
        "timestamp": "2025-08-16 23:07:20.000",
        "id": "JFQwxSrHVn2MwE5TF7SB"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "97f32543-125b-451c-b300-0d1f845c01bb",
            "mapping_index": 5,
            "structured_type": "unstructured",
            "detail_level": "high"
        },
        "timestamp": "2025-08-16 23:07:20.000",
        "id": "MrBVIJJqxFlO0RDZJM9w"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "97f32543-125b-451c-b300-0d1f845c01bb",
            "detail_level": "high",
            "structured_type": "unstructured"
        },
        "timestamp": "2025-08-16 23:07:20.000",
        "id": "POnQdBNbmQbjxdUtOBjY"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "97f32543-125b-451c-b300-0d1f845c01bb",
            "mapping_index": 5,
            "structured_type": "unstructured",
            "detail_level": "high"
        },
        "timestamp": "2025-08-16 23:07:20.000",
        "id": "TydJHFMjeRFlxrcupETH"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "97f32543-125b-451c-b300-0d1f845c01bb",
            "mapping_index": 4,
            "structured_type": "unstructured",
            "detail_level": "high"
        },
        "timestamp": "2025-08-16 23:07:20.000",
        "id": "VZAdUI3XGkWoNeOuTVDo"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "97f32543-125b-451c-b300-0d1f845c01bb",
            "detail_level": "high",
            "structured_type": "unstructured"
        },
        "timestamp": "2025-08-16 23:07:20.000",
        "id": "XLjLVQv4DR3VgI3hjlMc"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "97f32543-125b-451c-b300-0d1f845c01bb",
            "mapping_index": 5,
            "structured_type": "unstructured",
            "detail_level": "high"
        },
        "timestamp": "2025-08-16 23:07:20.000",
        "id": "ZyNZYBjIxRj7u4EUYReX"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "97f32543-125b-451c-b300-0d1f845c01bb",
            "mapping_index": 4,
            "structured_type": "unstructured",
            "detail_level": "high"
        },
        "timestamp": "2025-08-16 23:07:20.000",
        "id": "aoGzEqwyKvdHjamKk6OO"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "97f32543-125b-451c-b300-0d1f845c01bb",
            "mapping_index": 1,
            "structured_type": "unstructured",
            "detail_level": "high"
        },
        "timestamp": "2025-08-16 23:07:20.000",
        "id": "avpjzMj2lqo2sbZgIjFY"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "97f32543-125b-451c-b300-0d1f845c01bb",
            "mapping_index": 2,
            "structured_type": "unstructured",
            "detail_level": "high"
        },
        "timestamp": "2025-08-16 23:07:20.000",
        "id": "bVYh56n8LPHK5CenP0HJ"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "97f32543-125b-451c-b300-0d1f845c01bb",
            "mapping_index": 0,
            "structured_type": "unstructured",
            "detail_level": "high"
        },
        "timestamp": "2025-08-16 23:07:20.000",
        "id": "bt2SxHii2VKqTO31KMlA"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "97f32543-125b-451c-b300-0d1f845c01bb",
            "mapping_index": 1,
            "structured_type": "unstructured",
            "detail_level": "high"
        },
        "timestamp": "2025-08-16 23:07:20.000",
        "id": "dbrLVkGIbD6rn7WvAIyB"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "97f32543-125b-451c-b300-0d1f845c01bb",
            "mapping_index": 4,
            "structured_type": "unstructured",
            "detail_level": "high"
        },
        "timestamp": "2025-08-16 23:07:20.000",
        "id": "dcoO4ApwJatP4F27PvGc"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "97f32543-125b-451c-b300-0d1f845c01bb",
            "detail_level": "high",
            "structured_type": "unstructured"
        },
        "timestamp": "2025-08-16 23:07:20.000",
        "id": "e7lVtfme0MvxCQJFzbXg"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "97f32543-125b-451c-b300-0d1f845c01bb",
            "detail_level": "high",
            "structured_type": "unstructured"
        },
        "timestamp": "2025-08-16 23:07:20.000",
        "id": "h81Oruk75i9CdxuEdAOt"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "97f32543-125b-451c-b300-0d1f845c01bb",
            "detail_level": "high",
            "structured_type": "unstructured"
        },
        "timestamp": "2025-08-16 23:07:20.000",
        "id": "ildFGXNYCfMm4vva0o5T"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "97f32543-125b-451c-b300-0d1f845c01bb",
            "detail_level": "high",
            "structured_type": "unstructured"
        },
        "timestamp": "2025-08-16 23:07:20.000",
        "id": "jToBku1HacCTEXOfbCmT"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "97f32543-125b-451c-b300-0d1f845c01bb",
            "detail_level": "high",
            "structured_type": "unstructured"
        },
        "timestamp": "2025-08-16 23:07:20.000",
        "id": "juOsKvwYiyhORTHKZTvO"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "97f32543-125b-451c-b300-0d1f845c01bb",
            "mapping_index": 0,
            "structured_type": "unstructured",
            "detail_level": "high"
        },
        "timestamp": "2025-08-16 23:07:20.000",
        "id": "mRZ9qKDBq4oYtM6v6kkl"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "97f32543-125b-451c-b300-0d1f845c01bb",
            "detail_level": "high",
            "structured_type": "unstructured"
        },
        "timestamp": "2025-08-16 23:07:20.000",
        "id": "n9zt86hEu4fMXdcSkf8Q"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "97f32543-125b-451c-b300-0d1f845c01bb",
            "detail_level": "high",
            "structured_type": "unstructured"
        },
        "timestamp": "2025-08-16 23:07:20.000",
        "id": "tuHy9oMGQ8XBLHTxmjWO"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "97f32543-125b-451c-b300-0d1f845c01bb",
            "detail_level": "high",
            "structured_type": "unstructured"
        },
        "timestamp": "2025-08-16 23:07:20.000",
        "id": "xAIvf0GsiDI6yI3nQoi6"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "97f32543-125b-451c-b300-0d1f845c01bb",
            "detail_level": "high",
            "structured_type": "unstructured"
        },
        "timestamp": "2025-08-16 23:07:20.000",
        "id": "zy3WWKmOV8LYuT0zden7"
    },
    {
        "source": "frontend",
        "event": "change_summary_level",
        "data": {
            "before_detail_level": "high",
            "section_id": "97f32543-125b-451c-b300-0d1f845c01bb",
            "before_structured": "unstructured",
            "after_structured": "unstructured",
            "after_detail_level": "medium"
        },
        "timestamp": "2025-08-16 23:07:21.000",
        "id": "FnezoOtZQKJTFe1uHPYQ"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "97f32543-125b-451c-b300-0d1f845c01bb",
            "detail_level": "high",
            "structured_type": "unstructured"
        },
        "timestamp": "2025-08-16 23:07:21.000",
        "id": "btfm5Mb1SenO7tLEntTJ"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "97f32543-125b-451c-b300-0d1f845c01bb",
            "detail_level": "medium",
            "structured_type": "unstructured"
        },
        "timestamp": "2025-08-16 23:07:22.000",
        "id": "6F6BMdNhjhO8iuGjoeIy"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "97f32543-125b-451c-b300-0d1f845c01bb",
            "mapping_index": 0,
            "structured_type": "unstructured",
            "detail_level": "medium"
        },
        "timestamp": "2025-08-16 23:07:22.000",
        "id": "BlbXKYZFZ3mUjWX1NIJX"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "97f32543-125b-451c-b300-0d1f845c01bb",
            "detail_level": "medium",
            "structured_type": "unstructured"
        },
        "timestamp": "2025-08-16 23:07:22.000",
        "id": "LAnOXD25zvchfAnBwQ2X"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "97f32543-125b-451c-b300-0d1f845c01bb",
            "detail_level": "medium",
            "structured_type": "unstructured"
        },
        "timestamp": "2025-08-16 23:07:22.000",
        "id": "MPucMlPjwFkxXKZHmWzd"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "97f32543-125b-451c-b300-0d1f845c01bb",
            "mapping_index": 5,
            "structured_type": "unstructured",
            "detail_level": "medium"
        },
        "timestamp": "2025-08-16 23:07:22.000",
        "id": "XiiMXSEV1FSNqD9LsRmk"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "97f32543-125b-451c-b300-0d1f845c01bb",
            "mapping_index": 7,
            "structured_type": "unstructured",
            "detail_level": "medium"
        },
        "timestamp": "2025-08-16 23:07:22.000",
        "id": "bapO7au9O6jhqxByNYVW"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "97f32543-125b-451c-b300-0d1f845c01bb",
            "detail_level": "medium",
            "structured_type": "unstructured"
        },
        "timestamp": "2025-08-16 23:07:22.000",
        "id": "lSK4jgQARtACLUlwcMEI"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "97f32543-125b-451c-b300-0d1f845c01bb",
            "mapping_index": 3,
            "structured_type": "unstructured",
            "detail_level": "medium"
        },
        "timestamp": "2025-08-16 23:07:22.000",
        "id": "ysMVTqZbAo5bEhYRZTQD"
    },
    {
        "source": "frontend",
        "event": "change_summary_level",
        "data": {
            "before_detail_level": "medium",
            "section_id": "97f32543-125b-451c-b300-0d1f845c01bb",
            "before_structured": "unstructured",
            "after_structured": "unstructured",
            "after_detail_level": "high"
        },
        "timestamp": "2025-08-16 23:07:25.000",
        "id": "9FBj8Bz0ATvgr0ycq2xh"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "97f32543-125b-451c-b300-0d1f845c01bb",
            "mapping_index": 1,
            "structured_type": "unstructured",
            "detail_level": "high"
        },
        "timestamp": "2025-08-16 23:07:26.000",
        "id": "4a3A8bdmt9GMAEzURryI"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "97f32543-125b-451c-b300-0d1f845c01bb",
            "detail_level": "high",
            "structured_type": "unstructured"
        },
        "timestamp": "2025-08-16 23:07:26.000",
        "id": "Zry3EJoAED89Vg1szjDI"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "97f32543-125b-451c-b300-0d1f845c01bb",
            "detail_level": "high",
            "structured_type": "unstructured"
        },
        "timestamp": "2025-08-16 23:07:26.000",
        "id": "hOATzfXslXAqreMWKPQj"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "97f32543-125b-451c-b300-0d1f845c01bb",
            "detail_level": "high",
            "structured_type": "unstructured"
        },
        "timestamp": "2025-08-16 23:07:26.000",
        "id": "ll38aUmnoGRkk3v0YbhJ"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "97f32543-125b-451c-b300-0d1f845c01bb",
            "mapping_index": 4,
            "structured_type": "unstructured",
            "detail_level": "high"
        },
        "timestamp": "2025-08-16 23:07:26.000",
        "id": "mamrpZQugZ94ApQ16gUh"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "97f32543-125b-451c-b300-0d1f845c01bb",
            "detail_level": "high",
            "structured_type": "unstructured"
        },
        "timestamp": "2025-08-16 23:07:26.000",
        "id": "wKNtPGxZJJRiZI7509I2"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "97f32543-125b-451c-b300-0d1f845c01bb",
            "mapping_index": 0,
            "structured_type": "unstructured",
            "detail_level": "high"
        },
        "timestamp": "2025-08-16 23:07:26.000",
        "id": "xeBQ2jDeghafCjvldgwc"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "97f32543-125b-451c-b300-0d1f845c01bb",
            "mapping_index": 5,
            "structured_type": "unstructured",
            "detail_level": "high"
        },
        "timestamp": "2025-08-16 23:07:26.000",
        "id": "zei4vfGF3vMkKp0C65CK"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "97f32543-125b-451c-b300-0d1f845c01bb",
            "detail_level": "high",
            "structured_type": "unstructured"
        },
        "timestamp": "2025-08-16 23:07:28.000",
        "id": "0N81ygcXbuijq03v3mBo"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "97f32543-125b-451c-b300-0d1f845c01bb",
            "detail_level": "high",
            "structured_type": "unstructured"
        },
        "timestamp": "2025-08-16 23:07:28.000",
        "id": "7GQH6TLNfCqm0ixtCz4J"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "97f32543-125b-451c-b300-0d1f845c01bb",
            "mapping_index": 1,
            "structured_type": "unstructured",
            "detail_level": "high"
        },
        "timestamp": "2025-08-16 23:07:28.000",
        "id": "DAkkf3PQDyabZ4RhJn5w"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "97f32543-125b-451c-b300-0d1f845c01bb",
            "mapping_index": 0,
            "structured_type": "unstructured",
            "detail_level": "high"
        },
        "timestamp": "2025-08-16 23:07:28.000",
        "id": "GX8eYDZPuOdK11lMTQYc"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "97f32543-125b-451c-b300-0d1f845c01bb",
            "mapping_index": 4,
            "structured_type": "unstructured",
            "detail_level": "high"
        },
        "timestamp": "2025-08-16 23:07:28.000",
        "id": "HjltQoQbsjpJQx0JNgPc"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "97f32543-125b-451c-b300-0d1f845c01bb",
            "detail_level": "high",
            "structured_type": "unstructured"
        },
        "timestamp": "2025-08-16 23:07:28.000",
        "id": "UU1RlOoYUZErbWmnmT7i"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "97f32543-125b-451c-b300-0d1f845c01bb",
            "mapping_index": 5,
            "structured_type": "unstructured",
            "detail_level": "high"
        },
        "timestamp": "2025-08-16 23:07:28.000",
        "id": "YCM4UGZH1lGKRZPgEaJL"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "97f32543-125b-451c-b300-0d1f845c01bb",
            "mapping_index": 3,
            "structured_type": "unstructured",
            "detail_level": "high"
        },
        "timestamp": "2025-08-16 23:07:28.000",
        "id": "YHpfBBej3WX2jckdtA4h"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "97f32543-125b-451c-b300-0d1f845c01bb",
            "mapping_index": 4,
            "structured_type": "unstructured",
            "detail_level": "high"
        },
        "timestamp": "2025-08-16 23:07:28.000",
        "id": "gV1YjJ2ug0xWQHt1RcjF"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "97f32543-125b-451c-b300-0d1f845c01bb",
            "detail_level": "high",
            "structured_type": "unstructured"
        },
        "timestamp": "2025-08-16 23:07:28.000",
        "id": "jL9GoByVS7fETsGFRAwz"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "97f32543-125b-451c-b300-0d1f845c01bb",
            "detail_level": "high",
            "structured_type": "unstructured"
        },
        "timestamp": "2025-08-16 23:07:28.000",
        "id": "mZ9A7bVkktLeAM3vwshh"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "97f32543-125b-451c-b300-0d1f845c01bb",
            "mapping_index": 3,
            "structured_type": "unstructured",
            "detail_level": "high"
        },
        "timestamp": "2025-08-16 23:07:28.000",
        "id": "nDnsEBmCsDKTXXIC8QpX"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "97f32543-125b-451c-b300-0d1f845c01bb",
            "detail_level": "high",
            "structured_type": "unstructured"
        },
        "timestamp": "2025-08-16 23:07:28.000",
        "id": "phuFjuOAVi8w1yWsqUTg"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "97f32543-125b-451c-b300-0d1f845c01bb",
            "detail_level": "high",
            "structured_type": "unstructured"
        },
        "timestamp": "2025-08-16 23:07:28.000",
        "id": "rjXio5SZneQ3ufniFmKG"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "97f32543-125b-451c-b300-0d1f845c01bb",
            "mapping_index": 7,
            "structured_type": "unstructured",
            "detail_level": "high"
        },
        "timestamp": "2025-08-16 23:07:28.000",
        "id": "sWA2Qr8sQFWbBWTI7JvX"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "97f32543-125b-451c-b300-0d1f845c01bb",
            "detail_level": "high",
            "structured_type": "unstructured"
        },
        "timestamp": "2025-08-16 23:07:28.000",
        "id": "tqjCUGbc2f2x32Yh5VVR"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "97f32543-125b-451c-b300-0d1f845c01bb",
            "mapping_index": 2,
            "structured_type": "unstructured",
            "detail_level": "high"
        },
        "timestamp": "2025-08-16 23:07:28.000",
        "id": "wzgCPn3pvrmKlZlDB0S6"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "97f32543-125b-451c-b300-0d1f845c01bb",
            "detail_level": "high",
            "structured_type": "unstructured"
        },
        "timestamp": "2025-08-16 23:07:29.000",
        "id": "ALeZLTkjlwxs0RIotMAB"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "97f32543-125b-451c-b300-0d1f845c01bb",
            "detail_level": "high",
            "structured_type": "unstructured"
        },
        "timestamp": "2025-08-16 23:07:29.000",
        "id": "QmH5WzbgtMXOw4Ddn76d"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "97f32543-125b-451c-b300-0d1f845c01bb",
            "mapping_index": 0,
            "structured_type": "unstructured",
            "detail_level": "high"
        },
        "timestamp": "2025-08-16 23:07:29.000",
        "id": "WzsEEch7ekQxcFCwYeDn"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "97f32543-125b-451c-b300-0d1f845c01bb",
            "detail_level": "high",
            "structured_type": "unstructured"
        },
        "timestamp": "2025-08-16 23:07:30.000",
        "id": "LT08RA5GMmdjaVoOkSp6"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "97f32543-125b-451c-b300-0d1f845c01bb",
            "detail_level": "high",
            "structured_type": "unstructured"
        },
        "timestamp": "2025-08-16 23:07:30.000",
        "id": "RWE7E0U9fsgEm0vVPaMr"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "97f32543-125b-451c-b300-0d1f845c01bb",
            "mapping_index": 0,
            "structured_type": "unstructured",
            "detail_level": "high"
        },
        "timestamp": "2025-08-16 23:07:30.000",
        "id": "cQZfmGzIS1pSvAxalujX"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "97f32543-125b-451c-b300-0d1f845c01bb",
            "mapping_index": 3,
            "structured_type": "unstructured",
            "detail_level": "high"
        },
        "timestamp": "2025-08-16 23:07:30.000",
        "id": "kJu19J3z3kckDLcAJ6cQ"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "97f32543-125b-451c-b300-0d1f845c01bb",
            "mapping_index": 0,
            "structured_type": "unstructured",
            "detail_level": "high"
        },
        "timestamp": "2025-08-16 23:07:30.000",
        "id": "y0D3i1atykurvFD5UvT6"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "97f32543-125b-451c-b300-0d1f845c01bb",
            "mapping_index": 1,
            "structured_type": "unstructured",
            "detail_level": "high"
        },
        "timestamp": "2025-08-16 23:07:32.000",
        "id": "0WAn3GbS5Im5PMgvqQZg"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "97f32543-125b-451c-b300-0d1f845c01bb",
            "mapping_index": 3,
            "structured_type": "unstructured",
            "detail_level": "high"
        },
        "timestamp": "2025-08-16 23:07:32.000",
        "id": "10QnXzoKS6IP5T9Ikx0G"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "97f32543-125b-451c-b300-0d1f845c01bb",
            "detail_level": "high",
            "structured_type": "unstructured"
        },
        "timestamp": "2025-08-16 23:07:32.000",
        "id": "1BzRgIhLDB30FKmhcDb5"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "97f32543-125b-451c-b300-0d1f845c01bb",
            "detail_level": "high",
            "structured_type": "unstructured"
        },
        "timestamp": "2025-08-16 23:07:32.000",
        "id": "28xx0XB1QYLBGdskPaDl"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "97f32543-125b-451c-b300-0d1f845c01bb",
            "detail_level": "high",
            "structured_type": "unstructured"
        },
        "timestamp": "2025-08-16 23:07:32.000",
        "id": "5tEbTF0mXEkmmayIL4xU"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "97f32543-125b-451c-b300-0d1f845c01bb",
            "mapping_index": 0,
            "structured_type": "unstructured",
            "detail_level": "high"
        },
        "timestamp": "2025-08-16 23:07:32.000",
        "id": "Clcn5DM8Fr4lqQoDsJH1"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "97f32543-125b-451c-b300-0d1f845c01bb",
            "detail_level": "high",
            "structured_type": "unstructured"
        },
        "timestamp": "2025-08-16 23:07:32.000",
        "id": "GMYFNREuJItYlEbY9e7Z"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "97f32543-125b-451c-b300-0d1f845c01bb",
            "mapping_index": 0,
            "structured_type": "unstructured",
            "detail_level": "high"
        },
        "timestamp": "2025-08-16 23:07:32.000",
        "id": "PiXMsLFoIX1UzFs7pIwm"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "97f32543-125b-451c-b300-0d1f845c01bb",
            "detail_level": "high",
            "structured_type": "unstructured"
        },
        "timestamp": "2025-08-16 23:07:32.000",
        "id": "TdUhipVueI63oKWNGy92"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "97f32543-125b-451c-b300-0d1f845c01bb",
            "detail_level": "high",
            "structured_type": "unstructured"
        },
        "timestamp": "2025-08-16 23:07:32.000",
        "id": "UdS8OUeO3i9IN2ZoZoqu"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "97f32543-125b-451c-b300-0d1f845c01bb",
            "mapping_index": 4,
            "structured_type": "unstructured",
            "detail_level": "high"
        },
        "timestamp": "2025-08-16 23:07:32.000",
        "id": "UlXBzN0AP2YRUTGXcqAd"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "97f32543-125b-451c-b300-0d1f845c01bb",
            "mapping_index": 5,
            "structured_type": "unstructured",
            "detail_level": "high"
        },
        "timestamp": "2025-08-16 23:07:32.000",
        "id": "WfOUYRn1ZQpDT9toWBGi"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "97f32543-125b-451c-b300-0d1f845c01bb",
            "detail_level": "high",
            "structured_type": "unstructured"
        },
        "timestamp": "2025-08-16 23:07:32.000",
        "id": "eQLwieF7vioFS9MesXFj"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "97f32543-125b-451c-b300-0d1f845c01bb",
            "mapping_index": 1,
            "structured_type": "unstructured",
            "detail_level": "high"
        },
        "timestamp": "2025-08-16 23:07:32.000",
        "id": "fOLFaCWc25GLKk3S7xDw"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "97f32543-125b-451c-b300-0d1f845c01bb",
            "mapping_index": 0,
            "structured_type": "unstructured",
            "detail_level": "high"
        },
        "timestamp": "2025-08-16 23:07:32.000",
        "id": "lfZPSCyJWsKcRzsOlGKb"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "97f32543-125b-451c-b300-0d1f845c01bb",
            "detail_level": "high",
            "structured_type": "unstructured"
        },
        "timestamp": "2025-08-16 23:07:32.000",
        "id": "loqiIWvVYi69GuwIDfla"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "97f32543-125b-451c-b300-0d1f845c01bb",
            "detail_level": "high",
            "structured_type": "unstructured"
        },
        "timestamp": "2025-08-16 23:07:32.000",
        "id": "uZUM2640BEHNChe7xuGG"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "97f32543-125b-451c-b300-0d1f845c01bb",
            "mapping_index": 1,
            "structured_type": "unstructured",
            "detail_level": "high"
        },
        "timestamp": "2025-08-16 23:07:32.000",
        "id": "vCn2ycunW6s5OQsQi2w4"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "97f32543-125b-451c-b300-0d1f845c01bb",
            "detail_level": "high",
            "structured_type": "unstructured"
        },
        "timestamp": "2025-08-16 23:07:33.000",
        "id": "5zUd1e7XOitmz3V9c0gM"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "97f32543-125b-451c-b300-0d1f845c01bb",
            "detail_level": "high",
            "structured_type": "unstructured"
        },
        "timestamp": "2025-08-16 23:07:33.000",
        "id": "DczTwuVRDTcreN37pNQs"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "97f32543-125b-451c-b300-0d1f845c01bb",
            "detail_level": "high",
            "structured_type": "unstructured"
        },
        "timestamp": "2025-08-16 23:07:33.000",
        "id": "Z4pwCNI4If6nDWkmROa6"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "97f32543-125b-451c-b300-0d1f845c01bb",
            "mapping_index": 1,
            "structured_type": "unstructured",
            "detail_level": "high"
        },
        "timestamp": "2025-08-16 23:07:33.000",
        "id": "cgF1SBaeRGJy46A1cPU1"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "97f32543-125b-451c-b300-0d1f845c01bb",
            "mapping_index": 0,
            "structured_type": "unstructured",
            "detail_level": "high"
        },
        "timestamp": "2025-08-16 23:07:33.000",
        "id": "eQ7G9JrGsJTe1j45sMc2"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "97f32543-125b-451c-b300-0d1f845c01bb",
            "mapping_index": 3,
            "structured_type": "unstructured",
            "detail_level": "high"
        },
        "timestamp": "2025-08-16 23:07:33.000",
        "id": "fbGqPGVUyKuNLHfcAjMf"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "97f32543-125b-451c-b300-0d1f845c01bb",
            "mapping_index": 0,
            "structured_type": "unstructured",
            "detail_level": "high"
        },
        "timestamp": "2025-08-16 23:07:33.000",
        "id": "n95SVkBojs7ysPB7g6N3"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "97f32543-125b-451c-b300-0d1f845c01bb",
            "detail_level": "high",
            "structured_type": "unstructured"
        },
        "timestamp": "2025-08-16 23:07:33.000",
        "id": "zQhWxJcGS1iKu7sbjWAh"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "97f32543-125b-451c-b300-0d1f845c01bb",
            "mapping_index": 2,
            "structured_type": "unstructured",
            "detail_level": "high"
        },
        "timestamp": "2025-08-16 23:07:34.000",
        "id": "73NUgv5sZrlY7UPoxxUe"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "97f32543-125b-451c-b300-0d1f845c01bb",
            "detail_level": "high",
            "structured_type": "unstructured"
        },
        "timestamp": "2025-08-16 23:07:34.000",
        "id": "TjsJuUXwVGdk0Yrqt93C"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "97f32543-125b-451c-b300-0d1f845c01bb",
            "mapping_index": 0,
            "structured_type": "unstructured",
            "detail_level": "high"
        },
        "timestamp": "2025-08-16 23:07:34.000",
        "id": "XAd0Ra7pVuexCBXqcxUL"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "97f32543-125b-451c-b300-0d1f845c01bb",
            "detail_level": "high",
            "structured_type": "unstructured"
        },
        "timestamp": "2025-08-16 23:07:34.000",
        "id": "dLnylWIwCS9EvyaHe2yg"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "97f32543-125b-451c-b300-0d1f845c01bb",
            "detail_level": "high",
            "structured_type": "unstructured"
        },
        "timestamp": "2025-08-16 23:07:34.000",
        "id": "s1Fl3sqgl8dgoPrytk5a"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "97f32543-125b-451c-b300-0d1f845c01bb",
            "mapping_index": 1,
            "structured_type": "unstructured",
            "detail_level": "high"
        },
        "timestamp": "2025-08-16 23:07:34.000",
        "id": "uBenYPZpMz2IOxepMjhW"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "97f32543-125b-451c-b300-0d1f845c01bb",
            "detail_level": "high",
            "structured_type": "unstructured"
        },
        "timestamp": "2025-08-16 23:07:35.000",
        "id": "0l86fkefVDNSQR8FPUaB"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "97f32543-125b-451c-b300-0d1f845c01bb",
            "mapping_index": 3,
            "structured_type": "unstructured",
            "detail_level": "high"
        },
        "timestamp": "2025-08-16 23:07:35.000",
        "id": "6uKFs1DcR2yy7522lRQj"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "97f32543-125b-451c-b300-0d1f845c01bb",
            "detail_level": "high",
            "structured_type": "unstructured"
        },
        "timestamp": "2025-08-16 23:07:35.000",
        "id": "910VDVNky8FTwxT8BEWk"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "97f32543-125b-451c-b300-0d1f845c01bb",
            "detail_level": "high",
            "structured_type": "unstructured"
        },
        "timestamp": "2025-08-16 23:07:35.000",
        "id": "BXsR62VSxpgGjOxpeJMf"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "97f32543-125b-451c-b300-0d1f845c01bb",
            "mapping_index": 6,
            "structured_type": "unstructured",
            "detail_level": "high"
        },
        "timestamp": "2025-08-16 23:07:35.000",
        "id": "CKSZxE8UJg0rJqjJzDyL"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "97f32543-125b-451c-b300-0d1f845c01bb",
            "mapping_index": 4,
            "structured_type": "unstructured",
            "detail_level": "high"
        },
        "timestamp": "2025-08-16 23:07:35.000",
        "id": "I2L8sqZxbBPoowDHFWw8"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "97f32543-125b-451c-b300-0d1f845c01bb",
            "detail_level": "high",
            "structured_type": "unstructured"
        },
        "timestamp": "2025-08-16 23:07:35.000",
        "id": "JLJnQeMAMBqhcyTflUPj"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "97f32543-125b-451c-b300-0d1f845c01bb",
            "detail_level": "high",
            "structured_type": "unstructured"
        },
        "timestamp": "2025-08-16 23:07:35.000",
        "id": "RdVZJTYsTetWV3qu5e9f"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "97f32543-125b-451c-b300-0d1f845c01bb",
            "mapping_index": 1,
            "structured_type": "unstructured",
            "detail_level": "high"
        },
        "timestamp": "2025-08-16 23:07:35.000",
        "id": "UVtGZNFJr1ZzfJ36AJXM"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "97f32543-125b-451c-b300-0d1f845c01bb",
            "mapping_index": 2,
            "structured_type": "unstructured",
            "detail_level": "high"
        },
        "timestamp": "2025-08-16 23:07:35.000",
        "id": "uhGt6BxRdH0IgDueNYEQ"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "97f32543-125b-451c-b300-0d1f845c01bb",
            "detail_level": "high",
            "structured_type": "unstructured"
        },
        "timestamp": "2025-08-16 23:07:36.000",
        "id": "2MNY5NdfxqvxFdHonPRb"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "97f32543-125b-451c-b300-0d1f845c01bb",
            "detail_level": "high",
            "structured_type": "unstructured"
        },
        "timestamp": "2025-08-16 23:07:36.000",
        "id": "GO2jz8RTWaZg3LX5S4Kc"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "97f32543-125b-451c-b300-0d1f845c01bb",
            "mapping_index": 5,
            "structured_type": "unstructured",
            "detail_level": "high"
        },
        "timestamp": "2025-08-16 23:07:36.000",
        "id": "Pg4fJtyMt2F1ud8hxmQL"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "97f32543-125b-451c-b300-0d1f845c01bb",
            "detail_level": "high",
            "structured_type": "unstructured"
        },
        "timestamp": "2025-08-16 23:07:36.000",
        "id": "eGtQSep5qUjk4z714GpA"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "97f32543-125b-451c-b300-0d1f845c01bb",
            "mapping_index": 4,
            "structured_type": "unstructured",
            "detail_level": "high"
        },
        "timestamp": "2025-08-16 23:07:36.000",
        "id": "nsvW7xnXoqolLfN9zKQx"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "97f32543-125b-451c-b300-0d1f845c01bb",
            "mapping_index": 5,
            "structured_type": "unstructured",
            "detail_level": "high"
        },
        "timestamp": "2025-08-16 23:07:36.000",
        "id": "ycimbW5VmX2azuXdNHEt"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "97f32543-125b-451c-b300-0d1f845c01bb",
            "mapping_index": 5,
            "structured_type": "unstructured",
            "detail_level": "high"
        },
        "timestamp": "2025-08-16 23:07:37.000",
        "id": "3xPvruuterKhj2qz2MZg"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "97f32543-125b-451c-b300-0d1f845c01bb",
            "mapping_index": 1,
            "structured_type": "unstructured",
            "detail_level": "high"
        },
        "timestamp": "2025-08-16 23:07:37.000",
        "id": "An7t2rjOVJvruuJDLKtD"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "97f32543-125b-451c-b300-0d1f845c01bb",
            "detail_level": "high",
            "structured_type": "unstructured"
        },
        "timestamp": "2025-08-16 23:07:37.000",
        "id": "BUmD16x0sGuZt89YKY1e"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "97f32543-125b-451c-b300-0d1f845c01bb",
            "mapping_index": 0,
            "structured_type": "unstructured",
            "detail_level": "high"
        },
        "timestamp": "2025-08-16 23:07:37.000",
        "id": "MiaUy2KYrbvRh4imGDC2"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "97f32543-125b-451c-b300-0d1f845c01bb",
            "detail_level": "high",
            "structured_type": "unstructured"
        },
        "timestamp": "2025-08-16 23:07:37.000",
        "id": "Pcvp0pCVdYCqa9e1Gmnc"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "97f32543-125b-451c-b300-0d1f845c01bb",
            "detail_level": "high",
            "structured_type": "unstructured"
        },
        "timestamp": "2025-08-16 23:07:37.000",
        "id": "WGl19zpMaDBqAo6jLf9T"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "97f32543-125b-451c-b300-0d1f845c01bb",
            "mapping_index": 3,
            "structured_type": "unstructured",
            "detail_level": "high"
        },
        "timestamp": "2025-08-16 23:07:37.000",
        "id": "XVhleF2Bb5Br8QmUMXhq"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "97f32543-125b-451c-b300-0d1f845c01bb",
            "mapping_index": 0,
            "structured_type": "unstructured",
            "detail_level": "high"
        },
        "timestamp": "2025-08-16 23:07:37.000",
        "id": "bI8x2cxamTi39qYetSYZ"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "97f32543-125b-451c-b300-0d1f845c01bb",
            "mapping_index": 4,
            "structured_type": "unstructured",
            "detail_level": "high"
        },
        "timestamp": "2025-08-16 23:07:37.000",
        "id": "bP8olccoOKqKvOCezQ8O"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "97f32543-125b-451c-b300-0d1f845c01bb",
            "detail_level": "high",
            "structured_type": "unstructured"
        },
        "timestamp": "2025-08-16 23:07:37.000",
        "id": "d5KAiJBhTTusps5eOJFm"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "97f32543-125b-451c-b300-0d1f845c01bb",
            "detail_level": "high",
            "structured_type": "unstructured"
        },
        "timestamp": "2025-08-16 23:07:37.000",
        "id": "kEusyKI4SMH8V7bUAmKg"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "97f32543-125b-451c-b300-0d1f845c01bb",
            "detail_level": "high",
            "structured_type": "unstructured"
        },
        "timestamp": "2025-08-16 23:07:37.000",
        "id": "xDkJSPJSTXsC7uutmxz4"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "97f32543-125b-451c-b300-0d1f845c01bb",
            "mapping_index": 3,
            "structured_type": "unstructured",
            "detail_level": "high"
        },
        "timestamp": "2025-08-16 23:07:38.000",
        "id": "1iKMsGPXPkGXXluISAho"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "97f32543-125b-451c-b300-0d1f845c01bb",
            "detail_level": "high",
            "structured_type": "unstructured"
        },
        "timestamp": "2025-08-16 23:07:38.000",
        "id": "UHCb6EWzlrWNhv0LsS2P"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "97f32543-125b-451c-b300-0d1f845c01bb",
            "mapping_index": 4,
            "structured_type": "unstructured",
            "detail_level": "high"
        },
        "timestamp": "2025-08-16 23:07:38.000",
        "id": "jqMNv22KVXSo41vUDLEp"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "97f32543-125b-451c-b300-0d1f845c01bb",
            "detail_level": "high",
            "structured_type": "unstructured"
        },
        "timestamp": "2025-08-16 23:07:38.000",
        "id": "uCvpsZ2G1sCrg4oooai4"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "97f32543-125b-451c-b300-0d1f845c01bb",
            "mapping_index": 4,
            "structured_type": "unstructured",
            "detail_level": "high"
        },
        "timestamp": "2025-08-16 23:07:39.000",
        "id": "EVD548FBFUXRfgBdtZdy"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "97f32543-125b-451c-b300-0d1f845c01bb",
            "detail_level": "high",
            "structured_type": "unstructured"
        },
        "timestamp": "2025-08-16 23:07:39.000",
        "id": "EzYOD5DkDVicCLhJH18A"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "97f32543-125b-451c-b300-0d1f845c01bb",
            "mapping_index": 4,
            "structured_type": "unstructured",
            "detail_level": "high"
        },
        "timestamp": "2025-08-16 23:07:39.000",
        "id": "FsbMM29c6rjhIVz7dV0u"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "97f32543-125b-451c-b300-0d1f845c01bb",
            "mapping_index": 3,
            "structured_type": "unstructured",
            "detail_level": "high"
        },
        "timestamp": "2025-08-16 23:07:39.000",
        "id": "GNXM3Z1uXVeu0KwWKo6m"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "97f32543-125b-451c-b300-0d1f845c01bb",
            "detail_level": "high",
            "structured_type": "unstructured"
        },
        "timestamp": "2025-08-16 23:07:39.000",
        "id": "RYxB8KozyaXn2ikLRO1B"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "97f32543-125b-451c-b300-0d1f845c01bb",
            "mapping_index": 5,
            "structured_type": "unstructured",
            "detail_level": "high"
        },
        "timestamp": "2025-08-16 23:07:39.000",
        "id": "UhvBJUG3ax48lrGFpqwG"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "97f32543-125b-451c-b300-0d1f845c01bb",
            "detail_level": "high",
            "structured_type": "unstructured"
        },
        "timestamp": "2025-08-16 23:07:39.000",
        "id": "YxuLqYeHDdUVMPilS80d"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "97f32543-125b-451c-b300-0d1f845c01bb",
            "detail_level": "high",
            "structured_type": "unstructured"
        },
        "timestamp": "2025-08-16 23:07:39.000",
        "id": "ilfUzfxaA1mf4w3v7V3O"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "97f32543-125b-451c-b300-0d1f845c01bb",
            "mapping_index": 1,
            "structured_type": "unstructured",
            "detail_level": "high"
        },
        "timestamp": "2025-08-16 23:07:44.000",
        "id": "JP8xkSZyXxg8lqtB1RmK"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "97f32543-125b-451c-b300-0d1f845c01bb",
            "detail_level": "high",
            "structured_type": "unstructured"
        },
        "timestamp": "2025-08-16 23:07:44.000",
        "id": "bg8pJHsF3yeZn9oGzwNm"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "97f32543-125b-451c-b300-0d1f845c01bb",
            "mapping_index": 6,
            "structured_type": "unstructured",
            "detail_level": "high"
        },
        "timestamp": "2025-08-16 23:07:44.000",
        "id": "iALLiCydbq7GC1k5FuET"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "97f32543-125b-451c-b300-0d1f845c01bb",
            "detail_level": "high",
            "structured_type": "unstructured"
        },
        "timestamp": "2025-08-16 23:07:44.000",
        "id": "lpVKr7ZxmLI9Pd81y2nx"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "97f32543-125b-451c-b300-0d1f845c01bb",
            "detail_level": "high",
            "structured_type": "unstructured"
        },
        "timestamp": "2025-08-16 23:07:44.000",
        "id": "ndSAfFGy2uVeF1y3c5sr"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "97f32543-125b-451c-b300-0d1f845c01bb",
            "detail_level": "high",
            "structured_type": "unstructured"
        },
        "timestamp": "2025-08-16 23:07:44.000",
        "id": "pngT358UtKfMvMdZbksn"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "97f32543-125b-451c-b300-0d1f845c01bb",
            "mapping_index": 5,
            "structured_type": "unstructured",
            "detail_level": "high"
        },
        "timestamp": "2025-08-16 23:07:44.000",
        "id": "sfBbflqspFFsRb3R14SP"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "97f32543-125b-451c-b300-0d1f845c01bb",
            "mapping_index": 4,
            "structured_type": "unstructured",
            "detail_level": "high"
        },
        "timestamp": "2025-08-16 23:07:44.000",
        "id": "yoJegEww979dcZa8JTJb"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "97f32543-125b-451c-b300-0d1f845c01bb",
            "mapping_index": 0,
            "structured_type": "unstructured",
            "detail_level": "high"
        },
        "timestamp": "2025-08-16 23:07:45.000",
        "id": "23O8ls42kPSOe6UMnbs2"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "97f32543-125b-451c-b300-0d1f845c01bb",
            "detail_level": "high",
            "structured_type": "unstructured"
        },
        "timestamp": "2025-08-16 23:07:45.000",
        "id": "7HtuglwuZvx078uMNyYv"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "97f32543-125b-451c-b300-0d1f845c01bb",
            "detail_level": "high",
            "structured_type": "unstructured"
        },
        "timestamp": "2025-08-16 23:07:45.000",
        "id": "pSISi4Ml4RzpUM4ZjjDo"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "97f32543-125b-451c-b300-0d1f845c01bb",
            "mapping_index": 1,
            "structured_type": "unstructured",
            "detail_level": "high"
        },
        "timestamp": "2025-08-16 23:07:46.000",
        "id": "11QiTt1nZE2ge1ozGXze"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "97f32543-125b-451c-b300-0d1f845c01bb",
            "mapping_index": 0,
            "structured_type": "unstructured",
            "detail_level": "high"
        },
        "timestamp": "2025-08-16 23:07:46.000",
        "id": "S0uzDQaHL6p8uRmMylLs"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "97f32543-125b-451c-b300-0d1f845c01bb",
            "detail_level": "high",
            "structured_type": "unstructured"
        },
        "timestamp": "2025-08-16 23:07:46.000",
        "id": "VWqu4Z6gS9mmHXtgLmkF"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "97f32543-125b-451c-b300-0d1f845c01bb",
            "mapping_index": 4,
            "structured_type": "unstructured",
            "detail_level": "high"
        },
        "timestamp": "2025-08-16 23:07:47.000",
        "id": "0P1cwIgjXKUsYCV58sfQ"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "97f32543-125b-451c-b300-0d1f845c01bb",
            "detail_level": "high",
            "structured_type": "unstructured"
        },
        "timestamp": "2025-08-16 23:07:47.000",
        "id": "4Hi7dX3A0HVQfTyazE3q"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "97f32543-125b-451c-b300-0d1f845c01bb",
            "detail_level": "high",
            "structured_type": "unstructured"
        },
        "timestamp": "2025-08-16 23:07:47.000",
        "id": "HEJHNNhFPX9e0vqtqnqT"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "97f32543-125b-451c-b300-0d1f845c01bb",
            "mapping_index": 4,
            "structured_type": "unstructured",
            "detail_level": "high"
        },
        "timestamp": "2025-08-16 23:07:47.000",
        "id": "WBClDsGwjaim4202MXyB"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "97f32543-125b-451c-b300-0d1f845c01bb",
            "detail_level": "high",
            "structured_type": "unstructured"
        },
        "timestamp": "2025-08-16 23:07:47.000",
        "id": "g1UitPGRlv7RDq3zJYL4"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "97f32543-125b-451c-b300-0d1f845c01bb",
            "mapping_index": 3,
            "structured_type": "unstructured",
            "detail_level": "high"
        },
        "timestamp": "2025-08-16 23:07:47.000",
        "id": "pTOQpsmHvPKEI6owgaoL"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "97f32543-125b-451c-b300-0d1f845c01bb",
            "detail_level": "high",
            "structured_type": "unstructured"
        },
        "timestamp": "2025-08-16 23:07:47.000",
        "id": "z53jqqK8nHTKGJbNEr3t"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "97f32543-125b-451c-b300-0d1f845c01bb",
            "detail_level": "high",
            "structured_type": "unstructured"
        },
        "timestamp": "2025-08-16 23:07:48.000",
        "id": "BVnKxbfeSvsEoYM2hnBb"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "97f32543-125b-451c-b300-0d1f845c01bb",
            "mapping_index": 0,
            "structured_type": "unstructured",
            "detail_level": "high"
        },
        "timestamp": "2025-08-16 23:07:48.000",
        "id": "DS9EUAYlQFGiYB22ieXk"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "97f32543-125b-451c-b300-0d1f845c01bb",
            "mapping_index": 0,
            "structured_type": "unstructured",
            "detail_level": "high"
        },
        "timestamp": "2025-08-16 23:07:48.000",
        "id": "GIt7VIrYh479aRGPejM1"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "97f32543-125b-451c-b300-0d1f845c01bb",
            "detail_level": "high",
            "structured_type": "unstructured"
        },
        "timestamp": "2025-08-16 23:07:48.000",
        "id": "cucZzKF9dxAjifxPr3CR"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "97f32543-125b-451c-b300-0d1f845c01bb",
            "mapping_index": 1,
            "structured_type": "unstructured",
            "detail_level": "high"
        },
        "timestamp": "2025-08-16 23:07:48.000",
        "id": "ddPmRvIQb8ghkOfYO6mu"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "97f32543-125b-451c-b300-0d1f845c01bb",
            "detail_level": "high",
            "structured_type": "unstructured"
        },
        "timestamp": "2025-08-16 23:07:48.000",
        "id": "fHuO0m6nL3UGU5G2VAF9"
    },
    {
        "source": "frontend",
        "event": "change_summary_level",
        "data": {
            "before_detail_level": "high",
            "section_id": "97f32543-125b-451c-b300-0d1f845c01bb",
            "before_structured": "unstructured",
            "after_structured": "unstructured",
            "after_detail_level": "medium"
        },
        "timestamp": "2025-08-16 23:07:49.000",
        "id": "cOvPrQWbndp8bweaK24o"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "97f32543-125b-451c-b300-0d1f845c01bb",
            "detail_level": "high",
            "structured_type": "unstructured"
        },
        "timestamp": "2025-08-16 23:07:50.000",
        "id": "47NjQ5hbHx6Iw6uMvFTg"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "97f32543-125b-451c-b300-0d1f845c01bb",
            "mapping_index": 0,
            "structured_type": "unstructured",
            "detail_level": "high"
        },
        "timestamp": "2025-08-16 23:07:50.000",
        "id": "AHk9KiC8rkbb1PkD9buo"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "97f32543-125b-451c-b300-0d1f845c01bb",
            "detail_level": "high",
            "structured_type": "unstructured"
        },
        "timestamp": "2025-08-16 23:07:50.000",
        "id": "PdeL7mlIIrth3Xpl7oPu"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "97f32543-125b-451c-b300-0d1f845c01bb",
            "mapping_index": 7,
            "structured_type": "unstructured",
            "detail_level": "high"
        },
        "timestamp": "2025-08-16 23:07:50.000",
        "id": "V3uh3laz75w4a9CFurJY"
    },
    {
        "source": "frontend",
        "event": "change_summary_level",
        "data": {
            "before_detail_level": "medium",
            "section_id": "97f32543-125b-451c-b300-0d1f845c01bb",
            "before_structured": "unstructured",
            "after_structured": "unstructured",
            "after_detail_level": "high"
        },
        "timestamp": "2025-08-16 23:07:50.000",
        "id": "vFByflRNkq8QtNHFr8wM"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "97f32543-125b-451c-b300-0d1f845c01bb",
            "mapping_index": 5,
            "structured_type": "unstructured",
            "detail_level": "high"
        },
        "timestamp": "2025-08-16 23:07:57.000",
        "id": "BvfGx5vx3dTIv8QoCy17"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "97f32543-125b-451c-b300-0d1f845c01bb",
            "mapping_index": 1,
            "structured_type": "unstructured",
            "detail_level": "high"
        },
        "timestamp": "2025-08-16 23:07:57.000",
        "id": "L7VhC7NwGTN5ZSkkWZ8u"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "97f32543-125b-451c-b300-0d1f845c01bb",
            "detail_level": "high",
            "structured_type": "unstructured"
        },
        "timestamp": "2025-08-16 23:07:57.000",
        "id": "SNRjDE5tJX35qAzvxmsy"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "97f32543-125b-451c-b300-0d1f845c01bb",
            "detail_level": "high",
            "structured_type": "unstructured"
        },
        "timestamp": "2025-08-16 23:07:57.000",
        "id": "VYpNngWztVAeVjSIEIXx"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "97f32543-125b-451c-b300-0d1f845c01bb",
            "mapping_index": 4,
            "structured_type": "unstructured",
            "detail_level": "high"
        },
        "timestamp": "2025-08-16 23:07:57.000",
        "id": "XvszVPMDxQoZWyXVWBde"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "97f32543-125b-451c-b300-0d1f845c01bb",
            "detail_level": "high",
            "structured_type": "unstructured"
        },
        "timestamp": "2025-08-16 23:07:57.000",
        "id": "cSpd2YPn4C5Dfp9EuXmr"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "97f32543-125b-451c-b300-0d1f845c01bb",
            "mapping_index": 0,
            "structured_type": "unstructured",
            "detail_level": "high"
        },
        "timestamp": "2025-08-16 23:07:57.000",
        "id": "oTUS3GDLaOUKqIZKqezB"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "97f32543-125b-451c-b300-0d1f845c01bb",
            "detail_level": "high",
            "structured_type": "unstructured"
        },
        "timestamp": "2025-08-16 23:07:58.000",
        "id": "YkflKym8fHTFtxWsl5co"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "97f32543-125b-451c-b300-0d1f845c01bb",
            "mapping_index": 0,
            "structured_type": "unstructured",
            "detail_level": "medium"
        },
        "timestamp": "2025-08-16 23:07:58.000",
        "id": "e5KyOnDBjWJmqnywF7Ha"
    },
    {
        "source": "frontend",
        "event": "change_summary_level",
        "data": {
            "before_detail_level": "high",
            "section_id": "97f32543-125b-451c-b300-0d1f845c01bb",
            "before_structured": "unstructured",
            "after_structured": "unstructured",
            "after_detail_level": "medium"
        },
        "timestamp": "2025-08-16 23:07:58.000",
        "id": "gVGgxK3WUfBnEhMaIUPo"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "97f32543-125b-451c-b300-0d1f845c01bb",
            "mapping_index": 3,
            "structured_type": "unstructured",
            "detail_level": "medium"
        },
        "timestamp": "2025-08-16 23:07:59.000",
        "id": "1mbbukanIyrOOSggyPfN"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "97f32543-125b-451c-b300-0d1f845c01bb",
            "mapping_index": 7,
            "structured_type": "unstructured",
            "detail_level": "medium"
        },
        "timestamp": "2025-08-16 23:07:59.000",
        "id": "CtnkuCbheUwHikHGUaaQ"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "97f32543-125b-451c-b300-0d1f845c01bb",
            "detail_level": "medium",
            "structured_type": "unstructured"
        },
        "timestamp": "2025-08-16 23:07:59.000",
        "id": "iyltTLzUsajcmZdfw6FJ"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "97f32543-125b-451c-b300-0d1f845c01bb",
            "detail_level": "medium",
            "structured_type": "unstructured"
        },
        "timestamp": "2025-08-16 23:07:59.000",
        "id": "lJlsPySwuxB6NtlUaBGq"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "97f32543-125b-451c-b300-0d1f845c01bb",
            "detail_level": "medium",
            "structured_type": "unstructured"
        },
        "timestamp": "2025-08-16 23:07:59.000",
        "id": "wIdrnbBKFmlPkVnPnIMA"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "97f32543-125b-451c-b300-0d1f845c01bb",
            "mapping_index": 6,
            "structured_type": "unstructured",
            "detail_level": "medium"
        },
        "timestamp": "2025-08-16 23:08:04.000",
        "id": "45FxHJPpMx7XoUG8eJwM"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "97f32543-125b-451c-b300-0d1f845c01bb",
            "detail_level": "medium",
            "structured_type": "unstructured"
        },
        "timestamp": "2025-08-16 23:08:04.000",
        "id": "NwwaWcArZsiVg5m6loWz"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "97f32543-125b-451c-b300-0d1f845c01bb",
            "mapping_index": 3,
            "structured_type": "unstructured",
            "detail_level": "medium"
        },
        "timestamp": "2025-08-16 23:08:04.000",
        "id": "ixyjJQlNnyiKGazg30e8"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "97f32543-125b-451c-b300-0d1f845c01bb",
            "detail_level": "medium",
            "structured_type": "unstructured"
        },
        "timestamp": "2025-08-16 23:08:04.000",
        "id": "l03jlzpMxTS4zYWICsMj"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "97f32543-125b-451c-b300-0d1f845c01bb",
            "mapping_index": 0,
            "structured_type": "unstructured",
            "detail_level": "high"
        },
        "timestamp": "2025-08-16 23:08:05.000",
        "id": "7bMVFgEbdybHTe48ATUv"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "97f32543-125b-451c-b300-0d1f845c01bb",
            "detail_level": "high",
            "structured_type": "unstructured"
        },
        "timestamp": "2025-08-16 23:08:05.000",
        "id": "9OGEZQQH7ebkXBBDroJe"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "97f32543-125b-451c-b300-0d1f845c01bb",
            "mapping_index": 0,
            "structured_type": "unstructured",
            "detail_level": "high"
        },
        "timestamp": "2025-08-16 23:08:05.000",
        "id": "9qrHeXllbfxAAySL1wKU"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "97f32543-125b-451c-b300-0d1f845c01bb",
            "mapping_index": 1,
            "structured_type": "unstructured",
            "detail_level": "high"
        },
        "timestamp": "2025-08-16 23:08:05.000",
        "id": "L3fEQa49LrAYwpJFFB2t"
    },
    {
        "source": "frontend",
        "event": "change_summary_level",
        "data": {
            "before_detail_level": "medium",
            "section_id": "97f32543-125b-451c-b300-0d1f845c01bb",
            "before_structured": "unstructured",
            "after_structured": "unstructured",
            "after_detail_level": "high"
        },
        "timestamp": "2025-08-16 23:08:05.000",
        "id": "kCpQoXWWWhxCK4S4Fd6z"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "97f32543-125b-451c-b300-0d1f845c01bb",
            "detail_level": "high",
            "structured_type": "unstructured"
        },
        "timestamp": "2025-08-16 23:08:05.000",
        "id": "yUiE2T6IibtHkHeKeAQs"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "97f32543-125b-451c-b300-0d1f845c01bb",
            "mapping_index": 0,
            "structured_type": "unstructured",
            "detail_level": "medium"
        },
        "timestamp": "2025-08-16 23:08:06.000",
        "id": "9qACm5u13uHYrEuqeqQE"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "97f32543-125b-451c-b300-0d1f845c01bb",
            "detail_level": "high",
            "structured_type": "unstructured"
        },
        "timestamp": "2025-08-16 23:08:06.000",
        "id": "QBkAOxkrrq9TPayXs2Yv"
    },
    {
        "source": "frontend",
        "event": "change_summary_level",
        "data": {
            "before_detail_level": "high",
            "section_id": "97f32543-125b-451c-b300-0d1f845c01bb",
            "before_structured": "unstructured",
            "after_structured": "unstructured",
            "after_detail_level": "medium"
        },
        "timestamp": "2025-08-16 23:08:06.000",
        "id": "QzWorSzWTsreG67VPrOU"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "97f32543-125b-451c-b300-0d1f845c01bb",
            "detail_level": "medium",
            "structured_type": "unstructured"
        },
        "timestamp": "2025-08-16 23:08:07.000",
        "id": "EweqkawsNbHcZuPpavPv"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "97f32543-125b-451c-b300-0d1f845c01bb",
            "mapping_index": 3,
            "structured_type": "unstructured",
            "detail_level": "medium"
        },
        "timestamp": "2025-08-16 23:08:07.000",
        "id": "MK6GXgo3X7m9I9pzoqrs"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "97f32543-125b-451c-b300-0d1f845c01bb",
            "mapping_index": 4,
            "structured_type": "unstructured",
            "detail_level": "medium"
        },
        "timestamp": "2025-08-16 23:08:07.000",
        "id": "SRbUfFMg3zGMvpzUWToq"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "97f32543-125b-451c-b300-0d1f845c01bb",
            "detail_level": "medium",
            "structured_type": "unstructured"
        },
        "timestamp": "2025-08-16 23:08:07.000",
        "id": "gMGsKtqL0Xkpv4u1ziUl"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "97f32543-125b-451c-b300-0d1f845c01bb",
            "detail_level": "medium",
            "structured_type": "unstructured"
        },
        "timestamp": "2025-08-16 23:08:07.000",
        "id": "pBeg12TCzV64kMwZwAuq"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "97f32543-125b-451c-b300-0d1f845c01bb",
            "mapping_index": 1,
            "structured_type": "unstructured",
            "detail_level": "medium"
        },
        "timestamp": "2025-08-16 23:08:07.000",
        "id": "pPzGJM9hdnGM2o1ZWYO8"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "97f32543-125b-451c-b300-0d1f845c01bb",
            "detail_level": "medium",
            "structured_type": "unstructured"
        },
        "timestamp": "2025-08-16 23:08:07.000",
        "id": "wP58ZoKCP1zY31aDeu3g"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "97f32543-125b-451c-b300-0d1f845c01bb",
            "mapping_index": 4,
            "structured_type": "unstructured",
            "detail_level": "medium"
        },
        "timestamp": "2025-08-16 23:08:08.000",
        "id": "SEEXPg05PwKJiVFLTfTO"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "97f32543-125b-451c-b300-0d1f845c01bb",
            "detail_level": "medium",
            "structured_type": "unstructured"
        },
        "timestamp": "2025-08-16 23:08:08.000",
        "id": "tB7lrNmy3alqDMJnwMg0"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "97f32543-125b-451c-b300-0d1f845c01bb",
            "mapping_index": 7,
            "structured_type": "unstructured",
            "detail_level": "medium"
        },
        "timestamp": "2025-08-16 23:08:09.000",
        "id": "49klMkbaFmbIGSc35Srq"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "97f32543-125b-451c-b300-0d1f845c01bb",
            "mapping_index": 5,
            "structured_type": "unstructured",
            "detail_level": "medium"
        },
        "timestamp": "2025-08-16 23:08:10.000",
        "id": "FL3dRNfzAm6jnAWgm9N4"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "97f32543-125b-451c-b300-0d1f845c01bb",
            "detail_level": "medium",
            "structured_type": "unstructured"
        },
        "timestamp": "2025-08-16 23:08:10.000",
        "id": "Q5mVjMggFeD5ZHYdogTN"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "97f32543-125b-451c-b300-0d1f845c01bb",
            "detail_level": "medium",
            "structured_type": "unstructured"
        },
        "timestamp": "2025-08-16 23:08:10.000",
        "id": "Rn2h2y6hGWxKtaEaiU0m"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "97f32543-125b-451c-b300-0d1f845c01bb",
            "mapping_index": 6,
            "structured_type": "unstructured",
            "detail_level": "medium"
        },
        "timestamp": "2025-08-16 23:08:10.000",
        "id": "p4ADu6PIhEkFMADuH0QM"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "97f32543-125b-451c-b300-0d1f845c01bb",
            "mapping_index": 2,
            "structured_type": "unstructured",
            "detail_level": "medium"
        },
        "timestamp": "2025-08-16 23:08:10.000",
        "id": "ramBpBbbHEgX3wx50Mc9"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "97f32543-125b-451c-b300-0d1f845c01bb",
            "detail_level": "medium",
            "structured_type": "unstructured"
        },
        "timestamp": "2025-08-16 23:08:10.000",
        "id": "zGI6eGwwL24wRjuQPdDp"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "97f32543-125b-451c-b300-0d1f845c01bb",
            "detail_level": "medium",
            "structured_type": "unstructured"
        },
        "timestamp": "2025-08-16 23:08:11.000",
        "id": "1IDcaBlssnHYOLWWzTc9"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "97f32543-125b-451c-b300-0d1f845c01bb",
            "detail_level": "medium",
            "structured_type": "unstructured"
        },
        "timestamp": "2025-08-16 23:08:11.000",
        "id": "5SwZDdrMfzKUxWDsoBeo"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "97f32543-125b-451c-b300-0d1f845c01bb",
            "mapping_index": 6,
            "structured_type": "unstructured",
            "detail_level": "medium"
        },
        "timestamp": "2025-08-16 23:08:11.000",
        "id": "7uvCJy7ycEHWUmYCROV5"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "97f32543-125b-451c-b300-0d1f845c01bb",
            "detail_level": "medium",
            "structured_type": "unstructured"
        },
        "timestamp": "2025-08-16 23:08:11.000",
        "id": "Fcp70dr7yyVrJThJRqGR"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "97f32543-125b-451c-b300-0d1f845c01bb",
            "detail_level": "medium",
            "structured_type": "unstructured"
        },
        "timestamp": "2025-08-16 23:08:11.000",
        "id": "KioG12675IQzCsN5120D"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "97f32543-125b-451c-b300-0d1f845c01bb",
            "mapping_index": 5,
            "structured_type": "unstructured",
            "detail_level": "medium"
        },
        "timestamp": "2025-08-16 23:08:11.000",
        "id": "ZBKubVcYT5aD5xcmxsWH"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "97f32543-125b-451c-b300-0d1f845c01bb",
            "mapping_index": 3,
            "structured_type": "unstructured",
            "detail_level": "medium"
        },
        "timestamp": "2025-08-16 23:08:11.000",
        "id": "Zt6WyVFwIOCmFKFgnRgS"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "97f32543-125b-451c-b300-0d1f845c01bb",
            "mapping_index": 7,
            "structured_type": "unstructured",
            "detail_level": "medium"
        },
        "timestamp": "2025-08-16 23:08:11.000",
        "id": "aD7Fu122L4Nvb9jRa4y7"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "97f32543-125b-451c-b300-0d1f845c01bb",
            "detail_level": "medium",
            "structured_type": "unstructured"
        },
        "timestamp": "2025-08-16 23:08:11.000",
        "id": "rRcbmp0q2MjhejXH8THT"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "97f32543-125b-451c-b300-0d1f845c01bb",
            "mapping_index": 4,
            "structured_type": "unstructured",
            "detail_level": "medium"
        },
        "timestamp": "2025-08-16 23:08:11.000",
        "id": "v0EanlPcJ1vT9r4lbpUM"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "97f32543-125b-451c-b300-0d1f845c01bb",
            "detail_level": "medium",
            "structured_type": "unstructured"
        },
        "timestamp": "2025-08-16 23:08:12.000",
        "id": "7CieWtr96BvSKPQo9G08"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "97f32543-125b-451c-b300-0d1f845c01bb",
            "mapping_index": 3,
            "structured_type": "unstructured",
            "detail_level": "medium"
        },
        "timestamp": "2025-08-16 23:08:12.000",
        "id": "DBBK9vdQDI7afAMmVx68"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "97f32543-125b-451c-b300-0d1f845c01bb",
            "detail_level": "medium",
            "structured_type": "unstructured"
        },
        "timestamp": "2025-08-16 23:08:12.000",
        "id": "KiLvmjrfCZzybBVTooQX"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "97f32543-125b-451c-b300-0d1f845c01bb",
            "detail_level": "medium",
            "structured_type": "unstructured"
        },
        "timestamp": "2025-08-16 23:08:12.000",
        "id": "MnnY4p5EYyHic8xhPFx3"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "97f32543-125b-451c-b300-0d1f845c01bb",
            "mapping_index": 1,
            "structured_type": "unstructured",
            "detail_level": "medium"
        },
        "timestamp": "2025-08-16 23:08:12.000",
        "id": "cwJyThV0JD5iOaMnYtwB"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "97f32543-125b-451c-b300-0d1f845c01bb",
            "mapping_index": 5,
            "structured_type": "unstructured",
            "detail_level": "medium"
        },
        "timestamp": "2025-08-16 23:08:12.000",
        "id": "hD29ssPfNjI6ubDPrYvK"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "97f32543-125b-451c-b300-0d1f845c01bb",
            "mapping_index": 2,
            "structured_type": "unstructured",
            "detail_level": "medium"
        },
        "timestamp": "2025-08-16 23:08:12.000",
        "id": "mGunn19f40z1M6UMUvH3"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "97f32543-125b-451c-b300-0d1f845c01bb",
            "detail_level": "medium",
            "structured_type": "unstructured"
        },
        "timestamp": "2025-08-16 23:08:12.000",
        "id": "npx73kVe925gJfFHoplw"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "97f32543-125b-451c-b300-0d1f845c01bb",
            "detail_level": "medium",
            "structured_type": "unstructured"
        },
        "timestamp": "2025-08-16 23:08:12.000",
        "id": "xlcT6JvvheWmKrm2VdJd"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "97f32543-125b-451c-b300-0d1f845c01bb",
            "mapping_index": 5,
            "structured_type": "unstructured",
            "detail_level": "medium"
        },
        "timestamp": "2025-08-16 23:08:13.000",
        "id": "BXExjNNsg9nnjMiSKv3c"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "97f32543-125b-451c-b300-0d1f845c01bb",
            "detail_level": "medium",
            "structured_type": "unstructured"
        },
        "timestamp": "2025-08-16 23:08:13.000",
        "id": "FjpHa4U7671Ozw5MDwvK"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "97f32543-125b-451c-b300-0d1f845c01bb",
            "detail_level": "medium",
            "structured_type": "unstructured"
        },
        "timestamp": "2025-08-16 23:08:13.000",
        "id": "PEqEw0WNBnMFZGJ4jPB7"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "97f32543-125b-451c-b300-0d1f845c01bb",
            "mapping_index": 2,
            "structured_type": "unstructured",
            "detail_level": "medium"
        },
        "timestamp": "2025-08-16 23:08:13.000",
        "id": "wzd4DXqZIegCcl3BZn2o"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "97f32543-125b-451c-b300-0d1f845c01bb",
            "detail_level": "medium",
            "structured_type": "unstructured"
        },
        "timestamp": "2025-08-16 23:08:14.000",
        "id": "0LVlau4kEpsp4IBNpIQu"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "97f32543-125b-451c-b300-0d1f845c01bb",
            "mapping_index": 5,
            "structured_type": "unstructured",
            "detail_level": "medium"
        },
        "timestamp": "2025-08-16 23:08:14.000",
        "id": "1fM7Amw06avT2m3WdqH9"
    },
    {
        "source": "frontend",
        "event": "click_edit_in_prompt",
        "data": {
            "section_id": "97f32543-125b-451c-b300-0d1f845c01bb",
            "summary": "The plot_ranking_predictions function visualizes the difference between predicted and actual ranks for each player in a specified year. It creates a bar plot showing these errors and saves the resulting image to a file. The plot includes player names, error values, and a reference line at zero. (There are no changes from the previous version.)",
            "detail_level": "medium",
            "structured": "unstructured"
        },
        "timestamp": "2025-08-16 23:08:14.000",
        "id": "F2capm2WY5Kl4Otu911P"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "97f32543-125b-451c-b300-0d1f845c01bb",
            "detail_level": "medium",
            "structured_type": "unstructured"
        },
        "timestamp": "2025-08-16 23:08:14.000",
        "id": "VDVcZYAi3XeVjRi3u5wA"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "97f32543-125b-451c-b300-0d1f845c01bb",
            "mapping_index": 2,
            "structured_type": "unstructured",
            "detail_level": "medium"
        },
        "timestamp": "2025-08-16 23:08:14.000",
        "id": "bKxpC5zvgH1yfj8mOfXV"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "97f32543-125b-451c-b300-0d1f845c01bb",
            "mapping_index": 1,
            "structured_type": "unstructured",
            "detail_level": "medium"
        },
        "timestamp": "2025-08-16 23:08:41.000",
        "id": "ZwSIEkSD2GkSpLu5emVa"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "97f32543-125b-451c-b300-0d1f845c01bb",
            "detail_level": "medium",
            "structured_type": "unstructured"
        },
        "timestamp": "2025-08-16 23:08:41.000",
        "id": "bWoLev4pskieVQEx9AyJ"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "97f32543-125b-451c-b300-0d1f845c01bb",
            "mapping_index": 3,
            "structured_type": "unstructured",
            "detail_level": "medium"
        },
        "timestamp": "2025-08-16 23:08:41.000",
        "id": "gP1b8HLfUYGKoVq4PsDi"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "97f32543-125b-451c-b300-0d1f845c01bb",
            "detail_level": "medium",
            "structured_type": "unstructured"
        },
        "timestamp": "2025-08-16 23:08:41.000",
        "id": "hDIzn8Crbkq21BnRUqem"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "97f32543-125b-451c-b300-0d1f845c01bb",
            "mapping_index": 4,
            "structured_type": "unstructured",
            "detail_level": "medium"
        },
        "timestamp": "2025-08-16 23:08:41.000",
        "id": "te6giDAsiIQjwDleyg49"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "97f32543-125b-451c-b300-0d1f845c01bb",
            "detail_level": "medium",
            "structured_type": "unstructured"
        },
        "timestamp": "2025-08-16 23:08:42.000",
        "id": "FLgbPBS7u5kqVC6LWsqH"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "97f32543-125b-451c-b300-0d1f845c01bb",
            "detail_level": "medium",
            "structured_type": "unstructured"
        },
        "timestamp": "2025-08-16 23:08:42.000",
        "id": "m1eC8IWFQd9AC3YERjl1"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "97f32543-125b-451c-b300-0d1f845c01bb",
            "mapping_index": 4,
            "structured_type": "unstructured",
            "detail_level": "medium"
        },
        "timestamp": "2025-08-16 23:08:42.000",
        "id": "nIk3SHEe8CUXCcN4QkOx"
    },
    {
        "source": "frontend",
        "event": "apply_instruction_summary",
        "data": {
            "section_id": "97f32543-125b-451c-b300-0d1f845c01bb",
            "instruction": "visualize the predicted rankings instead of diifference",
            "detail_level": "medium",
            "original_summary": "The plot_ranking_predictions function visualizes the difference between predicted and actual ranks for each player in a specified year. It creates a bar plot showing these errors and saves the resulting image to a file. The plot includes player names, error values, and a reference line at zero. (There are no changes from the previous version.)",
            "structured": "unstructured"
        },
        "timestamp": "2025-08-16 23:09:07.000",
        "id": "y3nh6HJPoSQu4Q2ds8vs"
    },
    {
        "source": "backend",
        "event": "apply_instruction_summary",
        "data": {
            "original_code": "def plot_ranking_predictions(df, year):\n    \"\"\"\n    Plot prediction error for a specific year.\n\n    Args:\n        df: DataFrame containing prediction results\n        year: Year to plot prediction errors for\n    \"\"\"\n    df[\"RankError\"] = df[\"PredictedRank\"] - df[\"Rank\"]\n    year_df = df[df[\"Year\"] == year].copy()\n    year_df.sort_values(\"Rank\", inplace=True)\n\n    plt.figure(figsize=(12, 6))\n    sns.barplot(x=\"Name\", y=\"RankError\", data=year_df, hue=\"Name\", palette=\"coolwarm\", dodge=True)\n    plt.axhline(0, color=\"black\", linestyle=\"--\")\n    plt.xticks(rotation=45, ha=\"right\")\n    plt.ylabel(\"Predicted Rank - True Rank\")\n    plt.title(f\"MVP Ranking Predictions ({year})\")\n    plt.tight_layout()\n    plt.savefig(f\"data/ranking_predictions_{year}.png\")",
            "original_summary": "The plot_ranking_predictions function visualizes the difference between predicted and actual ranks for each player in a specified year. It creates a bar plot showing these errors and saves the resulting image to a file. The plot includes player names, error values, and a reference line at zero. (There are no changes from the previous version.)",
            "instruction": "visualize the predicted rankings instead of diifference",
            "updated_summary": "The plot_ranking_predictions function visualizes the predicted ranks for each player in a specified year, instead of the difference between predicted and actual ranks. It creates a bar plot showing the predicted ranking values for each player and saves the resulting image to a file. The plot includes player names, their predicted ranks, and a reference line at zero. (There are no changes from the previous version.)"
        },
        "timestamp": "2025-08-16 23:09:08.000",
        "id": "UQQOtH6beC5RQfZzUmUD"
    },
    {
        "source": "frontend",
        "event": "commit_modified_summary",
        "data": {
            "section_id": "97f32543-125b-451c-b300-0d1f845c01bb",
            "edited_summary": "The plot_ranking_predictions function visualizes the predicted ranks for each player in a specified year, instead of the difference between predicted and actual ranks. It creates a bar plot showing the predicted ranking values for each player and saves the resulting image to a file. The plot includes player names, their predicted ranks, and a reference line at zero. (There are no changes from the previous version.)",
            "detail_level": "medium",
            "original_summary": "The plot_ranking_predictions function visualizes the difference between predicted and actual ranks for each player in a specified year. It creates a bar plot showing these errors and saves the resulting image to a file. The plot includes player names, error values, and a reference line at zero. (There are no changes from the previous version.)",
            "structured": "unstructured"
        },
        "timestamp": "2025-08-16 23:09:13.000",
        "id": "DslgqR4xk08CBU5J5lFI"
    },
    {
        "source": "backend",
        "event": "modify_summary_mediation",
        "data": {
            "original_code": "def plot_ranking_predictions(df, year):\n    \"\"\"\n    Plot prediction error for a specific year.\n\n    Args:\n        df: DataFrame containing prediction results\n        year: Year to plot prediction errors for\n    \"\"\"\n    df[\"RankError\"] = df[\"PredictedRank\"] - df[\"Rank\"]\n    year_df = df[df[\"Year\"] == year].copy()\n    year_df.sort_values(\"Rank\", inplace=True)\n\n    plt.figure(figsize=(12, 6))\n    sns.barplot(x=\"Name\", y=\"RankError\", data=year_df, hue=\"Name\", palette=\"coolwarm\", dodge=True)\n    plt.axhline(0, color=\"black\", linestyle=\"--\")\n    plt.xticks(rotation=45, ha=\"right\")\n    plt.ylabel(\"Predicted Rank - True Rank\")\n    plt.title(f\"MVP Ranking Predictions ({year})\")\n    plt.tight_layout()\n    plt.savefig(f\"data/ranking_predictions_{year}.png\")",
            "original_summary": "The plot_ranking_predictions function visualizes the difference between predicted and actual ranks for each player in a specified year. It creates a bar plot showing these errors and saves the resulting image to a file. The plot includes player names, error values, and a reference line at zero. (There are no changes from the previous version.)",
            "edited_summary": "The plot_ranking_predictions function visualizes the predicted ranks for each player in a specified year, instead of the difference between predicted and actual ranks. It creates a bar plot showing the predicted ranking values for each player and saves the resulting image to a file. The plot includes player names, their predicted ranks, and a reference line at zero. (There are no changes from the previous version.)",
            "structured_type": "unstructured",
            "detail_level": "medium",
            "updated_code": "def plot_ranking_predictions(df, year):\n    \"\"\"\n    Plot predicted ranks for a specific year.\n\n    Args:\n        df: DataFrame containing prediction results\n        year: Year to plot predicted ranks for\n    \"\"\"\n    year_df = df[df[\"Year\"] == year].copy()\n    year_df.sort_values(\"PredictedRank\", inplace=True)\n\n    plt.figure(figsize=(12, 6))\n    sns.barplot(x=\"Name\", y=\"PredictedRank\", data=year_df, hue=\"Name\", palette=\"coolwarm\", dodge=True)\n    plt.axhline(0, color=\"black\", linestyle=\"--\")\n    plt.xticks(rotation=45, ha=\"right\")\n    plt.ylabel(\"Predicted Rank\")\n    plt.title(f\"MVP Predicted Rankings ({year})\")\n    plt.tight_layout()\n    plt.savefig(f\"data/ranking_predictions_{year}.png\")"
        },
        "timestamp": "2025-08-16 23:09:15.000",
        "id": "5Nb9FgHGi0ZikCPsrjhJ"
    },
    {
        "source": "backend",
        "event": "summarize_modified_code",
        "data": {
            "new_code": "def plot_ranking_predictions(df, year):\n    \"\"\"\n    Plot predicted ranks for a specific year.\n\n    Args:\n        df: DataFrame containing prediction results\n        year: Year to plot predicted ranks for\n    \"\"\"\n    year_df = df[df[\"Year\"] == year].copy()\n    year_df.sort_values(\"PredictedRank\", inplace=True)\n\n    plt.figure(figsize=(12, 6))\n    sns.barplot(x=\"Name\", y=\"PredictedRank\", data=year_df, hue=\"Name\", palette=\"coolwarm\", dodge=True)\n    plt.axhline(0, color=\"black\", linestyle=\"--\")\n    plt.xticks(rotation=45, ha=\"right\")\n    plt.ylabel(\"Predicted Rank\")\n    plt.title(f\"MVP Predicted Rankings ({year})\")\n    plt.tight_layout()\n    plt.savefig(f\"data/ranking_predictions_{year}.png\")",
            "original_code": "def plot_ranking_predictions(df, year):\n    \"\"\"\n    Plot predicted ranks for a specific year.\n\n    Args:\n        df: DataFrame containing prediction results\n        year: Year to plot predicted ranks for\n    \"\"\"\n    year_df = df[df[\"Year\"] == year].copy()\n    year_df.sort_values(\"PredictedRank\", inplace=True)\n\n    plt.figure(figsize=(12, 6))\n    sns.barplot(x=\"Name\", y=\"PredictedRank\", data=year_df, hue=\"Name\", palette=\"coolwarm\", dodge=True)\n    plt.axhline(0, color=\"black\", linestyle=\"--\")\n    plt.xticks(rotation=45, ha=\"right\")\n    plt.ylabel(\"Predicted Rank\")\n    plt.title(f\"MVP Predicted Rankings ({year})\")\n    plt.tight_layout()\n    plt.savefig(f\"data/ranking_predictions_{year}.png\")",
            "old_summary": {
                "low_structured": "• Plots prediction errors for a given year\n• Saves the plot as an image file\n• (No changes were made to the function.)",
                "high_unstructured": "The plot_ranking_predictions function generates a bar plot to visualize the prediction error (PredictedRank minus actual Rank) for each player in a specified year. It first computes the rank error, filters the DataFrame for the given year, and sorts the data by true rank to ensure a consistent order. Using Seaborn, it creates a colored bar plot with player names on the x-axis and prediction errors on the y-axis, adding a horizontal line at zero for reference. The plot is formatted for readability and saved as a PNG file named according to the year. (No changes were made to the function.)",
                "medium_unstructured": "The plot_ranking_predictions function visualizes the difference between predicted and actual ranks for each player in a specified year. It creates a bar plot showing these errors and saves the resulting image to a file. The plot includes player names, error values, and a reference line at zero. (There are no changes from the previous version.)",
                "high_structured": "• Computes the 'RankError' column as the difference between 'PredictedRank' and 'Rank' for each entry\n• Filters the DataFrame to include only rows from the specified year and sorts them by actual rank\n• Sets up a matplotlib figure with a specific size\n• Creates a Seaborn bar plot:\n  ◦ x-axis: Player names\n  ◦ y-axis: RankError values\n  ◦ Hue: Player names for color distinction\n  ◦ Palette: 'coolwarm' for visual contrast\n• Adds a horizontal dashed line at y=0 to indicate no error\n• Rotates x-axis labels for better readability\n• Sets axis labels and a descriptive plot title indicating the year\n• Adjusts layout for clarity and saves the figure as 'data/ranking_predictions_{year}.png'\n• (No changes were made to the function.)",
                "title": "Function: plot_ranking_predictions",
                "low_unstructured": "This function plots and saves the prediction errors for player rankings in a specified year. (No changes were made to the function.)",
                "medium_structured": "• Calculates prediction error as the difference between predicted and actual ranks\n• Filters data for the specified year and sorts by true rank\n• Creates a bar plot of prediction errors for each player\n  ◦ Uses player names as labels and colors\n• Adds a horizontal reference line and saves the plot as a PNG file\n• (No changes were made to the function.)"
            },
            "new_summary": {
                "low_structured": "• Plots predicted ranks for a given year\n• Saves the plot as an image file\n• The function now visualizes predicted ranks directly instead of prediction errors.",
                "high_unstructured": "The plot_ranking_predictions function generates a bar plot to visualize the predicted rank for each player in a specified year. It filters the DataFrame for the given year, sorts the data by predicted rank, and uses Seaborn to create a colored bar plot with player names on the x-axis and predicted rank values on the y-axis, adding a horizontal line at zero for reference. The plot is formatted for readability and saved as a PNG file named according to the year. (The function now plots predicted ranks instead of the prediction error between predicted and actual ranks.)",
                "medium_unstructured": "The plot_ranking_predictions function visualizes the predicted ranks for each player in a specified year. It creates a bar plot showing the predicted rank values for each player and saves the resulting image to a file. The plot includes player names, predicted rank values, and a reference line at zero. (The function now focuses on plotting predicted ranks, not the difference between predicted and actual ranks.)",
                "high_structured": "• Filters the DataFrame to include only rows from the specified year and sorts them by predicted rank\n• Sets up a matplotlib figure with a specific size\n• Creates a Seaborn bar plot:\n  ◦ x-axis: Player names\n  ◦ y-axis: PredictedRank values\n  ◦ Hue: Player names for color distinction\n  ◦ Palette: 'coolwarm' for visual contrast\n• Adds a horizontal dashed line at y=0 to indicate a reference\n• Rotates x-axis labels for better readability\n• Sets axis labels and a descriptive plot title indicating the year\n• Adjusts layout for clarity and saves the figure as 'data/ranking_predictions_{year}.png'\n• The function now visualizes predicted ranks directly, not the difference between predicted and actual ranks.",
                "title": "Function: plot_ranking_predictions",
                "low_unstructured": "This function plots and saves the predicted ranks for players in a specified year, displaying predicted rank values rather than prediction errors. (The function now plots predicted ranks directly instead of errors.)",
                "medium_structured": "• Filters data for the specified year and sorts by predicted rank\n• Creates a bar plot of predicted ranks for each player\n  ◦ Uses player names as labels and colors\n• Adds a horizontal reference line and saves the plot as a PNG file\n• The function now plots predicted ranks directly, rather than prediction errors."
            }
        },
        "timestamp": "2025-08-16 23:09:24.000",
        "id": "4aVPStfhZOootmLhLXAb"
    },
    {
        "source": "backend",
        "event": "map_summary_code",
        "data": {
            "summary": "• Plots predicted ranks for a given year\n• Saves the plot as an image file\n• The function now visualizes predicted ranks directly instead of prediction errors.",
            "mapping": [
                {
                    "summaryComponent": "Plots predicted ranks for a given year",
                    "codeSegments": [
                        {
                            "line": 67,
                            "code": "def plot_ranking_predictions(df, year):"
                        },
                        {
                            "line": 78,
                            "code": "plt.figure(figsize=(12, 6))"
                        },
                        {
                            "line": 79,
                            "code": "sns.barplot(x=\"Name\", y=\"PredictedRank\", data=year_df, hue=\"Name\", palette=\"coolwarm\", dodge=True)"
                        },
                        {
                            "line": 83,
                            "code": "plt.title(f\"MVP Predicted Rankings ({year})\")"
                        }
                    ]
                },
                {
                    "summaryComponent": "Saves the plot as an image file",
                    "codeSegments": [
                        {
                            "line": 85,
                            "code": "plt.savefig(f\"data/ranking_predictions_{year}.png\")"
                        }
                    ]
                },
                {
                    "summaryComponent": "The function now visualizes predicted ranks directly instead of prediction errors.",
                    "codeSegments": [
                        {
                            "line": 79,
                            "code": "sns.barplot(x=\"Name\", y=\"PredictedRank\", data=year_df, hue=\"Name\", palette=\"coolwarm\", dodge=True)"
                        }
                    ]
                }
            ],
            "code": "67: def plot_ranking_predictions(df, year):\n68:     \"\"\"\n69:     Plot predicted ranks for a specific year.\n70: \n71:     Args:\n72:         df: DataFrame containing prediction results\n73:         year: Year to plot predicted ranks for\n74:     \"\"\"\n75:     year_df = df[df[\"Year\"] == year].copy()\n76:     year_df.sort_values(\"PredictedRank\", inplace=True)\n77: \n78:     plt.figure(figsize=(12, 6))\n79:     sns.barplot(x=\"Name\", y=\"PredictedRank\", data=year_df, hue=\"Name\", palette=\"coolwarm\", dodge=True)\n80:     plt.axhline(0, color=\"black\", linestyle=\"--\")\n81:     plt.xticks(rotation=45, ha=\"right\")\n82:     plt.ylabel(\"Predicted Rank\")\n83:     plt.title(f\"MVP Predicted Rankings ({year})\")\n84:     plt.tight_layout()\n85:     plt.savefig(f\"data/ranking_predictions_{year}.png\")"
        },
        "timestamp": "2025-08-16 23:09:26.000",
        "id": "bbrEeCUVw7w7cpF1fTn0"
    },
    {
        "source": "backend",
        "event": "map_summary_code",
        "data": {
            "summary": "• Filters data for the specified year and sorts by predicted rank\n• Creates a bar plot of predicted ranks for each player\n  ◦ Uses player names as labels and colors\n• Adds a horizontal reference line and saves the plot as a PNG file\n• The function now plots predicted ranks directly, rather than prediction errors.",
            "mapping": [
                {
                    "summaryComponent": "Filters data for the specified year and sorts by predicted rank",
                    "codeSegments": [
                        {
                            "line": 75,
                            "code": "year_df = df[df[\"Year\"] == year].copy()"
                        },
                        {
                            "line": 76,
                            "code": "year_df.sort_values(\"PredictedRank\", inplace=True)"
                        }
                    ]
                },
                {
                    "summaryComponent": "Creates a bar plot of predicted ranks for each player",
                    "codeSegments": [
                        {
                            "line": 79,
                            "code": "sns.barplot(x=\"Name\", y=\"PredictedRank\", data=year_df, hue=\"Name\", palette=\"coolwarm\", dodge=True)"
                        }
                    ]
                },
                {
                    "summaryComponent": "Uses player names as labels and colors",
                    "codeSegments": [
                        {
                            "line": 79,
                            "code": "sns.barplot(x=\"Name\", y=\"PredictedRank\", data=year_df, hue=\"Name\", palette=\"coolwarm\", dodge=True)"
                        }
                    ]
                },
                {
                    "summaryComponent": "Adds a horizontal reference line and saves the plot as a PNG file",
                    "codeSegments": [
                        {
                            "line": 80,
                            "code": "plt.axhline(0, color=\"black\", linestyle=\"--\")"
                        },
                        {
                            "line": 85,
                            "code": "plt.savefig(f\"data/ranking_predictions_{year}.png\")"
                        }
                    ]
                },
                {
                    "summaryComponent": "The function now plots predicted ranks directly, rather than prediction errors.",
                    "codeSegments": [
                        {
                            "line": 79,
                            "code": "sns.barplot(x=\"Name\", y=\"PredictedRank\", data=year_df, hue=\"Name\", palette=\"coolwarm\", dodge=True)"
                        }
                    ]
                }
            ],
            "code": "67: def plot_ranking_predictions(df, year):\n68:     \"\"\"\n69:     Plot predicted ranks for a specific year.\n70: \n71:     Args:\n72:         df: DataFrame containing prediction results\n73:         year: Year to plot predicted ranks for\n74:     \"\"\"\n75:     year_df = df[df[\"Year\"] == year].copy()\n76:     year_df.sort_values(\"PredictedRank\", inplace=True)\n77: \n78:     plt.figure(figsize=(12, 6))\n79:     sns.barplot(x=\"Name\", y=\"PredictedRank\", data=year_df, hue=\"Name\", palette=\"coolwarm\", dodge=True)\n80:     plt.axhline(0, color=\"black\", linestyle=\"--\")\n81:     plt.xticks(rotation=45, ha=\"right\")\n82:     plt.ylabel(\"Predicted Rank\")\n83:     plt.title(f\"MVP Predicted Rankings ({year})\")\n84:     plt.tight_layout()\n85:     plt.savefig(f\"data/ranking_predictions_{year}.png\")"
        },
        "timestamp": "2025-08-16 23:09:26.000",
        "id": "qzcPlbruDPCNfwRLglK9"
    },
    {
        "source": "backend",
        "event": "map_summary_code",
        "data": {
            "summary": "The plot_ranking_predictions function visualizes the predicted ranks for each player in a specified year. It creates a bar plot showing the predicted rank values for each player and saves the resulting image to a file. The plot includes player names, predicted rank values, and a reference line at zero. (The function now focuses on plotting predicted ranks, not the difference between predicted and actual ranks.)",
            "mapping": [
                {
                    "summaryComponent": "The plot_ranking_predictions function",
                    "codeSegments": [
                        {
                            "line": 67,
                            "code": "def plot_ranking_predictions(df, year):"
                        }
                    ]
                },
                {
                    "summaryComponent": "visualizes the predicted ranks for each player in a specified year",
                    "codeSegments": [
                        {
                            "line": 75,
                            "code": "year_df = df[df[\"Year\"] == year].copy()"
                        },
                        {
                            "line": 76,
                            "code": "year_df.sort_values(\"PredictedRank\", inplace=True)"
                        }
                    ]
                },
                {
                    "summaryComponent": "It creates a bar plot showing the predicted rank values for each player",
                    "codeSegments": [
                        {
                            "line": 79,
                            "code": "sns.barplot(x=\"Name\", y=\"PredictedRank\", data=year_df, hue=\"Name\", palette=\"coolwarm\", dodge=True)"
                        }
                    ]
                },
                {
                    "summaryComponent": "and saves the resulting image to a file",
                    "codeSegments": [
                        {
                            "line": 85,
                            "code": "plt.savefig(f\"data/ranking_predictions_{year}.png\")"
                        }
                    ]
                },
                {
                    "summaryComponent": "The plot includes player names",
                    "codeSegments": [
                        {
                            "line": 79,
                            "code": "sns.barplot(x=\"Name\", y=\"PredictedRank\", data=year_df, hue=\"Name\", palette=\"coolwarm\", dodge=True)"
                        }
                    ]
                },
                {
                    "summaryComponent": "predicted rank values",
                    "codeSegments": [
                        {
                            "line": 79,
                            "code": "sns.barplot(x=\"Name\", y=\"PredictedRank\", data=year_df, hue=\"Name\", palette=\"coolwarm\", dodge=True)"
                        }
                    ]
                },
                {
                    "summaryComponent": "and a reference line at zero",
                    "codeSegments": [
                        {
                            "line": 80,
                            "code": "plt.axhline(0, color=\"black\", linestyle=\"--\")"
                        }
                    ]
                },
                {
                    "summaryComponent": "The function now focuses on plotting predicted ranks",
                    "codeSegments": [
                        {
                            "line": 79,
                            "code": "sns.barplot(x=\"Name\", y=\"PredictedRank\", data=year_df, hue=\"Name\", palette=\"coolwarm\", dodge=True)"
                        }
                    ]
                },
                {
                    "summaryComponent": "not the difference between predicted and actual ranks",
                    "codeSegments": [
                        {
                            "line": 79,
                            "code": "sns.barplot(x=\"Name\", y=\"PredictedRank\", data=year_df, hue=\"Name\", palette=\"coolwarm\", dodge=True)"
                        }
                    ]
                }
            ],
            "code": "67: def plot_ranking_predictions(df, year):\n68:     \"\"\"\n69:     Plot predicted ranks for a specific year.\n70: \n71:     Args:\n72:         df: DataFrame containing prediction results\n73:         year: Year to plot predicted ranks for\n74:     \"\"\"\n75:     year_df = df[df[\"Year\"] == year].copy()\n76:     year_df.sort_values(\"PredictedRank\", inplace=True)\n77: \n78:     plt.figure(figsize=(12, 6))\n79:     sns.barplot(x=\"Name\", y=\"PredictedRank\", data=year_df, hue=\"Name\", palette=\"coolwarm\", dodge=True)\n80:     plt.axhline(0, color=\"black\", linestyle=\"--\")\n81:     plt.xticks(rotation=45, ha=\"right\")\n82:     plt.ylabel(\"Predicted Rank\")\n83:     plt.title(f\"MVP Predicted Rankings ({year})\")\n84:     plt.tight_layout()\n85:     plt.savefig(f\"data/ranking_predictions_{year}.png\")"
        },
        "timestamp": "2025-08-16 23:09:27.000",
        "id": "DZFloRtZzJqHWyz8e11C"
    },
    {
        "source": "backend",
        "event": "map_summary_code",
        "data": {
            "summary": "This function plots and saves the predicted ranks for players in a specified year, displaying predicted rank values rather than prediction errors. (The function now plots predicted ranks directly instead of errors.)",
            "mapping": [
                {
                    "summaryComponent": "plots and saves the predicted ranks",
                    "codeSegments": [
                        {
                            "line": 78,
                            "code": "plt.figure(figsize=(12, 6))"
                        },
                        {
                            "line": 79,
                            "code": "sns.barplot(x=\"Name\", y=\"PredictedRank\", data=year_df, hue=\"Name\", palette=\"coolwarm\", dodge=True)"
                        },
                        {
                            "line": 85,
                            "code": "plt.savefig(f\"data/ranking_predictions_{year}.png\")"
                        }
                    ]
                },
                {
                    "summaryComponent": "for players in a specified year",
                    "codeSegments": [
                        {
                            "line": 67,
                            "code": "def plot_ranking_predictions(df, year):"
                        },
                        {
                            "line": 75,
                            "code": "year_df = df[df[\"Year\"] == year].copy()"
                        }
                    ]
                },
                {
                    "summaryComponent": "displaying predicted rank values",
                    "codeSegments": [
                        {
                            "line": 79,
                            "code": "sns.barplot(x=\"Name\", y=\"PredictedRank\", data=year_df, hue=\"Name\", palette=\"coolwarm\", dodge=True)"
                        },
                        {
                            "line": 82,
                            "code": "plt.ylabel(\"Predicted Rank\")"
                        }
                    ]
                },
                {
                    "summaryComponent": "rather than prediction errors",
                    "codeSegments": [
                        {
                            "line": 79,
                            "code": "sns.barplot(x=\"Name\", y=\"PredictedRank\", data=year_df, hue=\"Name\", palette=\"coolwarm\", dodge=True)"
                        }
                    ]
                },
                {
                    "summaryComponent": "plots predicted ranks directly instead of errors",
                    "codeSegments": [
                        {
                            "line": 79,
                            "code": "sns.barplot(x=\"Name\", y=\"PredictedRank\", data=year_df, hue=\"Name\", palette=\"coolwarm\", dodge=True)"
                        }
                    ]
                }
            ],
            "code": "67: def plot_ranking_predictions(df, year):\n68:     \"\"\"\n69:     Plot predicted ranks for a specific year.\n70: \n71:     Args:\n72:         df: DataFrame containing prediction results\n73:         year: Year to plot predicted ranks for\n74:     \"\"\"\n75:     year_df = df[df[\"Year\"] == year].copy()\n76:     year_df.sort_values(\"PredictedRank\", inplace=True)\n77: \n78:     plt.figure(figsize=(12, 6))\n79:     sns.barplot(x=\"Name\", y=\"PredictedRank\", data=year_df, hue=\"Name\", palette=\"coolwarm\", dodge=True)\n80:     plt.axhline(0, color=\"black\", linestyle=\"--\")\n81:     plt.xticks(rotation=45, ha=\"right\")\n82:     plt.ylabel(\"Predicted Rank\")\n83:     plt.title(f\"MVP Predicted Rankings ({year})\")\n84:     plt.tight_layout()\n85:     plt.savefig(f\"data/ranking_predictions_{year}.png\")"
        },
        "timestamp": "2025-08-16 23:09:27.000",
        "id": "MRhzFDI8w0n9K5a0BsSb"
    },
    {
        "source": "backend",
        "event": "map_summary_code",
        "data": {
            "summary": "The plot_ranking_predictions function generates a bar plot to visualize the predicted rank for each player in a specified year. It filters the DataFrame for the given year, sorts the data by predicted rank, and uses Seaborn to create a colored bar plot with player names on the x-axis and predicted rank values on the y-axis, adding a horizontal line at zero for reference. The plot is formatted for readability and saved as a PNG file named according to the year. (The function now plots predicted ranks instead of the prediction error between predicted and actual ranks.)",
            "mapping": [
                {
                    "summaryComponent": "The plot_ranking_predictions function generates a bar plot to visualize the predicted rank for each player in a specified year.",
                    "codeSegments": [
                        {
                            "line": 67,
                            "code": "def plot_ranking_predictions(df, year):"
                        },
                        {
                            "line": 79,
                            "code": "sns.barplot(x=\"Name\", y=\"PredictedRank\", data=year_df, hue=\"Name\", palette=\"coolwarm\", dodge=True)"
                        }
                    ]
                },
                {
                    "summaryComponent": "It filters the DataFrame for the given year",
                    "codeSegments": [
                        {
                            "line": 75,
                            "code": "year_df = df[df[\"Year\"] == year].copy()"
                        }
                    ]
                },
                {
                    "summaryComponent": "sorts the data by predicted rank",
                    "codeSegments": [
                        {
                            "line": 76,
                            "code": "year_df.sort_values(\"PredictedRank\", inplace=True)"
                        }
                    ]
                },
                {
                    "summaryComponent": "uses Seaborn to create a colored bar plot with player names on the x-axis and predicted rank values on the y-axis",
                    "codeSegments": [
                        {
                            "line": 79,
                            "code": "sns.barplot(x=\"Name\", y=\"PredictedRank\", data=year_df, hue=\"Name\", palette=\"coolwarm\", dodge=True)"
                        }
                    ]
                },
                {
                    "summaryComponent": "adding a horizontal line at zero for reference",
                    "codeSegments": [
                        {
                            "line": 80,
                            "code": "plt.axhline(0, color=\"black\", linestyle=\"--\")"
                        }
                    ]
                },
                {
                    "summaryComponent": "The plot is formatted for readability",
                    "codeSegments": [
                        {
                            "line": 81,
                            "code": "plt.xticks(rotation=45, ha=\"right\")"
                        },
                        {
                            "line": 82,
                            "code": "plt.ylabel(\"Predicted Rank\")"
                        },
                        {
                            "line": 83,
                            "code": "plt.title(f\"MVP Predicted Rankings ({year})\")"
                        },
                        {
                            "line": 84,
                            "code": "plt.tight_layout()"
                        }
                    ]
                },
                {
                    "summaryComponent": "saved as a PNG file named according to the year",
                    "codeSegments": [
                        {
                            "line": 85,
                            "code": "plt.savefig(f\"data/ranking_predictions_{year}.png\")"
                        }
                    ]
                },
                {
                    "summaryComponent": "The function now plots predicted ranks instead of the prediction error between predicted and actual ranks.",
                    "codeSegments": [
                        {
                            "line": 79,
                            "code": "sns.barplot(x=\"Name\", y=\"PredictedRank\", data=year_df, hue=\"Name\", palette=\"coolwarm\", dodge=True)"
                        }
                    ]
                }
            ],
            "code": "67: def plot_ranking_predictions(df, year):\n68:     \"\"\"\n69:     Plot predicted ranks for a specific year.\n70: \n71:     Args:\n72:         df: DataFrame containing prediction results\n73:         year: Year to plot predicted ranks for\n74:     \"\"\"\n75:     year_df = df[df[\"Year\"] == year].copy()\n76:     year_df.sort_values(\"PredictedRank\", inplace=True)\n77: \n78:     plt.figure(figsize=(12, 6))\n79:     sns.barplot(x=\"Name\", y=\"PredictedRank\", data=year_df, hue=\"Name\", palette=\"coolwarm\", dodge=True)\n80:     plt.axhline(0, color=\"black\", linestyle=\"--\")\n81:     plt.xticks(rotation=45, ha=\"right\")\n82:     plt.ylabel(\"Predicted Rank\")\n83:     plt.title(f\"MVP Predicted Rankings ({year})\")\n84:     plt.tight_layout()\n85:     plt.savefig(f\"data/ranking_predictions_{year}.png\")"
        },
        "timestamp": "2025-08-16 23:09:27.000",
        "id": "OM0SfHoLYYZGHg4n6v9V"
    },
    {
        "source": "backend",
        "event": "map_summary_code",
        "data": {
            "summary": "• Filters the DataFrame to include only rows from the specified year and sorts them by predicted rank\n• Sets up a matplotlib figure with a specific size\n• Creates a Seaborn bar plot:\n  ◦ x-axis: Player names\n  ◦ y-axis: PredictedRank values\n  ◦ Hue: Player names for color distinction\n  ◦ Palette: 'coolwarm' for visual contrast\n• Adds a horizontal dashed line at y=0 to indicate a reference\n• Rotates x-axis labels for better readability\n• Sets axis labels and a descriptive plot title indicating the year\n• Adjusts layout for clarity and saves the figure as 'data/ranking_predictions_{year}.png'\n• The function now visualizes predicted ranks directly, not the difference between predicted and actual ranks.",
            "mapping": [
                {
                    "summaryComponent": "Filters the DataFrame to include only rows from the specified year and sorts them by predicted rank",
                    "codeSegments": [
                        {
                            "line": 75,
                            "code": "year_df = df[df[\"Year\"] == year].copy()"
                        },
                        {
                            "line": 76,
                            "code": "year_df.sort_values(\"PredictedRank\", inplace=True)"
                        }
                    ]
                },
                {
                    "summaryComponent": "Sets up a matplotlib figure with a specific size",
                    "codeSegments": [
                        {
                            "line": 78,
                            "code": "plt.figure(figsize=(12, 6))"
                        }
                    ]
                },
                {
                    "summaryComponent": "Creates a Seaborn bar plot:",
                    "codeSegments": [
                        {
                            "line": 79,
                            "code": "sns.barplot(x=\"Name\", y=\"PredictedRank\", data=year_df, hue=\"Name\", palette=\"coolwarm\", dodge=True)"
                        }
                    ]
                },
                {
                    "summaryComponent": "x-axis: Player names",
                    "codeSegments": [
                        {
                            "line": 79,
                            "code": "x=\"Name\""
                        }
                    ]
                },
                {
                    "summaryComponent": "y-axis: PredictedRank values",
                    "codeSegments": [
                        {
                            "line": 79,
                            "code": "y=\"PredictedRank\""
                        }
                    ]
                },
                {
                    "summaryComponent": "Hue: Player names for color distinction",
                    "codeSegments": [
                        {
                            "line": 79,
                            "code": "hue=\"Name\""
                        }
                    ]
                },
                {
                    "summaryComponent": "Palette: 'coolwarm' for visual contrast",
                    "codeSegments": [
                        {
                            "line": 79,
                            "code": "palette=\"coolwarm\""
                        }
                    ]
                },
                {
                    "summaryComponent": "Adds a horizontal dashed line at y=0 to indicate a reference",
                    "codeSegments": [
                        {
                            "line": 80,
                            "code": "plt.axhline(0, color=\"black\", linestyle=\"--\")"
                        }
                    ]
                },
                {
                    "summaryComponent": "Rotates x-axis labels for better readability",
                    "codeSegments": [
                        {
                            "line": 81,
                            "code": "plt.xticks(rotation=45, ha=\"right\")"
                        }
                    ]
                },
                {
                    "summaryComponent": "Sets axis labels and a descriptive plot title indicating the year",
                    "codeSegments": [
                        {
                            "line": 82,
                            "code": "plt.ylabel(\"Predicted Rank\")"
                        },
                        {
                            "line": 83,
                            "code": "plt.title(f\"MVP Predicted Rankings ({year})\")"
                        }
                    ]
                },
                {
                    "summaryComponent": "Adjusts layout for clarity and saves the figure as 'data/ranking_predictions_{year}.png'",
                    "codeSegments": [
                        {
                            "line": 84,
                            "code": "plt.tight_layout()"
                        },
                        {
                            "line": 85,
                            "code": "plt.savefig(f\"data/ranking_predictions_{year}.png\")"
                        }
                    ]
                },
                {
                    "summaryComponent": "The function now visualizes predicted ranks directly, not the difference between predicted and actual ranks.",
                    "codeSegments": [
                        {
                            "line": 79,
                            "code": "y=\"PredictedRank\""
                        }
                    ]
                }
            ],
            "code": "67: def plot_ranking_predictions(df, year):\n68:     \"\"\"\n69:     Plot predicted ranks for a specific year.\n70: \n71:     Args:\n72:         df: DataFrame containing prediction results\n73:         year: Year to plot predicted ranks for\n74:     \"\"\"\n75:     year_df = df[df[\"Year\"] == year].copy()\n76:     year_df.sort_values(\"PredictedRank\", inplace=True)\n77: \n78:     plt.figure(figsize=(12, 6))\n79:     sns.barplot(x=\"Name\", y=\"PredictedRank\", data=year_df, hue=\"Name\", palette=\"coolwarm\", dodge=True)\n80:     plt.axhline(0, color=\"black\", linestyle=\"--\")\n81:     plt.xticks(rotation=45, ha=\"right\")\n82:     plt.ylabel(\"Predicted Rank\")\n83:     plt.title(f\"MVP Predicted Rankings ({year})\")\n84:     plt.tight_layout()\n85:     plt.savefig(f\"data/ranking_predictions_{year}.png\")"
        },
        "timestamp": "2025-08-16 23:09:28.000",
        "id": "RpSXc7MS0qh69wM1HQgP"
    },
    {
        "source": "frontend",
        "event": "create_new_section",
        "data": {
            "section_id": "7389693e-0ca3-458e-9bce-3fc0b6b2bafd",
            "section_data": {
                "editPromptDetailLevel": null,
                "selectedStructured": "unstructured",
                "createdAt": 1755371368000,
                "lines": [
                    67,
                    85
                ],
                "editPromptStructured": null,
                "summaryData": {
                    "low_structured": "• Plots predicted ranks for a given year\n• Saves the plot as an image file\n• The function now visualizes predicted ranks directly instead of prediction errors.",
                    "high_unstructured": "The plot_ranking_predictions function generates a bar plot to visualize the predicted rank for each player in a specified year. It filters the DataFrame for the given year, sorts the data by predicted rank, and uses Seaborn to create a colored bar plot with player names on the x-axis and predicted rank values on the y-axis, adding a horizontal line at zero for reference. The plot is formatted for readability and saved as a PNG file named according to the year. (The function now plots predicted ranks instead of the prediction error between predicted and actual ranks.)",
                    "medium_unstructured": "The plot_ranking_predictions function visualizes the predicted ranks for each player in a specified year. It creates a bar plot showing the predicted rank values for each player and saves the resulting image to a file. The plot includes player names, predicted rank values, and a reference line at zero. (The function now focuses on plotting predicted ranks, not the difference between predicted and actual ranks.)",
                    "high_structured": "• Filters the DataFrame to include only rows from the specified year and sorts them by predicted rank\n• Sets up a matplotlib figure with a specific size\n• Creates a Seaborn bar plot:\n  ◦ x-axis: Player names\n  ◦ y-axis: PredictedRank values\n  ◦ Hue: Player names for color distinction\n  ◦ Palette: 'coolwarm' for visual contrast\n• Adds a horizontal dashed line at y=0 to indicate a reference\n• Rotates x-axis labels for better readability\n• Sets axis labels and a descriptive plot title indicating the year\n• Adjusts layout for clarity and saves the figure as 'data/ranking_predictions_{year}.png'\n• The function now visualizes predicted ranks directly, not the difference between predicted and actual ranks.",
                    "title": "Function: plot_ranking_predictions",
                    "low_unstructured": "This function plots and saves the predicted ranks for players in a specified year, displaying predicted rank values rather than prediction errors. (The function now plots predicted ranks directly instead of errors.)",
                    "medium_structured": "• Filters data for the specified year and sorts by predicted rank\n• Creates a bar plot of predicted ranks for each player\n  ◦ Uses player names as labels and colors\n• Adds a horizontal reference line and saves the plot as a PNG file\n• The function now plots predicted ranks directly, rather than prediction errors."
                },
                "selectedDetailLevel": "medium",
                "oldSummaryData": {
                    "low_structured": "• Plots prediction errors for a given year\n• Saves the plot as an image file\n• (No changes were made to the function.)",
                    "high_unstructured": "The plot_ranking_predictions function generates a bar plot to visualize the prediction error (PredictedRank minus actual Rank) for each player in a specified year. It first computes the rank error, filters the DataFrame for the given year, and sorts the data by true rank to ensure a consistent order. Using Seaborn, it creates a colored bar plot with player names on the x-axis and prediction errors on the y-axis, adding a horizontal line at zero for reference. The plot is formatted for readability and saved as a PNG file named according to the year. (No changes were made to the function.)",
                    "medium_unstructured": "The plot_ranking_predictions function visualizes the difference between predicted and actual ranks for each player in a specified year. It creates a bar plot showing these errors and saves the resulting image to a file. The plot includes player names, error values, and a reference line at zero. (There are no changes from the previous version.)",
                    "high_structured": "• Computes the 'RankError' column as the difference between 'PredictedRank' and 'Rank' for each entry\n• Filters the DataFrame to include only rows from the specified year and sorts them by actual rank\n• Sets up a matplotlib figure with a specific size\n• Creates a Seaborn bar plot:\n  ◦ x-axis: Player names\n  ◦ y-axis: RankError values\n  ◦ Hue: Player names for color distinction\n  ◦ Palette: 'coolwarm' for visual contrast\n• Adds a horizontal dashed line at y=0 to indicate no error\n• Rotates x-axis labels for better readability\n• Sets axis labels and a descriptive plot title indicating the year\n• Adjusts layout for clarity and saves the figure as 'data/ranking_predictions_{year}.png'\n• (No changes were made to the function.)",
                    "title": "Function: plot_ranking_predictions",
                    "low_unstructured": "This function plots and saves the prediction errors for player rankings in a specified year. (No changes were made to the function.)",
                    "medium_structured": "• Calculates prediction error as the difference between predicted and actual ranks\n• Filters data for the specified year and sorts by true rank\n• Creates a bar plot of prediction errors for each player\n  ◦ Uses player names as labels and colors\n• Adds a horizontal reference line and saves the plot as a PNG file\n• (No changes were made to the function.)"
                },
                "metadata": {
                    "originalCode": "def plot_ranking_predictions(df, year):\n    \"\"\"\n    Plot predicted ranks for a specific year.\n\n    Args:\n        df: DataFrame containing prediction results\n        year: Year to plot predicted ranks for\n    \"\"\"\n    year_df = df[df[\"Year\"] == year].copy()\n    year_df.sort_values(\"PredictedRank\", inplace=True)\n\n    plt.figure(figsize=(12, 6))\n    sns.barplot(x=\"Name\", y=\"PredictedRank\", data=year_df, hue=\"Name\", palette=\"coolwarm\", dodge=True)\n    plt.axhline(0, color=\"black\", linestyle=\"--\")\n    plt.xticks(rotation=45, ha=\"right\")\n    plt.ylabel(\"Predicted Rank\")\n    plt.title(f\"MVP Predicted Rankings ({year})\")\n    plt.tight_layout()\n    plt.savefig(f\"data/ranking_predictions_{year}.png\")",
                    "fullPath": "/project/workspace/rank_model.py",
                    "id": "7389693e-0ca3-458e-9bce-3fc0b6b2bafd",
                    "offset": 1496,
                    "filename": "rank_model.py"
                },
                "editPromptValue": "",
                "title": "Function: plot_ranking_predictions",
                "summaryMappings": {
                    "high_unstructured": [
                        {
                            "summaryComponent": "The plot_ranking_predictions function generates a bar plot to visualize the predicted rank for each player in a specified year.",
                            "codeSegments": [
                                {
                                    "line": 67,
                                    "code": "def plot_ranking_predictions(df, year):"
                                },
                                {
                                    "line": 79,
                                    "code": "sns.barplot(x=\"Name\", y=\"PredictedRank\", data=year_df, hue=\"Name\", palette=\"coolwarm\", dodge=True)"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "It filters the DataFrame for the given year",
                            "codeSegments": [
                                {
                                    "line": 75,
                                    "code": "year_df = df[df[\"Year\"] == year].copy()"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "sorts the data by predicted rank",
                            "codeSegments": [
                                {
                                    "line": 76,
                                    "code": "year_df.sort_values(\"PredictedRank\", inplace=True)"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "uses Seaborn to create a colored bar plot with player names on the x-axis and predicted rank values on the y-axis",
                            "codeSegments": [
                                {
                                    "line": 79,
                                    "code": "sns.barplot(x=\"Name\", y=\"PredictedRank\", data=year_df, hue=\"Name\", palette=\"coolwarm\", dodge=True)"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "adding a horizontal line at zero for reference",
                            "codeSegments": [
                                {
                                    "line": 80,
                                    "code": "plt.axhline(0, color=\"black\", linestyle=\"--\")"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "The plot is formatted for readability",
                            "codeSegments": [
                                {
                                    "line": 81,
                                    "code": "plt.xticks(rotation=45, ha=\"right\")"
                                },
                                {
                                    "line": 82,
                                    "code": "plt.ylabel(\"Predicted Rank\")"
                                },
                                {
                                    "line": 83,
                                    "code": "plt.title(f\"MVP Predicted Rankings ({year})\")"
                                },
                                {
                                    "line": 84,
                                    "code": "plt.tight_layout()"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "saved as a PNG file named according to the year",
                            "codeSegments": [
                                {
                                    "line": 85,
                                    "code": "plt.savefig(f\"data/ranking_predictions_{year}.png\")"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "The function now plots predicted ranks instead of the prediction error between predicted and actual ranks.",
                            "codeSegments": [
                                {
                                    "line": 79,
                                    "code": "sns.barplot(x=\"Name\", y=\"PredictedRank\", data=year_df, hue=\"Name\", palette=\"coolwarm\", dodge=True)"
                                }
                            ]
                        }
                    ],
                    "medium_unstructured": [
                        {
                            "summaryComponent": "The plot_ranking_predictions function",
                            "codeSegments": [
                                {
                                    "line": 67,
                                    "code": "def plot_ranking_predictions(df, year):"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "visualizes the predicted ranks for each player in a specified year",
                            "codeSegments": [
                                {
                                    "line": 75,
                                    "code": "year_df = df[df[\"Year\"] == year].copy()"
                                },
                                {
                                    "line": 76,
                                    "code": "year_df.sort_values(\"PredictedRank\", inplace=True)"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "It creates a bar plot showing the predicted rank values for each player",
                            "codeSegments": [
                                {
                                    "line": 79,
                                    "code": "sns.barplot(x=\"Name\", y=\"PredictedRank\", data=year_df, hue=\"Name\", palette=\"coolwarm\", dodge=True)"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "and saves the resulting image to a file",
                            "codeSegments": [
                                {
                                    "line": 85,
                                    "code": "plt.savefig(f\"data/ranking_predictions_{year}.png\")"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "The plot includes player names",
                            "codeSegments": [
                                {
                                    "line": 79,
                                    "code": "sns.barplot(x=\"Name\", y=\"PredictedRank\", data=year_df, hue=\"Name\", palette=\"coolwarm\", dodge=True)"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "predicted rank values",
                            "codeSegments": [
                                {
                                    "line": 79,
                                    "code": "sns.barplot(x=\"Name\", y=\"PredictedRank\", data=year_df, hue=\"Name\", palette=\"coolwarm\", dodge=True)"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "and a reference line at zero",
                            "codeSegments": [
                                {
                                    "line": 80,
                                    "code": "plt.axhline(0, color=\"black\", linestyle=\"--\")"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "The function now focuses on plotting predicted ranks",
                            "codeSegments": [
                                {
                                    "line": 79,
                                    "code": "sns.barplot(x=\"Name\", y=\"PredictedRank\", data=year_df, hue=\"Name\", palette=\"coolwarm\", dodge=True)"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "not the difference between predicted and actual ranks",
                            "codeSegments": [
                                {
                                    "line": 79,
                                    "code": "sns.barplot(x=\"Name\", y=\"PredictedRank\", data=year_df, hue=\"Name\", palette=\"coolwarm\", dodge=True)"
                                }
                            ]
                        }
                    ],
                    "high_structured": [
                        {
                            "summaryComponent": "Filters the DataFrame to include only rows from the specified year and sorts them by predicted rank",
                            "codeSegments": [
                                {
                                    "line": 75,
                                    "code": "year_df = df[df[\"Year\"] == year].copy()"
                                },
                                {
                                    "line": 76,
                                    "code": "year_df.sort_values(\"PredictedRank\", inplace=True)"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "Sets up a matplotlib figure with a specific size",
                            "codeSegments": [
                                {
                                    "line": 78,
                                    "code": "plt.figure(figsize=(12, 6))"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "Creates a Seaborn bar plot:",
                            "codeSegments": [
                                {
                                    "line": 79,
                                    "code": "sns.barplot(x=\"Name\", y=\"PredictedRank\", data=year_df, hue=\"Name\", palette=\"coolwarm\", dodge=True)"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "x-axis: Player names",
                            "codeSegments": [
                                {
                                    "line": 79,
                                    "code": "x=\"Name\""
                                }
                            ]
                        },
                        {
                            "summaryComponent": "y-axis: PredictedRank values",
                            "codeSegments": [
                                {
                                    "line": 79,
                                    "code": "y=\"PredictedRank\""
                                }
                            ]
                        },
                        {
                            "summaryComponent": "Hue: Player names for color distinction",
                            "codeSegments": [
                                {
                                    "line": 79,
                                    "code": "hue=\"Name\""
                                }
                            ]
                        },
                        {
                            "summaryComponent": "Palette: 'coolwarm' for visual contrast",
                            "codeSegments": [
                                {
                                    "line": 79,
                                    "code": "palette=\"coolwarm\""
                                }
                            ]
                        },
                        {
                            "summaryComponent": "Adds a horizontal dashed line at y=0 to indicate a reference",
                            "codeSegments": [
                                {
                                    "line": 80,
                                    "code": "plt.axhline(0, color=\"black\", linestyle=\"--\")"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "Rotates x-axis labels for better readability",
                            "codeSegments": [
                                {
                                    "line": 81,
                                    "code": "plt.xticks(rotation=45, ha=\"right\")"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "Sets axis labels and a descriptive plot title indicating the year",
                            "codeSegments": [
                                {
                                    "line": 82,
                                    "code": "plt.ylabel(\"Predicted Rank\")"
                                },
                                {
                                    "line": 83,
                                    "code": "plt.title(f\"MVP Predicted Rankings ({year})\")"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "Adjusts layout for clarity and saves the figure as 'data/ranking_predictions_{year}.png'",
                            "codeSegments": [
                                {
                                    "line": 84,
                                    "code": "plt.tight_layout()"
                                },
                                {
                                    "line": 85,
                                    "code": "plt.savefig(f\"data/ranking_predictions_{year}.png\")"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "The function now visualizes predicted ranks directly, not the difference between predicted and actual ranks.",
                            "codeSegments": [
                                {
                                    "line": 79,
                                    "code": "y=\"PredictedRank\""
                                }
                            ]
                        }
                    ],
                    "low_unstructured": [
                        {
                            "summaryComponent": "plots and saves the predicted ranks",
                            "codeSegments": [
                                {
                                    "line": 78,
                                    "code": "plt.figure(figsize=(12, 6))"
                                },
                                {
                                    "line": 79,
                                    "code": "sns.barplot(x=\"Name\", y=\"PredictedRank\", data=year_df, hue=\"Name\", palette=\"coolwarm\", dodge=True)"
                                },
                                {
                                    "line": 85,
                                    "code": "plt.savefig(f\"data/ranking_predictions_{year}.png\")"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "for players in a specified year",
                            "codeSegments": [
                                {
                                    "line": 67,
                                    "code": "def plot_ranking_predictions(df, year):"
                                },
                                {
                                    "line": 75,
                                    "code": "year_df = df[df[\"Year\"] == year].copy()"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "displaying predicted rank values",
                            "codeSegments": [
                                {
                                    "line": 79,
                                    "code": "sns.barplot(x=\"Name\", y=\"PredictedRank\", data=year_df, hue=\"Name\", palette=\"coolwarm\", dodge=True)"
                                },
                                {
                                    "line": 82,
                                    "code": "plt.ylabel(\"Predicted Rank\")"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "rather than prediction errors",
                            "codeSegments": [
                                {
                                    "line": 79,
                                    "code": "sns.barplot(x=\"Name\", y=\"PredictedRank\", data=year_df, hue=\"Name\", palette=\"coolwarm\", dodge=True)"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "plots predicted ranks directly instead of errors",
                            "codeSegments": [
                                {
                                    "line": 79,
                                    "code": "sns.barplot(x=\"Name\", y=\"PredictedRank\", data=year_df, hue=\"Name\", palette=\"coolwarm\", dodge=True)"
                                }
                            ]
                        }
                    ],
                    "low_structured": [
                        {
                            "summaryComponent": "Plots predicted ranks for a given year",
                            "codeSegments": [
                                {
                                    "line": 67,
                                    "code": "def plot_ranking_predictions(df, year):"
                                },
                                {
                                    "line": 78,
                                    "code": "plt.figure(figsize=(12, 6))"
                                },
                                {
                                    "line": 79,
                                    "code": "sns.barplot(x=\"Name\", y=\"PredictedRank\", data=year_df, hue=\"Name\", palette=\"coolwarm\", dodge=True)"
                                },
                                {
                                    "line": 83,
                                    "code": "plt.title(f\"MVP Predicted Rankings ({year})\")"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "Saves the plot as an image file",
                            "codeSegments": [
                                {
                                    "line": 85,
                                    "code": "plt.savefig(f\"data/ranking_predictions_{year}.png\")"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "The function now visualizes predicted ranks directly instead of prediction errors.",
                            "codeSegments": [
                                {
                                    "line": 79,
                                    "code": "sns.barplot(x=\"Name\", y=\"PredictedRank\", data=year_df, hue=\"Name\", palette=\"coolwarm\", dodge=True)"
                                }
                            ]
                        }
                    ],
                    "medium_structured": [
                        {
                            "summaryComponent": "Filters data for the specified year and sorts by predicted rank",
                            "codeSegments": [
                                {
                                    "line": 75,
                                    "code": "year_df = df[df[\"Year\"] == year].copy()"
                                },
                                {
                                    "line": 76,
                                    "code": "year_df.sort_values(\"PredictedRank\", inplace=True)"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "Creates a bar plot of predicted ranks for each player",
                            "codeSegments": [
                                {
                                    "line": 79,
                                    "code": "sns.barplot(x=\"Name\", y=\"PredictedRank\", data=year_df, hue=\"Name\", palette=\"coolwarm\", dodge=True)"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "Uses player names as labels and colors",
                            "codeSegments": [
                                {
                                    "line": 79,
                                    "code": "sns.barplot(x=\"Name\", y=\"PredictedRank\", data=year_df, hue=\"Name\", palette=\"coolwarm\", dodge=True)"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "Adds a horizontal reference line and saves the plot as a PNG file",
                            "codeSegments": [
                                {
                                    "line": 80,
                                    "code": "plt.axhline(0, color=\"black\", linestyle=\"--\")"
                                },
                                {
                                    "line": 85,
                                    "code": "plt.savefig(f\"data/ranking_predictions_{year}.png\")"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "The function now plots predicted ranks directly, rather than prediction errors.",
                            "codeSegments": [
                                {
                                    "line": 79,
                                    "code": "sns.barplot(x=\"Name\", y=\"PredictedRank\", data=year_df, hue=\"Name\", palette=\"coolwarm\", dodge=True)"
                                }
                            ]
                        }
                    ]
                }
            }
        },
        "timestamp": "2025-08-16 23:09:29.000",
        "id": "0kji76yHSKx025g0MTnw"
    },
    {
        "source": "frontend",
        "event": "autotransit_section",
        "data": {
            "before_section_id": "97f32543-125b-451c-b300-0d1f845c01bb",
            "after_section_id": "7389693e-0ca3-458e-9bce-3fc0b6b2bafd"
        },
        "timestamp": "2025-08-16 23:09:29.000",
        "id": "G7f5CvCZ3dRJ5I13oCQ9"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "7389693e-0ca3-458e-9bce-3fc0b6b2bafd",
            "detail_level": "medium",
            "structured_type": "unstructured"
        },
        "timestamp": "2025-08-16 23:09:36.000",
        "id": "EZpbqrmRQV0iM80MAbXe"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "7389693e-0ca3-458e-9bce-3fc0b6b2bafd",
            "mapping_index": 8,
            "structured_type": "unstructured",
            "detail_level": "medium"
        },
        "timestamp": "2025-08-16 23:09:36.000",
        "id": "PLsMgwb0bWCJxnUWDH1s"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "7389693e-0ca3-458e-9bce-3fc0b6b2bafd",
            "mapping_index": 7,
            "structured_type": "unstructured",
            "detail_level": "medium"
        },
        "timestamp": "2025-08-16 23:09:46.000",
        "id": "4flJVvx1cJJ3BEDvtzGN"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "7389693e-0ca3-458e-9bce-3fc0b6b2bafd",
            "detail_level": "medium",
            "structured_type": "unstructured"
        },
        "timestamp": "2025-08-16 23:09:46.000",
        "id": "6HWTGghIVVAf9ESGHJdL"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "7389693e-0ca3-458e-9bce-3fc0b6b2bafd",
            "mapping_index": 3,
            "structured_type": "unstructured",
            "detail_level": "medium"
        },
        "timestamp": "2025-08-16 23:10:30.000",
        "id": "Yo782pulSJL3eGX0sfai"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "7389693e-0ca3-458e-9bce-3fc0b6b2bafd",
            "detail_level": "medium",
            "structured_type": "unstructured"
        },
        "timestamp": "2025-08-16 23:10:30.000",
        "id": "k2RpupKg9Mbo5WohGZfu"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "7389693e-0ca3-458e-9bce-3fc0b6b2bafd",
            "detail_level": "medium",
            "structured_type": "unstructured"
        },
        "timestamp": "2025-08-16 23:10:31.000",
        "id": "00h3TretCPcaRDC48a9F"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "7389693e-0ca3-458e-9bce-3fc0b6b2bafd",
            "detail_level": "medium",
            "structured_type": "unstructured"
        },
        "timestamp": "2025-08-16 23:10:31.000",
        "id": "BOP1iIgET1llOfak3YJq"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "7389693e-0ca3-458e-9bce-3fc0b6b2bafd",
            "mapping_index": 8,
            "structured_type": "unstructured",
            "detail_level": "medium"
        },
        "timestamp": "2025-08-16 23:10:31.000",
        "id": "Nv43vwA6Qxe9vJV3QeGX"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "7389693e-0ca3-458e-9bce-3fc0b6b2bafd",
            "mapping_index": 2,
            "structured_type": "unstructured",
            "detail_level": "medium"
        },
        "timestamp": "2025-08-16 23:10:31.000",
        "id": "S1L8pgFj4VZIlWRWX4Jd"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "7389693e-0ca3-458e-9bce-3fc0b6b2bafd",
            "detail_level": "medium",
            "structured_type": "unstructured"
        },
        "timestamp": "2025-08-16 23:10:31.000",
        "id": "tIxrJAi4oLz2aZ9xWWdu"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "7389693e-0ca3-458e-9bce-3fc0b6b2bafd",
            "mapping_index": 4,
            "structured_type": "unstructured",
            "detail_level": "medium"
        },
        "timestamp": "2025-08-16 23:10:31.000",
        "id": "yf0690fX5ZH1mI5ot0Nd"
    },
    {
        "source": "frontend",
        "event": "click_edit_in_prompt",
        "data": {
            "section_id": "7389693e-0ca3-458e-9bce-3fc0b6b2bafd",
            "summary": "The plot_ranking_predictions function visualizes the predicted ranks for each player in a specified year. It creates a bar plot showing the predicted rank values for each player and saves the resulting image to a file. The plot includes player names, predicted rank values, and a reference line at zero. (The function now focuses on plotting predicted ranks, not the difference between predicted and actual ranks.)",
            "detail_level": "medium",
            "structured": "unstructured"
        },
        "timestamp": "2025-08-16 23:10:32.000",
        "id": "3VT34o3L16RSYzwN6TTt"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "7389693e-0ca3-458e-9bce-3fc0b6b2bafd",
            "mapping_index": 4,
            "structured_type": "unstructured",
            "detail_level": "medium"
        },
        "timestamp": "2025-08-16 23:10:32.000",
        "id": "DeM06P58oz5uhiJrLR0H"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "7389693e-0ca3-458e-9bce-3fc0b6b2bafd",
            "detail_level": "medium",
            "structured_type": "unstructured"
        },
        "timestamp": "2025-08-16 23:10:32.000",
        "id": "Ovzu17HC9jmVsvuWiwen"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "7389693e-0ca3-458e-9bce-3fc0b6b2bafd",
            "mapping_index": 8,
            "structured_type": "unstructured",
            "detail_level": "medium"
        },
        "timestamp": "2025-08-16 23:10:32.000",
        "id": "hB0NfnoZ8tm1pf0CrUNd"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "7389693e-0ca3-458e-9bce-3fc0b6b2bafd",
            "detail_level": "medium",
            "structured_type": "unstructured"
        },
        "timestamp": "2025-08-16 23:10:32.000",
        "id": "p4YmN2ceEWDE2MoVzMc7"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "7389693e-0ca3-458e-9bce-3fc0b6b2bafd",
            "mapping_index": 2,
            "structured_type": "unstructured",
            "detail_level": "medium"
        },
        "timestamp": "2025-08-16 23:10:32.000",
        "id": "rhWqC6vPn8ubwJxOViAK"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "7389693e-0ca3-458e-9bce-3fc0b6b2bafd",
            "detail_level": "medium",
            "structured_type": "unstructured"
        },
        "timestamp": "2025-08-16 23:10:32.000",
        "id": "sA6zAKZJq6Dvw3rMl3qV"
    },
    {
        "source": "frontend",
        "event": "apply_instruction_summary",
        "data": {
            "section_id": "7389693e-0ca3-458e-9bce-3fc0b6b2bafd",
            "instruction": "visualize another stat: the true rank for each player. group the stats into a grouped bar chart",
            "detail_level": "medium",
            "original_summary": "The plot_ranking_predictions function visualizes the predicted ranks for each player in a specified year. It creates a bar plot showing the predicted rank values for each player and saves the resulting image to a file. The plot includes player names, predicted rank values, and a reference line at zero. (The function now focuses on plotting predicted ranks, not the difference between predicted and actual ranks.)",
            "structured": "unstructured"
        },
        "timestamp": "2025-08-16 23:10:49.000",
        "id": "ps7N6rjMXH5arsShCQYu"
    },
    {
        "source": "backend",
        "event": "apply_instruction_summary",
        "data": {
            "original_code": "def plot_ranking_predictions(df, year):\n    \"\"\"\n    Plot predicted ranks for a specific year.\n\n    Args:\n        df: DataFrame containing prediction results\n        year: Year to plot predicted ranks for\n    \"\"\"\n    year_df = df[df[\"Year\"] == year].copy()\n    year_df.sort_values(\"PredictedRank\", inplace=True)\n\n    plt.figure(figsize=(12, 6))\n    sns.barplot(x=\"Name\", y=\"PredictedRank\", data=year_df, hue=\"Name\", palette=\"coolwarm\", dodge=True)\n    plt.axhline(0, color=\"black\", linestyle=\"--\")\n    plt.xticks(rotation=45, ha=\"right\")\n    plt.ylabel(\"Predicted Rank\")\n    plt.title(f\"MVP Predicted Rankings ({year})\")\n    plt.tight_layout()\n    plt.savefig(f\"data/ranking_predictions_{year}.png\")",
            "original_summary": "The plot_ranking_predictions function visualizes the predicted ranks for each player in a specified year. It creates a bar plot showing the predicted rank values for each player and saves the resulting image to a file. The plot includes player names, predicted rank values, and a reference line at zero. (The function now focuses on plotting predicted ranks, not the difference between predicted and actual ranks.)",
            "instruction": "visualize another stat: the true rank for each player. group the stats into a grouped bar chart",
            "updated_summary": "The plot_ranking_predictions function visualizes the predicted ranks and the true ranks for each player in a specified year. It creates a grouped bar plot showing both the predicted rank values and the true rank values for each player, and saves the resulting image to a file. The plot includes player names, both predicted and true rank values grouped together for each player, and a reference line at zero. (The function now focuses on plotting both predicted and true ranks for each player, not the difference between predicted and actual ranks.)"
        },
        "timestamp": "2025-08-16 23:10:50.000",
        "id": "dKroRoTNMkhtyozWnI6L"
    },
    {
        "source": "frontend",
        "event": "commit_modified_summary",
        "data": {
            "section_id": "7389693e-0ca3-458e-9bce-3fc0b6b2bafd",
            "edited_summary": "The plot_ranking_predictions function visualizes the predicted ranks and the true ranks for each player in a specified year. It creates a grouped bar plot showing both the predicted rank values and the true rank values for each player, and saves the resulting image to a file. The plot includes player names, both predicted and true rank values grouped together for each player, and a reference line at zero. (The function now focuses on plotting both predicted and true ranks for each player, not the difference between predicted and actual ranks.)",
            "detail_level": "medium",
            "original_summary": "The plot_ranking_predictions function visualizes the predicted ranks for each player in a specified year. It creates a bar plot showing the predicted rank values for each player and saves the resulting image to a file. The plot includes player names, predicted rank values, and a reference line at zero. (The function now focuses on plotting predicted ranks, not the difference between predicted and actual ranks.)",
            "structured": "unstructured"
        },
        "timestamp": "2025-08-16 23:10:56.000",
        "id": "2xaM7OopHWiFjyFK1NOq"
    },
    {
        "source": "backend",
        "event": "modify_summary_mediation",
        "data": {
            "original_code": "def plot_ranking_predictions(df, year):\n    \"\"\"\n    Plot predicted ranks for a specific year.\n\n    Args:\n        df: DataFrame containing prediction results\n        year: Year to plot predicted ranks for\n    \"\"\"\n    year_df = df[df[\"Year\"] == year].copy()\n    year_df.sort_values(\"PredictedRank\", inplace=True)\n\n    plt.figure(figsize=(12, 6))\n    sns.barplot(x=\"Name\", y=\"PredictedRank\", data=year_df, hue=\"Name\", palette=\"coolwarm\", dodge=True)\n    plt.axhline(0, color=\"black\", linestyle=\"--\")\n    plt.xticks(rotation=45, ha=\"right\")\n    plt.ylabel(\"Predicted Rank\")\n    plt.title(f\"MVP Predicted Rankings ({year})\")\n    plt.tight_layout()\n    plt.savefig(f\"data/ranking_predictions_{year}.png\")",
            "original_summary": "The plot_ranking_predictions function visualizes the predicted ranks for each player in a specified year. It creates a bar plot showing the predicted rank values for each player and saves the resulting image to a file. The plot includes player names, predicted rank values, and a reference line at zero. (The function now focuses on plotting predicted ranks, not the difference between predicted and actual ranks.)",
            "edited_summary": "The plot_ranking_predictions function visualizes the predicted ranks and the true ranks for each player in a specified year. It creates a grouped bar plot showing both the predicted rank values and the true rank values for each player, and saves the resulting image to a file. The plot includes player names, both predicted and true rank values grouped together for each player, and a reference line at zero. (The function now focuses on plotting both predicted and true ranks for each player, not the difference between predicted and actual ranks.)",
            "structured_type": "unstructured",
            "detail_level": "medium",
            "updated_code": "def plot_ranking_predictions(df, year):\n    \"\"\"\n    Plot predicted and true ranks for a specific year.\n\n    Args:\n        df: DataFrame containing prediction results\n        year: Year to plot predicted and true ranks for\n    \"\"\"\n    year_df = df[df[\"Year\"] == year].copy()\n    year_df.sort_values(\"PredictedRank\", inplace=True)\n\n    # Prepare data for grouped barplot\n    plot_df = year_df[[\"Name\", \"PredictedRank\", \"Rank\"]].melt(\n        id_vars=\"Name\", value_vars=[\"PredictedRank\", \"Rank\"], \n        var_name=\"RankType\", value_name=\"RankValue\"\n    )\n\n    plt.figure(figsize=(12, 6))\n    sns.barplot(\n        x=\"Name\", y=\"RankValue\", hue=\"RankType\", data=plot_df, \n        palette=\"coolwarm\", dodge=True\n    )\n    plt.axhline(0, color=\"black\", linestyle=\"--\")\n    plt.xticks(rotation=45, ha=\"right\")\n    plt.ylabel(\"Rank\")\n    plt.title(f\"MVP Predicted vs True Rankings ({year})\")\n    plt.tight_layout()\n    plt.savefig(f\"data/ranking_predictions_{year}.png\")"
        },
        "timestamp": "2025-08-16 23:10:58.000",
        "id": "Z8I5jwKk7hF71wH7PffA"
    },
    {
        "source": "backend",
        "event": "summarize_modified_code",
        "data": {
            "new_code": "def plot_ranking_predictions(df, year):\n    \"\"\"\n    Plot predicted and true ranks for a specific year.\n\n    Args:\n        df: DataFrame containing prediction results\n        year: Year to plot predicted and true ranks for\n    \"\"\"\n    year_df = df[df[\"Year\"] == year].copy()\n    year_df.sort_values(\"PredictedRank\", inplace=True)\n\n    # Prepare data for grouped barplot\n    plot_df = year_df[[\"Name\", \"PredictedRank\", \"Rank\"]].melt(\n        id_vars=\"Name\", value_vars=[\"PredictedRank\", \"Rank\"], \n        var_name=\"RankType\", value_name=\"RankValue\"\n    )\n\n    plt.figure(figsize=(12, 6))\n    sns.barplot(\n        x=\"Name\", y=\"RankValue\", hue=\"RankType\", data=plot_df, \n        palette=\"coolwarm\", dodge=True\n    )\n    plt.axhline(0, color=\"black\", linestyle=\"--\")\n    plt.xticks(rotation=45, ha=\"right\")\n    plt.ylabel(\"Rank\")\n    plt.title(f\"MVP Predicted vs True Rankings ({year})\")\n    plt.tight_layout()\n    plt.savefig(f\"data/ranking_predictions_{year}.png\")",
            "original_code": "def plot_ranking_predictions(df, year):\n    \"\"\"\n    Plot predicted and true ranks for a specific year.\n\n    Args:\n        df: DataFrame containing prediction results\n        year: Year to plot predicted and true ranks for\n    \"\"\"\n    year_df = df[df[\"Year\"] == year].copy()\n    year_df.sort_values(\"PredictedRank\", inplace=True)\n\n    # Prepare data for grouped barplot\n    plot_df = year_df[[\"Name\", \"PredictedRank\", \"Rank\"]].melt(\n        id_vars=\"Name\", value_vars=[\"PredictedRank\", \"Rank\"], \n        var_name=\"RankType\", value_name=\"RankValue\"\n    )\n\n    plt.figure(figsize=(12, 6))\n    sns.barplot(\n        x=\"Name\", y=\"RankValue\", hue=\"RankType\", data=plot_df, \n        palette=\"coolwarm\", dodge=True\n    )\n    plt.axhline(0, color=\"black\", linestyle=\"--\")\n    plt.xticks(rotation=45, ha=\"right\")\n    plt.ylabel(\"Rank\")\n    plt.title(f\"MVP Predicted vs True Rankings ({year})\")\n    plt.tight_layout()\n    plt.savefig(f\"data/ranking_predictions_{year}.png\")",
            "old_summary": {
                "low_structured": "• Plots predicted ranks for a given year\n• Saves the plot as an image file\n• The function now visualizes predicted ranks directly instead of prediction errors.",
                "high_unstructured": "The plot_ranking_predictions function generates a bar plot to visualize the predicted rank for each player in a specified year. It filters the DataFrame for the given year, sorts the data by predicted rank, and uses Seaborn to create a colored bar plot with player names on the x-axis and predicted rank values on the y-axis, adding a horizontal line at zero for reference. The plot is formatted for readability and saved as a PNG file named according to the year. (The function now plots predicted ranks instead of the prediction error between predicted and actual ranks.)",
                "medium_unstructured": "The plot_ranking_predictions function visualizes the predicted ranks for each player in a specified year. It creates a bar plot showing the predicted rank values for each player and saves the resulting image to a file. The plot includes player names, predicted rank values, and a reference line at zero. (The function now focuses on plotting predicted ranks, not the difference between predicted and actual ranks.)",
                "high_structured": "• Filters the DataFrame to include only rows from the specified year and sorts them by predicted rank\n• Sets up a matplotlib figure with a specific size\n• Creates a Seaborn bar plot:\n  ◦ x-axis: Player names\n  ◦ y-axis: PredictedRank values\n  ◦ Hue: Player names for color distinction\n  ◦ Palette: 'coolwarm' for visual contrast\n• Adds a horizontal dashed line at y=0 to indicate a reference\n• Rotates x-axis labels for better readability\n• Sets axis labels and a descriptive plot title indicating the year\n• Adjusts layout for clarity and saves the figure as 'data/ranking_predictions_{year}.png'\n• The function now visualizes predicted ranks directly, not the difference between predicted and actual ranks.",
                "title": "Function: plot_ranking_predictions",
                "low_unstructured": "This function plots and saves the predicted ranks for players in a specified year, displaying predicted rank values rather than prediction errors. (The function now plots predicted ranks directly instead of errors.)",
                "medium_structured": "• Filters data for the specified year and sorts by predicted rank\n• Creates a bar plot of predicted ranks for each player\n  ◦ Uses player names as labels and colors\n• Adds a horizontal reference line and saves the plot as a PNG file\n• The function now plots predicted ranks directly, rather than prediction errors."
            },
            "new_summary": {
                "low_structured": "• Plots both predicted and true ranks for a given year\n• Saves the plot as an image file\n• The function now visualizes both predicted and actual ranks in a grouped bar plot, instead of only predicted ranks.",
                "high_unstructured": "The plot_ranking_predictions function generates a grouped bar plot to visualize both the predicted and true rank for each player in a specified year. It filters the DataFrame for the given year, sorts the data by predicted rank, and prepares the data so that both predicted and actual ranks are shown as separate bars for each player using Seaborn. The plot uses player names on the x-axis, rank values on the y-axis, and a hue to distinguish between predicted and true ranks, with a horizontal line at zero for reference. The plot is formatted for readability and saved as a PNG file named according to the year. (The function now plots both predicted and actual ranks, instead of only predicted ranks.)",
                "medium_unstructured": "The plot_ranking_predictions function visualizes both the predicted and true ranks for each player in a specified year. It creates a grouped bar plot showing both predicted and actual rank values for each player and saves the resulting image to a file. The plot includes player names, predicted and true rank values, and a reference line at zero. (The function now focuses on plotting both predicted and actual ranks, not just predicted ranks.)",
                "high_structured": "• Filters the DataFrame to include only rows from the specified year and sorts them by predicted rank\n• Prepares a melted DataFrame to include both predicted and true ranks for grouped bar plotting\n• Sets up a matplotlib figure with a specific size\n• Creates a Seaborn grouped bar plot:\n  ◦ x-axis: Player names\n  ◦ y-axis: Rank values (both predicted and actual)\n  ◦ Hue: 'RankType' to distinguish between predicted and true ranks\n  ◦ Palette: 'coolwarm' for visual contrast\n• Adds a horizontal dashed line at y=0 to indicate a reference\n• Rotates x-axis labels for better readability\n• Sets axis labels and a descriptive plot title indicating the year, now reflecting both predicted and true rankings\n• Adjusts layout for clarity and saves the figure as 'data/ranking_predictions_{year}.png'\n• The function now visualizes both predicted and actual ranks in a grouped bar plot, not just predicted ranks.",
                "title": "Function: plot_ranking_predictions",
                "low_unstructured": "This function now plots and saves both the predicted and true ranks for players in a specified year, displaying both predicted and actual rank values in a grouped bar plot rather than only predicted ranks.",
                "medium_structured": "• Filters data for the specified year and sorts by predicted rank\n• Creates a grouped bar plot of both predicted and true ranks for each player\n  ◦ Uses player names as labels and includes both predicted and actual ranks as hue\n• Adds a horizontal reference line and saves the plot as a PNG file\n• The function now plots both predicted and actual ranks, rather than only predicted ranks."
            }
        },
        "timestamp": "2025-08-16 23:11:04.000",
        "id": "ILBNrgKKgsvLEToWnOVy"
    },
    {
        "source": "backend",
        "event": "map_summary_code",
        "data": {
            "summary": "• Filters data for the specified year and sorts by predicted rank\n• Creates a grouped bar plot of both predicted and true ranks for each player\n  ◦ Uses player names as labels and includes both predicted and actual ranks as hue\n• Adds a horizontal reference line and saves the plot as a PNG file\n• The function now plots both predicted and actual ranks, rather than only predicted ranks.",
            "mapping": [
                {
                    "summaryComponent": "Filters data for the specified year and sorts by predicted rank",
                    "codeSegments": [
                        {
                            "line": 75,
                            "code": "year_df = df[df[\"Year\"] == year].copy()"
                        },
                        {
                            "line": 76,
                            "code": "year_df.sort_values(\"PredictedRank\", inplace=True)"
                        }
                    ]
                },
                {
                    "summaryComponent": "Creates a grouped bar plot of both predicted and true ranks for each player",
                    "codeSegments": [
                        {
                            "line": 79,
                            "code": "plot_df = year_df[[\"Name\", \"PredictedRank\", \"Rank\"]].melt("
                        },
                        {
                            "line": 80,
                            "code": "id_vars=\"Name\", value_vars=[\"PredictedRank\", \"Rank\"], "
                        },
                        {
                            "line": 81,
                            "code": "var_name=\"RankType\", value_name=\"RankValue\""
                        },
                        {
                            "line": 85,
                            "code": "sns.barplot("
                        }
                    ]
                },
                {
                    "summaryComponent": "Uses player names as labels and includes both predicted and actual ranks as hue",
                    "codeSegments": [
                        {
                            "line": 86,
                            "code": "x=\"Name\", y=\"RankValue\", hue=\"RankType\", data=plot_df, "
                        }
                    ]
                },
                {
                    "summaryComponent": "Adds a horizontal reference line and saves the plot as a PNG file",
                    "codeSegments": [
                        {
                            "line": 89,
                            "code": "plt.axhline(0, color=\"black\", linestyle=\"--\")"
                        },
                        {
                            "line": 94,
                            "code": "plt.savefig(f\"data/ranking_predictions_{year}.png\")"
                        }
                    ]
                },
                {
                    "summaryComponent": "The function now plots both predicted and actual ranks, rather than only predicted ranks.",
                    "codeSegments": [
                        {
                            "line": 79,
                            "code": "plot_df = year_df[[\"Name\", \"PredictedRank\", \"Rank\"]].melt("
                        },
                        {
                            "line": 80,
                            "code": "value_vars=[\"PredictedRank\", \"Rank\"]"
                        }
                    ]
                }
            ],
            "code": "67: def plot_ranking_predictions(df, year):\n68:     \"\"\"\n69:     Plot predicted and true ranks for a specific year.\n70: \n71:     Args:\n72:         df: DataFrame containing prediction results\n73:         year: Year to plot predicted and true ranks for\n74:     \"\"\"\n75:     year_df = df[df[\"Year\"] == year].copy()\n76:     year_df.sort_values(\"PredictedRank\", inplace=True)\n77: \n78:     # Prepare data for grouped barplot\n79:     plot_df = year_df[[\"Name\", \"PredictedRank\", \"Rank\"]].melt(\n80:         id_vars=\"Name\", value_vars=[\"PredictedRank\", \"Rank\"], \n81:         var_name=\"RankType\", value_name=\"RankValue\"\n82:     )\n83: \n84:     plt.figure(figsize=(12, 6))\n85:     sns.barplot(\n86:         x=\"Name\", y=\"RankValue\", hue=\"RankType\", data=plot_df, \n87:         palette=\"coolwarm\", dodge=True\n88:     )\n89:     plt.axhline(0, color=\"black\", linestyle=\"--\")\n90:     plt.xticks(rotation=45, ha=\"right\")\n91:     plt.ylabel(\"Rank\")\n92:     plt.title(f\"MVP Predicted vs True Rankings ({year})\")\n93:     plt.tight_layout()\n94:     plt.savefig(f\"data/ranking_predictions_{year}.png\")"
        },
        "timestamp": "2025-08-16 23:11:07.000",
        "id": "3grsClqWKG7zZ8alIDVj"
    },
    {
        "source": "backend",
        "event": "map_summary_code",
        "data": {
            "summary": "This function now plots and saves both the predicted and true ranks for players in a specified year, displaying both predicted and actual rank values in a grouped bar plot rather than only predicted ranks.",
            "mapping": [
                {
                    "summaryComponent": "plots and saves both the predicted and true ranks",
                    "codeSegments": [
                        {
                            "line": 94,
                            "code": "plt.savefig(f\"data/ranking_predictions_{year}.png\")"
                        },
                        {
                            "line": 79,
                            "code": "plot_df = year_df[[\"Name\", \"PredictedRank\", \"Rank\"]].melt("
                        },
                        {
                            "line": 85,
                            "code": "sns.barplot("
                        }
                    ]
                },
                {
                    "summaryComponent": "for players in a specified year",
                    "codeSegments": [
                        {
                            "line": 67,
                            "code": "def plot_ranking_predictions(df, year):"
                        },
                        {
                            "line": 75,
                            "code": "year_df = df[df[\"Year\"] == year].copy()"
                        }
                    ]
                },
                {
                    "summaryComponent": "displaying both predicted and actual rank values",
                    "codeSegments": [
                        {
                            "line": 79,
                            "code": "plot_df = year_df[[\"Name\", \"PredictedRank\", \"Rank\"]].melt("
                        },
                        {
                            "line": 80,
                            "code": "value_vars=[\"PredictedRank\", \"Rank\"]"
                        }
                    ]
                },
                {
                    "summaryComponent": "in a grouped bar plot",
                    "codeSegments": [
                        {
                            "line": 85,
                            "code": "sns.barplot("
                        },
                        {
                            "line": 87,
                            "code": "dodge=True"
                        }
                    ]
                },
                {
                    "summaryComponent": "rather than only predicted ranks",
                    "codeSegments": [
                        {
                            "line": 79,
                            "code": "plot_df = year_df[[\"Name\", \"PredictedRank\", \"Rank\"]].melt("
                        },
                        {
                            "line": 80,
                            "code": "value_vars=[\"PredictedRank\", \"Rank\"]"
                        }
                    ]
                }
            ],
            "code": "67: def plot_ranking_predictions(df, year):\n68:     \"\"\"\n69:     Plot predicted and true ranks for a specific year.\n70: \n71:     Args:\n72:         df: DataFrame containing prediction results\n73:         year: Year to plot predicted and true ranks for\n74:     \"\"\"\n75:     year_df = df[df[\"Year\"] == year].copy()\n76:     year_df.sort_values(\"PredictedRank\", inplace=True)\n77: \n78:     # Prepare data for grouped barplot\n79:     plot_df = year_df[[\"Name\", \"PredictedRank\", \"Rank\"]].melt(\n80:         id_vars=\"Name\", value_vars=[\"PredictedRank\", \"Rank\"], \n81:         var_name=\"RankType\", value_name=\"RankValue\"\n82:     )\n83: \n84:     plt.figure(figsize=(12, 6))\n85:     sns.barplot(\n86:         x=\"Name\", y=\"RankValue\", hue=\"RankType\", data=plot_df, \n87:         palette=\"coolwarm\", dodge=True\n88:     )\n89:     plt.axhline(0, color=\"black\", linestyle=\"--\")\n90:     plt.xticks(rotation=45, ha=\"right\")\n91:     plt.ylabel(\"Rank\")\n92:     plt.title(f\"MVP Predicted vs True Rankings ({year})\")\n93:     plt.tight_layout()\n94:     plt.savefig(f\"data/ranking_predictions_{year}.png\")"
        },
        "timestamp": "2025-08-16 23:11:07.000",
        "id": "4DjWYxQ4C1RDAhBzQKKS"
    },
    {
        "source": "backend",
        "event": "map_summary_code",
        "data": {
            "summary": "• Plots both predicted and true ranks for a given year\n• Saves the plot as an image file\n• The function now visualizes both predicted and actual ranks in a grouped bar plot, instead of only predicted ranks.",
            "mapping": [
                {
                    "summaryComponent": "Plots both predicted and true ranks for a given year",
                    "codeSegments": [
                        {
                            "line": 67,
                            "code": "def plot_ranking_predictions(df, year):"
                        },
                        {
                            "line": 75,
                            "code": "year_df = df[df[\"Year\"] == year].copy()"
                        },
                        {
                            "line": 79,
                            "code": "plot_df = year_df[[\"Name\", \"PredictedRank\", \"Rank\"]].melt("
                        },
                        {
                            "line": 84,
                            "code": "plt.figure(figsize=(12, 6))"
                        },
                        {
                            "line": 85,
                            "code": "sns.barplot("
                        },
                        {
                            "line": 92,
                            "code": "plt.title(f\"MVP Predicted vs True Rankings ({year})\")"
                        }
                    ]
                },
                {
                    "summaryComponent": "Saves the plot as an image file",
                    "codeSegments": [
                        {
                            "line": 94,
                            "code": "plt.savefig(f\"data/ranking_predictions_{year}.png\")"
                        }
                    ]
                },
                {
                    "summaryComponent": "visualizes both predicted and actual ranks in a grouped bar plot",
                    "codeSegments": [
                        {
                            "line": 79,
                            "code": "plot_df = year_df[[\"Name\", \"PredictedRank\", \"Rank\"]].melt("
                        },
                        {
                            "line": 85,
                            "code": "sns.barplot("
                        }
                    ]
                },
                {
                    "summaryComponent": "instead of only predicted ranks",
                    "codeSegments": [
                        {
                            "line": 79,
                            "code": "plot_df = year_df[[\"Name\", \"PredictedRank\", \"Rank\"]].melt("
                        }
                    ]
                }
            ],
            "code": "67: def plot_ranking_predictions(df, year):\n68:     \"\"\"\n69:     Plot predicted and true ranks for a specific year.\n70: \n71:     Args:\n72:         df: DataFrame containing prediction results\n73:         year: Year to plot predicted and true ranks for\n74:     \"\"\"\n75:     year_df = df[df[\"Year\"] == year].copy()\n76:     year_df.sort_values(\"PredictedRank\", inplace=True)\n77: \n78:     # Prepare data for grouped barplot\n79:     plot_df = year_df[[\"Name\", \"PredictedRank\", \"Rank\"]].melt(\n80:         id_vars=\"Name\", value_vars=[\"PredictedRank\", \"Rank\"], \n81:         var_name=\"RankType\", value_name=\"RankValue\"\n82:     )\n83: \n84:     plt.figure(figsize=(12, 6))\n85:     sns.barplot(\n86:         x=\"Name\", y=\"RankValue\", hue=\"RankType\", data=plot_df, \n87:         palette=\"coolwarm\", dodge=True\n88:     )\n89:     plt.axhline(0, color=\"black\", linestyle=\"--\")\n90:     plt.xticks(rotation=45, ha=\"right\")\n91:     plt.ylabel(\"Rank\")\n92:     plt.title(f\"MVP Predicted vs True Rankings ({year})\")\n93:     plt.tight_layout()\n94:     plt.savefig(f\"data/ranking_predictions_{year}.png\")"
        },
        "timestamp": "2025-08-16 23:11:07.000",
        "id": "OHXVcnnSO4KDKQrnRZTx"
    },
    {
        "source": "backend",
        "event": "map_summary_code",
        "data": {
            "summary": "The plot_ranking_predictions function visualizes both the predicted and true ranks for each player in a specified year. It creates a grouped bar plot showing both predicted and actual rank values for each player and saves the resulting image to a file. The plot includes player names, predicted and true rank values, and a reference line at zero. (The function now focuses on plotting both predicted and actual ranks, not just predicted ranks.)",
            "mapping": [
                {
                    "summaryComponent": "The plot_ranking_predictions function",
                    "codeSegments": [
                        {
                            "line": 67,
                            "code": "def plot_ranking_predictions(df, year):"
                        }
                    ]
                },
                {
                    "summaryComponent": "visualizes both the predicted and true ranks for each player in a specified year",
                    "codeSegments": [
                        {
                            "line": 75,
                            "code": "year_df = df[df[\"Year\"] == year].copy()"
                        },
                        {
                            "line": 76,
                            "code": "year_df.sort_values(\"PredictedRank\", inplace=True)"
                        },
                        {
                            "line": 79,
                            "code": "plot_df = year_df[[\"Name\", \"PredictedRank\", \"Rank\"]].melt("
                        },
                        {
                            "line": 80,
                            "code": "id_vars=\"Name\", value_vars=[\"PredictedRank\", \"Rank\"], "
                        }
                    ]
                },
                {
                    "summaryComponent": "It creates a grouped bar plot showing both predicted and actual rank values for each player",
                    "codeSegments": [
                        {
                            "line": 85,
                            "code": "sns.barplot("
                        },
                        {
                            "line": 86,
                            "code": "x=\"Name\", y=\"RankValue\", hue=\"RankType\", data=plot_df, "
                        }
                    ]
                },
                {
                    "summaryComponent": "and saves the resulting image to a file",
                    "codeSegments": [
                        {
                            "line": 94,
                            "code": "plt.savefig(f\"data/ranking_predictions_{year}.png\")"
                        }
                    ]
                },
                {
                    "summaryComponent": "The plot includes player names, predicted and true rank values, and a reference line at zero",
                    "codeSegments": [
                        {
                            "line": 86,
                            "code": "x=\"Name\", y=\"RankValue\", hue=\"RankType\", data=plot_df, "
                        },
                        {
                            "line": 89,
                            "code": "plt.axhline(0, color=\"black\", linestyle=\"--\")"
                        }
                    ]
                },
                {
                    "summaryComponent": "(The function now focuses on plotting both predicted and actual ranks, not just predicted ranks.)",
                    "codeSegments": [
                        {
                            "line": 79,
                            "code": "plot_df = year_df[[\"Name\", \"PredictedRank\", \"Rank\"]].melt("
                        },
                        {
                            "line": 80,
                            "code": "value_vars=[\"PredictedRank\", \"Rank\"]"
                        }
                    ]
                }
            ],
            "code": "67: def plot_ranking_predictions(df, year):\n68:     \"\"\"\n69:     Plot predicted and true ranks for a specific year.\n70: \n71:     Args:\n72:         df: DataFrame containing prediction results\n73:         year: Year to plot predicted and true ranks for\n74:     \"\"\"\n75:     year_df = df[df[\"Year\"] == year].copy()\n76:     year_df.sort_values(\"PredictedRank\", inplace=True)\n77: \n78:     # Prepare data for grouped barplot\n79:     plot_df = year_df[[\"Name\", \"PredictedRank\", \"Rank\"]].melt(\n80:         id_vars=\"Name\", value_vars=[\"PredictedRank\", \"Rank\"], \n81:         var_name=\"RankType\", value_name=\"RankValue\"\n82:     )\n83: \n84:     plt.figure(figsize=(12, 6))\n85:     sns.barplot(\n86:         x=\"Name\", y=\"RankValue\", hue=\"RankType\", data=plot_df, \n87:         palette=\"coolwarm\", dodge=True\n88:     )\n89:     plt.axhline(0, color=\"black\", linestyle=\"--\")\n90:     plt.xticks(rotation=45, ha=\"right\")\n91:     plt.ylabel(\"Rank\")\n92:     plt.title(f\"MVP Predicted vs True Rankings ({year})\")\n93:     plt.tight_layout()\n94:     plt.savefig(f\"data/ranking_predictions_{year}.png\")"
        },
        "timestamp": "2025-08-16 23:11:08.000",
        "id": "9Px0yd3UUMFSjWCCmHDh"
    },
    {
        "source": "backend",
        "event": "map_summary_code",
        "data": {
            "summary": "The plot_ranking_predictions function generates a grouped bar plot to visualize both the predicted and true rank for each player in a specified year. It filters the DataFrame for the given year, sorts the data by predicted rank, and prepares the data so that both predicted and actual ranks are shown as separate bars for each player using Seaborn. The plot uses player names on the x-axis, rank values on the y-axis, and a hue to distinguish between predicted and true ranks, with a horizontal line at zero for reference. The plot is formatted for readability and saved as a PNG file named according to the year. (The function now plots both predicted and actual ranks, instead of only predicted ranks.)",
            "mapping": [
                {
                    "summaryComponent": "The plot_ranking_predictions function generates a grouped bar plot",
                    "codeSegments": [
                        {
                            "line": 67,
                            "code": "def plot_ranking_predictions(df, year):"
                        },
                        {
                            "line": 85,
                            "code": "sns.barplot("
                        }
                    ]
                },
                {
                    "summaryComponent": "to visualize both the predicted and true rank for each player in a specified year",
                    "codeSegments": [
                        {
                            "line": 75,
                            "code": "year_df = df[df[\"Year\"] == year].copy()"
                        },
                        {
                            "line": 79,
                            "code": "plot_df = year_df[[\"Name\", \"PredictedRank\", \"Rank\"]].melt("
                        }
                    ]
                },
                {
                    "summaryComponent": "It filters the DataFrame for the given year",
                    "codeSegments": [
                        {
                            "line": 75,
                            "code": "year_df = df[df[\"Year\"] == year].copy()"
                        }
                    ]
                },
                {
                    "summaryComponent": "sorts the data by predicted rank",
                    "codeSegments": [
                        {
                            "line": 76,
                            "code": "year_df.sort_values(\"PredictedRank\", inplace=True)"
                        }
                    ]
                },
                {
                    "summaryComponent": "and prepares the data so that both predicted and actual ranks are shown as separate bars for each player using Seaborn",
                    "codeSegments": [
                        {
                            "line": 79,
                            "code": "plot_df = year_df[[\"Name\", \"PredictedRank\", \"Rank\"]].melt("
                        },
                        {
                            "line": 85,
                            "code": "sns.barplot("
                        }
                    ]
                },
                {
                    "summaryComponent": "The plot uses player names on the x-axis",
                    "codeSegments": [
                        {
                            "line": 86,
                            "code": "x=\"Name\""
                        }
                    ]
                },
                {
                    "summaryComponent": "rank values on the y-axis",
                    "codeSegments": [
                        {
                            "line": 86,
                            "code": "y=\"RankValue\""
                        }
                    ]
                },
                {
                    "summaryComponent": "and a hue to distinguish between predicted and true ranks",
                    "codeSegments": [
                        {
                            "line": 86,
                            "code": "hue=\"RankType\""
                        }
                    ]
                },
                {
                    "summaryComponent": "with a horizontal line at zero for reference",
                    "codeSegments": [
                        {
                            "line": 89,
                            "code": "plt.axhline(0, color=\"black\", linestyle=\"--\")"
                        }
                    ]
                },
                {
                    "summaryComponent": "The plot is formatted for readability and saved as a PNG file named according to the year",
                    "codeSegments": [
                        {
                            "line": 93,
                            "code": "plt.tight_layout()"
                        },
                        {
                            "line": 94,
                            "code": "plt.savefig(f\"data/ranking_predictions_{year}.png\")"
                        }
                    ]
                }
            ],
            "code": "67: def plot_ranking_predictions(df, year):\n68:     \"\"\"\n69:     Plot predicted and true ranks for a specific year.\n70: \n71:     Args:\n72:         df: DataFrame containing prediction results\n73:         year: Year to plot predicted and true ranks for\n74:     \"\"\"\n75:     year_df = df[df[\"Year\"] == year].copy()\n76:     year_df.sort_values(\"PredictedRank\", inplace=True)\n77: \n78:     # Prepare data for grouped barplot\n79:     plot_df = year_df[[\"Name\", \"PredictedRank\", \"Rank\"]].melt(\n80:         id_vars=\"Name\", value_vars=[\"PredictedRank\", \"Rank\"], \n81:         var_name=\"RankType\", value_name=\"RankValue\"\n82:     )\n83: \n84:     plt.figure(figsize=(12, 6))\n85:     sns.barplot(\n86:         x=\"Name\", y=\"RankValue\", hue=\"RankType\", data=plot_df, \n87:         palette=\"coolwarm\", dodge=True\n88:     )\n89:     plt.axhline(0, color=\"black\", linestyle=\"--\")\n90:     plt.xticks(rotation=45, ha=\"right\")\n91:     plt.ylabel(\"Rank\")\n92:     plt.title(f\"MVP Predicted vs True Rankings ({year})\")\n93:     plt.tight_layout()\n94:     plt.savefig(f\"data/ranking_predictions_{year}.png\")"
        },
        "timestamp": "2025-08-16 23:11:08.000",
        "id": "kwvAOrdigLPTuwQIdIfM"
    },
    {
        "source": "backend",
        "event": "map_summary_code",
        "data": {
            "summary": "• Filters the DataFrame to include only rows from the specified year and sorts them by predicted rank\n• Prepares a melted DataFrame to include both predicted and true ranks for grouped bar plotting\n• Sets up a matplotlib figure with a specific size\n• Creates a Seaborn grouped bar plot:\n  ◦ x-axis: Player names\n  ◦ y-axis: Rank values (both predicted and actual)\n  ◦ Hue: 'RankType' to distinguish between predicted and true ranks\n  ◦ Palette: 'coolwarm' for visual contrast\n• Adds a horizontal dashed line at y=0 to indicate a reference\n• Rotates x-axis labels for better readability\n• Sets axis labels and a descriptive plot title indicating the year, now reflecting both predicted and true rankings\n• Adjusts layout for clarity and saves the figure as 'data/ranking_predictions_{year}.png'\n• The function now visualizes both predicted and actual ranks in a grouped bar plot, not just predicted ranks.",
            "mapping": [
                {
                    "summaryComponent": "Filters the DataFrame to include only rows from the specified year and sorts them by predicted rank",
                    "codeSegments": [
                        {
                            "line": 75,
                            "code": "year_df = df[df[\"Year\"] == year].copy()"
                        },
                        {
                            "line": 76,
                            "code": "year_df.sort_values(\"PredictedRank\", inplace=True)"
                        }
                    ]
                },
                {
                    "summaryComponent": "Prepares a melted DataFrame to include both predicted and true ranks for grouped bar plotting",
                    "codeSegments": [
                        {
                            "line": 79,
                            "code": "plot_df = year_df[[\"Name\", \"PredictedRank\", \"Rank\"]].melt("
                        },
                        {
                            "line": 80,
                            "code": "    id_vars=\"Name\", value_vars=[\"PredictedRank\", \"Rank\"], "
                        },
                        {
                            "line": 81,
                            "code": "    var_name=\"RankType\", value_name=\"RankValue\""
                        },
                        {
                            "line": 82,
                            "code": ")"
                        }
                    ]
                },
                {
                    "summaryComponent": "Sets up a matplotlib figure with a specific size",
                    "codeSegments": [
                        {
                            "line": 84,
                            "code": "plt.figure(figsize=(12, 6))"
                        }
                    ]
                },
                {
                    "summaryComponent": "Creates a Seaborn grouped bar plot:",
                    "codeSegments": [
                        {
                            "line": 85,
                            "code": "sns.barplot("
                        },
                        {
                            "line": 86,
                            "code": "    x=\"Name\", y=\"RankValue\", hue=\"RankType\", data=plot_df, "
                        },
                        {
                            "line": 87,
                            "code": "    palette=\"coolwarm\", dodge=True"
                        },
                        {
                            "line": 88,
                            "code": ")"
                        }
                    ]
                },
                {
                    "summaryComponent": "x-axis: Player names",
                    "codeSegments": [
                        {
                            "line": 86,
                            "code": "x=\"Name\""
                        }
                    ]
                },
                {
                    "summaryComponent": "y-axis: Rank values (both predicted and actual)",
                    "codeSegments": [
                        {
                            "line": 86,
                            "code": "y=\"RankValue\""
                        }
                    ]
                },
                {
                    "summaryComponent": "Hue: 'RankType' to distinguish between predicted and true ranks",
                    "codeSegments": [
                        {
                            "line": 86,
                            "code": "hue=\"RankType\""
                        }
                    ]
                },
                {
                    "summaryComponent": "Palette: 'coolwarm' for visual contrast",
                    "codeSegments": [
                        {
                            "line": 87,
                            "code": "palette=\"coolwarm\""
                        }
                    ]
                },
                {
                    "summaryComponent": "Adds a horizontal dashed line at y=0 to indicate a reference",
                    "codeSegments": [
                        {
                            "line": 89,
                            "code": "plt.axhline(0, color=\"black\", linestyle=\"--\")"
                        }
                    ]
                },
                {
                    "summaryComponent": "Rotates x-axis labels for better readability",
                    "codeSegments": [
                        {
                            "line": 90,
                            "code": "plt.xticks(rotation=45, ha=\"right\")"
                        }
                    ]
                },
                {
                    "summaryComponent": "Sets axis labels and a descriptive plot title indicating the year, now reflecting both predicted and true rankings",
                    "codeSegments": [
                        {
                            "line": 91,
                            "code": "plt.ylabel(\"Rank\")"
                        },
                        {
                            "line": 92,
                            "code": "plt.title(f\"MVP Predicted vs True Rankings ({year})\")"
                        }
                    ]
                },
                {
                    "summaryComponent": "Adjusts layout for clarity and saves the figure as 'data/ranking_predictions_{year}.png'",
                    "codeSegments": [
                        {
                            "line": 93,
                            "code": "plt.tight_layout()"
                        },
                        {
                            "line": 94,
                            "code": "plt.savefig(f\"data/ranking_predictions_{year}.png\")"
                        }
                    ]
                },
                {
                    "summaryComponent": "The function now visualizes both predicted and actual ranks in a grouped bar plot, not just predicted ranks.",
                    "codeSegments": [
                        {
                            "line": 85,
                            "code": "sns.barplot("
                        },
                        {
                            "line": 86,
                            "code": "    x=\"Name\", y=\"RankValue\", hue=\"RankType\", data=plot_df, "
                        },
                        {
                            "line": 87,
                            "code": "    palette=\"coolwarm\", dodge=True"
                        },
                        {
                            "line": 88,
                            "code": ")"
                        }
                    ]
                }
            ],
            "code": "67: def plot_ranking_predictions(df, year):\n68:     \"\"\"\n69:     Plot predicted and true ranks for a specific year.\n70: \n71:     Args:\n72:         df: DataFrame containing prediction results\n73:         year: Year to plot predicted and true ranks for\n74:     \"\"\"\n75:     year_df = df[df[\"Year\"] == year].copy()\n76:     year_df.sort_values(\"PredictedRank\", inplace=True)\n77: \n78:     # Prepare data for grouped barplot\n79:     plot_df = year_df[[\"Name\", \"PredictedRank\", \"Rank\"]].melt(\n80:         id_vars=\"Name\", value_vars=[\"PredictedRank\", \"Rank\"], \n81:         var_name=\"RankType\", value_name=\"RankValue\"\n82:     )\n83: \n84:     plt.figure(figsize=(12, 6))\n85:     sns.barplot(\n86:         x=\"Name\", y=\"RankValue\", hue=\"RankType\", data=plot_df, \n87:         palette=\"coolwarm\", dodge=True\n88:     )\n89:     plt.axhline(0, color=\"black\", linestyle=\"--\")\n90:     plt.xticks(rotation=45, ha=\"right\")\n91:     plt.ylabel(\"Rank\")\n92:     plt.title(f\"MVP Predicted vs True Rankings ({year})\")\n93:     plt.tight_layout()\n94:     plt.savefig(f\"data/ranking_predictions_{year}.png\")"
        },
        "timestamp": "2025-08-16 23:11:09.000",
        "id": "087hMg4UVQt8y7o77Mjy"
    },
    {
        "source": "frontend",
        "event": "create_new_section",
        "data": {
            "section_id": "ca827391-4617-4bf8-aaa4-cb88aaecb479",
            "section_data": {
                "editPromptDetailLevel": null,
                "selectedStructured": "unstructured",
                "createdAt": 1755371469000,
                "lines": [
                    67,
                    94
                ],
                "editPromptStructured": null,
                "summaryData": {
                    "low_structured": "• Plots both predicted and true ranks for a given year\n• Saves the plot as an image file\n• The function now visualizes both predicted and actual ranks in a grouped bar plot, instead of only predicted ranks.",
                    "high_unstructured": "The plot_ranking_predictions function generates a grouped bar plot to visualize both the predicted and true rank for each player in a specified year. It filters the DataFrame for the given year, sorts the data by predicted rank, and prepares the data so that both predicted and actual ranks are shown as separate bars for each player using Seaborn. The plot uses player names on the x-axis, rank values on the y-axis, and a hue to distinguish between predicted and true ranks, with a horizontal line at zero for reference. The plot is formatted for readability and saved as a PNG file named according to the year. (The function now plots both predicted and actual ranks, instead of only predicted ranks.)",
                    "medium_unstructured": "The plot_ranking_predictions function visualizes both the predicted and true ranks for each player in a specified year. It creates a grouped bar plot showing both predicted and actual rank values for each player and saves the resulting image to a file. The plot includes player names, predicted and true rank values, and a reference line at zero. (The function now focuses on plotting both predicted and actual ranks, not just predicted ranks.)",
                    "high_structured": "• Filters the DataFrame to include only rows from the specified year and sorts them by predicted rank\n• Prepares a melted DataFrame to include both predicted and true ranks for grouped bar plotting\n• Sets up a matplotlib figure with a specific size\n• Creates a Seaborn grouped bar plot:\n  ◦ x-axis: Player names\n  ◦ y-axis: Rank values (both predicted and actual)\n  ◦ Hue: 'RankType' to distinguish between predicted and true ranks\n  ◦ Palette: 'coolwarm' for visual contrast\n• Adds a horizontal dashed line at y=0 to indicate a reference\n• Rotates x-axis labels for better readability\n• Sets axis labels and a descriptive plot title indicating the year, now reflecting both predicted and true rankings\n• Adjusts layout for clarity and saves the figure as 'data/ranking_predictions_{year}.png'\n• The function now visualizes both predicted and actual ranks in a grouped bar plot, not just predicted ranks.",
                    "title": "Function: plot_ranking_predictions",
                    "low_unstructured": "This function now plots and saves both the predicted and true ranks for players in a specified year, displaying both predicted and actual rank values in a grouped bar plot rather than only predicted ranks.",
                    "medium_structured": "• Filters data for the specified year and sorts by predicted rank\n• Creates a grouped bar plot of both predicted and true ranks for each player\n  ◦ Uses player names as labels and includes both predicted and actual ranks as hue\n• Adds a horizontal reference line and saves the plot as a PNG file\n• The function now plots both predicted and actual ranks, rather than only predicted ranks."
                },
                "selectedDetailLevel": "medium",
                "oldSummaryData": {
                    "low_structured": "• Plots predicted ranks for a given year\n• Saves the plot as an image file\n• The function now visualizes predicted ranks directly instead of prediction errors.",
                    "high_unstructured": "The plot_ranking_predictions function generates a bar plot to visualize the predicted rank for each player in a specified year. It filters the DataFrame for the given year, sorts the data by predicted rank, and uses Seaborn to create a colored bar plot with player names on the x-axis and predicted rank values on the y-axis, adding a horizontal line at zero for reference. The plot is formatted for readability and saved as a PNG file named according to the year. (The function now plots predicted ranks instead of the prediction error between predicted and actual ranks.)",
                    "medium_unstructured": "The plot_ranking_predictions function visualizes the predicted ranks for each player in a specified year. It creates a bar plot showing the predicted rank values for each player and saves the resulting image to a file. The plot includes player names, predicted rank values, and a reference line at zero. (The function now focuses on plotting predicted ranks, not the difference between predicted and actual ranks.)",
                    "high_structured": "• Filters the DataFrame to include only rows from the specified year and sorts them by predicted rank\n• Sets up a matplotlib figure with a specific size\n• Creates a Seaborn bar plot:\n  ◦ x-axis: Player names\n  ◦ y-axis: PredictedRank values\n  ◦ Hue: Player names for color distinction\n  ◦ Palette: 'coolwarm' for visual contrast\n• Adds a horizontal dashed line at y=0 to indicate a reference\n• Rotates x-axis labels for better readability\n• Sets axis labels and a descriptive plot title indicating the year\n• Adjusts layout for clarity and saves the figure as 'data/ranking_predictions_{year}.png'\n• The function now visualizes predicted ranks directly, not the difference between predicted and actual ranks.",
                    "title": "Function: plot_ranking_predictions",
                    "low_unstructured": "This function plots and saves the predicted ranks for players in a specified year, displaying predicted rank values rather than prediction errors. (The function now plots predicted ranks directly instead of errors.)",
                    "medium_structured": "• Filters data for the specified year and sorts by predicted rank\n• Creates a bar plot of predicted ranks for each player\n  ◦ Uses player names as labels and colors\n• Adds a horizontal reference line and saves the plot as a PNG file\n• The function now plots predicted ranks directly, rather than prediction errors."
                },
                "metadata": {
                    "originalCode": "def plot_ranking_predictions(df, year):\n    \"\"\"\n    Plot predicted and true ranks for a specific year.\n\n    Args:\n        df: DataFrame containing prediction results\n        year: Year to plot predicted and true ranks for\n    \"\"\"\n    year_df = df[df[\"Year\"] == year].copy()\n    year_df.sort_values(\"PredictedRank\", inplace=True)\n\n    # Prepare data for grouped barplot\n    plot_df = year_df[[\"Name\", \"PredictedRank\", \"Rank\"]].melt(\n        id_vars=\"Name\", value_vars=[\"PredictedRank\", \"Rank\"], \n        var_name=\"RankType\", value_name=\"RankValue\"\n    )\n\n    plt.figure(figsize=(12, 6))\n    sns.barplot(\n        x=\"Name\", y=\"RankValue\", hue=\"RankType\", data=plot_df, \n        palette=\"coolwarm\", dodge=True\n    )\n    plt.axhline(0, color=\"black\", linestyle=\"--\")\n    plt.xticks(rotation=45, ha=\"right\")\n    plt.ylabel(\"Rank\")\n    plt.title(f\"MVP Predicted vs True Rankings ({year})\")\n    plt.tight_layout()\n    plt.savefig(f\"data/ranking_predictions_{year}.png\")",
                    "fullPath": "/project/workspace/rank_model.py",
                    "id": "ca827391-4617-4bf8-aaa4-cb88aaecb479",
                    "offset": 1496,
                    "filename": "rank_model.py"
                },
                "editPromptValue": "",
                "title": "Function: plot_ranking_predictions",
                "summaryMappings": {
                    "high_unstructured": [
                        {
                            "summaryComponent": "The plot_ranking_predictions function generates a grouped bar plot",
                            "codeSegments": [
                                {
                                    "line": 67,
                                    "code": "def plot_ranking_predictions(df, year):"
                                },
                                {
                                    "line": 85,
                                    "code": "sns.barplot("
                                }
                            ]
                        },
                        {
                            "summaryComponent": "to visualize both the predicted and true rank for each player in a specified year",
                            "codeSegments": [
                                {
                                    "line": 75,
                                    "code": "year_df = df[df[\"Year\"] == year].copy()"
                                },
                                {
                                    "line": 79,
                                    "code": "plot_df = year_df[[\"Name\", \"PredictedRank\", \"Rank\"]].melt("
                                }
                            ]
                        },
                        {
                            "summaryComponent": "It filters the DataFrame for the given year",
                            "codeSegments": [
                                {
                                    "line": 75,
                                    "code": "year_df = df[df[\"Year\"] == year].copy()"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "sorts the data by predicted rank",
                            "codeSegments": [
                                {
                                    "line": 76,
                                    "code": "year_df.sort_values(\"PredictedRank\", inplace=True)"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "and prepares the data so that both predicted and actual ranks are shown as separate bars for each player using Seaborn",
                            "codeSegments": [
                                {
                                    "line": 79,
                                    "code": "plot_df = year_df[[\"Name\", \"PredictedRank\", \"Rank\"]].melt("
                                },
                                {
                                    "line": 85,
                                    "code": "sns.barplot("
                                }
                            ]
                        },
                        {
                            "summaryComponent": "The plot uses player names on the x-axis",
                            "codeSegments": [
                                {
                                    "line": 86,
                                    "code": "x=\"Name\""
                                }
                            ]
                        },
                        {
                            "summaryComponent": "rank values on the y-axis",
                            "codeSegments": [
                                {
                                    "line": 86,
                                    "code": "y=\"RankValue\""
                                }
                            ]
                        },
                        {
                            "summaryComponent": "and a hue to distinguish between predicted and true ranks",
                            "codeSegments": [
                                {
                                    "line": 86,
                                    "code": "hue=\"RankType\""
                                }
                            ]
                        },
                        {
                            "summaryComponent": "with a horizontal line at zero for reference",
                            "codeSegments": [
                                {
                                    "line": 89,
                                    "code": "plt.axhline(0, color=\"black\", linestyle=\"--\")"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "The plot is formatted for readability and saved as a PNG file named according to the year",
                            "codeSegments": [
                                {
                                    "line": 93,
                                    "code": "plt.tight_layout()"
                                },
                                {
                                    "line": 94,
                                    "code": "plt.savefig(f\"data/ranking_predictions_{year}.png\")"
                                }
                            ]
                        }
                    ],
                    "medium_unstructured": [
                        {
                            "summaryComponent": "The plot_ranking_predictions function",
                            "codeSegments": [
                                {
                                    "line": 67,
                                    "code": "def plot_ranking_predictions(df, year):"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "visualizes both the predicted and true ranks for each player in a specified year",
                            "codeSegments": [
                                {
                                    "line": 75,
                                    "code": "year_df = df[df[\"Year\"] == year].copy()"
                                },
                                {
                                    "line": 76,
                                    "code": "year_df.sort_values(\"PredictedRank\", inplace=True)"
                                },
                                {
                                    "line": 79,
                                    "code": "plot_df = year_df[[\"Name\", \"PredictedRank\", \"Rank\"]].melt("
                                },
                                {
                                    "line": 80,
                                    "code": "id_vars=\"Name\", value_vars=[\"PredictedRank\", \"Rank\"], "
                                }
                            ]
                        },
                        {
                            "summaryComponent": "It creates a grouped bar plot showing both predicted and actual rank values for each player",
                            "codeSegments": [
                                {
                                    "line": 85,
                                    "code": "sns.barplot("
                                },
                                {
                                    "line": 86,
                                    "code": "x=\"Name\", y=\"RankValue\", hue=\"RankType\", data=plot_df, "
                                }
                            ]
                        },
                        {
                            "summaryComponent": "and saves the resulting image to a file",
                            "codeSegments": [
                                {
                                    "line": 94,
                                    "code": "plt.savefig(f\"data/ranking_predictions_{year}.png\")"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "The plot includes player names, predicted and true rank values, and a reference line at zero",
                            "codeSegments": [
                                {
                                    "line": 86,
                                    "code": "x=\"Name\", y=\"RankValue\", hue=\"RankType\", data=plot_df, "
                                },
                                {
                                    "line": 89,
                                    "code": "plt.axhline(0, color=\"black\", linestyle=\"--\")"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "(The function now focuses on plotting both predicted and actual ranks, not just predicted ranks.)",
                            "codeSegments": [
                                {
                                    "line": 79,
                                    "code": "plot_df = year_df[[\"Name\", \"PredictedRank\", \"Rank\"]].melt("
                                },
                                {
                                    "line": 80,
                                    "code": "value_vars=[\"PredictedRank\", \"Rank\"]"
                                }
                            ]
                        }
                    ],
                    "high_structured": [
                        {
                            "summaryComponent": "Filters the DataFrame to include only rows from the specified year and sorts them by predicted rank",
                            "codeSegments": [
                                {
                                    "line": 75,
                                    "code": "year_df = df[df[\"Year\"] == year].copy()"
                                },
                                {
                                    "line": 76,
                                    "code": "year_df.sort_values(\"PredictedRank\", inplace=True)"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "Prepares a melted DataFrame to include both predicted and true ranks for grouped bar plotting",
                            "codeSegments": [
                                {
                                    "line": 79,
                                    "code": "plot_df = year_df[[\"Name\", \"PredictedRank\", \"Rank\"]].melt("
                                },
                                {
                                    "line": 80,
                                    "code": "    id_vars=\"Name\", value_vars=[\"PredictedRank\", \"Rank\"], "
                                },
                                {
                                    "line": 81,
                                    "code": "    var_name=\"RankType\", value_name=\"RankValue\""
                                },
                                {
                                    "line": 82,
                                    "code": ")"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "Sets up a matplotlib figure with a specific size",
                            "codeSegments": [
                                {
                                    "line": 84,
                                    "code": "plt.figure(figsize=(12, 6))"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "Creates a Seaborn grouped bar plot:",
                            "codeSegments": [
                                {
                                    "line": 85,
                                    "code": "sns.barplot("
                                },
                                {
                                    "line": 86,
                                    "code": "    x=\"Name\", y=\"RankValue\", hue=\"RankType\", data=plot_df, "
                                },
                                {
                                    "line": 87,
                                    "code": "    palette=\"coolwarm\", dodge=True"
                                },
                                {
                                    "line": 88,
                                    "code": ")"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "x-axis: Player names",
                            "codeSegments": [
                                {
                                    "line": 86,
                                    "code": "x=\"Name\""
                                }
                            ]
                        },
                        {
                            "summaryComponent": "y-axis: Rank values (both predicted and actual)",
                            "codeSegments": [
                                {
                                    "line": 86,
                                    "code": "y=\"RankValue\""
                                }
                            ]
                        },
                        {
                            "summaryComponent": "Hue: 'RankType' to distinguish between predicted and true ranks",
                            "codeSegments": [
                                {
                                    "line": 86,
                                    "code": "hue=\"RankType\""
                                }
                            ]
                        },
                        {
                            "summaryComponent": "Palette: 'coolwarm' for visual contrast",
                            "codeSegments": [
                                {
                                    "line": 87,
                                    "code": "palette=\"coolwarm\""
                                }
                            ]
                        },
                        {
                            "summaryComponent": "Adds a horizontal dashed line at y=0 to indicate a reference",
                            "codeSegments": [
                                {
                                    "line": 89,
                                    "code": "plt.axhline(0, color=\"black\", linestyle=\"--\")"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "Rotates x-axis labels for better readability",
                            "codeSegments": [
                                {
                                    "line": 90,
                                    "code": "plt.xticks(rotation=45, ha=\"right\")"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "Sets axis labels and a descriptive plot title indicating the year, now reflecting both predicted and true rankings",
                            "codeSegments": [
                                {
                                    "line": 91,
                                    "code": "plt.ylabel(\"Rank\")"
                                },
                                {
                                    "line": 92,
                                    "code": "plt.title(f\"MVP Predicted vs True Rankings ({year})\")"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "Adjusts layout for clarity and saves the figure as 'data/ranking_predictions_{year}.png'",
                            "codeSegments": [
                                {
                                    "line": 93,
                                    "code": "plt.tight_layout()"
                                },
                                {
                                    "line": 94,
                                    "code": "plt.savefig(f\"data/ranking_predictions_{year}.png\")"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "The function now visualizes both predicted and actual ranks in a grouped bar plot, not just predicted ranks.",
                            "codeSegments": [
                                {
                                    "line": 85,
                                    "code": "sns.barplot("
                                },
                                {
                                    "line": 86,
                                    "code": "    x=\"Name\", y=\"RankValue\", hue=\"RankType\", data=plot_df, "
                                },
                                {
                                    "line": 87,
                                    "code": "    palette=\"coolwarm\", dodge=True"
                                },
                                {
                                    "line": 88,
                                    "code": ")"
                                }
                            ]
                        }
                    ],
                    "low_unstructured": [
                        {
                            "summaryComponent": "plots and saves both the predicted and true ranks",
                            "codeSegments": [
                                {
                                    "line": 94,
                                    "code": "plt.savefig(f\"data/ranking_predictions_{year}.png\")"
                                },
                                {
                                    "line": 79,
                                    "code": "plot_df = year_df[[\"Name\", \"PredictedRank\", \"Rank\"]].melt("
                                },
                                {
                                    "line": 85,
                                    "code": "sns.barplot("
                                }
                            ]
                        },
                        {
                            "summaryComponent": "for players in a specified year",
                            "codeSegments": [
                                {
                                    "line": 67,
                                    "code": "def plot_ranking_predictions(df, year):"
                                },
                                {
                                    "line": 75,
                                    "code": "year_df = df[df[\"Year\"] == year].copy()"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "displaying both predicted and actual rank values",
                            "codeSegments": [
                                {
                                    "line": 79,
                                    "code": "plot_df = year_df[[\"Name\", \"PredictedRank\", \"Rank\"]].melt("
                                },
                                {
                                    "line": 80,
                                    "code": "value_vars=[\"PredictedRank\", \"Rank\"]"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "in a grouped bar plot",
                            "codeSegments": [
                                {
                                    "line": 85,
                                    "code": "sns.barplot("
                                },
                                {
                                    "line": 87,
                                    "code": "dodge=True"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "rather than only predicted ranks",
                            "codeSegments": [
                                {
                                    "line": 79,
                                    "code": "plot_df = year_df[[\"Name\", \"PredictedRank\", \"Rank\"]].melt("
                                },
                                {
                                    "line": 80,
                                    "code": "value_vars=[\"PredictedRank\", \"Rank\"]"
                                }
                            ]
                        }
                    ],
                    "low_structured": [
                        {
                            "summaryComponent": "Plots both predicted and true ranks for a given year",
                            "codeSegments": [
                                {
                                    "line": 67,
                                    "code": "def plot_ranking_predictions(df, year):"
                                },
                                {
                                    "line": 75,
                                    "code": "year_df = df[df[\"Year\"] == year].copy()"
                                },
                                {
                                    "line": 79,
                                    "code": "plot_df = year_df[[\"Name\", \"PredictedRank\", \"Rank\"]].melt("
                                },
                                {
                                    "line": 84,
                                    "code": "plt.figure(figsize=(12, 6))"
                                },
                                {
                                    "line": 85,
                                    "code": "sns.barplot("
                                },
                                {
                                    "line": 92,
                                    "code": "plt.title(f\"MVP Predicted vs True Rankings ({year})\")"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "Saves the plot as an image file",
                            "codeSegments": [
                                {
                                    "line": 94,
                                    "code": "plt.savefig(f\"data/ranking_predictions_{year}.png\")"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "visualizes both predicted and actual ranks in a grouped bar plot",
                            "codeSegments": [
                                {
                                    "line": 79,
                                    "code": "plot_df = year_df[[\"Name\", \"PredictedRank\", \"Rank\"]].melt("
                                },
                                {
                                    "line": 85,
                                    "code": "sns.barplot("
                                }
                            ]
                        },
                        {
                            "summaryComponent": "instead of only predicted ranks",
                            "codeSegments": [
                                {
                                    "line": 79,
                                    "code": "plot_df = year_df[[\"Name\", \"PredictedRank\", \"Rank\"]].melt("
                                }
                            ]
                        }
                    ],
                    "medium_structured": [
                        {
                            "summaryComponent": "Filters data for the specified year and sorts by predicted rank",
                            "codeSegments": [
                                {
                                    "line": 75,
                                    "code": "year_df = df[df[\"Year\"] == year].copy()"
                                },
                                {
                                    "line": 76,
                                    "code": "year_df.sort_values(\"PredictedRank\", inplace=True)"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "Creates a grouped bar plot of both predicted and true ranks for each player",
                            "codeSegments": [
                                {
                                    "line": 79,
                                    "code": "plot_df = year_df[[\"Name\", \"PredictedRank\", \"Rank\"]].melt("
                                },
                                {
                                    "line": 80,
                                    "code": "id_vars=\"Name\", value_vars=[\"PredictedRank\", \"Rank\"], "
                                },
                                {
                                    "line": 81,
                                    "code": "var_name=\"RankType\", value_name=\"RankValue\""
                                },
                                {
                                    "line": 85,
                                    "code": "sns.barplot("
                                }
                            ]
                        },
                        {
                            "summaryComponent": "Uses player names as labels and includes both predicted and actual ranks as hue",
                            "codeSegments": [
                                {
                                    "line": 86,
                                    "code": "x=\"Name\", y=\"RankValue\", hue=\"RankType\", data=plot_df, "
                                }
                            ]
                        },
                        {
                            "summaryComponent": "Adds a horizontal reference line and saves the plot as a PNG file",
                            "codeSegments": [
                                {
                                    "line": 89,
                                    "code": "plt.axhline(0, color=\"black\", linestyle=\"--\")"
                                },
                                {
                                    "line": 94,
                                    "code": "plt.savefig(f\"data/ranking_predictions_{year}.png\")"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "The function now plots both predicted and actual ranks, rather than only predicted ranks.",
                            "codeSegments": [
                                {
                                    "line": 79,
                                    "code": "plot_df = year_df[[\"Name\", \"PredictedRank\", \"Rank\"]].melt("
                                },
                                {
                                    "line": 80,
                                    "code": "value_vars=[\"PredictedRank\", \"Rank\"]"
                                }
                            ]
                        }
                    ]
                }
            }
        },
        "timestamp": "2025-08-16 23:11:10.000",
        "id": "UZUMfRWBlK0ErSCgZUbk"
    },
    {
        "source": "frontend",
        "event": "autotransit_section",
        "data": {
            "before_section_id": "7389693e-0ca3-458e-9bce-3fc0b6b2bafd",
            "after_section_id": "ca827391-4617-4bf8-aaa4-cb88aaecb479"
        },
        "timestamp": "2025-08-16 23:11:10.000",
        "id": "dhs7eEqXptfrsVkL9c1G"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "ca827391-4617-4bf8-aaa4-cb88aaecb479",
            "detail_level": "medium",
            "structured_type": "unstructured"
        },
        "timestamp": "2025-08-16 23:11:52.000",
        "id": "KvGwW96mkZjXuGtcMoKE"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "ca827391-4617-4bf8-aaa4-cb88aaecb479",
            "mapping_index": 2,
            "structured_type": "unstructured",
            "detail_level": "medium"
        },
        "timestamp": "2025-08-16 23:11:52.000",
        "id": "MJff4bPKSpetQdeXG34T"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "ca827391-4617-4bf8-aaa4-cb88aaecb479",
            "mapping_index": 4,
            "structured_type": "unstructured",
            "detail_level": "medium"
        },
        "timestamp": "2025-08-16 23:11:52.000",
        "id": "wf5uiGD5JwrlBhBkl1yj"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "ca827391-4617-4bf8-aaa4-cb88aaecb479",
            "detail_level": "medium",
            "structured_type": "unstructured"
        },
        "timestamp": "2025-08-16 23:11:52.000",
        "id": "yskMYmrZSjAnPdVKSHgX"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "ca827391-4617-4bf8-aaa4-cb88aaecb479",
            "mapping_index": 2,
            "structured_type": "unstructured",
            "detail_level": "medium"
        },
        "timestamp": "2025-08-16 23:11:53.000",
        "id": "BhRbdLKkqs7uUY3huwZZ"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "ca827391-4617-4bf8-aaa4-cb88aaecb479",
            "detail_level": "medium",
            "structured_type": "unstructured"
        },
        "timestamp": "2025-08-16 23:11:53.000",
        "id": "D7Rt2kuGbOnWXpznRnNK"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "ca827391-4617-4bf8-aaa4-cb88aaecb479",
            "mapping_index": 1,
            "structured_type": "unstructured",
            "detail_level": "medium"
        },
        "timestamp": "2025-08-16 23:11:53.000",
        "id": "FPHdeVDeYw3BpoEY9Zxm"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "ca827391-4617-4bf8-aaa4-cb88aaecb479",
            "mapping_index": 4,
            "structured_type": "unstructured",
            "detail_level": "medium"
        },
        "timestamp": "2025-08-16 23:11:53.000",
        "id": "TZdiWQdJaCsRxv2uaiov"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "ca827391-4617-4bf8-aaa4-cb88aaecb479",
            "detail_level": "medium",
            "structured_type": "unstructured"
        },
        "timestamp": "2025-08-16 23:11:53.000",
        "id": "Wjgd1NDGmCS8fGRkqbWx"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "ca827391-4617-4bf8-aaa4-cb88aaecb479",
            "detail_level": "medium",
            "structured_type": "unstructured"
        },
        "timestamp": "2025-08-16 23:11:53.000",
        "id": "yxH9LeRP7l8qXsgoqAfD"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "ca827391-4617-4bf8-aaa4-cb88aaecb479",
            "detail_level": "medium",
            "structured_type": "unstructured"
        },
        "timestamp": "2025-08-16 23:11:55.000",
        "id": "7gME18sBYe0YrepDc6DS"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "ca827391-4617-4bf8-aaa4-cb88aaecb479",
            "mapping_index": 4,
            "structured_type": "unstructured",
            "detail_level": "medium"
        },
        "timestamp": "2025-08-16 23:11:55.000",
        "id": "8KZkc9d0vlM6G0z5X5Qq"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "ca827391-4617-4bf8-aaa4-cb88aaecb479",
            "mapping_index": 5,
            "structured_type": "unstructured",
            "detail_level": "medium"
        },
        "timestamp": "2025-08-16 23:11:55.000",
        "id": "L68IXPYILx0G375SbwHP"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "ca827391-4617-4bf8-aaa4-cb88aaecb479",
            "detail_level": "medium",
            "structured_type": "unstructured"
        },
        "timestamp": "2025-08-16 23:11:55.000",
        "id": "U8XFnggSn0TdIY6GTqP4"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "ca827391-4617-4bf8-aaa4-cb88aaecb479",
            "mapping_index": 3,
            "structured_type": "unstructured",
            "detail_level": "medium"
        },
        "timestamp": "2025-08-16 23:11:55.000",
        "id": "ZK4X3BuG40pE1E0loWFx"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "ca827391-4617-4bf8-aaa4-cb88aaecb479",
            "detail_level": "medium",
            "structured_type": "unstructured"
        },
        "timestamp": "2025-08-16 23:11:55.000",
        "id": "kIGseKQb590N58irBHHl"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "ca827391-4617-4bf8-aaa4-cb88aaecb479",
            "mapping_index": 5,
            "structured_type": "unstructured",
            "detail_level": "medium"
        },
        "timestamp": "2025-08-16 23:11:55.000",
        "id": "lq0gkF5C0rzvE6G5WciE"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "ca827391-4617-4bf8-aaa4-cb88aaecb479",
            "detail_level": "medium",
            "structured_type": "unstructured"
        },
        "timestamp": "2025-08-16 23:11:55.000",
        "id": "w0wX8AIMg4ogInCMW6M4"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "ca827391-4617-4bf8-aaa4-cb88aaecb479",
            "mapping_index": 5,
            "structured_type": "unstructured",
            "detail_level": "medium"
        },
        "timestamp": "2025-08-16 23:11:56.000",
        "id": "CYQPdoFO1xcRx0hS1CdI"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "ca827391-4617-4bf8-aaa4-cb88aaecb479",
            "detail_level": "medium",
            "structured_type": "unstructured"
        },
        "timestamp": "2025-08-16 23:11:56.000",
        "id": "SzCvFMZ8dE8549iJCOhQ"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "ca827391-4617-4bf8-aaa4-cb88aaecb479",
            "mapping_index": 0,
            "structured_type": "unstructured",
            "detail_level": "medium"
        },
        "timestamp": "2025-08-16 23:11:57.000",
        "id": "AAvTi6TAWgc0HC3kHcVz"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "ca827391-4617-4bf8-aaa4-cb88aaecb479",
            "detail_level": "medium",
            "structured_type": "unstructured"
        },
        "timestamp": "2025-08-16 23:11:57.000",
        "id": "FPm1j0RDb7Js2TVKEXfk"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "ca827391-4617-4bf8-aaa4-cb88aaecb479",
            "detail_level": "medium",
            "structured_type": "unstructured"
        },
        "timestamp": "2025-08-16 23:11:57.000",
        "id": "H5Y3yvXB7uBaRMhu7xYS"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "ca827391-4617-4bf8-aaa4-cb88aaecb479",
            "detail_level": "medium",
            "structured_type": "unstructured"
        },
        "timestamp": "2025-08-16 23:11:57.000",
        "id": "OrZFJLksLAggVVgMiWWx"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "ca827391-4617-4bf8-aaa4-cb88aaecb479",
            "mapping_index": 5,
            "structured_type": "unstructured",
            "detail_level": "medium"
        },
        "timestamp": "2025-08-16 23:11:57.000",
        "id": "Zq1KKfif0FPLX8VSPJWv"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "ca827391-4617-4bf8-aaa4-cb88aaecb479",
            "detail_level": "medium",
            "structured_type": "unstructured"
        },
        "timestamp": "2025-08-16 23:11:57.000",
        "id": "sNqie37qwAapAkwbvZ0L"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "ca827391-4617-4bf8-aaa4-cb88aaecb479",
            "mapping_index": 2,
            "structured_type": "unstructured",
            "detail_level": "medium"
        },
        "timestamp": "2025-08-16 23:11:57.000",
        "id": "wbcCT6jGR9NIbWNVIEeU"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "ca827391-4617-4bf8-aaa4-cb88aaecb479",
            "mapping_index": 4,
            "structured_type": "unstructured",
            "detail_level": "medium"
        },
        "timestamp": "2025-08-16 23:11:57.000",
        "id": "zHqv8MJdmdqMGTTDIqjt"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "ca827391-4617-4bf8-aaa4-cb88aaecb479",
            "mapping_index": 2,
            "structured_type": "unstructured",
            "detail_level": "medium"
        },
        "timestamp": "2025-08-16 23:11:58.000",
        "id": "1gUQyJZAmDNjq5blqQVm"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "ca827391-4617-4bf8-aaa4-cb88aaecb479",
            "detail_level": "medium",
            "structured_type": "unstructured"
        },
        "timestamp": "2025-08-16 23:11:58.000",
        "id": "FiXH1MeJs010c9VoJ3ZS"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "ca827391-4617-4bf8-aaa4-cb88aaecb479",
            "mapping_index": 0,
            "structured_type": "unstructured",
            "detail_level": "medium"
        },
        "timestamp": "2025-08-16 23:11:58.000",
        "id": "GOzdGlNqKijXBWyQMCEs"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "ca827391-4617-4bf8-aaa4-cb88aaecb479",
            "mapping_index": 0,
            "structured_type": "unstructured",
            "detail_level": "medium"
        },
        "timestamp": "2025-08-16 23:11:58.000",
        "id": "QhuKypCJ0xqj00pqplnA"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "ca827391-4617-4bf8-aaa4-cb88aaecb479",
            "detail_level": "medium",
            "structured_type": "unstructured"
        },
        "timestamp": "2025-08-16 23:11:58.000",
        "id": "aMXFhORrINAYVCuFX3d8"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "ca827391-4617-4bf8-aaa4-cb88aaecb479",
            "detail_level": "medium",
            "structured_type": "unstructured"
        },
        "timestamp": "2025-08-16 23:11:58.000",
        "id": "mguxadyhLQrVhtFbv9nB"
    },
    {
        "source": "frontend",
        "event": "change_summary_level",
        "data": {
            "before_detail_level": "medium",
            "section_id": "ca827391-4617-4bf8-aaa4-cb88aaecb479",
            "before_structured": "unstructured",
            "after_structured": "unstructured",
            "after_detail_level": "high"
        },
        "timestamp": "2025-08-16 23:11:59.000",
        "id": "zwQUQRWuZwME06nBwme5"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "ca827391-4617-4bf8-aaa4-cb88aaecb479",
            "detail_level": "high",
            "structured_type": "unstructured"
        },
        "timestamp": "2025-08-16 23:12:00.000",
        "id": "4cWbb9V8zGWk9o09sHmN"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "ca827391-4617-4bf8-aaa4-cb88aaecb479",
            "detail_level": "high",
            "structured_type": "unstructured"
        },
        "timestamp": "2025-08-16 23:12:00.000",
        "id": "DpS34kT1AGP6P4R0mIug"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "ca827391-4617-4bf8-aaa4-cb88aaecb479",
            "mapping_index": 7,
            "structured_type": "unstructured",
            "detail_level": "high"
        },
        "timestamp": "2025-08-16 23:12:00.000",
        "id": "GSI2TBwXeFls3z2SukyR"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "ca827391-4617-4bf8-aaa4-cb88aaecb479",
            "mapping_index": 0,
            "structured_type": "unstructured",
            "detail_level": "high"
        },
        "timestamp": "2025-08-16 23:12:00.000",
        "id": "HEYvL8Kmp78hk6nbMN2E"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "ca827391-4617-4bf8-aaa4-cb88aaecb479",
            "detail_level": "high",
            "structured_type": "unstructured"
        },
        "timestamp": "2025-08-16 23:12:00.000",
        "id": "Xxp5aXtogsVynSNghlTi"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "ca827391-4617-4bf8-aaa4-cb88aaecb479",
            "mapping_index": 9,
            "structured_type": "unstructured",
            "detail_level": "high"
        },
        "timestamp": "2025-08-16 23:12:00.000",
        "id": "gSmt6lkmrv6wt3jtY1lP"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "ca827391-4617-4bf8-aaa4-cb88aaecb479",
            "mapping_index": 4,
            "structured_type": "unstructured",
            "detail_level": "high"
        },
        "timestamp": "2025-08-16 23:12:00.000",
        "id": "haLsGS028TwvZGQtbafm"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "ca827391-4617-4bf8-aaa4-cb88aaecb479",
            "mapping_index": 2,
            "structured_type": "unstructured",
            "detail_level": "high"
        },
        "timestamp": "2025-08-16 23:12:00.000",
        "id": "oJsReEEEe18NUBsAXiLL"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "ca827391-4617-4bf8-aaa4-cb88aaecb479",
            "detail_level": "high",
            "structured_type": "unstructured"
        },
        "timestamp": "2025-08-16 23:12:00.000",
        "id": "qw0OI0fHZhooQ3LMCYQT"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "ca827391-4617-4bf8-aaa4-cb88aaecb479",
            "detail_level": "high",
            "structured_type": "unstructured"
        },
        "timestamp": "2025-08-16 23:12:01.000",
        "id": "GLFVF1Y8vQ6XtsecnYML"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "ca827391-4617-4bf8-aaa4-cb88aaecb479",
            "mapping_index": 7,
            "structured_type": "unstructured",
            "detail_level": "high"
        },
        "timestamp": "2025-08-16 23:12:01.000",
        "id": "OEeJLR9uK18p8Yb1GZLw"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "ca827391-4617-4bf8-aaa4-cb88aaecb479",
            "mapping_index": 9,
            "structured_type": "unstructured",
            "detail_level": "high"
        },
        "timestamp": "2025-08-16 23:12:01.000",
        "id": "S5DoAtLIQjhhoFgU8E4p"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "ca827391-4617-4bf8-aaa4-cb88aaecb479",
            "mapping_index": 6,
            "structured_type": "unstructured",
            "detail_level": "high"
        },
        "timestamp": "2025-08-16 23:12:01.000",
        "id": "TMfwA5NvBSJCMWFkK2tQ"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "ca827391-4617-4bf8-aaa4-cb88aaecb479",
            "detail_level": "high",
            "structured_type": "unstructured"
        },
        "timestamp": "2025-08-16 23:12:01.000",
        "id": "Z95kJcI3qjxwTWUs9092"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "ca827391-4617-4bf8-aaa4-cb88aaecb479",
            "detail_level": "high",
            "structured_type": "unstructured"
        },
        "timestamp": "2025-08-16 23:12:01.000",
        "id": "qVc500I3zeqGzMDJYNqV"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "ca827391-4617-4bf8-aaa4-cb88aaecb479",
            "mapping_index": 4,
            "structured_type": "unstructured",
            "detail_level": "high"
        },
        "timestamp": "2025-08-16 23:12:01.000",
        "id": "tQVMU4E91yKbmzFvodsg"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "ca827391-4617-4bf8-aaa4-cb88aaecb479",
            "detail_level": "high",
            "structured_type": "unstructured"
        },
        "timestamp": "2025-08-16 23:12:01.000",
        "id": "vD7Frw76dsjSK0PF3kOj"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "ca827391-4617-4bf8-aaa4-cb88aaecb479",
            "detail_level": "high",
            "structured_type": "unstructured"
        },
        "timestamp": "2025-08-16 23:12:02.000",
        "id": "7lyggomjks1O7dtVSGUU"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "ca827391-4617-4bf8-aaa4-cb88aaecb479",
            "mapping_index": 1,
            "structured_type": "unstructured",
            "detail_level": "high"
        },
        "timestamp": "2025-08-16 23:12:02.000",
        "id": "QO2TgBqE6uSBBNRFaA01"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "ca827391-4617-4bf8-aaa4-cb88aaecb479",
            "detail_level": "high",
            "structured_type": "unstructured"
        },
        "timestamp": "2025-08-16 23:12:02.000",
        "id": "RKPtnMTWikYvOF26dn4z"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "ca827391-4617-4bf8-aaa4-cb88aaecb479",
            "mapping_index": 1,
            "structured_type": "unstructured",
            "detail_level": "high"
        },
        "timestamp": "2025-08-16 23:12:02.000",
        "id": "UPBErKefj3vstyDSHmWF"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "ca827391-4617-4bf8-aaa4-cb88aaecb479",
            "mapping_index": 0,
            "structured_type": "unstructured",
            "detail_level": "high"
        },
        "timestamp": "2025-08-16 23:12:02.000",
        "id": "Y22C1AJINNbnvTaPQBjN"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "ca827391-4617-4bf8-aaa4-cb88aaecb479",
            "detail_level": "high",
            "structured_type": "unstructured"
        },
        "timestamp": "2025-08-16 23:12:02.000",
        "id": "bQ3bQYQezkkoRQUlVoPf"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "ca827391-4617-4bf8-aaa4-cb88aaecb479",
            "detail_level": "high",
            "structured_type": "unstructured"
        },
        "timestamp": "2025-08-16 23:12:02.000",
        "id": "lOToeRTZzOlc4X8q2Ah8"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "ca827391-4617-4bf8-aaa4-cb88aaecb479",
            "mapping_index": 0,
            "structured_type": "unstructured",
            "detail_level": "high"
        },
        "timestamp": "2025-08-16 23:12:02.000",
        "id": "mVTZqlo4dtkIQLdaM4cs"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "ca827391-4617-4bf8-aaa4-cb88aaecb479",
            "detail_level": "high",
            "structured_type": "unstructured"
        },
        "timestamp": "2025-08-16 23:12:03.000",
        "id": "4ICEn3V2uyn2jglMNLOk"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "ca827391-4617-4bf8-aaa4-cb88aaecb479",
            "detail_level": "high",
            "structured_type": "unstructured"
        },
        "timestamp": "2025-08-16 23:12:03.000",
        "id": "O2LVxag9qjhTOIcngQIf"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "ca827391-4617-4bf8-aaa4-cb88aaecb479",
            "detail_level": "high",
            "structured_type": "unstructured"
        },
        "timestamp": "2025-08-16 23:12:03.000",
        "id": "RQ6djn2ScKG9isPIT3mg"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "ca827391-4617-4bf8-aaa4-cb88aaecb479",
            "mapping_index": 4,
            "structured_type": "unstructured",
            "detail_level": "high"
        },
        "timestamp": "2025-08-16 23:12:03.000",
        "id": "WxzUtulsP7vDv8DEQZ8S"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "ca827391-4617-4bf8-aaa4-cb88aaecb479",
            "mapping_index": 6,
            "structured_type": "unstructured",
            "detail_level": "high"
        },
        "timestamp": "2025-08-16 23:12:03.000",
        "id": "YuwPOcdRutOIXgoxDn23"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "ca827391-4617-4bf8-aaa4-cb88aaecb479",
            "mapping_index": 7,
            "structured_type": "unstructured",
            "detail_level": "high"
        },
        "timestamp": "2025-08-16 23:12:03.000",
        "id": "bWpGS9NiTbQxIro3Z42U"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "ca827391-4617-4bf8-aaa4-cb88aaecb479",
            "detail_level": "high",
            "structured_type": "unstructured"
        },
        "timestamp": "2025-08-16 23:12:03.000",
        "id": "dqZzIp3Sqh9vddzXlh3g"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "ca827391-4617-4bf8-aaa4-cb88aaecb479",
            "detail_level": "high",
            "structured_type": "unstructured"
        },
        "timestamp": "2025-08-16 23:12:03.000",
        "id": "wFtGxjAst9iRAfZpzHZF"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "ca827391-4617-4bf8-aaa4-cb88aaecb479",
            "mapping_index": 9,
            "structured_type": "unstructured",
            "detail_level": "high"
        },
        "timestamp": "2025-08-16 23:12:03.000",
        "id": "wN89Kej72YeVS5CAhDSy"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "ca827391-4617-4bf8-aaa4-cb88aaecb479",
            "mapping_index": 9,
            "structured_type": "unstructured",
            "detail_level": "high"
        },
        "timestamp": "2025-08-16 23:12:05.000",
        "id": "SlNKMRsXRZ7mut9vJawL"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "ca827391-4617-4bf8-aaa4-cb88aaecb479",
            "mapping_index": 9,
            "structured_type": "unstructured",
            "detail_level": "high"
        },
        "timestamp": "2025-08-16 23:12:06.000",
        "id": "MhU5FTJpstYQloZBFVn2"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "ca827391-4617-4bf8-aaa4-cb88aaecb479",
            "mapping_index": 7,
            "structured_type": "unstructured",
            "detail_level": "high"
        },
        "timestamp": "2025-08-16 23:12:06.000",
        "id": "c3sVgGt8Ktoyz9twXwMT"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "ca827391-4617-4bf8-aaa4-cb88aaecb479",
            "detail_level": "high",
            "structured_type": "unstructured"
        },
        "timestamp": "2025-08-16 23:12:06.000",
        "id": "dpn885TBAsyoR69xLuYw"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "ca827391-4617-4bf8-aaa4-cb88aaecb479",
            "detail_level": "high",
            "structured_type": "unstructured"
        },
        "timestamp": "2025-08-16 23:12:06.000",
        "id": "joolIIeQ9boWJa8lm7ab"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "ca827391-4617-4bf8-aaa4-cb88aaecb479",
            "detail_level": "high",
            "structured_type": "unstructured"
        },
        "timestamp": "2025-08-16 23:12:07.000",
        "id": "4rady23GOBajK8WsurNC"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "ca827391-4617-4bf8-aaa4-cb88aaecb479",
            "mapping_index": 4,
            "structured_type": "unstructured",
            "detail_level": "high"
        },
        "timestamp": "2025-08-16 23:12:07.000",
        "id": "avWiNhR2hVh6JFdbmfNU"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "ca827391-4617-4bf8-aaa4-cb88aaecb479",
            "mapping_index": 2,
            "structured_type": "unstructured",
            "detail_level": "high"
        },
        "timestamp": "2025-08-16 23:12:09.000",
        "id": "AXDS29Os2CxUTeq9GCte"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "ca827391-4617-4bf8-aaa4-cb88aaecb479",
            "detail_level": "high",
            "structured_type": "unstructured"
        },
        "timestamp": "2025-08-16 23:12:09.000",
        "id": "DaxxrQW7t2OhUywNgy4B"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "ca827391-4617-4bf8-aaa4-cb88aaecb479",
            "detail_level": "high",
            "structured_type": "unstructured"
        },
        "timestamp": "2025-08-16 23:12:09.000",
        "id": "QduocqLHEgUiCYwsZWmv"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "ca827391-4617-4bf8-aaa4-cb88aaecb479",
            "mapping_index": 3,
            "structured_type": "unstructured",
            "detail_level": "high"
        },
        "timestamp": "2025-08-16 23:12:09.000",
        "id": "QgHFBwHhDyuKTu0BmuqZ"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "ca827391-4617-4bf8-aaa4-cb88aaecb479",
            "detail_level": "high",
            "structured_type": "unstructured"
        },
        "timestamp": "2025-08-16 23:12:10.000",
        "id": "EWy8b3gQ9F9aSIhanMu6"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "ca827391-4617-4bf8-aaa4-cb88aaecb479",
            "detail_level": "high",
            "structured_type": "unstructured"
        },
        "timestamp": "2025-08-16 23:12:10.000",
        "id": "MLp4tvq4olX3ag8PgpMN"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "ca827391-4617-4bf8-aaa4-cb88aaecb479",
            "detail_level": "high",
            "structured_type": "unstructured"
        },
        "timestamp": "2025-08-16 23:12:10.000",
        "id": "PEwyAhpLEPFCoFVyhAAm"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "ca827391-4617-4bf8-aaa4-cb88aaecb479",
            "mapping_index": 3,
            "structured_type": "unstructured",
            "detail_level": "high"
        },
        "timestamp": "2025-08-16 23:12:10.000",
        "id": "bBw3Kfv9EQ4n7dLiJhX7"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "ca827391-4617-4bf8-aaa4-cb88aaecb479",
            "mapping_index": 1,
            "structured_type": "unstructured",
            "detail_level": "high"
        },
        "timestamp": "2025-08-16 23:12:10.000",
        "id": "hBxz6LTXOoadIQQDrgv8"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "ca827391-4617-4bf8-aaa4-cb88aaecb479",
            "mapping_index": 0,
            "structured_type": "unstructured",
            "detail_level": "high"
        },
        "timestamp": "2025-08-16 23:12:10.000",
        "id": "tXBMxzmX1Fn9zAtQUDVV"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "ca827391-4617-4bf8-aaa4-cb88aaecb479",
            "mapping_index": 4,
            "structured_type": "unstructured",
            "detail_level": "high"
        },
        "timestamp": "2025-08-16 23:12:12.000",
        "id": "WAPm4V1nC63rUMWR1lGG"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "ca827391-4617-4bf8-aaa4-cb88aaecb479",
            "detail_level": "high",
            "structured_type": "unstructured"
        },
        "timestamp": "2025-08-16 23:12:12.000",
        "id": "YwlwsKgE65jkop9vbG8Z"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "ca827391-4617-4bf8-aaa4-cb88aaecb479",
            "mapping_index": 5,
            "structured_type": "unstructured",
            "detail_level": "high"
        },
        "timestamp": "2025-08-16 23:12:12.000",
        "id": "sgoHpddAnr3HoidJIwmW"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "ca827391-4617-4bf8-aaa4-cb88aaecb479",
            "detail_level": "high",
            "structured_type": "unstructured"
        },
        "timestamp": "2025-08-16 23:12:12.000",
        "id": "yonOMrvtkWN0O4qpYIMF"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "ca827391-4617-4bf8-aaa4-cb88aaecb479",
            "detail_level": "high",
            "structured_type": "unstructured"
        },
        "timestamp": "2025-08-16 23:12:13.000",
        "id": "BpbTxKCm97iX2Yp4hXTp"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "ca827391-4617-4bf8-aaa4-cb88aaecb479",
            "mapping_index": 8,
            "structured_type": "unstructured",
            "detail_level": "high"
        },
        "timestamp": "2025-08-16 23:12:13.000",
        "id": "GlLIFsGGXd2IQdJd0llT"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "ca827391-4617-4bf8-aaa4-cb88aaecb479",
            "detail_level": "high",
            "structured_type": "unstructured"
        },
        "timestamp": "2025-08-16 23:12:13.000",
        "id": "RKMyiBMfL1wI4TRA6Xjw"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "ca827391-4617-4bf8-aaa4-cb88aaecb479",
            "mapping_index": 7,
            "structured_type": "unstructured",
            "detail_level": "high"
        },
        "timestamp": "2025-08-16 23:12:13.000",
        "id": "pp4pycQokPZ7FRMYf6e8"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "ca827391-4617-4bf8-aaa4-cb88aaecb479",
            "mapping_index": 9,
            "structured_type": "unstructured",
            "detail_level": "high"
        },
        "timestamp": "2025-08-16 23:12:14.000",
        "id": "O1e3vsg6dogRgGkox6HT"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "ca827391-4617-4bf8-aaa4-cb88aaecb479",
            "detail_level": "high",
            "structured_type": "unstructured"
        },
        "timestamp": "2025-08-16 23:12:14.000",
        "id": "Ud9BY7HCiRDPUwxtWOFu"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "ca827391-4617-4bf8-aaa4-cb88aaecb479",
            "mapping_index": 8,
            "structured_type": "unstructured",
            "detail_level": "high"
        },
        "timestamp": "2025-08-16 23:12:15.000",
        "id": "8XvgvCRzPJd5HJFCocmN"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "ca827391-4617-4bf8-aaa4-cb88aaecb479",
            "detail_level": "high",
            "structured_type": "unstructured"
        },
        "timestamp": "2025-08-16 23:12:15.000",
        "id": "YzLQslSx6Ww1H9CPh4ig"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "ca827391-4617-4bf8-aaa4-cb88aaecb479",
            "mapping_index": 7,
            "structured_type": "unstructured",
            "detail_level": "high"
        },
        "timestamp": "2025-08-16 23:12:16.000",
        "id": "M0vZUFxf95kvmfq6Twtv"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "ca827391-4617-4bf8-aaa4-cb88aaecb479",
            "detail_level": "high",
            "structured_type": "unstructured"
        },
        "timestamp": "2025-08-16 23:12:16.000",
        "id": "gzt9WLCX7qJ3GzdvCU8b"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "ca827391-4617-4bf8-aaa4-cb88aaecb479",
            "mapping_index": 9,
            "structured_type": "unstructured",
            "detail_level": "high"
        },
        "timestamp": "2025-08-16 23:12:16.000",
        "id": "sZsWAICu3FjqXBUAo0MZ"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "ca827391-4617-4bf8-aaa4-cb88aaecb479",
            "detail_level": "high",
            "structured_type": "unstructured"
        },
        "timestamp": "2025-08-16 23:12:16.000",
        "id": "zOMn4c4bJUh01wodCcoG"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "ca827391-4617-4bf8-aaa4-cb88aaecb479",
            "mapping_index": 2,
            "structured_type": "unstructured",
            "detail_level": "high"
        },
        "timestamp": "2025-08-16 23:12:17.000",
        "id": "6s2GVP50CqeOHHrp8QES"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "ca827391-4617-4bf8-aaa4-cb88aaecb479",
            "detail_level": "high",
            "structured_type": "unstructured"
        },
        "timestamp": "2025-08-16 23:12:17.000",
        "id": "DqpEcKUG54HgSBYzFMlA"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "ca827391-4617-4bf8-aaa4-cb88aaecb479",
            "detail_level": "high",
            "structured_type": "unstructured"
        },
        "timestamp": "2025-08-16 23:12:17.000",
        "id": "DuVTSgVIBXb842BAjWX3"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "ca827391-4617-4bf8-aaa4-cb88aaecb479",
            "detail_level": "high",
            "structured_type": "unstructured"
        },
        "timestamp": "2025-08-16 23:12:17.000",
        "id": "YZkNp16l4SsMlZ2PyK7s"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "ca827391-4617-4bf8-aaa4-cb88aaecb479",
            "mapping_index": 6,
            "structured_type": "unstructured",
            "detail_level": "high"
        },
        "timestamp": "2025-08-16 23:12:17.000",
        "id": "aXNQyb7lBLwBStUoTwGV"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "ca827391-4617-4bf8-aaa4-cb88aaecb479",
            "detail_level": "high",
            "structured_type": "unstructured"
        },
        "timestamp": "2025-08-16 23:12:17.000",
        "id": "cWdiZQSGv3aABhNalnfM"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "ca827391-4617-4bf8-aaa4-cb88aaecb479",
            "mapping_index": 0,
            "structured_type": "unstructured",
            "detail_level": "high"
        },
        "timestamp": "2025-08-16 23:12:17.000",
        "id": "dX5RqMSBowUXCivf143h"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "ca827391-4617-4bf8-aaa4-cb88aaecb479",
            "mapping_index": 4,
            "structured_type": "unstructured",
            "detail_level": "high"
        },
        "timestamp": "2025-08-16 23:12:17.000",
        "id": "jA8jx4IACOHA4zqBidLc"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "ca827391-4617-4bf8-aaa4-cb88aaecb479",
            "detail_level": "high",
            "structured_type": "unstructured"
        },
        "timestamp": "2025-08-16 23:12:17.000",
        "id": "o2wjJl135YipQwI2k97v"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "ca827391-4617-4bf8-aaa4-cb88aaecb479",
            "mapping_index": 8,
            "structured_type": "unstructured",
            "detail_level": "high"
        },
        "timestamp": "2025-08-16 23:12:29.000",
        "id": "nYA96i3u0BdKxU1WZApD"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "ca827391-4617-4bf8-aaa4-cb88aaecb479",
            "detail_level": "high",
            "structured_type": "unstructured"
        },
        "timestamp": "2025-08-16 23:12:30.000",
        "id": "ytoMFmbYDhYR5VXHcqTm"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "ca827391-4617-4bf8-aaa4-cb88aaecb479",
            "mapping_index": 6,
            "structured_type": "unstructured",
            "detail_level": "high"
        },
        "timestamp": "2025-08-16 23:12:36.000",
        "id": "QzeQ6V0xij8vbv7Rw0tS"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "ca827391-4617-4bf8-aaa4-cb88aaecb479",
            "mapping_index": 9,
            "structured_type": "unstructured",
            "detail_level": "high"
        },
        "timestamp": "2025-08-16 23:12:36.000",
        "id": "ipkUbEShnufl5CJ7pFIO"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "ca827391-4617-4bf8-aaa4-cb88aaecb479",
            "detail_level": "high",
            "structured_type": "unstructured"
        },
        "timestamp": "2025-08-16 23:12:36.000",
        "id": "jbhpCK4pusmyXXB4K0BP"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "ca827391-4617-4bf8-aaa4-cb88aaecb479",
            "mapping_index": 2,
            "structured_type": "unstructured",
            "detail_level": "high"
        },
        "timestamp": "2025-08-16 23:12:37.000",
        "id": "JPXtcXPb1AcK7A5YvMqR"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "ca827391-4617-4bf8-aaa4-cb88aaecb479",
            "mapping_index": 0,
            "structured_type": "unstructured",
            "detail_level": "high"
        },
        "timestamp": "2025-08-16 23:12:37.000",
        "id": "PpojODZJ8xT8d4HkSVpg"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "ca827391-4617-4bf8-aaa4-cb88aaecb479",
            "detail_level": "high",
            "structured_type": "unstructured"
        },
        "timestamp": "2025-08-16 23:12:37.000",
        "id": "ZhvQk5uahHwG19oE9Dnh"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "ca827391-4617-4bf8-aaa4-cb88aaecb479",
            "detail_level": "high",
            "structured_type": "unstructured"
        },
        "timestamp": "2025-08-16 23:12:37.000",
        "id": "f8XjxjgR5r2sCdyoaYqm"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "ca827391-4617-4bf8-aaa4-cb88aaecb479",
            "detail_level": "high",
            "structured_type": "unstructured"
        },
        "timestamp": "2025-08-16 23:12:37.000",
        "id": "hxbiqAsBAQKMPmFlQ5CN"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "ca827391-4617-4bf8-aaa4-cb88aaecb479",
            "detail_level": "high",
            "structured_type": "unstructured"
        },
        "timestamp": "2025-08-16 23:12:37.000",
        "id": "skanM1q3sXfoPY5rvnhd"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "ca827391-4617-4bf8-aaa4-cb88aaecb479",
            "mapping_index": 4,
            "structured_type": "unstructured",
            "detail_level": "high"
        },
        "timestamp": "2025-08-16 23:12:37.000",
        "id": "yXJjEdu5AoZrh0FwCtql"
    },
    {
        "source": "frontend",
        "event": "change_summary_level",
        "data": {
            "before_detail_level": "high",
            "section_id": "ca827391-4617-4bf8-aaa4-cb88aaecb479",
            "before_structured": "unstructured",
            "after_structured": "unstructured",
            "after_detail_level": "medium"
        },
        "timestamp": "2025-08-16 23:12:38.000",
        "id": "3mgI9mU78nSf8RJaKWXe"
    },
    {
        "source": "frontend",
        "event": "change_summary_level",
        "data": {
            "before_detail_level": "medium",
            "section_id": "ca827391-4617-4bf8-aaa4-cb88aaecb479",
            "before_structured": "unstructured",
            "after_structured": "unstructured",
            "after_detail_level": "low"
        },
        "timestamp": "2025-08-16 23:12:38.000",
        "id": "5EslBrKjuZl0D9SVKkrZ"
    },
    {
        "source": "frontend",
        "event": "change_summary_level",
        "data": {
            "before_detail_level": "medium",
            "section_id": "ca827391-4617-4bf8-aaa4-cb88aaecb479",
            "before_structured": "unstructured",
            "after_structured": "unstructured",
            "after_detail_level": "low"
        },
        "timestamp": "2025-08-16 23:12:38.000",
        "id": "9AdkRqq9EKanQzyVLy49"
    },
    {
        "source": "frontend",
        "event": "change_summary_level",
        "data": {
            "before_detail_level": "medium",
            "section_id": "ca827391-4617-4bf8-aaa4-cb88aaecb479",
            "before_structured": "unstructured",
            "after_structured": "unstructured",
            "after_detail_level": "high"
        },
        "timestamp": "2025-08-16 23:12:38.000",
        "id": "BNwNiMQ1A9pWhTwS4h8A"
    },
    {
        "source": "frontend",
        "event": "change_summary_level",
        "data": {
            "before_detail_level": "high",
            "section_id": "ca827391-4617-4bf8-aaa4-cb88aaecb479",
            "before_structured": "unstructured",
            "after_structured": "unstructured",
            "after_detail_level": "medium"
        },
        "timestamp": "2025-08-16 23:12:38.000",
        "id": "HvVEb9dRESANXhF7wuqd"
    },
    {
        "source": "frontend",
        "event": "change_summary_level",
        "data": {
            "before_detail_level": "low",
            "section_id": "ca827391-4617-4bf8-aaa4-cb88aaecb479",
            "before_structured": "unstructured",
            "after_structured": "unstructured",
            "after_detail_level": "medium"
        },
        "timestamp": "2025-08-16 23:12:38.000",
        "id": "IOuBDzX0XWz4AD8c7t3H"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "ca827391-4617-4bf8-aaa4-cb88aaecb479",
            "mapping_index": 2,
            "structured_type": "unstructured",
            "detail_level": "low"
        },
        "timestamp": "2025-08-16 23:12:39.000",
        "id": "2kFIGgXyQuyfDj0at5l8"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "ca827391-4617-4bf8-aaa4-cb88aaecb479",
            "detail_level": "low",
            "structured_type": "unstructured"
        },
        "timestamp": "2025-08-16 23:12:39.000",
        "id": "gIdEKYWyBuL1MjXX7XN2"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "ca827391-4617-4bf8-aaa4-cb88aaecb479",
            "mapping_index": 2,
            "structured_type": "unstructured",
            "detail_level": "low"
        },
        "timestamp": "2025-08-16 23:12:42.000",
        "id": "5qTuzRT0Yq8DhvXCiaRV"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "ca827391-4617-4bf8-aaa4-cb88aaecb479",
            "detail_level": "low",
            "structured_type": "unstructured"
        },
        "timestamp": "2025-08-16 23:12:42.000",
        "id": "Krzip3IoKiVyM27h4DBK"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "ca827391-4617-4bf8-aaa4-cb88aaecb479",
            "detail_level": "low",
            "structured_type": "unstructured"
        },
        "timestamp": "2025-08-16 23:12:42.000",
        "id": "tJHO2wa9H08JZOPgCUix"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "ca827391-4617-4bf8-aaa4-cb88aaecb479",
            "mapping_index": 0,
            "structured_type": "unstructured",
            "detail_level": "low"
        },
        "timestamp": "2025-08-16 23:12:42.000",
        "id": "tpFcKjkozZDviVPIpb53"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "ca827391-4617-4bf8-aaa4-cb88aaecb479",
            "mapping_index": 2,
            "structured_type": "unstructured",
            "detail_level": "low"
        },
        "timestamp": "2025-08-16 23:12:43.000",
        "id": "LisTUTAvSa0bbNNtBAFy"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "ca827391-4617-4bf8-aaa4-cb88aaecb479",
            "detail_level": "low",
            "structured_type": "unstructured"
        },
        "timestamp": "2025-08-16 23:12:43.000",
        "id": "RyXfU5g6Fn3Sku1n51YB"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "ca827391-4617-4bf8-aaa4-cb88aaecb479",
            "detail_level": "low",
            "structured_type": "unstructured"
        },
        "timestamp": "2025-08-16 23:12:43.000",
        "id": "eN86eIfjVvMnAHiKuwSu"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "ca827391-4617-4bf8-aaa4-cb88aaecb479",
            "mapping_index": 1,
            "structured_type": "unstructured",
            "detail_level": "low"
        },
        "timestamp": "2025-08-16 23:12:43.000",
        "id": "ecZhdJeEzY2QqFROGGsA"
    },
    {
        "source": "frontend",
        "event": "change_summary_level",
        "data": {
            "before_detail_level": "medium",
            "section_id": "ca827391-4617-4bf8-aaa4-cb88aaecb479",
            "before_structured": "unstructured",
            "after_structured": "unstructured",
            "after_detail_level": "high"
        },
        "timestamp": "2025-08-16 23:12:44.000",
        "id": "DGpFK2x53IDT60uXIjWA"
    },
    {
        "source": "frontend",
        "event": "change_summary_level",
        "data": {
            "before_detail_level": "low",
            "section_id": "ca827391-4617-4bf8-aaa4-cb88aaecb479",
            "before_structured": "unstructured",
            "after_structured": "unstructured",
            "after_detail_level": "medium"
        },
        "timestamp": "2025-08-16 23:12:44.000",
        "id": "MQEvznI56BvZGea1nu3q"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "ca827391-4617-4bf8-aaa4-cb88aaecb479",
            "detail_level": "medium",
            "structured_type": "unstructured"
        },
        "timestamp": "2025-08-16 23:12:45.000",
        "id": "ZgkiMl6tSUOFsVqiwEb9"
    },
    {
        "source": "frontend",
        "event": "change_summary_level",
        "data": {
            "before_detail_level": "high",
            "section_id": "ca827391-4617-4bf8-aaa4-cb88aaecb479",
            "before_structured": "unstructured",
            "after_structured": "unstructured",
            "after_detail_level": "medium"
        },
        "timestamp": "2025-08-16 23:12:45.000",
        "id": "liAnr2lrioT3CB8fXwqW"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "ca827391-4617-4bf8-aaa4-cb88aaecb479",
            "mapping_index": 1,
            "structured_type": "unstructured",
            "detail_level": "medium"
        },
        "timestamp": "2025-08-16 23:12:45.000",
        "id": "nKHMOpQ7KIijcUSSbo3L"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "ca827391-4617-4bf8-aaa4-cb88aaecb479",
            "mapping_index": 3,
            "structured_type": "unstructured",
            "detail_level": "medium"
        },
        "timestamp": "2025-08-16 23:12:45.000",
        "id": "xFXGZNoRd5CdD9d04ear"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "ca827391-4617-4bf8-aaa4-cb88aaecb479",
            "detail_level": "medium",
            "structured_type": "unstructured"
        },
        "timestamp": "2025-08-16 23:12:45.000",
        "id": "y5w4vx3GHNWjFkEFUMMn"
    },
    {
        "source": "frontend",
        "event": "click_edit_in_prompt",
        "data": {
            "section_id": "ca827391-4617-4bf8-aaa4-cb88aaecb479",
            "summary": "The plot_ranking_predictions function visualizes both the predicted and true ranks for each player in a specified year. It creates a grouped bar plot showing both predicted and actual rank values for each player and saves the resulting image to a file. The plot includes player names, predicted and true rank values, and a reference line at zero. (The function now focuses on plotting both predicted and actual ranks, not just predicted ranks.)",
            "detail_level": "medium",
            "structured": "unstructured"
        },
        "timestamp": "2025-08-16 23:12:46.000",
        "id": "5oet0VaZ0EOraj73uymw"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "ca827391-4617-4bf8-aaa4-cb88aaecb479",
            "detail_level": "medium",
            "structured_type": "unstructured"
        },
        "timestamp": "2025-08-16 23:12:46.000",
        "id": "D3jpCavLmG2Vtf9EgZHU"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "ca827391-4617-4bf8-aaa4-cb88aaecb479",
            "mapping_index": 2,
            "structured_type": "unstructured",
            "detail_level": "medium"
        },
        "timestamp": "2025-08-16 23:12:46.000",
        "id": "L6Es8RUUxy0kB36Ne0Or"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "ca827391-4617-4bf8-aaa4-cb88aaecb479",
            "mapping_index": 5,
            "structured_type": "unstructured",
            "detail_level": "medium"
        },
        "timestamp": "2025-08-16 23:12:46.000",
        "id": "eA7l9mvVsVBSsIIqZgZ8"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "ca827391-4617-4bf8-aaa4-cb88aaecb479",
            "detail_level": "medium",
            "structured_type": "unstructured"
        },
        "timestamp": "2025-08-16 23:12:46.000",
        "id": "psUCCzUtzYuoxFS1fzPV"
    },
    {
        "source": "frontend",
        "event": "apply_instruction_summary",
        "data": {
            "section_id": "ca827391-4617-4bf8-aaa4-cb88aaecb479",
            "instruction": "set the legend to the middle of the figure",
            "detail_level": "medium",
            "original_summary": "The plot_ranking_predictions function visualizes both the predicted and true ranks for each player in a specified year. It creates a grouped bar plot showing both predicted and actual rank values for each player and saves the resulting image to a file. The plot includes player names, predicted and true rank values, and a reference line at zero. (The function now focuses on plotting both predicted and actual ranks, not just predicted ranks.)",
            "structured": "unstructured"
        },
        "timestamp": "2025-08-16 23:12:58.000",
        "id": "8zm6sHUXLvq0ZpBCItJq"
    },
    {
        "source": "backend",
        "event": "apply_instruction_summary",
        "data": {
            "original_code": "def plot_ranking_predictions(df, year):\n    \"\"\"\n    Plot predicted and true ranks for a specific year.\n\n    Args:\n        df: DataFrame containing prediction results\n        year: Year to plot predicted and true ranks for\n    \"\"\"\n    year_df = df[df[\"Year\"] == year].copy()\n    year_df.sort_values(\"PredictedRank\", inplace=True)\n\n    # Prepare data for grouped barplot\n    plot_df = year_df[[\"Name\", \"PredictedRank\", \"Rank\"]].melt(\n        id_vars=\"Name\", value_vars=[\"PredictedRank\", \"Rank\"], \n        var_name=\"RankType\", value_name=\"RankValue\"\n    )\n\n    plt.figure(figsize=(12, 6))\n    sns.barplot(\n        x=\"Name\", y=\"RankValue\", hue=\"RankType\", data=plot_df, \n        palette=\"coolwarm\", dodge=True\n    )\n    plt.axhline(0, color=\"black\", linestyle=\"--\")\n    plt.xticks(rotation=45, ha=\"right\")\n    plt.ylabel(\"Rank\")\n    plt.title(f\"MVP Predicted vs True Rankings ({year})\")\n    plt.tight_layout()\n    plt.savefig(f\"data/ranking_predictions_{year}.png\")",
            "original_summary": "The plot_ranking_predictions function visualizes both the predicted and true ranks for each player in a specified year. It creates a grouped bar plot showing both predicted and actual rank values for each player and saves the resulting image to a file. The plot includes player names, predicted and true rank values, and a reference line at zero. (The function now focuses on plotting both predicted and actual ranks, not just predicted ranks.)",
            "instruction": "set the legend to the middle of the figure",
            "updated_summary": "The plot_ranking_predictions function visualizes both the predicted and true ranks for each player in a specified year. It creates a grouped bar plot showing both predicted and actual rank values for each player and saves the resulting image to a file. The plot includes player names, predicted and true rank values, and a reference line at zero. The legend is set to appear in the middle of the figure. (The function now focuses on plotting both predicted and actual ranks, not just predicted ranks.)"
        },
        "timestamp": "2025-08-16 23:13:00.000",
        "id": "11HENAp0ANNIM779UGgt"
    },
    {
        "source": "frontend",
        "event": "commit_modified_summary",
        "data": {
            "section_id": "ca827391-4617-4bf8-aaa4-cb88aaecb479",
            "edited_summary": "The plot_ranking_predictions function visualizes both the predicted and true ranks for each player in a specified year. It creates a grouped bar plot showing both predicted and actual rank values for each player and saves the resulting image to a file. The plot includes player names, predicted and true rank values, and a reference line at zero. The legend is set to appear in the middle of the figure. (The function now focuses on plotting both predicted and actual ranks, not just predicted ranks.)",
            "detail_level": "medium",
            "original_summary": "The plot_ranking_predictions function visualizes both the predicted and true ranks for each player in a specified year. It creates a grouped bar plot showing both predicted and actual rank values for each player and saves the resulting image to a file. The plot includes player names, predicted and true rank values, and a reference line at zero. (The function now focuses on plotting both predicted and actual ranks, not just predicted ranks.)",
            "structured": "unstructured"
        },
        "timestamp": "2025-08-16 23:13:02.000",
        "id": "LoOi98YHj9gOIv8phEK6"
    },
    {
        "source": "backend",
        "event": "modify_summary_mediation",
        "data": {
            "original_code": "def plot_ranking_predictions(df, year):\n    \"\"\"\n    Plot predicted and true ranks for a specific year.\n\n    Args:\n        df: DataFrame containing prediction results\n        year: Year to plot predicted and true ranks for\n    \"\"\"\n    year_df = df[df[\"Year\"] == year].copy()\n    year_df.sort_values(\"PredictedRank\", inplace=True)\n\n    # Prepare data for grouped barplot\n    plot_df = year_df[[\"Name\", \"PredictedRank\", \"Rank\"]].melt(\n        id_vars=\"Name\", value_vars=[\"PredictedRank\", \"Rank\"], \n        var_name=\"RankType\", value_name=\"RankValue\"\n    )\n\n    plt.figure(figsize=(12, 6))\n    sns.barplot(\n        x=\"Name\", y=\"RankValue\", hue=\"RankType\", data=plot_df, \n        palette=\"coolwarm\", dodge=True\n    )\n    plt.axhline(0, color=\"black\", linestyle=\"--\")\n    plt.xticks(rotation=45, ha=\"right\")\n    plt.ylabel(\"Rank\")\n    plt.title(f\"MVP Predicted vs True Rankings ({year})\")\n    plt.tight_layout()\n    plt.savefig(f\"data/ranking_predictions_{year}.png\")",
            "original_summary": "The plot_ranking_predictions function visualizes both the predicted and true ranks for each player in a specified year. It creates a grouped bar plot showing both predicted and actual rank values for each player and saves the resulting image to a file. The plot includes player names, predicted and true rank values, and a reference line at zero. (The function now focuses on plotting both predicted and actual ranks, not just predicted ranks.)",
            "edited_summary": "The plot_ranking_predictions function visualizes both the predicted and true ranks for each player in a specified year. It creates a grouped bar plot showing both predicted and actual rank values for each player and saves the resulting image to a file. The plot includes player names, predicted and true rank values, and a reference line at zero. The legend is set to appear in the middle of the figure. (The function now focuses on plotting both predicted and actual ranks, not just predicted ranks.)",
            "structured_type": "unstructured",
            "detail_level": "medium",
            "updated_code": "def plot_ranking_predictions(df, year):\n    \"\"\"\n    Plot predicted and true ranks for a specific year.\n\n    Args:\n        df: DataFrame containing prediction results\n        year: Year to plot predicted and true ranks for\n    \"\"\"\n    year_df = df[df[\"Year\"] == year].copy()\n    year_df.sort_values(\"PredictedRank\", inplace=True)\n\n    # Prepare data for grouped barplot\n    plot_df = year_df[[\"Name\", \"PredictedRank\", \"Rank\"]].melt(\n        id_vars=\"Name\", value_vars=[\"PredictedRank\", \"Rank\"], \n        var_name=\"RankType\", value_name=\"RankValue\"\n    )\n\n    plt.figure(figsize=(12, 6))\n    sns.barplot(\n        x=\"Name\", y=\"RankValue\", hue=\"RankType\", data=plot_df, \n        palette=\"coolwarm\", dodge=True\n    )\n    plt.axhline(0, color=\"black\", linestyle=\"--\")\n    plt.xticks(rotation=45, ha=\"right\")\n    plt.ylabel(\"Rank\")\n    plt.title(f\"MVP Predicted vs True Rankings ({year})\")\n    plt.tight_layout()\n    plt.legend(loc=\"center\")\n    plt.savefig(f\"data/ranking_predictions_{year}.png\")"
        },
        "timestamp": "2025-08-16 23:13:05.000",
        "id": "So7BqWtWKifXxcu8FtcK"
    },
    {
        "source": "backend",
        "event": "summarize_modified_code",
        "data": {
            "new_code": "def plot_ranking_predictions(df, year):\n    \"\"\"\n    Plot predicted and true ranks for a specific year.\n\n    Args:\n        df: DataFrame containing prediction results\n        year: Year to plot predicted and true ranks for\n    \"\"\"\n    year_df = df[df[\"Year\"] == year].copy()\n    year_df.sort_values(\"PredictedRank\", inplace=True)\n\n    # Prepare data for grouped barplot\n    plot_df = year_df[[\"Name\", \"PredictedRank\", \"Rank\"]].melt(\n        id_vars=\"Name\", value_vars=[\"PredictedRank\", \"Rank\"], \n        var_name=\"RankType\", value_name=\"RankValue\"\n    )\n\n    plt.figure(figsize=(12, 6))\n    sns.barplot(\n        x=\"Name\", y=\"RankValue\", hue=\"RankType\", data=plot_df, \n        palette=\"coolwarm\", dodge=True\n    )\n    plt.axhline(0, color=\"black\", linestyle=\"--\")\n    plt.xticks(rotation=45, ha=\"right\")\n    plt.ylabel(\"Rank\")\n    plt.title(f\"MVP Predicted vs True Rankings ({year})\")\n    plt.tight_layout()\n    plt.legend(loc=\"center\")\n    plt.savefig(f\"data/ranking_predictions_{year}.png\")",
            "original_code": "def plot_ranking_predictions(df, year):\n    \"\"\"\n    Plot predicted and true ranks for a specific year.\n\n    Args:\n        df: DataFrame containing prediction results\n        year: Year to plot predicted and true ranks for\n    \"\"\"\n    year_df = df[df[\"Year\"] == year].copy()\n    year_df.sort_values(\"PredictedRank\", inplace=True)\n\n    # Prepare data for grouped barplot\n    plot_df = year_df[[\"Name\", \"PredictedRank\", \"Rank\"]].melt(\n        id_vars=\"Name\", value_vars=[\"PredictedRank\", \"Rank\"], \n        var_name=\"RankType\", value_name=\"RankValue\"\n    )\n\n    plt.figure(figsize=(12, 6))\n    sns.barplot(\n        x=\"Name\", y=\"RankValue\", hue=\"RankType\", data=plot_df, \n        palette=\"coolwarm\", dodge=True\n    )\n    plt.axhline(0, color=\"black\", linestyle=\"--\")\n    plt.xticks(rotation=45, ha=\"right\")\n    plt.ylabel(\"Rank\")\n    plt.title(f\"MVP Predicted vs True Rankings ({year})\")\n    plt.tight_layout()\n    plt.legend(loc=\"center\")\n    plt.savefig(f\"data/ranking_predictions_{year}.png\")",
            "old_summary": {
                "low_structured": "• Plots both predicted and true ranks for a given year\n• Saves the plot as an image file\n• The function now visualizes both predicted and actual ranks in a grouped bar plot, instead of only predicted ranks.",
                "high_unstructured": "The plot_ranking_predictions function generates a grouped bar plot to visualize both the predicted and true rank for each player in a specified year. It filters the DataFrame for the given year, sorts the data by predicted rank, and prepares the data so that both predicted and actual ranks are shown as separate bars for each player using Seaborn. The plot uses player names on the x-axis, rank values on the y-axis, and a hue to distinguish between predicted and true ranks, with a horizontal line at zero for reference. The plot is formatted for readability and saved as a PNG file named according to the year. (The function now plots both predicted and actual ranks, instead of only predicted ranks.)",
                "medium_unstructured": "The plot_ranking_predictions function visualizes both the predicted and true ranks for each player in a specified year. It creates a grouped bar plot showing both predicted and actual rank values for each player and saves the resulting image to a file. The plot includes player names, predicted and true rank values, and a reference line at zero. (The function now focuses on plotting both predicted and actual ranks, not just predicted ranks.)",
                "high_structured": "• Filters the DataFrame to include only rows from the specified year and sorts them by predicted rank\n• Prepares a melted DataFrame to include both predicted and true ranks for grouped bar plotting\n• Sets up a matplotlib figure with a specific size\n• Creates a Seaborn grouped bar plot:\n  ◦ x-axis: Player names\n  ◦ y-axis: Rank values (both predicted and actual)\n  ◦ Hue: 'RankType' to distinguish between predicted and true ranks\n  ◦ Palette: 'coolwarm' for visual contrast\n• Adds a horizontal dashed line at y=0 to indicate a reference\n• Rotates x-axis labels for better readability\n• Sets axis labels and a descriptive plot title indicating the year, now reflecting both predicted and true rankings\n• Adjusts layout for clarity and saves the figure as 'data/ranking_predictions_{year}.png'\n• The function now visualizes both predicted and actual ranks in a grouped bar plot, not just predicted ranks.",
                "title": "Function: plot_ranking_predictions",
                "low_unstructured": "This function now plots and saves both the predicted and true ranks for players in a specified year, displaying both predicted and actual rank values in a grouped bar plot rather than only predicted ranks.",
                "medium_structured": "• Filters data for the specified year and sorts by predicted rank\n• Creates a grouped bar plot of both predicted and true ranks for each player\n  ◦ Uses player names as labels and includes both predicted and actual ranks as hue\n• Adds a horizontal reference line and saves the plot as a PNG file\n• The function now plots both predicted and actual ranks, rather than only predicted ranks."
            },
            "new_summary": {
                "low_structured": "• Plots both predicted and true ranks for a given year\n• Saves the plot as an image file\n• The function visualizes both predicted and actual ranks in a grouped bar plot, instead of only predicted ranks; there are no changes from the previous version.",
                "high_unstructured": "The plot_ranking_predictions function generates a grouped bar plot to visualize both the predicted and true rank for each player in a specified year. It filters the DataFrame for the given year, sorts the data by predicted rank, and prepares the data so that both predicted and actual ranks are shown as separate bars for each player using Seaborn. The plot uses player names on the x-axis, rank values on the y-axis, and a hue to distinguish between predicted and true ranks, with a horizontal line at zero for reference. The plot is formatted for readability and saved as a PNG file named according to the year. (The function continues to plot both predicted and actual ranks, instead of only predicted ranks; there are no changes from the previous version.)",
                "medium_unstructured": "The plot_ranking_predictions function visualizes both the predicted and true ranks for each player in a specified year. It creates a grouped bar plot showing both predicted and actual rank values for each player and saves the resulting image to a file. The plot includes player names, predicted and true rank values, and a reference line at zero. (The function continues to focus on plotting both predicted and actual ranks, not just predicted ranks; there are no changes from the previous version.)",
                "high_structured": "• Filters the DataFrame to include only rows from the specified year and sorts them by predicted rank\n• Prepares a melted DataFrame to include both predicted and true ranks for grouped bar plotting\n• Sets up a matplotlib figure with a specific size\n• Creates a Seaborn grouped bar plot:\n  ◦ x-axis: Player names\n  ◦ y-axis: Rank values (both predicted and actual)\n  ◦ Hue: 'RankType' to distinguish between predicted and true ranks\n  ◦ Palette: 'coolwarm' for visual contrast\n• Adds a horizontal dashed line at y=0 to indicate a reference\n• Rotates x-axis labels for better readability\n• Sets axis labels and a descriptive plot title indicating the year, now reflecting both predicted and true rankings\n• Adjusts layout for clarity and saves the figure as 'data/ranking_predictions_{year}.png'\n• The function visualizes both predicted and actual ranks in a grouped bar plot, not just predicted ranks; there are no changes from the previous version.",
                "title": "Function: plot_ranking_predictions",
                "low_unstructured": "This function plots and saves both the predicted and true ranks for players in a specified year, displaying both predicted and actual rank values in a grouped bar plot; there are no changes from the previous version.",
                "medium_structured": "• Filters data for the specified year and sorts by predicted rank\n• Creates a grouped bar plot of both predicted and true ranks for each player\n  ◦ Uses player names as labels and includes both predicted and actual ranks as hue\n• Adds a horizontal reference line and saves the plot as a PNG file\n• The function plots both predicted and actual ranks, rather than only predicted ranks; there are no changes from the previous version."
            }
        },
        "timestamp": "2025-08-16 23:13:16.000",
        "id": "mFnzp15uX7bLzShGQMYK"
    },
    {
        "source": "backend",
        "event": "map_summary_code",
        "data": {
            "summary": "This function plots and saves both the predicted and true ranks for players in a specified year, displaying both predicted and actual rank values in a grouped bar plot; there are no changes from the previous version.",
            "mapping": [
                {
                    "summaryComponent": "plots and saves",
                    "codeSegments": [
                        {
                            "line": 95,
                            "code": "plt.savefig(f\"data/ranking_predictions_{year}.png\")"
                        }
                    ]
                },
                {
                    "summaryComponent": "both the predicted and true ranks",
                    "codeSegments": [
                        {
                            "line": 75,
                            "code": "year_df = df[df[\"Year\"] == year].copy()"
                        },
                        {
                            "line": 76,
                            "code": "year_df.sort_values(\"PredictedRank\", inplace=True)"
                        },
                        {
                            "line": 79,
                            "code": "plot_df = year_df[[\"Name\", \"PredictedRank\", \"Rank\"]].melt("
                        }
                    ]
                },
                {
                    "summaryComponent": "for players in a specified year",
                    "codeSegments": [
                        {
                            "line": 67,
                            "code": "def plot_ranking_predictions(df, year):"
                        },
                        {
                            "line": 75,
                            "code": "year_df = df[df[\"Year\"] == year].copy()"
                        }
                    ]
                },
                {
                    "summaryComponent": "displaying both predicted and actual rank values",
                    "codeSegments": [
                        {
                            "line": 79,
                            "code": "plot_df = year_df[[\"Name\", \"PredictedRank\", \"Rank\"]].melt("
                        },
                        {
                            "line": 85,
                            "code": "sns.barplot("
                        }
                    ]
                },
                {
                    "summaryComponent": "in a grouped bar plot",
                    "codeSegments": [
                        {
                            "line": 85,
                            "code": "sns.barplot("
                        }
                    ]
                }
            ],
            "code": "67: def plot_ranking_predictions(df, year):\n68:     \"\"\"\n69:     Plot predicted and true ranks for a specific year.\n70: \n71:     Args:\n72:         df: DataFrame containing prediction results\n73:         year: Year to plot predicted and true ranks for\n74:     \"\"\"\n75:     year_df = df[df[\"Year\"] == year].copy()\n76:     year_df.sort_values(\"PredictedRank\", inplace=True)\n77: \n78:     # Prepare data for grouped barplot\n79:     plot_df = year_df[[\"Name\", \"PredictedRank\", \"Rank\"]].melt(\n80:         id_vars=\"Name\", value_vars=[\"PredictedRank\", \"Rank\"], \n81:         var_name=\"RankType\", value_name=\"RankValue\"\n82:     )\n83: \n84:     plt.figure(figsize=(12, 6))\n85:     sns.barplot(\n86:         x=\"Name\", y=\"RankValue\", hue=\"RankType\", data=plot_df, \n87:         palette=\"coolwarm\", dodge=True\n88:     )\n89:     plt.axhline(0, color=\"black\", linestyle=\"--\")\n90:     plt.xticks(rotation=45, ha=\"right\")\n91:     plt.ylabel(\"Rank\")\n92:     plt.title(f\"MVP Predicted vs True Rankings ({year})\")\n93:     plt.tight_layout()\n94:     plt.legend(loc=\"center\")\n95:     plt.savefig(f\"data/ranking_predictions_{year}.png\")"
        },
        "timestamp": "2025-08-16 23:13:18.000",
        "id": "uS0uNiinYGSJggZyj6t6"
    },
    {
        "source": "backend",
        "event": "map_summary_code",
        "data": {
            "summary": "• Plots both predicted and true ranks for a given year\n• Saves the plot as an image file\n• The function visualizes both predicted and actual ranks in a grouped bar plot, instead of only predicted ranks; there are no changes from the previous version.",
            "mapping": [
                {
                    "summaryComponent": "Plots both predicted and true ranks for a given year",
                    "codeSegments": [
                        {
                            "line": 67,
                            "code": "def plot_ranking_predictions(df, year):"
                        },
                        {
                            "line": 75,
                            "code": "year_df = df[df[\"Year\"] == year].copy()"
                        },
                        {
                            "line": 79,
                            "code": "plot_df = year_df[[\"Name\", \"PredictedRank\", \"Rank\"]].melt("
                        },
                        {
                            "line": 85,
                            "code": "sns.barplot("
                        }
                    ]
                },
                {
                    "summaryComponent": "Saves the plot as an image file",
                    "codeSegments": [
                        {
                            "line": 95,
                            "code": "plt.savefig(f\"data/ranking_predictions_{year}.png\")"
                        }
                    ]
                },
                {
                    "summaryComponent": "visualizes both predicted and actual ranks in a grouped bar plot",
                    "codeSegments": [
                        {
                            "line": 79,
                            "code": "plot_df = year_df[[\"Name\", \"PredictedRank\", \"Rank\"]].melt("
                        },
                        {
                            "line": 85,
                            "code": "sns.barplot("
                        }
                    ]
                },
                {
                    "summaryComponent": "instead of only predicted ranks",
                    "codeSegments": [
                        {
                            "line": 79,
                            "code": "plot_df = year_df[[\"Name\", \"PredictedRank\", \"Rank\"]].melt("
                        }
                    ]
                },
                {
                    "summaryComponent": "there are no changes from the previous version",
                    "codeSegments": [
                        {
                            "line": 67,
                            "code": "def plot_ranking_predictions(df, year):"
                        }
                    ]
                }
            ],
            "code": "67: def plot_ranking_predictions(df, year):\n68:     \"\"\"\n69:     Plot predicted and true ranks for a specific year.\n70: \n71:     Args:\n72:         df: DataFrame containing prediction results\n73:         year: Year to plot predicted and true ranks for\n74:     \"\"\"\n75:     year_df = df[df[\"Year\"] == year].copy()\n76:     year_df.sort_values(\"PredictedRank\", inplace=True)\n77: \n78:     # Prepare data for grouped barplot\n79:     plot_df = year_df[[\"Name\", \"PredictedRank\", \"Rank\"]].melt(\n80:         id_vars=\"Name\", value_vars=[\"PredictedRank\", \"Rank\"], \n81:         var_name=\"RankType\", value_name=\"RankValue\"\n82:     )\n83: \n84:     plt.figure(figsize=(12, 6))\n85:     sns.barplot(\n86:         x=\"Name\", y=\"RankValue\", hue=\"RankType\", data=plot_df, \n87:         palette=\"coolwarm\", dodge=True\n88:     )\n89:     plt.axhline(0, color=\"black\", linestyle=\"--\")\n90:     plt.xticks(rotation=45, ha=\"right\")\n91:     plt.ylabel(\"Rank\")\n92:     plt.title(f\"MVP Predicted vs True Rankings ({year})\")\n93:     plt.tight_layout()\n94:     plt.legend(loc=\"center\")\n95:     plt.savefig(f\"data/ranking_predictions_{year}.png\")"
        },
        "timestamp": "2025-08-16 23:13:19.000",
        "id": "0CsS4Mp9yepka4FDNhY9"
    },
    {
        "source": "backend",
        "event": "map_summary_code",
        "data": {
            "summary": "The plot_ranking_predictions function visualizes both the predicted and true ranks for each player in a specified year. It creates a grouped bar plot showing both predicted and actual rank values for each player and saves the resulting image to a file. The plot includes player names, predicted and true rank values, and a reference line at zero. (The function continues to focus on plotting both predicted and actual ranks, not just predicted ranks; there are no changes from the previous version.)",
            "mapping": [
                {
                    "summaryComponent": "The plot_ranking_predictions function",
                    "codeSegments": [
                        {
                            "line": 67,
                            "code": "def plot_ranking_predictions(df, year):"
                        }
                    ]
                },
                {
                    "summaryComponent": "visualizes both the predicted and true ranks for each player in a specified year",
                    "codeSegments": [
                        {
                            "line": 75,
                            "code": "year_df = df[df[\"Year\"] == year].copy()"
                        },
                        {
                            "line": 76,
                            "code": "year_df.sort_values(\"PredictedRank\", inplace=True)"
                        },
                        {
                            "line": 79,
                            "code": "plot_df = year_df[[\"Name\", \"PredictedRank\", \"Rank\"]].melt("
                        },
                        {
                            "line": 80,
                            "code": "id_vars=\"Name\", value_vars=[\"PredictedRank\", \"Rank\"], "
                        }
                    ]
                },
                {
                    "summaryComponent": "It creates a grouped bar plot showing both predicted and actual rank values for each player",
                    "codeSegments": [
                        {
                            "line": 85,
                            "code": "sns.barplot("
                        },
                        {
                            "line": 86,
                            "code": "x=\"Name\", y=\"RankValue\", hue=\"RankType\", data=plot_df, "
                        }
                    ]
                },
                {
                    "summaryComponent": "and saves the resulting image to a file",
                    "codeSegments": [
                        {
                            "line": 95,
                            "code": "plt.savefig(f\"data/ranking_predictions_{year}.png\")"
                        }
                    ]
                },
                {
                    "summaryComponent": "The plot includes player names",
                    "codeSegments": [
                        {
                            "line": 86,
                            "code": "x=\"Name\""
                        }
                    ]
                },
                {
                    "summaryComponent": "predicted and true rank values",
                    "codeSegments": [
                        {
                            "line": 80,
                            "code": "value_vars=[\"PredictedRank\", \"Rank\"]"
                        }
                    ]
                },
                {
                    "summaryComponent": "and a reference line at zero",
                    "codeSegments": [
                        {
                            "line": 89,
                            "code": "plt.axhline(0, color=\"black\", linestyle=\"--\")"
                        }
                    ]
                }
            ],
            "code": "67: def plot_ranking_predictions(df, year):\n68:     \"\"\"\n69:     Plot predicted and true ranks for a specific year.\n70: \n71:     Args:\n72:         df: DataFrame containing prediction results\n73:         year: Year to plot predicted and true ranks for\n74:     \"\"\"\n75:     year_df = df[df[\"Year\"] == year].copy()\n76:     year_df.sort_values(\"PredictedRank\", inplace=True)\n77: \n78:     # Prepare data for grouped barplot\n79:     plot_df = year_df[[\"Name\", \"PredictedRank\", \"Rank\"]].melt(\n80:         id_vars=\"Name\", value_vars=[\"PredictedRank\", \"Rank\"], \n81:         var_name=\"RankType\", value_name=\"RankValue\"\n82:     )\n83: \n84:     plt.figure(figsize=(12, 6))\n85:     sns.barplot(\n86:         x=\"Name\", y=\"RankValue\", hue=\"RankType\", data=plot_df, \n87:         palette=\"coolwarm\", dodge=True\n88:     )\n89:     plt.axhline(0, color=\"black\", linestyle=\"--\")\n90:     plt.xticks(rotation=45, ha=\"right\")\n91:     plt.ylabel(\"Rank\")\n92:     plt.title(f\"MVP Predicted vs True Rankings ({year})\")\n93:     plt.tight_layout()\n94:     plt.legend(loc=\"center\")\n95:     plt.savefig(f\"data/ranking_predictions_{year}.png\")"
        },
        "timestamp": "2025-08-16 23:13:19.000",
        "id": "6yRE9ULaa9AYEStNlEyA"
    },
    {
        "source": "backend",
        "event": "map_summary_code",
        "data": {
            "summary": "• Filters data for the specified year and sorts by predicted rank\n• Creates a grouped bar plot of both predicted and true ranks for each player\n  ◦ Uses player names as labels and includes both predicted and actual ranks as hue\n• Adds a horizontal reference line and saves the plot as a PNG file\n• The function plots both predicted and actual ranks, rather than only predicted ranks; there are no changes from the previous version.",
            "mapping": [
                {
                    "summaryComponent": "Filters data for the specified year and sorts by predicted rank",
                    "codeSegments": [
                        {
                            "line": 75,
                            "code": "year_df = df[df[\"Year\"] == year].copy()"
                        },
                        {
                            "line": 76,
                            "code": "year_df.sort_values(\"PredictedRank\", inplace=True)"
                        }
                    ]
                },
                {
                    "summaryComponent": "Creates a grouped bar plot of both predicted and true ranks for each player",
                    "codeSegments": [
                        {
                            "line": 79,
                            "code": "plot_df = year_df[[\"Name\", \"PredictedRank\", \"Rank\"]].melt("
                        },
                        {
                            "line": 85,
                            "code": "sns.barplot("
                        }
                    ]
                },
                {
                    "summaryComponent": "Uses player names as labels and includes both predicted and actual ranks as hue",
                    "codeSegments": [
                        {
                            "line": 86,
                            "code": "x=\"Name\", y=\"RankValue\", hue=\"RankType\", data=plot_df,"
                        }
                    ]
                },
                {
                    "summaryComponent": "Adds a horizontal reference line and saves the plot as a PNG file",
                    "codeSegments": [
                        {
                            "line": 89,
                            "code": "plt.axhline(0, color=\"black\", linestyle=\"--\")"
                        },
                        {
                            "line": 95,
                            "code": "plt.savefig(f\"data/ranking_predictions_{year}.png\")"
                        }
                    ]
                },
                {
                    "summaryComponent": "The function plots both predicted and actual ranks, rather than only predicted ranks; there are no changes from the previous version.",
                    "codeSegments": [
                        {
                            "line": 79,
                            "code": "plot_df = year_df[[\"Name\", \"PredictedRank\", \"Rank\"]].melt("
                        },
                        {
                            "line": 85,
                            "code": "sns.barplot("
                        }
                    ]
                }
            ],
            "code": "67: def plot_ranking_predictions(df, year):\n68:     \"\"\"\n69:     Plot predicted and true ranks for a specific year.\n70: \n71:     Args:\n72:         df: DataFrame containing prediction results\n73:         year: Year to plot predicted and true ranks for\n74:     \"\"\"\n75:     year_df = df[df[\"Year\"] == year].copy()\n76:     year_df.sort_values(\"PredictedRank\", inplace=True)\n77: \n78:     # Prepare data for grouped barplot\n79:     plot_df = year_df[[\"Name\", \"PredictedRank\", \"Rank\"]].melt(\n80:         id_vars=\"Name\", value_vars=[\"PredictedRank\", \"Rank\"], \n81:         var_name=\"RankType\", value_name=\"RankValue\"\n82:     )\n83: \n84:     plt.figure(figsize=(12, 6))\n85:     sns.barplot(\n86:         x=\"Name\", y=\"RankValue\", hue=\"RankType\", data=plot_df, \n87:         palette=\"coolwarm\", dodge=True\n88:     )\n89:     plt.axhline(0, color=\"black\", linestyle=\"--\")\n90:     plt.xticks(rotation=45, ha=\"right\")\n91:     plt.ylabel(\"Rank\")\n92:     plt.title(f\"MVP Predicted vs True Rankings ({year})\")\n93:     plt.tight_layout()\n94:     plt.legend(loc=\"center\")\n95:     plt.savefig(f\"data/ranking_predictions_{year}.png\")"
        },
        "timestamp": "2025-08-16 23:13:19.000",
        "id": "HyswKQbraAs7cdMgiIBD"
    },
    {
        "source": "backend",
        "event": "map_summary_code",
        "data": {
            "summary": "The plot_ranking_predictions function generates a grouped bar plot to visualize both the predicted and true rank for each player in a specified year. It filters the DataFrame for the given year, sorts the data by predicted rank, and prepares the data so that both predicted and actual ranks are shown as separate bars for each player using Seaborn. The plot uses player names on the x-axis, rank values on the y-axis, and a hue to distinguish between predicted and true ranks, with a horizontal line at zero for reference. The plot is formatted for readability and saved as a PNG file named according to the year. (The function continues to plot both predicted and actual ranks, instead of only predicted ranks; there are no changes from the previous version.)",
            "mapping": [
                {
                    "summaryComponent": "The plot_ranking_predictions function generates a grouped bar plot",
                    "codeSegments": [
                        {
                            "line": 67,
                            "code": "def plot_ranking_predictions(df, year):"
                        },
                        {
                            "line": 85,
                            "code": "sns.barplot("
                        }
                    ]
                },
                {
                    "summaryComponent": "to visualize both the predicted and true rank for each player in a specified year.",
                    "codeSegments": [
                        {
                            "line": 75,
                            "code": "year_df = df[df[\"Year\"] == year].copy()"
                        },
                        {
                            "line": 79,
                            "code": "plot_df = year_df[[\"Name\", \"PredictedRank\", \"Rank\"]].melt("
                        }
                    ]
                },
                {
                    "summaryComponent": "It filters the DataFrame for the given year",
                    "codeSegments": [
                        {
                            "line": 75,
                            "code": "year_df = df[df[\"Year\"] == year].copy()"
                        }
                    ]
                },
                {
                    "summaryComponent": "sorts the data by predicted rank",
                    "codeSegments": [
                        {
                            "line": 76,
                            "code": "year_df.sort_values(\"PredictedRank\", inplace=True)"
                        }
                    ]
                },
                {
                    "summaryComponent": "and prepares the data so that both predicted and actual ranks are shown as separate bars for each player using Seaborn.",
                    "codeSegments": [
                        {
                            "line": 79,
                            "code": "plot_df = year_df[[\"Name\", \"PredictedRank\", \"Rank\"]].melt("
                        },
                        {
                            "line": 85,
                            "code": "sns.barplot("
                        }
                    ]
                },
                {
                    "summaryComponent": "The plot uses player names on the x-axis",
                    "codeSegments": [
                        {
                            "line": 86,
                            "code": "x=\"Name\""
                        }
                    ]
                },
                {
                    "summaryComponent": "rank values on the y-axis",
                    "codeSegments": [
                        {
                            "line": 86,
                            "code": "y=\"RankValue\""
                        }
                    ]
                },
                {
                    "summaryComponent": "and a hue to distinguish between predicted and true ranks",
                    "codeSegments": [
                        {
                            "line": 86,
                            "code": "hue=\"RankType\""
                        }
                    ]
                },
                {
                    "summaryComponent": "with a horizontal line at zero for reference.",
                    "codeSegments": [
                        {
                            "line": 89,
                            "code": "plt.axhline(0, color=\"black\", linestyle=\"--\")"
                        }
                    ]
                },
                {
                    "summaryComponent": "The plot is formatted for readability and saved as a PNG file named according to the year.",
                    "codeSegments": [
                        {
                            "line": 93,
                            "code": "plt.tight_layout()"
                        },
                        {
                            "line": 95,
                            "code": "plt.savefig(f\"data/ranking_predictions_{year}.png\")"
                        }
                    ]
                }
            ],
            "code": "67: def plot_ranking_predictions(df, year):\n68:     \"\"\"\n69:     Plot predicted and true ranks for a specific year.\n70: \n71:     Args:\n72:         df: DataFrame containing prediction results\n73:         year: Year to plot predicted and true ranks for\n74:     \"\"\"\n75:     year_df = df[df[\"Year\"] == year].copy()\n76:     year_df.sort_values(\"PredictedRank\", inplace=True)\n77: \n78:     # Prepare data for grouped barplot\n79:     plot_df = year_df[[\"Name\", \"PredictedRank\", \"Rank\"]].melt(\n80:         id_vars=\"Name\", value_vars=[\"PredictedRank\", \"Rank\"], \n81:         var_name=\"RankType\", value_name=\"RankValue\"\n82:     )\n83: \n84:     plt.figure(figsize=(12, 6))\n85:     sns.barplot(\n86:         x=\"Name\", y=\"RankValue\", hue=\"RankType\", data=plot_df, \n87:         palette=\"coolwarm\", dodge=True\n88:     )\n89:     plt.axhline(0, color=\"black\", linestyle=\"--\")\n90:     plt.xticks(rotation=45, ha=\"right\")\n91:     plt.ylabel(\"Rank\")\n92:     plt.title(f\"MVP Predicted vs True Rankings ({year})\")\n93:     plt.tight_layout()\n94:     plt.legend(loc=\"center\")\n95:     plt.savefig(f\"data/ranking_predictions_{year}.png\")"
        },
        "timestamp": "2025-08-16 23:13:20.000",
        "id": "YxSBalFRnhQVt2DrecCs"
    },
    {
        "source": "backend",
        "event": "map_summary_code",
        "data": {
            "summary": "• Filters the DataFrame to include only rows from the specified year and sorts them by predicted rank\n• Prepares a melted DataFrame to include both predicted and true ranks for grouped bar plotting\n• Sets up a matplotlib figure with a specific size\n• Creates a Seaborn grouped bar plot:\n  ◦ x-axis: Player names\n  ◦ y-axis: Rank values (both predicted and actual)\n  ◦ Hue: 'RankType' to distinguish between predicted and true ranks\n  ◦ Palette: 'coolwarm' for visual contrast\n• Adds a horizontal dashed line at y=0 to indicate a reference\n• Rotates x-axis labels for better readability\n• Sets axis labels and a descriptive plot title indicating the year, now reflecting both predicted and true rankings\n• Adjusts layout for clarity and saves the figure as 'data/ranking_predictions_{year}.png'\n• The function visualizes both predicted and actual ranks in a grouped bar plot, not just predicted ranks; there are no changes from the previous version.",
            "mapping": [
                {
                    "summaryComponent": "Filters the DataFrame to include only rows from the specified year and sorts them by predicted rank",
                    "codeSegments": [
                        {
                            "line": 75,
                            "code": "year_df = df[df[\"Year\"] == year].copy()"
                        },
                        {
                            "line": 76,
                            "code": "year_df.sort_values(\"PredictedRank\", inplace=True)"
                        }
                    ]
                },
                {
                    "summaryComponent": "Prepares a melted DataFrame to include both predicted and true ranks for grouped bar plotting",
                    "codeSegments": [
                        {
                            "line": 79,
                            "code": "plot_df = year_df[[\"Name\", \"PredictedRank\", \"Rank\"]].melt("
                        },
                        {
                            "line": 80,
                            "code": "    id_vars=\"Name\", value_vars=[\"PredictedRank\", \"Rank\"], "
                        },
                        {
                            "line": 81,
                            "code": "    var_name=\"RankType\", value_name=\"RankValue\""
                        }
                    ]
                },
                {
                    "summaryComponent": "Sets up a matplotlib figure with a specific size",
                    "codeSegments": [
                        {
                            "line": 84,
                            "code": "plt.figure(figsize=(12, 6))"
                        }
                    ]
                },
                {
                    "summaryComponent": "Creates a Seaborn grouped bar plot:",
                    "codeSegments": [
                        {
                            "line": 85,
                            "code": "sns.barplot("
                        },
                        {
                            "line": 86,
                            "code": "    x=\"Name\", y=\"RankValue\", hue=\"RankType\", data=plot_df, "
                        },
                        {
                            "line": 87,
                            "code": "    palette=\"coolwarm\", dodge=True"
                        }
                    ]
                },
                {
                    "summaryComponent": "x-axis: Player names",
                    "codeSegments": [
                        {
                            "line": 86,
                            "code": "x=\"Name\""
                        }
                    ]
                },
                {
                    "summaryComponent": "y-axis: Rank values (both predicted and actual)",
                    "codeSegments": [
                        {
                            "line": 86,
                            "code": "y=\"RankValue\""
                        }
                    ]
                },
                {
                    "summaryComponent": "Hue: 'RankType' to distinguish between predicted and true ranks",
                    "codeSegments": [
                        {
                            "line": 86,
                            "code": "hue=\"RankType\""
                        }
                    ]
                },
                {
                    "summaryComponent": "Palette: 'coolwarm' for visual contrast",
                    "codeSegments": [
                        {
                            "line": 87,
                            "code": "palette=\"coolwarm\""
                        }
                    ]
                },
                {
                    "summaryComponent": "Adds a horizontal dashed line at y=0 to indicate a reference",
                    "codeSegments": [
                        {
                            "line": 89,
                            "code": "plt.axhline(0, color=\"black\", linestyle=\"--\")"
                        }
                    ]
                },
                {
                    "summaryComponent": "Rotates x-axis labels for better readability",
                    "codeSegments": [
                        {
                            "line": 90,
                            "code": "plt.xticks(rotation=45, ha=\"right\")"
                        }
                    ]
                },
                {
                    "summaryComponent": "Sets axis labels and a descriptive plot title indicating the year, now reflecting both predicted and true rankings",
                    "codeSegments": [
                        {
                            "line": 91,
                            "code": "plt.ylabel(\"Rank\")"
                        },
                        {
                            "line": 92,
                            "code": "plt.title(f\"MVP Predicted vs True Rankings ({year})\")"
                        }
                    ]
                },
                {
                    "summaryComponent": "Adjusts layout for clarity and saves the figure as 'data/ranking_predictions_{year}.png'",
                    "codeSegments": [
                        {
                            "line": 93,
                            "code": "plt.tight_layout()"
                        },
                        {
                            "line": 94,
                            "code": "plt.legend(loc=\"center\")"
                        },
                        {
                            "line": 95,
                            "code": "plt.savefig(f\"data/ranking_predictions_{year}.png\")"
                        }
                    ]
                }
            ],
            "code": "67: def plot_ranking_predictions(df, year):\n68:     \"\"\"\n69:     Plot predicted and true ranks for a specific year.\n70: \n71:     Args:\n72:         df: DataFrame containing prediction results\n73:         year: Year to plot predicted and true ranks for\n74:     \"\"\"\n75:     year_df = df[df[\"Year\"] == year].copy()\n76:     year_df.sort_values(\"PredictedRank\", inplace=True)\n77: \n78:     # Prepare data for grouped barplot\n79:     plot_df = year_df[[\"Name\", \"PredictedRank\", \"Rank\"]].melt(\n80:         id_vars=\"Name\", value_vars=[\"PredictedRank\", \"Rank\"], \n81:         var_name=\"RankType\", value_name=\"RankValue\"\n82:     )\n83: \n84:     plt.figure(figsize=(12, 6))\n85:     sns.barplot(\n86:         x=\"Name\", y=\"RankValue\", hue=\"RankType\", data=plot_df, \n87:         palette=\"coolwarm\", dodge=True\n88:     )\n89:     plt.axhline(0, color=\"black\", linestyle=\"--\")\n90:     plt.xticks(rotation=45, ha=\"right\")\n91:     plt.ylabel(\"Rank\")\n92:     plt.title(f\"MVP Predicted vs True Rankings ({year})\")\n93:     plt.tight_layout()\n94:     plt.legend(loc=\"center\")\n95:     plt.savefig(f\"data/ranking_predictions_{year}.png\")"
        },
        "timestamp": "2025-08-16 23:13:20.000",
        "id": "l6BArn3mJM6xUtUQ51jF"
    },
    {
        "source": "frontend",
        "event": "autotransit_section",
        "data": {
            "before_section_id": "ca827391-4617-4bf8-aaa4-cb88aaecb479",
            "after_section_id": "8e22b665-a601-46c2-9ba5-ef874de1dde4"
        },
        "timestamp": "2025-08-16 23:13:21.000",
        "id": "9moKtTZR7KUqlVA0Tz3Y"
    },
    {
        "source": "frontend",
        "event": "create_new_section",
        "data": {
            "section_id": "8e22b665-a601-46c2-9ba5-ef874de1dde4",
            "section_data": {
                "editPromptDetailLevel": null,
                "selectedStructured": "unstructured",
                "createdAt": 1755371600000,
                "lines": [
                    67,
                    95
                ],
                "editPromptStructured": null,
                "summaryData": {
                    "low_structured": "• Plots both predicted and true ranks for a given year\n• Saves the plot as an image file\n• The function visualizes both predicted and actual ranks in a grouped bar plot, instead of only predicted ranks; there are no changes from the previous version.",
                    "high_unstructured": "The plot_ranking_predictions function generates a grouped bar plot to visualize both the predicted and true rank for each player in a specified year. It filters the DataFrame for the given year, sorts the data by predicted rank, and prepares the data so that both predicted and actual ranks are shown as separate bars for each player using Seaborn. The plot uses player names on the x-axis, rank values on the y-axis, and a hue to distinguish between predicted and true ranks, with a horizontal line at zero for reference. The plot is formatted for readability and saved as a PNG file named according to the year. (The function continues to plot both predicted and actual ranks, instead of only predicted ranks; there are no changes from the previous version.)",
                    "medium_unstructured": "The plot_ranking_predictions function visualizes both the predicted and true ranks for each player in a specified year. It creates a grouped bar plot showing both predicted and actual rank values for each player and saves the resulting image to a file. The plot includes player names, predicted and true rank values, and a reference line at zero. (The function continues to focus on plotting both predicted and actual ranks, not just predicted ranks; there are no changes from the previous version.)",
                    "high_structured": "• Filters the DataFrame to include only rows from the specified year and sorts them by predicted rank\n• Prepares a melted DataFrame to include both predicted and true ranks for grouped bar plotting\n• Sets up a matplotlib figure with a specific size\n• Creates a Seaborn grouped bar plot:\n  ◦ x-axis: Player names\n  ◦ y-axis: Rank values (both predicted and actual)\n  ◦ Hue: 'RankType' to distinguish between predicted and true ranks\n  ◦ Palette: 'coolwarm' for visual contrast\n• Adds a horizontal dashed line at y=0 to indicate a reference\n• Rotates x-axis labels for better readability\n• Sets axis labels and a descriptive plot title indicating the year, now reflecting both predicted and true rankings\n• Adjusts layout for clarity and saves the figure as 'data/ranking_predictions_{year}.png'\n• The function visualizes both predicted and actual ranks in a grouped bar plot, not just predicted ranks; there are no changes from the previous version.",
                    "title": "Function: plot_ranking_predictions",
                    "low_unstructured": "This function plots and saves both the predicted and true ranks for players in a specified year, displaying both predicted and actual rank values in a grouped bar plot; there are no changes from the previous version.",
                    "medium_structured": "• Filters data for the specified year and sorts by predicted rank\n• Creates a grouped bar plot of both predicted and true ranks for each player\n  ◦ Uses player names as labels and includes both predicted and actual ranks as hue\n• Adds a horizontal reference line and saves the plot as a PNG file\n• The function plots both predicted and actual ranks, rather than only predicted ranks; there are no changes from the previous version."
                },
                "selectedDetailLevel": "medium",
                "oldSummaryData": {
                    "low_structured": "• Plots both predicted and true ranks for a given year\n• Saves the plot as an image file\n• The function now visualizes both predicted and actual ranks in a grouped bar plot, instead of only predicted ranks.",
                    "high_unstructured": "The plot_ranking_predictions function generates a grouped bar plot to visualize both the predicted and true rank for each player in a specified year. It filters the DataFrame for the given year, sorts the data by predicted rank, and prepares the data so that both predicted and actual ranks are shown as separate bars for each player using Seaborn. The plot uses player names on the x-axis, rank values on the y-axis, and a hue to distinguish between predicted and true ranks, with a horizontal line at zero for reference. The plot is formatted for readability and saved as a PNG file named according to the year. (The function now plots both predicted and actual ranks, instead of only predicted ranks.)",
                    "medium_unstructured": "The plot_ranking_predictions function visualizes both the predicted and true ranks for each player in a specified year. It creates a grouped bar plot showing both predicted and actual rank values for each player and saves the resulting image to a file. The plot includes player names, predicted and true rank values, and a reference line at zero. (The function now focuses on plotting both predicted and actual ranks, not just predicted ranks.)",
                    "high_structured": "• Filters the DataFrame to include only rows from the specified year and sorts them by predicted rank\n• Prepares a melted DataFrame to include both predicted and true ranks for grouped bar plotting\n• Sets up a matplotlib figure with a specific size\n• Creates a Seaborn grouped bar plot:\n  ◦ x-axis: Player names\n  ◦ y-axis: Rank values (both predicted and actual)\n  ◦ Hue: 'RankType' to distinguish between predicted and true ranks\n  ◦ Palette: 'coolwarm' for visual contrast\n• Adds a horizontal dashed line at y=0 to indicate a reference\n• Rotates x-axis labels for better readability\n• Sets axis labels and a descriptive plot title indicating the year, now reflecting both predicted and true rankings\n• Adjusts layout for clarity and saves the figure as 'data/ranking_predictions_{year}.png'\n• The function now visualizes both predicted and actual ranks in a grouped bar plot, not just predicted ranks.",
                    "title": "Function: plot_ranking_predictions",
                    "low_unstructured": "This function now plots and saves both the predicted and true ranks for players in a specified year, displaying both predicted and actual rank values in a grouped bar plot rather than only predicted ranks.",
                    "medium_structured": "• Filters data for the specified year and sorts by predicted rank\n• Creates a grouped bar plot of both predicted and true ranks for each player\n  ◦ Uses player names as labels and includes both predicted and actual ranks as hue\n• Adds a horizontal reference line and saves the plot as a PNG file\n• The function now plots both predicted and actual ranks, rather than only predicted ranks."
                },
                "metadata": {
                    "originalCode": "def plot_ranking_predictions(df, year):\n    \"\"\"\n    Plot predicted and true ranks for a specific year.\n\n    Args:\n        df: DataFrame containing prediction results\n        year: Year to plot predicted and true ranks for\n    \"\"\"\n    year_df = df[df[\"Year\"] == year].copy()\n    year_df.sort_values(\"PredictedRank\", inplace=True)\n\n    # Prepare data for grouped barplot\n    plot_df = year_df[[\"Name\", \"PredictedRank\", \"Rank\"]].melt(\n        id_vars=\"Name\", value_vars=[\"PredictedRank\", \"Rank\"], \n        var_name=\"RankType\", value_name=\"RankValue\"\n    )\n\n    plt.figure(figsize=(12, 6))\n    sns.barplot(\n        x=\"Name\", y=\"RankValue\", hue=\"RankType\", data=plot_df, \n        palette=\"coolwarm\", dodge=True\n    )\n    plt.axhline(0, color=\"black\", linestyle=\"--\")\n    plt.xticks(rotation=45, ha=\"right\")\n    plt.ylabel(\"Rank\")\n    plt.title(f\"MVP Predicted vs True Rankings ({year})\")\n    plt.tight_layout()\n    plt.legend(loc=\"center\")\n    plt.savefig(f\"data/ranking_predictions_{year}.png\")",
                    "fullPath": "/project/workspace/rank_model.py",
                    "id": "8e22b665-a601-46c2-9ba5-ef874de1dde4",
                    "offset": 1496,
                    "filename": "rank_model.py"
                },
                "editPromptValue": "",
                "title": "Function: plot_ranking_predictions",
                "summaryMappings": {
                    "high_unstructured": [
                        {
                            "summaryComponent": "The plot_ranking_predictions function generates a grouped bar plot",
                            "codeSegments": [
                                {
                                    "line": 67,
                                    "code": "def plot_ranking_predictions(df, year):"
                                },
                                {
                                    "line": 85,
                                    "code": "sns.barplot("
                                }
                            ]
                        },
                        {
                            "summaryComponent": "to visualize both the predicted and true rank for each player in a specified year.",
                            "codeSegments": [
                                {
                                    "line": 75,
                                    "code": "year_df = df[df[\"Year\"] == year].copy()"
                                },
                                {
                                    "line": 79,
                                    "code": "plot_df = year_df[[\"Name\", \"PredictedRank\", \"Rank\"]].melt("
                                }
                            ]
                        },
                        {
                            "summaryComponent": "It filters the DataFrame for the given year",
                            "codeSegments": [
                                {
                                    "line": 75,
                                    "code": "year_df = df[df[\"Year\"] == year].copy()"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "sorts the data by predicted rank",
                            "codeSegments": [
                                {
                                    "line": 76,
                                    "code": "year_df.sort_values(\"PredictedRank\", inplace=True)"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "and prepares the data so that both predicted and actual ranks are shown as separate bars for each player using Seaborn.",
                            "codeSegments": [
                                {
                                    "line": 79,
                                    "code": "plot_df = year_df[[\"Name\", \"PredictedRank\", \"Rank\"]].melt("
                                },
                                {
                                    "line": 85,
                                    "code": "sns.barplot("
                                }
                            ]
                        },
                        {
                            "summaryComponent": "The plot uses player names on the x-axis",
                            "codeSegments": [
                                {
                                    "line": 86,
                                    "code": "x=\"Name\""
                                }
                            ]
                        },
                        {
                            "summaryComponent": "rank values on the y-axis",
                            "codeSegments": [
                                {
                                    "line": 86,
                                    "code": "y=\"RankValue\""
                                }
                            ]
                        },
                        {
                            "summaryComponent": "and a hue to distinguish between predicted and true ranks",
                            "codeSegments": [
                                {
                                    "line": 86,
                                    "code": "hue=\"RankType\""
                                }
                            ]
                        },
                        {
                            "summaryComponent": "with a horizontal line at zero for reference.",
                            "codeSegments": [
                                {
                                    "line": 89,
                                    "code": "plt.axhline(0, color=\"black\", linestyle=\"--\")"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "The plot is formatted for readability and saved as a PNG file named according to the year.",
                            "codeSegments": [
                                {
                                    "line": 93,
                                    "code": "plt.tight_layout()"
                                },
                                {
                                    "line": 95,
                                    "code": "plt.savefig(f\"data/ranking_predictions_{year}.png\")"
                                }
                            ]
                        }
                    ],
                    "medium_unstructured": [
                        {
                            "summaryComponent": "The plot_ranking_predictions function",
                            "codeSegments": [
                                {
                                    "line": 67,
                                    "code": "def plot_ranking_predictions(df, year):"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "visualizes both the predicted and true ranks for each player in a specified year",
                            "codeSegments": [
                                {
                                    "line": 75,
                                    "code": "year_df = df[df[\"Year\"] == year].copy()"
                                },
                                {
                                    "line": 76,
                                    "code": "year_df.sort_values(\"PredictedRank\", inplace=True)"
                                },
                                {
                                    "line": 79,
                                    "code": "plot_df = year_df[[\"Name\", \"PredictedRank\", \"Rank\"]].melt("
                                },
                                {
                                    "line": 80,
                                    "code": "id_vars=\"Name\", value_vars=[\"PredictedRank\", \"Rank\"], "
                                }
                            ]
                        },
                        {
                            "summaryComponent": "It creates a grouped bar plot showing both predicted and actual rank values for each player",
                            "codeSegments": [
                                {
                                    "line": 85,
                                    "code": "sns.barplot("
                                },
                                {
                                    "line": 86,
                                    "code": "x=\"Name\", y=\"RankValue\", hue=\"RankType\", data=plot_df, "
                                }
                            ]
                        },
                        {
                            "summaryComponent": "and saves the resulting image to a file",
                            "codeSegments": [
                                {
                                    "line": 95,
                                    "code": "plt.savefig(f\"data/ranking_predictions_{year}.png\")"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "The plot includes player names",
                            "codeSegments": [
                                {
                                    "line": 86,
                                    "code": "x=\"Name\""
                                }
                            ]
                        },
                        {
                            "summaryComponent": "predicted and true rank values",
                            "codeSegments": [
                                {
                                    "line": 80,
                                    "code": "value_vars=[\"PredictedRank\", \"Rank\"]"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "and a reference line at zero",
                            "codeSegments": [
                                {
                                    "line": 89,
                                    "code": "plt.axhline(0, color=\"black\", linestyle=\"--\")"
                                }
                            ]
                        }
                    ],
                    "high_structured": [
                        {
                            "summaryComponent": "Filters the DataFrame to include only rows from the specified year and sorts them by predicted rank",
                            "codeSegments": [
                                {
                                    "line": 75,
                                    "code": "year_df = df[df[\"Year\"] == year].copy()"
                                },
                                {
                                    "line": 76,
                                    "code": "year_df.sort_values(\"PredictedRank\", inplace=True)"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "Prepares a melted DataFrame to include both predicted and true ranks for grouped bar plotting",
                            "codeSegments": [
                                {
                                    "line": 79,
                                    "code": "plot_df = year_df[[\"Name\", \"PredictedRank\", \"Rank\"]].melt("
                                },
                                {
                                    "line": 80,
                                    "code": "    id_vars=\"Name\", value_vars=[\"PredictedRank\", \"Rank\"], "
                                },
                                {
                                    "line": 81,
                                    "code": "    var_name=\"RankType\", value_name=\"RankValue\""
                                }
                            ]
                        },
                        {
                            "summaryComponent": "Sets up a matplotlib figure with a specific size",
                            "codeSegments": [
                                {
                                    "line": 84,
                                    "code": "plt.figure(figsize=(12, 6))"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "Creates a Seaborn grouped bar plot:",
                            "codeSegments": [
                                {
                                    "line": 85,
                                    "code": "sns.barplot("
                                },
                                {
                                    "line": 86,
                                    "code": "    x=\"Name\", y=\"RankValue\", hue=\"RankType\", data=plot_df, "
                                },
                                {
                                    "line": 87,
                                    "code": "    palette=\"coolwarm\", dodge=True"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "x-axis: Player names",
                            "codeSegments": [
                                {
                                    "line": 86,
                                    "code": "x=\"Name\""
                                }
                            ]
                        },
                        {
                            "summaryComponent": "y-axis: Rank values (both predicted and actual)",
                            "codeSegments": [
                                {
                                    "line": 86,
                                    "code": "y=\"RankValue\""
                                }
                            ]
                        },
                        {
                            "summaryComponent": "Hue: 'RankType' to distinguish between predicted and true ranks",
                            "codeSegments": [
                                {
                                    "line": 86,
                                    "code": "hue=\"RankType\""
                                }
                            ]
                        },
                        {
                            "summaryComponent": "Palette: 'coolwarm' for visual contrast",
                            "codeSegments": [
                                {
                                    "line": 87,
                                    "code": "palette=\"coolwarm\""
                                }
                            ]
                        },
                        {
                            "summaryComponent": "Adds a horizontal dashed line at y=0 to indicate a reference",
                            "codeSegments": [
                                {
                                    "line": 89,
                                    "code": "plt.axhline(0, color=\"black\", linestyle=\"--\")"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "Rotates x-axis labels for better readability",
                            "codeSegments": [
                                {
                                    "line": 90,
                                    "code": "plt.xticks(rotation=45, ha=\"right\")"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "Sets axis labels and a descriptive plot title indicating the year, now reflecting both predicted and true rankings",
                            "codeSegments": [
                                {
                                    "line": 91,
                                    "code": "plt.ylabel(\"Rank\")"
                                },
                                {
                                    "line": 92,
                                    "code": "plt.title(f\"MVP Predicted vs True Rankings ({year})\")"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "Adjusts layout for clarity and saves the figure as 'data/ranking_predictions_{year}.png'",
                            "codeSegments": [
                                {
                                    "line": 93,
                                    "code": "plt.tight_layout()"
                                },
                                {
                                    "line": 94,
                                    "code": "plt.legend(loc=\"center\")"
                                },
                                {
                                    "line": 95,
                                    "code": "plt.savefig(f\"data/ranking_predictions_{year}.png\")"
                                }
                            ]
                        }
                    ],
                    "low_unstructured": [
                        {
                            "summaryComponent": "plots and saves",
                            "codeSegments": [
                                {
                                    "line": 95,
                                    "code": "plt.savefig(f\"data/ranking_predictions_{year}.png\")"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "both the predicted and true ranks",
                            "codeSegments": [
                                {
                                    "line": 75,
                                    "code": "year_df = df[df[\"Year\"] == year].copy()"
                                },
                                {
                                    "line": 76,
                                    "code": "year_df.sort_values(\"PredictedRank\", inplace=True)"
                                },
                                {
                                    "line": 79,
                                    "code": "plot_df = year_df[[\"Name\", \"PredictedRank\", \"Rank\"]].melt("
                                }
                            ]
                        },
                        {
                            "summaryComponent": "for players in a specified year",
                            "codeSegments": [
                                {
                                    "line": 67,
                                    "code": "def plot_ranking_predictions(df, year):"
                                },
                                {
                                    "line": 75,
                                    "code": "year_df = df[df[\"Year\"] == year].copy()"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "displaying both predicted and actual rank values",
                            "codeSegments": [
                                {
                                    "line": 79,
                                    "code": "plot_df = year_df[[\"Name\", \"PredictedRank\", \"Rank\"]].melt("
                                },
                                {
                                    "line": 85,
                                    "code": "sns.barplot("
                                }
                            ]
                        },
                        {
                            "summaryComponent": "in a grouped bar plot",
                            "codeSegments": [
                                {
                                    "line": 85,
                                    "code": "sns.barplot("
                                }
                            ]
                        }
                    ],
                    "low_structured": [
                        {
                            "summaryComponent": "Plots both predicted and true ranks for a given year",
                            "codeSegments": [
                                {
                                    "line": 67,
                                    "code": "def plot_ranking_predictions(df, year):"
                                },
                                {
                                    "line": 75,
                                    "code": "year_df = df[df[\"Year\"] == year].copy()"
                                },
                                {
                                    "line": 79,
                                    "code": "plot_df = year_df[[\"Name\", \"PredictedRank\", \"Rank\"]].melt("
                                },
                                {
                                    "line": 85,
                                    "code": "sns.barplot("
                                }
                            ]
                        },
                        {
                            "summaryComponent": "Saves the plot as an image file",
                            "codeSegments": [
                                {
                                    "line": 95,
                                    "code": "plt.savefig(f\"data/ranking_predictions_{year}.png\")"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "visualizes both predicted and actual ranks in a grouped bar plot",
                            "codeSegments": [
                                {
                                    "line": 79,
                                    "code": "plot_df = year_df[[\"Name\", \"PredictedRank\", \"Rank\"]].melt("
                                },
                                {
                                    "line": 85,
                                    "code": "sns.barplot("
                                }
                            ]
                        },
                        {
                            "summaryComponent": "instead of only predicted ranks",
                            "codeSegments": [
                                {
                                    "line": 79,
                                    "code": "plot_df = year_df[[\"Name\", \"PredictedRank\", \"Rank\"]].melt("
                                }
                            ]
                        },
                        {
                            "summaryComponent": "there are no changes from the previous version",
                            "codeSegments": [
                                {
                                    "line": 67,
                                    "code": "def plot_ranking_predictions(df, year):"
                                }
                            ]
                        }
                    ],
                    "medium_structured": [
                        {
                            "summaryComponent": "Filters data for the specified year and sorts by predicted rank",
                            "codeSegments": [
                                {
                                    "line": 75,
                                    "code": "year_df = df[df[\"Year\"] == year].copy()"
                                },
                                {
                                    "line": 76,
                                    "code": "year_df.sort_values(\"PredictedRank\", inplace=True)"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "Creates a grouped bar plot of both predicted and true ranks for each player",
                            "codeSegments": [
                                {
                                    "line": 79,
                                    "code": "plot_df = year_df[[\"Name\", \"PredictedRank\", \"Rank\"]].melt("
                                },
                                {
                                    "line": 85,
                                    "code": "sns.barplot("
                                }
                            ]
                        },
                        {
                            "summaryComponent": "Uses player names as labels and includes both predicted and actual ranks as hue",
                            "codeSegments": [
                                {
                                    "line": 86,
                                    "code": "x=\"Name\", y=\"RankValue\", hue=\"RankType\", data=plot_df,"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "Adds a horizontal reference line and saves the plot as a PNG file",
                            "codeSegments": [
                                {
                                    "line": 89,
                                    "code": "plt.axhline(0, color=\"black\", linestyle=\"--\")"
                                },
                                {
                                    "line": 95,
                                    "code": "plt.savefig(f\"data/ranking_predictions_{year}.png\")"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "The function plots both predicted and actual ranks, rather than only predicted ranks; there are no changes from the previous version.",
                            "codeSegments": [
                                {
                                    "line": 79,
                                    "code": "plot_df = year_df[[\"Name\", \"PredictedRank\", \"Rank\"]].melt("
                                },
                                {
                                    "line": 85,
                                    "code": "sns.barplot("
                                }
                            ]
                        }
                    ]
                }
            }
        },
        "timestamp": "2025-08-16 23:13:21.000",
        "id": "PjprWVQGs0ZFbt3YZFNv"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "8e22b665-a601-46c2-9ba5-ef874de1dde4",
            "detail_level": "medium",
            "structured_type": "unstructured"
        },
        "timestamp": "2025-08-16 23:13:22.000",
        "id": "Asd3wpqZf2y6jl0NtJsr"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "8e22b665-a601-46c2-9ba5-ef874de1dde4",
            "mapping_index": 2,
            "structured_type": "unstructured",
            "detail_level": "medium"
        },
        "timestamp": "2025-08-16 23:13:22.000",
        "id": "BI8IPSPu3840uHPRbxce"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "8e22b665-a601-46c2-9ba5-ef874de1dde4",
            "detail_level": "medium",
            "structured_type": "unstructured"
        },
        "timestamp": "2025-08-16 23:13:22.000",
        "id": "DlTMUTpfCqJfZWY36lOO"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "8e22b665-a601-46c2-9ba5-ef874de1dde4",
            "mapping_index": 5,
            "structured_type": "unstructured",
            "detail_level": "medium"
        },
        "timestamp": "2025-08-16 23:13:22.000",
        "id": "MvPhS15HebOtZo0Y3cJE"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "8e22b665-a601-46c2-9ba5-ef874de1dde4",
            "detail_level": "medium",
            "structured_type": "unstructured"
        },
        "timestamp": "2025-08-16 23:13:22.000",
        "id": "dbgwi3AleWvgVsG57WuT"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "8e22b665-a601-46c2-9ba5-ef874de1dde4",
            "mapping_index": 5,
            "structured_type": "unstructured",
            "detail_level": "medium"
        },
        "timestamp": "2025-08-16 23:13:22.000",
        "id": "owXVs6tr4Aw83AIl5lah"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "8e22b665-a601-46c2-9ba5-ef874de1dde4",
            "mapping_index": 4,
            "structured_type": "unstructured",
            "detail_level": "medium"
        },
        "timestamp": "2025-08-16 23:13:22.000",
        "id": "riHGEnMk6CULFtPa9yWe"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "8e22b665-a601-46c2-9ba5-ef874de1dde4",
            "detail_level": "medium",
            "structured_type": "unstructured"
        },
        "timestamp": "2025-08-16 23:13:22.000",
        "id": "uplYQmBZGPNH79N1eBad"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "8e22b665-a601-46c2-9ba5-ef874de1dde4",
            "detail_level": "medium",
            "structured_type": "unstructured"
        },
        "timestamp": "2025-08-16 23:13:30.000",
        "id": "ALSeMzxvWiX7ucGjCUCl"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "8e22b665-a601-46c2-9ba5-ef874de1dde4",
            "detail_level": "medium",
            "structured_type": "unstructured"
        },
        "timestamp": "2025-08-16 23:13:30.000",
        "id": "ON7SCgDQTDmbVsejrbN2"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "8e22b665-a601-46c2-9ba5-ef874de1dde4",
            "mapping_index": 2,
            "structured_type": "unstructured",
            "detail_level": "medium"
        },
        "timestamp": "2025-08-16 23:13:30.000",
        "id": "Sr6okB5ZHZGBTUSGQtW6"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "8e22b665-a601-46c2-9ba5-ef874de1dde4",
            "detail_level": "medium",
            "structured_type": "unstructured"
        },
        "timestamp": "2025-08-16 23:13:30.000",
        "id": "l5374WE47Ftzi28XZvYK"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "8e22b665-a601-46c2-9ba5-ef874de1dde4",
            "mapping_index": 5,
            "structured_type": "unstructured",
            "detail_level": "medium"
        },
        "timestamp": "2025-08-16 23:13:30.000",
        "id": "rPMLpF8A4eLX54znKsTA"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "8e22b665-a601-46c2-9ba5-ef874de1dde4",
            "mapping_index": 5,
            "structured_type": "unstructured",
            "detail_level": "medium"
        },
        "timestamp": "2025-08-16 23:13:30.000",
        "id": "ynyij754s5yCoM3SCx2Y"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "8e22b665-a601-46c2-9ba5-ef874de1dde4",
            "mapping_index": 5,
            "structured_type": "unstructured",
            "detail_level": "medium"
        },
        "timestamp": "2025-08-16 23:13:32.000",
        "id": "50eZNfDrfEikIOTYqLVH"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "8e22b665-a601-46c2-9ba5-ef874de1dde4",
            "mapping_index": 2,
            "structured_type": "unstructured",
            "detail_level": "medium"
        },
        "timestamp": "2025-08-16 23:13:32.000",
        "id": "9LgFF0fOolD5cBsRdaZL"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "8e22b665-a601-46c2-9ba5-ef874de1dde4",
            "detail_level": "medium",
            "structured_type": "unstructured"
        },
        "timestamp": "2025-08-16 23:13:32.000",
        "id": "NB0HymGhnOuQnefZ6XRx"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "8e22b665-a601-46c2-9ba5-ef874de1dde4",
            "mapping_index": 1,
            "structured_type": "unstructured",
            "detail_level": "medium"
        },
        "timestamp": "2025-08-16 23:13:32.000",
        "id": "O6IrPwsPvAurBX4mf2ZJ"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "8e22b665-a601-46c2-9ba5-ef874de1dde4",
            "detail_level": "medium",
            "structured_type": "unstructured"
        },
        "timestamp": "2025-08-16 23:13:32.000",
        "id": "mJSzSbDyRg9PvlRV7kqi"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "8e22b665-a601-46c2-9ba5-ef874de1dde4",
            "detail_level": "medium",
            "structured_type": "unstructured"
        },
        "timestamp": "2025-08-16 23:13:32.000",
        "id": "ou1Yuf2G1BJ9Y6dzT5BA"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "8e22b665-a601-46c2-9ba5-ef874de1dde4",
            "mapping_index": 2,
            "structured_type": "unstructured",
            "detail_level": "high"
        },
        "timestamp": "2025-08-16 23:13:37.000",
        "id": "B55vAKQeqFqKhKgkRTdE"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "8e22b665-a601-46c2-9ba5-ef874de1dde4",
            "mapping_index": 0,
            "structured_type": "unstructured",
            "detail_level": "high"
        },
        "timestamp": "2025-08-16 23:13:37.000",
        "id": "GfGYZy4zwGuj2QtBztV1"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "8e22b665-a601-46c2-9ba5-ef874de1dde4",
            "mapping_index": 4,
            "structured_type": "unstructured",
            "detail_level": "high"
        },
        "timestamp": "2025-08-16 23:13:37.000",
        "id": "Q6XmeVa0R7H52AM7myRG"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "8e22b665-a601-46c2-9ba5-ef874de1dde4",
            "detail_level": "high",
            "structured_type": "unstructured"
        },
        "timestamp": "2025-08-16 23:13:37.000",
        "id": "QY1z0v7rMtJUeTLo0MWd"
    },
    {
        "source": "frontend",
        "event": "change_summary_level",
        "data": {
            "before_detail_level": "medium",
            "section_id": "8e22b665-a601-46c2-9ba5-ef874de1dde4",
            "before_structured": "unstructured",
            "after_structured": "unstructured",
            "after_detail_level": "high"
        },
        "timestamp": "2025-08-16 23:13:37.000",
        "id": "f3IzMcwbR4wHZ8Cm2yxL"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "8e22b665-a601-46c2-9ba5-ef874de1dde4",
            "detail_level": "high",
            "structured_type": "unstructured"
        },
        "timestamp": "2025-08-16 23:13:37.000",
        "id": "fLxx3YbHwGziBquJGS55"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "8e22b665-a601-46c2-9ba5-ef874de1dde4",
            "mapping_index": 9,
            "structured_type": "unstructured",
            "detail_level": "high"
        },
        "timestamp": "2025-08-16 23:13:37.000",
        "id": "k361Pe7JLregqmM2Uq0w"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "8e22b665-a601-46c2-9ba5-ef874de1dde4",
            "mapping_index": 7,
            "structured_type": "unstructured",
            "detail_level": "high"
        },
        "timestamp": "2025-08-16 23:13:37.000",
        "id": "khCb7Ynrmmg98m6zFkmI"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "8e22b665-a601-46c2-9ba5-ef874de1dde4",
            "detail_level": "high",
            "structured_type": "unstructured"
        },
        "timestamp": "2025-08-16 23:13:37.000",
        "id": "xEmkjJGF7tQdbnG4bx8s"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "8e22b665-a601-46c2-9ba5-ef874de1dde4",
            "detail_level": "high",
            "structured_type": "unstructured"
        },
        "timestamp": "2025-08-16 23:13:37.000",
        "id": "yVY6x6a7rBQVDAfdy38x"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "8e22b665-a601-46c2-9ba5-ef874de1dde4",
            "mapping_index": 9,
            "structured_type": "unstructured",
            "detail_level": "high"
        },
        "timestamp": "2025-08-16 23:13:38.000",
        "id": "2u6aMwP7PdSS2tQuMfSF"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "8e22b665-a601-46c2-9ba5-ef874de1dde4",
            "detail_level": "high",
            "structured_type": "unstructured"
        },
        "timestamp": "2025-08-16 23:13:38.000",
        "id": "WQFwS0Iwg863zWLR47Gg"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "8e22b665-a601-46c2-9ba5-ef874de1dde4",
            "detail_level": "high",
            "structured_type": "unstructured"
        },
        "timestamp": "2025-08-16 23:13:39.000",
        "id": "VFM8EBdRci0VjXbR5YUy"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "8e22b665-a601-46c2-9ba5-ef874de1dde4",
            "detail_level": "high",
            "structured_type": "unstructured"
        },
        "timestamp": "2025-08-16 23:13:42.000",
        "id": "m5c9oQPKbv5RJf9mBl8z"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "8e22b665-a601-46c2-9ba5-ef874de1dde4",
            "mapping_index": 8,
            "structured_type": "unstructured",
            "detail_level": "high"
        },
        "timestamp": "2025-08-16 23:13:42.000",
        "id": "yYkUl7IFYi6R8OeylaIc"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "8e22b665-a601-46c2-9ba5-ef874de1dde4",
            "mapping_index": 0,
            "structured_type": "unstructured",
            "detail_level": "high"
        },
        "timestamp": "2025-08-16 23:13:45.000",
        "id": "8q0aM4n5k01yMk03rYwU"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "8e22b665-a601-46c2-9ba5-ef874de1dde4",
            "detail_level": "high",
            "structured_type": "unstructured"
        },
        "timestamp": "2025-08-16 23:13:45.000",
        "id": "s4AsIQaE9mxLcYCz3ohs"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "8e22b665-a601-46c2-9ba5-ef874de1dde4",
            "mapping_index": 3,
            "structured_type": "unstructured",
            "detail_level": "high"
        },
        "timestamp": "2025-08-16 23:13:45.000",
        "id": "xldBDFQlnvDkYOVQEErr"
    },
    {
        "source": "frontend",
        "event": "change_summary_level",
        "data": {
            "before_detail_level": "high",
            "section_id": "8e22b665-a601-46c2-9ba5-ef874de1dde4",
            "before_structured": "unstructured",
            "after_structured": "structured",
            "after_detail_level": "high"
        },
        "timestamp": "2025-08-16 23:13:46.000",
        "id": "FQ6rtNPOkIB2ELpZBalC"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "8e22b665-a601-46c2-9ba5-ef874de1dde4",
            "detail_level": "high",
            "structured_type": "unstructured"
        },
        "timestamp": "2025-08-16 23:13:46.000",
        "id": "I8CTcTuBD8Oq48qvA4jI"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "8e22b665-a601-46c2-9ba5-ef874de1dde4",
            "mapping_index": 2,
            "structured_type": "unstructured",
            "detail_level": "high"
        },
        "timestamp": "2025-08-16 23:13:46.000",
        "id": "R73sCWgq7mj3RA8EYJ8v"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "8e22b665-a601-46c2-9ba5-ef874de1dde4",
            "detail_level": "high",
            "structured_type": "unstructured"
        },
        "timestamp": "2025-08-16 23:13:46.000",
        "id": "UcKQeKfhtQkzCOdjfNlL"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "8e22b665-a601-46c2-9ba5-ef874de1dde4",
            "mapping_index": 0,
            "structured_type": "unstructured",
            "detail_level": "high"
        },
        "timestamp": "2025-08-16 23:13:46.000",
        "id": "orCh3D57Sj4xIPJgCbOH"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "8e22b665-a601-46c2-9ba5-ef874de1dde4",
            "detail_level": "high",
            "structured_type": "unstructured"
        },
        "timestamp": "2025-08-16 23:13:46.000",
        "id": "wV3hjaLrDkh8UXRHgsee"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "8e22b665-a601-46c2-9ba5-ef874de1dde4",
            "mapping_index": 0,
            "structured_type": "structured",
            "detail_level": "high"
        },
        "timestamp": "2025-08-16 23:13:47.000",
        "id": "18GPO4yGPMOVHkmsSTap"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "8e22b665-a601-46c2-9ba5-ef874de1dde4",
            "detail_level": "high",
            "structured_type": "structured"
        },
        "timestamp": "2025-08-16 23:13:47.000",
        "id": "8p9KUhYpkPm3GM0ulEEl"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "8e22b665-a601-46c2-9ba5-ef874de1dde4",
            "detail_level": "high",
            "structured_type": "structured"
        },
        "timestamp": "2025-08-16 23:13:47.000",
        "id": "A5PDhCQIZpVwuaCDK9Gf"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "8e22b665-a601-46c2-9ba5-ef874de1dde4",
            "mapping_index": 10,
            "structured_type": "structured",
            "detail_level": "high"
        },
        "timestamp": "2025-08-16 23:13:47.000",
        "id": "EQBishcdmBwv60g0GAd4"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "8e22b665-a601-46c2-9ba5-ef874de1dde4",
            "detail_level": "high",
            "structured_type": "structured"
        },
        "timestamp": "2025-08-16 23:13:47.000",
        "id": "INtEdmBwmHLeIWj2BJWk"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "8e22b665-a601-46c2-9ba5-ef874de1dde4",
            "detail_level": "high",
            "structured_type": "structured"
        },
        "timestamp": "2025-08-16 23:13:47.000",
        "id": "KlKC50LKCFbRn6ELUYCf"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "8e22b665-a601-46c2-9ba5-ef874de1dde4",
            "mapping_index": 4,
            "structured_type": "structured",
            "detail_level": "high"
        },
        "timestamp": "2025-08-16 23:13:47.000",
        "id": "N2NUgONglzpqpAGqp3P2"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "8e22b665-a601-46c2-9ba5-ef874de1dde4",
            "mapping_index": 7,
            "structured_type": "structured",
            "detail_level": "high"
        },
        "timestamp": "2025-08-16 23:13:47.000",
        "id": "OEAhyE0HjmC4q96ooZMB"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "8e22b665-a601-46c2-9ba5-ef874de1dde4",
            "mapping_index": 9,
            "structured_type": "structured",
            "detail_level": "high"
        },
        "timestamp": "2025-08-16 23:13:47.000",
        "id": "Pb3nDyXs87FtlBOBqpgD"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "8e22b665-a601-46c2-9ba5-ef874de1dde4",
            "detail_level": "high",
            "structured_type": "structured"
        },
        "timestamp": "2025-08-16 23:13:47.000",
        "id": "TDIucPvrXEGWUoYxszud"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "8e22b665-a601-46c2-9ba5-ef874de1dde4",
            "detail_level": "high",
            "structured_type": "structured"
        },
        "timestamp": "2025-08-16 23:13:47.000",
        "id": "ULPeMo4DmvSPjBG5YXPV"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "8e22b665-a601-46c2-9ba5-ef874de1dde4",
            "detail_level": "high",
            "structured_type": "structured"
        },
        "timestamp": "2025-08-16 23:13:47.000",
        "id": "YWLXvH3DYnCFKQaVTX9c"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "8e22b665-a601-46c2-9ba5-ef874de1dde4",
            "detail_level": "high",
            "structured_type": "structured"
        },
        "timestamp": "2025-08-16 23:13:47.000",
        "id": "YjyVU7QvrIOAJLRfsFdT"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "8e22b665-a601-46c2-9ba5-ef874de1dde4",
            "mapping_index": 6,
            "structured_type": "structured",
            "detail_level": "high"
        },
        "timestamp": "2025-08-16 23:13:47.000",
        "id": "byGb375BTt49slV5pyAy"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "8e22b665-a601-46c2-9ba5-ef874de1dde4",
            "mapping_index": 5,
            "structured_type": "structured",
            "detail_level": "high"
        },
        "timestamp": "2025-08-16 23:13:47.000",
        "id": "cgnSeoWVWZ7e2uRAVTO3"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "8e22b665-a601-46c2-9ba5-ef874de1dde4",
            "mapping_index": 8,
            "structured_type": "structured",
            "detail_level": "high"
        },
        "timestamp": "2025-08-16 23:13:47.000",
        "id": "gTtUE6uK3h39nWhmTdpN"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "8e22b665-a601-46c2-9ba5-ef874de1dde4",
            "mapping_index": 1,
            "structured_type": "structured",
            "detail_level": "high"
        },
        "timestamp": "2025-08-16 23:13:47.000",
        "id": "jUFr8NG9LQXl5aGeIkZe"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "8e22b665-a601-46c2-9ba5-ef874de1dde4",
            "detail_level": "high",
            "structured_type": "structured"
        },
        "timestamp": "2025-08-16 23:13:47.000",
        "id": "rTZPFEM7mii7q2XxHCLs"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "8e22b665-a601-46c2-9ba5-ef874de1dde4",
            "mapping_index": 3,
            "structured_type": "structured",
            "detail_level": "high"
        },
        "timestamp": "2025-08-16 23:13:47.000",
        "id": "uZfBo5totkvgR7IkjbhV"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "8e22b665-a601-46c2-9ba5-ef874de1dde4",
            "mapping_index": 11,
            "structured_type": "structured",
            "detail_level": "high"
        },
        "timestamp": "2025-08-16 23:13:48.000",
        "id": "6xJKE6lHWvWYkDjOoKRS"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "8e22b665-a601-46c2-9ba5-ef874de1dde4",
            "detail_level": "high",
            "structured_type": "structured"
        },
        "timestamp": "2025-08-16 23:13:48.000",
        "id": "kOd7d7yDO0tzDr9LQmQo"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "8e22b665-a601-46c2-9ba5-ef874de1dde4",
            "detail_level": "high",
            "structured_type": "structured"
        },
        "timestamp": "2025-08-16 23:13:49.000",
        "id": "KzBlX9qd5oIBLW1GExj1"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "8e22b665-a601-46c2-9ba5-ef874de1dde4",
            "mapping_index": 11,
            "structured_type": "structured",
            "detail_level": "high"
        },
        "timestamp": "2025-08-16 23:13:50.000",
        "id": "rI40RaGgZHVvxUYn8FcX"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "8e22b665-a601-46c2-9ba5-ef874de1dde4",
            "mapping_index": 10,
            "structured_type": "structured",
            "detail_level": "high"
        },
        "timestamp": "2025-08-16 23:13:55.000",
        "id": "LvySkXuHCIw6H7LmOPeV"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "8e22b665-a601-46c2-9ba5-ef874de1dde4",
            "detail_level": "high",
            "structured_type": "structured"
        },
        "timestamp": "2025-08-16 23:13:55.000",
        "id": "S8ggvHL76PF0aINquLAs"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "8e22b665-a601-46c2-9ba5-ef874de1dde4",
            "detail_level": "high",
            "structured_type": "structured"
        },
        "timestamp": "2025-08-16 23:13:55.000",
        "id": "yCAcJbk4UiuYbugXKCRY"
    },
    {
        "source": "frontend",
        "event": "click_edit_in_prompt",
        "data": {
            "section_id": "8e22b665-a601-46c2-9ba5-ef874de1dde4",
            "summary": "• Filters the DataFrame to include only rows from the specified year and sorts them by predicted rank\n• Prepares a melted DataFrame to include both predicted and true ranks for grouped bar plotting\n• Sets up a matplotlib figure with a specific size\n• Creates a Seaborn grouped bar plot:\n  ◦ x-axis: Player names\n  ◦ y-axis: Rank values (both predicted and actual)\n  ◦ Hue: 'RankType' to distinguish between predicted and true ranks\n  ◦ Palette: 'coolwarm' for visual contrast\n• Adds a horizontal dashed line at y=0 to indicate a reference\n• Rotates x-axis labels for better readability\n• Sets axis labels and a descriptive plot title indicating the year, now reflecting both predicted and true rankings\n• Adjusts layout for clarity and saves the figure as 'data/ranking_predictions_{year}.png'\n• The function visualizes both predicted and actual ranks in a grouped bar plot, not just predicted ranks; there are no changes from the previous version.",
            "detail_level": "high",
            "structured": "structured"
        },
        "timestamp": "2025-08-16 23:13:56.000",
        "id": "aT9KCuSvbiBm36sfVOx1"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "8e22b665-a601-46c2-9ba5-ef874de1dde4",
            "mapping_index": 10,
            "structured_type": "structured",
            "detail_level": "high"
        },
        "timestamp": "2025-08-16 23:13:57.000",
        "id": "0jWKAhQrhXCQdgTGbgSF"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "8e22b665-a601-46c2-9ba5-ef874de1dde4",
            "detail_level": "high",
            "structured_type": "structured"
        },
        "timestamp": "2025-08-16 23:13:57.000",
        "id": "EVqzWmD4Z93hVlxQ3aDR"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "8e22b665-a601-46c2-9ba5-ef874de1dde4",
            "mapping_index": 11,
            "structured_type": "structured",
            "detail_level": "high"
        },
        "timestamp": "2025-08-16 23:13:57.000",
        "id": "b8tLKJ6dVv8IisyiqaTi"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "8e22b665-a601-46c2-9ba5-ef874de1dde4",
            "detail_level": "high",
            "structured_type": "structured"
        },
        "timestamp": "2025-08-16 23:13:57.000",
        "id": "wDtnSoZJWW0SIYPVNOfP"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "8e22b665-a601-46c2-9ba5-ef874de1dde4",
            "mapping_index": 11,
            "structured_type": "structured",
            "detail_level": "high"
        },
        "timestamp": "2025-08-16 23:13:58.000",
        "id": "xjIHvh14hg8NUGrcHWdg"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "8e22b665-a601-46c2-9ba5-ef874de1dde4",
            "detail_level": "high",
            "structured_type": "structured"
        },
        "timestamp": "2025-08-16 23:13:58.000",
        "id": "yakNeoWaSjbWbap5jkfV"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "8e22b665-a601-46c2-9ba5-ef874de1dde4",
            "mapping_index": 11,
            "structured_type": "structured",
            "detail_level": "high"
        },
        "timestamp": "2025-08-16 23:13:59.000",
        "id": "p4f2GpjKVxmBVxY9PGs7"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "8e22b665-a601-46c2-9ba5-ef874de1dde4",
            "detail_level": "high",
            "structured_type": "structured"
        },
        "timestamp": "2025-08-16 23:14:01.000",
        "id": "0yJ7CNAuUqWO08HLTC4r"
    },
    {
        "source": "frontend",
        "event": "commit_modified_summary",
        "data": {
            "section_id": "8e22b665-a601-46c2-9ba5-ef874de1dde4",
            "edited_summary": "• Filters the DataFrame to include only rows from the specified year and sorts them by predicted rank\n• Prepares a melted DataFrame to include both predicted and true ranks for grouped bar plotting\n• Sets up a matplotlib figure with a specific size\n• Creates a Seaborn grouped bar plot:\n  ◦ x-axis: Player names\n  ◦ y-axis: Rank values (both predicted and actual)\n  ◦ Hue: 'RankType' to distinguish between predicted and true ranks\n  ◦ Palette: 'coolwarm' for visual contrast\n• Adds a horizontal dashed line at y=0 to indicate a reference\n• Rotates x-axis labels for better readability\n• Sets axis labels and a descriptive plot title indicating the year, now reflecting both predicted and true rankings\n• Adjusts layout (set legend to the top mid) for clarity and saves the figure as 'data/ranking_predictions_{year}.png'\n• The function visualizes both predicted and actual ranks in a grouped bar plot, not just predicted ranks; there are no changes from the previous version.",
            "detail_level": "high",
            "original_summary": "• Filters the DataFrame to include only rows from the specified year and sorts them by predicted rank\n• Prepares a melted DataFrame to include both predicted and true ranks for grouped bar plotting\n• Sets up a matplotlib figure with a specific size\n• Creates a Seaborn grouped bar plot:\n  ◦ x-axis: Player names\n  ◦ y-axis: Rank values (both predicted and actual)\n  ◦ Hue: 'RankType' to distinguish between predicted and true ranks\n  ◦ Palette: 'coolwarm' for visual contrast\n• Adds a horizontal dashed line at y=0 to indicate a reference\n• Rotates x-axis labels for better readability\n• Sets axis labels and a descriptive plot title indicating the year, now reflecting both predicted and true rankings\n• Adjusts layout for clarity and saves the figure as 'data/ranking_predictions_{year}.png'\n• The function visualizes both predicted and actual ranks in a grouped bar plot, not just predicted ranks; there are no changes from the previous version.",
            "structured": "structured"
        },
        "timestamp": "2025-08-16 23:14:13.000",
        "id": "dCzFzV1SB2cuHMnJTPia"
    },
    {
        "source": "backend",
        "event": "modify_summary_mediation",
        "data": {
            "original_code": "def plot_ranking_predictions(df, year):\n    \"\"\"\n    Plot predicted and true ranks for a specific year.\n\n    Args:\n        df: DataFrame containing prediction results\n        year: Year to plot predicted and true ranks for\n    \"\"\"\n    year_df = df[df[\"Year\"] == year].copy()\n    year_df.sort_values(\"PredictedRank\", inplace=True)\n\n    # Prepare data for grouped barplot\n    plot_df = year_df[[\"Name\", \"PredictedRank\", \"Rank\"]].melt(\n        id_vars=\"Name\", value_vars=[\"PredictedRank\", \"Rank\"], \n        var_name=\"RankType\", value_name=\"RankValue\"\n    )\n\n    plt.figure(figsize=(12, 6))\n    sns.barplot(\n        x=\"Name\", y=\"RankValue\", hue=\"RankType\", data=plot_df, \n        palette=\"coolwarm\", dodge=True\n    )\n    plt.axhline(0, color=\"black\", linestyle=\"--\")\n    plt.xticks(rotation=45, ha=\"right\")\n    plt.ylabel(\"Rank\")\n    plt.title(f\"MVP Predicted vs True Rankings ({year})\")\n    plt.tight_layout()\n    plt.legend(loc=\"center\")\n    plt.savefig(f\"data/ranking_predictions_{year}.png\")",
            "original_summary": "• Filters the DataFrame to include only rows from the specified year and sorts them by predicted rank\n• Prepares a melted DataFrame to include both predicted and true ranks for grouped bar plotting\n• Sets up a matplotlib figure with a specific size\n• Creates a Seaborn grouped bar plot:\n  ◦ x-axis: Player names\n  ◦ y-axis: Rank values (both predicted and actual)\n  ◦ Hue: 'RankType' to distinguish between predicted and true ranks\n  ◦ Palette: 'coolwarm' for visual contrast\n• Adds a horizontal dashed line at y=0 to indicate a reference\n• Rotates x-axis labels for better readability\n• Sets axis labels and a descriptive plot title indicating the year, now reflecting both predicted and true rankings\n• Adjusts layout for clarity and saves the figure as 'data/ranking_predictions_{year}.png'\n• The function visualizes both predicted and actual ranks in a grouped bar plot, not just predicted ranks; there are no changes from the previous version.",
            "edited_summary": "• Filters the DataFrame to include only rows from the specified year and sorts them by predicted rank\n• Prepares a melted DataFrame to include both predicted and true ranks for grouped bar plotting\n• Sets up a matplotlib figure with a specific size\n• Creates a Seaborn grouped bar plot:\n  ◦ x-axis: Player names\n  ◦ y-axis: Rank values (both predicted and actual)\n  ◦ Hue: 'RankType' to distinguish between predicted and true ranks\n  ◦ Palette: 'coolwarm' for visual contrast\n• Adds a horizontal dashed line at y=0 to indicate a reference\n• Rotates x-axis labels for better readability\n• Sets axis labels and a descriptive plot title indicating the year, now reflecting both predicted and true rankings\n• Adjusts layout (set legend to the top mid) for clarity and saves the figure as 'data/ranking_predictions_{year}.png'\n• The function visualizes both predicted and actual ranks in a grouped bar plot, not just predicted ranks; there are no changes from the previous version.",
            "structured_type": "structured",
            "detail_level": "high",
            "updated_code": "def plot_ranking_predictions(df, year):\n    \"\"\"\n    Plot predicted and true ranks for a specific year.\n\n    Args:\n        df: DataFrame containing prediction results\n        year: Year to plot predicted and true ranks for\n    \"\"\"\n    year_df = df[df[\"Year\"] == year].copy()\n    year_df.sort_values(\"PredictedRank\", inplace=True)\n\n    # Prepare data for grouped barplot\n    plot_df = year_df[[\"Name\", \"PredictedRank\", \"Rank\"]].melt(\n        id_vars=\"Name\", value_vars=[\"PredictedRank\", \"Rank\"], \n        var_name=\"RankType\", value_name=\"RankValue\"\n    )\n\n    plt.figure(figsize=(12, 6))\n    sns.barplot(\n        x=\"Name\", y=\"RankValue\", hue=\"RankType\", data=plot_df, \n        palette=\"coolwarm\", dodge=True\n    )\n    plt.axhline(0, color=\"black\", linestyle=\"--\")\n    plt.xticks(rotation=45, ha=\"right\")\n    plt.ylabel(\"Rank\")\n    plt.title(f\"MVP Predicted vs True Rankings ({year})\")\n    plt.tight_layout()\n    plt.legend(loc=\"upper center\", bbox_to_anchor=(0.5, 1.10), ncol=2)\n    plt.savefig(f\"data/ranking_predictions_{year}.png\")"
        },
        "timestamp": "2025-08-16 23:14:18.000",
        "id": "AKayR0a1ua6WBqF0rCmx"
    },
    {
        "source": "backend",
        "event": "summarize_modified_code",
        "data": {
            "new_code": "def plot_ranking_predictions(df, year):\n    \"\"\"\n    Plot predicted and true ranks for a specific year.\n\n    Args:\n        df: DataFrame containing prediction results\n        year: Year to plot predicted and true ranks for\n    \"\"\"\n    year_df = df[df[\"Year\"] == year].copy()\n    year_df.sort_values(\"PredictedRank\", inplace=True)\n\n    # Prepare data for grouped barplot\n    plot_df = year_df[[\"Name\", \"PredictedRank\", \"Rank\"]].melt(\n        id_vars=\"Name\", value_vars=[\"PredictedRank\", \"Rank\"], \n        var_name=\"RankType\", value_name=\"RankValue\"\n    )\n\n    plt.figure(figsize=(12, 6))\n    sns.barplot(\n        x=\"Name\", y=\"RankValue\", hue=\"RankType\", data=plot_df, \n        palette=\"coolwarm\", dodge=True\n    )\n    plt.axhline(0, color=\"black\", linestyle=\"--\")\n    plt.xticks(rotation=45, ha=\"right\")\n    plt.ylabel(\"Rank\")\n    plt.title(f\"MVP Predicted vs True Rankings ({year})\")\n    plt.tight_layout()\n    plt.legend(loc=\"upper center\", bbox_to_anchor=(0.5, 1.10), ncol=2)\n    plt.savefig(f\"data/ranking_predictions_{year}.png\")",
            "original_code": "def plot_ranking_predictions(df, year):\n    \"\"\"\n    Plot predicted and true ranks for a specific year.\n\n    Args:\n        df: DataFrame containing prediction results\n        year: Year to plot predicted and true ranks for\n    \"\"\"\n    year_df = df[df[\"Year\"] == year].copy()\n    year_df.sort_values(\"PredictedRank\", inplace=True)\n\n    # Prepare data for grouped barplot\n    plot_df = year_df[[\"Name\", \"PredictedRank\", \"Rank\"]].melt(\n        id_vars=\"Name\", value_vars=[\"PredictedRank\", \"Rank\"], \n        var_name=\"RankType\", value_name=\"RankValue\"\n    )\n\n    plt.figure(figsize=(12, 6))\n    sns.barplot(\n        x=\"Name\", y=\"RankValue\", hue=\"RankType\", data=plot_df, \n        palette=\"coolwarm\", dodge=True\n    )\n    plt.axhline(0, color=\"black\", linestyle=\"--\")\n    plt.xticks(rotation=45, ha=\"right\")\n    plt.ylabel(\"Rank\")\n    plt.title(f\"MVP Predicted vs True Rankings ({year})\")\n    plt.tight_layout()\n    plt.legend(loc=\"upper center\", bbox_to_anchor=(0.5, 1.10), ncol=2)\n    plt.savefig(f\"data/ranking_predictions_{year}.png\")",
            "old_summary": {
                "low_structured": "• Plots both predicted and true ranks for a given year\n• Saves the plot as an image file\n• The function visualizes both predicted and actual ranks in a grouped bar plot, instead of only predicted ranks; there are no changes from the previous version.",
                "high_unstructured": "The plot_ranking_predictions function generates a grouped bar plot to visualize both the predicted and true rank for each player in a specified year. It filters the DataFrame for the given year, sorts the data by predicted rank, and prepares the data so that both predicted and actual ranks are shown as separate bars for each player using Seaborn. The plot uses player names on the x-axis, rank values on the y-axis, and a hue to distinguish between predicted and true ranks, with a horizontal line at zero for reference. The plot is formatted for readability and saved as a PNG file named according to the year. (The function continues to plot both predicted and actual ranks, instead of only predicted ranks; there are no changes from the previous version.)",
                "medium_unstructured": "The plot_ranking_predictions function visualizes both the predicted and true ranks for each player in a specified year. It creates a grouped bar plot showing both predicted and actual rank values for each player and saves the resulting image to a file. The plot includes player names, predicted and true rank values, and a reference line at zero. (The function continues to focus on plotting both predicted and actual ranks, not just predicted ranks; there are no changes from the previous version.)",
                "high_structured": "• Filters the DataFrame to include only rows from the specified year and sorts them by predicted rank\n• Prepares a melted DataFrame to include both predicted and true ranks for grouped bar plotting\n• Sets up a matplotlib figure with a specific size\n• Creates a Seaborn grouped bar plot:\n  ◦ x-axis: Player names\n  ◦ y-axis: Rank values (both predicted and actual)\n  ◦ Hue: 'RankType' to distinguish between predicted and true ranks\n  ◦ Palette: 'coolwarm' for visual contrast\n• Adds a horizontal dashed line at y=0 to indicate a reference\n• Rotates x-axis labels for better readability\n• Sets axis labels and a descriptive plot title indicating the year, now reflecting both predicted and true rankings\n• Adjusts layout for clarity and saves the figure as 'data/ranking_predictions_{year}.png'\n• The function visualizes both predicted and actual ranks in a grouped bar plot, not just predicted ranks; there are no changes from the previous version.",
                "title": "Function: plot_ranking_predictions",
                "low_unstructured": "This function plots and saves both the predicted and true ranks for players in a specified year, displaying both predicted and actual rank values in a grouped bar plot; there are no changes from the previous version.",
                "medium_structured": "• Filters data for the specified year and sorts by predicted rank\n• Creates a grouped bar plot of both predicted and true ranks for each player\n  ◦ Uses player names as labels and includes both predicted and actual ranks as hue\n• Adds a horizontal reference line and saves the plot as a PNG file\n• The function plots both predicted and actual ranks, rather than only predicted ranks; there are no changes from the previous version."
            },
            "new_summary": {
                "low_structured": "• Plots both predicted and true ranks for a given year\n• Saves the plot as an image file\n• The function visualizes both predicted and actual ranks in a grouped bar plot, instead of only predicted ranks; the function remains unchanged from the previous version.",
                "high_unstructured": "The plot_ranking_predictions function generates a grouped bar plot to visualize both the predicted and true rank for each player in a specified year. It filters the DataFrame for the given year, sorts the data by predicted rank, and prepares the data so that both predicted and actual ranks are shown as separate bars for each player using Seaborn. The plot uses player names on the x-axis, rank values on the y-axis, and a hue to distinguish between predicted and true ranks, with a horizontal line at zero for reference. The plot is formatted for readability and saved as a PNG file named according to the year. (The function continues to plot both predicted and actual ranks, instead of only predicted ranks; the function remains unchanged from the previous version.)",
                "medium_unstructured": "The plot_ranking_predictions function visualizes both the predicted and true ranks for each player in a specified year. It creates a grouped bar plot showing both predicted and actual rank values for each player and saves the resulting image to a file. The plot includes player names, predicted and true rank values, and a reference line at zero. (The function continues to focus on plotting both predicted and actual ranks, not just predicted ranks; the function remains unchanged from the previous version.)",
                "high_structured": "• Filters the DataFrame to include only rows from the specified year and sorts them by predicted rank\n• Prepares a melted DataFrame to include both predicted and true ranks for grouped bar plotting\n• Sets up a matplotlib figure with a specific size\n• Creates a Seaborn grouped bar plot:\n  ◦ x-axis: Player names\n  ◦ y-axis: Rank values (both predicted and actual)\n  ◦ Hue: 'RankType' to distinguish between predicted and true ranks\n  ◦ Palette: 'coolwarm' for visual contrast\n• Adds a horizontal dashed line at y=0 to indicate a reference\n• Rotates x-axis labels for better readability\n• Sets axis labels and a descriptive plot title indicating the year, now reflecting both predicted and true rankings\n• Adjusts layout for clarity and saves the figure as 'data/ranking_predictions_{year}.png'\n• The function visualizes both predicted and actual ranks in a grouped bar plot, not just predicted ranks; the function remains unchanged from the previous version.",
                "title": "Function: plot_ranking_predictions",
                "low_unstructured": "This function plots and saves both the predicted and true ranks for players in a specified year, displaying both predicted and actual rank values in a grouped bar plot; the function remains unchanged from the previous version.",
                "medium_structured": "• Filters data for the specified year and sorts by predicted rank\n• Creates a grouped bar plot of both predicted and true ranks for each player\n  ◦ Uses player names as labels and includes both predicted and actual ranks as hue\n• Adds a horizontal reference line and saves the plot as a PNG file\n• The function plots both predicted and actual ranks, rather than only predicted ranks; the function remains unchanged from the previous version."
            }
        },
        "timestamp": "2025-08-16 23:14:23.000",
        "id": "IstUeNA0CrYEehGaYGzz"
    },
    {
        "source": "backend",
        "event": "map_summary_code",
        "data": {
            "summary": "This function plots and saves both the predicted and true ranks for players in a specified year, displaying both predicted and actual rank values in a grouped bar plot; the function remains unchanged from the previous version.",
            "mapping": [
                {
                    "summaryComponent": "plots and saves both the predicted and true ranks",
                    "codeSegments": [
                        {
                            "line": 95,
                            "code": "plt.savefig(f\"data/ranking_predictions_{year}.png\")"
                        },
                        {
                            "line": 85,
                            "code": "sns.barplot("
                        },
                        {
                            "line": 86,
                            "code": "x=\"Name\", y=\"RankValue\", hue=\"RankType\", data=plot_df,"
                        }
                    ]
                },
                {
                    "summaryComponent": "for players in a specified year",
                    "codeSegments": [
                        {
                            "line": 75,
                            "code": "year_df = df[df[\"Year\"] == year].copy()"
                        }
                    ]
                },
                {
                    "summaryComponent": "displaying both predicted and actual rank values",
                    "codeSegments": [
                        {
                            "line": 79,
                            "code": "plot_df = year_df[[\"Name\", \"PredictedRank\", \"Rank\"]].melt("
                        },
                        {
                            "line": 80,
                            "code": "value_vars=[\"PredictedRank\", \"Rank\"],"
                        }
                    ]
                },
                {
                    "summaryComponent": "in a grouped bar plot",
                    "codeSegments": [
                        {
                            "line": 85,
                            "code": "sns.barplot("
                        },
                        {
                            "line": 87,
                            "code": "dodge=True"
                        }
                    ]
                },
                {
                    "summaryComponent": "the function remains unchanged from the previous version",
                    "codeSegments": []
                }
            ],
            "code": "67: def plot_ranking_predictions(df, year):\n68:     \"\"\"\n69:     Plot predicted and true ranks for a specific year.\n70: \n71:     Args:\n72:         df: DataFrame containing prediction results\n73:         year: Year to plot predicted and true ranks for\n74:     \"\"\"\n75:     year_df = df[df[\"Year\"] == year].copy()\n76:     year_df.sort_values(\"PredictedRank\", inplace=True)\n77: \n78:     # Prepare data for grouped barplot\n79:     plot_df = year_df[[\"Name\", \"PredictedRank\", \"Rank\"]].melt(\n80:         id_vars=\"Name\", value_vars=[\"PredictedRank\", \"Rank\"], \n81:         var_name=\"RankType\", value_name=\"RankValue\"\n82:     )\n83: \n84:     plt.figure(figsize=(12, 6))\n85:     sns.barplot(\n86:         x=\"Name\", y=\"RankValue\", hue=\"RankType\", data=plot_df, \n87:         palette=\"coolwarm\", dodge=True\n88:     )\n89:     plt.axhline(0, color=\"black\", linestyle=\"--\")\n90:     plt.xticks(rotation=45, ha=\"right\")\n91:     plt.ylabel(\"Rank\")\n92:     plt.title(f\"MVP Predicted vs True Rankings ({year})\")\n93:     plt.tight_layout()\n94:     plt.legend(loc=\"upper center\", bbox_to_anchor=(0.5, 1.10), ncol=2)\n95:     plt.savefig(f\"data/ranking_predictions_{year}.png\")"
        },
        "timestamp": "2025-08-16 23:14:25.000",
        "id": "E6dcYzXxAzjtWn9GQNyE"
    },
    {
        "source": "backend",
        "event": "map_summary_code",
        "data": {
            "summary": "• Filters data for the specified year and sorts by predicted rank\n• Creates a grouped bar plot of both predicted and true ranks for each player\n  ◦ Uses player names as labels and includes both predicted and actual ranks as hue\n• Adds a horizontal reference line and saves the plot as a PNG file\n• The function plots both predicted and actual ranks, rather than only predicted ranks; the function remains unchanged from the previous version.",
            "mapping": [
                {
                    "summaryComponent": "Filters data for the specified year and sorts by predicted rank",
                    "codeSegments": [
                        {
                            "line": 75,
                            "code": "year_df = df[df[\"Year\"] == year].copy()"
                        },
                        {
                            "line": 76,
                            "code": "year_df.sort_values(\"PredictedRank\", inplace=True)"
                        }
                    ]
                },
                {
                    "summaryComponent": "Creates a grouped bar plot of both predicted and true ranks for each player",
                    "codeSegments": [
                        {
                            "line": 79,
                            "code": "plot_df = year_df[[\"Name\", \"PredictedRank\", \"Rank\"]].melt("
                        },
                        {
                            "line": 85,
                            "code": "sns.barplot("
                        }
                    ]
                },
                {
                    "summaryComponent": "Uses player names as labels and includes both predicted and actual ranks as hue",
                    "codeSegments": [
                        {
                            "line": 86,
                            "code": "x=\"Name\", y=\"RankValue\", hue=\"RankType\", data=plot_df,"
                        }
                    ]
                },
                {
                    "summaryComponent": "Adds a horizontal reference line and saves the plot as a PNG file",
                    "codeSegments": [
                        {
                            "line": 89,
                            "code": "plt.axhline(0, color=\"black\", linestyle=\"--\")"
                        },
                        {
                            "line": 95,
                            "code": "plt.savefig(f\"data/ranking_predictions_{year}.png\")"
                        }
                    ]
                },
                {
                    "summaryComponent": "The function plots both predicted and actual ranks, rather than only predicted ranks; the function remains unchanged from the previous version.",
                    "codeSegments": [
                        {
                            "line": 79,
                            "code": "plot_df = year_df[[\"Name\", \"PredictedRank\", \"Rank\"]].melt("
                        },
                        {
                            "line": 85,
                            "code": "sns.barplot("
                        }
                    ]
                }
            ],
            "code": "67: def plot_ranking_predictions(df, year):\n68:     \"\"\"\n69:     Plot predicted and true ranks for a specific year.\n70: \n71:     Args:\n72:         df: DataFrame containing prediction results\n73:         year: Year to plot predicted and true ranks for\n74:     \"\"\"\n75:     year_df = df[df[\"Year\"] == year].copy()\n76:     year_df.sort_values(\"PredictedRank\", inplace=True)\n77: \n78:     # Prepare data for grouped barplot\n79:     plot_df = year_df[[\"Name\", \"PredictedRank\", \"Rank\"]].melt(\n80:         id_vars=\"Name\", value_vars=[\"PredictedRank\", \"Rank\"], \n81:         var_name=\"RankType\", value_name=\"RankValue\"\n82:     )\n83: \n84:     plt.figure(figsize=(12, 6))\n85:     sns.barplot(\n86:         x=\"Name\", y=\"RankValue\", hue=\"RankType\", data=plot_df, \n87:         palette=\"coolwarm\", dodge=True\n88:     )\n89:     plt.axhline(0, color=\"black\", linestyle=\"--\")\n90:     plt.xticks(rotation=45, ha=\"right\")\n91:     plt.ylabel(\"Rank\")\n92:     plt.title(f\"MVP Predicted vs True Rankings ({year})\")\n93:     plt.tight_layout()\n94:     plt.legend(loc=\"upper center\", bbox_to_anchor=(0.5, 1.10), ncol=2)\n95:     plt.savefig(f\"data/ranking_predictions_{year}.png\")"
        },
        "timestamp": "2025-08-16 23:14:26.000",
        "id": "UmYkd15MhnLTOvjEdTYX"
    },
    {
        "source": "backend",
        "event": "map_summary_code",
        "data": {
            "summary": "The plot_ranking_predictions function visualizes both the predicted and true ranks for each player in a specified year. It creates a grouped bar plot showing both predicted and actual rank values for each player and saves the resulting image to a file. The plot includes player names, predicted and true rank values, and a reference line at zero. (The function continues to focus on plotting both predicted and actual ranks, not just predicted ranks; the function remains unchanged from the previous version.)",
            "mapping": [
                {
                    "summaryComponent": "The plot_ranking_predictions function",
                    "codeSegments": [
                        {
                            "line": 67,
                            "code": "def plot_ranking_predictions(df, year):"
                        }
                    ]
                },
                {
                    "summaryComponent": "visualizes both the predicted and true ranks for each player in a specified year",
                    "codeSegments": [
                        {
                            "line": 75,
                            "code": "year_df = df[df[\"Year\"] == year].copy()"
                        },
                        {
                            "line": 76,
                            "code": "year_df.sort_values(\"PredictedRank\", inplace=True)"
                        },
                        {
                            "line": 79,
                            "code": "plot_df = year_df[[\"Name\", \"PredictedRank\", \"Rank\"]].melt("
                        },
                        {
                            "line": 80,
                            "code": "id_vars=\"Name\", value_vars=[\"PredictedRank\", \"Rank\"], "
                        }
                    ]
                },
                {
                    "summaryComponent": "It creates a grouped bar plot showing both predicted and actual rank values for each player",
                    "codeSegments": [
                        {
                            "line": 85,
                            "code": "sns.barplot("
                        },
                        {
                            "line": 86,
                            "code": "x=\"Name\", y=\"RankValue\", hue=\"RankType\", data=plot_df, "
                        }
                    ]
                },
                {
                    "summaryComponent": "and saves the resulting image to a file",
                    "codeSegments": [
                        {
                            "line": 95,
                            "code": "plt.savefig(f\"data/ranking_predictions_{year}.png\")"
                        }
                    ]
                },
                {
                    "summaryComponent": "The plot includes player names, predicted and true rank values, and a reference line at zero",
                    "codeSegments": [
                        {
                            "line": 86,
                            "code": "x=\"Name\", y=\"RankValue\", hue=\"RankType\", data=plot_df, "
                        },
                        {
                            "line": 89,
                            "code": "plt.axhline(0, color=\"black\", linestyle=\"--\")"
                        }
                    ]
                }
            ],
            "code": "67: def plot_ranking_predictions(df, year):\n68:     \"\"\"\n69:     Plot predicted and true ranks for a specific year.\n70: \n71:     Args:\n72:         df: DataFrame containing prediction results\n73:         year: Year to plot predicted and true ranks for\n74:     \"\"\"\n75:     year_df = df[df[\"Year\"] == year].copy()\n76:     year_df.sort_values(\"PredictedRank\", inplace=True)\n77: \n78:     # Prepare data for grouped barplot\n79:     plot_df = year_df[[\"Name\", \"PredictedRank\", \"Rank\"]].melt(\n80:         id_vars=\"Name\", value_vars=[\"PredictedRank\", \"Rank\"], \n81:         var_name=\"RankType\", value_name=\"RankValue\"\n82:     )\n83: \n84:     plt.figure(figsize=(12, 6))\n85:     sns.barplot(\n86:         x=\"Name\", y=\"RankValue\", hue=\"RankType\", data=plot_df, \n87:         palette=\"coolwarm\", dodge=True\n88:     )\n89:     plt.axhline(0, color=\"black\", linestyle=\"--\")\n90:     plt.xticks(rotation=45, ha=\"right\")\n91:     plt.ylabel(\"Rank\")\n92:     plt.title(f\"MVP Predicted vs True Rankings ({year})\")\n93:     plt.tight_layout()\n94:     plt.legend(loc=\"upper center\", bbox_to_anchor=(0.5, 1.10), ncol=2)\n95:     plt.savefig(f\"data/ranking_predictions_{year}.png\")"
        },
        "timestamp": "2025-08-16 23:14:26.000",
        "id": "X3NYHLRBDpfczbtsYOjr"
    },
    {
        "source": "backend",
        "event": "map_summary_code",
        "data": {
            "summary": "• Plots both predicted and true ranks for a given year\n• Saves the plot as an image file\n• The function visualizes both predicted and actual ranks in a grouped bar plot, instead of only predicted ranks; the function remains unchanged from the previous version.",
            "mapping": [
                {
                    "summaryComponent": "Plots both predicted and true ranks for a given year",
                    "codeSegments": [
                        {
                            "line": 67,
                            "code": "def plot_ranking_predictions(df, year):"
                        },
                        {
                            "line": 75,
                            "code": "year_df = df[df[\"Year\"] == year].copy()"
                        },
                        {
                            "line": 79,
                            "code": "plot_df = year_df[[\"Name\", \"PredictedRank\", \"Rank\"]].melt("
                        },
                        {
                            "line": 85,
                            "code": "sns.barplot("
                        }
                    ]
                },
                {
                    "summaryComponent": "Saves the plot as an image file",
                    "codeSegments": [
                        {
                            "line": 95,
                            "code": "plt.savefig(f\"data/ranking_predictions_{year}.png\")"
                        }
                    ]
                },
                {
                    "summaryComponent": "visualizes both predicted and actual ranks in a grouped bar plot",
                    "codeSegments": [
                        {
                            "line": 79,
                            "code": "plot_df = year_df[[\"Name\", \"PredictedRank\", \"Rank\"]].melt("
                        },
                        {
                            "line": 85,
                            "code": "sns.barplot("
                        }
                    ]
                },
                {
                    "summaryComponent": "instead of only predicted ranks",
                    "codeSegments": [
                        {
                            "line": 79,
                            "code": "plot_df = year_df[[\"Name\", \"PredictedRank\", \"Rank\"]].melt("
                        }
                    ]
                },
                {
                    "summaryComponent": "the function remains unchanged from the previous version.",
                    "codeSegments": [
                        {
                            "line": 67,
                            "code": "def plot_ranking_predictions(df, year):"
                        }
                    ]
                }
            ],
            "code": "67: def plot_ranking_predictions(df, year):\n68:     \"\"\"\n69:     Plot predicted and true ranks for a specific year.\n70: \n71:     Args:\n72:         df: DataFrame containing prediction results\n73:         year: Year to plot predicted and true ranks for\n74:     \"\"\"\n75:     year_df = df[df[\"Year\"] == year].copy()\n76:     year_df.sort_values(\"PredictedRank\", inplace=True)\n77: \n78:     # Prepare data for grouped barplot\n79:     plot_df = year_df[[\"Name\", \"PredictedRank\", \"Rank\"]].melt(\n80:         id_vars=\"Name\", value_vars=[\"PredictedRank\", \"Rank\"], \n81:         var_name=\"RankType\", value_name=\"RankValue\"\n82:     )\n83: \n84:     plt.figure(figsize=(12, 6))\n85:     sns.barplot(\n86:         x=\"Name\", y=\"RankValue\", hue=\"RankType\", data=plot_df, \n87:         palette=\"coolwarm\", dodge=True\n88:     )\n89:     plt.axhline(0, color=\"black\", linestyle=\"--\")\n90:     plt.xticks(rotation=45, ha=\"right\")\n91:     plt.ylabel(\"Rank\")\n92:     plt.title(f\"MVP Predicted vs True Rankings ({year})\")\n93:     plt.tight_layout()\n94:     plt.legend(loc=\"upper center\", bbox_to_anchor=(0.5, 1.10), ncol=2)\n95:     plt.savefig(f\"data/ranking_predictions_{year}.png\")"
        },
        "timestamp": "2025-08-16 23:14:26.000",
        "id": "dEDEizOS5gvSiMvY2rts"
    },
    {
        "source": "backend",
        "event": "map_summary_code",
        "data": {
            "summary": "• Filters the DataFrame to include only rows from the specified year and sorts them by predicted rank\n• Prepares a melted DataFrame to include both predicted and true ranks for grouped bar plotting\n• Sets up a matplotlib figure with a specific size\n• Creates a Seaborn grouped bar plot:\n  ◦ x-axis: Player names\n  ◦ y-axis: Rank values (both predicted and actual)\n  ◦ Hue: 'RankType' to distinguish between predicted and true ranks\n  ◦ Palette: 'coolwarm' for visual contrast\n• Adds a horizontal dashed line at y=0 to indicate a reference\n• Rotates x-axis labels for better readability\n• Sets axis labels and a descriptive plot title indicating the year, now reflecting both predicted and true rankings\n• Adjusts layout for clarity and saves the figure as 'data/ranking_predictions_{year}.png'\n• The function visualizes both predicted and actual ranks in a grouped bar plot, not just predicted ranks; the function remains unchanged from the previous version.",
            "mapping": [
                {
                    "summaryComponent": "Filters the DataFrame to include only rows from the specified year and sorts them by predicted rank",
                    "codeSegments": [
                        {
                            "line": 75,
                            "code": "year_df = df[df[\"Year\"] == year].copy()"
                        },
                        {
                            "line": 76,
                            "code": "year_df.sort_values(\"PredictedRank\", inplace=True)"
                        }
                    ]
                },
                {
                    "summaryComponent": "Prepares a melted DataFrame to include both predicted and true ranks for grouped bar plotting",
                    "codeSegments": [
                        {
                            "line": 79,
                            "code": "plot_df = year_df[[\"Name\", \"PredictedRank\", \"Rank\"]].melt("
                        },
                        {
                            "line": 80,
                            "code": "    id_vars=\"Name\", value_vars=[\"PredictedRank\", \"Rank\"], "
                        },
                        {
                            "line": 81,
                            "code": "    var_name=\"RankType\", value_name=\"RankValue\""
                        },
                        {
                            "line": 82,
                            "code": ")"
                        }
                    ]
                },
                {
                    "summaryComponent": "Sets up a matplotlib figure with a specific size",
                    "codeSegments": [
                        {
                            "line": 84,
                            "code": "plt.figure(figsize=(12, 6))"
                        }
                    ]
                },
                {
                    "summaryComponent": "Creates a Seaborn grouped bar plot:",
                    "codeSegments": [
                        {
                            "line": 85,
                            "code": "sns.barplot("
                        },
                        {
                            "line": 86,
                            "code": "    x=\"Name\", y=\"RankValue\", hue=\"RankType\", data=plot_df, "
                        },
                        {
                            "line": 87,
                            "code": "    palette=\"coolwarm\", dodge=True"
                        },
                        {
                            "line": 88,
                            "code": ")"
                        }
                    ]
                },
                {
                    "summaryComponent": "x-axis: Player names",
                    "codeSegments": [
                        {
                            "line": 86,
                            "code": "x=\"Name\""
                        }
                    ]
                },
                {
                    "summaryComponent": "y-axis: Rank values (both predicted and actual)",
                    "codeSegments": [
                        {
                            "line": 86,
                            "code": "y=\"RankValue\""
                        }
                    ]
                },
                {
                    "summaryComponent": "Hue: 'RankType' to distinguish between predicted and true ranks",
                    "codeSegments": [
                        {
                            "line": 86,
                            "code": "hue=\"RankType\""
                        }
                    ]
                },
                {
                    "summaryComponent": "Palette: 'coolwarm' for visual contrast",
                    "codeSegments": [
                        {
                            "line": 87,
                            "code": "palette=\"coolwarm\""
                        }
                    ]
                },
                {
                    "summaryComponent": "Adds a horizontal dashed line at y=0 to indicate a reference",
                    "codeSegments": [
                        {
                            "line": 89,
                            "code": "plt.axhline(0, color=\"black\", linestyle=\"--\")"
                        }
                    ]
                },
                {
                    "summaryComponent": "Rotates x-axis labels for better readability",
                    "codeSegments": [
                        {
                            "line": 90,
                            "code": "plt.xticks(rotation=45, ha=\"right\")"
                        }
                    ]
                }
            ],
            "code": "67: def plot_ranking_predictions(df, year):\n68:     \"\"\"\n69:     Plot predicted and true ranks for a specific year.\n70: \n71:     Args:\n72:         df: DataFrame containing prediction results\n73:         year: Year to plot predicted and true ranks for\n74:     \"\"\"\n75:     year_df = df[df[\"Year\"] == year].copy()\n76:     year_df.sort_values(\"PredictedRank\", inplace=True)\n77: \n78:     # Prepare data for grouped barplot\n79:     plot_df = year_df[[\"Name\", \"PredictedRank\", \"Rank\"]].melt(\n80:         id_vars=\"Name\", value_vars=[\"PredictedRank\", \"Rank\"], \n81:         var_name=\"RankType\", value_name=\"RankValue\"\n82:     )\n83: \n84:     plt.figure(figsize=(12, 6))\n85:     sns.barplot(\n86:         x=\"Name\", y=\"RankValue\", hue=\"RankType\", data=plot_df, \n87:         palette=\"coolwarm\", dodge=True\n88:     )\n89:     plt.axhline(0, color=\"black\", linestyle=\"--\")\n90:     plt.xticks(rotation=45, ha=\"right\")\n91:     plt.ylabel(\"Rank\")\n92:     plt.title(f\"MVP Predicted vs True Rankings ({year})\")\n93:     plt.tight_layout()\n94:     plt.legend(loc=\"upper center\", bbox_to_anchor=(0.5, 1.10), ncol=2)\n95:     plt.savefig(f\"data/ranking_predictions_{year}.png\")"
        },
        "timestamp": "2025-08-16 23:14:27.000",
        "id": "BuucnmudUDEk82EzM7JS"
    },
    {
        "source": "backend",
        "event": "map_summary_code",
        "data": {
            "summary": "The plot_ranking_predictions function generates a grouped bar plot to visualize both the predicted and true rank for each player in a specified year. It filters the DataFrame for the given year, sorts the data by predicted rank, and prepares the data so that both predicted and actual ranks are shown as separate bars for each player using Seaborn. The plot uses player names on the x-axis, rank values on the y-axis, and a hue to distinguish between predicted and true ranks, with a horizontal line at zero for reference. The plot is formatted for readability and saved as a PNG file named according to the year. (The function continues to plot both predicted and actual ranks, instead of only predicted ranks; the function remains unchanged from the previous version.)",
            "mapping": [
                {
                    "summaryComponent": "The plot_ranking_predictions function generates a grouped bar plot",
                    "codeSegments": [
                        {
                            "line": 67,
                            "code": "def plot_ranking_predictions(df, year):"
                        },
                        {
                            "line": 85,
                            "code": "sns.barplot("
                        }
                    ]
                },
                {
                    "summaryComponent": "to visualize both the predicted and true rank for each player in a specified year",
                    "codeSegments": [
                        {
                            "line": 75,
                            "code": "year_df = df[df[\"Year\"] == year].copy()"
                        },
                        {
                            "line": 79,
                            "code": "plot_df = year_df[[\"Name\", \"PredictedRank\", \"Rank\"]].melt("
                        }
                    ]
                },
                {
                    "summaryComponent": "It filters the DataFrame for the given year",
                    "codeSegments": [
                        {
                            "line": 75,
                            "code": "year_df = df[df[\"Year\"] == year].copy()"
                        }
                    ]
                },
                {
                    "summaryComponent": "sorts the data by predicted rank",
                    "codeSegments": [
                        {
                            "line": 76,
                            "code": "year_df.sort_values(\"PredictedRank\", inplace=True)"
                        }
                    ]
                },
                {
                    "summaryComponent": "and prepares the data so that both predicted and actual ranks are shown as separate bars for each player using Seaborn",
                    "codeSegments": [
                        {
                            "line": 79,
                            "code": "plot_df = year_df[[\"Name\", \"PredictedRank\", \"Rank\"]].melt("
                        },
                        {
                            "line": 85,
                            "code": "sns.barplot("
                        }
                    ]
                },
                {
                    "summaryComponent": "The plot uses player names on the x-axis",
                    "codeSegments": [
                        {
                            "line": 86,
                            "code": "x=\"Name\""
                        }
                    ]
                },
                {
                    "summaryComponent": "rank values on the y-axis",
                    "codeSegments": [
                        {
                            "line": 86,
                            "code": "y=\"RankValue\""
                        }
                    ]
                },
                {
                    "summaryComponent": "and a hue to distinguish between predicted and true ranks",
                    "codeSegments": [
                        {
                            "line": 86,
                            "code": "hue=\"RankType\""
                        }
                    ]
                },
                {
                    "summaryComponent": "with a horizontal line at zero for reference",
                    "codeSegments": [
                        {
                            "line": 89,
                            "code": "plt.axhline(0, color=\"black\", linestyle=\"--\")"
                        }
                    ]
                },
                {
                    "summaryComponent": "The plot is formatted for readability and saved as a PNG file named according to the year",
                    "codeSegments": [
                        {
                            "line": 93,
                            "code": "plt.tight_layout()"
                        },
                        {
                            "line": 95,
                            "code": "plt.savefig(f\"data/ranking_predictions_{year}.png\")"
                        }
                    ]
                }
            ],
            "code": "67: def plot_ranking_predictions(df, year):\n68:     \"\"\"\n69:     Plot predicted and true ranks for a specific year.\n70: \n71:     Args:\n72:         df: DataFrame containing prediction results\n73:         year: Year to plot predicted and true ranks for\n74:     \"\"\"\n75:     year_df = df[df[\"Year\"] == year].copy()\n76:     year_df.sort_values(\"PredictedRank\", inplace=True)\n77: \n78:     # Prepare data for grouped barplot\n79:     plot_df = year_df[[\"Name\", \"PredictedRank\", \"Rank\"]].melt(\n80:         id_vars=\"Name\", value_vars=[\"PredictedRank\", \"Rank\"], \n81:         var_name=\"RankType\", value_name=\"RankValue\"\n82:     )\n83: \n84:     plt.figure(figsize=(12, 6))\n85:     sns.barplot(\n86:         x=\"Name\", y=\"RankValue\", hue=\"RankType\", data=plot_df, \n87:         palette=\"coolwarm\", dodge=True\n88:     )\n89:     plt.axhline(0, color=\"black\", linestyle=\"--\")\n90:     plt.xticks(rotation=45, ha=\"right\")\n91:     plt.ylabel(\"Rank\")\n92:     plt.title(f\"MVP Predicted vs True Rankings ({year})\")\n93:     plt.tight_layout()\n94:     plt.legend(loc=\"upper center\", bbox_to_anchor=(0.5, 1.10), ncol=2)\n95:     plt.savefig(f\"data/ranking_predictions_{year}.png\")"
        },
        "timestamp": "2025-08-16 23:14:27.000",
        "id": "M4uOI6CMyTbMEKrzZXEa"
    },
    {
        "source": "frontend",
        "event": "autotransit_section",
        "data": {
            "before_section_id": "8e22b665-a601-46c2-9ba5-ef874de1dde4",
            "after_section_id": "0d5dab9e-50f3-4ec3-9f83-c6f5eab5ae20"
        },
        "timestamp": "2025-08-16 23:14:27.000",
        "id": "w5LSg2kcAMWZoiKhfQub"
    },
    {
        "source": "frontend",
        "event": "create_new_section",
        "data": {
            "section_id": "0d5dab9e-50f3-4ec3-9f83-c6f5eab5ae20",
            "section_data": {
                "editPromptDetailLevel": null,
                "selectedStructured": "unstructured",
                "createdAt": 1755371667000,
                "lines": [
                    67,
                    95
                ],
                "editPromptStructured": null,
                "summaryData": {
                    "low_structured": "• Plots both predicted and true ranks for a given year\n• Saves the plot as an image file\n• The function visualizes both predicted and actual ranks in a grouped bar plot, instead of only predicted ranks; the function remains unchanged from the previous version.",
                    "high_unstructured": "The plot_ranking_predictions function generates a grouped bar plot to visualize both the predicted and true rank for each player in a specified year. It filters the DataFrame for the given year, sorts the data by predicted rank, and prepares the data so that both predicted and actual ranks are shown as separate bars for each player using Seaborn. The plot uses player names on the x-axis, rank values on the y-axis, and a hue to distinguish between predicted and true ranks, with a horizontal line at zero for reference. The plot is formatted for readability and saved as a PNG file named according to the year. (The function continues to plot both predicted and actual ranks, instead of only predicted ranks; the function remains unchanged from the previous version.)",
                    "medium_unstructured": "The plot_ranking_predictions function visualizes both the predicted and true ranks for each player in a specified year. It creates a grouped bar plot showing both predicted and actual rank values for each player and saves the resulting image to a file. The plot includes player names, predicted and true rank values, and a reference line at zero. (The function continues to focus on plotting both predicted and actual ranks, not just predicted ranks; the function remains unchanged from the previous version.)",
                    "high_structured": "• Filters the DataFrame to include only rows from the specified year and sorts them by predicted rank\n• Prepares a melted DataFrame to include both predicted and true ranks for grouped bar plotting\n• Sets up a matplotlib figure with a specific size\n• Creates a Seaborn grouped bar plot:\n  ◦ x-axis: Player names\n  ◦ y-axis: Rank values (both predicted and actual)\n  ◦ Hue: 'RankType' to distinguish between predicted and true ranks\n  ◦ Palette: 'coolwarm' for visual contrast\n• Adds a horizontal dashed line at y=0 to indicate a reference\n• Rotates x-axis labels for better readability\n• Sets axis labels and a descriptive plot title indicating the year, now reflecting both predicted and true rankings\n• Adjusts layout for clarity and saves the figure as 'data/ranking_predictions_{year}.png'\n• The function visualizes both predicted and actual ranks in a grouped bar plot, not just predicted ranks; the function remains unchanged from the previous version.",
                    "title": "Function: plot_ranking_predictions",
                    "low_unstructured": "This function plots and saves both the predicted and true ranks for players in a specified year, displaying both predicted and actual rank values in a grouped bar plot; the function remains unchanged from the previous version.",
                    "medium_structured": "• Filters data for the specified year and sorts by predicted rank\n• Creates a grouped bar plot of both predicted and true ranks for each player\n  ◦ Uses player names as labels and includes both predicted and actual ranks as hue\n• Adds a horizontal reference line and saves the plot as a PNG file\n• The function plots both predicted and actual ranks, rather than only predicted ranks; the function remains unchanged from the previous version."
                },
                "selectedDetailLevel": "medium",
                "oldSummaryData": {
                    "low_structured": "• Plots both predicted and true ranks for a given year\n• Saves the plot as an image file\n• The function visualizes both predicted and actual ranks in a grouped bar plot, instead of only predicted ranks; there are no changes from the previous version.",
                    "high_unstructured": "The plot_ranking_predictions function generates a grouped bar plot to visualize both the predicted and true rank for each player in a specified year. It filters the DataFrame for the given year, sorts the data by predicted rank, and prepares the data so that both predicted and actual ranks are shown as separate bars for each player using Seaborn. The plot uses player names on the x-axis, rank values on the y-axis, and a hue to distinguish between predicted and true ranks, with a horizontal line at zero for reference. The plot is formatted for readability and saved as a PNG file named according to the year. (The function continues to plot both predicted and actual ranks, instead of only predicted ranks; there are no changes from the previous version.)",
                    "medium_unstructured": "The plot_ranking_predictions function visualizes both the predicted and true ranks for each player in a specified year. It creates a grouped bar plot showing both predicted and actual rank values for each player and saves the resulting image to a file. The plot includes player names, predicted and true rank values, and a reference line at zero. (The function continues to focus on plotting both predicted and actual ranks, not just predicted ranks; there are no changes from the previous version.)",
                    "high_structured": "• Filters the DataFrame to include only rows from the specified year and sorts them by predicted rank\n• Prepares a melted DataFrame to include both predicted and true ranks for grouped bar plotting\n• Sets up a matplotlib figure with a specific size\n• Creates a Seaborn grouped bar plot:\n  ◦ x-axis: Player names\n  ◦ y-axis: Rank values (both predicted and actual)\n  ◦ Hue: 'RankType' to distinguish between predicted and true ranks\n  ◦ Palette: 'coolwarm' for visual contrast\n• Adds a horizontal dashed line at y=0 to indicate a reference\n• Rotates x-axis labels for better readability\n• Sets axis labels and a descriptive plot title indicating the year, now reflecting both predicted and true rankings\n• Adjusts layout for clarity and saves the figure as 'data/ranking_predictions_{year}.png'\n• The function visualizes both predicted and actual ranks in a grouped bar plot, not just predicted ranks; there are no changes from the previous version.",
                    "title": "Function: plot_ranking_predictions",
                    "low_unstructured": "This function plots and saves both the predicted and true ranks for players in a specified year, displaying both predicted and actual rank values in a grouped bar plot; there are no changes from the previous version.",
                    "medium_structured": "• Filters data for the specified year and sorts by predicted rank\n• Creates a grouped bar plot of both predicted and true ranks for each player\n  ◦ Uses player names as labels and includes both predicted and actual ranks as hue\n• Adds a horizontal reference line and saves the plot as a PNG file\n• The function plots both predicted and actual ranks, rather than only predicted ranks; there are no changes from the previous version."
                },
                "metadata": {
                    "originalCode": "def plot_ranking_predictions(df, year):\n    \"\"\"\n    Plot predicted and true ranks for a specific year.\n\n    Args:\n        df: DataFrame containing prediction results\n        year: Year to plot predicted and true ranks for\n    \"\"\"\n    year_df = df[df[\"Year\"] == year].copy()\n    year_df.sort_values(\"PredictedRank\", inplace=True)\n\n    # Prepare data for grouped barplot\n    plot_df = year_df[[\"Name\", \"PredictedRank\", \"Rank\"]].melt(\n        id_vars=\"Name\", value_vars=[\"PredictedRank\", \"Rank\"], \n        var_name=\"RankType\", value_name=\"RankValue\"\n    )\n\n    plt.figure(figsize=(12, 6))\n    sns.barplot(\n        x=\"Name\", y=\"RankValue\", hue=\"RankType\", data=plot_df, \n        palette=\"coolwarm\", dodge=True\n    )\n    plt.axhline(0, color=\"black\", linestyle=\"--\")\n    plt.xticks(rotation=45, ha=\"right\")\n    plt.ylabel(\"Rank\")\n    plt.title(f\"MVP Predicted vs True Rankings ({year})\")\n    plt.tight_layout()\n    plt.legend(loc=\"upper center\", bbox_to_anchor=(0.5, 1.10), ncol=2)\n    plt.savefig(f\"data/ranking_predictions_{year}.png\")",
                    "fullPath": "/project/workspace/rank_model.py",
                    "id": "0d5dab9e-50f3-4ec3-9f83-c6f5eab5ae20",
                    "offset": 1496,
                    "filename": "rank_model.py"
                },
                "editPromptValue": "",
                "title": "Function: plot_ranking_predictions",
                "summaryMappings": {
                    "high_unstructured": [
                        {
                            "summaryComponent": "The plot_ranking_predictions function generates a grouped bar plot",
                            "codeSegments": [
                                {
                                    "line": 67,
                                    "code": "def plot_ranking_predictions(df, year):"
                                },
                                {
                                    "line": 85,
                                    "code": "sns.barplot("
                                }
                            ]
                        },
                        {
                            "summaryComponent": "to visualize both the predicted and true rank for each player in a specified year",
                            "codeSegments": [
                                {
                                    "line": 75,
                                    "code": "year_df = df[df[\"Year\"] == year].copy()"
                                },
                                {
                                    "line": 79,
                                    "code": "plot_df = year_df[[\"Name\", \"PredictedRank\", \"Rank\"]].melt("
                                }
                            ]
                        },
                        {
                            "summaryComponent": "It filters the DataFrame for the given year",
                            "codeSegments": [
                                {
                                    "line": 75,
                                    "code": "year_df = df[df[\"Year\"] == year].copy()"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "sorts the data by predicted rank",
                            "codeSegments": [
                                {
                                    "line": 76,
                                    "code": "year_df.sort_values(\"PredictedRank\", inplace=True)"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "and prepares the data so that both predicted and actual ranks are shown as separate bars for each player using Seaborn",
                            "codeSegments": [
                                {
                                    "line": 79,
                                    "code": "plot_df = year_df[[\"Name\", \"PredictedRank\", \"Rank\"]].melt("
                                },
                                {
                                    "line": 85,
                                    "code": "sns.barplot("
                                }
                            ]
                        },
                        {
                            "summaryComponent": "The plot uses player names on the x-axis",
                            "codeSegments": [
                                {
                                    "line": 86,
                                    "code": "x=\"Name\""
                                }
                            ]
                        },
                        {
                            "summaryComponent": "rank values on the y-axis",
                            "codeSegments": [
                                {
                                    "line": 86,
                                    "code": "y=\"RankValue\""
                                }
                            ]
                        },
                        {
                            "summaryComponent": "and a hue to distinguish between predicted and true ranks",
                            "codeSegments": [
                                {
                                    "line": 86,
                                    "code": "hue=\"RankType\""
                                }
                            ]
                        },
                        {
                            "summaryComponent": "with a horizontal line at zero for reference",
                            "codeSegments": [
                                {
                                    "line": 89,
                                    "code": "plt.axhline(0, color=\"black\", linestyle=\"--\")"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "The plot is formatted for readability and saved as a PNG file named according to the year",
                            "codeSegments": [
                                {
                                    "line": 93,
                                    "code": "plt.tight_layout()"
                                },
                                {
                                    "line": 95,
                                    "code": "plt.savefig(f\"data/ranking_predictions_{year}.png\")"
                                }
                            ]
                        }
                    ],
                    "medium_unstructured": [
                        {
                            "summaryComponent": "The plot_ranking_predictions function",
                            "codeSegments": [
                                {
                                    "line": 67,
                                    "code": "def plot_ranking_predictions(df, year):"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "visualizes both the predicted and true ranks for each player in a specified year",
                            "codeSegments": [
                                {
                                    "line": 75,
                                    "code": "year_df = df[df[\"Year\"] == year].copy()"
                                },
                                {
                                    "line": 76,
                                    "code": "year_df.sort_values(\"PredictedRank\", inplace=True)"
                                },
                                {
                                    "line": 79,
                                    "code": "plot_df = year_df[[\"Name\", \"PredictedRank\", \"Rank\"]].melt("
                                },
                                {
                                    "line": 80,
                                    "code": "id_vars=\"Name\", value_vars=[\"PredictedRank\", \"Rank\"], "
                                }
                            ]
                        },
                        {
                            "summaryComponent": "It creates a grouped bar plot showing both predicted and actual rank values for each player",
                            "codeSegments": [
                                {
                                    "line": 85,
                                    "code": "sns.barplot("
                                },
                                {
                                    "line": 86,
                                    "code": "x=\"Name\", y=\"RankValue\", hue=\"RankType\", data=plot_df, "
                                }
                            ]
                        },
                        {
                            "summaryComponent": "and saves the resulting image to a file",
                            "codeSegments": [
                                {
                                    "line": 95,
                                    "code": "plt.savefig(f\"data/ranking_predictions_{year}.png\")"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "The plot includes player names, predicted and true rank values, and a reference line at zero",
                            "codeSegments": [
                                {
                                    "line": 86,
                                    "code": "x=\"Name\", y=\"RankValue\", hue=\"RankType\", data=plot_df, "
                                },
                                {
                                    "line": 89,
                                    "code": "plt.axhline(0, color=\"black\", linestyle=\"--\")"
                                }
                            ]
                        }
                    ],
                    "high_structured": [
                        {
                            "summaryComponent": "Filters the DataFrame to include only rows from the specified year and sorts them by predicted rank",
                            "codeSegments": [
                                {
                                    "line": 75,
                                    "code": "year_df = df[df[\"Year\"] == year].copy()"
                                },
                                {
                                    "line": 76,
                                    "code": "year_df.sort_values(\"PredictedRank\", inplace=True)"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "Prepares a melted DataFrame to include both predicted and true ranks for grouped bar plotting",
                            "codeSegments": [
                                {
                                    "line": 79,
                                    "code": "plot_df = year_df[[\"Name\", \"PredictedRank\", \"Rank\"]].melt("
                                },
                                {
                                    "line": 80,
                                    "code": "    id_vars=\"Name\", value_vars=[\"PredictedRank\", \"Rank\"], "
                                },
                                {
                                    "line": 81,
                                    "code": "    var_name=\"RankType\", value_name=\"RankValue\""
                                },
                                {
                                    "line": 82,
                                    "code": ")"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "Sets up a matplotlib figure with a specific size",
                            "codeSegments": [
                                {
                                    "line": 84,
                                    "code": "plt.figure(figsize=(12, 6))"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "Creates a Seaborn grouped bar plot:",
                            "codeSegments": [
                                {
                                    "line": 85,
                                    "code": "sns.barplot("
                                },
                                {
                                    "line": 86,
                                    "code": "    x=\"Name\", y=\"RankValue\", hue=\"RankType\", data=plot_df, "
                                },
                                {
                                    "line": 87,
                                    "code": "    palette=\"coolwarm\", dodge=True"
                                },
                                {
                                    "line": 88,
                                    "code": ")"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "x-axis: Player names",
                            "codeSegments": [
                                {
                                    "line": 86,
                                    "code": "x=\"Name\""
                                }
                            ]
                        },
                        {
                            "summaryComponent": "y-axis: Rank values (both predicted and actual)",
                            "codeSegments": [
                                {
                                    "line": 86,
                                    "code": "y=\"RankValue\""
                                }
                            ]
                        },
                        {
                            "summaryComponent": "Hue: 'RankType' to distinguish between predicted and true ranks",
                            "codeSegments": [
                                {
                                    "line": 86,
                                    "code": "hue=\"RankType\""
                                }
                            ]
                        },
                        {
                            "summaryComponent": "Palette: 'coolwarm' for visual contrast",
                            "codeSegments": [
                                {
                                    "line": 87,
                                    "code": "palette=\"coolwarm\""
                                }
                            ]
                        },
                        {
                            "summaryComponent": "Adds a horizontal dashed line at y=0 to indicate a reference",
                            "codeSegments": [
                                {
                                    "line": 89,
                                    "code": "plt.axhline(0, color=\"black\", linestyle=\"--\")"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "Rotates x-axis labels for better readability",
                            "codeSegments": [
                                {
                                    "line": 90,
                                    "code": "plt.xticks(rotation=45, ha=\"right\")"
                                }
                            ]
                        }
                    ],
                    "low_unstructured": [
                        {
                            "summaryComponent": "plots and saves both the predicted and true ranks",
                            "codeSegments": [
                                {
                                    "line": 95,
                                    "code": "plt.savefig(f\"data/ranking_predictions_{year}.png\")"
                                },
                                {
                                    "line": 85,
                                    "code": "sns.barplot("
                                },
                                {
                                    "line": 86,
                                    "code": "x=\"Name\", y=\"RankValue\", hue=\"RankType\", data=plot_df,"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "for players in a specified year",
                            "codeSegments": [
                                {
                                    "line": 75,
                                    "code": "year_df = df[df[\"Year\"] == year].copy()"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "displaying both predicted and actual rank values",
                            "codeSegments": [
                                {
                                    "line": 79,
                                    "code": "plot_df = year_df[[\"Name\", \"PredictedRank\", \"Rank\"]].melt("
                                },
                                {
                                    "line": 80,
                                    "code": "value_vars=[\"PredictedRank\", \"Rank\"],"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "in a grouped bar plot",
                            "codeSegments": [
                                {
                                    "line": 85,
                                    "code": "sns.barplot("
                                },
                                {
                                    "line": 87,
                                    "code": "dodge=True"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "the function remains unchanged from the previous version",
                            "codeSegments": []
                        }
                    ],
                    "low_structured": [
                        {
                            "summaryComponent": "Plots both predicted and true ranks for a given year",
                            "codeSegments": [
                                {
                                    "line": 67,
                                    "code": "def plot_ranking_predictions(df, year):"
                                },
                                {
                                    "line": 75,
                                    "code": "year_df = df[df[\"Year\"] == year].copy()"
                                },
                                {
                                    "line": 79,
                                    "code": "plot_df = year_df[[\"Name\", \"PredictedRank\", \"Rank\"]].melt("
                                },
                                {
                                    "line": 85,
                                    "code": "sns.barplot("
                                }
                            ]
                        },
                        {
                            "summaryComponent": "Saves the plot as an image file",
                            "codeSegments": [
                                {
                                    "line": 95,
                                    "code": "plt.savefig(f\"data/ranking_predictions_{year}.png\")"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "visualizes both predicted and actual ranks in a grouped bar plot",
                            "codeSegments": [
                                {
                                    "line": 79,
                                    "code": "plot_df = year_df[[\"Name\", \"PredictedRank\", \"Rank\"]].melt("
                                },
                                {
                                    "line": 85,
                                    "code": "sns.barplot("
                                }
                            ]
                        },
                        {
                            "summaryComponent": "instead of only predicted ranks",
                            "codeSegments": [
                                {
                                    "line": 79,
                                    "code": "plot_df = year_df[[\"Name\", \"PredictedRank\", \"Rank\"]].melt("
                                }
                            ]
                        },
                        {
                            "summaryComponent": "the function remains unchanged from the previous version.",
                            "codeSegments": [
                                {
                                    "line": 67,
                                    "code": "def plot_ranking_predictions(df, year):"
                                }
                            ]
                        }
                    ],
                    "medium_structured": [
                        {
                            "summaryComponent": "Filters data for the specified year and sorts by predicted rank",
                            "codeSegments": [
                                {
                                    "line": 75,
                                    "code": "year_df = df[df[\"Year\"] == year].copy()"
                                },
                                {
                                    "line": 76,
                                    "code": "year_df.sort_values(\"PredictedRank\", inplace=True)"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "Creates a grouped bar plot of both predicted and true ranks for each player",
                            "codeSegments": [
                                {
                                    "line": 79,
                                    "code": "plot_df = year_df[[\"Name\", \"PredictedRank\", \"Rank\"]].melt("
                                },
                                {
                                    "line": 85,
                                    "code": "sns.barplot("
                                }
                            ]
                        },
                        {
                            "summaryComponent": "Uses player names as labels and includes both predicted and actual ranks as hue",
                            "codeSegments": [
                                {
                                    "line": 86,
                                    "code": "x=\"Name\", y=\"RankValue\", hue=\"RankType\", data=plot_df,"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "Adds a horizontal reference line and saves the plot as a PNG file",
                            "codeSegments": [
                                {
                                    "line": 89,
                                    "code": "plt.axhline(0, color=\"black\", linestyle=\"--\")"
                                },
                                {
                                    "line": 95,
                                    "code": "plt.savefig(f\"data/ranking_predictions_{year}.png\")"
                                }
                            ]
                        },
                        {
                            "summaryComponent": "The function plots both predicted and actual ranks, rather than only predicted ranks; the function remains unchanged from the previous version.",
                            "codeSegments": [
                                {
                                    "line": 79,
                                    "code": "plot_df = year_df[[\"Name\", \"PredictedRank\", \"Rank\"]].melt("
                                },
                                {
                                    "line": 85,
                                    "code": "sns.barplot("
                                }
                            ]
                        }
                    ]
                }
            }
        },
        "timestamp": "2025-08-16 23:14:27.000",
        "id": "zpbS1UBnL9GwmUEVyVHH"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "0d5dab9e-50f3-4ec3-9f83-c6f5eab5ae20",
            "detail_level": "medium",
            "structured_type": "unstructured"
        },
        "timestamp": "2025-08-16 23:14:30.000",
        "id": "3M6usChvy2u3hafJU3hQ"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "0d5dab9e-50f3-4ec3-9f83-c6f5eab5ae20",
            "detail_level": "medium",
            "structured_type": "unstructured"
        },
        "timestamp": "2025-08-16 23:14:30.000",
        "id": "B8fTlDawCCbDGs3w0Spp"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "0d5dab9e-50f3-4ec3-9f83-c6f5eab5ae20",
            "mapping_index": 4,
            "structured_type": "unstructured",
            "detail_level": "medium"
        },
        "timestamp": "2025-08-16 23:14:30.000",
        "id": "I86TE6jn1Mky6pPP2qDa"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "0d5dab9e-50f3-4ec3-9f83-c6f5eab5ae20",
            "detail_level": "medium",
            "structured_type": "unstructured"
        },
        "timestamp": "2025-08-16 23:14:30.000",
        "id": "LQQvTjoKKO0nMv2UBCYy"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "0d5dab9e-50f3-4ec3-9f83-c6f5eab5ae20",
            "mapping_index": 1,
            "structured_type": "unstructured",
            "detail_level": "medium"
        },
        "timestamp": "2025-08-16 23:14:30.000",
        "id": "c2VaG3Sloc0vIOm5TUdz"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "0d5dab9e-50f3-4ec3-9f83-c6f5eab5ae20",
            "mapping_index": 1,
            "structured_type": "unstructured",
            "detail_level": "medium"
        },
        "timestamp": "2025-08-16 23:14:30.000",
        "id": "dW6kufFS5sP2RU8GuOZt"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "0d5dab9e-50f3-4ec3-9f83-c6f5eab5ae20",
            "detail_level": "medium",
            "structured_type": "unstructured"
        },
        "timestamp": "2025-08-16 23:14:30.000",
        "id": "hGzWdI6PMkqFNn1gmCXR"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "0d5dab9e-50f3-4ec3-9f83-c6f5eab5ae20",
            "detail_level": "medium",
            "structured_type": "unstructured"
        },
        "timestamp": "2025-08-16 23:14:30.000",
        "id": "iTvnOzjQBBfRSsZUepWh"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "0d5dab9e-50f3-4ec3-9f83-c6f5eab5ae20",
            "mapping_index": 3,
            "structured_type": "unstructured",
            "detail_level": "medium"
        },
        "timestamp": "2025-08-16 23:14:30.000",
        "id": "m2XS7yKg3R1i7cixy0IM"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "0d5dab9e-50f3-4ec3-9f83-c6f5eab5ae20",
            "mapping_index": 3,
            "structured_type": "unstructured",
            "detail_level": "medium"
        },
        "timestamp": "2025-08-16 23:14:30.000",
        "id": "oxtL04u6yP4ZxAPUn0lg"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "0d5dab9e-50f3-4ec3-9f83-c6f5eab5ae20",
            "detail_level": "medium",
            "structured_type": "unstructured"
        },
        "timestamp": "2025-08-16 23:14:31.000",
        "id": "5b4KjVFYadHfNTUIv2nT"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "0d5dab9e-50f3-4ec3-9f83-c6f5eab5ae20",
            "detail_level": "medium",
            "structured_type": "unstructured"
        },
        "timestamp": "2025-08-16 23:14:31.000",
        "id": "LvcVLpMCFdIOe5CoizXe"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "0d5dab9e-50f3-4ec3-9f83-c6f5eab5ae20",
            "mapping_index": 2,
            "structured_type": "unstructured",
            "detail_level": "medium"
        },
        "timestamp": "2025-08-16 23:14:31.000",
        "id": "NsTqvcz1GiX3rWOcO4Vn"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "0d5dab9e-50f3-4ec3-9f83-c6f5eab5ae20",
            "detail_level": "medium",
            "structured_type": "unstructured"
        },
        "timestamp": "2025-08-16 23:14:31.000",
        "id": "Zg3tQNud73belsKXHDxa"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "0d5dab9e-50f3-4ec3-9f83-c6f5eab5ae20",
            "mapping_index": 0,
            "structured_type": "unstructured",
            "detail_level": "medium"
        },
        "timestamp": "2025-08-16 23:14:31.000",
        "id": "aZkRo3G0EF2qH3NezoOT"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "0d5dab9e-50f3-4ec3-9f83-c6f5eab5ae20",
            "mapping_index": 4,
            "structured_type": "unstructured",
            "detail_level": "medium"
        },
        "timestamp": "2025-08-16 23:14:31.000",
        "id": "tpcrC8xJXcVdJQK52jxl"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "0d5dab9e-50f3-4ec3-9f83-c6f5eab5ae20",
            "mapping_index": 2,
            "structured_type": "unstructured",
            "detail_level": "medium"
        },
        "timestamp": "2025-08-16 23:14:57.000",
        "id": "49pMLaBQHbppJCPJZiwY"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "0d5dab9e-50f3-4ec3-9f83-c6f5eab5ae20",
            "detail_level": "medium",
            "structured_type": "unstructured"
        },
        "timestamp": "2025-08-16 23:14:57.000",
        "id": "8RagipzcAEQS62ZAXM96"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "0d5dab9e-50f3-4ec3-9f83-c6f5eab5ae20",
            "detail_level": "medium",
            "structured_type": "unstructured"
        },
        "timestamp": "2025-08-16 23:14:57.000",
        "id": "A0IDHSNoxgK6ETwLaGqw"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "0d5dab9e-50f3-4ec3-9f83-c6f5eab5ae20",
            "detail_level": "medium",
            "structured_type": "unstructured"
        },
        "timestamp": "2025-08-16 23:14:57.000",
        "id": "DykMiqEHHCI5ETpxyuC0"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "0d5dab9e-50f3-4ec3-9f83-c6f5eab5ae20",
            "mapping_index": 1,
            "structured_type": "unstructured",
            "detail_level": "medium"
        },
        "timestamp": "2025-08-16 23:14:57.000",
        "id": "GufYLz0BzKmDxl2naiGQ"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "0d5dab9e-50f3-4ec3-9f83-c6f5eab5ae20",
            "mapping_index": 0,
            "structured_type": "unstructured",
            "detail_level": "medium"
        },
        "timestamp": "2025-08-16 23:14:57.000",
        "id": "NeCBspEyMCkO7iIBE7il"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "data": {
            "section_id": "0d5dab9e-50f3-4ec3-9f83-c6f5eab5ae20",
            "detail_level": "medium",
            "structured_type": "unstructured"
        },
        "timestamp": "2025-08-16 23:14:57.000",
        "id": "q8N4OXP5vKNYsIv7cp7a"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "data": {
            "section_id": "0d5dab9e-50f3-4ec3-9f83-c6f5eab5ae20",
            "mapping_index": 4,
            "structured_type": "unstructured",
            "detail_level": "medium"
        },
        "timestamp": "2025-08-16 23:14:57.000",
        "id": "tQW2Dujy6RU7KyMb3RcW"
    }
]