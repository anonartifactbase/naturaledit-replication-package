[
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:02:59.000",
        "data": {},
        "event": "click_summarize_code",
        "id": "rHUesYpm5xJENVWStd4f"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:03:00.000",
        "data": {
            "detail_level": "high",
            "section_id": "6e94bc2f-f907-4080-842c-5a2eda4c273e",
            "structured_type": "structured",
            "mapping_index": 8
        },
        "event": "mapping_hover",
        "id": "3IqfufCIprOkhe2vIbVD"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:03:06.000",
        "data": {
            "detail_level": "high",
            "section_id": "6e94bc2f-f907-4080-842c-5a2eda4c273e",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "Mw8mP8Cei5x6k6geZMKv"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:03:06.000",
        "data": {
            "detail_level": "high",
            "section_id": "6e94bc2f-f907-4080-842c-5a2eda4c273e",
            "structured_type": "structured",
            "mapping_index": 7
        },
        "event": "mapping_hover",
        "id": "tfKtYPEskSpYd3IxWd9h"
    },
    {
        "source": "backend",
        "timestamp": "2025-08-23 14:03:06.000",
        "data": {
            "summary": {
                "high_unstructured": "This code provides functions to scrape NBA MVP voting results and player per-game statistics from Basketball Reference for seasons between 2018 and 2025. The scrape_mvp_votes function collects MVP vote data, renames columns, and returns a DataFrame with year, player name, and MVP points. The scrape_season_stats function retrieves per-game stats (points, assists, rebounds, field goal percentage) for each player, cleaning the data by removing invalid rows and ensuring completeness. The main block creates a data directory if needed, runs both scrapers, and saves the results as separate CSV files.",
                "low_structured": "• Scrapes MVP votes and player stats from Basketball Reference\n• Processes data for multiple seasons\n• Saves results to CSV files",
                "high_structured": "• Implements two main scraping functions:\n  ◦ scrape_mvp_votes: Collects MVP voting data for each year, renames columns, and aggregates results\n  ◦ scrape_season_stats: Retrieves per-game stats (PTS, AST, TRB, FG%) for all players in a season, cleans and filters data\n• scrape_multiple_seasons aggregates season stats across multiple years\n• Main execution block:\n  ◦ Checks for and creates a 'data' directory if missing\n  ◦ Runs the MVP votes and player stats scrapers\n  ◦ Saves the scraped data to 'data/mvp_votes.csv' and 'data/season_stats.csv'\n• Handles errors gracefully during scraping (e.g., missing years)\n• Uses pandas for data extraction, manipulation, and saving",
                "title": "Summary of Basketball Reference Scraper Code",
                "medium_unstructured": "The script defines functions to scrape NBA MVP voting results and player per-game statistics from Basketball Reference for a range of years. It processes and combines the data, then saves the results as CSV files in a local directory. The code also ensures the output directory exists before saving.",
                "medium_structured": "• Defines functions to scrape MVP votes and player stats from Basketball Reference\n• Processes data for each year in a specified range\n• Ensures a 'data' directory exists before saving\n• Saves MVP and player statistics as CSV files",
                "low_unstructured": "This code scrapes NBA MVP votes and player statistics from Basketball Reference for multiple seasons and saves the data as CSV files."
            },
            "selected_code": "import pandas as pd\nimport os\n\n\ndef scrape_mvp_votes(start_year=2018, end_year=2025):\n    all_votes = []\n    for year in range(start_year, end_year + 1):\n        url = f\"https://www.basketball-reference.com/awards/awards_{year}.html\"\n        tables = pd.read_html(url, header=1)\n        try:\n            mvp_table = tables[0]  # MVP table is the first table\n            mvp_table[\"Year\"] = year\n            all_votes.append(mvp_table)\n        except:\n            print(f\"Could not parse year {year}\")\n\n    df = pd.concat(all_votes)\n    df = df.rename(columns={\"Player\": \"Name\", \"Pts Won\": \"MVP_Points\"})\n    return df[[\"Year\", \"Name\", \"MVP_Points\"]]\n\n\ndef scrape_season_stats(year):\n    base_url_reg = (\n        f\"https://www.basketball-reference.com/leagues/NBA_{year}_per_game.html\"\n    )\n    df_reg = pd.read_html(base_url_reg, header=0)[0]\n    df_reg = df_reg[df_reg[\"Player\"] != \"Player\"]  # remove repeated header rows\n    df_reg[\"Year\"] = year\n\n    df_reg = df_reg[\n        [\"Player\", \"Year\", \"PTS\", \"AST\", \"TRB\", \"FG%\"]\n    ]  # Keep only specified columns\n    df_reg = df_reg.dropna(\n        subset=[\"PTS\", \"AST\", \"TRB\", \"FG%\"]\n    )  # Ensure key stats aren't invalid\n    return df_reg\n\n\ndef scrape_multiple_seasons(start_year=2018, end_year=2025):\n    all_stats = []\n    for year in range(start_year, end_year + 1):\n        df = scrape_season_stats(year)\n        all_stats.append(df)\n    return pd.concat(all_stats)\n\n\nif __name__ == \"__main__\":\n    if not os.path.exists(\"data\"):\n        os.makedirs(\"data\")\n\n    print(\"Scraping MVP votes...\")\n    mvp_df = scrape_mvp_votes()\n    mvp_df.to_csv(\"data/mvp_votes.csv\", index=False)\n\n    print(\"Scraping player stats...\")\n    stats_df = scrape_multiple_seasons()\n    stats_df.to_csv(\"data/season_stats.csv\", index=False)\n"
        },
        "event": "summarize_selected_code",
        "id": "vlU3VEOdzBIoENiklNOX"
    },
    {
        "source": "backend",
        "timestamp": "2025-08-23 14:03:08.000",
        "data": {
            "summary": "This code scrapes NBA MVP votes and player statistics from Basketball Reference for multiple seasons and saves the data as CSV files.",
            "code": "1: import pandas as pd\n2: import os\n3: \n4: \n5: def scrape_mvp_votes(start_year=2018, end_year=2025):\n6:     all_votes = []\n7:     for year in range(start_year, end_year + 1):\n8:         url = f\"https://www.basketball-reference.com/awards/awards_{year}.html\"\n9:         tables = pd.read_html(url, header=1)\n10:         try:\n11:             mvp_table = tables[0]  # MVP table is the first table\n12:             mvp_table[\"Year\"] = year\n13:             all_votes.append(mvp_table)\n14:         except:\n15:             print(f\"Could not parse year {year}\")\n16: \n17:     df = pd.concat(all_votes)\n18:     df = df.rename(columns={\"Player\": \"Name\", \"Pts Won\": \"MVP_Points\"})\n19:     return df[[\"Year\", \"Name\", \"MVP_Points\"]]\n20: \n21: \n22: def scrape_season_stats(year):\n23:     base_url_reg = (\n24:         f\"https://www.basketball-reference.com/leagues/NBA_{year}_per_game.html\"\n25:     )\n26:     df_reg = pd.read_html(base_url_reg, header=0)[0]\n27:     df_reg = df_reg[df_reg[\"Player\"] != \"Player\"]  # remove repeated header rows\n28:     df_reg[\"Year\"] = year\n29: \n30:     df_reg = df_reg[\n31:         [\"Player\", \"Year\", \"PTS\", \"AST\", \"TRB\", \"FG%\"]\n32:     ]  # Keep only specified columns\n33:     df_reg = df_reg.dropna(\n34:         subset=[\"PTS\", \"AST\", \"TRB\", \"FG%\"]\n35:     )  # Ensure key stats aren't invalid\n36:     return df_reg\n37: \n38: \n39: def scrape_multiple_seasons(start_year=2018, end_year=2025):\n40:     all_stats = []\n41:     for year in range(start_year, end_year + 1):\n42:         df = scrape_season_stats(year)\n43:         all_stats.append(df)\n44:     return pd.concat(all_stats)\n45: \n46: \n47: if __name__ == \"__main__\":\n48:     if not os.path.exists(\"data\"):\n49:         os.makedirs(\"data\")\n50: \n51:     print(\"Scraping MVP votes...\")\n52:     mvp_df = scrape_mvp_votes()\n53:     mvp_df.to_csv(\"data/mvp_votes.csv\", index=False)\n54: \n55:     print(\"Scraping player stats...\")\n56:     stats_df = scrape_multiple_seasons()\n57:     stats_df.to_csv(\"data/season_stats.csv\", index=False)\n58: ",
            "mapping": [
                {
                    "codeSegments": [
                        {
                            "line": 5,
                            "code": "def scrape_mvp_votes(start_year=2018, end_year=2025):"
                        },
                        {
                            "line": 52,
                            "code": "mvp_df = scrape_mvp_votes()"
                        }
                    ],
                    "summaryComponent": "scrapes NBA MVP votes"
                },
                {
                    "codeSegments": [
                        {
                            "line": 22,
                            "code": "def scrape_season_stats(year):"
                        },
                        {
                            "line": 39,
                            "code": "def scrape_multiple_seasons(start_year=2018, end_year=2025):"
                        },
                        {
                            "line": 56,
                            "code": "stats_df = scrape_multiple_seasons()"
                        }
                    ],
                    "summaryComponent": "and player statistics"
                },
                {
                    "codeSegments": [
                        {
                            "line": 8,
                            "code": "url = f\"https://www.basketball-reference.com/awards/awards_{year}.html\""
                        },
                        {
                            "line": 23,
                            "code": "base_url_reg = ("
                        },
                        {
                            "line": 24,
                            "code": "f\"https://www.basketball-reference.com/leagues/NBA_{year}_per_game.html\""
                        }
                    ],
                    "summaryComponent": "from Basketball Reference"
                },
                {
                    "codeSegments": [
                        {
                            "line": 7,
                            "code": "for year in range(start_year, end_year + 1):"
                        },
                        {
                            "line": 41,
                            "code": "for year in range(start_year, end_year + 1):"
                        }
                    ],
                    "summaryComponent": "for multiple seasons"
                },
                {
                    "codeSegments": [
                        {
                            "line": 53,
                            "code": "mvp_df.to_csv(\"data/mvp_votes.csv\", index=False)"
                        },
                        {
                            "line": 57,
                            "code": "stats_df.to_csv(\"data/season_stats.csv\", index=False)"
                        }
                    ],
                    "summaryComponent": "and saves the data as CSV files"
                }
            ]
        },
        "event": "map_summary_code",
        "id": "1gZ1wywbVjSVVAEa8aGX"
    },
    {
        "source": "backend",
        "timestamp": "2025-08-23 14:03:08.000",
        "data": {
            "summary": "• Defines functions to scrape MVP votes and player stats from Basketball Reference\n• Processes data for each year in a specified range\n• Ensures a 'data' directory exists before saving\n• Saves MVP and player statistics as CSV files",
            "code": "1: import pandas as pd\n2: import os\n3: \n4: \n5: def scrape_mvp_votes(start_year=2018, end_year=2025):\n6:     all_votes = []\n7:     for year in range(start_year, end_year + 1):\n8:         url = f\"https://www.basketball-reference.com/awards/awards_{year}.html\"\n9:         tables = pd.read_html(url, header=1)\n10:         try:\n11:             mvp_table = tables[0]  # MVP table is the first table\n12:             mvp_table[\"Year\"] = year\n13:             all_votes.append(mvp_table)\n14:         except:\n15:             print(f\"Could not parse year {year}\")\n16: \n17:     df = pd.concat(all_votes)\n18:     df = df.rename(columns={\"Player\": \"Name\", \"Pts Won\": \"MVP_Points\"})\n19:     return df[[\"Year\", \"Name\", \"MVP_Points\"]]\n20: \n21: \n22: def scrape_season_stats(year):\n23:     base_url_reg = (\n24:         f\"https://www.basketball-reference.com/leagues/NBA_{year}_per_game.html\"\n25:     )\n26:     df_reg = pd.read_html(base_url_reg, header=0)[0]\n27:     df_reg = df_reg[df_reg[\"Player\"] != \"Player\"]  # remove repeated header rows\n28:     df_reg[\"Year\"] = year\n29: \n30:     df_reg = df_reg[\n31:         [\"Player\", \"Year\", \"PTS\", \"AST\", \"TRB\", \"FG%\"]\n32:     ]  # Keep only specified columns\n33:     df_reg = df_reg.dropna(\n34:         subset=[\"PTS\", \"AST\", \"TRB\", \"FG%\"]\n35:     )  # Ensure key stats aren't invalid\n36:     return df_reg\n37: \n38: \n39: def scrape_multiple_seasons(start_year=2018, end_year=2025):\n40:     all_stats = []\n41:     for year in range(start_year, end_year + 1):\n42:         df = scrape_season_stats(year)\n43:         all_stats.append(df)\n44:     return pd.concat(all_stats)\n45: \n46: \n47: if __name__ == \"__main__\":\n48:     if not os.path.exists(\"data\"):\n49:         os.makedirs(\"data\")\n50: \n51:     print(\"Scraping MVP votes...\")\n52:     mvp_df = scrape_mvp_votes()\n53:     mvp_df.to_csv(\"data/mvp_votes.csv\", index=False)\n54: \n55:     print(\"Scraping player stats...\")\n56:     stats_df = scrape_multiple_seasons()\n57:     stats_df.to_csv(\"data/season_stats.csv\", index=False)\n58: ",
            "mapping": [
                {
                    "codeSegments": [
                        {
                            "line": 5,
                            "code": "def scrape_mvp_votes(start_year=2018, end_year=2025):"
                        },
                        {
                            "line": 22,
                            "code": "def scrape_season_stats(year):"
                        },
                        {
                            "line": 39,
                            "code": "def scrape_multiple_seasons(start_year=2018, end_year=2025):"
                        }
                    ],
                    "summaryComponent": "Defines functions to scrape MVP votes and player stats from Basketball Reference"
                },
                {
                    "codeSegments": [
                        {
                            "line": 7,
                            "code": "for year in range(start_year, end_year + 1):"
                        },
                        {
                            "line": 41,
                            "code": "for year in range(start_year, end_year + 1):"
                        }
                    ],
                    "summaryComponent": "Processes data for each year in a specified range"
                },
                {
                    "codeSegments": [
                        {
                            "line": 48,
                            "code": "if not os.path.exists(\"data\"):"
                        },
                        {
                            "line": 49,
                            "code": "os.makedirs(\"data\")"
                        }
                    ],
                    "summaryComponent": "Ensures a 'data' directory exists before saving"
                },
                {
                    "codeSegments": [
                        {
                            "line": 53,
                            "code": "mvp_df.to_csv(\"data/mvp_votes.csv\", index=False)"
                        },
                        {
                            "line": 57,
                            "code": "stats_df.to_csv(\"data/season_stats.csv\", index=False)"
                        }
                    ],
                    "summaryComponent": "Saves MVP and player statistics as CSV files"
                }
            ]
        },
        "event": "map_summary_code",
        "id": "4VWsnjQgZHOSXtPEUFJh"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:03:08.000",
        "data": {
            "detail_level": "high",
            "section_id": "6e94bc2f-f907-4080-842c-5a2eda4c273e",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "BdyH8Cd8YbFMOnGZ9FzN"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:03:08.000",
        "data": {
            "detail_level": "high",
            "section_id": "6e94bc2f-f907-4080-842c-5a2eda4c273e",
            "structured_type": "structured",
            "mapping_index": 6
        },
        "event": "mapping_hover",
        "id": "jbIq2Tm0dTDoZiiletUZ"
    },
    {
        "source": "backend",
        "timestamp": "2025-08-23 14:03:09.000",
        "data": {
            "summary": "• Scrapes MVP votes and player stats from Basketball Reference\n• Processes data for multiple seasons\n• Saves results to CSV files",
            "code": "1: import pandas as pd\n2: import os\n3: \n4: \n5: def scrape_mvp_votes(start_year=2018, end_year=2025):\n6:     all_votes = []\n7:     for year in range(start_year, end_year + 1):\n8:         url = f\"https://www.basketball-reference.com/awards/awards_{year}.html\"\n9:         tables = pd.read_html(url, header=1)\n10:         try:\n11:             mvp_table = tables[0]  # MVP table is the first table\n12:             mvp_table[\"Year\"] = year\n13:             all_votes.append(mvp_table)\n14:         except:\n15:             print(f\"Could not parse year {year}\")\n16: \n17:     df = pd.concat(all_votes)\n18:     df = df.rename(columns={\"Player\": \"Name\", \"Pts Won\": \"MVP_Points\"})\n19:     return df[[\"Year\", \"Name\", \"MVP_Points\"]]\n20: \n21: \n22: def scrape_season_stats(year):\n23:     base_url_reg = (\n24:         f\"https://www.basketball-reference.com/leagues/NBA_{year}_per_game.html\"\n25:     )\n26:     df_reg = pd.read_html(base_url_reg, header=0)[0]\n27:     df_reg = df_reg[df_reg[\"Player\"] != \"Player\"]  # remove repeated header rows\n28:     df_reg[\"Year\"] = year\n29: \n30:     df_reg = df_reg[\n31:         [\"Player\", \"Year\", \"PTS\", \"AST\", \"TRB\", \"FG%\"]\n32:     ]  # Keep only specified columns\n33:     df_reg = df_reg.dropna(\n34:         subset=[\"PTS\", \"AST\", \"TRB\", \"FG%\"]\n35:     )  # Ensure key stats aren't invalid\n36:     return df_reg\n37: \n38: \n39: def scrape_multiple_seasons(start_year=2018, end_year=2025):\n40:     all_stats = []\n41:     for year in range(start_year, end_year + 1):\n42:         df = scrape_season_stats(year)\n43:         all_stats.append(df)\n44:     return pd.concat(all_stats)\n45: \n46: \n47: if __name__ == \"__main__\":\n48:     if not os.path.exists(\"data\"):\n49:         os.makedirs(\"data\")\n50: \n51:     print(\"Scraping MVP votes...\")\n52:     mvp_df = scrape_mvp_votes()\n53:     mvp_df.to_csv(\"data/mvp_votes.csv\", index=False)\n54: \n55:     print(\"Scraping player stats...\")\n56:     stats_df = scrape_multiple_seasons()\n57:     stats_df.to_csv(\"data/season_stats.csv\", index=False)\n58: ",
            "mapping": [
                {
                    "codeSegments": [
                        {
                            "line": 5,
                            "code": "def scrape_mvp_votes(start_year=2018, end_year=2025):"
                        },
                        {
                            "line": 52,
                            "code": "mvp_df = scrape_mvp_votes()"
                        }
                    ],
                    "summaryComponent": "Scrapes MVP votes"
                },
                {
                    "codeSegments": [
                        {
                            "line": 22,
                            "code": "def scrape_season_stats(year):"
                        },
                        {
                            "line": 39,
                            "code": "def scrape_multiple_seasons(start_year=2018, end_year=2025):"
                        },
                        {
                            "line": 56,
                            "code": "stats_df = scrape_multiple_seasons()"
                        }
                    ],
                    "summaryComponent": "and player stats"
                },
                {
                    "codeSegments": [
                        {
                            "line": 8,
                            "code": "url = f\"https://www.basketball-reference.com/awards/awards_{year}.html\""
                        },
                        {
                            "line": 23,
                            "code": "base_url_reg = ("
                        },
                        {
                            "line": 24,
                            "code": "f\"https://www.basketball-reference.com/leagues/NBA_{year}_per_game.html\""
                        }
                    ],
                    "summaryComponent": "from Basketball Reference"
                },
                {
                    "codeSegments": [
                        {
                            "line": 7,
                            "code": "for year in range(start_year, end_year + 1):"
                        },
                        {
                            "line": 41,
                            "code": "for year in range(start_year, end_year + 1):"
                        }
                    ],
                    "summaryComponent": "Processes data for multiple seasons"
                },
                {
                    "codeSegments": [
                        {
                            "line": 53,
                            "code": "mvp_df.to_csv(\"data/mvp_votes.csv\", index=False)"
                        },
                        {
                            "line": 57,
                            "code": "stats_df.to_csv(\"data/season_stats.csv\", index=False)"
                        }
                    ],
                    "summaryComponent": "Saves results to CSV files"
                }
            ]
        },
        "event": "map_summary_code",
        "id": "6pvscIhfXNJWAgMH35Fd"
    },
    {
        "source": "backend",
        "timestamp": "2025-08-23 14:03:10.000",
        "data": {
            "summary": "The script defines functions to scrape NBA MVP voting results and player per-game statistics from Basketball Reference for a range of years. It processes and combines the data, then saves the results as CSV files in a local directory. The code also ensures the output directory exists before saving.",
            "code": "1: import pandas as pd\n2: import os\n3: \n4: \n5: def scrape_mvp_votes(start_year=2018, end_year=2025):\n6:     all_votes = []\n7:     for year in range(start_year, end_year + 1):\n8:         url = f\"https://www.basketball-reference.com/awards/awards_{year}.html\"\n9:         tables = pd.read_html(url, header=1)\n10:         try:\n11:             mvp_table = tables[0]  # MVP table is the first table\n12:             mvp_table[\"Year\"] = year\n13:             all_votes.append(mvp_table)\n14:         except:\n15:             print(f\"Could not parse year {year}\")\n16: \n17:     df = pd.concat(all_votes)\n18:     df = df.rename(columns={\"Player\": \"Name\", \"Pts Won\": \"MVP_Points\"})\n19:     return df[[\"Year\", \"Name\", \"MVP_Points\"]]\n20: \n21: \n22: def scrape_season_stats(year):\n23:     base_url_reg = (\n24:         f\"https://www.basketball-reference.com/leagues/NBA_{year}_per_game.html\"\n25:     )\n26:     df_reg = pd.read_html(base_url_reg, header=0)[0]\n27:     df_reg = df_reg[df_reg[\"Player\"] != \"Player\"]  # remove repeated header rows\n28:     df_reg[\"Year\"] = year\n29: \n30:     df_reg = df_reg[\n31:         [\"Player\", \"Year\", \"PTS\", \"AST\", \"TRB\", \"FG%\"]\n32:     ]  # Keep only specified columns\n33:     df_reg = df_reg.dropna(\n34:         subset=[\"PTS\", \"AST\", \"TRB\", \"FG%\"]\n35:     )  # Ensure key stats aren't invalid\n36:     return df_reg\n37: \n38: \n39: def scrape_multiple_seasons(start_year=2018, end_year=2025):\n40:     all_stats = []\n41:     for year in range(start_year, end_year + 1):\n42:         df = scrape_season_stats(year)\n43:         all_stats.append(df)\n44:     return pd.concat(all_stats)\n45: \n46: \n47: if __name__ == \"__main__\":\n48:     if not os.path.exists(\"data\"):\n49:         os.makedirs(\"data\")\n50: \n51:     print(\"Scraping MVP votes...\")\n52:     mvp_df = scrape_mvp_votes()\n53:     mvp_df.to_csv(\"data/mvp_votes.csv\", index=False)\n54: \n55:     print(\"Scraping player stats...\")\n56:     stats_df = scrape_multiple_seasons()\n57:     stats_df.to_csv(\"data/season_stats.csv\", index=False)\n58: ",
            "mapping": [
                {
                    "codeSegments": [
                        {
                            "line": 5,
                            "code": "def scrape_mvp_votes(start_year=2018, end_year=2025):"
                        }
                    ],
                    "summaryComponent": "defines functions to scrape NBA MVP voting results"
                },
                {
                    "codeSegments": [
                        {
                            "line": 22,
                            "code": "def scrape_season_stats(year):"
                        },
                        {
                            "line": 39,
                            "code": "def scrape_multiple_seasons(start_year=2018, end_year=2025):"
                        }
                    ],
                    "summaryComponent": "and player per-game statistics"
                },
                {
                    "codeSegments": [
                        {
                            "line": 8,
                            "code": "url = f\"https://www.basketball-reference.com/awards/awards_{year}.html\""
                        },
                        {
                            "line": 23,
                            "code": "base_url_reg = ("
                        },
                        {
                            "line": 24,
                            "code": "f\"https://www.basketball-reference.com/leagues/NBA_{year}_per_game.html\""
                        },
                        {
                            "line": 7,
                            "code": "for year in range(start_year, end_year + 1):"
                        },
                        {
                            "line": 41,
                            "code": "for year in range(start_year, end_year + 1):"
                        }
                    ],
                    "summaryComponent": "from Basketball Reference for a range of years"
                },
                {
                    "codeSegments": [
                        {
                            "line": 17,
                            "code": "df = pd.concat(all_votes)"
                        },
                        {
                            "line": 18,
                            "code": "df = df.rename(columns={\"Player\": \"Name\", \"Pts Won\": \"MVP_Points\"})"
                        },
                        {
                            "line": 27,
                            "code": "df_reg = df_reg[df_reg[\"Player\"] != \"Player\"]  # remove repeated header rows"
                        },
                        {
                            "line": 33,
                            "code": "df_reg = df_reg.dropna("
                        },
                        {
                            "line": 44,
                            "code": "return pd.concat(all_stats)"
                        }
                    ],
                    "summaryComponent": "It processes and combines the data"
                },
                {
                    "codeSegments": [
                        {
                            "line": 53,
                            "code": "mvp_df.to_csv(\"data/mvp_votes.csv\", index=False)"
                        },
                        {
                            "line": 57,
                            "code": "stats_df.to_csv(\"data/season_stats.csv\", index=False)"
                        }
                    ],
                    "summaryComponent": "then saves the results as CSV files"
                },
                {
                    "codeSegments": [
                        {
                            "line": 53,
                            "code": "\"data/mvp_votes.csv\""
                        },
                        {
                            "line": 57,
                            "code": "\"data/season_stats.csv\""
                        }
                    ],
                    "summaryComponent": "in a local directory"
                },
                {
                    "codeSegments": [
                        {
                            "line": 48,
                            "code": "if not os.path.exists(\"data\"):"
                        },
                        {
                            "line": 49,
                            "code": "os.makedirs(\"data\")"
                        }
                    ],
                    "summaryComponent": "The code also ensures the output directory exists before saving."
                }
            ]
        },
        "event": "map_summary_code",
        "id": "7URGSMi8EFrLluoBsZd1"
    },
    {
        "source": "backend",
        "timestamp": "2025-08-23 14:03:12.000",
        "data": {
            "summary": "This code provides functions to scrape NBA MVP voting results and player per-game statistics from Basketball Reference for seasons between 2018 and 2025. The scrape_mvp_votes function collects MVP vote data, renames columns, and returns a DataFrame with year, player name, and MVP points. The scrape_season_stats function retrieves per-game stats (points, assists, rebounds, field goal percentage) for each player, cleaning the data by removing invalid rows and ensuring completeness. The main block creates a data directory if needed, runs both scrapers, and saves the results as separate CSV files.",
            "code": "1: import pandas as pd\n2: import os\n3: \n4: \n5: def scrape_mvp_votes(start_year=2018, end_year=2025):\n6:     all_votes = []\n7:     for year in range(start_year, end_year + 1):\n8:         url = f\"https://www.basketball-reference.com/awards/awards_{year}.html\"\n9:         tables = pd.read_html(url, header=1)\n10:         try:\n11:             mvp_table = tables[0]  # MVP table is the first table\n12:             mvp_table[\"Year\"] = year\n13:             all_votes.append(mvp_table)\n14:         except:\n15:             print(f\"Could not parse year {year}\")\n16: \n17:     df = pd.concat(all_votes)\n18:     df = df.rename(columns={\"Player\": \"Name\", \"Pts Won\": \"MVP_Points\"})\n19:     return df[[\"Year\", \"Name\", \"MVP_Points\"]]\n20: \n21: \n22: def scrape_season_stats(year):\n23:     base_url_reg = (\n24:         f\"https://www.basketball-reference.com/leagues/NBA_{year}_per_game.html\"\n25:     )\n26:     df_reg = pd.read_html(base_url_reg, header=0)[0]\n27:     df_reg = df_reg[df_reg[\"Player\"] != \"Player\"]  # remove repeated header rows\n28:     df_reg[\"Year\"] = year\n29: \n30:     df_reg = df_reg[\n31:         [\"Player\", \"Year\", \"PTS\", \"AST\", \"TRB\", \"FG%\"]\n32:     ]  # Keep only specified columns\n33:     df_reg = df_reg.dropna(\n34:         subset=[\"PTS\", \"AST\", \"TRB\", \"FG%\"]\n35:     )  # Ensure key stats aren't invalid\n36:     return df_reg\n37: \n38: \n39: def scrape_multiple_seasons(start_year=2018, end_year=2025):\n40:     all_stats = []\n41:     for year in range(start_year, end_year + 1):\n42:         df = scrape_season_stats(year)\n43:         all_stats.append(df)\n44:     return pd.concat(all_stats)\n45: \n46: \n47: if __name__ == \"__main__\":\n48:     if not os.path.exists(\"data\"):\n49:         os.makedirs(\"data\")\n50: \n51:     print(\"Scraping MVP votes...\")\n52:     mvp_df = scrape_mvp_votes()\n53:     mvp_df.to_csv(\"data/mvp_votes.csv\", index=False)\n54: \n55:     print(\"Scraping player stats...\")\n56:     stats_df = scrape_multiple_seasons()\n57:     stats_df.to_csv(\"data/season_stats.csv\", index=False)\n58: ",
            "mapping": [
                {
                    "codeSegments": [
                        {
                            "line": 5,
                            "code": "def scrape_mvp_votes(start_year=2018, end_year=2025):"
                        },
                        {
                            "line": 22,
                            "code": "def scrape_season_stats(year):"
                        },
                        {
                            "line": 39,
                            "code": "def scrape_multiple_seasons(start_year=2018, end_year=2025):"
                        },
                        {
                            "line": 8,
                            "code": "url = f\"https://www.basketball-reference.com/awards/awards_{year}.html\""
                        },
                        {
                            "line": 23,
                            "code": "base_url_reg = (\n    f\"https://www.basketball-reference.com/leagues/NBA_{year}_per_game.html\"\n)"
                        }
                    ],
                    "summaryComponent": "functions to scrape NBA MVP voting results and player per-game statistics from Basketball Reference for seasons between 2018 and 2025"
                },
                {
                    "codeSegments": [
                        {
                            "line": 5,
                            "code": "def scrape_mvp_votes(start_year=2018, end_year=2025):"
                        },
                        {
                            "line": 9,
                            "code": "tables = pd.read_html(url, header=1)"
                        },
                        {
                            "line": 11,
                            "code": "mvp_table = tables[0]  # MVP table is the first table"
                        },
                        {
                            "line": 13,
                            "code": "all_votes.append(mvp_table)"
                        }
                    ],
                    "summaryComponent": "The scrape_mvp_votes function collects MVP vote data"
                },
                {
                    "codeSegments": [
                        {
                            "line": 18,
                            "code": "df = df.rename(columns={\"Player\": \"Name\", \"Pts Won\": \"MVP_Points\"})"
                        }
                    ],
                    "summaryComponent": "renames columns"
                },
                {
                    "codeSegments": [
                        {
                            "line": 19,
                            "code": "return df[[\"Year\", \"Name\", \"MVP_Points\"]]"
                        }
                    ],
                    "summaryComponent": "returns a DataFrame with year, player name, and MVP points"
                },
                {
                    "codeSegments": [
                        {
                            "line": 22,
                            "code": "def scrape_season_stats(year):"
                        },
                        {
                            "line": 26,
                            "code": "df_reg = pd.read_html(base_url_reg, header=0)[0]"
                        },
                        {
                            "line": 30,
                            "code": "df_reg = df_reg[\n    [\"Player\", \"Year\", \"PTS\", \"AST\", \"TRB\", \"FG%\"]\n]"
                        }
                    ],
                    "summaryComponent": "The scrape_season_stats function retrieves per-game stats (points, assists, rebounds, field goal percentage) for each player"
                },
                {
                    "codeSegments": [
                        {
                            "line": 27,
                            "code": "df_reg = df_reg[df_reg[\"Player\"] != \"Player\"]  # remove repeated header rows"
                        },
                        {
                            "line": 33,
                            "code": "df_reg = df_reg.dropna(\n    subset=[\"PTS\", \"AST\", \"TRB\", \"FG%\"]\n)"
                        }
                    ],
                    "summaryComponent": "cleaning the data by removing invalid rows and ensuring completeness"
                },
                {
                    "codeSegments": [
                        {
                            "line": 47,
                            "code": "if __name__ == \"__main__\":"
                        },
                        {
                            "line": 48,
                            "code": "if not os.path.exists(\"data\"):"
                        },
                        {
                            "line": 49,
                            "code": "os.makedirs(\"data\")"
                        }
                    ],
                    "summaryComponent": "The main block creates a data directory if needed"
                },
                {
                    "codeSegments": [
                        {
                            "line": 52,
                            "code": "mvp_df = scrape_mvp_votes()"
                        },
                        {
                            "line": 56,
                            "code": "stats_df = scrape_multiple_seasons()"
                        }
                    ],
                    "summaryComponent": "runs both scrapers"
                },
                {
                    "codeSegments": [
                        {
                            "line": 53,
                            "code": "mvp_df.to_csv(\"data/mvp_votes.csv\", index=False)"
                        },
                        {
                            "line": 57,
                            "code": "stats_df.to_csv(\"data/season_stats.csv\", index=False)"
                        }
                    ],
                    "summaryComponent": "saves the results as separate CSV files"
                }
            ]
        },
        "event": "map_summary_code",
        "id": "59rJkhiExpr97aQlk07E"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:03:17.000",
        "data": {
            "detail_level": "high",
            "section_id": "6e94bc2f-f907-4080-842c-5a2eda4c273e",
            "structured_type": "structured",
            "mapping_index": 4
        },
        "event": "mapping_hover",
        "id": "BqUEmCenEJUujT9JNo9Z"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:03:17.000",
        "data": {
            "detail_level": "high",
            "section_id": "6e94bc2f-f907-4080-842c-5a2eda4c273e",
            "structured_type": "structured",
            "mapping_index": 5
        },
        "event": "mapping_hover",
        "id": "CpHQddbYZcBFB3RMmDAa"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:03:17.000",
        "data": {
            "detail_level": "high",
            "section_id": "6e94bc2f-f907-4080-842c-5a2eda4c273e",
            "structured_type": "structured",
            "mapping_index": 2
        },
        "event": "mapping_hover",
        "id": "S76rjOAwdJlkNZUsLxry"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:03:17.000",
        "data": {
            "detail_level": "high",
            "section_id": "6e94bc2f-f907-4080-842c-5a2eda4c273e",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "T9duhNU66s2fWMHlybVx"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:03:17.000",
        "data": {
            "detail_level": "high",
            "section_id": "6e94bc2f-f907-4080-842c-5a2eda4c273e",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "e5wniOoyULZ2juYvPZF7"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:03:17.000",
        "data": {
            "detail_level": "high",
            "section_id": "6e94bc2f-f907-4080-842c-5a2eda4c273e",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "g0Cupd7PYtgfqrFg2EdZ"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:03:17.000",
        "data": {
            "detail_level": "high",
            "section_id": "6e94bc2f-f907-4080-842c-5a2eda4c273e",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "mq9idzlySLAyBoitYILM"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:03:18.000",
        "data": {
            "detail_level": "high",
            "section_id": "6e94bc2f-f907-4080-842c-5a2eda4c273e",
            "structured_type": "structured",
            "mapping_index": 2
        },
        "event": "mapping_hover",
        "id": "0hW8CXN8GaS1ICMIHCyY"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:03:18.000",
        "data": {
            "detail_level": "high",
            "section_id": "6e94bc2f-f907-4080-842c-5a2eda4c273e",
            "structured_type": "structured",
            "mapping_index": 3
        },
        "event": "mapping_hover",
        "id": "VgY85t2UeUcdN5KI33E8"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:03:18.000",
        "data": {
            "detail_level": "high",
            "section_id": "6e94bc2f-f907-4080-842c-5a2eda4c273e",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "qxGNMhw3tbJDL5UhIqGu"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:03:19.000",
        "data": {
            "detail_level": "high",
            "section_id": "6e94bc2f-f907-4080-842c-5a2eda4c273e",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "NnxMxUdtFQYLsDsc1Ebi"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:03:20.000",
        "data": {
            "detail_level": "high",
            "section_id": "6e94bc2f-f907-4080-842c-5a2eda4c273e",
            "structured_type": "structured",
            "mapping_index": 0
        },
        "event": "mapping_hover",
        "id": "FAEDBLqciOms03T6GmAZ"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:03:20.000",
        "data": {
            "detail_level": "high",
            "section_id": "6e94bc2f-f907-4080-842c-5a2eda4c273e",
            "structured_type": "structured",
            "mapping_index": 1
        },
        "event": "mapping_hover",
        "id": "NlbACIAEmXYh8jLCtbaC"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:03:20.000",
        "data": {
            "detail_level": "high",
            "section_id": "6e94bc2f-f907-4080-842c-5a2eda4c273e",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "QlaqVAdBmJzW9fLRWWDL"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:03:20.000",
        "data": {
            "after_section_id": "8ab37932-2678-4985-b380-b6109d821347",
            "before_section_id": "6e94bc2f-f907-4080-842c-5a2eda4c273e"
        },
        "event": "autotransit_section",
        "id": "TepuxnNCKMGW9gvL7iqQ"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:03:20.000",
        "data": {
            "section_data": {
                "editPromptValue": "",
                "summaryData": {
                    "high_unstructured": "This code provides functions to scrape NBA MVP voting results and player per-game statistics from Basketball Reference for seasons between 2018 and 2025. The scrape_mvp_votes function collects MVP vote data, renames columns, and returns a DataFrame with year, player name, and MVP points. The scrape_season_stats function retrieves per-game stats (points, assists, rebounds, field goal percentage) for each player, cleaning the data by removing invalid rows and ensuring completeness. The main block creates a data directory if needed, runs both scrapers, and saves the results as separate CSV files.",
                    "low_structured": "• Scrapes MVP votes and player stats from Basketball Reference\n• Processes data for multiple seasons\n• Saves results to CSV files",
                    "high_structured": "• Implements two main scraping functions:\n  ◦ scrape_mvp_votes: Collects MVP voting data for each year, renames columns, and aggregates results\n  ◦ scrape_season_stats: Retrieves per-game stats (PTS, AST, TRB, FG%) for all players in a season, cleans and filters data\n• scrape_multiple_seasons aggregates season stats across multiple years\n• Main execution block:\n  ◦ Checks for and creates a 'data' directory if missing\n  ◦ Runs the MVP votes and player stats scrapers\n  ◦ Saves the scraped data to 'data/mvp_votes.csv' and 'data/season_stats.csv'\n• Handles errors gracefully during scraping (e.g., missing years)\n• Uses pandas for data extraction, manipulation, and saving",
                    "title": "Summary of Basketball Reference Scraper Code",
                    "medium_unstructured": "The script defines functions to scrape NBA MVP voting results and player per-game statistics from Basketball Reference for a range of years. It processes and combines the data, then saves the results as CSV files in a local directory. The code also ensures the output directory exists before saving.",
                    "medium_structured": "• Defines functions to scrape MVP votes and player stats from Basketball Reference\n• Processes data for each year in a specified range\n• Ensures a 'data' directory exists before saving\n• Saves MVP and player statistics as CSV files",
                    "low_unstructured": "This code scrapes NBA MVP votes and player statistics from Basketball Reference for multiple seasons and saves the data as CSV files."
                },
                "selectedDetailLevel": "medium",
                "title": "Summary of Basketball Reference Scraper Code",
                "summaryMappings": {
                    "low_structured": [
                        {
                            "codeSegments": [
                                {
                                    "line": 5,
                                    "code": "def scrape_mvp_votes(start_year=2018, end_year=2025):"
                                },
                                {
                                    "line": 52,
                                    "code": "mvp_df = scrape_mvp_votes()"
                                }
                            ],
                            "summaryComponent": "Scrapes MVP votes"
                        },
                        {
                            "codeSegments": [
                                {
                                    "line": 22,
                                    "code": "def scrape_season_stats(year):"
                                },
                                {
                                    "line": 39,
                                    "code": "def scrape_multiple_seasons(start_year=2018, end_year=2025):"
                                },
                                {
                                    "line": 56,
                                    "code": "stats_df = scrape_multiple_seasons()"
                                }
                            ],
                            "summaryComponent": "and player stats"
                        },
                        {
                            "codeSegments": [
                                {
                                    "line": 8,
                                    "code": "url = f\"https://www.basketball-reference.com/awards/awards_{year}.html\""
                                },
                                {
                                    "line": 23,
                                    "code": "base_url_reg = ("
                                },
                                {
                                    "line": 24,
                                    "code": "f\"https://www.basketball-reference.com/leagues/NBA_{year}_per_game.html\""
                                }
                            ],
                            "summaryComponent": "from Basketball Reference"
                        },
                        {
                            "codeSegments": [
                                {
                                    "line": 7,
                                    "code": "for year in range(start_year, end_year + 1):"
                                },
                                {
                                    "line": 41,
                                    "code": "for year in range(start_year, end_year + 1):"
                                }
                            ],
                            "summaryComponent": "Processes data for multiple seasons"
                        },
                        {
                            "codeSegments": [
                                {
                                    "line": 53,
                                    "code": "mvp_df.to_csv(\"data/mvp_votes.csv\", index=False)"
                                },
                                {
                                    "line": 57,
                                    "code": "stats_df.to_csv(\"data/season_stats.csv\", index=False)"
                                }
                            ],
                            "summaryComponent": "Saves results to CSV files"
                        }
                    ],
                    "high_structured": [
                        {
                            "codeSegments": [
                                {
                                    "line": 5,
                                    "code": "def scrape_mvp_votes(start_year=2018, end_year=2025):"
                                },
                                {
                                    "line": 22,
                                    "code": "def scrape_season_stats(year):"
                                }
                            ],
                            "summaryComponent": "Implements two main scraping functions"
                        },
                        {
                            "codeSegments": [
                                {
                                    "line": 7,
                                    "code": "for year in range(start_year, end_year + 1):"
                                },
                                {
                                    "line": 8,
                                    "code": "url = f\"https://www.basketball-reference.com/awards/awards_{year}.html\""
                                },
                                {
                                    "line": 9,
                                    "code": "tables = pd.read_html(url, header=1)"
                                },
                                {
                                    "line": 11,
                                    "code": "mvp_table = tables[0]  # MVP table is the first table"
                                },
                                {
                                    "line": 12,
                                    "code": "mvp_table[\"Year\"] = year"
                                },
                                {
                                    "line": 13,
                                    "code": "all_votes.append(mvp_table)"
                                },
                                {
                                    "line": 17,
                                    "code": "df = pd.concat(all_votes)"
                                },
                                {
                                    "line": 18,
                                    "code": "df = df.rename(columns={\"Player\": \"Name\", \"Pts Won\": \"MVP_Points\"})"
                                },
                                {
                                    "line": 19,
                                    "code": "return df[[\"Year\", \"Name\", \"MVP_Points\"]]"
                                }
                            ],
                            "summaryComponent": "scrape_mvp_votes: Collects MVP voting data for each year, renames columns, and aggregates results"
                        },
                        {
                            "codeSegments": [
                                {
                                    "line": 23,
                                    "code": "base_url_reg = ("
                                },
                                {
                                    "line": 26,
                                    "code": "df_reg = pd.read_html(base_url_reg, header=0)[0]"
                                },
                                {
                                    "line": 27,
                                    "code": "df_reg = df_reg[df_reg[\"Player\"] != \"Player\"]  # remove repeated header rows"
                                },
                                {
                                    "line": 28,
                                    "code": "df_reg[\"Year\"] = year"
                                },
                                {
                                    "line": 30,
                                    "code": "df_reg = df_reg["
                                },
                                {
                                    "line": 31,
                                    "code": "[\"Player\", \"Year\", \"PTS\", \"AST\", \"TRB\", \"FG%\"]"
                                },
                                {
                                    "line": 33,
                                    "code": "df_reg = df_reg.dropna("
                                },
                                {
                                    "line": 34,
                                    "code": "subset=[\"PTS\", \"AST\", \"TRB\", \"FG%\"]"
                                },
                                {
                                    "line": 36,
                                    "code": "return df_reg"
                                }
                            ],
                            "summaryComponent": "scrape_season_stats: Retrieves per-game stats (PTS, AST, TRB, FG%) for all players in a season, cleans and filters data"
                        },
                        {
                            "codeSegments": [
                                {
                                    "line": 39,
                                    "code": "def scrape_multiple_seasons(start_year=2018, end_year=2025):"
                                },
                                {
                                    "line": 41,
                                    "code": "for year in range(start_year, end_year + 1):"
                                },
                                {
                                    "line": 42,
                                    "code": "df = scrape_season_stats(year)"
                                },
                                {
                                    "line": 43,
                                    "code": "all_stats.append(df)"
                                },
                                {
                                    "line": 44,
                                    "code": "return pd.concat(all_stats)"
                                }
                            ],
                            "summaryComponent": "scrape_multiple_seasons aggregates season stats across multiple years"
                        },
                        {
                            "codeSegments": [
                                {
                                    "line": 47,
                                    "code": "if __name__ == \"__main__\":"
                                }
                            ],
                            "summaryComponent": "Main execution block"
                        },
                        {
                            "codeSegments": [
                                {
                                    "line": 48,
                                    "code": "if not os.path.exists(\"data\"):"
                                },
                                {
                                    "line": 49,
                                    "code": "os.makedirs(\"data\")"
                                }
                            ],
                            "summaryComponent": "Checks for and creates a 'data' directory if missing"
                        },
                        {
                            "codeSegments": [
                                {
                                    "line": 52,
                                    "code": "mvp_df = scrape_mvp_votes()"
                                },
                                {
                                    "line": 56,
                                    "code": "stats_df = scrape_multiple_seasons()"
                                }
                            ],
                            "summaryComponent": "Runs the MVP votes and player stats scrapers"
                        },
                        {
                            "codeSegments": [
                                {
                                    "line": 53,
                                    "code": "mvp_df.to_csv(\"data/mvp_votes.csv\", index=False)"
                                },
                                {
                                    "line": 57,
                                    "code": "stats_df.to_csv(\"data/season_stats.csv\", index=False)"
                                }
                            ],
                            "summaryComponent": "Saves the scraped data to 'data/mvp_votes.csv' and 'data/season_stats.csv'"
                        },
                        {
                            "codeSegments": [
                                {
                                    "line": 14,
                                    "code": "except:"
                                },
                                {
                                    "line": 15,
                                    "code": "print(f\"Could not parse year {year}\")"
                                }
                            ],
                            "summaryComponent": "Handles errors gracefully during scraping (e.g., missing years)"
                        },
                        {
                            "codeSegments": [
                                {
                                    "line": 1,
                                    "code": "import pandas as pd"
                                },
                                {
                                    "line": 9,
                                    "code": "tables = pd.read_html(url, header=1)"
                                },
                                {
                                    "line": 17,
                                    "code": "df = pd.concat(all_votes)"
                                },
                                {
                                    "line": 18,
                                    "code": "df = df.rename(columns={\"Player\": \"Name\", \"Pts Won\": \"MVP_Points\"})"
                                },
                                {
                                    "line": 26,
                                    "code": "df_reg = pd.read_html(base_url_reg, header=0)[0]"
                                },
                                {
                                    "line": 33,
                                    "code": "df_reg = df_reg.dropna("
                                },
                                {
                                    "line": 44,
                                    "code": "return pd.concat(all_stats)"
                                },
                                {
                                    "line": 53,
                                    "code": "mvp_df.to_csv(\"data/mvp_votes.csv\", index=False)"
                                },
                                {
                                    "line": 57,
                                    "code": "stats_df.to_csv(\"data/season_stats.csv\", index=False)"
                                }
                            ],
                            "summaryComponent": "Uses pandas for data extraction, manipulation, and saving"
                        }
                    ],
                    "medium_structured": [
                        {
                            "codeSegments": [
                                {
                                    "line": 5,
                                    "code": "def scrape_mvp_votes(start_year=2018, end_year=2025):"
                                },
                                {
                                    "line": 22,
                                    "code": "def scrape_season_stats(year):"
                                },
                                {
                                    "line": 39,
                                    "code": "def scrape_multiple_seasons(start_year=2018, end_year=2025):"
                                }
                            ],
                            "summaryComponent": "Defines functions to scrape MVP votes and player stats from Basketball Reference"
                        },
                        {
                            "codeSegments": [
                                {
                                    "line": 7,
                                    "code": "for year in range(start_year, end_year + 1):"
                                },
                                {
                                    "line": 41,
                                    "code": "for year in range(start_year, end_year + 1):"
                                }
                            ],
                            "summaryComponent": "Processes data for each year in a specified range"
                        },
                        {
                            "codeSegments": [
                                {
                                    "line": 48,
                                    "code": "if not os.path.exists(\"data\"):"
                                },
                                {
                                    "line": 49,
                                    "code": "os.makedirs(\"data\")"
                                }
                            ],
                            "summaryComponent": "Ensures a 'data' directory exists before saving"
                        },
                        {
                            "codeSegments": [
                                {
                                    "line": 53,
                                    "code": "mvp_df.to_csv(\"data/mvp_votes.csv\", index=False)"
                                },
                                {
                                    "line": 57,
                                    "code": "stats_df.to_csv(\"data/season_stats.csv\", index=False)"
                                }
                            ],
                            "summaryComponent": "Saves MVP and player statistics as CSV files"
                        }
                    ],
                    "medium_unstructured": [
                        {
                            "codeSegments": [
                                {
                                    "line": 5,
                                    "code": "def scrape_mvp_votes(start_year=2018, end_year=2025):"
                                }
                            ],
                            "summaryComponent": "defines functions to scrape NBA MVP voting results"
                        },
                        {
                            "codeSegments": [
                                {
                                    "line": 22,
                                    "code": "def scrape_season_stats(year):"
                                },
                                {
                                    "line": 39,
                                    "code": "def scrape_multiple_seasons(start_year=2018, end_year=2025):"
                                }
                            ],
                            "summaryComponent": "and player per-game statistics"
                        },
                        {
                            "codeSegments": [
                                {
                                    "line": 8,
                                    "code": "url = f\"https://www.basketball-reference.com/awards/awards_{year}.html\""
                                },
                                {
                                    "line": 23,
                                    "code": "base_url_reg = ("
                                },
                                {
                                    "line": 24,
                                    "code": "f\"https://www.basketball-reference.com/leagues/NBA_{year}_per_game.html\""
                                },
                                {
                                    "line": 7,
                                    "code": "for year in range(start_year, end_year + 1):"
                                },
                                {
                                    "line": 41,
                                    "code": "for year in range(start_year, end_year + 1):"
                                }
                            ],
                            "summaryComponent": "from Basketball Reference for a range of years"
                        },
                        {
                            "codeSegments": [
                                {
                                    "line": 17,
                                    "code": "df = pd.concat(all_votes)"
                                },
                                {
                                    "line": 18,
                                    "code": "df = df.rename(columns={\"Player\": \"Name\", \"Pts Won\": \"MVP_Points\"})"
                                },
                                {
                                    "line": 27,
                                    "code": "df_reg = df_reg[df_reg[\"Player\"] != \"Player\"]  # remove repeated header rows"
                                },
                                {
                                    "line": 33,
                                    "code": "df_reg = df_reg.dropna("
                                },
                                {
                                    "line": 44,
                                    "code": "return pd.concat(all_stats)"
                                }
                            ],
                            "summaryComponent": "It processes and combines the data"
                        },
                        {
                            "codeSegments": [
                                {
                                    "line": 53,
                                    "code": "mvp_df.to_csv(\"data/mvp_votes.csv\", index=False)"
                                },
                                {
                                    "line": 57,
                                    "code": "stats_df.to_csv(\"data/season_stats.csv\", index=False)"
                                }
                            ],
                            "summaryComponent": "then saves the results as CSV files"
                        },
                        {
                            "codeSegments": [
                                {
                                    "line": 53,
                                    "code": "\"data/mvp_votes.csv\""
                                },
                                {
                                    "line": 57,
                                    "code": "\"data/season_stats.csv\""
                                }
                            ],
                            "summaryComponent": "in a local directory"
                        },
                        {
                            "codeSegments": [
                                {
                                    "line": 48,
                                    "code": "if not os.path.exists(\"data\"):"
                                },
                                {
                                    "line": 49,
                                    "code": "os.makedirs(\"data\")"
                                }
                            ],
                            "summaryComponent": "The code also ensures the output directory exists before saving."
                        }
                    ],
                    "high_unstructured": [
                        {
                            "codeSegments": [
                                {
                                    "line": 5,
                                    "code": "def scrape_mvp_votes(start_year=2018, end_year=2025):"
                                },
                                {
                                    "line": 22,
                                    "code": "def scrape_season_stats(year):"
                                },
                                {
                                    "line": 39,
                                    "code": "def scrape_multiple_seasons(start_year=2018, end_year=2025):"
                                },
                                {
                                    "line": 8,
                                    "code": "url = f\"https://www.basketball-reference.com/awards/awards_{year}.html\""
                                },
                                {
                                    "line": 23,
                                    "code": "base_url_reg = (\n    f\"https://www.basketball-reference.com/leagues/NBA_{year}_per_game.html\"\n)"
                                }
                            ],
                            "summaryComponent": "functions to scrape NBA MVP voting results and player per-game statistics from Basketball Reference for seasons between 2018 and 2025"
                        },
                        {
                            "codeSegments": [
                                {
                                    "line": 5,
                                    "code": "def scrape_mvp_votes(start_year=2018, end_year=2025):"
                                },
                                {
                                    "line": 9,
                                    "code": "tables = pd.read_html(url, header=1)"
                                },
                                {
                                    "line": 11,
                                    "code": "mvp_table = tables[0]  # MVP table is the first table"
                                },
                                {
                                    "line": 13,
                                    "code": "all_votes.append(mvp_table)"
                                }
                            ],
                            "summaryComponent": "The scrape_mvp_votes function collects MVP vote data"
                        },
                        {
                            "codeSegments": [
                                {
                                    "line": 18,
                                    "code": "df = df.rename(columns={\"Player\": \"Name\", \"Pts Won\": \"MVP_Points\"})"
                                }
                            ],
                            "summaryComponent": "renames columns"
                        },
                        {
                            "codeSegments": [
                                {
                                    "line": 19,
                                    "code": "return df[[\"Year\", \"Name\", \"MVP_Points\"]]"
                                }
                            ],
                            "summaryComponent": "returns a DataFrame with year, player name, and MVP points"
                        },
                        {
                            "codeSegments": [
                                {
                                    "line": 22,
                                    "code": "def scrape_season_stats(year):"
                                },
                                {
                                    "line": 26,
                                    "code": "df_reg = pd.read_html(base_url_reg, header=0)[0]"
                                },
                                {
                                    "line": 30,
                                    "code": "df_reg = df_reg[\n    [\"Player\", \"Year\", \"PTS\", \"AST\", \"TRB\", \"FG%\"]\n]"
                                }
                            ],
                            "summaryComponent": "The scrape_season_stats function retrieves per-game stats (points, assists, rebounds, field goal percentage) for each player"
                        },
                        {
                            "codeSegments": [
                                {
                                    "line": 27,
                                    "code": "df_reg = df_reg[df_reg[\"Player\"] != \"Player\"]  # remove repeated header rows"
                                },
                                {
                                    "line": 33,
                                    "code": "df_reg = df_reg.dropna(\n    subset=[\"PTS\", \"AST\", \"TRB\", \"FG%\"]\n)"
                                }
                            ],
                            "summaryComponent": "cleaning the data by removing invalid rows and ensuring completeness"
                        },
                        {
                            "codeSegments": [
                                {
                                    "line": 47,
                                    "code": "if __name__ == \"__main__\":"
                                },
                                {
                                    "line": 48,
                                    "code": "if not os.path.exists(\"data\"):"
                                },
                                {
                                    "line": 49,
                                    "code": "os.makedirs(\"data\")"
                                }
                            ],
                            "summaryComponent": "The main block creates a data directory if needed"
                        },
                        {
                            "codeSegments": [
                                {
                                    "line": 52,
                                    "code": "mvp_df = scrape_mvp_votes()"
                                },
                                {
                                    "line": 56,
                                    "code": "stats_df = scrape_multiple_seasons()"
                                }
                            ],
                            "summaryComponent": "runs both scrapers"
                        },
                        {
                            "codeSegments": [
                                {
                                    "line": 53,
                                    "code": "mvp_df.to_csv(\"data/mvp_votes.csv\", index=False)"
                                },
                                {
                                    "line": 57,
                                    "code": "stats_df.to_csv(\"data/season_stats.csv\", index=False)"
                                }
                            ],
                            "summaryComponent": "saves the results as separate CSV files"
                        }
                    ],
                    "low_unstructured": [
                        {
                            "codeSegments": [
                                {
                                    "line": 5,
                                    "code": "def scrape_mvp_votes(start_year=2018, end_year=2025):"
                                },
                                {
                                    "line": 52,
                                    "code": "mvp_df = scrape_mvp_votes()"
                                }
                            ],
                            "summaryComponent": "scrapes NBA MVP votes"
                        },
                        {
                            "codeSegments": [
                                {
                                    "line": 22,
                                    "code": "def scrape_season_stats(year):"
                                },
                                {
                                    "line": 39,
                                    "code": "def scrape_multiple_seasons(start_year=2018, end_year=2025):"
                                },
                                {
                                    "line": 56,
                                    "code": "stats_df = scrape_multiple_seasons()"
                                }
                            ],
                            "summaryComponent": "and player statistics"
                        },
                        {
                            "codeSegments": [
                                {
                                    "line": 8,
                                    "code": "url = f\"https://www.basketball-reference.com/awards/awards_{year}.html\""
                                },
                                {
                                    "line": 23,
                                    "code": "base_url_reg = ("
                                },
                                {
                                    "line": 24,
                                    "code": "f\"https://www.basketball-reference.com/leagues/NBA_{year}_per_game.html\""
                                }
                            ],
                            "summaryComponent": "from Basketball Reference"
                        },
                        {
                            "codeSegments": [
                                {
                                    "line": 7,
                                    "code": "for year in range(start_year, end_year + 1):"
                                },
                                {
                                    "line": 41,
                                    "code": "for year in range(start_year, end_year + 1):"
                                }
                            ],
                            "summaryComponent": "for multiple seasons"
                        },
                        {
                            "codeSegments": [
                                {
                                    "line": 53,
                                    "code": "mvp_df.to_csv(\"data/mvp_votes.csv\", index=False)"
                                },
                                {
                                    "line": 57,
                                    "code": "stats_df.to_csv(\"data/season_stats.csv\", index=False)"
                                }
                            ],
                            "summaryComponent": "and saves the data as CSV files"
                        }
                    ]
                },
                "metadata": {
                    "id": "8ab37932-2678-4985-b380-b6109d821347",
                    "filename": "scraper.py",
                    "offset": 0,
                    "fullPath": "/project/workspace/scraper.py",
                    "originalCode": "import pandas as pd\nimport os\n\n\ndef scrape_mvp_votes(start_year=2018, end_year=2025):\n    all_votes = []\n    for year in range(start_year, end_year + 1):\n        url = f\"https://www.basketball-reference.com/awards/awards_{year}.html\"\n        tables = pd.read_html(url, header=1)\n        try:\n            mvp_table = tables[0]  # MVP table is the first table\n            mvp_table[\"Year\"] = year\n            all_votes.append(mvp_table)\n        except:\n            print(f\"Could not parse year {year}\")\n\n    df = pd.concat(all_votes)\n    df = df.rename(columns={\"Player\": \"Name\", \"Pts Won\": \"MVP_Points\"})\n    return df[[\"Year\", \"Name\", \"MVP_Points\"]]\n\n\ndef scrape_season_stats(year):\n    base_url_reg = (\n        f\"https://www.basketball-reference.com/leagues/NBA_{year}_per_game.html\"\n    )\n    df_reg = pd.read_html(base_url_reg, header=0)[0]\n    df_reg = df_reg[df_reg[\"Player\"] != \"Player\"]  # remove repeated header rows\n    df_reg[\"Year\"] = year\n\n    df_reg = df_reg[\n        [\"Player\", \"Year\", \"PTS\", \"AST\", \"TRB\", \"FG%\"]\n    ]  # Keep only specified columns\n    df_reg = df_reg.dropna(\n        subset=[\"PTS\", \"AST\", \"TRB\", \"FG%\"]\n    )  # Ensure key stats aren't invalid\n    return df_reg\n\n\ndef scrape_multiple_seasons(start_year=2018, end_year=2025):\n    all_stats = []\n    for year in range(start_year, end_year + 1):\n        df = scrape_season_stats(year)\n        all_stats.append(df)\n    return pd.concat(all_stats)\n\n\nif __name__ == \"__main__\":\n    if not os.path.exists(\"data\"):\n        os.makedirs(\"data\")\n\n    print(\"Scraping MVP votes...\")\n    mvp_df = scrape_mvp_votes()\n    mvp_df.to_csv(\"data/mvp_votes.csv\", index=False)\n\n    print(\"Scraping player stats...\")\n    stats_df = scrape_multiple_seasons()\n    stats_df.to_csv(\"data/season_stats.csv\", index=False)\n"
                },
                "createdAt": 1755986601000,
                "lines": [
                    1,
                    58
                ],
                "editPromptStructured": null,
                "selectedStructured": "unstructured",
                "editPromptDetailLevel": null
            },
            "section_id": "8ab37932-2678-4985-b380-b6109d821347"
        },
        "event": "create_new_section",
        "id": "qvT0FoSfhSYwK7U0h0pW"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:03:20.000",
        "data": {
            "detail_level": "high",
            "section_id": "6e94bc2f-f907-4080-842c-5a2eda4c273e",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "qzKoKN1LQZkULF6EwaPJ"
    },
    {
        "source": "backend",
        "timestamp": "2025-08-23 14:03:21.000",
        "data": {
            "summary": "• Implements two main scraping functions:\n  ◦ scrape_mvp_votes: Collects MVP voting data for each year, renames columns, and aggregates results\n  ◦ scrape_season_stats: Retrieves per-game stats (PTS, AST, TRB, FG%) for all players in a season, cleans and filters data\n• scrape_multiple_seasons aggregates season stats across multiple years\n• Main execution block:\n  ◦ Checks for and creates a 'data' directory if missing\n  ◦ Runs the MVP votes and player stats scrapers\n  ◦ Saves the scraped data to 'data/mvp_votes.csv' and 'data/season_stats.csv'\n• Handles errors gracefully during scraping (e.g., missing years)\n• Uses pandas for data extraction, manipulation, and saving",
            "code": "1: import pandas as pd\n2: import os\n3: \n4: \n5: def scrape_mvp_votes(start_year=2018, end_year=2025):\n6:     all_votes = []\n7:     for year in range(start_year, end_year + 1):\n8:         url = f\"https://www.basketball-reference.com/awards/awards_{year}.html\"\n9:         tables = pd.read_html(url, header=1)\n10:         try:\n11:             mvp_table = tables[0]  # MVP table is the first table\n12:             mvp_table[\"Year\"] = year\n13:             all_votes.append(mvp_table)\n14:         except:\n15:             print(f\"Could not parse year {year}\")\n16: \n17:     df = pd.concat(all_votes)\n18:     df = df.rename(columns={\"Player\": \"Name\", \"Pts Won\": \"MVP_Points\"})\n19:     return df[[\"Year\", \"Name\", \"MVP_Points\"]]\n20: \n21: \n22: def scrape_season_stats(year):\n23:     base_url_reg = (\n24:         f\"https://www.basketball-reference.com/leagues/NBA_{year}_per_game.html\"\n25:     )\n26:     df_reg = pd.read_html(base_url_reg, header=0)[0]\n27:     df_reg = df_reg[df_reg[\"Player\"] != \"Player\"]  # remove repeated header rows\n28:     df_reg[\"Year\"] = year\n29: \n30:     df_reg = df_reg[\n31:         [\"Player\", \"Year\", \"PTS\", \"AST\", \"TRB\", \"FG%\"]\n32:     ]  # Keep only specified columns\n33:     df_reg = df_reg.dropna(\n34:         subset=[\"PTS\", \"AST\", \"TRB\", \"FG%\"]\n35:     )  # Ensure key stats aren't invalid\n36:     return df_reg\n37: \n38: \n39: def scrape_multiple_seasons(start_year=2018, end_year=2025):\n40:     all_stats = []\n41:     for year in range(start_year, end_year + 1):\n42:         df = scrape_season_stats(year)\n43:         all_stats.append(df)\n44:     return pd.concat(all_stats)\n45: \n46: \n47: if __name__ == \"__main__\":\n48:     if not os.path.exists(\"data\"):\n49:         os.makedirs(\"data\")\n50: \n51:     print(\"Scraping MVP votes...\")\n52:     mvp_df = scrape_mvp_votes()\n53:     mvp_df.to_csv(\"data/mvp_votes.csv\", index=False)\n54: \n55:     print(\"Scraping player stats...\")\n56:     stats_df = scrape_multiple_seasons()\n57:     stats_df.to_csv(\"data/season_stats.csv\", index=False)\n58: ",
            "mapping": [
                {
                    "codeSegments": [
                        {
                            "line": 5,
                            "code": "def scrape_mvp_votes(start_year=2018, end_year=2025):"
                        },
                        {
                            "line": 22,
                            "code": "def scrape_season_stats(year):"
                        }
                    ],
                    "summaryComponent": "Implements two main scraping functions"
                },
                {
                    "codeSegments": [
                        {
                            "line": 7,
                            "code": "for year in range(start_year, end_year + 1):"
                        },
                        {
                            "line": 8,
                            "code": "url = f\"https://www.basketball-reference.com/awards/awards_{year}.html\""
                        },
                        {
                            "line": 9,
                            "code": "tables = pd.read_html(url, header=1)"
                        },
                        {
                            "line": 11,
                            "code": "mvp_table = tables[0]  # MVP table is the first table"
                        },
                        {
                            "line": 12,
                            "code": "mvp_table[\"Year\"] = year"
                        },
                        {
                            "line": 13,
                            "code": "all_votes.append(mvp_table)"
                        },
                        {
                            "line": 17,
                            "code": "df = pd.concat(all_votes)"
                        },
                        {
                            "line": 18,
                            "code": "df = df.rename(columns={\"Player\": \"Name\", \"Pts Won\": \"MVP_Points\"})"
                        },
                        {
                            "line": 19,
                            "code": "return df[[\"Year\", \"Name\", \"MVP_Points\"]]"
                        }
                    ],
                    "summaryComponent": "scrape_mvp_votes: Collects MVP voting data for each year, renames columns, and aggregates results"
                },
                {
                    "codeSegments": [
                        {
                            "line": 23,
                            "code": "base_url_reg = ("
                        },
                        {
                            "line": 26,
                            "code": "df_reg = pd.read_html(base_url_reg, header=0)[0]"
                        },
                        {
                            "line": 27,
                            "code": "df_reg = df_reg[df_reg[\"Player\"] != \"Player\"]  # remove repeated header rows"
                        },
                        {
                            "line": 28,
                            "code": "df_reg[\"Year\"] = year"
                        },
                        {
                            "line": 30,
                            "code": "df_reg = df_reg["
                        },
                        {
                            "line": 31,
                            "code": "[\"Player\", \"Year\", \"PTS\", \"AST\", \"TRB\", \"FG%\"]"
                        },
                        {
                            "line": 33,
                            "code": "df_reg = df_reg.dropna("
                        },
                        {
                            "line": 34,
                            "code": "subset=[\"PTS\", \"AST\", \"TRB\", \"FG%\"]"
                        },
                        {
                            "line": 36,
                            "code": "return df_reg"
                        }
                    ],
                    "summaryComponent": "scrape_season_stats: Retrieves per-game stats (PTS, AST, TRB, FG%) for all players in a season, cleans and filters data"
                },
                {
                    "codeSegments": [
                        {
                            "line": 39,
                            "code": "def scrape_multiple_seasons(start_year=2018, end_year=2025):"
                        },
                        {
                            "line": 41,
                            "code": "for year in range(start_year, end_year + 1):"
                        },
                        {
                            "line": 42,
                            "code": "df = scrape_season_stats(year)"
                        },
                        {
                            "line": 43,
                            "code": "all_stats.append(df)"
                        },
                        {
                            "line": 44,
                            "code": "return pd.concat(all_stats)"
                        }
                    ],
                    "summaryComponent": "scrape_multiple_seasons aggregates season stats across multiple years"
                },
                {
                    "codeSegments": [
                        {
                            "line": 47,
                            "code": "if __name__ == \"__main__\":"
                        }
                    ],
                    "summaryComponent": "Main execution block"
                },
                {
                    "codeSegments": [
                        {
                            "line": 48,
                            "code": "if not os.path.exists(\"data\"):"
                        },
                        {
                            "line": 49,
                            "code": "os.makedirs(\"data\")"
                        }
                    ],
                    "summaryComponent": "Checks for and creates a 'data' directory if missing"
                },
                {
                    "codeSegments": [
                        {
                            "line": 52,
                            "code": "mvp_df = scrape_mvp_votes()"
                        },
                        {
                            "line": 56,
                            "code": "stats_df = scrape_multiple_seasons()"
                        }
                    ],
                    "summaryComponent": "Runs the MVP votes and player stats scrapers"
                },
                {
                    "codeSegments": [
                        {
                            "line": 53,
                            "code": "mvp_df.to_csv(\"data/mvp_votes.csv\", index=False)"
                        },
                        {
                            "line": 57,
                            "code": "stats_df.to_csv(\"data/season_stats.csv\", index=False)"
                        }
                    ],
                    "summaryComponent": "Saves the scraped data to 'data/mvp_votes.csv' and 'data/season_stats.csv'"
                },
                {
                    "codeSegments": [
                        {
                            "line": 14,
                            "code": "except:"
                        },
                        {
                            "line": 15,
                            "code": "print(f\"Could not parse year {year}\")"
                        }
                    ],
                    "summaryComponent": "Handles errors gracefully during scraping (e.g., missing years)"
                },
                {
                    "codeSegments": [
                        {
                            "line": 1,
                            "code": "import pandas as pd"
                        },
                        {
                            "line": 9,
                            "code": "tables = pd.read_html(url, header=1)"
                        },
                        {
                            "line": 17,
                            "code": "df = pd.concat(all_votes)"
                        },
                        {
                            "line": 18,
                            "code": "df = df.rename(columns={\"Player\": \"Name\", \"Pts Won\": \"MVP_Points\"})"
                        },
                        {
                            "line": 26,
                            "code": "df_reg = pd.read_html(base_url_reg, header=0)[0]"
                        },
                        {
                            "line": 33,
                            "code": "df_reg = df_reg.dropna("
                        },
                        {
                            "line": 44,
                            "code": "return pd.concat(all_stats)"
                        },
                        {
                            "line": 53,
                            "code": "mvp_df.to_csv(\"data/mvp_votes.csv\", index=False)"
                        },
                        {
                            "line": 57,
                            "code": "stats_df.to_csv(\"data/season_stats.csv\", index=False)"
                        }
                    ],
                    "summaryComponent": "Uses pandas for data extraction, manipulation, and saving"
                }
            ]
        },
        "event": "map_summary_code",
        "id": "9DMZtMvLZRqUseta4ux9"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:03:24.000",
        "data": {
            "before_detail_level": "medium",
            "before_structured": "unstructured",
            "section_id": "8ab37932-2678-4985-b380-b6109d821347",
            "after_detail_level": "high",
            "after_structured": "unstructured"
        },
        "event": "change_summary_level",
        "id": "GQiEOVoZlH2NqHMLOh7A"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:03:25.000",
        "data": {
            "detail_level": "high",
            "section_id": "8ab37932-2678-4985-b380-b6109d821347",
            "structured_type": "structured",
            "mapping_index": 6
        },
        "event": "mapping_hover",
        "id": "0MYq3JRRU4H8i2u6drMU"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:03:25.000",
        "data": {
            "detail_level": "high",
            "section_id": "8ab37932-2678-4985-b380-b6109d821347",
            "structured_type": "structured",
            "mapping_index": 7
        },
        "event": "mapping_hover",
        "id": "3FFX2kPR9FGfqlYnylAV"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:03:25.000",
        "data": {
            "detail_level": "high",
            "section_id": "8ab37932-2678-4985-b380-b6109d821347",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "3yAWbW0WBHlYau0rYpmz"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:03:25.000",
        "data": {
            "detail_level": "high",
            "section_id": "8ab37932-2678-4985-b380-b6109d821347",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "5NqVuCISvukcRsNL2vvy"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:03:25.000",
        "data": {
            "detail_level": "high",
            "section_id": "8ab37932-2678-4985-b380-b6109d821347",
            "structured_type": "structured",
            "mapping_index": 4
        },
        "event": "mapping_hover",
        "id": "9CdTmSEKN1padbUp9lFs"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:03:25.000",
        "data": {
            "detail_level": "high",
            "section_id": "8ab37932-2678-4985-b380-b6109d821347",
            "structured_type": "structured",
            "mapping_index": 8
        },
        "event": "mapping_hover",
        "id": "D2mgTFjaBakBf8jC0n1q"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:03:25.000",
        "data": {
            "detail_level": "high",
            "section_id": "8ab37932-2678-4985-b380-b6109d821347",
            "structured_type": "structured",
            "mapping_index": 9
        },
        "event": "mapping_hover",
        "id": "DiTcXr2a1aQ6ukVTVQ3x"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:03:25.000",
        "data": {
            "detail_level": "high",
            "section_id": "8ab37932-2678-4985-b380-b6109d821347",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "FDEXkaRUybZ8Pu1OikcO"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:03:25.000",
        "data": {
            "detail_level": "high",
            "section_id": "8ab37932-2678-4985-b380-b6109d821347",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "FOGi03mbBHFAfg5zOZRN"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:03:25.000",
        "data": {
            "detail_level": "high",
            "section_id": "8ab37932-2678-4985-b380-b6109d821347",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "Fc7VLhSB4npPXDIb6dJk"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:03:25.000",
        "data": {
            "detail_level": "high",
            "section_id": "8ab37932-2678-4985-b380-b6109d821347",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "G8UGMPBQ5zkVU2Z8mi9L"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:03:25.000",
        "data": {
            "detail_level": "high",
            "section_id": "8ab37932-2678-4985-b380-b6109d821347",
            "structured_type": "structured",
            "mapping_index": 3
        },
        "event": "mapping_hover",
        "id": "IwO8aMxScZ9rCfqYe3g8"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:03:25.000",
        "data": {
            "detail_level": "high",
            "section_id": "8ab37932-2678-4985-b380-b6109d821347",
            "structured_type": "structured",
            "mapping_index": 4
        },
        "event": "mapping_hover",
        "id": "N9UotD1mEwkOBPoqzKYm"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:03:25.000",
        "data": {
            "detail_level": "high",
            "section_id": "8ab37932-2678-4985-b380-b6109d821347",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "Yx6gZbLibDDuISFlAyfu"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:03:25.000",
        "data": {
            "detail_level": "high",
            "section_id": "8ab37932-2678-4985-b380-b6109d821347",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "aRAGUA8FOHZExxUhNoWe"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:03:25.000",
        "data": {
            "detail_level": "high",
            "section_id": "8ab37932-2678-4985-b380-b6109d821347",
            "structured_type": "structured",
            "mapping_index": 1
        },
        "event": "mapping_hover",
        "id": "bmdFZSaFyKeOYdm8NUg6"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:03:25.000",
        "data": {
            "detail_level": "high",
            "section_id": "8ab37932-2678-4985-b380-b6109d821347",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "chxCGoUdieqN5RVLa6xL"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:03:25.000",
        "data": {
            "detail_level": "high",
            "section_id": "8ab37932-2678-4985-b380-b6109d821347",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "d6dCgEmuZpezWg7S5L5f"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:03:25.000",
        "data": {
            "before_detail_level": "high",
            "before_structured": "unstructured",
            "section_id": "8ab37932-2678-4985-b380-b6109d821347",
            "after_detail_level": "high",
            "after_structured": "structured"
        },
        "event": "change_summary_level",
        "id": "j3gMs5mD79oQL2vUcqL2"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:03:25.000",
        "data": {
            "detail_level": "high",
            "section_id": "8ab37932-2678-4985-b380-b6109d821347",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "liqD9xBs1IgPBmPJxX3J"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:03:25.000",
        "data": {
            "detail_level": "high",
            "section_id": "8ab37932-2678-4985-b380-b6109d821347",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "mcZExPj12BW5i8ACsTW7"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:03:25.000",
        "data": {
            "detail_level": "high",
            "section_id": "8ab37932-2678-4985-b380-b6109d821347",
            "structured_type": "structured",
            "mapping_index": 8
        },
        "event": "mapping_hover",
        "id": "nt5Sh774l1kvrZ8kunZz"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:03:25.000",
        "data": {
            "detail_level": "high",
            "section_id": "8ab37932-2678-4985-b380-b6109d821347",
            "structured_type": "structured",
            "mapping_index": 5
        },
        "event": "mapping_hover",
        "id": "p6FM7hzbFEJjXq7hiuH3"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:03:25.000",
        "data": {
            "detail_level": "high",
            "section_id": "8ab37932-2678-4985-b380-b6109d821347",
            "structured_type": "structured",
            "mapping_index": 0
        },
        "event": "mapping_hover",
        "id": "sFf9g3Wktku6YyFg00Fh"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:03:25.000",
        "data": {
            "detail_level": "high",
            "section_id": "8ab37932-2678-4985-b380-b6109d821347",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "sao63rKtQChRT2ArwpJe"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:03:25.000",
        "data": {
            "detail_level": "high",
            "section_id": "8ab37932-2678-4985-b380-b6109d821347",
            "structured_type": "structured",
            "mapping_index": 2
        },
        "event": "mapping_hover",
        "id": "uYB9uqCO5o8G3jSzETHy"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:03:25.000",
        "data": {
            "detail_level": "high",
            "section_id": "8ab37932-2678-4985-b380-b6109d821347",
            "structured_type": "structured",
            "mapping_index": 7
        },
        "event": "mapping_hover",
        "id": "xauzCvfNAWQVrSvHsrAu"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:03:25.000",
        "data": {
            "detail_level": "high",
            "section_id": "8ab37932-2678-4985-b380-b6109d821347",
            "structured_type": "structured",
            "mapping_index": 6
        },
        "event": "mapping_hover",
        "id": "y4u3yXydJ7eyJZtjcuk1"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:03:25.000",
        "data": {
            "detail_level": "high",
            "section_id": "8ab37932-2678-4985-b380-b6109d821347",
            "structured_type": "structured",
            "mapping_index": 5
        },
        "event": "mapping_hover",
        "id": "zRVrxcDXc0Qds1O1aicV"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:03:25.000",
        "data": {
            "detail_level": "high",
            "section_id": "8ab37932-2678-4985-b380-b6109d821347",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "zbPiXhWHQV2Ik6dNvxEi"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:03:26.000",
        "data": {
            "detail_level": "high",
            "section_id": "8ab37932-2678-4985-b380-b6109d821347",
            "structured_type": "structured",
            "mapping_index": 0
        },
        "event": "mapping_hover",
        "id": "LLXxWKKydJKmQwErn0tb"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:03:26.000",
        "data": {
            "detail_level": "high",
            "section_id": "8ab37932-2678-4985-b380-b6109d821347",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "RKyFX0MQnclGOhZvAL3D"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:03:26.000",
        "data": {
            "detail_level": "high",
            "section_id": "8ab37932-2678-4985-b380-b6109d821347",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "VxfyN3N56kaBNquxrb8o"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:03:26.000",
        "data": {
            "detail_level": "high",
            "section_id": "8ab37932-2678-4985-b380-b6109d821347",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "YvYDnUUDBYT5wqbysjZR"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:03:26.000",
        "data": {
            "detail_level": "high",
            "section_id": "8ab37932-2678-4985-b380-b6109d821347",
            "structured_type": "structured",
            "mapping_index": 2
        },
        "event": "mapping_hover",
        "id": "c9s3cSWLN2mSxn8rQLXb"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:03:26.000",
        "data": {
            "detail_level": "high",
            "section_id": "8ab37932-2678-4985-b380-b6109d821347",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "gPgXq25YJrkAOCoBOriI"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:03:26.000",
        "data": {
            "detail_level": "high",
            "section_id": "8ab37932-2678-4985-b380-b6109d821347",
            "structured_type": "structured",
            "mapping_index": 3
        },
        "event": "mapping_hover",
        "id": "jqFer172qAMrC7VFhQdO"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:03:26.000",
        "data": {
            "detail_level": "high",
            "section_id": "8ab37932-2678-4985-b380-b6109d821347",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "p6b16KXc55iqziooHn7w"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:03:26.000",
        "data": {
            "detail_level": "high",
            "section_id": "8ab37932-2678-4985-b380-b6109d821347",
            "structured_type": "structured",
            "mapping_index": 1
        },
        "event": "mapping_hover",
        "id": "xKpzCLg2V51T5u8n1Fp7"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:03:27.000",
        "data": {
            "detail_level": "low",
            "section_id": "8ab37932-2678-4985-b380-b6109d821347",
            "structured_type": "structured",
            "mapping_index": 4
        },
        "event": "mapping_hover",
        "id": "2muZWwpvKrSLazOZv32t"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:03:27.000",
        "data": {
            "detail_level": "low",
            "section_id": "8ab37932-2678-4985-b380-b6109d821347",
            "structured_type": "structured",
            "mapping_index": 0
        },
        "event": "mapping_hover",
        "id": "DrqC0cQlZ4PsUTCUQ5tx"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:03:27.000",
        "data": {
            "detail_level": "low",
            "section_id": "8ab37932-2678-4985-b380-b6109d821347",
            "structured_type": "structured",
            "mapping_index": 3
        },
        "event": "mapping_hover",
        "id": "Hfu5OyhfRqs3TVwT6zv2"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:03:27.000",
        "data": {
            "detail_level": "low",
            "section_id": "8ab37932-2678-4985-b380-b6109d821347",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "KhRNS1EEqKBFIJggB9XE"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:03:27.000",
        "data": {
            "detail_level": "low",
            "section_id": "8ab37932-2678-4985-b380-b6109d821347",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "T1N38N4PugSUCZnKwNeg"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:03:27.000",
        "data": {
            "before_detail_level": "high",
            "before_structured": "structured",
            "section_id": "8ab37932-2678-4985-b380-b6109d821347",
            "after_detail_level": "low",
            "after_structured": "structured"
        },
        "event": "change_summary_level",
        "id": "UhboAEDoE9yeaDImM1IV"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:03:27.000",
        "data": {
            "detail_level": "low",
            "section_id": "8ab37932-2678-4985-b380-b6109d821347",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "XXcR6YPYfGhEK8RAHUgG"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:03:27.000",
        "data": {
            "detail_level": "low",
            "section_id": "8ab37932-2678-4985-b380-b6109d821347",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "dxKKUNs65FgimSR7wG2u"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:03:27.000",
        "data": {
            "detail_level": "low",
            "section_id": "8ab37932-2678-4985-b380-b6109d821347",
            "structured_type": "structured",
            "mapping_index": 1
        },
        "event": "mapping_hover",
        "id": "oobHa97PQDw3dG8tZdjt"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:03:27.000",
        "data": {
            "detail_level": "low",
            "section_id": "8ab37932-2678-4985-b380-b6109d821347",
            "structured_type": "structured",
            "mapping_index": 3
        },
        "event": "mapping_hover",
        "id": "pjE5AzQ0BfjpF8gN9ZFB"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:03:28.000",
        "data": {
            "detail_level": "low",
            "section_id": "8ab37932-2678-4985-b380-b6109d821347",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "XSC0opopqyKThepQBdo8"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:03:28.000",
        "data": {
            "detail_level": "low",
            "section_id": "8ab37932-2678-4985-b380-b6109d821347",
            "structured_type": "structured",
            "mapping_index": 1
        },
        "event": "mapping_hover",
        "id": "uIY614BxuT898BTGR4F8"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:03:29.000",
        "data": {
            "detail_level": "low",
            "section_id": "8ab37932-2678-4985-b380-b6109d821347",
            "structured_type": "structured",
            "mapping_index": 0
        },
        "event": "mapping_hover",
        "id": "0IMAi3OPvyeuzskQQTqv"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:03:29.000",
        "data": {
            "detail_level": "low",
            "section_id": "8ab37932-2678-4985-b380-b6109d821347",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "4fWbF8anl12uc1FlMRqN"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:03:29.000",
        "data": {
            "detail_level": "low",
            "section_id": "8ab37932-2678-4985-b380-b6109d821347",
            "structured_type": "structured",
            "mapping_index": 1
        },
        "event": "mapping_hover",
        "id": "94xX0xm7oD41umsNk5S3"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:03:29.000",
        "data": {
            "detail_level": "low",
            "section_id": "8ab37932-2678-4985-b380-b6109d821347",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "CgaHYZBltOMqq4SMi5pJ"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:03:30.000",
        "data": {
            "detail_level": "low",
            "section_id": "8ab37932-2678-4985-b380-b6109d821347",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "MTWG3TJDb6TBj6uHjeiD"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:03:30.000",
        "data": {
            "detail_level": "low",
            "section_id": "8ab37932-2678-4985-b380-b6109d821347",
            "structured_type": "structured",
            "mapping_index": 2
        },
        "event": "mapping_hover",
        "id": "RglR8OltaqPAjAXvHXXc"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:03:30.000",
        "data": {
            "detail_level": "low",
            "section_id": "8ab37932-2678-4985-b380-b6109d821347",
            "structured_type": "structured",
            "mapping_index": 3
        },
        "event": "mapping_hover",
        "id": "eU1vSc95x3gvMRLOQ7I8"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:03:30.000",
        "data": {
            "detail_level": "low",
            "section_id": "8ab37932-2678-4985-b380-b6109d821347",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "vnTumFNaYoTHEaiMDMnG"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:03:31.000",
        "data": {
            "detail_level": "low",
            "section_id": "8ab37932-2678-4985-b380-b6109d821347",
            "structured_type": "structured",
            "mapping_index": 4
        },
        "event": "mapping_hover",
        "id": "0ilWr1M4NjvfDE07zIVA"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:03:31.000",
        "data": {
            "detail_level": "low",
            "section_id": "8ab37932-2678-4985-b380-b6109d821347",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "DqvSed454Ao9rk6EIVIZ"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:03:31.000",
        "data": {
            "detail_level": "low",
            "section_id": "8ab37932-2678-4985-b380-b6109d821347",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "IlkMKeP6NrhYzU7Wz23N"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:03:31.000",
        "data": {
            "detail_level": "low",
            "section_id": "8ab37932-2678-4985-b380-b6109d821347",
            "structured_type": "structured",
            "mapping_index": 3
        },
        "event": "mapping_hover",
        "id": "LCMxYsHyeWoYPRvkfH4X"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:03:31.000",
        "data": {
            "detail_level": "low",
            "section_id": "8ab37932-2678-4985-b380-b6109d821347",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "OS4pB6AyddG61WS4xAPx"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:03:31.000",
        "data": {
            "detail_level": "low",
            "section_id": "8ab37932-2678-4985-b380-b6109d821347",
            "structured_type": "structured",
            "mapping_index": 4
        },
        "event": "mapping_hover",
        "id": "mP4Ry6qoFVqhZzbfdRTa"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:03:31.000",
        "data": {
            "detail_level": "low",
            "section_id": "8ab37932-2678-4985-b380-b6109d821347",
            "structured_type": "structured",
            "mapping_index": 3
        },
        "event": "mapping_hover",
        "id": "necVXbBkDgmC8C7Z95J2"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:03:31.000",
        "data": {
            "detail_level": "low",
            "section_id": "8ab37932-2678-4985-b380-b6109d821347",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "oz7ZMUrYKvlMhukS4JqT"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:03:32.000",
        "data": {
            "detail_level": "medium",
            "section_id": "8ab37932-2678-4985-b380-b6109d821347",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "6hbdKXIV9BFsXDBBNGnZ"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:03:32.000",
        "data": {
            "detail_level": "medium",
            "section_id": "8ab37932-2678-4985-b380-b6109d821347",
            "structured_type": "structured",
            "mapping_index": 3
        },
        "event": "mapping_hover",
        "id": "CTqItBgU6yUxguP2h6pF"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:03:32.000",
        "data": {
            "detail_level": "medium",
            "section_id": "8ab37932-2678-4985-b380-b6109d821347",
            "structured_type": "structured",
            "mapping_index": 1
        },
        "event": "mapping_hover",
        "id": "JX8t14lWlDqntnQNcvpk"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:03:32.000",
        "data": {
            "detail_level": "medium",
            "section_id": "8ab37932-2678-4985-b380-b6109d821347",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "WhVUTYXWZ9Cp1bmTPTAJ"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:03:32.000",
        "data": {
            "detail_level": "medium",
            "section_id": "8ab37932-2678-4985-b380-b6109d821347",
            "structured_type": "structured",
            "mapping_index": 2
        },
        "event": "mapping_hover",
        "id": "ckqN2DRYB8S9XbHg3yVM"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:03:32.000",
        "data": {
            "detail_level": "medium",
            "section_id": "8ab37932-2678-4985-b380-b6109d821347",
            "structured_type": "structured",
            "mapping_index": 0
        },
        "event": "mapping_hover",
        "id": "mTLaqSxvGfH2E8RzKUZW"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:03:32.000",
        "data": {
            "detail_level": "low",
            "section_id": "8ab37932-2678-4985-b380-b6109d821347",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "nOUKxRdvbYSAZ49pvD23"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:03:32.000",
        "data": {
            "detail_level": "low",
            "section_id": "8ab37932-2678-4985-b380-b6109d821347",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "rbOt9CJXvymJohFH3lFD"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:03:32.000",
        "data": {
            "detail_level": "low",
            "section_id": "8ab37932-2678-4985-b380-b6109d821347",
            "structured_type": "structured",
            "mapping_index": 1
        },
        "event": "mapping_hover",
        "id": "sCWOAJeT0odNxuJU7PoJ"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:03:32.000",
        "data": {
            "detail_level": "medium",
            "section_id": "8ab37932-2678-4985-b380-b6109d821347",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "yuaYanVUYLYwTFfEBUxk"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:03:32.000",
        "data": {
            "before_detail_level": "low",
            "before_structured": "structured",
            "section_id": "8ab37932-2678-4985-b380-b6109d821347",
            "after_detail_level": "medium",
            "after_structured": "structured"
        },
        "event": "change_summary_level",
        "id": "zEr5zJgrb85fwTrdj8hs"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:03:33.000",
        "data": {
            "detail_level": "medium",
            "section_id": "8ab37932-2678-4985-b380-b6109d821347",
            "structured_type": "structured",
            "mapping_index": 0
        },
        "event": "mapping_hover",
        "id": "AYnNcFX0S0MaafFukwaS"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:03:33.000",
        "data": {
            "detail_level": "medium",
            "section_id": "8ab37932-2678-4985-b380-b6109d821347",
            "structured_type": "structured",
            "mapping_index": 1
        },
        "event": "mapping_hover",
        "id": "GG7cTMceFOWXP2gSzQA1"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:03:33.000",
        "data": {
            "detail_level": "medium",
            "section_id": "8ab37932-2678-4985-b380-b6109d821347",
            "structured_type": "structured",
            "mapping_index": 2
        },
        "event": "mapping_hover",
        "id": "Yon8yFWouBcuibp8W5MJ"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:03:33.000",
        "data": {
            "detail_level": "medium",
            "section_id": "8ab37932-2678-4985-b380-b6109d821347",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "dkCUrPNenQcvOnEmRC5c"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:03:33.000",
        "data": {
            "detail_level": "medium",
            "section_id": "8ab37932-2678-4985-b380-b6109d821347",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "emtBDtclPtGI1d6i5vdG"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:03:33.000",
        "data": {
            "detail_level": "medium",
            "section_id": "8ab37932-2678-4985-b380-b6109d821347",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "symVy7WJfjhI2EmFMFit"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:03:35.000",
        "data": {
            "detail_level": "medium",
            "section_id": "8ab37932-2678-4985-b380-b6109d821347",
            "structured_type": "structured",
            "mapping_index": 1
        },
        "event": "mapping_hover",
        "id": "0Abc0waXpnUgQgKaqRdV"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:03:35.000",
        "data": {
            "detail_level": "medium",
            "section_id": "8ab37932-2678-4985-b380-b6109d821347",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "KfeAwkLq00tAt1315n35"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:03:35.000",
        "data": {
            "detail_level": "medium",
            "section_id": "8ab37932-2678-4985-b380-b6109d821347",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "SUjfSSC4SEIpyBmP2anW"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:03:35.000",
        "data": {
            "detail_level": "medium",
            "section_id": "8ab37932-2678-4985-b380-b6109d821347",
            "structured_type": "structured",
            "mapping_index": 2
        },
        "event": "mapping_hover",
        "id": "zLiqfpiXlcBlAoxxlXIn"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:03:36.000",
        "data": {
            "detail_level": "medium",
            "section_id": "8ab37932-2678-4985-b380-b6109d821347",
            "structured_type": "structured",
            "mapping_index": 1
        },
        "event": "mapping_hover",
        "id": "D9vXbl1tV5WHLSdQBU2Y"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:03:36.000",
        "data": {
            "detail_level": "medium",
            "section_id": "8ab37932-2678-4985-b380-b6109d821347",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "Ll6lU6sTR4ycRv1H7Dp1"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:03:37.000",
        "data": {
            "detail_level": "medium",
            "section_id": "8ab37932-2678-4985-b380-b6109d821347",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "6Fnjo6j2noT4KqUDllO0"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:03:37.000",
        "data": {
            "detail_level": "medium",
            "section_id": "8ab37932-2678-4985-b380-b6109d821347",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "stY7zCA1c2yMwSPNaTqK"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:03:37.000",
        "data": {
            "detail_level": "medium",
            "section_id": "8ab37932-2678-4985-b380-b6109d821347",
            "structured_type": "structured",
            "mapping_index": 0
        },
        "event": "mapping_hover",
        "id": "zPYyLb4zoeNQgAZsFHHX"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:03:38.000",
        "data": {
            "before_detail_level": "medium",
            "before_structured": "structured",
            "section_id": "8ab37932-2678-4985-b380-b6109d821347",
            "after_detail_level": "medium",
            "after_structured": "unstructured"
        },
        "event": "change_summary_level",
        "id": "5OaGMk0z3tnm1HCo2gkt"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:03:38.000",
        "data": {
            "detail_level": "medium",
            "section_id": "8ab37932-2678-4985-b380-b6109d821347",
            "structured_type": "unstructured",
            "mapping_index": 0
        },
        "event": "mapping_hover",
        "id": "gfZ4qhX2OeorQn4Zoh9G"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:03:39.000",
        "data": {
            "detail_level": "medium",
            "section_id": "8ab37932-2678-4985-b380-b6109d821347",
            "structured_type": "unstructured",
            "mapping_index": 0
        },
        "event": "mapping_hover",
        "id": "7mT3dJdCtR4xzyGnlIhW"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:03:39.000",
        "data": {
            "detail_level": "medium",
            "section_id": "8ab37932-2678-4985-b380-b6109d821347",
            "structured_type": "unstructured",
            "mapping_index": 1
        },
        "event": "mapping_hover",
        "id": "UE560Pk2wDCVMtkG8KE3"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:03:39.000",
        "data": {
            "detail_level": "medium",
            "section_id": "8ab37932-2678-4985-b380-b6109d821347",
            "structured_type": "unstructured"
        },
        "event": "mapping_unhover",
        "id": "ZcoiaMzC5FzvakMyxtho"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:03:39.000",
        "data": {
            "detail_level": "medium",
            "section_id": "8ab37932-2678-4985-b380-b6109d821347",
            "structured_type": "unstructured"
        },
        "event": "mapping_unhover",
        "id": "ddgkb6Z30VBQ8bkYQ8DJ"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:03:40.000",
        "data": {
            "detail_level": "medium",
            "section_id": "8ab37932-2678-4985-b380-b6109d821347",
            "structured_type": "unstructured"
        },
        "event": "mapping_unhover",
        "id": "EWGCr3voE3f4Ui4rMTUp"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:03:40.000",
        "data": {
            "detail_level": "medium",
            "section_id": "8ab37932-2678-4985-b380-b6109d821347",
            "structured_type": "unstructured"
        },
        "event": "mapping_unhover",
        "id": "IvCGkhDLhLXTtgjFGYKv"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:03:40.000",
        "data": {
            "detail_level": "medium",
            "section_id": "8ab37932-2678-4985-b380-b6109d821347",
            "structured_type": "unstructured",
            "mapping_index": 3
        },
        "event": "mapping_hover",
        "id": "YtN90GqND058o24MRmSW"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:03:40.000",
        "data": {
            "detail_level": "medium",
            "section_id": "8ab37932-2678-4985-b380-b6109d821347",
            "structured_type": "unstructured",
            "mapping_index": 2
        },
        "event": "mapping_hover",
        "id": "x3aKDjfFPSDlscvU4hGN"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:03:41.000",
        "data": {
            "detail_level": "medium",
            "section_id": "8ab37932-2678-4985-b380-b6109d821347",
            "structured_type": "unstructured"
        },
        "event": "mapping_unhover",
        "id": "5uWPnHMdb1i7DU1NfkWq"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:03:41.000",
        "data": {
            "detail_level": "medium",
            "section_id": "8ab37932-2678-4985-b380-b6109d821347",
            "structured_type": "unstructured"
        },
        "event": "mapping_unhover",
        "id": "Ucc9J4AzqThz1hkBI1UB"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:03:41.000",
        "data": {
            "detail_level": "medium",
            "section_id": "8ab37932-2678-4985-b380-b6109d821347",
            "structured_type": "unstructured",
            "mapping_index": 2
        },
        "event": "mapping_hover",
        "id": "VWal93l5BT6iyN65FVnI"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:03:41.000",
        "data": {
            "detail_level": "medium",
            "section_id": "8ab37932-2678-4985-b380-b6109d821347",
            "structured_type": "unstructured",
            "mapping_index": 0
        },
        "event": "mapping_hover",
        "id": "gkaoC2VmvLtf9UIndcoP"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:03:41.000",
        "data": {
            "detail_level": "medium",
            "section_id": "8ab37932-2678-4985-b380-b6109d821347",
            "structured_type": "unstructured"
        },
        "event": "mapping_unhover",
        "id": "uE89uQNwQNmJ4Ciyso3G"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:03:42.000",
        "data": {
            "detail_level": "medium",
            "section_id": "8ab37932-2678-4985-b380-b6109d821347",
            "structured_type": "unstructured",
            "mapping_index": 2
        },
        "event": "mapping_hover",
        "id": "9NQPdDGGwRyQ0KitClfC"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:03:42.000",
        "data": {
            "detail_level": "medium",
            "section_id": "8ab37932-2678-4985-b380-b6109d821347",
            "structured_type": "unstructured",
            "mapping_index": 1
        },
        "event": "mapping_hover",
        "id": "fLyOzFC8RJ12OQsda7UT"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:03:42.000",
        "data": {
            "detail_level": "medium",
            "section_id": "8ab37932-2678-4985-b380-b6109d821347",
            "structured_type": "unstructured"
        },
        "event": "mapping_unhover",
        "id": "hebaiU0LVKqFYM7KrSwa"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:03:42.000",
        "data": {
            "detail_level": "medium",
            "section_id": "8ab37932-2678-4985-b380-b6109d821347",
            "structured_type": "unstructured",
            "mapping_index": 3
        },
        "event": "mapping_hover",
        "id": "nxPQsTIy79CpVm9CwiEP"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:03:42.000",
        "data": {
            "detail_level": "medium",
            "section_id": "8ab37932-2678-4985-b380-b6109d821347",
            "structured_type": "unstructured"
        },
        "event": "mapping_unhover",
        "id": "oAU7ReRoV4Tad8NZ7g1m"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:03:43.000",
        "data": {
            "detail_level": "medium",
            "section_id": "8ab37932-2678-4985-b380-b6109d821347",
            "structured_type": "unstructured"
        },
        "event": "mapping_unhover",
        "id": "BRmzHxu8nd0OgJ7UM9aF"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:03:43.000",
        "data": {
            "detail_level": "medium",
            "section_id": "8ab37932-2678-4985-b380-b6109d821347",
            "structured_type": "unstructured",
            "mapping_index": 2
        },
        "event": "mapping_hover",
        "id": "i7RwM0gpjD0BjMUaW1w1"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:03:43.000",
        "data": {
            "detail_level": "medium",
            "section_id": "8ab37932-2678-4985-b380-b6109d821347",
            "structured_type": "unstructured",
            "mapping_index": 4
        },
        "event": "mapping_hover",
        "id": "qwQcdBolNRZqdvfzjXDP"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:03:43.000",
        "data": {
            "detail_level": "medium",
            "section_id": "8ab37932-2678-4985-b380-b6109d821347",
            "structured_type": "unstructured"
        },
        "event": "mapping_unhover",
        "id": "rc5ou77e6ETTMos44jGJ"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:03:44.000",
        "data": {
            "detail_level": "medium",
            "section_id": "8ab37932-2678-4985-b380-b6109d821347",
            "structured_type": "unstructured"
        },
        "event": "mapping_unhover",
        "id": "DkkUvcx66J8I8mO4iyKM"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:03:44.000",
        "data": {
            "detail_level": "medium",
            "section_id": "8ab37932-2678-4985-b380-b6109d821347",
            "structured_type": "unstructured",
            "mapping_index": 6
        },
        "event": "mapping_hover",
        "id": "EwT0xjVYVqMbhmerG14a"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:03:44.000",
        "data": {
            "detail_level": "medium",
            "section_id": "8ab37932-2678-4985-b380-b6109d821347",
            "structured_type": "unstructured",
            "mapping_index": 6
        },
        "event": "mapping_hover",
        "id": "PJB2IXG6SLfzSwesZE9D"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:03:44.000",
        "data": {
            "detail_level": "medium",
            "section_id": "8ab37932-2678-4985-b380-b6109d821347",
            "structured_type": "unstructured"
        },
        "event": "mapping_unhover",
        "id": "ZvQUDAobqrN5SgBXIrse"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:03:44.000",
        "data": {
            "detail_level": "medium",
            "section_id": "8ab37932-2678-4985-b380-b6109d821347",
            "structured_type": "unstructured"
        },
        "event": "mapping_unhover",
        "id": "e85If7PmdfpiSK0gkdfU"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:03:44.000",
        "data": {
            "detail_level": "medium",
            "section_id": "8ab37932-2678-4985-b380-b6109d821347",
            "structured_type": "unstructured",
            "mapping_index": 5
        },
        "event": "mapping_hover",
        "id": "ws1iRvE8Wid2szUJytQ6"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:03:45.000",
        "data": {
            "detail_level": "medium",
            "section_id": "8ab37932-2678-4985-b380-b6109d821347",
            "structured_type": "unstructured"
        },
        "event": "mapping_unhover",
        "id": "4PnBTzQaVTw7X1PqLbr8"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:03:45.000",
        "data": {
            "detail_level": "medium",
            "section_id": "8ab37932-2678-4985-b380-b6109d821347",
            "structured_type": "unstructured",
            "mapping_index": 0
        },
        "event": "mapping_hover",
        "id": "IkshebNVTjv6eGdvqaik"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:03:45.000",
        "data": {
            "detail_level": "medium",
            "section_id": "8ab37932-2678-4985-b380-b6109d821347",
            "structured_type": "unstructured"
        },
        "event": "mapping_unhover",
        "id": "MoHQxnVWQjgx3kCRBqTa"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:03:45.000",
        "data": {
            "detail_level": "medium",
            "section_id": "8ab37932-2678-4985-b380-b6109d821347",
            "structured_type": "unstructured"
        },
        "event": "mapping_unhover",
        "id": "QumgYHrTRGNX1fVCvbJ4"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:03:45.000",
        "data": {
            "detail_level": "medium",
            "section_id": "8ab37932-2678-4985-b380-b6109d821347",
            "structured_type": "unstructured",
            "mapping_index": 5
        },
        "event": "mapping_hover",
        "id": "ae01fKatHVOvQFciVGDB"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:03:45.000",
        "data": {
            "detail_level": "medium",
            "section_id": "8ab37932-2678-4985-b380-b6109d821347",
            "structured_type": "unstructured"
        },
        "event": "mapping_unhover",
        "id": "mNDlMZ4zYD6pz1StB9uE"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:03:45.000",
        "data": {
            "detail_level": "medium",
            "section_id": "8ab37932-2678-4985-b380-b6109d821347",
            "structured_type": "unstructured",
            "mapping_index": 2
        },
        "event": "mapping_hover",
        "id": "tdRsHkwTGF7gEkP0NMEo"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:03:47.000",
        "data": {
            "before_detail_level": "medium",
            "before_structured": "structured",
            "section_id": "8ab37932-2678-4985-b380-b6109d821347",
            "after_detail_level": "high",
            "after_structured": "structured"
        },
        "event": "change_summary_level",
        "id": "ER4mCksU2EJcy1vOGKYH"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:03:47.000",
        "data": {
            "before_detail_level": "medium",
            "before_structured": "unstructured",
            "section_id": "8ab37932-2678-4985-b380-b6109d821347",
            "after_detail_level": "medium",
            "after_structured": "structured"
        },
        "event": "change_summary_level",
        "id": "aDB794N20pRrqrvNBGXX"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:03:48.000",
        "data": {
            "detail_level": "high",
            "section_id": "8ab37932-2678-4985-b380-b6109d821347",
            "structured_type": "structured",
            "mapping_index": 0
        },
        "event": "mapping_hover",
        "id": "GO84UpauQMoLmW0Zp3xE"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:03:48.000",
        "data": {
            "detail_level": "high",
            "section_id": "8ab37932-2678-4985-b380-b6109d821347",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "MCPT3ODRQ9qqmjn3NpBy"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:03:48.000",
        "data": {
            "detail_level": "high",
            "section_id": "8ab37932-2678-4985-b380-b6109d821347",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "QrShHebTMKFusHvG1r2W"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:03:48.000",
        "data": {
            "detail_level": "high",
            "section_id": "8ab37932-2678-4985-b380-b6109d821347",
            "structured_type": "structured",
            "mapping_index": 1
        },
        "event": "mapping_hover",
        "id": "cVDIjBNj9C8U55W1ZwWx"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:03:48.000",
        "data": {
            "detail_level": "high",
            "section_id": "8ab37932-2678-4985-b380-b6109d821347",
            "structured_type": "structured",
            "mapping_index": 1
        },
        "event": "mapping_hover",
        "id": "yXczwpaXL23wsHR27d2C"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:03:49.000",
        "data": {
            "detail_level": "high",
            "section_id": "8ab37932-2678-4985-b380-b6109d821347",
            "structured_type": "structured",
            "mapping_index": 1
        },
        "event": "mapping_hover",
        "id": "50qhSbTjD4o0WRXR3Kyq"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:03:49.000",
        "data": {
            "detail_level": "high",
            "section_id": "8ab37932-2678-4985-b380-b6109d821347",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "5nF3lmWcTOJisQcbbC0K"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:03:49.000",
        "data": {
            "detail_level": "high",
            "section_id": "8ab37932-2678-4985-b380-b6109d821347",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "FrEtAcWm18jXzxS1PqGA"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:03:49.000",
        "data": {
            "detail_level": "high",
            "section_id": "8ab37932-2678-4985-b380-b6109d821347",
            "structured_type": "structured",
            "mapping_index": 0
        },
        "event": "mapping_hover",
        "id": "HnUXernq51Q28EkEjRUQ"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:03:50.000",
        "data": {
            "detail_level": "high",
            "section_id": "8ab37932-2678-4985-b380-b6109d821347",
            "structured_type": "structured",
            "mapping_index": 1
        },
        "event": "mapping_hover",
        "id": "QhpzMtH0MgD9QbavgDOt"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:03:50.000",
        "data": {
            "detail_level": "high",
            "section_id": "8ab37932-2678-4985-b380-b6109d821347",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "uIKZ7gVE2SO7GedqsFxL"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:03:53.000",
        "data": {
            "detail_level": "high",
            "section_id": "8ab37932-2678-4985-b380-b6109d821347",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "aDhxPIobKlC0bDQWKAtr"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:03:53.000",
        "data": {
            "detail_level": "high",
            "section_id": "8ab37932-2678-4985-b380-b6109d821347",
            "structured_type": "structured",
            "mapping_index": 1
        },
        "event": "mapping_hover",
        "id": "aOsbRIzYTxoARKV3P5Rp"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:03:53.000",
        "data": {
            "detail_level": "high",
            "section_id": "8ab37932-2678-4985-b380-b6109d821347",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "iSMl0QqTMVyX2x9wu60A"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:03:53.000",
        "data": {
            "detail_level": "high",
            "section_id": "8ab37932-2678-4985-b380-b6109d821347",
            "structured_type": "structured",
            "mapping_index": 2
        },
        "event": "mapping_hover",
        "id": "lgrqkpWqrVgo1LQiynfe"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:03:56.000",
        "data": {
            "detail_level": "high",
            "section_id": "8ab37932-2678-4985-b380-b6109d821347",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "IFbCfExneECn0Bm2sIzO"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:03:56.000",
        "data": {
            "detail_level": "high",
            "section_id": "8ab37932-2678-4985-b380-b6109d821347",
            "structured_type": "structured",
            "mapping_index": 3
        },
        "event": "mapping_hover",
        "id": "Lz7NYbr4L6tLDMQo5wCw"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:03:56.000",
        "data": {
            "detail_level": "high",
            "section_id": "8ab37932-2678-4985-b380-b6109d821347",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "l8fb9OBoS3xt0k3905cU"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:03:56.000",
        "data": {
            "detail_level": "high",
            "section_id": "8ab37932-2678-4985-b380-b6109d821347",
            "structured_type": "structured",
            "mapping_index": 2
        },
        "event": "mapping_hover",
        "id": "tHV3c2gGLszjTNkIKCor"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:03:57.000",
        "data": {
            "detail_level": "high",
            "section_id": "8ab37932-2678-4985-b380-b6109d821347",
            "structured_type": "structured",
            "mapping_index": 3
        },
        "event": "mapping_hover",
        "id": "AtQK2dMfdsusT82rFtYl"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:03:57.000",
        "data": {
            "detail_level": "high",
            "section_id": "8ab37932-2678-4985-b380-b6109d821347",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "VKX6rrF5ktX9XHMDwr6y"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:03:58.000",
        "data": {
            "detail_level": "high",
            "section_id": "8ab37932-2678-4985-b380-b6109d821347",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "KF8PBB0utJjUxiJgHhZA"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:03:58.000",
        "data": {
            "detail_level": "high",
            "section_id": "8ab37932-2678-4985-b380-b6109d821347",
            "structured_type": "structured",
            "mapping_index": 4
        },
        "event": "mapping_hover",
        "id": "S7OP6haaMSBvu1eAyVb6"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:03:59.000",
        "data": {
            "detail_level": "high",
            "section_id": "8ab37932-2678-4985-b380-b6109d821347",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "1q7Iae5PRNLcgtVGSarW"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:03:59.000",
        "data": {
            "detail_level": "high",
            "section_id": "8ab37932-2678-4985-b380-b6109d821347",
            "structured_type": "structured",
            "mapping_index": 5
        },
        "event": "mapping_hover",
        "id": "hGW7wWBsrskYp6bdxF4e"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:04:00.000",
        "data": {
            "detail_level": "high",
            "section_id": "8ab37932-2678-4985-b380-b6109d821347",
            "structured_type": "structured",
            "mapping_index": 6
        },
        "event": "mapping_hover",
        "id": "FAzVN40FJiV9Mb3m7Lp6"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:04:00.000",
        "data": {
            "detail_level": "high",
            "section_id": "8ab37932-2678-4985-b380-b6109d821347",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "Z9jser65bDkgKieg4VlF"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:04:01.000",
        "data": {
            "detail_level": "high",
            "section_id": "8ab37932-2678-4985-b380-b6109d821347",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "8vBrhqdOR3w0DbcN2iwy"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:04:01.000",
        "data": {
            "detail_level": "high",
            "section_id": "8ab37932-2678-4985-b380-b6109d821347",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "AcOhvnqjwVjP8jU2ypJ1"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:04:01.000",
        "data": {
            "detail_level": "high",
            "section_id": "8ab37932-2678-4985-b380-b6109d821347",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "NpFX7J7GBWu4hlpdWZTi"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:04:01.000",
        "data": {
            "detail_level": "high",
            "section_id": "8ab37932-2678-4985-b380-b6109d821347",
            "structured_type": "structured",
            "mapping_index": 8
        },
        "event": "mapping_hover",
        "id": "cLHDnK7mIB9S0bfmPUXR"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:04:01.000",
        "data": {
            "detail_level": "high",
            "section_id": "8ab37932-2678-4985-b380-b6109d821347",
            "structured_type": "structured",
            "mapping_index": 9
        },
        "event": "mapping_hover",
        "id": "t3btKz8foRYORuIXyBJ0"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:04:01.000",
        "data": {
            "detail_level": "high",
            "section_id": "8ab37932-2678-4985-b380-b6109d821347",
            "structured_type": "structured",
            "mapping_index": 7
        },
        "event": "mapping_hover",
        "id": "vQwBAtJbblc2tRhNmXEo"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:04:06.000",
        "data": {
            "detail_level": "high",
            "section_id": "8ab37932-2678-4985-b380-b6109d821347",
            "structured_type": "structured",
            "mapping_index": 8
        },
        "event": "mapping_hover",
        "id": "fAvfyjlArezBgYrhHWOI"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:04:06.000",
        "data": {
            "detail_level": "high",
            "section_id": "8ab37932-2678-4985-b380-b6109d821347",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "yZ2hoaRwFkQOFeRCIorz"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:04:08.000",
        "data": {
            "detail_level": "high",
            "section_id": "8ab37932-2678-4985-b380-b6109d821347",
            "structured_type": "structured",
            "mapping_index": 7
        },
        "event": "mapping_hover",
        "id": "7Z3k8ZyMf0unkl9fedEj"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:04:08.000",
        "data": {
            "detail_level": "high",
            "section_id": "8ab37932-2678-4985-b380-b6109d821347",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "8gIwB9hRVyQw4xLAGbza"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:04:08.000",
        "data": {
            "detail_level": "high",
            "section_id": "8ab37932-2678-4985-b380-b6109d821347",
            "structured_type": "structured",
            "mapping_index": 6
        },
        "event": "mapping_hover",
        "id": "DXUD4TyMOCYvpNaYarCC"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:04:08.000",
        "data": {
            "detail_level": "high",
            "section_id": "8ab37932-2678-4985-b380-b6109d821347",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "I8TsTlWbxk929BENTnJ1"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:04:08.000",
        "data": {
            "detail_level": "high",
            "section_id": "8ab37932-2678-4985-b380-b6109d821347",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "KuVsfB57pDg30AeX5nJk"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:04:08.000",
        "data": {
            "detail_level": "high",
            "section_id": "8ab37932-2678-4985-b380-b6109d821347",
            "structured_type": "structured",
            "mapping_index": 7
        },
        "event": "mapping_hover",
        "id": "wqfohIjl3t30cZrmy9QG"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:04:09.000",
        "data": {
            "detail_level": "high",
            "section_id": "8ab37932-2678-4985-b380-b6109d821347",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "560aEbujHDdMFtO8orDw"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:04:09.000",
        "data": {
            "detail_level": "high",
            "section_id": "8ab37932-2678-4985-b380-b6109d821347",
            "structured_type": "structured",
            "mapping_index": 6
        },
        "event": "mapping_hover",
        "id": "TnuhKTXJHRw9luegEJzk"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:04:09.000",
        "data": {
            "detail_level": "high",
            "section_id": "8ab37932-2678-4985-b380-b6109d821347",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "qU9urrlW52GnBbw9Xd62"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:04:10.000",
        "data": {
            "detail_level": "high",
            "section_id": "8ab37932-2678-4985-b380-b6109d821347",
            "structured_type": "structured",
            "mapping_index": 3
        },
        "event": "mapping_hover",
        "id": "0HlqTHLk1l7C2ibmt7OO"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:04:10.000",
        "data": {
            "detail_level": "high",
            "section_id": "8ab37932-2678-4985-b380-b6109d821347",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "8jfxFMdiEM8diwG0hwVx"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:04:10.000",
        "data": {
            "detail_level": "high",
            "section_id": "8ab37932-2678-4985-b380-b6109d821347",
            "structured_type": "structured",
            "mapping_index": 2
        },
        "event": "mapping_hover",
        "id": "EgnN00EvS01VvPUlKbez"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:04:10.000",
        "data": {
            "detail_level": "high",
            "section_id": "8ab37932-2678-4985-b380-b6109d821347",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "oPT5tLn6IX1SZ05J6LGK"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:04:10.000",
        "data": {
            "detail_level": "high",
            "section_id": "8ab37932-2678-4985-b380-b6109d821347",
            "structured_type": "structured",
            "mapping_index": 5
        },
        "event": "mapping_hover",
        "id": "yyAtfQezhjTc5aGULCfk"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:04:11.000",
        "data": {
            "detail_level": "high",
            "section_id": "8ab37932-2678-4985-b380-b6109d821347",
            "structured_type": "structured",
            "mapping_index": 7
        },
        "event": "mapping_hover",
        "id": "2zV0Hsn30XHKyFNKvIl1"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:04:11.000",
        "data": {
            "detail_level": "high",
            "section_id": "8ab37932-2678-4985-b380-b6109d821347",
            "structured_type": "structured",
            "mapping_index": 6
        },
        "event": "mapping_hover",
        "id": "Ftj0U3rD1XBI2Yr7oY8y"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:04:11.000",
        "data": {
            "detail_level": "high",
            "section_id": "8ab37932-2678-4985-b380-b6109d821347",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "Jhh1dPGJWUZYufJxOY4i"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:04:11.000",
        "data": {
            "detail_level": "high",
            "section_id": "8ab37932-2678-4985-b380-b6109d821347",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "XcendCym2BFNdkHEyLdE"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:04:11.000",
        "data": {
            "detail_level": "high",
            "section_id": "8ab37932-2678-4985-b380-b6109d821347",
            "structured_type": "structured",
            "mapping_index": 6
        },
        "event": "mapping_hover",
        "id": "ioO7GMwVCmAtciuO3mk0"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:04:11.000",
        "data": {
            "detail_level": "high",
            "section_id": "8ab37932-2678-4985-b380-b6109d821347",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "owNCJK2YS151aiqG0B1k"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:04:11.000",
        "data": {
            "detail_level": "high",
            "section_id": "8ab37932-2678-4985-b380-b6109d821347",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "zqHiQOhAeCA465ACexFY"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:04:38.000",
        "data": {
            "detail_level": "high",
            "section_id": "8ab37932-2678-4985-b380-b6109d821347",
            "structured_type": "structured",
            "mapping_index": 3
        },
        "event": "mapping_hover",
        "id": "1ynoiKdDi2PKSOM7eoJ3"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:04:38.000",
        "data": {
            "detail_level": "high",
            "section_id": "8ab37932-2678-4985-b380-b6109d821347",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "5L8y4b0YNDYZxyDyI5zD"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:04:38.000",
        "data": {
            "detail_level": "high",
            "section_id": "8ab37932-2678-4985-b380-b6109d821347",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "79MvbrLzJBFc0VCNRN99"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:04:38.000",
        "data": {
            "detail_level": "high",
            "section_id": "8ab37932-2678-4985-b380-b6109d821347",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "LS3oAt78HG3iqGagcCLJ"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:04:38.000",
        "data": {
            "detail_level": "high",
            "section_id": "8ab37932-2678-4985-b380-b6109d821347",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "YsJa0eLYuHP0H52mj3dd"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:04:38.000",
        "data": {
            "detail_level": "high",
            "section_id": "8ab37932-2678-4985-b380-b6109d821347",
            "structured_type": "structured",
            "mapping_index": 2
        },
        "event": "mapping_hover",
        "id": "Zot5G0JURnYmfCb2uxRh"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:04:38.000",
        "data": {
            "detail_level": "high",
            "section_id": "8ab37932-2678-4985-b380-b6109d821347",
            "structured_type": "structured",
            "mapping_index": 4
        },
        "event": "mapping_hover",
        "id": "iFOXoIKx8kl4NgiDVSQF"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:04:38.000",
        "data": {
            "detail_level": "high",
            "section_id": "8ab37932-2678-4985-b380-b6109d821347",
            "structured_type": "structured",
            "mapping_index": 3
        },
        "event": "mapping_hover",
        "id": "pfyZOEJujpl5Y5Z1cdzt"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:04:38.000",
        "data": {
            "detail_level": "high",
            "section_id": "8ab37932-2678-4985-b380-b6109d821347",
            "structured_type": "structured",
            "mapping_index": 1
        },
        "event": "mapping_hover",
        "id": "phdFra4LFct1uPWy4G54"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:04:39.000",
        "data": {
            "detail_level": "high",
            "section_id": "8ab37932-2678-4985-b380-b6109d821347",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "20BJPs5THMdfTpawzhXl"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:04:39.000",
        "data": {
            "detail_level": "high",
            "section_id": "8ab37932-2678-4985-b380-b6109d821347",
            "structured_type": "structured",
            "mapping_index": 2
        },
        "event": "mapping_hover",
        "id": "zCtDyuK73K5uDtX4rff8"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:04:40.000",
        "data": {
            "detail_level": "high",
            "section_id": "8ab37932-2678-4985-b380-b6109d821347",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "9el5eizpY9kYnmrzxAUR"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:04:40.000",
        "data": {
            "detail_level": "high",
            "section_id": "8ab37932-2678-4985-b380-b6109d821347",
            "structured_type": "structured",
            "mapping_index": 5
        },
        "event": "mapping_hover",
        "id": "AgsE4Ri12XwvHukCTLcx"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:04:40.000",
        "data": {
            "detail_level": "high",
            "section_id": "8ab37932-2678-4985-b380-b6109d821347",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "CuUTXGc2EqZ6fHsQZdPj"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:04:40.000",
        "data": {
            "detail_level": "high",
            "section_id": "8ab37932-2678-4985-b380-b6109d821347",
            "structured_type": "structured",
            "mapping_index": 3
        },
        "event": "mapping_hover",
        "id": "Lw6rEp1F1PircXQZZfkY"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:04:40.000",
        "data": {
            "detail_level": "high",
            "section_id": "8ab37932-2678-4985-b380-b6109d821347",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "MOuySgZ5b9Pggphl236W"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:04:40.000",
        "data": {
            "detail_level": "high",
            "section_id": "8ab37932-2678-4985-b380-b6109d821347",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "U2rQK8J5aV3BFLZd3wmY"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:04:40.000",
        "data": {
            "detail_level": "high",
            "section_id": "8ab37932-2678-4985-b380-b6109d821347",
            "structured_type": "structured",
            "mapping_index": 5
        },
        "event": "mapping_hover",
        "id": "WCbSHW5ji25Hkb9HCaov"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:04:40.000",
        "data": {
            "detail_level": "high",
            "section_id": "8ab37932-2678-4985-b380-b6109d821347",
            "structured_type": "structured",
            "mapping_index": 4
        },
        "event": "mapping_hover",
        "id": "b1R9OtL08ePBMkOIuScn"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:04:40.000",
        "data": {
            "detail_level": "high",
            "section_id": "8ab37932-2678-4985-b380-b6109d821347",
            "structured_type": "structured",
            "mapping_index": 6
        },
        "event": "mapping_hover",
        "id": "gLsgZRfFU6rVWzhebajJ"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:04:40.000",
        "data": {
            "detail_level": "high",
            "section_id": "8ab37932-2678-4985-b380-b6109d821347",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "t8ymDR3ZKGnwMTBBIfef"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:04:41.000",
        "data": {
            "detail_level": "high",
            "section_id": "8ab37932-2678-4985-b380-b6109d821347",
            "structured_type": "structured",
            "mapping_index": 2
        },
        "event": "mapping_hover",
        "id": "0dRGzJTse2yjeF4Q1xdS"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:04:41.000",
        "data": {
            "detail_level": "high",
            "section_id": "8ab37932-2678-4985-b380-b6109d821347",
            "structured_type": "structured",
            "mapping_index": 1
        },
        "event": "mapping_hover",
        "id": "8j2qZJZI0hpezG4Ovhcd"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:04:41.000",
        "data": {
            "detail_level": "high",
            "section_id": "8ab37932-2678-4985-b380-b6109d821347",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "8wxfk5DBjSjCoY2P62iQ"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:04:41.000",
        "data": {
            "detail_level": "high",
            "section_id": "8ab37932-2678-4985-b380-b6109d821347",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "JIzaL96I3KR7McUxsqyt"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:04:41.000",
        "data": {
            "detail_level": "high",
            "section_id": "8ab37932-2678-4985-b380-b6109d821347",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "K9ktL29ICRTNjWearCXw"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:04:41.000",
        "data": {
            "detail_level": "high",
            "section_id": "8ab37932-2678-4985-b380-b6109d821347",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "TcoEhO96P0ZtOSNr37We"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:04:41.000",
        "data": {
            "detail_level": "high",
            "section_id": "8ab37932-2678-4985-b380-b6109d821347",
            "structured_type": "structured",
            "mapping_index": 4
        },
        "event": "mapping_hover",
        "id": "XFaN7yPw6rbrWsiyF2ee"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:04:41.000",
        "data": {
            "detail_level": "high",
            "section_id": "8ab37932-2678-4985-b380-b6109d821347",
            "structured_type": "structured",
            "mapping_index": 0
        },
        "event": "mapping_hover",
        "id": "eq5ZIhSPLhwiZmMnq10O"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:04:41.000",
        "data": {
            "detail_level": "high",
            "section_id": "8ab37932-2678-4985-b380-b6109d821347",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "i6h3rVyk0CdMbmDkACo1"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:04:41.000",
        "data": {
            "detail_level": "high",
            "section_id": "8ab37932-2678-4985-b380-b6109d821347",
            "structured_type": "structured",
            "mapping_index": 2
        },
        "event": "mapping_hover",
        "id": "nGRaTA7bFMzrI3SqbsIX"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:04:41.000",
        "data": {
            "detail_level": "high",
            "section_id": "8ab37932-2678-4985-b380-b6109d821347",
            "structured_type": "structured",
            "mapping_index": 1
        },
        "event": "mapping_hover",
        "id": "nbCG4gTtkEQSZDAnATc8"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:04:41.000",
        "data": {
            "detail_level": "high",
            "section_id": "8ab37932-2678-4985-b380-b6109d821347",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "rhEWZcL9ojs2I80IOzgV"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:04:41.000",
        "data": {
            "detail_level": "high",
            "section_id": "8ab37932-2678-4985-b380-b6109d821347",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "upg8sFfHGBqwPCxDNHkB"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:04:41.000",
        "data": {
            "detail_level": "high",
            "section_id": "8ab37932-2678-4985-b380-b6109d821347",
            "structured_type": "structured",
            "mapping_index": 3
        },
        "event": "mapping_hover",
        "id": "xDiJ0Fl3cx4Rum8es7iz"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:04:43.000",
        "data": {
            "detail_level": "high",
            "section_id": "8ab37932-2678-4985-b380-b6109d821347",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "8VGnRjUDUZygnvWKmnBR"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:04:43.000",
        "data": {
            "detail_level": "high",
            "section_id": "8ab37932-2678-4985-b380-b6109d821347",
            "structured_type": "structured",
            "mapping_index": 1
        },
        "event": "mapping_hover",
        "id": "mP6KrEkKg6VUGnW4UaVH"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:04:43.000",
        "data": {
            "detail_level": "high",
            "section_id": "8ab37932-2678-4985-b380-b6109d821347",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "pYmKZGuyUO6DtBLqQSAn"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:04:44.000",
        "data": {
            "detail_level": "high",
            "section_id": "8ab37932-2678-4985-b380-b6109d821347",
            "structured_type": "structured",
            "mapping_index": 3
        },
        "event": "mapping_hover",
        "id": "4D9Ix4hiJr8Heo2KPw15"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:04:44.000",
        "data": {
            "detail_level": "high",
            "section_id": "8ab37932-2678-4985-b380-b6109d821347",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "Oq6TOjl66pFPAQydzU49"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:04:44.000",
        "data": {
            "detail_level": "high",
            "section_id": "8ab37932-2678-4985-b380-b6109d821347",
            "structured_type": "structured",
            "mapping_index": 2
        },
        "event": "mapping_hover",
        "id": "nhw2KU5TtmmLFEh2KmEe"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:04:44.000",
        "data": {
            "detail_level": "high",
            "section_id": "8ab37932-2678-4985-b380-b6109d821347",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "wocOgABOHLw65Iql6puB"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:04:48.000",
        "data": {
            "detail_level": "high",
            "section_id": "8ab37932-2678-4985-b380-b6109d821347",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "TYrjJdUft9Gu2Tmc0R7h"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:04:48.000",
        "data": {
            "detail_level": "high",
            "section_id": "8ab37932-2678-4985-b380-b6109d821347",
            "structured_type": "structured",
            "mapping_index": 3
        },
        "event": "mapping_hover",
        "id": "V98cO7n9TfUM37N9okZ3"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:04:48.000",
        "data": {
            "detail_level": "high",
            "section_id": "8ab37932-2678-4985-b380-b6109d821347",
            "structured_type": "structured",
            "mapping_index": 4
        },
        "event": "mapping_hover",
        "id": "vKBVr4tZKr0U0O0F3C69"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:04:49.000",
        "data": {
            "detail_level": "high",
            "section_id": "8ab37932-2678-4985-b380-b6109d821347",
            "structured_type": "structured",
            "mapping_index": 3
        },
        "event": "mapping_hover",
        "id": "GdMw0xvt8cq5wFYqIa0A"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:04:49.000",
        "data": {
            "detail_level": "high",
            "section_id": "8ab37932-2678-4985-b380-b6109d821347",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "iokCQPs83CSJt9yIQNp3"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:04:49.000",
        "data": {
            "detail_level": "high",
            "section_id": "8ab37932-2678-4985-b380-b6109d821347",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "nT8kXSXEnvRfinsoOFPx"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:06:46.000",
        "data": {
            "detail_level": "high",
            "section_id": "8ab37932-2678-4985-b380-b6109d821347",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "4U6CJUZ4C1M9O0cYufMx"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:06:46.000",
        "data": {
            "detail_level": "high",
            "section_id": "8ab37932-2678-4985-b380-b6109d821347",
            "structured_type": "structured",
            "mapping_index": 0
        },
        "event": "mapping_hover",
        "id": "f0AvMb1npfhgKYX9vpdW"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:07:10.000",
        "data": {},
        "event": "click_summarize_code",
        "id": "D4K8Pau5Is0S9JX4eoc9"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:07:11.000",
        "data": {
            "detail_level": "high",
            "section_id": "8ab37932-2678-4985-b380-b6109d821347",
            "structured_type": "structured",
            "mapping_index": 2
        },
        "event": "mapping_hover",
        "id": "6gc2P7ZKhvkGgQ89uWKa"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:07:11.000",
        "data": {
            "detail_level": "high",
            "section_id": "8ab37932-2678-4985-b380-b6109d821347",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "CX5VvW2nP527tIb1l6Bg"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:07:11.000",
        "data": {
            "detail_level": "high",
            "section_id": "8ab37932-2678-4985-b380-b6109d821347",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "GBO5OKoBosR9kXK32I3T"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:07:11.000",
        "data": {
            "detail_level": "high",
            "section_id": "8ab37932-2678-4985-b380-b6109d821347",
            "structured_type": "structured",
            "mapping_index": 1
        },
        "event": "mapping_hover",
        "id": "X0kE8J40PmvPPRha48lK"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:07:11.000",
        "data": {
            "detail_level": "high",
            "section_id": "8ab37932-2678-4985-b380-b6109d821347",
            "structured_type": "structured",
            "mapping_index": 3
        },
        "event": "mapping_hover",
        "id": "j7Cr7QosE5fSJzfeTSD2"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:07:11.000",
        "data": {
            "detail_level": "high",
            "section_id": "8ab37932-2678-4985-b380-b6109d821347",
            "structured_type": "structured",
            "mapping_index": 0
        },
        "event": "mapping_hover",
        "id": "m6tOIeuhn3ZEslAIEUwq"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:07:11.000",
        "data": {
            "detail_level": "high",
            "section_id": "8ab37932-2678-4985-b380-b6109d821347",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "mCxGlWZf3ZlQe5cKmA4e"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:07:11.000",
        "data": {
            "detail_level": "high",
            "section_id": "8ab37932-2678-4985-b380-b6109d821347",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "pkLDNuQpGXvjjBJV2yJo"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:07:13.000",
        "data": {
            "detail_level": "high",
            "section_id": "8ab37932-2678-4985-b380-b6109d821347",
            "structured_type": "structured",
            "mapping_index": 0
        },
        "event": "mapping_hover",
        "id": "put1BUrU9clxyuCtfjYv"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:07:14.000",
        "data": {
            "detail_level": "high",
            "section_id": "8ab37932-2678-4985-b380-b6109d821347",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "3CZ8GASRDKSmZH7D07bT"
    },
    {
        "source": "backend",
        "timestamp": "2025-08-23 14:07:20.000",
        "data": {
            "summary": {
                "high_unstructured": "The scrape_mvp_votes function scrapes NBA MVP voting data from Basketball Reference for each year in a given range, defaulting from 2018 to 2025. For each year, it constructs the appropriate URL, reads all HTML tables, and attempts to extract the first table, which contains the MVP votes. The function appends each year's table to a list, handling any exceptions by printing a message if parsing fails for a year. After collecting all available data, it concatenates the tables, renames the 'Player' and 'Pts Won' columns to 'Name' and 'MVP_Points', respectively, and returns a DataFrame with only the year, player name, and MVP points columns.",
                "low_structured": "• Scrapes MVP vote data from a website\n• Handles multiple years\n• Returns selected columns in a DataFrame",
                "high_structured": "• Accepts a start and end year, defaulting to 2018 and 2025\n• For each year in the range:\n  ◦ Constructs the Basketball Reference awards URL for that year\n  ◦ Reads all HTML tables from the page using pandas\n  ◦ Attempts to extract the first table (MVP votes)\n    ◦ Adds a 'Year' column to the table\n    ◦ Appends the table to a list\n  ◦ If extraction fails, prints an error message for that year\n• After looping, concatenates all collected tables into a single DataFrame\n• Renames 'Player' to 'Name' and 'Pts Won' to 'MVP_Points'\n• Returns a DataFrame containing only the 'Year', 'Name', and 'MVP_Points' columns",
                "title": "Summary of scrape_mvp_votes Function",
                "medium_unstructured": "The scrape_mvp_votes function collects NBA MVP voting results from Basketball Reference for each year in a specified range. It reads the relevant table from each year's awards page, adds the year information, and combines the results. The function then renames certain columns and returns a DataFrame with the year, player name, and MVP points.",
                "medium_structured": "• Iterates through a range of years to access each season's awards page\n• Extracts the MVP vote table from each page\n  ◦ Adds the year to the table\n  ◦ Handles errors if a year's data can't be parsed\n• Combines all yearly tables into one DataFrame\n• Renames columns and selects only year, player name, and MVP points for output",
                "low_unstructured": "This function scrapes NBA MVP vote data from Basketball Reference for a range of years and returns a DataFrame with selected columns."
            },
            "selected_code": "\ndef scrape_mvp_votes(start_year=2018, end_year=2025):\n    all_votes = []\n    for year in range(start_year, end_year + 1):\n        url = f\"https://www.basketball-reference.com/awards/awards_{year}.html\"\n        tables = pd.read_html(url, header=1)\n        try:\n            mvp_table = tables[0]  # MVP table is the first table\n            mvp_table[\"Year\"] = year\n            all_votes.append(mvp_table)\n        except:\n            print(f\"Could not parse year {year}\")\n\n    df = pd.concat(all_votes)\n    df = df.rename(columns={\"Player\": \"Name\", \"Pts Won\": \"MVP_Points\"})\n    return df[[\"Year\", \"Name\", \"MVP_Points\"]]"
        },
        "event": "summarize_selected_code",
        "id": "7sew7j55V8AWR00u1NDU"
    },
    {
        "source": "backend",
        "timestamp": "2025-08-23 14:07:21.000",
        "data": {
            "summary": "• Scrapes MVP vote data from a website\n• Handles multiple years\n• Returns selected columns in a DataFrame",
            "code": "4: \n5: def scrape_mvp_votes(start_year=2018, end_year=2025):\n6:     all_votes = []\n7:     for year in range(start_year, end_year + 1):\n8:         url = f\"https://www.basketball-reference.com/awards/awards_{year}.html\"\n9:         tables = pd.read_html(url, header=1)\n10:         try:\n11:             mvp_table = tables[0]  # MVP table is the first table\n12:             mvp_table[\"Year\"] = year\n13:             all_votes.append(mvp_table)\n14:         except:\n15:             print(f\"Could not parse year {year}\")\n16: \n17:     df = pd.concat(all_votes)\n18:     df = df.rename(columns={\"Player\": \"Name\", \"Pts Won\": \"MVP_Points\"})\n19:     return df[[\"Year\", \"Name\", \"MVP_Points\"]]",
            "mapping": [
                {
                    "codeSegments": [
                        {
                            "line": 8,
                            "code": "url = f\"https://www.basketball-reference.com/awards/awards_{year}.html\""
                        },
                        {
                            "line": 9,
                            "code": "tables = pd.read_html(url, header=1)"
                        }
                    ],
                    "summaryComponent": "Scrapes MVP vote data from a website"
                },
                {
                    "codeSegments": [
                        {
                            "line": 7,
                            "code": "for year in range(start_year, end_year + 1):"
                        }
                    ],
                    "summaryComponent": "Handles multiple years"
                },
                {
                    "codeSegments": [
                        {
                            "line": 19,
                            "code": "return df[[\"Year\", \"Name\", \"MVP_Points\"]]"
                        }
                    ],
                    "summaryComponent": "Returns selected columns in a DataFrame"
                }
            ]
        },
        "event": "map_summary_code",
        "id": "lJNjeMBzW2s85bSSgFUF"
    },
    {
        "source": "backend",
        "timestamp": "2025-08-23 14:07:23.000",
        "data": {
            "summary": "• Iterates through a range of years to access each season's awards page\n• Extracts the MVP vote table from each page\n  ◦ Adds the year to the table\n  ◦ Handles errors if a year's data can't be parsed\n• Combines all yearly tables into one DataFrame\n• Renames columns and selects only year, player name, and MVP points for output",
            "code": "4: \n5: def scrape_mvp_votes(start_year=2018, end_year=2025):\n6:     all_votes = []\n7:     for year in range(start_year, end_year + 1):\n8:         url = f\"https://www.basketball-reference.com/awards/awards_{year}.html\"\n9:         tables = pd.read_html(url, header=1)\n10:         try:\n11:             mvp_table = tables[0]  # MVP table is the first table\n12:             mvp_table[\"Year\"] = year\n13:             all_votes.append(mvp_table)\n14:         except:\n15:             print(f\"Could not parse year {year}\")\n16: \n17:     df = pd.concat(all_votes)\n18:     df = df.rename(columns={\"Player\": \"Name\", \"Pts Won\": \"MVP_Points\"})\n19:     return df[[\"Year\", \"Name\", \"MVP_Points\"]]",
            "mapping": [
                {
                    "codeSegments": [
                        {
                            "line": 7,
                            "code": "for year in range(start_year, end_year + 1):"
                        },
                        {
                            "line": 8,
                            "code": "url = f\"https://www.basketball-reference.com/awards/awards_{year}.html\""
                        }
                    ],
                    "summaryComponent": "Iterates through a range of years to access each season's awards page"
                },
                {
                    "codeSegments": [
                        {
                            "line": 9,
                            "code": "tables = pd.read_html(url, header=1)"
                        },
                        {
                            "line": 11,
                            "code": "mvp_table = tables[0]  # MVP table is the first table"
                        }
                    ],
                    "summaryComponent": "Extracts the MVP vote table from each page"
                },
                {
                    "codeSegments": [
                        {
                            "line": 12,
                            "code": "mvp_table[\"Year\"] = year"
                        }
                    ],
                    "summaryComponent": "Adds the year to the table"
                },
                {
                    "codeSegments": [
                        {
                            "line": 14,
                            "code": "except:"
                        },
                        {
                            "line": 15,
                            "code": "print(f\"Could not parse year {year}\")"
                        }
                    ],
                    "summaryComponent": "Handles errors if a year's data can't be parsed"
                },
                {
                    "codeSegments": [
                        {
                            "line": 17,
                            "code": "df = pd.concat(all_votes)"
                        }
                    ],
                    "summaryComponent": "Combines all yearly tables into one DataFrame"
                },
                {
                    "codeSegments": [
                        {
                            "line": 18,
                            "code": "df = df.rename(columns={\"Player\": \"Name\", \"Pts Won\": \"MVP_Points\"})"
                        },
                        {
                            "line": 19,
                            "code": "return df[[\"Year\", \"Name\", \"MVP_Points\"]]"
                        }
                    ],
                    "summaryComponent": "Renames columns and selects only year, player name, and MVP points for output"
                }
            ]
        },
        "event": "map_summary_code",
        "id": "0ts4EwzPYlnYgDIjXUP3"
    },
    {
        "source": "backend",
        "timestamp": "2025-08-23 14:07:23.000",
        "data": {
            "summary": "This function scrapes NBA MVP vote data from Basketball Reference for a range of years and returns a DataFrame with selected columns.",
            "code": "4: \n5: def scrape_mvp_votes(start_year=2018, end_year=2025):\n6:     all_votes = []\n7:     for year in range(start_year, end_year + 1):\n8:         url = f\"https://www.basketball-reference.com/awards/awards_{year}.html\"\n9:         tables = pd.read_html(url, header=1)\n10:         try:\n11:             mvp_table = tables[0]  # MVP table is the first table\n12:             mvp_table[\"Year\"] = year\n13:             all_votes.append(mvp_table)\n14:         except:\n15:             print(f\"Could not parse year {year}\")\n16: \n17:     df = pd.concat(all_votes)\n18:     df = df.rename(columns={\"Player\": \"Name\", \"Pts Won\": \"MVP_Points\"})\n19:     return df[[\"Year\", \"Name\", \"MVP_Points\"]]",
            "mapping": [
                {
                    "codeSegments": [
                        {
                            "line": 5,
                            "code": "def scrape_mvp_votes(start_year=2018, end_year=2025):"
                        },
                        {
                            "line": 8,
                            "code": "url = f\"https://www.basketball-reference.com/awards/awards_{year}.html\""
                        },
                        {
                            "line": 9,
                            "code": "tables = pd.read_html(url, header=1)"
                        },
                        {
                            "line": 11,
                            "code": "mvp_table = tables[0]  # MVP table is the first table"
                        }
                    ],
                    "summaryComponent": "scrapes NBA MVP vote data"
                },
                {
                    "codeSegments": [
                        {
                            "line": 8,
                            "code": "url = f\"https://www.basketball-reference.com/awards/awards_{year}.html\""
                        }
                    ],
                    "summaryComponent": "from Basketball Reference"
                },
                {
                    "codeSegments": [
                        {
                            "line": 7,
                            "code": "for year in range(start_year, end_year + 1):"
                        }
                    ],
                    "summaryComponent": "for a range of years"
                },
                {
                    "codeSegments": [
                        {
                            "line": 19,
                            "code": "return df[[\"Year\", \"Name\", \"MVP_Points\"]]"
                        }
                    ],
                    "summaryComponent": "returns a DataFrame"
                },
                {
                    "codeSegments": [
                        {
                            "line": 19,
                            "code": "return df[[\"Year\", \"Name\", \"MVP_Points\"]]"
                        }
                    ],
                    "summaryComponent": "with selected columns"
                }
            ]
        },
        "event": "map_summary_code",
        "id": "1AOSXmUViHZsYID4mCZi"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:07:24.000",
        "data": {
            "after_section_id": "818d302c-425a-46cf-a0b3-0d6987487f54",
            "before_section_id": "8ab37932-2678-4985-b380-b6109d821347"
        },
        "event": "autotransit_section",
        "id": "dY9OANVYtr4WQDDerfCH"
    },
    {
        "source": "backend",
        "timestamp": "2025-08-23 14:07:24.000",
        "data": {
            "summary": "The scrape_mvp_votes function collects NBA MVP voting results from Basketball Reference for each year in a specified range. It reads the relevant table from each year's awards page, adds the year information, and combines the results. The function then renames certain columns and returns a DataFrame with the year, player name, and MVP points.",
            "code": "4: \n5: def scrape_mvp_votes(start_year=2018, end_year=2025):\n6:     all_votes = []\n7:     for year in range(start_year, end_year + 1):\n8:         url = f\"https://www.basketball-reference.com/awards/awards_{year}.html\"\n9:         tables = pd.read_html(url, header=1)\n10:         try:\n11:             mvp_table = tables[0]  # MVP table is the first table\n12:             mvp_table[\"Year\"] = year\n13:             all_votes.append(mvp_table)\n14:         except:\n15:             print(f\"Could not parse year {year}\")\n16: \n17:     df = pd.concat(all_votes)\n18:     df = df.rename(columns={\"Player\": \"Name\", \"Pts Won\": \"MVP_Points\"})\n19:     return df[[\"Year\", \"Name\", \"MVP_Points\"]]",
            "mapping": [
                {
                    "codeSegments": [
                        {
                            "line": 5,
                            "code": "def scrape_mvp_votes(start_year=2018, end_year=2025):"
                        }
                    ],
                    "summaryComponent": "The scrape_mvp_votes function"
                },
                {
                    "codeSegments": [
                        {
                            "line": 7,
                            "code": "for year in range(start_year, end_year + 1):"
                        },
                        {
                            "line": 8,
                            "code": "url = f\"https://www.basketball-reference.com/awards/awards_{year}.html\""
                        }
                    ],
                    "summaryComponent": "collects NBA MVP voting results from Basketball Reference for each year in a specified range"
                },
                {
                    "codeSegments": [
                        {
                            "line": 9,
                            "code": "tables = pd.read_html(url, header=1)"
                        },
                        {
                            "line": 11,
                            "code": "mvp_table = tables[0]  # MVP table is the first table"
                        }
                    ],
                    "summaryComponent": "It reads the relevant table from each year's awards page"
                },
                {
                    "codeSegments": [
                        {
                            "line": 12,
                            "code": "mvp_table[\"Year\"] = year"
                        }
                    ],
                    "summaryComponent": "adds the year information"
                },
                {
                    "codeSegments": [
                        {
                            "line": 13,
                            "code": "all_votes.append(mvp_table)"
                        },
                        {
                            "line": 17,
                            "code": "df = pd.concat(all_votes)"
                        }
                    ],
                    "summaryComponent": "and combines the results"
                },
                {
                    "codeSegments": [
                        {
                            "line": 18,
                            "code": "df = df.rename(columns={\"Player\": \"Name\", \"Pts Won\": \"MVP_Points\"})"
                        }
                    ],
                    "summaryComponent": "The function then renames certain columns"
                },
                {
                    "codeSegments": [
                        {
                            "line": 19,
                            "code": "return df[[\"Year\", \"Name\", \"MVP_Points\"]]"
                        }
                    ],
                    "summaryComponent": "and returns a DataFrame with the year, player name, and MVP points"
                }
            ]
        },
        "event": "map_summary_code",
        "id": "obBzGc67Zubsn1Kp2TZ2"
    },
    {
        "source": "backend",
        "timestamp": "2025-08-23 14:07:24.000",
        "data": {
            "summary": "• Accepts a start and end year, defaulting to 2018 and 2025\n• For each year in the range:\n  ◦ Constructs the Basketball Reference awards URL for that year\n  ◦ Reads all HTML tables from the page using pandas\n  ◦ Attempts to extract the first table (MVP votes)\n    ◦ Adds a 'Year' column to the table\n    ◦ Appends the table to a list\n  ◦ If extraction fails, prints an error message for that year\n• After looping, concatenates all collected tables into a single DataFrame\n• Renames 'Player' to 'Name' and 'Pts Won' to 'MVP_Points'\n• Returns a DataFrame containing only the 'Year', 'Name', and 'MVP_Points' columns",
            "code": "4: \n5: def scrape_mvp_votes(start_year=2018, end_year=2025):\n6:     all_votes = []\n7:     for year in range(start_year, end_year + 1):\n8:         url = f\"https://www.basketball-reference.com/awards/awards_{year}.html\"\n9:         tables = pd.read_html(url, header=1)\n10:         try:\n11:             mvp_table = tables[0]  # MVP table is the first table\n12:             mvp_table[\"Year\"] = year\n13:             all_votes.append(mvp_table)\n14:         except:\n15:             print(f\"Could not parse year {year}\")\n16: \n17:     df = pd.concat(all_votes)\n18:     df = df.rename(columns={\"Player\": \"Name\", \"Pts Won\": \"MVP_Points\"})\n19:     return df[[\"Year\", \"Name\", \"MVP_Points\"]]",
            "mapping": [
                {
                    "codeSegments": [
                        {
                            "line": 5,
                            "code": "def scrape_mvp_votes(start_year=2018, end_year=2025):"
                        }
                    ],
                    "summaryComponent": "Accepts a start and end year, defaulting to 2018 and 2025"
                },
                {
                    "codeSegments": [
                        {
                            "line": 7,
                            "code": "for year in range(start_year, end_year + 1):"
                        }
                    ],
                    "summaryComponent": "For each year in the range"
                },
                {
                    "codeSegments": [
                        {
                            "line": 8,
                            "code": "url = f\"https://www.basketball-reference.com/awards/awards_{year}.html\""
                        }
                    ],
                    "summaryComponent": "Constructs the Basketball Reference awards URL for that year"
                },
                {
                    "codeSegments": [
                        {
                            "line": 9,
                            "code": "tables = pd.read_html(url, header=1)"
                        }
                    ],
                    "summaryComponent": "Reads all HTML tables from the page using pandas"
                },
                {
                    "codeSegments": [
                        {
                            "line": 11,
                            "code": "mvp_table = tables[0]  # MVP table is the first table"
                        }
                    ],
                    "summaryComponent": "Attempts to extract the first table (MVP votes)"
                },
                {
                    "codeSegments": [
                        {
                            "line": 12,
                            "code": "mvp_table[\"Year\"] = year"
                        }
                    ],
                    "summaryComponent": "Adds a 'Year' column to the table"
                },
                {
                    "codeSegments": [
                        {
                            "line": 13,
                            "code": "all_votes.append(mvp_table)"
                        }
                    ],
                    "summaryComponent": "Appends the table to a list"
                },
                {
                    "codeSegments": [
                        {
                            "line": 14,
                            "code": "except:"
                        },
                        {
                            "line": 15,
                            "code": "print(f\"Could not parse year {year}\")"
                        }
                    ],
                    "summaryComponent": "If extraction fails, prints an error message for that year"
                },
                {
                    "codeSegments": [
                        {
                            "line": 17,
                            "code": "df = pd.concat(all_votes)"
                        }
                    ],
                    "summaryComponent": "After looping, concatenates all collected tables into a single DataFrame"
                },
                {
                    "codeSegments": [
                        {
                            "line": 18,
                            "code": "df = df.rename(columns={\"Player\": \"Name\", \"Pts Won\": \"MVP_Points\"})"
                        }
                    ],
                    "summaryComponent": "Renames 'Player' to 'Name' and 'Pts Won' to 'MVP_Points'"
                },
                {
                    "codeSegments": [
                        {
                            "line": 19,
                            "code": "return df[[\"Year\", \"Name\", \"MVP_Points\"]]"
                        }
                    ],
                    "summaryComponent": "Returns a DataFrame containing only the 'Year', 'Name', and 'MVP_Points' columns"
                }
            ]
        },
        "event": "map_summary_code",
        "id": "pyeYoFwMwCclvKcgs9R9"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:07:24.000",
        "data": {
            "section_data": {
                "editPromptValue": "",
                "summaryData": {
                    "high_unstructured": "The scrape_mvp_votes function scrapes NBA MVP voting data from Basketball Reference for each year in a given range, defaulting from 2018 to 2025. For each year, it constructs the appropriate URL, reads all HTML tables, and attempts to extract the first table, which contains the MVP votes. The function appends each year's table to a list, handling any exceptions by printing a message if parsing fails for a year. After collecting all available data, it concatenates the tables, renames the 'Player' and 'Pts Won' columns to 'Name' and 'MVP_Points', respectively, and returns a DataFrame with only the year, player name, and MVP points columns.",
                    "low_structured": "• Scrapes MVP vote data from a website\n• Handles multiple years\n• Returns selected columns in a DataFrame",
                    "high_structured": "• Accepts a start and end year, defaulting to 2018 and 2025\n• For each year in the range:\n  ◦ Constructs the Basketball Reference awards URL for that year\n  ◦ Reads all HTML tables from the page using pandas\n  ◦ Attempts to extract the first table (MVP votes)\n    ◦ Adds a 'Year' column to the table\n    ◦ Appends the table to a list\n  ◦ If extraction fails, prints an error message for that year\n• After looping, concatenates all collected tables into a single DataFrame\n• Renames 'Player' to 'Name' and 'Pts Won' to 'MVP_Points'\n• Returns a DataFrame containing only the 'Year', 'Name', and 'MVP_Points' columns",
                    "title": "Summary of scrape_mvp_votes Function",
                    "medium_unstructured": "The scrape_mvp_votes function collects NBA MVP voting results from Basketball Reference for each year in a specified range. It reads the relevant table from each year's awards page, adds the year information, and combines the results. The function then renames certain columns and returns a DataFrame with the year, player name, and MVP points.",
                    "medium_structured": "• Iterates through a range of years to access each season's awards page\n• Extracts the MVP vote table from each page\n  ◦ Adds the year to the table\n  ◦ Handles errors if a year's data can't be parsed\n• Combines all yearly tables into one DataFrame\n• Renames columns and selects only year, player name, and MVP points for output",
                    "low_unstructured": "This function scrapes NBA MVP vote data from Basketball Reference for a range of years and returns a DataFrame with selected columns."
                },
                "selectedDetailLevel": "medium",
                "title": "Summary of scrape_mvp_votes Function",
                "summaryMappings": {
                    "low_structured": [
                        {
                            "codeSegments": [
                                {
                                    "line": 8,
                                    "code": "url = f\"https://www.basketball-reference.com/awards/awards_{year}.html\""
                                },
                                {
                                    "line": 9,
                                    "code": "tables = pd.read_html(url, header=1)"
                                }
                            ],
                            "summaryComponent": "Scrapes MVP vote data from a website"
                        },
                        {
                            "codeSegments": [
                                {
                                    "line": 7,
                                    "code": "for year in range(start_year, end_year + 1):"
                                }
                            ],
                            "summaryComponent": "Handles multiple years"
                        },
                        {
                            "codeSegments": [
                                {
                                    "line": 19,
                                    "code": "return df[[\"Year\", \"Name\", \"MVP_Points\"]]"
                                }
                            ],
                            "summaryComponent": "Returns selected columns in a DataFrame"
                        }
                    ],
                    "high_structured": [
                        {
                            "codeSegments": [
                                {
                                    "line": 5,
                                    "code": "def scrape_mvp_votes(start_year=2018, end_year=2025):"
                                }
                            ],
                            "summaryComponent": "Accepts a start and end year, defaulting to 2018 and 2025"
                        },
                        {
                            "codeSegments": [
                                {
                                    "line": 7,
                                    "code": "for year in range(start_year, end_year + 1):"
                                }
                            ],
                            "summaryComponent": "For each year in the range"
                        },
                        {
                            "codeSegments": [
                                {
                                    "line": 8,
                                    "code": "url = f\"https://www.basketball-reference.com/awards/awards_{year}.html\""
                                }
                            ],
                            "summaryComponent": "Constructs the Basketball Reference awards URL for that year"
                        },
                        {
                            "codeSegments": [
                                {
                                    "line": 9,
                                    "code": "tables = pd.read_html(url, header=1)"
                                }
                            ],
                            "summaryComponent": "Reads all HTML tables from the page using pandas"
                        },
                        {
                            "codeSegments": [
                                {
                                    "line": 11,
                                    "code": "mvp_table = tables[0]  # MVP table is the first table"
                                }
                            ],
                            "summaryComponent": "Attempts to extract the first table (MVP votes)"
                        },
                        {
                            "codeSegments": [
                                {
                                    "line": 12,
                                    "code": "mvp_table[\"Year\"] = year"
                                }
                            ],
                            "summaryComponent": "Adds a 'Year' column to the table"
                        },
                        {
                            "codeSegments": [
                                {
                                    "line": 13,
                                    "code": "all_votes.append(mvp_table)"
                                }
                            ],
                            "summaryComponent": "Appends the table to a list"
                        },
                        {
                            "codeSegments": [
                                {
                                    "line": 14,
                                    "code": "except:"
                                },
                                {
                                    "line": 15,
                                    "code": "print(f\"Could not parse year {year}\")"
                                }
                            ],
                            "summaryComponent": "If extraction fails, prints an error message for that year"
                        },
                        {
                            "codeSegments": [
                                {
                                    "line": 17,
                                    "code": "df = pd.concat(all_votes)"
                                }
                            ],
                            "summaryComponent": "After looping, concatenates all collected tables into a single DataFrame"
                        },
                        {
                            "codeSegments": [
                                {
                                    "line": 18,
                                    "code": "df = df.rename(columns={\"Player\": \"Name\", \"Pts Won\": \"MVP_Points\"})"
                                }
                            ],
                            "summaryComponent": "Renames 'Player' to 'Name' and 'Pts Won' to 'MVP_Points'"
                        },
                        {
                            "codeSegments": [
                                {
                                    "line": 19,
                                    "code": "return df[[\"Year\", \"Name\", \"MVP_Points\"]]"
                                }
                            ],
                            "summaryComponent": "Returns a DataFrame containing only the 'Year', 'Name', and 'MVP_Points' columns"
                        }
                    ],
                    "medium_structured": [
                        {
                            "codeSegments": [
                                {
                                    "line": 7,
                                    "code": "for year in range(start_year, end_year + 1):"
                                },
                                {
                                    "line": 8,
                                    "code": "url = f\"https://www.basketball-reference.com/awards/awards_{year}.html\""
                                }
                            ],
                            "summaryComponent": "Iterates through a range of years to access each season's awards page"
                        },
                        {
                            "codeSegments": [
                                {
                                    "line": 9,
                                    "code": "tables = pd.read_html(url, header=1)"
                                },
                                {
                                    "line": 11,
                                    "code": "mvp_table = tables[0]  # MVP table is the first table"
                                }
                            ],
                            "summaryComponent": "Extracts the MVP vote table from each page"
                        },
                        {
                            "codeSegments": [
                                {
                                    "line": 12,
                                    "code": "mvp_table[\"Year\"] = year"
                                }
                            ],
                            "summaryComponent": "Adds the year to the table"
                        },
                        {
                            "codeSegments": [
                                {
                                    "line": 14,
                                    "code": "except:"
                                },
                                {
                                    "line": 15,
                                    "code": "print(f\"Could not parse year {year}\")"
                                }
                            ],
                            "summaryComponent": "Handles errors if a year's data can't be parsed"
                        },
                        {
                            "codeSegments": [
                                {
                                    "line": 17,
                                    "code": "df = pd.concat(all_votes)"
                                }
                            ],
                            "summaryComponent": "Combines all yearly tables into one DataFrame"
                        },
                        {
                            "codeSegments": [
                                {
                                    "line": 18,
                                    "code": "df = df.rename(columns={\"Player\": \"Name\", \"Pts Won\": \"MVP_Points\"})"
                                },
                                {
                                    "line": 19,
                                    "code": "return df[[\"Year\", \"Name\", \"MVP_Points\"]]"
                                }
                            ],
                            "summaryComponent": "Renames columns and selects only year, player name, and MVP points for output"
                        }
                    ],
                    "medium_unstructured": [
                        {
                            "codeSegments": [
                                {
                                    "line": 5,
                                    "code": "def scrape_mvp_votes(start_year=2018, end_year=2025):"
                                }
                            ],
                            "summaryComponent": "The scrape_mvp_votes function"
                        },
                        {
                            "codeSegments": [
                                {
                                    "line": 7,
                                    "code": "for year in range(start_year, end_year + 1):"
                                },
                                {
                                    "line": 8,
                                    "code": "url = f\"https://www.basketball-reference.com/awards/awards_{year}.html\""
                                }
                            ],
                            "summaryComponent": "collects NBA MVP voting results from Basketball Reference for each year in a specified range"
                        },
                        {
                            "codeSegments": [
                                {
                                    "line": 9,
                                    "code": "tables = pd.read_html(url, header=1)"
                                },
                                {
                                    "line": 11,
                                    "code": "mvp_table = tables[0]  # MVP table is the first table"
                                }
                            ],
                            "summaryComponent": "It reads the relevant table from each year's awards page"
                        },
                        {
                            "codeSegments": [
                                {
                                    "line": 12,
                                    "code": "mvp_table[\"Year\"] = year"
                                }
                            ],
                            "summaryComponent": "adds the year information"
                        },
                        {
                            "codeSegments": [
                                {
                                    "line": 13,
                                    "code": "all_votes.append(mvp_table)"
                                },
                                {
                                    "line": 17,
                                    "code": "df = pd.concat(all_votes)"
                                }
                            ],
                            "summaryComponent": "and combines the results"
                        },
                        {
                            "codeSegments": [
                                {
                                    "line": 18,
                                    "code": "df = df.rename(columns={\"Player\": \"Name\", \"Pts Won\": \"MVP_Points\"})"
                                }
                            ],
                            "summaryComponent": "The function then renames certain columns"
                        },
                        {
                            "codeSegments": [
                                {
                                    "line": 19,
                                    "code": "return df[[\"Year\", \"Name\", \"MVP_Points\"]]"
                                }
                            ],
                            "summaryComponent": "and returns a DataFrame with the year, player name, and MVP points"
                        }
                    ],
                    "high_unstructured": [
                        {
                            "codeSegments": [
                                {
                                    "line": 5,
                                    "code": "def scrape_mvp_votes(start_year=2018, end_year=2025):"
                                }
                            ],
                            "summaryComponent": "The scrape_mvp_votes function"
                        },
                        {
                            "codeSegments": [
                                {
                                    "line": 7,
                                    "code": "for year in range(start_year, end_year + 1):"
                                },
                                {
                                    "line": 8,
                                    "code": "url = f\"https://www.basketball-reference.com/awards/awards_{year}.html\""
                                },
                                {
                                    "line": 5,
                                    "code": "def scrape_mvp_votes(start_year=2018, end_year=2025):"
                                }
                            ],
                            "summaryComponent": "scrapes NBA MVP voting data from Basketball Reference for each year in a given range, defaulting from 2018 to 2025."
                        },
                        {
                            "codeSegments": [
                                {
                                    "line": 8,
                                    "code": "url = f\"https://www.basketball-reference.com/awards/awards_{year}.html\""
                                }
                            ],
                            "summaryComponent": "For each year, it constructs the appropriate URL,"
                        },
                        {
                            "codeSegments": [
                                {
                                    "line": 9,
                                    "code": "tables = pd.read_html(url, header=1)"
                                }
                            ],
                            "summaryComponent": "reads all HTML tables,"
                        },
                        {
                            "codeSegments": [
                                {
                                    "line": 11,
                                    "code": "mvp_table = tables[0]  # MVP table is the first table"
                                }
                            ],
                            "summaryComponent": "and attempts to extract the first table, which contains the MVP votes."
                        },
                        {
                            "codeSegments": [
                                {
                                    "line": 13,
                                    "code": "all_votes.append(mvp_table)"
                                }
                            ],
                            "summaryComponent": "The function appends each year's table to a list,"
                        },
                        {
                            "codeSegments": [
                                {
                                    "line": 14,
                                    "code": "except:"
                                },
                                {
                                    "line": 15,
                                    "code": "print(f\"Could not parse year {year}\")"
                                }
                            ],
                            "summaryComponent": "handling any exceptions by printing a message if parsing fails for a year."
                        },
                        {
                            "codeSegments": [
                                {
                                    "line": 17,
                                    "code": "df = pd.concat(all_votes)"
                                }
                            ],
                            "summaryComponent": "After collecting all available data, it concatenates the tables,"
                        },
                        {
                            "codeSegments": [
                                {
                                    "line": 18,
                                    "code": "df = df.rename(columns={\"Player\": \"Name\", \"Pts Won\": \"MVP_Points\"})"
                                }
                            ],
                            "summaryComponent": "renames the 'Player' and 'Pts Won' columns to 'Name' and 'MVP_Points', respectively,"
                        },
                        {
                            "codeSegments": [
                                {
                                    "line": 19,
                                    "code": "return df[[\"Year\", \"Name\", \"MVP_Points\"]]"
                                }
                            ],
                            "summaryComponent": "and returns a DataFrame with only the year, player name, and MVP points columns."
                        }
                    ],
                    "low_unstructured": [
                        {
                            "codeSegments": [
                                {
                                    "line": 5,
                                    "code": "def scrape_mvp_votes(start_year=2018, end_year=2025):"
                                },
                                {
                                    "line": 8,
                                    "code": "url = f\"https://www.basketball-reference.com/awards/awards_{year}.html\""
                                },
                                {
                                    "line": 9,
                                    "code": "tables = pd.read_html(url, header=1)"
                                },
                                {
                                    "line": 11,
                                    "code": "mvp_table = tables[0]  # MVP table is the first table"
                                }
                            ],
                            "summaryComponent": "scrapes NBA MVP vote data"
                        },
                        {
                            "codeSegments": [
                                {
                                    "line": 8,
                                    "code": "url = f\"https://www.basketball-reference.com/awards/awards_{year}.html\""
                                }
                            ],
                            "summaryComponent": "from Basketball Reference"
                        },
                        {
                            "codeSegments": [
                                {
                                    "line": 7,
                                    "code": "for year in range(start_year, end_year + 1):"
                                }
                            ],
                            "summaryComponent": "for a range of years"
                        },
                        {
                            "codeSegments": [
                                {
                                    "line": 19,
                                    "code": "return df[[\"Year\", \"Name\", \"MVP_Points\"]]"
                                }
                            ],
                            "summaryComponent": "returns a DataFrame"
                        },
                        {
                            "codeSegments": [
                                {
                                    "line": 19,
                                    "code": "return df[[\"Year\", \"Name\", \"MVP_Points\"]]"
                                }
                            ],
                            "summaryComponent": "with selected columns"
                        }
                    ]
                },
                "metadata": {
                    "id": "818d302c-425a-46cf-a0b3-0d6987487f54",
                    "filename": "scraper.py",
                    "offset": 31,
                    "fullPath": "/project/workspace/scraper.py",
                    "originalCode": "\ndef scrape_mvp_votes(start_year=2018, end_year=2025):\n    all_votes = []\n    for year in range(start_year, end_year + 1):\n        url = f\"https://www.basketball-reference.com/awards/awards_{year}.html\"\n        tables = pd.read_html(url, header=1)\n        try:\n            mvp_table = tables[0]  # MVP table is the first table\n            mvp_table[\"Year\"] = year\n            all_votes.append(mvp_table)\n        except:\n            print(f\"Could not parse year {year}\")\n\n    df = pd.concat(all_votes)\n    df = df.rename(columns={\"Player\": \"Name\", \"Pts Won\": \"MVP_Points\"})\n    return df[[\"Year\", \"Name\", \"MVP_Points\"]]"
                },
                "createdAt": 1755986845000,
                "lines": [
                    4,
                    19
                ],
                "editPromptStructured": null,
                "selectedStructured": "unstructured",
                "editPromptDetailLevel": null
            },
            "section_id": "818d302c-425a-46cf-a0b3-0d6987487f54"
        },
        "event": "create_new_section",
        "id": "vxuPcVgH967guArijCF4"
    },
    {
        "source": "backend",
        "timestamp": "2025-08-23 14:07:25.000",
        "data": {
            "summary": "The scrape_mvp_votes function scrapes NBA MVP voting data from Basketball Reference for each year in a given range, defaulting from 2018 to 2025. For each year, it constructs the appropriate URL, reads all HTML tables, and attempts to extract the first table, which contains the MVP votes. The function appends each year's table to a list, handling any exceptions by printing a message if parsing fails for a year. After collecting all available data, it concatenates the tables, renames the 'Player' and 'Pts Won' columns to 'Name' and 'MVP_Points', respectively, and returns a DataFrame with only the year, player name, and MVP points columns.",
            "code": "4: \n5: def scrape_mvp_votes(start_year=2018, end_year=2025):\n6:     all_votes = []\n7:     for year in range(start_year, end_year + 1):\n8:         url = f\"https://www.basketball-reference.com/awards/awards_{year}.html\"\n9:         tables = pd.read_html(url, header=1)\n10:         try:\n11:             mvp_table = tables[0]  # MVP table is the first table\n12:             mvp_table[\"Year\"] = year\n13:             all_votes.append(mvp_table)\n14:         except:\n15:             print(f\"Could not parse year {year}\")\n16: \n17:     df = pd.concat(all_votes)\n18:     df = df.rename(columns={\"Player\": \"Name\", \"Pts Won\": \"MVP_Points\"})\n19:     return df[[\"Year\", \"Name\", \"MVP_Points\"]]",
            "mapping": [
                {
                    "codeSegments": [
                        {
                            "line": 5,
                            "code": "def scrape_mvp_votes(start_year=2018, end_year=2025):"
                        }
                    ],
                    "summaryComponent": "The scrape_mvp_votes function"
                },
                {
                    "codeSegments": [
                        {
                            "line": 7,
                            "code": "for year in range(start_year, end_year + 1):"
                        },
                        {
                            "line": 8,
                            "code": "url = f\"https://www.basketball-reference.com/awards/awards_{year}.html\""
                        },
                        {
                            "line": 5,
                            "code": "def scrape_mvp_votes(start_year=2018, end_year=2025):"
                        }
                    ],
                    "summaryComponent": "scrapes NBA MVP voting data from Basketball Reference for each year in a given range, defaulting from 2018 to 2025."
                },
                {
                    "codeSegments": [
                        {
                            "line": 8,
                            "code": "url = f\"https://www.basketball-reference.com/awards/awards_{year}.html\""
                        }
                    ],
                    "summaryComponent": "For each year, it constructs the appropriate URL,"
                },
                {
                    "codeSegments": [
                        {
                            "line": 9,
                            "code": "tables = pd.read_html(url, header=1)"
                        }
                    ],
                    "summaryComponent": "reads all HTML tables,"
                },
                {
                    "codeSegments": [
                        {
                            "line": 11,
                            "code": "mvp_table = tables[0]  # MVP table is the first table"
                        }
                    ],
                    "summaryComponent": "and attempts to extract the first table, which contains the MVP votes."
                },
                {
                    "codeSegments": [
                        {
                            "line": 13,
                            "code": "all_votes.append(mvp_table)"
                        }
                    ],
                    "summaryComponent": "The function appends each year's table to a list,"
                },
                {
                    "codeSegments": [
                        {
                            "line": 14,
                            "code": "except:"
                        },
                        {
                            "line": 15,
                            "code": "print(f\"Could not parse year {year}\")"
                        }
                    ],
                    "summaryComponent": "handling any exceptions by printing a message if parsing fails for a year."
                },
                {
                    "codeSegments": [
                        {
                            "line": 17,
                            "code": "df = pd.concat(all_votes)"
                        }
                    ],
                    "summaryComponent": "After collecting all available data, it concatenates the tables,"
                },
                {
                    "codeSegments": [
                        {
                            "line": 18,
                            "code": "df = df.rename(columns={\"Player\": \"Name\", \"Pts Won\": \"MVP_Points\"})"
                        }
                    ],
                    "summaryComponent": "renames the 'Player' and 'Pts Won' columns to 'Name' and 'MVP_Points', respectively,"
                },
                {
                    "codeSegments": [
                        {
                            "line": 19,
                            "code": "return df[[\"Year\", \"Name\", \"MVP_Points\"]]"
                        }
                    ],
                    "summaryComponent": "and returns a DataFrame with only the year, player name, and MVP points columns."
                }
            ]
        },
        "event": "map_summary_code",
        "id": "5cwIXNCjRZ0KkgPSlQGn"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:07:26.000",
        "data": {
            "detail_level": "medium",
            "section_id": "818d302c-425a-46cf-a0b3-0d6987487f54",
            "structured_type": "unstructured"
        },
        "event": "mapping_unhover",
        "id": "LSHTPQWGbVYMub6YbQvX"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:07:26.000",
        "data": {
            "detail_level": "medium",
            "section_id": "818d302c-425a-46cf-a0b3-0d6987487f54",
            "structured_type": "unstructured",
            "mapping_index": 6
        },
        "event": "mapping_hover",
        "id": "QRSaUdTmQVj23oYUhPW0"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:07:26.000",
        "data": {
            "detail_level": "medium",
            "section_id": "818d302c-425a-46cf-a0b3-0d6987487f54",
            "structured_type": "unstructured",
            "mapping_index": 1
        },
        "event": "mapping_hover",
        "id": "fMe7Xxh3SaKq0yFsFRRr"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:07:26.000",
        "data": {
            "detail_level": "medium",
            "section_id": "818d302c-425a-46cf-a0b3-0d6987487f54",
            "structured_type": "unstructured"
        },
        "event": "mapping_unhover",
        "id": "iz4OHRAsZreYTwxkHwwn"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:07:26.000",
        "data": {
            "detail_level": "medium",
            "section_id": "818d302c-425a-46cf-a0b3-0d6987487f54",
            "structured_type": "unstructured"
        },
        "event": "mapping_unhover",
        "id": "lf8qLFX5No2nUZniCnlE"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:07:26.000",
        "data": {
            "detail_level": "medium",
            "section_id": "818d302c-425a-46cf-a0b3-0d6987487f54",
            "structured_type": "unstructured",
            "mapping_index": 3
        },
        "event": "mapping_hover",
        "id": "nJQBP1SUFTzlONFy6KbP"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:07:27.000",
        "data": {
            "detail_level": "medium",
            "section_id": "818d302c-425a-46cf-a0b3-0d6987487f54",
            "structured_type": "unstructured",
            "mapping_index": 6
        },
        "event": "mapping_hover",
        "id": "MM7OCQqpu2LtgAV318L2"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:07:27.000",
        "data": {
            "detail_level": "medium",
            "section_id": "818d302c-425a-46cf-a0b3-0d6987487f54",
            "structured_type": "unstructured"
        },
        "event": "mapping_unhover",
        "id": "T36ARH09ibzRuD6Ls0Tt"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:07:27.000",
        "data": {
            "detail_level": "medium",
            "section_id": "818d302c-425a-46cf-a0b3-0d6987487f54",
            "structured_type": "unstructured",
            "mapping_index": 1
        },
        "event": "mapping_hover",
        "id": "VMV1gmzx0ueZ5I027wds"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:07:27.000",
        "data": {
            "detail_level": "medium",
            "section_id": "818d302c-425a-46cf-a0b3-0d6987487f54",
            "structured_type": "unstructured"
        },
        "event": "mapping_unhover",
        "id": "VbJBC4iC9RtLWNjKixnX"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:07:27.000",
        "data": {
            "detail_level": "medium",
            "section_id": "818d302c-425a-46cf-a0b3-0d6987487f54",
            "structured_type": "unstructured",
            "mapping_index": 3
        },
        "event": "mapping_hover",
        "id": "dUxnDKtUMpWa867RzrCC"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:07:27.000",
        "data": {
            "detail_level": "medium",
            "section_id": "818d302c-425a-46cf-a0b3-0d6987487f54",
            "structured_type": "unstructured",
            "mapping_index": 0
        },
        "event": "mapping_hover",
        "id": "fO5P8lSgAnJB7MaoelPn"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:07:27.000",
        "data": {
            "detail_level": "medium",
            "section_id": "818d302c-425a-46cf-a0b3-0d6987487f54",
            "structured_type": "unstructured"
        },
        "event": "mapping_unhover",
        "id": "lrcRy3jQnc5egtv1UZzB"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:07:27.000",
        "data": {
            "detail_level": "medium",
            "section_id": "818d302c-425a-46cf-a0b3-0d6987487f54",
            "structured_type": "unstructured"
        },
        "event": "mapping_unhover",
        "id": "n0Gq0nEROoof6VNZFjMg"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:07:27.000",
        "data": {
            "before_detail_level": "medium",
            "before_structured": "unstructured",
            "section_id": "818d302c-425a-46cf-a0b3-0d6987487f54",
            "after_detail_level": "high",
            "after_structured": "unstructured"
        },
        "event": "change_summary_level",
        "id": "sE0AU5avvqEE1b8nuOMt"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:07:28.000",
        "data": {
            "detail_level": "high",
            "section_id": "818d302c-425a-46cf-a0b3-0d6987487f54",
            "structured_type": "unstructured"
        },
        "event": "mapping_unhover",
        "id": "0mxqhYbn3YPpNz6JgSel"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:07:28.000",
        "data": {
            "detail_level": "high",
            "section_id": "818d302c-425a-46cf-a0b3-0d6987487f54",
            "structured_type": "unstructured",
            "mapping_index": 0
        },
        "event": "mapping_hover",
        "id": "QnOcjU494LkQ5JRC75CQ"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:07:28.000",
        "data": {
            "before_detail_level": "high",
            "before_structured": "unstructured",
            "section_id": "818d302c-425a-46cf-a0b3-0d6987487f54",
            "after_detail_level": "high",
            "after_structured": "structured"
        },
        "event": "change_summary_level",
        "id": "jBt06FsOMHgFsvadLgvi"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:07:29.000",
        "data": {
            "detail_level": "high",
            "section_id": "818d302c-425a-46cf-a0b3-0d6987487f54",
            "structured_type": "structured",
            "mapping_index": 0
        },
        "event": "mapping_hover",
        "id": "JMACjjxe4MOjetkDKRxS"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:07:29.000",
        "data": {
            "detail_level": "high",
            "section_id": "818d302c-425a-46cf-a0b3-0d6987487f54",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "Lqf2BHdzj8X2rYzpG2Mk"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:07:29.000",
        "data": {
            "detail_level": "high",
            "section_id": "818d302c-425a-46cf-a0b3-0d6987487f54",
            "structured_type": "structured",
            "mapping_index": 1
        },
        "event": "mapping_hover",
        "id": "Oqu4qwLf1s6wL7VUU8zo"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:07:29.000",
        "data": {
            "detail_level": "high",
            "section_id": "818d302c-425a-46cf-a0b3-0d6987487f54",
            "structured_type": "structured",
            "mapping_index": 1
        },
        "event": "mapping_hover",
        "id": "Sootr1uVEQlKC8ZsZ64Z"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:07:29.000",
        "data": {
            "detail_level": "high",
            "section_id": "818d302c-425a-46cf-a0b3-0d6987487f54",
            "structured_type": "structured",
            "mapping_index": 2
        },
        "event": "mapping_hover",
        "id": "YaKfxt8i61lDnJb35xD5"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:07:29.000",
        "data": {
            "detail_level": "high",
            "section_id": "818d302c-425a-46cf-a0b3-0d6987487f54",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "oS5xaWXyuU1oSWQixyah"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:07:29.000",
        "data": {
            "detail_level": "high",
            "section_id": "818d302c-425a-46cf-a0b3-0d6987487f54",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "rQHv1P6BaiHmnfPOqRus"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:07:29.000",
        "data": {
            "detail_level": "high",
            "section_id": "818d302c-425a-46cf-a0b3-0d6987487f54",
            "structured_type": "structured",
            "mapping_index": 0
        },
        "event": "mapping_hover",
        "id": "sQClz8pupJ2r7kQjtY1h"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:07:29.000",
        "data": {
            "detail_level": "high",
            "section_id": "818d302c-425a-46cf-a0b3-0d6987487f54",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "wLgaWXQVjlpBbOUFaZlr"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:07:30.000",
        "data": {
            "detail_level": "high",
            "section_id": "818d302c-425a-46cf-a0b3-0d6987487f54",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "47Kle6yH3QKKBOoXeqIS"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:07:30.000",
        "data": {
            "detail_level": "high",
            "section_id": "818d302c-425a-46cf-a0b3-0d6987487f54",
            "structured_type": "structured",
            "mapping_index": 1
        },
        "event": "mapping_hover",
        "id": "F5d0UQIuaD7EEYH932jS"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:07:30.000",
        "data": {
            "detail_level": "high",
            "section_id": "818d302c-425a-46cf-a0b3-0d6987487f54",
            "structured_type": "structured",
            "mapping_index": 2
        },
        "event": "mapping_hover",
        "id": "g9rg0XHDHo74G8Wxwfts"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:07:30.000",
        "data": {
            "detail_level": "high",
            "section_id": "818d302c-425a-46cf-a0b3-0d6987487f54",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "rkbuViMXpo3AQZ5xvQYh"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:07:31.000",
        "data": {
            "detail_level": "high",
            "section_id": "818d302c-425a-46cf-a0b3-0d6987487f54",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "Ngi7arvWRLywwjlzrePU"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:07:31.000",
        "data": {
            "detail_level": "high",
            "section_id": "818d302c-425a-46cf-a0b3-0d6987487f54",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "XsnLmg0Qs8sUsTsVFn1d"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:07:31.000",
        "data": {
            "detail_level": "high",
            "section_id": "818d302c-425a-46cf-a0b3-0d6987487f54",
            "structured_type": "structured",
            "mapping_index": 3
        },
        "event": "mapping_hover",
        "id": "dmKzr6d7AXnvVtOuWubw"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:07:31.000",
        "data": {
            "detail_level": "high",
            "section_id": "818d302c-425a-46cf-a0b3-0d6987487f54",
            "structured_type": "structured",
            "mapping_index": 4
        },
        "event": "mapping_hover",
        "id": "dvQLe3ra1uZLyTadSZw1"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:07:32.000",
        "data": {
            "detail_level": "high",
            "section_id": "818d302c-425a-46cf-a0b3-0d6987487f54",
            "structured_type": "structured",
            "mapping_index": 2
        },
        "event": "mapping_hover",
        "id": "8sjqf6b7kMuIPDOmm5Jc"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:07:32.000",
        "data": {
            "detail_level": "high",
            "section_id": "818d302c-425a-46cf-a0b3-0d6987487f54",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "JKCdmi7Nfgo09UUltO2M"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:07:32.000",
        "data": {
            "detail_level": "high",
            "section_id": "818d302c-425a-46cf-a0b3-0d6987487f54",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "Oe9koomI79HHfptIWHDB"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:07:32.000",
        "data": {
            "detail_level": "high",
            "section_id": "818d302c-425a-46cf-a0b3-0d6987487f54",
            "structured_type": "structured",
            "mapping_index": 3
        },
        "event": "mapping_hover",
        "id": "YKf5Sqpgjet9We2zwJnE"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:07:32.000",
        "data": {
            "detail_level": "high",
            "section_id": "818d302c-425a-46cf-a0b3-0d6987487f54",
            "structured_type": "structured",
            "mapping_index": 1
        },
        "event": "mapping_hover",
        "id": "c1d4pJ5UiqAN4HkUFDll"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:07:32.000",
        "data": {
            "detail_level": "high",
            "section_id": "818d302c-425a-46cf-a0b3-0d6987487f54",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "pYgE4gyoc9wIGHyOXBIA"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:07:32.000",
        "data": {
            "detail_level": "high",
            "section_id": "818d302c-425a-46cf-a0b3-0d6987487f54",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "zDU1x1w7dWAHmvPoeVmq"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:07:36.000",
        "data": {
            "detail_level": "high",
            "section_id": "818d302c-425a-46cf-a0b3-0d6987487f54",
            "structured_type": "structured",
            "mapping_index": 6
        },
        "event": "mapping_hover",
        "id": "DjJmUk77wLnVe7WebEZD"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:07:36.000",
        "data": {
            "detail_level": "high",
            "section_id": "818d302c-425a-46cf-a0b3-0d6987487f54",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "NbD9fSgN7WYVdbJkycrm"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:07:36.000",
        "data": {
            "detail_level": "high",
            "section_id": "818d302c-425a-46cf-a0b3-0d6987487f54",
            "structured_type": "structured",
            "mapping_index": 4
        },
        "event": "mapping_hover",
        "id": "PuZYFtRtOVux9mWCHMpg"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:07:36.000",
        "data": {
            "detail_level": "high",
            "section_id": "818d302c-425a-46cf-a0b3-0d6987487f54",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "k73zeAnrdWEu2l05vgTP"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:07:36.000",
        "data": {
            "detail_level": "high",
            "section_id": "818d302c-425a-46cf-a0b3-0d6987487f54",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "neizR3QjeWJBOKQOLxE1"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:07:36.000",
        "data": {
            "detail_level": "high",
            "section_id": "818d302c-425a-46cf-a0b3-0d6987487f54",
            "structured_type": "structured",
            "mapping_index": 3
        },
        "event": "mapping_hover",
        "id": "rw1vDE9axp932OYubp1z"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:07:36.000",
        "data": {
            "detail_level": "high",
            "section_id": "818d302c-425a-46cf-a0b3-0d6987487f54",
            "structured_type": "structured",
            "mapping_index": 5
        },
        "event": "mapping_hover",
        "id": "uTOJN0pPWTWbx6QXBJhh"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:07:37.000",
        "data": {
            "detail_level": "high",
            "section_id": "818d302c-425a-46cf-a0b3-0d6987487f54",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "7CK1ssUwoghZzK4PBGgd"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:07:37.000",
        "data": {
            "detail_level": "high",
            "section_id": "818d302c-425a-46cf-a0b3-0d6987487f54",
            "structured_type": "structured",
            "mapping_index": 7
        },
        "event": "mapping_hover",
        "id": "FUgjkXeEpmKq8A2MzhxC"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:07:37.000",
        "data": {
            "detail_level": "high",
            "section_id": "818d302c-425a-46cf-a0b3-0d6987487f54",
            "structured_type": "structured",
            "mapping_index": 8
        },
        "event": "mapping_hover",
        "id": "KP54B2dxtQrlhNeKJTDo"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:07:37.000",
        "data": {
            "detail_level": "high",
            "section_id": "818d302c-425a-46cf-a0b3-0d6987487f54",
            "structured_type": "structured",
            "mapping_index": 5
        },
        "event": "mapping_hover",
        "id": "S3naWIMEeYG8bUZpkQv4"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:07:37.000",
        "data": {
            "detail_level": "high",
            "section_id": "818d302c-425a-46cf-a0b3-0d6987487f54",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "hDTlGvBD6kP6OxufiXLt"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:07:37.000",
        "data": {
            "detail_level": "high",
            "section_id": "818d302c-425a-46cf-a0b3-0d6987487f54",
            "structured_type": "structured",
            "mapping_index": 7
        },
        "event": "mapping_hover",
        "id": "k6pqwTYvLu01FJfxUiyC"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:07:37.000",
        "data": {
            "detail_level": "high",
            "section_id": "818d302c-425a-46cf-a0b3-0d6987487f54",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "mOgifeM9NdjBprKKh1eK"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:07:37.000",
        "data": {
            "detail_level": "high",
            "section_id": "818d302c-425a-46cf-a0b3-0d6987487f54",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "okYzeV4nvPDvKYAO9EAb"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:07:37.000",
        "data": {
            "detail_level": "high",
            "section_id": "818d302c-425a-46cf-a0b3-0d6987487f54",
            "structured_type": "structured",
            "mapping_index": 6
        },
        "event": "mapping_hover",
        "id": "uHhV1HzZTVKFDxSOHcgL"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:07:37.000",
        "data": {
            "detail_level": "high",
            "section_id": "818d302c-425a-46cf-a0b3-0d6987487f54",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "ys7MWjQMRYLBLfvU8hGe"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:07:38.000",
        "data": {
            "detail_level": "high",
            "section_id": "818d302c-425a-46cf-a0b3-0d6987487f54",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "0cKnZ8UeLGn8r99RqMis"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:07:38.000",
        "data": {
            "detail_level": "high",
            "section_id": "818d302c-425a-46cf-a0b3-0d6987487f54",
            "structured_type": "structured",
            "mapping_index": 8
        },
        "event": "mapping_hover",
        "id": "2ph64h4iaTwFd9yIglCO"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:07:38.000",
        "data": {
            "detail_level": "high",
            "section_id": "818d302c-425a-46cf-a0b3-0d6987487f54",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "455up9ij84RGpiZOCh04"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:07:38.000",
        "data": {
            "detail_level": "high",
            "section_id": "818d302c-425a-46cf-a0b3-0d6987487f54",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "Y4Iuv0rj1czovBd172Xj"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:07:38.000",
        "data": {
            "detail_level": "high",
            "section_id": "818d302c-425a-46cf-a0b3-0d6987487f54",
            "structured_type": "structured",
            "mapping_index": 6
        },
        "event": "mapping_hover",
        "id": "aRBTExdV21dC0bqMmCWg"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:07:38.000",
        "data": {
            "detail_level": "high",
            "section_id": "818d302c-425a-46cf-a0b3-0d6987487f54",
            "structured_type": "structured",
            "mapping_index": 7
        },
        "event": "mapping_hover",
        "id": "iNwarHg4JoGBwYsYSy3s"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:07:39.000",
        "data": {
            "detail_level": "high",
            "section_id": "818d302c-425a-46cf-a0b3-0d6987487f54",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "BfOwfsSOR99WxjfiLUMy"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:07:39.000",
        "data": {
            "detail_level": "high",
            "section_id": "818d302c-425a-46cf-a0b3-0d6987487f54",
            "structured_type": "structured",
            "mapping_index": 9
        },
        "event": "mapping_hover",
        "id": "HP1ini8oqYr1ZpI41p2a"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:07:41.000",
        "data": {
            "detail_level": "high",
            "section_id": "818d302c-425a-46cf-a0b3-0d6987487f54",
            "structured_type": "structured",
            "mapping_index": 8
        },
        "event": "mapping_hover",
        "id": "2YL3QyOTNVaYFfZQUONJ"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:07:41.000",
        "data": {
            "detail_level": "high",
            "section_id": "818d302c-425a-46cf-a0b3-0d6987487f54",
            "structured_type": "structured",
            "mapping_index": 6
        },
        "event": "mapping_hover",
        "id": "AF2a4vCb7z4Kjh12aK4L"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:07:41.000",
        "data": {
            "detail_level": "high",
            "section_id": "818d302c-425a-46cf-a0b3-0d6987487f54",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "AlFtNiwrO1E7DkPNpVt3"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:07:41.000",
        "data": {
            "detail_level": "high",
            "section_id": "818d302c-425a-46cf-a0b3-0d6987487f54",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "LNyjRAAGmNzHjvApPbFZ"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:07:41.000",
        "data": {
            "detail_level": "high",
            "section_id": "818d302c-425a-46cf-a0b3-0d6987487f54",
            "structured_type": "structured",
            "mapping_index": 7
        },
        "event": "mapping_hover",
        "id": "ScTKTv7YiZ1iBEoJIFed"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:07:41.000",
        "data": {
            "detail_level": "high",
            "section_id": "818d302c-425a-46cf-a0b3-0d6987487f54",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "aYBPjEsgn1p3PlsOErO1"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:07:41.000",
        "data": {
            "detail_level": "high",
            "section_id": "818d302c-425a-46cf-a0b3-0d6987487f54",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "dIfrfMrA8XFgvNyUKsRy"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:07:45.000",
        "data": {},
        "event": "click_summarize_code",
        "id": "1h2rOCPb3rK91F0Eyaez"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:07:45.000",
        "data": {
            "detail_level": "high",
            "section_id": "818d302c-425a-46cf-a0b3-0d6987487f54",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "AaCNwxQ1pUfSLuXhV0Ji"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:07:45.000",
        "data": {
            "detail_level": "high",
            "section_id": "818d302c-425a-46cf-a0b3-0d6987487f54",
            "structured_type": "structured",
            "mapping_index": 0
        },
        "event": "mapping_hover",
        "id": "AsZAsx2eIHkq3Z1bUQF7"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:07:45.000",
        "data": {
            "detail_level": "high",
            "section_id": "818d302c-425a-46cf-a0b3-0d6987487f54",
            "structured_type": "structured",
            "mapping_index": 2
        },
        "event": "mapping_hover",
        "id": "ggB9cJeiAMiFs1v8DOmk"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:07:46.000",
        "data": {
            "detail_level": "high",
            "section_id": "818d302c-425a-46cf-a0b3-0d6987487f54",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "7zngiktuCTtkU7Eli8YH"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:07:46.000",
        "data": {
            "detail_level": "high",
            "section_id": "818d302c-425a-46cf-a0b3-0d6987487f54",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "939EfO82JDaESHBs7KcO"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:07:46.000",
        "data": {
            "detail_level": "high",
            "section_id": "818d302c-425a-46cf-a0b3-0d6987487f54",
            "structured_type": "structured",
            "mapping_index": 4
        },
        "event": "mapping_hover",
        "id": "9LBWpJs3GiaO5KYFBV2h"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:07:46.000",
        "data": {
            "detail_level": "high",
            "section_id": "818d302c-425a-46cf-a0b3-0d6987487f54",
            "structured_type": "structured",
            "mapping_index": 8
        },
        "event": "mapping_hover",
        "id": "DONA6MhhG2Lm8MoicO53"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:07:46.000",
        "data": {
            "detail_level": "high",
            "section_id": "818d302c-425a-46cf-a0b3-0d6987487f54",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "DQqRwZbdQMFwJdqRnxOg"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:07:46.000",
        "data": {
            "detail_level": "high",
            "section_id": "818d302c-425a-46cf-a0b3-0d6987487f54",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "Foy6KwUWMHH9ztVI4QPP"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:07:46.000",
        "data": {
            "detail_level": "high",
            "section_id": "818d302c-425a-46cf-a0b3-0d6987487f54",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "G0mnyn0LB9GS96DU27C4"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:07:46.000",
        "data": {
            "detail_level": "high",
            "section_id": "818d302c-425a-46cf-a0b3-0d6987487f54",
            "structured_type": "structured",
            "mapping_index": 10
        },
        "event": "mapping_hover",
        "id": "GeY3VwEB7FmiE9pRpnuZ"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:07:46.000",
        "data": {
            "detail_level": "high",
            "section_id": "818d302c-425a-46cf-a0b3-0d6987487f54",
            "structured_type": "structured",
            "mapping_index": 7
        },
        "event": "mapping_hover",
        "id": "H88eRLwLzVSUDvJAJ8iE"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:07:46.000",
        "data": {
            "detail_level": "high",
            "section_id": "818d302c-425a-46cf-a0b3-0d6987487f54",
            "structured_type": "structured",
            "mapping_index": 8
        },
        "event": "mapping_hover",
        "id": "WyVY9iUqPBkEl77yom5X"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:07:46.000",
        "data": {
            "detail_level": "high",
            "section_id": "818d302c-425a-46cf-a0b3-0d6987487f54",
            "structured_type": "structured",
            "mapping_index": 9
        },
        "event": "mapping_hover",
        "id": "Xu8RIUMDlPyeEWBQunRM"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:07:46.000",
        "data": {
            "detail_level": "high",
            "section_id": "818d302c-425a-46cf-a0b3-0d6987487f54",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "XwG0suEo4d9DAbuvk67I"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:07:46.000",
        "data": {
            "detail_level": "high",
            "section_id": "818d302c-425a-46cf-a0b3-0d6987487f54",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "Zf6AkS8QqhSn10paLfmm"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:07:46.000",
        "data": {
            "detail_level": "high",
            "section_id": "818d302c-425a-46cf-a0b3-0d6987487f54",
            "structured_type": "structured",
            "mapping_index": 7
        },
        "event": "mapping_hover",
        "id": "gnMWN2HHVjCbtKi3xTc7"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:07:46.000",
        "data": {
            "detail_level": "high",
            "section_id": "818d302c-425a-46cf-a0b3-0d6987487f54",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "hyNErTU0dVT1Vm8H9uAL"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:07:46.000",
        "data": {
            "detail_level": "high",
            "section_id": "818d302c-425a-46cf-a0b3-0d6987487f54",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "oGKFTvCAnSd5sYWitNK3"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:07:46.000",
        "data": {
            "detail_level": "high",
            "section_id": "818d302c-425a-46cf-a0b3-0d6987487f54",
            "structured_type": "structured",
            "mapping_index": 3
        },
        "event": "mapping_hover",
        "id": "tYTPLoOZeLAo5XWPPuBW"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:07:46.000",
        "data": {
            "detail_level": "high",
            "section_id": "818d302c-425a-46cf-a0b3-0d6987487f54",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "wvNDaxwYeOJk2JGkrKKr"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:07:46.000",
        "data": {
            "detail_level": "high",
            "section_id": "818d302c-425a-46cf-a0b3-0d6987487f54",
            "structured_type": "structured",
            "mapping_index": 8
        },
        "event": "mapping_hover",
        "id": "xH2z4Mndvdeec7N84Bod"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:07:46.000",
        "data": {
            "detail_level": "high",
            "section_id": "818d302c-425a-46cf-a0b3-0d6987487f54",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "y8YHmxS8ImXkjHT7pO9A"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:07:46.000",
        "data": {
            "detail_level": "high",
            "section_id": "818d302c-425a-46cf-a0b3-0d6987487f54",
            "structured_type": "structured",
            "mapping_index": 9
        },
        "event": "mapping_hover",
        "id": "zhC0Q80ywNXPXTYqvzJm"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:07:47.000",
        "data": {
            "detail_level": "high",
            "section_id": "818d302c-425a-46cf-a0b3-0d6987487f54",
            "structured_type": "structured",
            "mapping_index": 10
        },
        "event": "mapping_hover",
        "id": "1PJ2IGG2zxQefmPOtC1j"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:07:47.000",
        "data": {
            "detail_level": "high",
            "section_id": "818d302c-425a-46cf-a0b3-0d6987487f54",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "EFQoAtWcrBzbRjDMLKfB"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:07:47.000",
        "data": {
            "detail_level": "high",
            "section_id": "818d302c-425a-46cf-a0b3-0d6987487f54",
            "structured_type": "structured",
            "mapping_index": 9
        },
        "event": "mapping_hover",
        "id": "FqpxYodYmDDbvKuK6F0u"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:07:47.000",
        "data": {
            "detail_level": "high",
            "section_id": "818d302c-425a-46cf-a0b3-0d6987487f54",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "Hx7IIjyaIlbFSruw3O61"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:07:48.000",
        "data": {
            "detail_level": "high",
            "section_id": "818d302c-425a-46cf-a0b3-0d6987487f54",
            "structured_type": "structured",
            "mapping_index": 9
        },
        "event": "mapping_hover",
        "id": "fHSERl9e4GePtvpFnabr"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:07:48.000",
        "data": {
            "detail_level": "high",
            "section_id": "818d302c-425a-46cf-a0b3-0d6987487f54",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "gTxxAfF4WTNVTCwq8zjo"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:07:48.000",
        "data": {
            "detail_level": "high",
            "section_id": "818d302c-425a-46cf-a0b3-0d6987487f54",
            "structured_type": "structured",
            "mapping_index": 10
        },
        "event": "mapping_hover",
        "id": "nqpn3QkSv4x3LCXf4Ylc"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:07:50.000",
        "data": {
            "detail_level": "high",
            "section_id": "818d302c-425a-46cf-a0b3-0d6987487f54",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "4zs74lIGsU42uVLxmE3i"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:07:50.000",
        "data": {
            "detail_level": "high",
            "section_id": "818d302c-425a-46cf-a0b3-0d6987487f54",
            "structured_type": "structured",
            "mapping_index": 8
        },
        "event": "mapping_hover",
        "id": "GhLUwDHoOsQrD5rEjneI"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:07:50.000",
        "data": {
            "detail_level": "high",
            "section_id": "818d302c-425a-46cf-a0b3-0d6987487f54",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "GikTqr7qWp2RmJqk2XdK"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:07:50.000",
        "data": {
            "detail_level": "high",
            "section_id": "818d302c-425a-46cf-a0b3-0d6987487f54",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "GinWMi0nTJhwtpvdUZJl"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:07:50.000",
        "data": {
            "detail_level": "high",
            "section_id": "818d302c-425a-46cf-a0b3-0d6987487f54",
            "structured_type": "structured",
            "mapping_index": 7
        },
        "event": "mapping_hover",
        "id": "NacLB8sK97vCGR6B9Mvt"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:07:50.000",
        "data": {
            "detail_level": "high",
            "section_id": "818d302c-425a-46cf-a0b3-0d6987487f54",
            "structured_type": "structured",
            "mapping_index": 8
        },
        "event": "mapping_hover",
        "id": "XNVbCmmKBDkhjsRTmWHY"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:07:50.000",
        "data": {
            "detail_level": "high",
            "section_id": "818d302c-425a-46cf-a0b3-0d6987487f54",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "kEEyjF5L0qvlZKopJm1d"
    },
    {
        "source": "backend",
        "timestamp": "2025-08-23 14:07:52.000",
        "data": {
            "summary": {
                "high_unstructured": "The scrape_season_stats function downloads per-game NBA player statistics for a specified year by reading the relevant table from Basketball Reference. It removes any repeated header rows that may appear in the data and adds a 'Year' column to each row. The function then filters the DataFrame to retain only the columns for player name, year, points, assists, rebounds, and field goal percentage, and drops any rows where these key statistics are missing. Finally, it returns the cleaned and structured DataFrame for further analysis.",
                "low_structured": "• Scrapes NBA per-game stats for a specified year\n• Keeps only key player statistics\n• Returns cleaned data",
                "high_structured": "• Downloads NBA per-game player statistics for a specified year from Basketball Reference\n• Reads the first HTML table from the stats page\n  ◦ Removes any rows where the 'Player' column contains the header string, eliminating repeated headers\n• Adds a 'Year' column to the DataFrame for context\n• Filters the DataFrame to keep only:\n  ◦ Player name\n  ◦ Year\n  ◦ Points (PTS)\n  ◦ Assists (AST)\n  ◦ Rebounds (TRB)\n  ◦ Field Goal Percentage (FG%)\n• Drops rows with missing values in any of the key statistical columns\n• Returns the cleaned DataFrame for further use",
                "title": "Summary of scrape_season_stats Function",
                "medium_unstructured": "The scrape_season_stats function retrieves NBA per-game statistics for a specified year from Basketball Reference. It processes the data to remove duplicate headers and keeps only relevant columns such as player name, points, assists, rebounds, and field goal percentage. The function returns a cleaned DataFrame with these stats and the year.",
                "medium_structured": "• Fetches NBA per-game stats for a given year from Basketball Reference\n• Processes the HTML table to remove repeated header rows\n• Keeps only selected columns: Player, Year, PTS, AST, TRB, FG%\n• Removes rows with missing values in key stats\n• Returns the cleaned DataFrame",
                "low_unstructured": "This function scrapes and processes NBA per-game player stats for a given year."
            },
            "selected_code": "def scrape_season_stats(year):\n    base_url_reg = (\n        f\"https://www.basketball-reference.com/leagues/NBA_{year}_per_game.html\"\n    )\n    df_reg = pd.read_html(base_url_reg, header=0)[0]\n    df_reg = df_reg[df_reg[\"Player\"] != \"Player\"]  # remove repeated header rows\n    df_reg[\"Year\"] = year\n\n    df_reg = df_reg[\n        [\"Player\", \"Year\", \"PTS\", \"AST\", \"TRB\", \"FG%\"]\n    ]  # Keep only specified columns\n    df_reg = df_reg.dropna(\n        subset=[\"PTS\", \"AST\", \"TRB\", \"FG%\"]\n    )  # Ensure key stats aren't invalid\n    return df_reg"
        },
        "event": "summarize_selected_code",
        "id": "jJeW4f4cAA1qCbW8Tskk"
    },
    {
        "source": "backend",
        "timestamp": "2025-08-23 14:07:54.000",
        "data": {
            "summary": "• Scrapes NBA per-game stats for a specified year\n• Keeps only key player statistics\n• Returns cleaned data",
            "code": "22: def scrape_season_stats(year):\n23:     base_url_reg = (\n24:         f\"https://www.basketball-reference.com/leagues/NBA_{year}_per_game.html\"\n25:     )\n26:     df_reg = pd.read_html(base_url_reg, header=0)[0]\n27:     df_reg = df_reg[df_reg[\"Player\"] != \"Player\"]  # remove repeated header rows\n28:     df_reg[\"Year\"] = year\n29: \n30:     df_reg = df_reg[\n31:         [\"Player\", \"Year\", \"PTS\", \"AST\", \"TRB\", \"FG%\"]\n32:     ]  # Keep only specified columns\n33:     df_reg = df_reg.dropna(\n34:         subset=[\"PTS\", \"AST\", \"TRB\", \"FG%\"]\n35:     )  # Ensure key stats aren't invalid\n36:     return df_reg",
            "mapping": [
                {
                    "codeSegments": [
                        {
                            "line": 22,
                            "code": "def scrape_season_stats(year):"
                        },
                        {
                            "line": 23,
                            "code": "base_url_reg = (\n    f\"https://www.basketball-reference.com/leagues/NBA_{year}_per_game.html\"\n)"
                        },
                        {
                            "line": 26,
                            "code": "df_reg = pd.read_html(base_url_reg, header=0)[0]"
                        }
                    ],
                    "summaryComponent": "Scrapes NBA per-game stats for a specified year"
                },
                {
                    "codeSegments": [
                        {
                            "line": 30,
                            "code": "df_reg = df_reg[\n    [\"Player\", \"Year\", \"PTS\", \"AST\", \"TRB\", \"FG%\"]\n]"
                        }
                    ],
                    "summaryComponent": "Keeps only key player statistics"
                },
                {
                    "codeSegments": [
                        {
                            "line": 33,
                            "code": "df_reg = df_reg.dropna(\n    subset=[\"PTS\", \"AST\", \"TRB\", \"FG%\"]\n)"
                        },
                        {
                            "line": 36,
                            "code": "return df_reg"
                        }
                    ],
                    "summaryComponent": "Returns cleaned data"
                }
            ]
        },
        "event": "map_summary_code",
        "id": "PZx2BYJd6C1r3rmz1bRZ"
    },
    {
        "source": "backend",
        "timestamp": "2025-08-23 14:07:54.000",
        "data": {
            "summary": "• Fetches NBA per-game stats for a given year from Basketball Reference\n• Processes the HTML table to remove repeated header rows\n• Keeps only selected columns: Player, Year, PTS, AST, TRB, FG%\n• Removes rows with missing values in key stats\n• Returns the cleaned DataFrame",
            "code": "22: def scrape_season_stats(year):\n23:     base_url_reg = (\n24:         f\"https://www.basketball-reference.com/leagues/NBA_{year}_per_game.html\"\n25:     )\n26:     df_reg = pd.read_html(base_url_reg, header=0)[0]\n27:     df_reg = df_reg[df_reg[\"Player\"] != \"Player\"]  # remove repeated header rows\n28:     df_reg[\"Year\"] = year\n29: \n30:     df_reg = df_reg[\n31:         [\"Player\", \"Year\", \"PTS\", \"AST\", \"TRB\", \"FG%\"]\n32:     ]  # Keep only specified columns\n33:     df_reg = df_reg.dropna(\n34:         subset=[\"PTS\", \"AST\", \"TRB\", \"FG%\"]\n35:     )  # Ensure key stats aren't invalid\n36:     return df_reg",
            "mapping": [
                {
                    "codeSegments": [
                        {
                            "line": 23,
                            "code": "base_url_reg = (\n    f\"https://www.basketball-reference.com/leagues/NBA_{year}_per_game.html\"\n)"
                        },
                        {
                            "line": 26,
                            "code": "df_reg = pd.read_html(base_url_reg, header=0)[0]"
                        }
                    ],
                    "summaryComponent": "Fetches NBA per-game stats for a given year from Basketball Reference"
                },
                {
                    "codeSegments": [
                        {
                            "line": 27,
                            "code": "df_reg = df_reg[df_reg[\"Player\"] != \"Player\"]  # remove repeated header rows"
                        }
                    ],
                    "summaryComponent": "Processes the HTML table to remove repeated header rows"
                },
                {
                    "codeSegments": [
                        {
                            "line": 30,
                            "code": "df_reg = df_reg[\n    [\"Player\", \"Year\", \"PTS\", \"AST\", \"TRB\", \"FG%\"]\n]"
                        }
                    ],
                    "summaryComponent": "Keeps only selected columns: Player, Year, PTS, AST, TRB, FG%"
                },
                {
                    "codeSegments": [
                        {
                            "line": 33,
                            "code": "df_reg = df_reg.dropna(\n    subset=[\"PTS\", \"AST\", \"TRB\", \"FG%\"]\n)"
                        }
                    ],
                    "summaryComponent": "Removes rows with missing values in key stats"
                },
                {
                    "codeSegments": [
                        {
                            "line": 36,
                            "code": "return df_reg"
                        }
                    ],
                    "summaryComponent": "Returns the cleaned DataFrame"
                }
            ]
        },
        "event": "map_summary_code",
        "id": "o7EhnA0E5m2nXTSPYtJ0"
    },
    {
        "source": "backend",
        "timestamp": "2025-08-23 14:07:55.000",
        "data": {
            "summary": "The scrape_season_stats function retrieves NBA per-game statistics for a specified year from Basketball Reference. It processes the data to remove duplicate headers and keeps only relevant columns such as player name, points, assists, rebounds, and field goal percentage. The function returns a cleaned DataFrame with these stats and the year.",
            "code": "22: def scrape_season_stats(year):\n23:     base_url_reg = (\n24:         f\"https://www.basketball-reference.com/leagues/NBA_{year}_per_game.html\"\n25:     )\n26:     df_reg = pd.read_html(base_url_reg, header=0)[0]\n27:     df_reg = df_reg[df_reg[\"Player\"] != \"Player\"]  # remove repeated header rows\n28:     df_reg[\"Year\"] = year\n29: \n30:     df_reg = df_reg[\n31:         [\"Player\", \"Year\", \"PTS\", \"AST\", \"TRB\", \"FG%\"]\n32:     ]  # Keep only specified columns\n33:     df_reg = df_reg.dropna(\n34:         subset=[\"PTS\", \"AST\", \"TRB\", \"FG%\"]\n35:     )  # Ensure key stats aren't invalid\n36:     return df_reg",
            "mapping": [
                {
                    "codeSegments": [
                        {
                            "line": 22,
                            "code": "def scrape_season_stats(year):"
                        }
                    ],
                    "summaryComponent": "The scrape_season_stats function"
                },
                {
                    "codeSegments": [
                        {
                            "line": 23,
                            "code": "base_url_reg = ("
                        },
                        {
                            "line": 24,
                            "code": "f\"https://www.basketball-reference.com/leagues/NBA_{year}_per_game.html\""
                        },
                        {
                            "line": 26,
                            "code": "df_reg = pd.read_html(base_url_reg, header=0)[0]"
                        }
                    ],
                    "summaryComponent": "retrieves NBA per-game statistics for a specified year from Basketball Reference"
                },
                {
                    "codeSegments": [
                        {
                            "line": 27,
                            "code": "df_reg = df_reg[df_reg[\"Player\"] != \"Player\"]  # remove repeated header rows"
                        }
                    ],
                    "summaryComponent": "It processes the data to remove duplicate headers"
                },
                {
                    "codeSegments": [
                        {
                            "line": 30,
                            "code": "df_reg = df_reg["
                        },
                        {
                            "line": 31,
                            "code": "[\"Player\", \"Year\", \"PTS\", \"AST\", \"TRB\", \"FG%\"]"
                        }
                    ],
                    "summaryComponent": "and keeps only relevant columns such as player name, points, assists, rebounds, and field goal percentage"
                },
                {
                    "codeSegments": [
                        {
                            "line": 36,
                            "code": "return df_reg"
                        }
                    ],
                    "summaryComponent": "The function returns a cleaned DataFrame with these stats and the year"
                }
            ]
        },
        "event": "map_summary_code",
        "id": "0RnvqZZUIq2z8fSwTkLy"
    },
    {
        "source": "backend",
        "timestamp": "2025-08-23 14:07:55.000",
        "data": {
            "summary": "This function scrapes and processes NBA per-game player stats for a given year.",
            "code": "22: def scrape_season_stats(year):\n23:     base_url_reg = (\n24:         f\"https://www.basketball-reference.com/leagues/NBA_{year}_per_game.html\"\n25:     )\n26:     df_reg = pd.read_html(base_url_reg, header=0)[0]\n27:     df_reg = df_reg[df_reg[\"Player\"] != \"Player\"]  # remove repeated header rows\n28:     df_reg[\"Year\"] = year\n29: \n30:     df_reg = df_reg[\n31:         [\"Player\", \"Year\", \"PTS\", \"AST\", \"TRB\", \"FG%\"]\n32:     ]  # Keep only specified columns\n33:     df_reg = df_reg.dropna(\n34:         subset=[\"PTS\", \"AST\", \"TRB\", \"FG%\"]\n35:     )  # Ensure key stats aren't invalid\n36:     return df_reg",
            "mapping": [
                {
                    "codeSegments": [
                        {
                            "line": 26,
                            "code": "df_reg = pd.read_html(base_url_reg, header=0)[0]"
                        }
                    ],
                    "summaryComponent": "scrapes"
                },
                {
                    "codeSegments": [
                        {
                            "line": 27,
                            "code": "df_reg = df_reg[df_reg[\"Player\"] != \"Player\"]  # remove repeated header rows"
                        },
                        {
                            "line": 28,
                            "code": "df_reg[\"Year\"] = year"
                        },
                        {
                            "line": 30,
                            "code": "df_reg = df_reg[\n    [\"Player\", \"Year\", \"PTS\", \"AST\", \"TRB\", \"FG%\"]\n]"
                        },
                        {
                            "line": 33,
                            "code": "df_reg = df_reg.dropna(\n    subset=[\"PTS\", \"AST\", \"TRB\", \"FG%\"]\n)"
                        }
                    ],
                    "summaryComponent": "processes"
                },
                {
                    "codeSegments": [
                        {
                            "line": 23,
                            "code": "base_url_reg = (\n    f\"https://www.basketball-reference.com/leagues/NBA_{year}_per_game.html\"\n)"
                        },
                        {
                            "line": 26,
                            "code": "df_reg = pd.read_html(base_url_reg, header=0)[0]"
                        }
                    ],
                    "summaryComponent": "NBA per-game player stats"
                },
                {
                    "codeSegments": [
                        {
                            "line": 22,
                            "code": "def scrape_season_stats(year):"
                        },
                        {
                            "line": 28,
                            "code": "df_reg[\"Year\"] = year"
                        }
                    ],
                    "summaryComponent": "for a given year"
                }
            ]
        },
        "event": "map_summary_code",
        "id": "8XqDP2hhXnTCaI6moCGC"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:07:55.000",
        "data": {
            "after_section_id": "f9b0208b-12de-4f2b-80f7-7870bbeabae0",
            "before_section_id": "818d302c-425a-46cf-a0b3-0d6987487f54"
        },
        "event": "autotransit_section",
        "id": "ZY1wiM6aAXV4oj00iGWO"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:07:55.000",
        "data": {
            "section_data": {
                "editPromptValue": "",
                "summaryData": {
                    "high_unstructured": "The scrape_season_stats function downloads per-game NBA player statistics for a specified year by reading the relevant table from Basketball Reference. It removes any repeated header rows that may appear in the data and adds a 'Year' column to each row. The function then filters the DataFrame to retain only the columns for player name, year, points, assists, rebounds, and field goal percentage, and drops any rows where these key statistics are missing. Finally, it returns the cleaned and structured DataFrame for further analysis.",
                    "low_structured": "• Scrapes NBA per-game stats for a specified year\n• Keeps only key player statistics\n• Returns cleaned data",
                    "high_structured": "• Downloads NBA per-game player statistics for a specified year from Basketball Reference\n• Reads the first HTML table from the stats page\n  ◦ Removes any rows where the 'Player' column contains the header string, eliminating repeated headers\n• Adds a 'Year' column to the DataFrame for context\n• Filters the DataFrame to keep only:\n  ◦ Player name\n  ◦ Year\n  ◦ Points (PTS)\n  ◦ Assists (AST)\n  ◦ Rebounds (TRB)\n  ◦ Field Goal Percentage (FG%)\n• Drops rows with missing values in any of the key statistical columns\n• Returns the cleaned DataFrame for further use",
                    "title": "Summary of scrape_season_stats Function",
                    "medium_unstructured": "The scrape_season_stats function retrieves NBA per-game statistics for a specified year from Basketball Reference. It processes the data to remove duplicate headers and keeps only relevant columns such as player name, points, assists, rebounds, and field goal percentage. The function returns a cleaned DataFrame with these stats and the year.",
                    "medium_structured": "• Fetches NBA per-game stats for a given year from Basketball Reference\n• Processes the HTML table to remove repeated header rows\n• Keeps only selected columns: Player, Year, PTS, AST, TRB, FG%\n• Removes rows with missing values in key stats\n• Returns the cleaned DataFrame",
                    "low_unstructured": "This function scrapes and processes NBA per-game player stats for a given year."
                },
                "selectedDetailLevel": "medium",
                "title": "Summary of scrape_season_stats Function",
                "summaryMappings": {
                    "low_structured": [
                        {
                            "codeSegments": [
                                {
                                    "line": 22,
                                    "code": "def scrape_season_stats(year):"
                                },
                                {
                                    "line": 23,
                                    "code": "base_url_reg = (\n    f\"https://www.basketball-reference.com/leagues/NBA_{year}_per_game.html\"\n)"
                                },
                                {
                                    "line": 26,
                                    "code": "df_reg = pd.read_html(base_url_reg, header=0)[0]"
                                }
                            ],
                            "summaryComponent": "Scrapes NBA per-game stats for a specified year"
                        },
                        {
                            "codeSegments": [
                                {
                                    "line": 30,
                                    "code": "df_reg = df_reg[\n    [\"Player\", \"Year\", \"PTS\", \"AST\", \"TRB\", \"FG%\"]\n]"
                                }
                            ],
                            "summaryComponent": "Keeps only key player statistics"
                        },
                        {
                            "codeSegments": [
                                {
                                    "line": 33,
                                    "code": "df_reg = df_reg.dropna(\n    subset=[\"PTS\", \"AST\", \"TRB\", \"FG%\"]\n)"
                                },
                                {
                                    "line": 36,
                                    "code": "return df_reg"
                                }
                            ],
                            "summaryComponent": "Returns cleaned data"
                        }
                    ],
                    "high_structured": [
                        {
                            "codeSegments": [
                                {
                                    "line": 23,
                                    "code": "base_url_reg = (\n    f\"https://www.basketball-reference.com/leagues/NBA_{year}_per_game.html\"\n)"
                                },
                                {
                                    "line": 26,
                                    "code": "df_reg = pd.read_html(base_url_reg, header=0)[0]"
                                }
                            ],
                            "summaryComponent": "Downloads NBA per-game player statistics for a specified year from Basketball Reference"
                        },
                        {
                            "codeSegments": [
                                {
                                    "line": 26,
                                    "code": "df_reg = pd.read_html(base_url_reg, header=0)[0]"
                                }
                            ],
                            "summaryComponent": "Reads the first HTML table from the stats page"
                        },
                        {
                            "codeSegments": [
                                {
                                    "line": 27,
                                    "code": "df_reg = df_reg[df_reg[\"Player\"] != \"Player\"]  # remove repeated header rows"
                                }
                            ],
                            "summaryComponent": "Removes any rows where the 'Player' column contains the header string, eliminating repeated headers"
                        },
                        {
                            "codeSegments": [
                                {
                                    "line": 28,
                                    "code": "df_reg[\"Year\"] = year"
                                }
                            ],
                            "summaryComponent": "Adds a 'Year' column to the DataFrame for context"
                        },
                        {
                            "codeSegments": [
                                {
                                    "line": 30,
                                    "code": "df_reg = df_reg[\n    [\"Player\", \"Year\", \"PTS\", \"AST\", \"TRB\", \"FG%\"]\n]  # Keep only specified columns"
                                }
                            ],
                            "summaryComponent": "Filters the DataFrame to keep only:"
                        },
                        {
                            "codeSegments": [
                                {
                                    "line": 31,
                                    "code": "\"Player\""
                                }
                            ],
                            "summaryComponent": "Player name"
                        },
                        {
                            "codeSegments": [
                                {
                                    "line": 31,
                                    "code": "\"Year\""
                                }
                            ],
                            "summaryComponent": "Year"
                        },
                        {
                            "codeSegments": [
                                {
                                    "line": 31,
                                    "code": "\"PTS\""
                                }
                            ],
                            "summaryComponent": "Points (PTS)"
                        },
                        {
                            "codeSegments": [
                                {
                                    "line": 31,
                                    "code": "\"AST\""
                                }
                            ],
                            "summaryComponent": "Assists (AST)"
                        },
                        {
                            "codeSegments": [
                                {
                                    "line": 31,
                                    "code": "\"TRB\""
                                }
                            ],
                            "summaryComponent": "Rebounds (TRB)"
                        },
                        {
                            "codeSegments": [
                                {
                                    "line": 31,
                                    "code": "\"FG%\""
                                }
                            ],
                            "summaryComponent": "Field Goal Percentage (FG%)"
                        },
                        {
                            "codeSegments": [
                                {
                                    "line": 33,
                                    "code": "df_reg = df_reg.dropna(\n    subset=[\"PTS\", \"AST\", \"TRB\", \"FG%\"]\n)  # Ensure key stats aren't invalid"
                                }
                            ],
                            "summaryComponent": "Drops rows with missing values in any of the key statistical columns"
                        },
                        {
                            "codeSegments": [
                                {
                                    "line": 36,
                                    "code": "return df_reg"
                                }
                            ],
                            "summaryComponent": "Returns the cleaned DataFrame for further use"
                        }
                    ],
                    "medium_structured": [
                        {
                            "codeSegments": [
                                {
                                    "line": 23,
                                    "code": "base_url_reg = (\n    f\"https://www.basketball-reference.com/leagues/NBA_{year}_per_game.html\"\n)"
                                },
                                {
                                    "line": 26,
                                    "code": "df_reg = pd.read_html(base_url_reg, header=0)[0]"
                                }
                            ],
                            "summaryComponent": "Fetches NBA per-game stats for a given year from Basketball Reference"
                        },
                        {
                            "codeSegments": [
                                {
                                    "line": 27,
                                    "code": "df_reg = df_reg[df_reg[\"Player\"] != \"Player\"]  # remove repeated header rows"
                                }
                            ],
                            "summaryComponent": "Processes the HTML table to remove repeated header rows"
                        },
                        {
                            "codeSegments": [
                                {
                                    "line": 30,
                                    "code": "df_reg = df_reg[\n    [\"Player\", \"Year\", \"PTS\", \"AST\", \"TRB\", \"FG%\"]\n]"
                                }
                            ],
                            "summaryComponent": "Keeps only selected columns: Player, Year, PTS, AST, TRB, FG%"
                        },
                        {
                            "codeSegments": [
                                {
                                    "line": 33,
                                    "code": "df_reg = df_reg.dropna(\n    subset=[\"PTS\", \"AST\", \"TRB\", \"FG%\"]\n)"
                                }
                            ],
                            "summaryComponent": "Removes rows with missing values in key stats"
                        },
                        {
                            "codeSegments": [
                                {
                                    "line": 36,
                                    "code": "return df_reg"
                                }
                            ],
                            "summaryComponent": "Returns the cleaned DataFrame"
                        }
                    ],
                    "medium_unstructured": [
                        {
                            "codeSegments": [
                                {
                                    "line": 22,
                                    "code": "def scrape_season_stats(year):"
                                }
                            ],
                            "summaryComponent": "The scrape_season_stats function"
                        },
                        {
                            "codeSegments": [
                                {
                                    "line": 23,
                                    "code": "base_url_reg = ("
                                },
                                {
                                    "line": 24,
                                    "code": "f\"https://www.basketball-reference.com/leagues/NBA_{year}_per_game.html\""
                                },
                                {
                                    "line": 26,
                                    "code": "df_reg = pd.read_html(base_url_reg, header=0)[0]"
                                }
                            ],
                            "summaryComponent": "retrieves NBA per-game statistics for a specified year from Basketball Reference"
                        },
                        {
                            "codeSegments": [
                                {
                                    "line": 27,
                                    "code": "df_reg = df_reg[df_reg[\"Player\"] != \"Player\"]  # remove repeated header rows"
                                }
                            ],
                            "summaryComponent": "It processes the data to remove duplicate headers"
                        },
                        {
                            "codeSegments": [
                                {
                                    "line": 30,
                                    "code": "df_reg = df_reg["
                                },
                                {
                                    "line": 31,
                                    "code": "[\"Player\", \"Year\", \"PTS\", \"AST\", \"TRB\", \"FG%\"]"
                                }
                            ],
                            "summaryComponent": "and keeps only relevant columns such as player name, points, assists, rebounds, and field goal percentage"
                        },
                        {
                            "codeSegments": [
                                {
                                    "line": 36,
                                    "code": "return df_reg"
                                }
                            ],
                            "summaryComponent": "The function returns a cleaned DataFrame with these stats and the year"
                        }
                    ],
                    "high_unstructured": [
                        {
                            "codeSegments": [
                                {
                                    "line": 22,
                                    "code": "def scrape_season_stats(year):"
                                }
                            ],
                            "summaryComponent": "The scrape_season_stats function"
                        },
                        {
                            "codeSegments": [
                                {
                                    "line": 23,
                                    "code": "base_url_reg = ("
                                },
                                {
                                    "line": 24,
                                    "code": "f\"https://www.basketball-reference.com/leagues/NBA_{year}_per_game.html\""
                                },
                                {
                                    "line": 26,
                                    "code": "df_reg = pd.read_html(base_url_reg, header=0)[0]"
                                }
                            ],
                            "summaryComponent": "downloads per-game NBA player statistics for a specified year"
                        },
                        {
                            "codeSegments": [
                                {
                                    "line": 26,
                                    "code": "df_reg = pd.read_html(base_url_reg, header=0)[0]"
                                }
                            ],
                            "summaryComponent": "by reading the relevant table from Basketball Reference"
                        },
                        {
                            "codeSegments": [
                                {
                                    "line": 27,
                                    "code": "df_reg = df_reg[df_reg[\"Player\"] != \"Player\"]  # remove repeated header rows"
                                }
                            ],
                            "summaryComponent": "It removes any repeated header rows that may appear in the data"
                        },
                        {
                            "codeSegments": [
                                {
                                    "line": 28,
                                    "code": "df_reg[\"Year\"] = year"
                                }
                            ],
                            "summaryComponent": "and adds a 'Year' column to each row"
                        },
                        {
                            "codeSegments": [
                                {
                                    "line": 30,
                                    "code": "df_reg = df_reg["
                                },
                                {
                                    "line": 31,
                                    "code": "[\"Player\", \"Year\", \"PTS\", \"AST\", \"TRB\", \"FG%\"]"
                                }
                            ],
                            "summaryComponent": "The function then filters the DataFrame to retain only the columns for player name, year, points, assists, rebounds, and field goal percentage"
                        },
                        {
                            "codeSegments": [
                                {
                                    "line": 33,
                                    "code": "df_reg = df_reg.dropna("
                                },
                                {
                                    "line": 34,
                                    "code": "subset=[\"PTS\", \"AST\", \"TRB\", \"FG%\"]"
                                }
                            ],
                            "summaryComponent": "and drops any rows where these key statistics are missing"
                        },
                        {
                            "codeSegments": [
                                {
                                    "line": 36,
                                    "code": "return df_reg"
                                }
                            ],
                            "summaryComponent": "Finally, it returns the cleaned and structured DataFrame for further analysis."
                        }
                    ],
                    "low_unstructured": [
                        {
                            "codeSegments": [
                                {
                                    "line": 26,
                                    "code": "df_reg = pd.read_html(base_url_reg, header=0)[0]"
                                }
                            ],
                            "summaryComponent": "scrapes"
                        },
                        {
                            "codeSegments": [
                                {
                                    "line": 27,
                                    "code": "df_reg = df_reg[df_reg[\"Player\"] != \"Player\"]  # remove repeated header rows"
                                },
                                {
                                    "line": 28,
                                    "code": "df_reg[\"Year\"] = year"
                                },
                                {
                                    "line": 30,
                                    "code": "df_reg = df_reg[\n    [\"Player\", \"Year\", \"PTS\", \"AST\", \"TRB\", \"FG%\"]\n]"
                                },
                                {
                                    "line": 33,
                                    "code": "df_reg = df_reg.dropna(\n    subset=[\"PTS\", \"AST\", \"TRB\", \"FG%\"]\n)"
                                }
                            ],
                            "summaryComponent": "processes"
                        },
                        {
                            "codeSegments": [
                                {
                                    "line": 23,
                                    "code": "base_url_reg = (\n    f\"https://www.basketball-reference.com/leagues/NBA_{year}_per_game.html\"\n)"
                                },
                                {
                                    "line": 26,
                                    "code": "df_reg = pd.read_html(base_url_reg, header=0)[0]"
                                }
                            ],
                            "summaryComponent": "NBA per-game player stats"
                        },
                        {
                            "codeSegments": [
                                {
                                    "line": 22,
                                    "code": "def scrape_season_stats(year):"
                                },
                                {
                                    "line": 28,
                                    "code": "df_reg[\"Year\"] = year"
                                }
                            ],
                            "summaryComponent": "for a given year"
                        }
                    ]
                },
                "metadata": {
                    "id": "f9b0208b-12de-4f2b-80f7-7870bbeabae0",
                    "filename": "scraper.py",
                    "offset": 652,
                    "fullPath": "/project/workspace/scraper.py",
                    "originalCode": "def scrape_season_stats(year):\n    base_url_reg = (\n        f\"https://www.basketball-reference.com/leagues/NBA_{year}_per_game.html\"\n    )\n    df_reg = pd.read_html(base_url_reg, header=0)[0]\n    df_reg = df_reg[df_reg[\"Player\"] != \"Player\"]  # remove repeated header rows\n    df_reg[\"Year\"] = year\n\n    df_reg = df_reg[\n        [\"Player\", \"Year\", \"PTS\", \"AST\", \"TRB\", \"FG%\"]\n    ]  # Keep only specified columns\n    df_reg = df_reg.dropna(\n        subset=[\"PTS\", \"AST\", \"TRB\", \"FG%\"]\n    )  # Ensure key stats aren't invalid\n    return df_reg"
                },
                "createdAt": 1755986876000,
                "lines": [
                    22,
                    36
                ],
                "editPromptStructured": null,
                "selectedStructured": "unstructured",
                "editPromptDetailLevel": null
            },
            "section_id": "f9b0208b-12de-4f2b-80f7-7870bbeabae0"
        },
        "event": "create_new_section",
        "id": "x4sQ0FWwgocIWYqPzL2c"
    },
    {
        "source": "backend",
        "timestamp": "2025-08-23 14:07:56.000",
        "data": {
            "summary": "The scrape_season_stats function downloads per-game NBA player statistics for a specified year by reading the relevant table from Basketball Reference. It removes any repeated header rows that may appear in the data and adds a 'Year' column to each row. The function then filters the DataFrame to retain only the columns for player name, year, points, assists, rebounds, and field goal percentage, and drops any rows where these key statistics are missing. Finally, it returns the cleaned and structured DataFrame for further analysis.",
            "code": "22: def scrape_season_stats(year):\n23:     base_url_reg = (\n24:         f\"https://www.basketball-reference.com/leagues/NBA_{year}_per_game.html\"\n25:     )\n26:     df_reg = pd.read_html(base_url_reg, header=0)[0]\n27:     df_reg = df_reg[df_reg[\"Player\"] != \"Player\"]  # remove repeated header rows\n28:     df_reg[\"Year\"] = year\n29: \n30:     df_reg = df_reg[\n31:         [\"Player\", \"Year\", \"PTS\", \"AST\", \"TRB\", \"FG%\"]\n32:     ]  # Keep only specified columns\n33:     df_reg = df_reg.dropna(\n34:         subset=[\"PTS\", \"AST\", \"TRB\", \"FG%\"]\n35:     )  # Ensure key stats aren't invalid\n36:     return df_reg",
            "mapping": [
                {
                    "codeSegments": [
                        {
                            "line": 22,
                            "code": "def scrape_season_stats(year):"
                        }
                    ],
                    "summaryComponent": "The scrape_season_stats function"
                },
                {
                    "codeSegments": [
                        {
                            "line": 23,
                            "code": "base_url_reg = ("
                        },
                        {
                            "line": 24,
                            "code": "f\"https://www.basketball-reference.com/leagues/NBA_{year}_per_game.html\""
                        },
                        {
                            "line": 26,
                            "code": "df_reg = pd.read_html(base_url_reg, header=0)[0]"
                        }
                    ],
                    "summaryComponent": "downloads per-game NBA player statistics for a specified year"
                },
                {
                    "codeSegments": [
                        {
                            "line": 26,
                            "code": "df_reg = pd.read_html(base_url_reg, header=0)[0]"
                        }
                    ],
                    "summaryComponent": "by reading the relevant table from Basketball Reference"
                },
                {
                    "codeSegments": [
                        {
                            "line": 27,
                            "code": "df_reg = df_reg[df_reg[\"Player\"] != \"Player\"]  # remove repeated header rows"
                        }
                    ],
                    "summaryComponent": "It removes any repeated header rows that may appear in the data"
                },
                {
                    "codeSegments": [
                        {
                            "line": 28,
                            "code": "df_reg[\"Year\"] = year"
                        }
                    ],
                    "summaryComponent": "and adds a 'Year' column to each row"
                },
                {
                    "codeSegments": [
                        {
                            "line": 30,
                            "code": "df_reg = df_reg["
                        },
                        {
                            "line": 31,
                            "code": "[\"Player\", \"Year\", \"PTS\", \"AST\", \"TRB\", \"FG%\"]"
                        }
                    ],
                    "summaryComponent": "The function then filters the DataFrame to retain only the columns for player name, year, points, assists, rebounds, and field goal percentage"
                },
                {
                    "codeSegments": [
                        {
                            "line": 33,
                            "code": "df_reg = df_reg.dropna("
                        },
                        {
                            "line": 34,
                            "code": "subset=[\"PTS\", \"AST\", \"TRB\", \"FG%\"]"
                        }
                    ],
                    "summaryComponent": "and drops any rows where these key statistics are missing"
                },
                {
                    "codeSegments": [
                        {
                            "line": 36,
                            "code": "return df_reg"
                        }
                    ],
                    "summaryComponent": "Finally, it returns the cleaned and structured DataFrame for further analysis."
                }
            ]
        },
        "event": "map_summary_code",
        "id": "6Isai1kBbGy3V2i5aXor"
    },
    {
        "source": "backend",
        "timestamp": "2025-08-23 14:07:56.000",
        "data": {
            "summary": "• Downloads NBA per-game player statistics for a specified year from Basketball Reference\n• Reads the first HTML table from the stats page\n  ◦ Removes any rows where the 'Player' column contains the header string, eliminating repeated headers\n• Adds a 'Year' column to the DataFrame for context\n• Filters the DataFrame to keep only:\n  ◦ Player name\n  ◦ Year\n  ◦ Points (PTS)\n  ◦ Assists (AST)\n  ◦ Rebounds (TRB)\n  ◦ Field Goal Percentage (FG%)\n• Drops rows with missing values in any of the key statistical columns\n• Returns the cleaned DataFrame for further use",
            "code": "22: def scrape_season_stats(year):\n23:     base_url_reg = (\n24:         f\"https://www.basketball-reference.com/leagues/NBA_{year}_per_game.html\"\n25:     )\n26:     df_reg = pd.read_html(base_url_reg, header=0)[0]\n27:     df_reg = df_reg[df_reg[\"Player\"] != \"Player\"]  # remove repeated header rows\n28:     df_reg[\"Year\"] = year\n29: \n30:     df_reg = df_reg[\n31:         [\"Player\", \"Year\", \"PTS\", \"AST\", \"TRB\", \"FG%\"]\n32:     ]  # Keep only specified columns\n33:     df_reg = df_reg.dropna(\n34:         subset=[\"PTS\", \"AST\", \"TRB\", \"FG%\"]\n35:     )  # Ensure key stats aren't invalid\n36:     return df_reg",
            "mapping": [
                {
                    "codeSegments": [
                        {
                            "line": 23,
                            "code": "base_url_reg = (\n    f\"https://www.basketball-reference.com/leagues/NBA_{year}_per_game.html\"\n)"
                        },
                        {
                            "line": 26,
                            "code": "df_reg = pd.read_html(base_url_reg, header=0)[0]"
                        }
                    ],
                    "summaryComponent": "Downloads NBA per-game player statistics for a specified year from Basketball Reference"
                },
                {
                    "codeSegments": [
                        {
                            "line": 26,
                            "code": "df_reg = pd.read_html(base_url_reg, header=0)[0]"
                        }
                    ],
                    "summaryComponent": "Reads the first HTML table from the stats page"
                },
                {
                    "codeSegments": [
                        {
                            "line": 27,
                            "code": "df_reg = df_reg[df_reg[\"Player\"] != \"Player\"]  # remove repeated header rows"
                        }
                    ],
                    "summaryComponent": "Removes any rows where the 'Player' column contains the header string, eliminating repeated headers"
                },
                {
                    "codeSegments": [
                        {
                            "line": 28,
                            "code": "df_reg[\"Year\"] = year"
                        }
                    ],
                    "summaryComponent": "Adds a 'Year' column to the DataFrame for context"
                },
                {
                    "codeSegments": [
                        {
                            "line": 30,
                            "code": "df_reg = df_reg[\n    [\"Player\", \"Year\", \"PTS\", \"AST\", \"TRB\", \"FG%\"]\n]  # Keep only specified columns"
                        }
                    ],
                    "summaryComponent": "Filters the DataFrame to keep only:"
                },
                {
                    "codeSegments": [
                        {
                            "line": 31,
                            "code": "\"Player\""
                        }
                    ],
                    "summaryComponent": "Player name"
                },
                {
                    "codeSegments": [
                        {
                            "line": 31,
                            "code": "\"Year\""
                        }
                    ],
                    "summaryComponent": "Year"
                },
                {
                    "codeSegments": [
                        {
                            "line": 31,
                            "code": "\"PTS\""
                        }
                    ],
                    "summaryComponent": "Points (PTS)"
                },
                {
                    "codeSegments": [
                        {
                            "line": 31,
                            "code": "\"AST\""
                        }
                    ],
                    "summaryComponent": "Assists (AST)"
                },
                {
                    "codeSegments": [
                        {
                            "line": 31,
                            "code": "\"TRB\""
                        }
                    ],
                    "summaryComponent": "Rebounds (TRB)"
                },
                {
                    "codeSegments": [
                        {
                            "line": 31,
                            "code": "\"FG%\""
                        }
                    ],
                    "summaryComponent": "Field Goal Percentage (FG%)"
                },
                {
                    "codeSegments": [
                        {
                            "line": 33,
                            "code": "df_reg = df_reg.dropna(\n    subset=[\"PTS\", \"AST\", \"TRB\", \"FG%\"]\n)  # Ensure key stats aren't invalid"
                        }
                    ],
                    "summaryComponent": "Drops rows with missing values in any of the key statistical columns"
                },
                {
                    "codeSegments": [
                        {
                            "line": 36,
                            "code": "return df_reg"
                        }
                    ],
                    "summaryComponent": "Returns the cleaned DataFrame for further use"
                }
            ]
        },
        "event": "map_summary_code",
        "id": "KK7WFLMPX4pA8BNxI1x5"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:07:57.000",
        "data": {
            "detail_level": "medium",
            "section_id": "f9b0208b-12de-4f2b-80f7-7870bbeabae0",
            "structured_type": "unstructured"
        },
        "event": "mapping_unhover",
        "id": "NRQkTQLGqmktK3XHMiEy"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:07:57.000",
        "data": {
            "detail_level": "medium",
            "section_id": "f9b0208b-12de-4f2b-80f7-7870bbeabae0",
            "structured_type": "unstructured"
        },
        "event": "mapping_unhover",
        "id": "RcffitLU4zZg7kM216Ih"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:07:57.000",
        "data": {
            "detail_level": "medium",
            "section_id": "f9b0208b-12de-4f2b-80f7-7870bbeabae0",
            "structured_type": "unstructured",
            "mapping_index": 4
        },
        "event": "mapping_hover",
        "id": "WylDExDY6G8PZ2kUQzVN"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:07:57.000",
        "data": {
            "detail_level": "medium",
            "section_id": "f9b0208b-12de-4f2b-80f7-7870bbeabae0",
            "structured_type": "unstructured",
            "mapping_index": 3
        },
        "event": "mapping_hover",
        "id": "cZDsUBnOigN5xzgQOZMm"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:07:57.000",
        "data": {
            "detail_level": "medium",
            "section_id": "f9b0208b-12de-4f2b-80f7-7870bbeabae0",
            "structured_type": "unstructured",
            "mapping_index": 2
        },
        "event": "mapping_hover",
        "id": "r1LbAtfXyWdnF1N3T9qW"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:07:58.000",
        "data": {
            "detail_level": "medium",
            "section_id": "f9b0208b-12de-4f2b-80f7-7870bbeabae0",
            "structured_type": "unstructured"
        },
        "event": "mapping_unhover",
        "id": "8UzkKcm5gfvaenKwWywG"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:07:58.000",
        "data": {
            "detail_level": "medium",
            "section_id": "f9b0208b-12de-4f2b-80f7-7870bbeabae0",
            "structured_type": "unstructured"
        },
        "event": "mapping_unhover",
        "id": "XkePr1YjE1YZtY10AFqG"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:07:58.000",
        "data": {
            "detail_level": "medium",
            "section_id": "f9b0208b-12de-4f2b-80f7-7870bbeabae0",
            "structured_type": "unstructured",
            "mapping_index": 1
        },
        "event": "mapping_hover",
        "id": "rf1FvD8CXwcJJFkdiqxX"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:07:59.000",
        "data": {
            "before_detail_level": "medium",
            "before_structured": "unstructured",
            "section_id": "f9b0208b-12de-4f2b-80f7-7870bbeabae0",
            "after_detail_level": "high",
            "after_structured": "unstructured"
        },
        "event": "change_summary_level",
        "id": "3egsjIsBQC7B2599HJDn"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:08:00.000",
        "data": {
            "detail_level": "high",
            "section_id": "f9b0208b-12de-4f2b-80f7-7870bbeabae0",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "2eGstRnrWKAq7Uv3iE92"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:08:00.000",
        "data": {
            "detail_level": "high",
            "section_id": "f9b0208b-12de-4f2b-80f7-7870bbeabae0",
            "structured_type": "structured",
            "mapping_index": 2
        },
        "event": "mapping_hover",
        "id": "8YZhY53LFBNWerQMxhyg"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:08:00.000",
        "data": {
            "detail_level": "high",
            "section_id": "f9b0208b-12de-4f2b-80f7-7870bbeabae0",
            "structured_type": "structured",
            "mapping_index": 1
        },
        "event": "mapping_hover",
        "id": "8upXgB3ItL4yPaDa6Oij"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:08:00.000",
        "data": {
            "detail_level": "high",
            "section_id": "f9b0208b-12de-4f2b-80f7-7870bbeabae0",
            "structured_type": "structured",
            "mapping_index": 0
        },
        "event": "mapping_hover",
        "id": "98zYjgh3XwNiMMooH11M"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:08:00.000",
        "data": {
            "detail_level": "high",
            "section_id": "f9b0208b-12de-4f2b-80f7-7870bbeabae0",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "FJmcVue1cvpEPCqwoXwm"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:08:00.000",
        "data": {
            "detail_level": "high",
            "section_id": "f9b0208b-12de-4f2b-80f7-7870bbeabae0",
            "structured_type": "structured",
            "mapping_index": 11
        },
        "event": "mapping_hover",
        "id": "MhLyzc7wcD98AIpvo5by"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:08:00.000",
        "data": {
            "detail_level": "high",
            "section_id": "f9b0208b-12de-4f2b-80f7-7870bbeabae0",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "UuHgcSjfJkFV3nI21v7e"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:08:00.000",
        "data": {
            "before_detail_level": "high",
            "before_structured": "unstructured",
            "section_id": "f9b0208b-12de-4f2b-80f7-7870bbeabae0",
            "after_detail_level": "high",
            "after_structured": "structured"
        },
        "event": "change_summary_level",
        "id": "mG9pCqIuVBfPFHqzK64w"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:08:00.000",
        "data": {
            "detail_level": "high",
            "section_id": "f9b0208b-12de-4f2b-80f7-7870bbeabae0",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "oI6epRvlCh7xW1KmJGFT"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:08:00.000",
        "data": {
            "detail_level": "high",
            "section_id": "f9b0208b-12de-4f2b-80f7-7870bbeabae0",
            "structured_type": "structured",
            "mapping_index": 10
        },
        "event": "mapping_hover",
        "id": "sCl4QhQkTbLAqOCoQoBb"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:08:00.000",
        "data": {
            "detail_level": "high",
            "section_id": "f9b0208b-12de-4f2b-80f7-7870bbeabae0",
            "structured_type": "structured",
            "mapping_index": 12
        },
        "event": "mapping_hover",
        "id": "sfv170DGfrgukl3qSPOd"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:08:00.000",
        "data": {
            "detail_level": "high",
            "section_id": "f9b0208b-12de-4f2b-80f7-7870bbeabae0",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "ylpUn5jE0tdLV2xZtfVk"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:08:00.000",
        "data": {
            "detail_level": "high",
            "section_id": "f9b0208b-12de-4f2b-80f7-7870bbeabae0",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "zMRcCldmIGQPTxmsWv3I"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:08:01.000",
        "data": {
            "detail_level": "high",
            "section_id": "f9b0208b-12de-4f2b-80f7-7870bbeabae0",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "3HJnweCrWZRPSLW0n45G"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:08:01.000",
        "data": {
            "detail_level": "high",
            "section_id": "f9b0208b-12de-4f2b-80f7-7870bbeabae0",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "L3JjBWCOnVIfWN3GxPvx"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:08:01.000",
        "data": {
            "detail_level": "high",
            "section_id": "f9b0208b-12de-4f2b-80f7-7870bbeabae0",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "SDFvoWk0JD9SqN7gsmvZ"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:08:01.000",
        "data": {
            "detail_level": "high",
            "section_id": "f9b0208b-12de-4f2b-80f7-7870bbeabae0",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "XrdHdmUNbKRZypZVcH6t"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:08:01.000",
        "data": {
            "detail_level": "high",
            "section_id": "f9b0208b-12de-4f2b-80f7-7870bbeabae0",
            "structured_type": "structured",
            "mapping_index": 2
        },
        "event": "mapping_hover",
        "id": "YIK9A5atcmUkhk1jzxvz"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:08:01.000",
        "data": {
            "detail_level": "high",
            "section_id": "f9b0208b-12de-4f2b-80f7-7870bbeabae0",
            "structured_type": "structured",
            "mapping_index": 10
        },
        "event": "mapping_hover",
        "id": "YXvVhNk9LrRM7C53tdwz"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:08:01.000",
        "data": {
            "detail_level": "high",
            "section_id": "f9b0208b-12de-4f2b-80f7-7870bbeabae0",
            "structured_type": "structured",
            "mapping_index": 12
        },
        "event": "mapping_hover",
        "id": "a6kU728PjDscffGj9aSI"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:08:01.000",
        "data": {
            "detail_level": "high",
            "section_id": "f9b0208b-12de-4f2b-80f7-7870bbeabae0",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "cZkOU5Ti5HkeRaI14AjW"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:08:01.000",
        "data": {
            "detail_level": "high",
            "section_id": "f9b0208b-12de-4f2b-80f7-7870bbeabae0",
            "structured_type": "structured",
            "mapping_index": 1
        },
        "event": "mapping_hover",
        "id": "e1BbpU5kcVeobZ4Q93u8"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:08:01.000",
        "data": {
            "detail_level": "high",
            "section_id": "f9b0208b-12de-4f2b-80f7-7870bbeabae0",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "fOpH6mseOhXLI1Ox1nfP"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:08:01.000",
        "data": {
            "detail_level": "high",
            "section_id": "f9b0208b-12de-4f2b-80f7-7870bbeabae0",
            "structured_type": "structured",
            "mapping_index": 11
        },
        "event": "mapping_hover",
        "id": "mx8BrwAtolJpAjbNwOIR"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:08:01.000",
        "data": {
            "detail_level": "high",
            "section_id": "f9b0208b-12de-4f2b-80f7-7870bbeabae0",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "q1ZguhiOUTlHYumIlCr2"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:08:01.000",
        "data": {
            "detail_level": "high",
            "section_id": "f9b0208b-12de-4f2b-80f7-7870bbeabae0",
            "structured_type": "structured",
            "mapping_index": 3
        },
        "event": "mapping_hover",
        "id": "uCLedXlTSnPyL4KnFivC"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:08:01.000",
        "data": {
            "detail_level": "high",
            "section_id": "f9b0208b-12de-4f2b-80f7-7870bbeabae0",
            "structured_type": "structured",
            "mapping_index": 4
        },
        "event": "mapping_hover",
        "id": "z8NUaEXcB2xd1tIrzbvn"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:08:02.000",
        "data": {
            "detail_level": "high",
            "section_id": "f9b0208b-12de-4f2b-80f7-7870bbeabae0",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "VSreG4BgHC1nQVU1q1jj"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:08:02.000",
        "data": {
            "detail_level": "high",
            "section_id": "f9b0208b-12de-4f2b-80f7-7870bbeabae0",
            "structured_type": "structured",
            "mapping_index": 1
        },
        "event": "mapping_hover",
        "id": "ilNYRGQxfKy48Adio4rq"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:08:02.000",
        "data": {
            "detail_level": "high",
            "section_id": "f9b0208b-12de-4f2b-80f7-7870bbeabae0",
            "structured_type": "structured",
            "mapping_index": 2
        },
        "event": "mapping_hover",
        "id": "r2o39fNjrqb6XkrUjNqT"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:08:03.000",
        "data": {
            "detail_level": "high",
            "section_id": "f9b0208b-12de-4f2b-80f7-7870bbeabae0",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "1KQXnUTEVichsLHAg8vp"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:08:03.000",
        "data": {
            "detail_level": "high",
            "section_id": "f9b0208b-12de-4f2b-80f7-7870bbeabae0",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "FRwl4Uv88vbOToIGdvm1"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:08:03.000",
        "data": {
            "detail_level": "high",
            "section_id": "f9b0208b-12de-4f2b-80f7-7870bbeabae0",
            "structured_type": "structured",
            "mapping_index": 4
        },
        "event": "mapping_hover",
        "id": "H64PBMrvtsINMar43t7I"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:08:03.000",
        "data": {
            "detail_level": "high",
            "section_id": "f9b0208b-12de-4f2b-80f7-7870bbeabae0",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "WF0aGL1j0eEhMJjA3r6h"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:08:03.000",
        "data": {
            "detail_level": "high",
            "section_id": "f9b0208b-12de-4f2b-80f7-7870bbeabae0",
            "structured_type": "structured",
            "mapping_index": 3
        },
        "event": "mapping_hover",
        "id": "lQpWUDH9NcMSJdkrvYtq"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:08:04.000",
        "data": {
            "detail_level": "high",
            "section_id": "f9b0208b-12de-4f2b-80f7-7870bbeabae0",
            "structured_type": "structured",
            "mapping_index": 9
        },
        "event": "mapping_hover",
        "id": "6E2nT2mTQaug1di2tGyg"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:08:04.000",
        "data": {
            "detail_level": "high",
            "section_id": "f9b0208b-12de-4f2b-80f7-7870bbeabae0",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "8axh68H4IoKIEp8K3aC9"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:08:04.000",
        "data": {
            "detail_level": "high",
            "section_id": "f9b0208b-12de-4f2b-80f7-7870bbeabae0",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "HCeieWI4NWwLCdt1K3f1"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:08:04.000",
        "data": {
            "detail_level": "high",
            "section_id": "f9b0208b-12de-4f2b-80f7-7870bbeabae0",
            "structured_type": "structured",
            "mapping_index": 8
        },
        "event": "mapping_hover",
        "id": "UzLRrNRnMhQb0JYr7HsK"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:08:04.000",
        "data": {
            "detail_level": "high",
            "section_id": "f9b0208b-12de-4f2b-80f7-7870bbeabae0",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "c5ndQbUTIY77gXMET7lm"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:08:04.000",
        "data": {
            "detail_level": "high",
            "section_id": "f9b0208b-12de-4f2b-80f7-7870bbeabae0",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "oBMIXjuLvUbDnh5Ik43W"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:08:04.000",
        "data": {
            "detail_level": "high",
            "section_id": "f9b0208b-12de-4f2b-80f7-7870bbeabae0",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "pHHi2V9piPaQqvV9Gy7I"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:08:04.000",
        "data": {
            "detail_level": "high",
            "section_id": "f9b0208b-12de-4f2b-80f7-7870bbeabae0",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "q1zyDaSWHgPB5vyzqcjh"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:08:04.000",
        "data": {
            "detail_level": "high",
            "section_id": "f9b0208b-12de-4f2b-80f7-7870bbeabae0",
            "structured_type": "structured",
            "mapping_index": 10
        },
        "event": "mapping_hover",
        "id": "qcxQic6oS4ic5kQ9z4sn"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:08:04.000",
        "data": {
            "detail_level": "high",
            "section_id": "f9b0208b-12de-4f2b-80f7-7870bbeabae0",
            "structured_type": "structured",
            "mapping_index": 11
        },
        "event": "mapping_hover",
        "id": "qfXqN8JjpJdcRBpDDraw"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:08:04.000",
        "data": {
            "detail_level": "high",
            "section_id": "f9b0208b-12de-4f2b-80f7-7870bbeabae0",
            "structured_type": "structured",
            "mapping_index": 12
        },
        "event": "mapping_hover",
        "id": "uwNvYlC5CHYrjUIZw1lN"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:08:04.000",
        "data": {
            "detail_level": "high",
            "section_id": "f9b0208b-12de-4f2b-80f7-7870bbeabae0",
            "structured_type": "structured",
            "mapping_index": 7
        },
        "event": "mapping_hover",
        "id": "zsKQByTmuoB9gs6ZWvhL"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:08:13.000",
        "data": {
            "detail_level": "high",
            "section_id": "f9b0208b-12de-4f2b-80f7-7870bbeabae0",
            "structured_type": "structured",
            "mapping_index": 11
        },
        "event": "mapping_hover",
        "id": "RpGNltayTIfcQbLpKz2H"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:08:13.000",
        "data": {
            "structured": "structured",
            "detail_level": "high",
            "summary": "• Downloads NBA per-game player statistics for a specified year from Basketball Reference\n• Reads the first HTML table from the stats page\n  ◦ Removes any rows where the 'Player' column contains the header string, eliminating repeated headers\n• Adds a 'Year' column to the DataFrame for context\n• Filters the DataFrame to keep only:\n  ◦ Player name\n  ◦ Year\n  ◦ Points (PTS)\n  ◦ Assists (AST)\n  ◦ Rebounds (TRB)\n  ◦ Field Goal Percentage (FG%)\n• Drops rows with missing values in any of the key statistical columns\n• Returns the cleaned DataFrame for further use",
            "section_id": "f9b0208b-12de-4f2b-80f7-7870bbeabae0"
        },
        "event": "click_edit_in_prompt",
        "id": "f6YNI2dh0a3MLV3vD6s4"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:08:13.000",
        "data": {
            "detail_level": "high",
            "section_id": "f9b0208b-12de-4f2b-80f7-7870bbeabae0",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "fT5AVa4ZlEua2VNL1ZwJ"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:08:13.000",
        "data": {
            "detail_level": "high",
            "section_id": "f9b0208b-12de-4f2b-80f7-7870bbeabae0",
            "structured_type": "structured",
            "mapping_index": 2
        },
        "event": "mapping_hover",
        "id": "iTUoNQpYAhMyig31o0bs"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:08:13.000",
        "data": {
            "detail_level": "high",
            "section_id": "f9b0208b-12de-4f2b-80f7-7870bbeabae0",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "qIM2fd0JHhd6KPHWvr20"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:08:29.000",
        "data": {
            "detail_level": "high",
            "section_id": "f9b0208b-12de-4f2b-80f7-7870bbeabae0",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "9KfLG4cAyvZ0SK8jAqW0"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:08:29.000",
        "data": {
            "detail_level": "high",
            "section_id": "f9b0208b-12de-4f2b-80f7-7870bbeabae0",
            "structured_type": "structured",
            "mapping_index": 11
        },
        "event": "mapping_hover",
        "id": "CzbcuZS5S7lQZf8VjXBI"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:08:29.000",
        "data": {
            "detail_level": "high",
            "section_id": "f9b0208b-12de-4f2b-80f7-7870bbeabae0",
            "structured_type": "structured",
            "mapping_index": 10
        },
        "event": "mapping_hover",
        "id": "QwyIp4gSixRbodacgqyE"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:08:29.000",
        "data": {
            "detail_level": "high",
            "section_id": "f9b0208b-12de-4f2b-80f7-7870bbeabae0",
            "structured_type": "structured",
            "mapping_index": 12
        },
        "event": "mapping_hover",
        "id": "cEbDE2HHJ42XOvRpAJyg"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:08:29.000",
        "data": {
            "detail_level": "high",
            "section_id": "f9b0208b-12de-4f2b-80f7-7870bbeabae0",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "rINbUsTdXNYZCuShxTvb"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:08:30.000",
        "data": {
            "detail_level": "high",
            "section_id": "f9b0208b-12de-4f2b-80f7-7870bbeabae0",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "80EE20xAw9xjTUuAajCy"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:08:30.000",
        "data": {
            "detail_level": "high",
            "section_id": "f9b0208b-12de-4f2b-80f7-7870bbeabae0",
            "structured_type": "structured",
            "mapping_index": 10
        },
        "event": "mapping_hover",
        "id": "9yw1WTHgyC5RC8nI5P2n"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:08:30.000",
        "data": {
            "detail_level": "high",
            "section_id": "f9b0208b-12de-4f2b-80f7-7870bbeabae0",
            "structured_type": "structured",
            "mapping_index": 9
        },
        "event": "mapping_hover",
        "id": "KN9TaQYHmjas4bzCu1d7"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:08:30.000",
        "data": {
            "detail_level": "high",
            "section_id": "f9b0208b-12de-4f2b-80f7-7870bbeabae0",
            "structured_type": "structured",
            "mapping_index": 8
        },
        "event": "mapping_hover",
        "id": "LLlyN3w14dAYkTwYzmaH"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:08:30.000",
        "data": {
            "detail_level": "high",
            "section_id": "f9b0208b-12de-4f2b-80f7-7870bbeabae0",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "ftLmX89u8oUztwfqF1Tl"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:08:30.000",
        "data": {
            "detail_level": "high",
            "section_id": "f9b0208b-12de-4f2b-80f7-7870bbeabae0",
            "structured_type": "structured",
            "mapping_index": 7
        },
        "event": "mapping_hover",
        "id": "tHs8Qz5hnN09TfMAAaHP"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:08:30.000",
        "data": {
            "detail_level": "high",
            "section_id": "f9b0208b-12de-4f2b-80f7-7870bbeabae0",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "uCapHtMzKWyCiuREELeR"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:08:30.000",
        "data": {
            "detail_level": "high",
            "section_id": "f9b0208b-12de-4f2b-80f7-7870bbeabae0",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "wzZwMYi7tRBJQUOzh7rH"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:08:30.000",
        "data": {
            "detail_level": "high",
            "section_id": "f9b0208b-12de-4f2b-80f7-7870bbeabae0",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "yvlBrMamtvP2AKnn7H1G"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:08:39.000",
        "data": {
            "detail_level": "high",
            "section_id": "f9b0208b-12de-4f2b-80f7-7870bbeabae0",
            "structured_type": "structured",
            "mapping_index": 12
        },
        "event": "mapping_hover",
        "id": "J0twe64oUw4BDFNzFVRI"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:08:39.000",
        "data": {
            "detail_level": "high",
            "section_id": "f9b0208b-12de-4f2b-80f7-7870bbeabae0",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "NVLe2sWtJmmFb8dJOacG"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:08:39.000",
        "data": {
            "detail_level": "high",
            "section_id": "f9b0208b-12de-4f2b-80f7-7870bbeabae0",
            "structured_type": "structured",
            "mapping_index": 10
        },
        "event": "mapping_hover",
        "id": "VnLKCEQQIam5hZ49PCd5"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:08:39.000",
        "data": {
            "detail_level": "high",
            "section_id": "f9b0208b-12de-4f2b-80f7-7870bbeabae0",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "ahkkwMI3ZYBfYi7RFdf9"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:08:39.000",
        "data": {
            "detail_level": "high",
            "section_id": "f9b0208b-12de-4f2b-80f7-7870bbeabae0",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "jONio0FDtxUZUNap8TS5"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:08:39.000",
        "data": {
            "detail_level": "high",
            "section_id": "f9b0208b-12de-4f2b-80f7-7870bbeabae0",
            "structured_type": "structured",
            "mapping_index": 11
        },
        "event": "mapping_hover",
        "id": "nwgqYctgQzSS5Zgt1GXW"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:09:13.000",
        "data": {
            "instruction": "Change the url-reg to Advanced (2025): https://www.basketball-reference.com/leagues/NBA_2025_advanced.html\n\nand scrape attributes like BPM WS/48 TS% VORP WS PER and also keep the original attributes",
            "section_id": "f9b0208b-12de-4f2b-80f7-7870bbeabae0"
        },
        "event": "commit_direct_instruction",
        "id": "8kbucIiLzsREcW2cYJEh"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:09:13.000",
        "data": {
            "detail_level": "high",
            "section_id": "f9b0208b-12de-4f2b-80f7-7870bbeabae0",
            "structured_type": "structured",
            "mapping_index": 12
        },
        "event": "mapping_hover",
        "id": "H2PVqbYYAjJhqdDhY9wq"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:09:13.000",
        "data": {
            "detail_level": "high",
            "section_id": "f9b0208b-12de-4f2b-80f7-7870bbeabae0",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "ajci3Z4gP1qKC3zReFsM"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:09:13.000",
        "data": {
            "detail_level": "high",
            "section_id": "f9b0208b-12de-4f2b-80f7-7870bbeabae0",
            "structured_type": "structured",
            "mapping_index": 10
        },
        "event": "mapping_hover",
        "id": "bM0iTopjW0pk7jjdybW7"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:09:13.000",
        "data": {
            "detail_level": "high",
            "section_id": "f9b0208b-12de-4f2b-80f7-7870bbeabae0",
            "structured_type": "structured",
            "mapping_index": 11
        },
        "event": "mapping_hover",
        "id": "olb5CfMUb0PNfzjTSZ1S"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:09:13.000",
        "data": {
            "detail_level": "high",
            "section_id": "f9b0208b-12de-4f2b-80f7-7870bbeabae0",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "zHpap2qfMX6mZnNfkFyl"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:09:13.000",
        "data": {
            "detail_level": "high",
            "section_id": "f9b0208b-12de-4f2b-80f7-7870bbeabae0",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "zK1L1P9aie7RvOqQqKcH"
    },
    {
        "source": "backend",
        "timestamp": "2025-08-23 14:09:18.000",
        "data": {
            "original_code": "def scrape_season_stats(year):\n    base_url_reg = (\n        f\"https://www.basketball-reference.com/leagues/NBA_{year}_per_game.html\"\n    )\n    df_reg = pd.read_html(base_url_reg, header=0)[0]\n    df_reg = df_reg[df_reg[\"Player\"] != \"Player\"]  # remove repeated header rows\n    df_reg[\"Year\"] = year\n\n    df_reg = df_reg[\n        [\"Player\", \"Year\", \"PTS\", \"AST\", \"TRB\", \"FG%\"]\n    ]  # Keep only specified columns\n    df_reg = df_reg.dropna(\n        subset=[\"PTS\", \"AST\", \"TRB\", \"FG%\"]\n    )  # Ensure key stats aren't invalid\n    return df_reg",
            "updated_code": "def scrape_season_stats(year):\n    if year == 2025:\n        base_url_reg = (\n            f\"https://www.basketball-reference.com/leagues/NBA_{year}_advanced.html\"\n        )\n        df_reg = pd.read_html(base_url_reg, header=0)[0]\n        df_reg = df_reg[df_reg[\"Player\"] != \"Player\"]  # remove repeated header rows\n        df_reg[\"Year\"] = year\n\n        df_reg = df_reg[\n            [\n                \"Player\", \"Year\", \"PTS\", \"AST\", \"TRB\", \"FG%\",\n                \"BPM\", \"WS/48\", \"TS%\", \"VORP\", \"WS\", \"PER\"\n            ]\n        ]  # Keep specified columns\n        df_reg = df_reg.dropna(\n            subset=[\"PTS\", \"AST\", \"TRB\", \"FG%\", \"BPM\", \"WS/48\", \"TS%\", \"VORP\", \"WS\", \"PER\"]\n        )  # Ensure key stats aren't invalid\n        return df_reg\n    else:\n        base_url_reg = (\n            f\"https://www.basketball-reference.com/leagues/NBA_{year}_per_game.html\"\n        )\n        df_reg = pd.read_html(base_url_reg, header=0)[0]\n        df_reg = df_reg[df_reg[\"Player\"] != \"Player\"]  # remove repeated header rows\n        df_reg[\"Year\"] = year\n\n        df_reg = df_reg[\n            [\"Player\", \"Year\", \"PTS\", \"AST\", \"TRB\", \"FG%\"]\n        ]  # Keep only specified columns\n        df_reg = df_reg.dropna(\n            subset=[\"PTS\", \"AST\", \"TRB\", \"FG%\"]\n        )  # Ensure key stats aren't invalid\n        return df_reg",
            "instruction": "Change the url-reg to Advanced (2025): https://www.basketball-reference.com/leagues/NBA_2025_advanced.html\n\nand scrape attributes like BPM WS/48 TS% VORP WS PER and also keep the original attributes"
        },
        "event": "modify_direct_instruction",
        "id": "P4ISOtxpIs0Jfd4K9sFT"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:09:20.000",
        "data": {
            "structured": "structured",
            "detail_level": "high",
            "instruction": "Change the url-reg to Advanced (2025): https://www.basketball-reference.com/leagues/NBA_2025_advanced.html\n\nand scrape attributes like BPM WS/48 TS% VORP WS PER and also keep the original attributes",
            "original_summary": "• Downloads NBA per-game player statistics for a specified year from Basketball Reference\n• Reads the first HTML table from the stats page\n  ◦ Removes any rows where the 'Player' column contains the header string, eliminating repeated headers\n• Adds a 'Year' column to the DataFrame for context\n• Filters the DataFrame to keep only:\n  ◦ Player name\n  ◦ Year\n  ◦ Points (PTS)\n  ◦ Assists (AST)\n  ◦ Rebounds (TRB)\n  ◦ Field Goal Percentage (FG%)\n• Drops rows with missing values in any of the key statistical columns\n• Returns the cleaned DataFrame for further use",
            "section_id": "f9b0208b-12de-4f2b-80f7-7870bbeabae0"
        },
        "event": "apply_instruction_summary",
        "id": "NTz33tGAMTzqih37wHnc"
    },
    {
        "source": "backend",
        "timestamp": "2025-08-23 14:09:23.000",
        "data": {
            "original_code": "def scrape_season_stats(year):\n    base_url_reg = (\n        f\"https://www.basketball-reference.com/leagues/NBA_{year}_per_game.html\"\n    )\n    df_reg = pd.read_html(base_url_reg, header=0)[0]\n    df_reg = df_reg[df_reg[\"Player\"] != \"Player\"]  # remove repeated header rows\n    df_reg[\"Year\"] = year\n\n    df_reg = df_reg[\n        [\"Player\", \"Year\", \"PTS\", \"AST\", \"TRB\", \"FG%\"]\n    ]  # Keep only specified columns\n    df_reg = df_reg.dropna(\n        subset=[\"PTS\", \"AST\", \"TRB\", \"FG%\"]\n    )  # Ensure key stats aren't invalid\n    return df_reg",
            "instruction": "Change the url-reg to Advanced (2025): https://www.basketball-reference.com/leagues/NBA_2025_advanced.html\n\nand scrape attributes like BPM WS/48 TS% VORP WS PER and also keep the original attributes",
            "original_summary": "• Downloads NBA per-game player statistics for a specified year from Basketball Reference\n• Reads the first HTML table from the stats page\n  ◦ Removes any rows where the 'Player' column contains the header string, eliminating repeated headers\n• Adds a 'Year' column to the DataFrame for context\n• Filters the DataFrame to keep only:\n  ◦ Player name\n  ◦ Year\n  ◦ Points (PTS)\n  ◦ Assists (AST)\n  ◦ Rebounds (TRB)\n  ◦ Field Goal Percentage (FG%)\n• Drops rows with missing values in any of the key statistical columns\n• Returns the cleaned DataFrame for further use",
            "updated_summary": "• Downloads NBA advanced per-game player statistics for a specified year from Basketball Reference, using the advanced stats page for 2025: https://www.basketball-reference.com/leagues/NBA_2025_advanced.html  \n• Reads the first HTML table from the stats page  \n  ◦ Removes any rows where the 'Player' column contains the header string, eliminating repeated headers  \n• Adds a 'Year' column to the DataFrame for context  \n• Filters the DataFrame to keep only:  \n  ◦ Player name  \n  ◦ Year  \n  ◦ Points (PTS)  \n  ◦ Assists (AST)  \n  ◦ Rebounds (TRB)  \n  ◦ Field Goal Percentage (FG%)  \n  ◦ Box Plus/Minus (BPM)  \n  ◦ Win Shares per 48 minutes (WS/48)  \n  ◦ True Shooting Percentage (TS%)  \n  ◦ Value Over Replacement Player (VORP)  \n  ◦ Win Shares (WS)  \n  ◦ Player Efficiency Rating (PER)  \n• Drops rows with missing values in any of the key statistical columns  \n• Returns the cleaned DataFrame for further use"
        },
        "event": "apply_instruction_summary",
        "id": "pJ6LytsAgHCGy5RRe62F"
    },
    {
        "source": "backend",
        "timestamp": "2025-08-23 14:09:34.000",
        "data": {
            "original_code": "def scrape_season_stats(year):\n    if year == 2025:\n        base_url_reg = (\n            f\"https://www.basketball-reference.com/leagues/NBA_{year}_advanced.html\"\n        )\n        df_reg = pd.read_html(base_url_reg, header=0)[0]\n        df_reg = df_reg[df_reg[\"Player\"] != \"Player\"]  # remove repeated header rows\n        df_reg[\"Year\"] = year\n\n        df_reg = df_reg[\n            [\n                \"Player\", \"Year\", \"PTS\", \"AST\", \"TRB\", \"FG%\",\n                \"BPM\", \"WS/48\", \"TS%\", \"VORP\", \"WS\", \"PER\"\n            ]\n        ]  # Keep specified columns\n        df_reg = df_reg.dropna(\n            subset=[\"PTS\", \"AST\", \"TRB\", \"FG%\", \"BPM\", \"WS/48\", \"TS%\", \"VORP\", \"WS\", \"PER\"]\n        )  # Ensure key stats aren't invalid\n        return df_reg\n    else:\n        base_url_reg = (\n            f\"https://www.basketball-reference.com/leagues/NBA_{year}_per_game.html\"\n        )\n        df_reg = pd.read_html(base_url_reg, header=0)[0]\n        df_reg = df_reg[df_reg[\"Player\"] != \"Player\"]  # remove repeated header rows\n        df_reg[\"Year\"] = year\n\n        df_reg = df_reg[\n            [\"Player\", \"Year\", \"PTS\", \"AST\", \"TRB\", \"FG%\"]\n        ]  # Keep only specified columns\n        df_reg = df_reg.dropna(\n            subset=[\"PTS\", \"AST\", \"TRB\", \"FG%\"]\n        )  # Ensure key stats aren't invalid\n        return df_reg",
            "old_summary": {
                "high_unstructured": "The scrape_season_stats function downloads per-game NBA player statistics for a specified year by reading the relevant table from Basketball Reference. It removes any repeated header rows that may appear in the data and adds a 'Year' column to each row. The function then filters the DataFrame to retain only the columns for player name, year, points, assists, rebounds, and field goal percentage, and drops any rows where these key statistics are missing. Finally, it returns the cleaned and structured DataFrame for further analysis.",
                "low_structured": "• Scrapes NBA per-game stats for a specified year\n• Keeps only key player statistics\n• Returns cleaned data",
                "high_structured": "• Downloads NBA per-game player statistics for a specified year from Basketball Reference\n• Reads the first HTML table from the stats page\n  ◦ Removes any rows where the 'Player' column contains the header string, eliminating repeated headers\n• Adds a 'Year' column to the DataFrame for context\n• Filters the DataFrame to keep only:\n  ◦ Player name\n  ◦ Year\n  ◦ Points (PTS)\n  ◦ Assists (AST)\n  ◦ Rebounds (TRB)\n  ◦ Field Goal Percentage (FG%)\n• Drops rows with missing values in any of the key statistical columns\n• Returns the cleaned DataFrame for further use",
                "title": "Summary of scrape_season_stats Function",
                "medium_unstructured": "The scrape_season_stats function retrieves NBA per-game statistics for a specified year from Basketball Reference. It processes the data to remove duplicate headers and keeps only relevant columns such as player name, points, assists, rebounds, and field goal percentage. The function returns a cleaned DataFrame with these stats and the year.",
                "medium_structured": "• Fetches NBA per-game stats for a given year from Basketball Reference\n• Processes the HTML table to remove repeated header rows\n• Keeps only selected columns: Player, Year, PTS, AST, TRB, FG%\n• Removes rows with missing values in key stats\n• Returns the cleaned DataFrame",
                "low_unstructured": "This function scrapes and processes NBA per-game player stats for a given year."
            },
            "new_summary": {
                "high_unstructured": "The scrape_season_stats function downloads per-game NBA player statistics for a specified year by reading the relevant table from Basketball Reference, but for the year 2025, it now reads from the advanced statistics page and includes additional metrics such as BPM, WS/48, TS%, VORP, WS, and PER. It removes any repeated header rows that may appear in the data and adds a 'Year' column to each row. The function then filters the DataFrame to retain only the columns for player name, year, points, assists, rebounds, and field goal percentage for most years, and for 2025, it also retains the advanced stats columns, dropping any rows where these key statistics are missing. Finally, it returns the cleaned and structured DataFrame for further analysis.",
                "low_structured": "• Scrapes NBA per-game stats for a specified year, except for 2025\n• For 2025, scrapes advanced player statistics with additional metrics\n• Keeps only key player statistics for each case\n• Returns cleaned data",
                "high_structured": "• Downloads NBA per-game player statistics for a specified year from Basketball Reference, except for 2025\n• For 2025, downloads advanced player statistics from the advanced stats page, including additional metrics\n• Reads the first HTML table from the stats page\n  ◦ Removes any rows where the 'Player' column contains the header string, eliminating repeated headers\n• Adds a 'Year' column to the DataFrame for context\n• Filters the DataFrame to keep only:\n  ◦ For most years: Player name, Year, Points (PTS), Assists (AST), Rebounds (TRB), Field Goal Percentage (FG%)\n  ◦ For 2025: also includes BPM, WS/48, TS%, VORP, WS, and PER\n• Drops rows with missing values in any of the key statistical columns\n• Returns the cleaned DataFrame for further use",
                "title": "Summary of scrape_season_stats Function (Updated for 2025 Advanced Stats)",
                "medium_unstructured": "The scrape_season_stats function retrieves NBA per-game statistics for a specified year from Basketball Reference, but for the year 2025, it now fetches advanced statistics including metrics such as BPM, WS/48, TS%, VORP, WS, and PER. It processes the data to remove duplicate headers and keeps only relevant columns for each case. The function returns a cleaned DataFrame with these stats and the year.",
                "medium_structured": "• Fetches NBA per-game stats for a given year from Basketball Reference, except for 2025\n• For 2025, fetches advanced stats including BPM, WS/48, TS%, VORP, WS, and PER\n• Processes the HTML table to remove repeated header rows\n• Keeps only selected columns: Player, Year, PTS, AST, TRB, FG% for most years, and additional advanced stats for 2025\n• Removes rows with missing values in key stats\n• Returns the cleaned DataFrame",
                "low_unstructured": "This function scrapes and processes NBA per-game player stats for a given year, and for 2025 specifically, it now scrapes and returns advanced player statistics instead of per-game stats."
            },
            "new_code": "def scrape_season_stats(year):\n    if year == 2025:\n        base_url_reg = (\n            f\"https://www.basketball-reference.com/leagues/NBA_{year}_advanced.html\"\n        )\n        df_reg = pd.read_html(base_url_reg, header=0)[0]\n        df_reg = df_reg[df_reg[\"Player\"] != \"Player\"]  # remove repeated header rows\n        df_reg[\"Year\"] = year\n\n        df_reg = df_reg[\n            [\n                \"Player\", \"Year\", \"PTS\", \"AST\", \"TRB\", \"FG%\",\n                \"BPM\", \"WS/48\", \"TS%\", \"VORP\", \"WS\", \"PER\"\n            ]\n        ]  # Keep specified columns\n        df_reg = df_reg.dropna(\n            subset=[\"PTS\", \"AST\", \"TRB\", \"FG%\", \"BPM\", \"WS/48\", \"TS%\", \"VORP\", \"WS\", \"PER\"]\n        )  # Ensure key stats aren't invalid\n        return df_reg\n    else:\n        base_url_reg = (\n            f\"https://www.basketball-reference.com/leagues/NBA_{year}_per_game.html\"\n        )\n        df_reg = pd.read_html(base_url_reg, header=0)[0]\n        df_reg = df_reg[df_reg[\"Player\"] != \"Player\"]  # remove repeated header rows\n        df_reg[\"Year\"] = year\n\n        df_reg = df_reg[\n            [\"Player\", \"Year\", \"PTS\", \"AST\", \"TRB\", \"FG%\"]\n        ]  # Keep only specified columns\n        df_reg = df_reg.dropna(\n            subset=[\"PTS\", \"AST\", \"TRB\", \"FG%\"]\n        )  # Ensure key stats aren't invalid\n        return df_reg"
        },
        "event": "summarize_modified_code",
        "id": "wwwXjfhVSpHzWRqgZh7Z"
    },
    {
        "source": "backend",
        "timestamp": "2025-08-23 14:09:39.000",
        "data": {
            "summary": "• Scrapes NBA per-game stats for a specified year, except for 2025\n• For 2025, scrapes advanced player statistics with additional metrics\n• Keeps only key player statistics for each case\n• Returns cleaned data",
            "code": "22: def scrape_season_stats(year):\n23:     if year == 2025:\n24:         base_url_reg = (\n25:             f\"https://www.basketball-reference.com/leagues/NBA_{year}_advanced.html\"\n26:         )\n27:         df_reg = pd.read_html(base_url_reg, header=0)[0]\n28:         df_reg = df_reg[df_reg[\"Player\"] != \"Player\"]  # remove repeated header rows\n29:         df_reg[\"Year\"] = year\n30: \n31:         df_reg = df_reg[\n32:             [\n33:                 \"Player\", \"Year\", \"PTS\", \"AST\", \"TRB\", \"FG%\",\n34:                 \"BPM\", \"WS/48\", \"TS%\", \"VORP\", \"WS\", \"PER\"\n35:             ]\n36:         ]  # Keep specified columns\n37:         df_reg = df_reg.dropna(\n38:             subset=[\"PTS\", \"AST\", \"TRB\", \"FG%\", \"BPM\", \"WS/48\", \"TS%\", \"VORP\", \"WS\", \"PER\"]\n39:         )  # Ensure key stats aren't invalid\n40:         return df_reg\n41:     else:\n42:         base_url_reg = (\n43:             f\"https://www.basketball-reference.com/leagues/NBA_{year}_per_game.html\"\n44:         )\n45:         df_reg = pd.read_html(base_url_reg, header=0)[0]\n46:         df_reg = df_reg[df_reg[\"Player\"] != \"Player\"]  # remove repeated header rows\n47:         df_reg[\"Year\"] = year\n48: \n49:         df_reg = df_reg[\n50:             [\"Player\", \"Year\", \"PTS\", \"AST\", \"TRB\", \"FG%\"]\n51:         ]  # Keep only specified columns\n52:         df_reg = df_reg.dropna(\n53:             subset=[\"PTS\", \"AST\", \"TRB\", \"FG%\"]\n54:         )  # Ensure key stats aren't invalid\n55:         return df_reg",
            "mapping": [
                {
                    "codeSegments": [
                        {
                            "line": 23,
                            "code": "if year == 2025:"
                        },
                        {
                            "line": 41,
                            "code": "else:"
                        },
                        {
                            "line": 42,
                            "code": "base_url_reg = (\n    f\"https://www.basketball-reference.com/leagues/NBA_{year}_per_game.html\"\n)"
                        },
                        {
                            "line": 45,
                            "code": "df_reg = pd.read_html(base_url_reg, header=0)[0]"
                        }
                    ],
                    "summaryComponent": "Scrapes NBA per-game stats for a specified year, except for 2025"
                },
                {
                    "codeSegments": [
                        {
                            "line": 23,
                            "code": "if year == 2025:"
                        },
                        {
                            "line": 24,
                            "code": "base_url_reg = (\n    f\"https://www.basketball-reference.com/leagues/NBA_{year}_advanced.html\"\n)"
                        },
                        {
                            "line": 27,
                            "code": "df_reg = pd.read_html(base_url_reg, header=0)[0]"
                        }
                    ],
                    "summaryComponent": "For 2025, scrapes advanced player statistics with additional metrics"
                },
                {
                    "codeSegments": [
                        {
                            "line": 31,
                            "code": "df_reg = df_reg[\n    [\n        \"Player\", \"Year\", \"PTS\", \"AST\", \"TRB\", \"FG%\",\n        \"BPM\", \"WS/48\", \"TS%\", \"VORP\", \"WS\", \"PER\"\n    ]\n]"
                        },
                        {
                            "line": 49,
                            "code": "df_reg = df_reg[\n    [\"Player\", \"Year\", \"PTS\", \"AST\", \"TRB\", \"FG%\"]\n]"
                        }
                    ],
                    "summaryComponent": "Keeps only key player statistics for each case"
                },
                {
                    "codeSegments": [
                        {
                            "line": 28,
                            "code": "df_reg = df_reg[df_reg[\"Player\"] != \"Player\"]  # remove repeated header rows"
                        },
                        {
                            "line": 37,
                            "code": "df_reg = df_reg.dropna(\n    subset=[\"PTS\", \"AST\", \"TRB\", \"FG%\", \"BPM\", \"WS/48\", \"TS%\", \"VORP\", \"WS\", \"PER\"]\n)"
                        },
                        {
                            "line": 52,
                            "code": "df_reg = df_reg.dropna(\n    subset=[\"PTS\", \"AST\", \"TRB\", \"FG%\"]\n)"
                        },
                        {
                            "line": 40,
                            "code": "return df_reg"
                        },
                        {
                            "line": 55,
                            "code": "return df_reg"
                        }
                    ],
                    "summaryComponent": "Returns cleaned data"
                }
            ]
        },
        "event": "map_summary_code",
        "id": "FlbQTYwL6Y2asClc7Jo8"
    },
    {
        "source": "backend",
        "timestamp": "2025-08-23 14:09:39.000",
        "data": {
            "summary": "This function scrapes and processes NBA per-game player stats for a given year, and for 2025 specifically, it now scrapes and returns advanced player statistics instead of per-game stats.",
            "code": "22: def scrape_season_stats(year):\n23:     if year == 2025:\n24:         base_url_reg = (\n25:             f\"https://www.basketball-reference.com/leagues/NBA_{year}_advanced.html\"\n26:         )\n27:         df_reg = pd.read_html(base_url_reg, header=0)[0]\n28:         df_reg = df_reg[df_reg[\"Player\"] != \"Player\"]  # remove repeated header rows\n29:         df_reg[\"Year\"] = year\n30: \n31:         df_reg = df_reg[\n32:             [\n33:                 \"Player\", \"Year\", \"PTS\", \"AST\", \"TRB\", \"FG%\",\n34:                 \"BPM\", \"WS/48\", \"TS%\", \"VORP\", \"WS\", \"PER\"\n35:             ]\n36:         ]  # Keep specified columns\n37:         df_reg = df_reg.dropna(\n38:             subset=[\"PTS\", \"AST\", \"TRB\", \"FG%\", \"BPM\", \"WS/48\", \"TS%\", \"VORP\", \"WS\", \"PER\"]\n39:         )  # Ensure key stats aren't invalid\n40:         return df_reg\n41:     else:\n42:         base_url_reg = (\n43:             f\"https://www.basketball-reference.com/leagues/NBA_{year}_per_game.html\"\n44:         )\n45:         df_reg = pd.read_html(base_url_reg, header=0)[0]\n46:         df_reg = df_reg[df_reg[\"Player\"] != \"Player\"]  # remove repeated header rows\n47:         df_reg[\"Year\"] = year\n48: \n49:         df_reg = df_reg[\n50:             [\"Player\", \"Year\", \"PTS\", \"AST\", \"TRB\", \"FG%\"]\n51:         ]  # Keep only specified columns\n52:         df_reg = df_reg.dropna(\n53:             subset=[\"PTS\", \"AST\", \"TRB\", \"FG%\"]\n54:         )  # Ensure key stats aren't invalid\n55:         return df_reg",
            "mapping": [
                {
                    "codeSegments": [
                        {
                            "line": 22,
                            "code": "def scrape_season_stats(year):"
                        },
                        {
                            "line": 42,
                            "code": "base_url_reg = (\n    f\"https://www.basketball-reference.com/leagues/NBA_{year}_per_game.html\"\n)"
                        },
                        {
                            "line": 45,
                            "code": "df_reg = pd.read_html(base_url_reg, header=0)[0]"
                        },
                        {
                            "line": 46,
                            "code": "df_reg = df_reg[df_reg[\"Player\"] != \"Player\"]  # remove repeated header rows"
                        },
                        {
                            "line": 47,
                            "code": "df_reg[\"Year\"] = year"
                        },
                        {
                            "line": 49,
                            "code": "df_reg = df_reg[\n    [\"Player\", \"Year\", \"PTS\", \"AST\", \"TRB\", \"FG%\"]\n]"
                        },
                        {
                            "line": 52,
                            "code": "df_reg = df_reg.dropna(\n    subset=[\"PTS\", \"AST\", \"TRB\", \"FG%\"]\n)"
                        },
                        {
                            "line": 55,
                            "code": "return df_reg"
                        }
                    ],
                    "summaryComponent": "This function scrapes and processes NBA per-game player stats for a given year"
                },
                {
                    "codeSegments": [
                        {
                            "line": 23,
                            "code": "if year == 2025:"
                        }
                    ],
                    "summaryComponent": "and for 2025 specifically"
                },
                {
                    "codeSegments": [
                        {
                            "line": 24,
                            "code": "base_url_reg = (\n    f\"https://www.basketball-reference.com/leagues/NBA_{year}_advanced.html\"\n)"
                        },
                        {
                            "line": 27,
                            "code": "df_reg = pd.read_html(base_url_reg, header=0)[0]"
                        },
                        {
                            "line": 28,
                            "code": "df_reg = df_reg[df_reg[\"Player\"] != \"Player\"]  # remove repeated header rows"
                        },
                        {
                            "line": 29,
                            "code": "df_reg[\"Year\"] = year"
                        },
                        {
                            "line": 31,
                            "code": "df_reg = df_reg[\n    [\n        \"Player\", \"Year\", \"PTS\", \"AST\", \"TRB\", \"FG%\",\n        \"BPM\", \"WS/48\", \"TS%\", \"VORP\", \"WS\", \"PER\"\n    ]\n]"
                        },
                        {
                            "line": 37,
                            "code": "df_reg = df_reg.dropna(\n    subset=[\"PTS\", \"AST\", \"TRB\", \"FG%\", \"BPM\", \"WS/48\", \"TS%\", \"VORP\", \"WS\", \"PER\"]\n)"
                        },
                        {
                            "line": 40,
                            "code": "return df_reg"
                        }
                    ],
                    "summaryComponent": "it now scrapes and returns advanced player statistics instead of per-game stats"
                }
            ]
        },
        "event": "map_summary_code",
        "id": "SxycxLb29nyI8dcSYNtk"
    },
    {
        "source": "backend",
        "timestamp": "2025-08-23 14:09:40.000",
        "data": {
            "summary": "The scrape_season_stats function retrieves NBA per-game statistics for a specified year from Basketball Reference, but for the year 2025, it now fetches advanced statistics including metrics such as BPM, WS/48, TS%, VORP, WS, and PER. It processes the data to remove duplicate headers and keeps only relevant columns for each case. The function returns a cleaned DataFrame with these stats and the year.",
            "code": "22: def scrape_season_stats(year):\n23:     if year == 2025:\n24:         base_url_reg = (\n25:             f\"https://www.basketball-reference.com/leagues/NBA_{year}_advanced.html\"\n26:         )\n27:         df_reg = pd.read_html(base_url_reg, header=0)[0]\n28:         df_reg = df_reg[df_reg[\"Player\"] != \"Player\"]  # remove repeated header rows\n29:         df_reg[\"Year\"] = year\n30: \n31:         df_reg = df_reg[\n32:             [\n33:                 \"Player\", \"Year\", \"PTS\", \"AST\", \"TRB\", \"FG%\",\n34:                 \"BPM\", \"WS/48\", \"TS%\", \"VORP\", \"WS\", \"PER\"\n35:             ]\n36:         ]  # Keep specified columns\n37:         df_reg = df_reg.dropna(\n38:             subset=[\"PTS\", \"AST\", \"TRB\", \"FG%\", \"BPM\", \"WS/48\", \"TS%\", \"VORP\", \"WS\", \"PER\"]\n39:         )  # Ensure key stats aren't invalid\n40:         return df_reg\n41:     else:\n42:         base_url_reg = (\n43:             f\"https://www.basketball-reference.com/leagues/NBA_{year}_per_game.html\"\n44:         )\n45:         df_reg = pd.read_html(base_url_reg, header=0)[0]\n46:         df_reg = df_reg[df_reg[\"Player\"] != \"Player\"]  # remove repeated header rows\n47:         df_reg[\"Year\"] = year\n48: \n49:         df_reg = df_reg[\n50:             [\"Player\", \"Year\", \"PTS\", \"AST\", \"TRB\", \"FG%\"]\n51:         ]  # Keep only specified columns\n52:         df_reg = df_reg.dropna(\n53:             subset=[\"PTS\", \"AST\", \"TRB\", \"FG%\"]\n54:         )  # Ensure key stats aren't invalid\n55:         return df_reg",
            "mapping": [
                {
                    "codeSegments": [
                        {
                            "line": 22,
                            "code": "def scrape_season_stats(year):"
                        }
                    ],
                    "summaryComponent": "The scrape_season_stats function"
                },
                {
                    "codeSegments": [
                        {
                            "line": 42,
                            "code": "base_url_reg = (\n    f\"https://www.basketball-reference.com/leagues/NBA_{year}_per_game.html\"\n)"
                        },
                        {
                            "line": 45,
                            "code": "df_reg = pd.read_html(base_url_reg, header=0)[0]"
                        }
                    ],
                    "summaryComponent": "retrieves NBA per-game statistics for a specified year from Basketball Reference"
                },
                {
                    "codeSegments": [
                        {
                            "line": 23,
                            "code": "if year == 2025:"
                        },
                        {
                            "line": 24,
                            "code": "base_url_reg = (\n    f\"https://www.basketball-reference.com/leagues/NBA_{year}_advanced.html\"\n)"
                        },
                        {
                            "line": 27,
                            "code": "df_reg = pd.read_html(base_url_reg, header=0)[0]"
                        }
                    ],
                    "summaryComponent": "but for the year 2025, it now fetches advanced statistics"
                },
                {
                    "codeSegments": [
                        {
                            "line": 34,
                            "code": "\"BPM\", \"WS/48\", \"TS%\", \"VORP\", \"WS\", \"PER\""
                        }
                    ],
                    "summaryComponent": "including metrics such as BPM, WS/48, TS%, VORP, WS, and PER"
                },
                {
                    "codeSegments": [
                        {
                            "line": 28,
                            "code": "df_reg = df_reg[df_reg[\"Player\"] != \"Player\"]  # remove repeated header rows"
                        },
                        {
                            "line": 46,
                            "code": "df_reg = df_reg[df_reg[\"Player\"] != \"Player\"]  # remove repeated header rows"
                        }
                    ],
                    "summaryComponent": "It processes the data to remove duplicate headers"
                },
                {
                    "codeSegments": [
                        {
                            "line": 31,
                            "code": "df_reg = df_reg[\n    [\n        \"Player\", \"Year\", \"PTS\", \"AST\", \"TRB\", \"FG%\",\n        \"BPM\", \"WS/48\", \"TS%\", \"VORP\", \"WS\", \"PER\"\n    ]\n]"
                        },
                        {
                            "line": 49,
                            "code": "df_reg = df_reg[\n    [\"Player\", \"Year\", \"PTS\", \"AST\", \"TRB\", \"FG%\"]\n]"
                        }
                    ],
                    "summaryComponent": "and keeps only relevant columns for each case"
                },
                {
                    "codeSegments": [
                        {
                            "line": 40,
                            "code": "return df_reg"
                        },
                        {
                            "line": 55,
                            "code": "return df_reg"
                        }
                    ],
                    "summaryComponent": "The function returns a cleaned DataFrame with these stats and the year."
                }
            ]
        },
        "event": "map_summary_code",
        "id": "4vtUTrCd6syM6R9LURKS"
    },
    {
        "source": "backend",
        "timestamp": "2025-08-23 14:09:40.000",
        "data": {
            "summary": "• Fetches NBA per-game stats for a given year from Basketball Reference, except for 2025\n• For 2025, fetches advanced stats including BPM, WS/48, TS%, VORP, WS, and PER\n• Processes the HTML table to remove repeated header rows\n• Keeps only selected columns: Player, Year, PTS, AST, TRB, FG% for most years, and additional advanced stats for 2025\n• Removes rows with missing values in key stats\n• Returns the cleaned DataFrame",
            "code": "22: def scrape_season_stats(year):\n23:     if year == 2025:\n24:         base_url_reg = (\n25:             f\"https://www.basketball-reference.com/leagues/NBA_{year}_advanced.html\"\n26:         )\n27:         df_reg = pd.read_html(base_url_reg, header=0)[0]\n28:         df_reg = df_reg[df_reg[\"Player\"] != \"Player\"]  # remove repeated header rows\n29:         df_reg[\"Year\"] = year\n30: \n31:         df_reg = df_reg[\n32:             [\n33:                 \"Player\", \"Year\", \"PTS\", \"AST\", \"TRB\", \"FG%\",\n34:                 \"BPM\", \"WS/48\", \"TS%\", \"VORP\", \"WS\", \"PER\"\n35:             ]\n36:         ]  # Keep specified columns\n37:         df_reg = df_reg.dropna(\n38:             subset=[\"PTS\", \"AST\", \"TRB\", \"FG%\", \"BPM\", \"WS/48\", \"TS%\", \"VORP\", \"WS\", \"PER\"]\n39:         )  # Ensure key stats aren't invalid\n40:         return df_reg\n41:     else:\n42:         base_url_reg = (\n43:             f\"https://www.basketball-reference.com/leagues/NBA_{year}_per_game.html\"\n44:         )\n45:         df_reg = pd.read_html(base_url_reg, header=0)[0]\n46:         df_reg = df_reg[df_reg[\"Player\"] != \"Player\"]  # remove repeated header rows\n47:         df_reg[\"Year\"] = year\n48: \n49:         df_reg = df_reg[\n50:             [\"Player\", \"Year\", \"PTS\", \"AST\", \"TRB\", \"FG%\"]\n51:         ]  # Keep only specified columns\n52:         df_reg = df_reg.dropna(\n53:             subset=[\"PTS\", \"AST\", \"TRB\", \"FG%\"]\n54:         )  # Ensure key stats aren't invalid\n55:         return df_reg",
            "mapping": [
                {
                    "codeSegments": [
                        {
                            "line": 23,
                            "code": "if year == 2025:"
                        },
                        {
                            "line": 41,
                            "code": "else:"
                        },
                        {
                            "line": 42,
                            "code": "base_url_reg = (\n    f\"https://www.basketball-reference.com/leagues/NBA_{year}_per_game.html\"\n)"
                        },
                        {
                            "line": 45,
                            "code": "df_reg = pd.read_html(base_url_reg, header=0)[0]"
                        }
                    ],
                    "summaryComponent": "Fetches NBA per-game stats for a given year from Basketball Reference, except for 2025"
                },
                {
                    "codeSegments": [
                        {
                            "line": 23,
                            "code": "if year == 2025:"
                        },
                        {
                            "line": 24,
                            "code": "base_url_reg = (\n    f\"https://www.basketball-reference.com/leagues/NBA_{year}_advanced.html\"\n)"
                        },
                        {
                            "line": 27,
                            "code": "df_reg = pd.read_html(base_url_reg, header=0)[0]"
                        },
                        {
                            "line": 34,
                            "code": "\"BPM\", \"WS/48\", \"TS%\", \"VORP\", \"WS\", \"PER\""
                        }
                    ],
                    "summaryComponent": "For 2025, fetches advanced stats including BPM, WS/48, TS%, VORP, WS, and PER"
                },
                {
                    "codeSegments": [
                        {
                            "line": 28,
                            "code": "df_reg = df_reg[df_reg[\"Player\"] != \"Player\"]  # remove repeated header rows"
                        },
                        {
                            "line": 46,
                            "code": "df_reg = df_reg[df_reg[\"Player\"] != \"Player\"]  # remove repeated header rows"
                        }
                    ],
                    "summaryComponent": "Processes the HTML table to remove repeated header rows"
                },
                {
                    "codeSegments": [
                        {
                            "line": 31,
                            "code": "df_reg = df_reg[\n    [\n        \"Player\", \"Year\", \"PTS\", \"AST\", \"TRB\", \"FG%\",\n        \"BPM\", \"WS/48\", \"TS%\", \"VORP\", \"WS\", \"PER\"\n    ]\n]"
                        },
                        {
                            "line": 49,
                            "code": "df_reg = df_reg[\n    [\"Player\", \"Year\", \"PTS\", \"AST\", \"TRB\", \"FG%\"]\n]"
                        }
                    ],
                    "summaryComponent": "Keeps only selected columns: Player, Year, PTS, AST, TRB, FG% for most years, and additional advanced stats for 2025"
                },
                {
                    "codeSegments": [
                        {
                            "line": 37,
                            "code": "df_reg = df_reg.dropna(\n    subset=[\"PTS\", \"AST\", \"TRB\", \"FG%\", \"BPM\", \"WS/48\", \"TS%\", \"VORP\", \"WS\", \"PER\"]\n)"
                        },
                        {
                            "line": 52,
                            "code": "df_reg = df_reg.dropna(\n    subset=[\"PTS\", \"AST\", \"TRB\", \"FG%\"]\n)"
                        }
                    ],
                    "summaryComponent": "Removes rows with missing values in key stats"
                },
                {
                    "codeSegments": [
                        {
                            "line": 40,
                            "code": "return df_reg"
                        },
                        {
                            "line": 55,
                            "code": "return df_reg"
                        }
                    ],
                    "summaryComponent": "Returns the cleaned DataFrame"
                }
            ]
        },
        "event": "map_summary_code",
        "id": "B2EGVgG3RG7OLbTRYWWg"
    },
    {
        "source": "backend",
        "timestamp": "2025-08-23 14:09:42.000",
        "data": {
            "summary": "The scrape_season_stats function downloads per-game NBA player statistics for a specified year by reading the relevant table from Basketball Reference, but for the year 2025, it now reads from the advanced statistics page and includes additional metrics such as BPM, WS/48, TS%, VORP, WS, and PER. It removes any repeated header rows that may appear in the data and adds a 'Year' column to each row. The function then filters the DataFrame to retain only the columns for player name, year, points, assists, rebounds, and field goal percentage for most years, and for 2025, it also retains the advanced stats columns, dropping any rows where these key statistics are missing. Finally, it returns the cleaned and structured DataFrame for further analysis.",
            "code": "22: def scrape_season_stats(year):\n23:     if year == 2025:\n24:         base_url_reg = (\n25:             f\"https://www.basketball-reference.com/leagues/NBA_{year}_advanced.html\"\n26:         )\n27:         df_reg = pd.read_html(base_url_reg, header=0)[0]\n28:         df_reg = df_reg[df_reg[\"Player\"] != \"Player\"]  # remove repeated header rows\n29:         df_reg[\"Year\"] = year\n30: \n31:         df_reg = df_reg[\n32:             [\n33:                 \"Player\", \"Year\", \"PTS\", \"AST\", \"TRB\", \"FG%\",\n34:                 \"BPM\", \"WS/48\", \"TS%\", \"VORP\", \"WS\", \"PER\"\n35:             ]\n36:         ]  # Keep specified columns\n37:         df_reg = df_reg.dropna(\n38:             subset=[\"PTS\", \"AST\", \"TRB\", \"FG%\", \"BPM\", \"WS/48\", \"TS%\", \"VORP\", \"WS\", \"PER\"]\n39:         )  # Ensure key stats aren't invalid\n40:         return df_reg\n41:     else:\n42:         base_url_reg = (\n43:             f\"https://www.basketball-reference.com/leagues/NBA_{year}_per_game.html\"\n44:         )\n45:         df_reg = pd.read_html(base_url_reg, header=0)[0]\n46:         df_reg = df_reg[df_reg[\"Player\"] != \"Player\"]  # remove repeated header rows\n47:         df_reg[\"Year\"] = year\n48: \n49:         df_reg = df_reg[\n50:             [\"Player\", \"Year\", \"PTS\", \"AST\", \"TRB\", \"FG%\"]\n51:         ]  # Keep only specified columns\n52:         df_reg = df_reg.dropna(\n53:             subset=[\"PTS\", \"AST\", \"TRB\", \"FG%\"]\n54:         )  # Ensure key stats aren't invalid\n55:         return df_reg",
            "mapping": [
                {
                    "codeSegments": [
                        {
                            "line": 22,
                            "code": "def scrape_season_stats(year):"
                        },
                        {
                            "line": 42,
                            "code": "base_url_reg = (\n    f\"https://www.basketball-reference.com/leagues/NBA_{year}_per_game.html\"\n)"
                        },
                        {
                            "line": 45,
                            "code": "df_reg = pd.read_html(base_url_reg, header=0)[0]"
                        }
                    ],
                    "summaryComponent": "downloads per-game NBA player statistics for a specified year"
                },
                {
                    "codeSegments": [
                        {
                            "line": 27,
                            "code": "df_reg = pd.read_html(base_url_reg, header=0)[0]"
                        },
                        {
                            "line": 45,
                            "code": "df_reg = pd.read_html(base_url_reg, header=0)[0]"
                        }
                    ],
                    "summaryComponent": "by reading the relevant table from Basketball Reference"
                },
                {
                    "codeSegments": [
                        {
                            "line": 23,
                            "code": "if year == 2025:"
                        },
                        {
                            "line": 24,
                            "code": "base_url_reg = (\n    f\"https://www.basketball-reference.com/leagues/NBA_{year}_advanced.html\"\n)"
                        }
                    ],
                    "summaryComponent": "but for the year 2025, it now reads from the advanced statistics page"
                },
                {
                    "codeSegments": [
                        {
                            "line": 34,
                            "code": "\"BPM\", \"WS/48\", \"TS%\", \"VORP\", \"WS\", \"PER\""
                        }
                    ],
                    "summaryComponent": "and includes additional metrics such as BPM, WS/48, TS%, VORP, WS, and PER"
                },
                {
                    "codeSegments": [
                        {
                            "line": 28,
                            "code": "df_reg = df_reg[df_reg[\"Player\"] != \"Player\"]  # remove repeated header rows"
                        },
                        {
                            "line": 46,
                            "code": "df_reg = df_reg[df_reg[\"Player\"] != \"Player\"]  # remove repeated header rows"
                        }
                    ],
                    "summaryComponent": "It removes any repeated header rows that may appear in the data"
                },
                {
                    "codeSegments": [
                        {
                            "line": 29,
                            "code": "df_reg[\"Year\"] = year"
                        },
                        {
                            "line": 47,
                            "code": "df_reg[\"Year\"] = year"
                        }
                    ],
                    "summaryComponent": "and adds a 'Year' column to each row"
                },
                {
                    "codeSegments": [
                        {
                            "line": 50,
                            "code": "df_reg = df_reg[\n    [\"Player\", \"Year\", \"PTS\", \"AST\", \"TRB\", \"FG%\"]\n]"
                        }
                    ],
                    "summaryComponent": "The function then filters the DataFrame to retain only the columns for player name, year, points, assists, rebounds, and field goal percentage for most years"
                },
                {
                    "codeSegments": [
                        {
                            "line": 31,
                            "code": "df_reg = df_reg[\n    [\n        \"Player\", \"Year\", \"PTS\", \"AST\", \"TRB\", \"FG%\",\n        \"BPM\", \"WS/48\", \"TS%\", \"VORP\", \"WS\", \"PER\"\n    ]\n]"
                        }
                    ],
                    "summaryComponent": "and for 2025, it also retains the advanced stats columns"
                },
                {
                    "codeSegments": [
                        {
                            "line": 37,
                            "code": "df_reg = df_reg.dropna(\n    subset=[\"PTS\", \"AST\", \"TRB\", \"FG%\", \"BPM\", \"WS/48\", \"TS%\", \"VORP\", \"WS\", \"PER\"]\n)"
                        },
                        {
                            "line": 52,
                            "code": "df_reg = df_reg.dropna(\n    subset=[\"PTS\", \"AST\", \"TRB\", \"FG%\"]\n)"
                        }
                    ],
                    "summaryComponent": "dropping any rows where these key statistics are missing"
                },
                {
                    "codeSegments": [
                        {
                            "line": 40,
                            "code": "return df_reg"
                        },
                        {
                            "line": 55,
                            "code": "return df_reg"
                        }
                    ],
                    "summaryComponent": "Finally, it returns the cleaned and structured DataFrame for further analysis."
                }
            ]
        },
        "event": "map_summary_code",
        "id": "8E7BHB8dS1bacUumfXaN"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:09:42.000",
        "data": {
            "after_section_id": "c57d1459-fc0c-4521-815d-a88a0fc33c55",
            "before_section_id": "f9b0208b-12de-4f2b-80f7-7870bbeabae0"
        },
        "event": "autotransit_section",
        "id": "ngPIOECrcsSUsM381SeG"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:09:42.000",
        "data": {
            "section_data": {
                "editPromptValue": "",
                "summaryData": {
                    "high_unstructured": "The scrape_season_stats function downloads per-game NBA player statistics for a specified year by reading the relevant table from Basketball Reference, but for the year 2025, it now reads from the advanced statistics page and includes additional metrics such as BPM, WS/48, TS%, VORP, WS, and PER. It removes any repeated header rows that may appear in the data and adds a 'Year' column to each row. The function then filters the DataFrame to retain only the columns for player name, year, points, assists, rebounds, and field goal percentage for most years, and for 2025, it also retains the advanced stats columns, dropping any rows where these key statistics are missing. Finally, it returns the cleaned and structured DataFrame for further analysis.",
                    "low_structured": "• Scrapes NBA per-game stats for a specified year, except for 2025\n• For 2025, scrapes advanced player statistics with additional metrics\n• Keeps only key player statistics for each case\n• Returns cleaned data",
                    "high_structured": "• Downloads NBA per-game player statistics for a specified year from Basketball Reference, except for 2025\n• For 2025, downloads advanced player statistics from the advanced stats page, including additional metrics\n• Reads the first HTML table from the stats page\n  ◦ Removes any rows where the 'Player' column contains the header string, eliminating repeated headers\n• Adds a 'Year' column to the DataFrame for context\n• Filters the DataFrame to keep only:\n  ◦ For most years: Player name, Year, Points (PTS), Assists (AST), Rebounds (TRB), Field Goal Percentage (FG%)\n  ◦ For 2025: also includes BPM, WS/48, TS%, VORP, WS, and PER\n• Drops rows with missing values in any of the key statistical columns\n• Returns the cleaned DataFrame for further use",
                    "title": "Summary of scrape_season_stats Function (Updated for 2025 Advanced Stats)",
                    "medium_unstructured": "The scrape_season_stats function retrieves NBA per-game statistics for a specified year from Basketball Reference, but for the year 2025, it now fetches advanced statistics including metrics such as BPM, WS/48, TS%, VORP, WS, and PER. It processes the data to remove duplicate headers and keeps only relevant columns for each case. The function returns a cleaned DataFrame with these stats and the year.",
                    "medium_structured": "• Fetches NBA per-game stats for a given year from Basketball Reference, except for 2025\n• For 2025, fetches advanced stats including BPM, WS/48, TS%, VORP, WS, and PER\n• Processes the HTML table to remove repeated header rows\n• Keeps only selected columns: Player, Year, PTS, AST, TRB, FG% for most years, and additional advanced stats for 2025\n• Removes rows with missing values in key stats\n• Returns the cleaned DataFrame",
                    "low_unstructured": "This function scrapes and processes NBA per-game player stats for a given year, and for 2025 specifically, it now scrapes and returns advanced player statistics instead of per-game stats."
                },
                "selectedDetailLevel": "medium",
                "title": "Summary of scrape_season_stats Function (Updated for 2025 Advanced Stats)",
                "summaryMappings": {
                    "low_structured": [
                        {
                            "codeSegments": [
                                {
                                    "line": 23,
                                    "code": "if year == 2025:"
                                },
                                {
                                    "line": 41,
                                    "code": "else:"
                                },
                                {
                                    "line": 42,
                                    "code": "base_url_reg = (\n    f\"https://www.basketball-reference.com/leagues/NBA_{year}_per_game.html\"\n)"
                                },
                                {
                                    "line": 45,
                                    "code": "df_reg = pd.read_html(base_url_reg, header=0)[0]"
                                }
                            ],
                            "summaryComponent": "Scrapes NBA per-game stats for a specified year, except for 2025"
                        },
                        {
                            "codeSegments": [
                                {
                                    "line": 23,
                                    "code": "if year == 2025:"
                                },
                                {
                                    "line": 24,
                                    "code": "base_url_reg = (\n    f\"https://www.basketball-reference.com/leagues/NBA_{year}_advanced.html\"\n)"
                                },
                                {
                                    "line": 27,
                                    "code": "df_reg = pd.read_html(base_url_reg, header=0)[0]"
                                }
                            ],
                            "summaryComponent": "For 2025, scrapes advanced player statistics with additional metrics"
                        },
                        {
                            "codeSegments": [
                                {
                                    "line": 31,
                                    "code": "df_reg = df_reg[\n    [\n        \"Player\", \"Year\", \"PTS\", \"AST\", \"TRB\", \"FG%\",\n        \"BPM\", \"WS/48\", \"TS%\", \"VORP\", \"WS\", \"PER\"\n    ]\n]"
                                },
                                {
                                    "line": 49,
                                    "code": "df_reg = df_reg[\n    [\"Player\", \"Year\", \"PTS\", \"AST\", \"TRB\", \"FG%\"]\n]"
                                }
                            ],
                            "summaryComponent": "Keeps only key player statistics for each case"
                        },
                        {
                            "codeSegments": [
                                {
                                    "line": 28,
                                    "code": "df_reg = df_reg[df_reg[\"Player\"] != \"Player\"]  # remove repeated header rows"
                                },
                                {
                                    "line": 37,
                                    "code": "df_reg = df_reg.dropna(\n    subset=[\"PTS\", \"AST\", \"TRB\", \"FG%\", \"BPM\", \"WS/48\", \"TS%\", \"VORP\", \"WS\", \"PER\"]\n)"
                                },
                                {
                                    "line": 52,
                                    "code": "df_reg = df_reg.dropna(\n    subset=[\"PTS\", \"AST\", \"TRB\", \"FG%\"]\n)"
                                },
                                {
                                    "line": 40,
                                    "code": "return df_reg"
                                },
                                {
                                    "line": 55,
                                    "code": "return df_reg"
                                }
                            ],
                            "summaryComponent": "Returns cleaned data"
                        }
                    ],
                    "high_structured": [
                        {
                            "codeSegments": [
                                {
                                    "line": 23,
                                    "code": "if year == 2025:"
                                },
                                {
                                    "line": 41,
                                    "code": "else:"
                                },
                                {
                                    "line": 42,
                                    "code": "base_url_reg = (\n    f\"https://www.basketball-reference.com/leagues/NBA_{year}_per_game.html\"\n)"
                                },
                                {
                                    "line": 45,
                                    "code": "df_reg = pd.read_html(base_url_reg, header=0)[0]"
                                }
                            ],
                            "summaryComponent": "Downloads NBA per-game player statistics for a specified year from Basketball Reference, except for 2025"
                        },
                        {
                            "codeSegments": [
                                {
                                    "line": 23,
                                    "code": "if year == 2025:"
                                },
                                {
                                    "line": 24,
                                    "code": "base_url_reg = (\n    f\"https://www.basketball-reference.com/leagues/NBA_{year}_advanced.html\"\n)"
                                },
                                {
                                    "line": 27,
                                    "code": "df_reg = pd.read_html(base_url_reg, header=0)[0]"
                                }
                            ],
                            "summaryComponent": "For 2025, downloads advanced player statistics from the advanced stats page, including additional metrics"
                        },
                        {
                            "codeSegments": [
                                {
                                    "line": 27,
                                    "code": "df_reg = pd.read_html(base_url_reg, header=0)[0]"
                                },
                                {
                                    "line": 45,
                                    "code": "df_reg = pd.read_html(base_url_reg, header=0)[0]"
                                }
                            ],
                            "summaryComponent": "Reads the first HTML table from the stats page"
                        },
                        {
                            "codeSegments": [
                                {
                                    "line": 28,
                                    "code": "df_reg = df_reg[df_reg[\"Player\"] != \"Player\"]  # remove repeated header rows"
                                },
                                {
                                    "line": 46,
                                    "code": "df_reg = df_reg[df_reg[\"Player\"] != \"Player\"]  # remove repeated header rows"
                                }
                            ],
                            "summaryComponent": "Removes any rows where the 'Player' column contains the header string, eliminating repeated headers"
                        },
                        {
                            "codeSegments": [
                                {
                                    "line": 29,
                                    "code": "df_reg[\"Year\"] = year"
                                },
                                {
                                    "line": 47,
                                    "code": "df_reg[\"Year\"] = year"
                                }
                            ],
                            "summaryComponent": "Adds a 'Year' column to the DataFrame for context"
                        },
                        {
                            "codeSegments": [
                                {
                                    "line": 31,
                                    "code": "df_reg = df_reg[\n    [\n        \"Player\", \"Year\", \"PTS\", \"AST\", \"TRB\", \"FG%\",\n        \"BPM\", \"WS/48\", \"TS%\", \"VORP\", \"WS\", \"PER\"\n    ]\n]  # Keep specified columns"
                                },
                                {
                                    "line": 49,
                                    "code": "df_reg = df_reg[\n    [\"Player\", \"Year\", \"PTS\", \"AST\", \"TRB\", \"FG%\"]\n]  # Keep only specified columns"
                                }
                            ],
                            "summaryComponent": "Filters the DataFrame to keep only:"
                        },
                        {
                            "codeSegments": [
                                {
                                    "line": 49,
                                    "code": "df_reg = df_reg[\n    [\"Player\", \"Year\", \"PTS\", \"AST\", \"TRB\", \"FG%\"]\n]  # Keep only specified columns"
                                }
                            ],
                            "summaryComponent": "For most years: Player name, Year, Points (PTS), Assists (AST), Rebounds (TRB), Field Goal Percentage (FG%)"
                        },
                        {
                            "codeSegments": [
                                {
                                    "line": 31,
                                    "code": "df_reg = df_reg[\n    [\n        \"Player\", \"Year\", \"PTS\", \"AST\", \"TRB\", \"FG%\",\n        \"BPM\", \"WS/48\", \"TS%\", \"VORP\", \"WS\", \"PER\"\n    ]\n]  # Keep specified columns"
                                }
                            ],
                            "summaryComponent": "For 2025: also includes BPM, WS/48, TS%, VORP, WS, and PER"
                        },
                        {
                            "codeSegments": [
                                {
                                    "line": 37,
                                    "code": "df_reg = df_reg.dropna(\n    subset=[\"PTS\", \"AST\", \"TRB\", \"FG%\", \"BPM\", \"WS/48\", \"TS%\", \"VORP\", \"WS\", \"PER\"]\n)  # Ensure key stats aren't invalid"
                                },
                                {
                                    "line": 52,
                                    "code": "df_reg = df_reg.dropna(\n    subset=[\"PTS\", \"AST\", \"TRB\", \"FG%\"]\n)  # Ensure key stats aren't invalid"
                                }
                            ],
                            "summaryComponent": "Drops rows with missing values in any of the key statistical columns"
                        },
                        {
                            "codeSegments": [
                                {
                                    "line": 40,
                                    "code": "return df_reg"
                                },
                                {
                                    "line": 55,
                                    "code": "return df_reg"
                                }
                            ],
                            "summaryComponent": "Returns the cleaned DataFrame for further use"
                        }
                    ],
                    "medium_structured": [
                        {
                            "codeSegments": [
                                {
                                    "line": 23,
                                    "code": "if year == 2025:"
                                },
                                {
                                    "line": 41,
                                    "code": "else:"
                                },
                                {
                                    "line": 42,
                                    "code": "base_url_reg = (\n    f\"https://www.basketball-reference.com/leagues/NBA_{year}_per_game.html\"\n)"
                                },
                                {
                                    "line": 45,
                                    "code": "df_reg = pd.read_html(base_url_reg, header=0)[0]"
                                }
                            ],
                            "summaryComponent": "Fetches NBA per-game stats for a given year from Basketball Reference, except for 2025"
                        },
                        {
                            "codeSegments": [
                                {
                                    "line": 23,
                                    "code": "if year == 2025:"
                                },
                                {
                                    "line": 24,
                                    "code": "base_url_reg = (\n    f\"https://www.basketball-reference.com/leagues/NBA_{year}_advanced.html\"\n)"
                                },
                                {
                                    "line": 27,
                                    "code": "df_reg = pd.read_html(base_url_reg, header=0)[0]"
                                },
                                {
                                    "line": 34,
                                    "code": "\"BPM\", \"WS/48\", \"TS%\", \"VORP\", \"WS\", \"PER\""
                                }
                            ],
                            "summaryComponent": "For 2025, fetches advanced stats including BPM, WS/48, TS%, VORP, WS, and PER"
                        },
                        {
                            "codeSegments": [
                                {
                                    "line": 28,
                                    "code": "df_reg = df_reg[df_reg[\"Player\"] != \"Player\"]  # remove repeated header rows"
                                },
                                {
                                    "line": 46,
                                    "code": "df_reg = df_reg[df_reg[\"Player\"] != \"Player\"]  # remove repeated header rows"
                                }
                            ],
                            "summaryComponent": "Processes the HTML table to remove repeated header rows"
                        },
                        {
                            "codeSegments": [
                                {
                                    "line": 31,
                                    "code": "df_reg = df_reg[\n    [\n        \"Player\", \"Year\", \"PTS\", \"AST\", \"TRB\", \"FG%\",\n        \"BPM\", \"WS/48\", \"TS%\", \"VORP\", \"WS\", \"PER\"\n    ]\n]"
                                },
                                {
                                    "line": 49,
                                    "code": "df_reg = df_reg[\n    [\"Player\", \"Year\", \"PTS\", \"AST\", \"TRB\", \"FG%\"]\n]"
                                }
                            ],
                            "summaryComponent": "Keeps only selected columns: Player, Year, PTS, AST, TRB, FG% for most years, and additional advanced stats for 2025"
                        },
                        {
                            "codeSegments": [
                                {
                                    "line": 37,
                                    "code": "df_reg = df_reg.dropna(\n    subset=[\"PTS\", \"AST\", \"TRB\", \"FG%\", \"BPM\", \"WS/48\", \"TS%\", \"VORP\", \"WS\", \"PER\"]\n)"
                                },
                                {
                                    "line": 52,
                                    "code": "df_reg = df_reg.dropna(\n    subset=[\"PTS\", \"AST\", \"TRB\", \"FG%\"]\n)"
                                }
                            ],
                            "summaryComponent": "Removes rows with missing values in key stats"
                        },
                        {
                            "codeSegments": [
                                {
                                    "line": 40,
                                    "code": "return df_reg"
                                },
                                {
                                    "line": 55,
                                    "code": "return df_reg"
                                }
                            ],
                            "summaryComponent": "Returns the cleaned DataFrame"
                        }
                    ],
                    "medium_unstructured": [
                        {
                            "codeSegments": [
                                {
                                    "line": 22,
                                    "code": "def scrape_season_stats(year):"
                                }
                            ],
                            "summaryComponent": "The scrape_season_stats function"
                        },
                        {
                            "codeSegments": [
                                {
                                    "line": 42,
                                    "code": "base_url_reg = (\n    f\"https://www.basketball-reference.com/leagues/NBA_{year}_per_game.html\"\n)"
                                },
                                {
                                    "line": 45,
                                    "code": "df_reg = pd.read_html(base_url_reg, header=0)[0]"
                                }
                            ],
                            "summaryComponent": "retrieves NBA per-game statistics for a specified year from Basketball Reference"
                        },
                        {
                            "codeSegments": [
                                {
                                    "line": 23,
                                    "code": "if year == 2025:"
                                },
                                {
                                    "line": 24,
                                    "code": "base_url_reg = (\n    f\"https://www.basketball-reference.com/leagues/NBA_{year}_advanced.html\"\n)"
                                },
                                {
                                    "line": 27,
                                    "code": "df_reg = pd.read_html(base_url_reg, header=0)[0]"
                                }
                            ],
                            "summaryComponent": "but for the year 2025, it now fetches advanced statistics"
                        },
                        {
                            "codeSegments": [
                                {
                                    "line": 34,
                                    "code": "\"BPM\", \"WS/48\", \"TS%\", \"VORP\", \"WS\", \"PER\""
                                }
                            ],
                            "summaryComponent": "including metrics such as BPM, WS/48, TS%, VORP, WS, and PER"
                        },
                        {
                            "codeSegments": [
                                {
                                    "line": 28,
                                    "code": "df_reg = df_reg[df_reg[\"Player\"] != \"Player\"]  # remove repeated header rows"
                                },
                                {
                                    "line": 46,
                                    "code": "df_reg = df_reg[df_reg[\"Player\"] != \"Player\"]  # remove repeated header rows"
                                }
                            ],
                            "summaryComponent": "It processes the data to remove duplicate headers"
                        },
                        {
                            "codeSegments": [
                                {
                                    "line": 31,
                                    "code": "df_reg = df_reg[\n    [\n        \"Player\", \"Year\", \"PTS\", \"AST\", \"TRB\", \"FG%\",\n        \"BPM\", \"WS/48\", \"TS%\", \"VORP\", \"WS\", \"PER\"\n    ]\n]"
                                },
                                {
                                    "line": 49,
                                    "code": "df_reg = df_reg[\n    [\"Player\", \"Year\", \"PTS\", \"AST\", \"TRB\", \"FG%\"]\n]"
                                }
                            ],
                            "summaryComponent": "and keeps only relevant columns for each case"
                        },
                        {
                            "codeSegments": [
                                {
                                    "line": 40,
                                    "code": "return df_reg"
                                },
                                {
                                    "line": 55,
                                    "code": "return df_reg"
                                }
                            ],
                            "summaryComponent": "The function returns a cleaned DataFrame with these stats and the year."
                        }
                    ],
                    "high_unstructured": [
                        {
                            "codeSegments": [
                                {
                                    "line": 22,
                                    "code": "def scrape_season_stats(year):"
                                },
                                {
                                    "line": 42,
                                    "code": "base_url_reg = (\n    f\"https://www.basketball-reference.com/leagues/NBA_{year}_per_game.html\"\n)"
                                },
                                {
                                    "line": 45,
                                    "code": "df_reg = pd.read_html(base_url_reg, header=0)[0]"
                                }
                            ],
                            "summaryComponent": "downloads per-game NBA player statistics for a specified year"
                        },
                        {
                            "codeSegments": [
                                {
                                    "line": 27,
                                    "code": "df_reg = pd.read_html(base_url_reg, header=0)[0]"
                                },
                                {
                                    "line": 45,
                                    "code": "df_reg = pd.read_html(base_url_reg, header=0)[0]"
                                }
                            ],
                            "summaryComponent": "by reading the relevant table from Basketball Reference"
                        },
                        {
                            "codeSegments": [
                                {
                                    "line": 23,
                                    "code": "if year == 2025:"
                                },
                                {
                                    "line": 24,
                                    "code": "base_url_reg = (\n    f\"https://www.basketball-reference.com/leagues/NBA_{year}_advanced.html\"\n)"
                                }
                            ],
                            "summaryComponent": "but for the year 2025, it now reads from the advanced statistics page"
                        },
                        {
                            "codeSegments": [
                                {
                                    "line": 34,
                                    "code": "\"BPM\", \"WS/48\", \"TS%\", \"VORP\", \"WS\", \"PER\""
                                }
                            ],
                            "summaryComponent": "and includes additional metrics such as BPM, WS/48, TS%, VORP, WS, and PER"
                        },
                        {
                            "codeSegments": [
                                {
                                    "line": 28,
                                    "code": "df_reg = df_reg[df_reg[\"Player\"] != \"Player\"]  # remove repeated header rows"
                                },
                                {
                                    "line": 46,
                                    "code": "df_reg = df_reg[df_reg[\"Player\"] != \"Player\"]  # remove repeated header rows"
                                }
                            ],
                            "summaryComponent": "It removes any repeated header rows that may appear in the data"
                        },
                        {
                            "codeSegments": [
                                {
                                    "line": 29,
                                    "code": "df_reg[\"Year\"] = year"
                                },
                                {
                                    "line": 47,
                                    "code": "df_reg[\"Year\"] = year"
                                }
                            ],
                            "summaryComponent": "and adds a 'Year' column to each row"
                        },
                        {
                            "codeSegments": [
                                {
                                    "line": 50,
                                    "code": "df_reg = df_reg[\n    [\"Player\", \"Year\", \"PTS\", \"AST\", \"TRB\", \"FG%\"]\n]"
                                }
                            ],
                            "summaryComponent": "The function then filters the DataFrame to retain only the columns for player name, year, points, assists, rebounds, and field goal percentage for most years"
                        },
                        {
                            "codeSegments": [
                                {
                                    "line": 31,
                                    "code": "df_reg = df_reg[\n    [\n        \"Player\", \"Year\", \"PTS\", \"AST\", \"TRB\", \"FG%\",\n        \"BPM\", \"WS/48\", \"TS%\", \"VORP\", \"WS\", \"PER\"\n    ]\n]"
                                }
                            ],
                            "summaryComponent": "and for 2025, it also retains the advanced stats columns"
                        },
                        {
                            "codeSegments": [
                                {
                                    "line": 37,
                                    "code": "df_reg = df_reg.dropna(\n    subset=[\"PTS\", \"AST\", \"TRB\", \"FG%\", \"BPM\", \"WS/48\", \"TS%\", \"VORP\", \"WS\", \"PER\"]\n)"
                                },
                                {
                                    "line": 52,
                                    "code": "df_reg = df_reg.dropna(\n    subset=[\"PTS\", \"AST\", \"TRB\", \"FG%\"]\n)"
                                }
                            ],
                            "summaryComponent": "dropping any rows where these key statistics are missing"
                        },
                        {
                            "codeSegments": [
                                {
                                    "line": 40,
                                    "code": "return df_reg"
                                },
                                {
                                    "line": 55,
                                    "code": "return df_reg"
                                }
                            ],
                            "summaryComponent": "Finally, it returns the cleaned and structured DataFrame for further analysis."
                        }
                    ],
                    "low_unstructured": [
                        {
                            "codeSegments": [
                                {
                                    "line": 22,
                                    "code": "def scrape_season_stats(year):"
                                },
                                {
                                    "line": 42,
                                    "code": "base_url_reg = (\n    f\"https://www.basketball-reference.com/leagues/NBA_{year}_per_game.html\"\n)"
                                },
                                {
                                    "line": 45,
                                    "code": "df_reg = pd.read_html(base_url_reg, header=0)[0]"
                                },
                                {
                                    "line": 46,
                                    "code": "df_reg = df_reg[df_reg[\"Player\"] != \"Player\"]  # remove repeated header rows"
                                },
                                {
                                    "line": 47,
                                    "code": "df_reg[\"Year\"] = year"
                                },
                                {
                                    "line": 49,
                                    "code": "df_reg = df_reg[\n    [\"Player\", \"Year\", \"PTS\", \"AST\", \"TRB\", \"FG%\"]\n]"
                                },
                                {
                                    "line": 52,
                                    "code": "df_reg = df_reg.dropna(\n    subset=[\"PTS\", \"AST\", \"TRB\", \"FG%\"]\n)"
                                },
                                {
                                    "line": 55,
                                    "code": "return df_reg"
                                }
                            ],
                            "summaryComponent": "This function scrapes and processes NBA per-game player stats for a given year"
                        },
                        {
                            "codeSegments": [
                                {
                                    "line": 23,
                                    "code": "if year == 2025:"
                                }
                            ],
                            "summaryComponent": "and for 2025 specifically"
                        },
                        {
                            "codeSegments": [
                                {
                                    "line": 24,
                                    "code": "base_url_reg = (\n    f\"https://www.basketball-reference.com/leagues/NBA_{year}_advanced.html\"\n)"
                                },
                                {
                                    "line": 27,
                                    "code": "df_reg = pd.read_html(base_url_reg, header=0)[0]"
                                },
                                {
                                    "line": 28,
                                    "code": "df_reg = df_reg[df_reg[\"Player\"] != \"Player\"]  # remove repeated header rows"
                                },
                                {
                                    "line": 29,
                                    "code": "df_reg[\"Year\"] = year"
                                },
                                {
                                    "line": 31,
                                    "code": "df_reg = df_reg[\n    [\n        \"Player\", \"Year\", \"PTS\", \"AST\", \"TRB\", \"FG%\",\n        \"BPM\", \"WS/48\", \"TS%\", \"VORP\", \"WS\", \"PER\"\n    ]\n]"
                                },
                                {
                                    "line": 37,
                                    "code": "df_reg = df_reg.dropna(\n    subset=[\"PTS\", \"AST\", \"TRB\", \"FG%\", \"BPM\", \"WS/48\", \"TS%\", \"VORP\", \"WS\", \"PER\"]\n)"
                                },
                                {
                                    "line": 40,
                                    "code": "return df_reg"
                                }
                            ],
                            "summaryComponent": "it now scrapes and returns advanced player statistics instead of per-game stats"
                        }
                    ]
                },
                "oldSummaryData": {
                    "high_unstructured": "The scrape_season_stats function downloads per-game NBA player statistics for a specified year by reading the relevant table from Basketball Reference. It removes any repeated header rows that may appear in the data and adds a 'Year' column to each row. The function then filters the DataFrame to retain only the columns for player name, year, points, assists, rebounds, and field goal percentage, and drops any rows where these key statistics are missing. Finally, it returns the cleaned and structured DataFrame for further analysis.",
                    "low_structured": "• Scrapes NBA per-game stats for a specified year\n• Keeps only key player statistics\n• Returns cleaned data",
                    "high_structured": "• Downloads NBA per-game player statistics for a specified year from Basketball Reference\n• Reads the first HTML table from the stats page\n  ◦ Removes any rows where the 'Player' column contains the header string, eliminating repeated headers\n• Adds a 'Year' column to the DataFrame for context\n• Filters the DataFrame to keep only:\n  ◦ Player name\n  ◦ Year\n  ◦ Points (PTS)\n  ◦ Assists (AST)\n  ◦ Rebounds (TRB)\n  ◦ Field Goal Percentage (FG%)\n• Drops rows with missing values in any of the key statistical columns\n• Returns the cleaned DataFrame for further use",
                    "title": "Summary of scrape_season_stats Function",
                    "medium_unstructured": "The scrape_season_stats function retrieves NBA per-game statistics for a specified year from Basketball Reference. It processes the data to remove duplicate headers and keeps only relevant columns such as player name, points, assists, rebounds, and field goal percentage. The function returns a cleaned DataFrame with these stats and the year.",
                    "medium_structured": "• Fetches NBA per-game stats for a given year from Basketball Reference\n• Processes the HTML table to remove repeated header rows\n• Keeps only selected columns: Player, Year, PTS, AST, TRB, FG%\n• Removes rows with missing values in key stats\n• Returns the cleaned DataFrame",
                    "low_unstructured": "This function scrapes and processes NBA per-game player stats for a given year."
                },
                "metadata": {
                    "id": "c57d1459-fc0c-4521-815d-a88a0fc33c55",
                    "filename": "scraper.py",
                    "offset": 652,
                    "fullPath": "/project/workspace/scraper.py",
                    "originalCode": "def scrape_season_stats(year):\n    if year == 2025:\n        base_url_reg = (\n            f\"https://www.basketball-reference.com/leagues/NBA_{year}_advanced.html\"\n        )\n        df_reg = pd.read_html(base_url_reg, header=0)[0]\n        df_reg = df_reg[df_reg[\"Player\"] != \"Player\"]  # remove repeated header rows\n        df_reg[\"Year\"] = year\n\n        df_reg = df_reg[\n            [\n                \"Player\", \"Year\", \"PTS\", \"AST\", \"TRB\", \"FG%\",\n                \"BPM\", \"WS/48\", \"TS%\", \"VORP\", \"WS\", \"PER\"\n            ]\n        ]  # Keep specified columns\n        df_reg = df_reg.dropna(\n            subset=[\"PTS\", \"AST\", \"TRB\", \"FG%\", \"BPM\", \"WS/48\", \"TS%\", \"VORP\", \"WS\", \"PER\"]\n        )  # Ensure key stats aren't invalid\n        return df_reg\n    else:\n        base_url_reg = (\n            f\"https://www.basketball-reference.com/leagues/NBA_{year}_per_game.html\"\n        )\n        df_reg = pd.read_html(base_url_reg, header=0)[0]\n        df_reg = df_reg[df_reg[\"Player\"] != \"Player\"]  # remove repeated header rows\n        df_reg[\"Year\"] = year\n\n        df_reg = df_reg[\n            [\"Player\", \"Year\", \"PTS\", \"AST\", \"TRB\", \"FG%\"]\n        ]  # Keep only specified columns\n        df_reg = df_reg.dropna(\n            subset=[\"PTS\", \"AST\", \"TRB\", \"FG%\"]\n        )  # Ensure key stats aren't invalid\n        return df_reg"
                },
                "createdAt": 1755986983000,
                "lines": [
                    22,
                    58
                ],
                "editPromptStructured": null,
                "selectedStructured": "unstructured",
                "editPromptDetailLevel": null
            },
            "section_id": "c57d1459-fc0c-4521-815d-a88a0fc33c55"
        },
        "event": "create_new_section",
        "id": "oyxRnTBYmr34YpDsQma5"
    },
    {
        "source": "backend",
        "timestamp": "2025-08-23 14:09:43.000",
        "data": {
            "summary": "• Downloads NBA per-game player statistics for a specified year from Basketball Reference, except for 2025\n• For 2025, downloads advanced player statistics from the advanced stats page, including additional metrics\n• Reads the first HTML table from the stats page\n  ◦ Removes any rows where the 'Player' column contains the header string, eliminating repeated headers\n• Adds a 'Year' column to the DataFrame for context\n• Filters the DataFrame to keep only:\n  ◦ For most years: Player name, Year, Points (PTS), Assists (AST), Rebounds (TRB), Field Goal Percentage (FG%)\n  ◦ For 2025: also includes BPM, WS/48, TS%, VORP, WS, and PER\n• Drops rows with missing values in any of the key statistical columns\n• Returns the cleaned DataFrame for further use",
            "code": "22: def scrape_season_stats(year):\n23:     if year == 2025:\n24:         base_url_reg = (\n25:             f\"https://www.basketball-reference.com/leagues/NBA_{year}_advanced.html\"\n26:         )\n27:         df_reg = pd.read_html(base_url_reg, header=0)[0]\n28:         df_reg = df_reg[df_reg[\"Player\"] != \"Player\"]  # remove repeated header rows\n29:         df_reg[\"Year\"] = year\n30: \n31:         df_reg = df_reg[\n32:             [\n33:                 \"Player\", \"Year\", \"PTS\", \"AST\", \"TRB\", \"FG%\",\n34:                 \"BPM\", \"WS/48\", \"TS%\", \"VORP\", \"WS\", \"PER\"\n35:             ]\n36:         ]  # Keep specified columns\n37:         df_reg = df_reg.dropna(\n38:             subset=[\"PTS\", \"AST\", \"TRB\", \"FG%\", \"BPM\", \"WS/48\", \"TS%\", \"VORP\", \"WS\", \"PER\"]\n39:         )  # Ensure key stats aren't invalid\n40:         return df_reg\n41:     else:\n42:         base_url_reg = (\n43:             f\"https://www.basketball-reference.com/leagues/NBA_{year}_per_game.html\"\n44:         )\n45:         df_reg = pd.read_html(base_url_reg, header=0)[0]\n46:         df_reg = df_reg[df_reg[\"Player\"] != \"Player\"]  # remove repeated header rows\n47:         df_reg[\"Year\"] = year\n48: \n49:         df_reg = df_reg[\n50:             [\"Player\", \"Year\", \"PTS\", \"AST\", \"TRB\", \"FG%\"]\n51:         ]  # Keep only specified columns\n52:         df_reg = df_reg.dropna(\n53:             subset=[\"PTS\", \"AST\", \"TRB\", \"FG%\"]\n54:         )  # Ensure key stats aren't invalid\n55:         return df_reg",
            "mapping": [
                {
                    "codeSegments": [
                        {
                            "line": 23,
                            "code": "if year == 2025:"
                        },
                        {
                            "line": 41,
                            "code": "else:"
                        },
                        {
                            "line": 42,
                            "code": "base_url_reg = (\n    f\"https://www.basketball-reference.com/leagues/NBA_{year}_per_game.html\"\n)"
                        },
                        {
                            "line": 45,
                            "code": "df_reg = pd.read_html(base_url_reg, header=0)[0]"
                        }
                    ],
                    "summaryComponent": "Downloads NBA per-game player statistics for a specified year from Basketball Reference, except for 2025"
                },
                {
                    "codeSegments": [
                        {
                            "line": 23,
                            "code": "if year == 2025:"
                        },
                        {
                            "line": 24,
                            "code": "base_url_reg = (\n    f\"https://www.basketball-reference.com/leagues/NBA_{year}_advanced.html\"\n)"
                        },
                        {
                            "line": 27,
                            "code": "df_reg = pd.read_html(base_url_reg, header=0)[0]"
                        }
                    ],
                    "summaryComponent": "For 2025, downloads advanced player statistics from the advanced stats page, including additional metrics"
                },
                {
                    "codeSegments": [
                        {
                            "line": 27,
                            "code": "df_reg = pd.read_html(base_url_reg, header=0)[0]"
                        },
                        {
                            "line": 45,
                            "code": "df_reg = pd.read_html(base_url_reg, header=0)[0]"
                        }
                    ],
                    "summaryComponent": "Reads the first HTML table from the stats page"
                },
                {
                    "codeSegments": [
                        {
                            "line": 28,
                            "code": "df_reg = df_reg[df_reg[\"Player\"] != \"Player\"]  # remove repeated header rows"
                        },
                        {
                            "line": 46,
                            "code": "df_reg = df_reg[df_reg[\"Player\"] != \"Player\"]  # remove repeated header rows"
                        }
                    ],
                    "summaryComponent": "Removes any rows where the 'Player' column contains the header string, eliminating repeated headers"
                },
                {
                    "codeSegments": [
                        {
                            "line": 29,
                            "code": "df_reg[\"Year\"] = year"
                        },
                        {
                            "line": 47,
                            "code": "df_reg[\"Year\"] = year"
                        }
                    ],
                    "summaryComponent": "Adds a 'Year' column to the DataFrame for context"
                },
                {
                    "codeSegments": [
                        {
                            "line": 31,
                            "code": "df_reg = df_reg[\n    [\n        \"Player\", \"Year\", \"PTS\", \"AST\", \"TRB\", \"FG%\",\n        \"BPM\", \"WS/48\", \"TS%\", \"VORP\", \"WS\", \"PER\"\n    ]\n]  # Keep specified columns"
                        },
                        {
                            "line": 49,
                            "code": "df_reg = df_reg[\n    [\"Player\", \"Year\", \"PTS\", \"AST\", \"TRB\", \"FG%\"]\n]  # Keep only specified columns"
                        }
                    ],
                    "summaryComponent": "Filters the DataFrame to keep only:"
                },
                {
                    "codeSegments": [
                        {
                            "line": 49,
                            "code": "df_reg = df_reg[\n    [\"Player\", \"Year\", \"PTS\", \"AST\", \"TRB\", \"FG%\"]\n]  # Keep only specified columns"
                        }
                    ],
                    "summaryComponent": "For most years: Player name, Year, Points (PTS), Assists (AST), Rebounds (TRB), Field Goal Percentage (FG%)"
                },
                {
                    "codeSegments": [
                        {
                            "line": 31,
                            "code": "df_reg = df_reg[\n    [\n        \"Player\", \"Year\", \"PTS\", \"AST\", \"TRB\", \"FG%\",\n        \"BPM\", \"WS/48\", \"TS%\", \"VORP\", \"WS\", \"PER\"\n    ]\n]  # Keep specified columns"
                        }
                    ],
                    "summaryComponent": "For 2025: also includes BPM, WS/48, TS%, VORP, WS, and PER"
                },
                {
                    "codeSegments": [
                        {
                            "line": 37,
                            "code": "df_reg = df_reg.dropna(\n    subset=[\"PTS\", \"AST\", \"TRB\", \"FG%\", \"BPM\", \"WS/48\", \"TS%\", \"VORP\", \"WS\", \"PER\"]\n)  # Ensure key stats aren't invalid"
                        },
                        {
                            "line": 52,
                            "code": "df_reg = df_reg.dropna(\n    subset=[\"PTS\", \"AST\", \"TRB\", \"FG%\"]\n)  # Ensure key stats aren't invalid"
                        }
                    ],
                    "summaryComponent": "Drops rows with missing values in any of the key statistical columns"
                },
                {
                    "codeSegments": [
                        {
                            "line": 40,
                            "code": "return df_reg"
                        },
                        {
                            "line": 55,
                            "code": "return df_reg"
                        }
                    ],
                    "summaryComponent": "Returns the cleaned DataFrame for further use"
                }
            ]
        },
        "event": "map_summary_code",
        "id": "AEhmIzrL4YA1mwoVAFNS"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:09:44.000",
        "data": {
            "detail_level": "medium",
            "section_id": "c57d1459-fc0c-4521-815d-a88a0fc33c55",
            "structured_type": "unstructured",
            "mapping_index": 0
        },
        "event": "mapping_hover",
        "id": "4zBwsWeM6MaLiuYeNpip"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:09:44.000",
        "data": {
            "detail_level": "medium",
            "section_id": "c57d1459-fc0c-4521-815d-a88a0fc33c55",
            "structured_type": "unstructured",
            "mapping_index": 5
        },
        "event": "mapping_hover",
        "id": "Fi8KfbOvCpUkeB74JqMC"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:09:44.000",
        "data": {
            "detail_level": "medium",
            "section_id": "c57d1459-fc0c-4521-815d-a88a0fc33c55",
            "structured_type": "unstructured"
        },
        "event": "mapping_unhover",
        "id": "FobT7ffJ4fUe1lF9PR7F"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:09:44.000",
        "data": {
            "detail_level": "medium",
            "section_id": "c57d1459-fc0c-4521-815d-a88a0fc33c55",
            "structured_type": "unstructured"
        },
        "event": "mapping_unhover",
        "id": "GH52gF5gfvlzRJ2ll85t"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:09:44.000",
        "data": {
            "detail_level": "medium",
            "section_id": "c57d1459-fc0c-4521-815d-a88a0fc33c55",
            "structured_type": "unstructured"
        },
        "event": "mapping_unhover",
        "id": "MF53rjVkqqWlOeWKdkl5"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:09:44.000",
        "data": {
            "detail_level": "medium",
            "section_id": "c57d1459-fc0c-4521-815d-a88a0fc33c55",
            "structured_type": "unstructured",
            "mapping_index": 4
        },
        "event": "mapping_hover",
        "id": "SrbVxdreEDJfXtQUYNYg"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:09:44.000",
        "data": {
            "detail_level": "medium",
            "section_id": "c57d1459-fc0c-4521-815d-a88a0fc33c55",
            "structured_type": "unstructured"
        },
        "event": "mapping_unhover",
        "id": "TtOYzGLKxekxDPf3gcRr"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:09:44.000",
        "data": {
            "detail_level": "medium",
            "section_id": "c57d1459-fc0c-4521-815d-a88a0fc33c55",
            "structured_type": "unstructured",
            "mapping_index": 1
        },
        "event": "mapping_hover",
        "id": "XgpXIk3gDfubnpyuSdW0"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:09:44.000",
        "data": {
            "detail_level": "medium",
            "section_id": "c57d1459-fc0c-4521-815d-a88a0fc33c55",
            "structured_type": "unstructured"
        },
        "event": "mapping_unhover",
        "id": "ZnhB8pfnDFseqZ6tXJp2"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:09:44.000",
        "data": {
            "detail_level": "medium",
            "section_id": "c57d1459-fc0c-4521-815d-a88a0fc33c55",
            "structured_type": "unstructured",
            "mapping_index": 1
        },
        "event": "mapping_hover",
        "id": "bqrQ8oUGfMiV96XO7QPK"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:09:44.000",
        "data": {
            "detail_level": "medium",
            "section_id": "c57d1459-fc0c-4521-815d-a88a0fc33c55",
            "structured_type": "unstructured",
            "mapping_index": 4
        },
        "event": "mapping_hover",
        "id": "iGa6CV4rdkLRLH85V90W"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:09:44.000",
        "data": {
            "detail_level": "medium",
            "section_id": "c57d1459-fc0c-4521-815d-a88a0fc33c55",
            "structured_type": "unstructured"
        },
        "event": "mapping_unhover",
        "id": "ihh5ggQoi7NXzOTEMa3a"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:09:44.000",
        "data": {
            "detail_level": "medium",
            "section_id": "c57d1459-fc0c-4521-815d-a88a0fc33c55",
            "structured_type": "unstructured"
        },
        "event": "mapping_unhover",
        "id": "jHbVcPtfs1ZzxeH7XyHO"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:09:44.000",
        "data": {
            "detail_level": "medium",
            "section_id": "c57d1459-fc0c-4521-815d-a88a0fc33c55",
            "structured_type": "unstructured",
            "mapping_index": 3
        },
        "event": "mapping_hover",
        "id": "qkUrHKF0hxBCFMru5EPk"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:09:44.000",
        "data": {
            "detail_level": "medium",
            "section_id": "c57d1459-fc0c-4521-815d-a88a0fc33c55",
            "structured_type": "unstructured",
            "mapping_index": 3
        },
        "event": "mapping_hover",
        "id": "rew5mIr4I8PIERJwYcra"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:09:44.000",
        "data": {
            "detail_level": "medium",
            "section_id": "c57d1459-fc0c-4521-815d-a88a0fc33c55",
            "structured_type": "unstructured"
        },
        "event": "mapping_unhover",
        "id": "t4yEQrv3omQlKyamEhQz"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:09:44.000",
        "data": {
            "detail_level": "medium",
            "section_id": "c57d1459-fc0c-4521-815d-a88a0fc33c55",
            "structured_type": "unstructured"
        },
        "event": "mapping_unhover",
        "id": "we76a91BPuaspmXcxbVu"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:09:44.000",
        "data": {
            "detail_level": "medium",
            "section_id": "c57d1459-fc0c-4521-815d-a88a0fc33c55",
            "structured_type": "unstructured",
            "mapping_index": 6
        },
        "event": "mapping_hover",
        "id": "zAwDnGoTSNVbvLGavz9n"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:09:44.000",
        "data": {
            "detail_level": "medium",
            "section_id": "c57d1459-fc0c-4521-815d-a88a0fc33c55",
            "structured_type": "unstructured",
            "mapping_index": 0
        },
        "event": "mapping_hover",
        "id": "zeAyxDBhXzUI1LgsBF7k"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:09:45.000",
        "data": {
            "detail_level": "medium",
            "section_id": "c57d1459-fc0c-4521-815d-a88a0fc33c55",
            "structured_type": "unstructured",
            "mapping_index": 5
        },
        "event": "mapping_hover",
        "id": "L5jdWLkzF0OysculTQLV"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:09:45.000",
        "data": {
            "detail_level": "medium",
            "section_id": "c57d1459-fc0c-4521-815d-a88a0fc33c55",
            "structured_type": "unstructured"
        },
        "event": "mapping_unhover",
        "id": "bIhYDlScADG0VvglLawY"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:09:45.000",
        "data": {
            "detail_level": "medium",
            "section_id": "c57d1459-fc0c-4521-815d-a88a0fc33c55",
            "structured_type": "unstructured"
        },
        "event": "mapping_unhover",
        "id": "fXp0lmcV5HC72cEUlQNJ"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:09:46.000",
        "data": {
            "detail_level": "medium",
            "section_id": "c57d1459-fc0c-4521-815d-a88a0fc33c55",
            "structured_type": "unstructured",
            "mapping_index": 4
        },
        "event": "mapping_hover",
        "id": "4ufLNhYdVT92N77AjZjw"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:09:46.000",
        "data": {
            "detail_level": "medium",
            "section_id": "c57d1459-fc0c-4521-815d-a88a0fc33c55",
            "structured_type": "unstructured"
        },
        "event": "mapping_unhover",
        "id": "T9tXTul8boQORTf2NzRx"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:09:46.000",
        "data": {
            "detail_level": "medium",
            "section_id": "c57d1459-fc0c-4521-815d-a88a0fc33c55",
            "structured_type": "unstructured",
            "mapping_index": 1
        },
        "event": "mapping_hover",
        "id": "TwgFa0ccysVGMNP13mRb"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:09:46.000",
        "data": {
            "detail_level": "medium",
            "section_id": "c57d1459-fc0c-4521-815d-a88a0fc33c55",
            "structured_type": "unstructured"
        },
        "event": "mapping_unhover",
        "id": "XzcfXjtkK16Ds4trs3kj"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:09:46.000",
        "data": {
            "detail_level": "medium",
            "section_id": "c57d1459-fc0c-4521-815d-a88a0fc33c55",
            "structured_type": "unstructured",
            "mapping_index": 6
        },
        "event": "mapping_hover",
        "id": "byS7nBEAY0x1cyrSxj0v"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:09:46.000",
        "data": {
            "detail_level": "medium",
            "section_id": "c57d1459-fc0c-4521-815d-a88a0fc33c55",
            "structured_type": "unstructured",
            "mapping_index": 3
        },
        "event": "mapping_hover",
        "id": "kb8YFbYlIsqrdzzTmlRr"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:09:46.000",
        "data": {
            "detail_level": "medium",
            "section_id": "c57d1459-fc0c-4521-815d-a88a0fc33c55",
            "structured_type": "unstructured"
        },
        "event": "mapping_unhover",
        "id": "mygiBzQCdhvFPljkOZO5"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:09:46.000",
        "data": {
            "detail_level": "medium",
            "section_id": "c57d1459-fc0c-4521-815d-a88a0fc33c55",
            "structured_type": "unstructured"
        },
        "event": "mapping_unhover",
        "id": "sPkmyRnP9BOLhCaRUkf4"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:09:48.000",
        "data": {
            "after_section_id": "f9b0208b-12de-4f2b-80f7-7870bbeabae0",
            "before_section_id": "c57d1459-fc0c-4521-815d-a88a0fc33c55"
        },
        "event": "toggle_section",
        "id": "gtDAJxqY0XHPwXFbPRmO"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:09:51.000",
        "data": {
            "detail_level": "high",
            "section_id": "f9b0208b-12de-4f2b-80f7-7870bbeabae0",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "LmzwxJ3wRynJbUyoO3w4"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:09:51.000",
        "data": {
            "detail_level": "high",
            "section_id": "f9b0208b-12de-4f2b-80f7-7870bbeabae0",
            "structured_type": "structured",
            "mapping_index": 12
        },
        "event": "mapping_hover",
        "id": "vIBxb9JM6aN70l8xm3l2"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:09:52.000",
        "data": {
            "detail_level": "high",
            "section_id": "f9b0208b-12de-4f2b-80f7-7870bbeabae0",
            "structured_type": "structured",
            "mapping_index": 5
        },
        "event": "mapping_hover",
        "id": "4yvK90EMtQUnBQDym46n"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:09:52.000",
        "data": {
            "detail_level": "high",
            "section_id": "f9b0208b-12de-4f2b-80f7-7870bbeabae0",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "BWwFG1tkFJBA6AMV81nD"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:09:54.000",
        "data": {
            "detail_level": "high",
            "section_id": "f9b0208b-12de-4f2b-80f7-7870bbeabae0",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "J35tNmoHr9e7bxoFCOLY"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:09:54.000",
        "data": {
            "detail_level": "high",
            "section_id": "f9b0208b-12de-4f2b-80f7-7870bbeabae0",
            "structured_type": "structured",
            "mapping_index": 11
        },
        "event": "mapping_hover",
        "id": "LSTw7BnvqbVmJ8qWqo1m"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:09:54.000",
        "data": {
            "detail_level": "high",
            "section_id": "f9b0208b-12de-4f2b-80f7-7870bbeabae0",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "jOadKC4MJKhTMjO9Am2m"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:09:54.000",
        "data": {
            "detail_level": "high",
            "section_id": "f9b0208b-12de-4f2b-80f7-7870bbeabae0",
            "structured_type": "structured",
            "mapping_index": 12
        },
        "event": "mapping_hover",
        "id": "srFIImCkYU06z7r53ap0"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:09:55.000",
        "data": {
            "detail_level": "high",
            "section_id": "f9b0208b-12de-4f2b-80f7-7870bbeabae0",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "7ilqJ1vSuIUMBzYpYlpB"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:09:55.000",
        "data": {
            "detail_level": "high",
            "section_id": "f9b0208b-12de-4f2b-80f7-7870bbeabae0",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "Ea6X32smWCz9D8A3aeC7"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:09:55.000",
        "data": {
            "detail_level": "high",
            "section_id": "f9b0208b-12de-4f2b-80f7-7870bbeabae0",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "FcEAkGwNHN3U4D62wyJ7"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:09:55.000",
        "data": {
            "detail_level": "high",
            "section_id": "f9b0208b-12de-4f2b-80f7-7870bbeabae0",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "H3XvvhlWH5SCCh8MURC5"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:09:55.000",
        "data": {
            "detail_level": "high",
            "section_id": "f9b0208b-12de-4f2b-80f7-7870bbeabae0",
            "structured_type": "structured",
            "mapping_index": 9
        },
        "event": "mapping_hover",
        "id": "Jk810Oq41zoxcmsGJTGc"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:09:55.000",
        "data": {
            "detail_level": "high",
            "section_id": "f9b0208b-12de-4f2b-80f7-7870bbeabae0",
            "structured_type": "structured",
            "mapping_index": 11
        },
        "event": "mapping_hover",
        "id": "KGvLrkKEP2zaa3XT45uh"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:09:55.000",
        "data": {
            "detail_level": "high",
            "section_id": "f9b0208b-12de-4f2b-80f7-7870bbeabae0",
            "structured_type": "structured",
            "mapping_index": 10
        },
        "event": "mapping_hover",
        "id": "MeGdkyQwZIuqbmd4GInM"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:09:55.000",
        "data": {
            "detail_level": "high",
            "section_id": "f9b0208b-12de-4f2b-80f7-7870bbeabae0",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "N6UYVH7tYmIoq6A2wzL9"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:09:55.000",
        "data": {
            "detail_level": "high",
            "section_id": "f9b0208b-12de-4f2b-80f7-7870bbeabae0",
            "structured_type": "structured",
            "mapping_index": 7
        },
        "event": "mapping_hover",
        "id": "aegatl9jLBPo5Iygh0Ek"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:09:55.000",
        "data": {
            "detail_level": "high",
            "section_id": "f9b0208b-12de-4f2b-80f7-7870bbeabae0",
            "structured_type": "structured",
            "mapping_index": 12
        },
        "event": "mapping_hover",
        "id": "ssVzZJLvJpjtPfWBxxlj"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:09:58.000",
        "data": {
            "detail_level": "high",
            "section_id": "f9b0208b-12de-4f2b-80f7-7870bbeabae0",
            "structured_type": "structured",
            "mapping_index": 3
        },
        "event": "mapping_hover",
        "id": "10byYzEiwZpF06yO26nt"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:09:58.000",
        "data": {
            "detail_level": "high",
            "section_id": "f9b0208b-12de-4f2b-80f7-7870bbeabae0",
            "structured_type": "structured",
            "mapping_index": 2
        },
        "event": "mapping_hover",
        "id": "1yNzgtahoXULl3DJEycm"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:09:58.000",
        "data": {
            "detail_level": "high",
            "section_id": "f9b0208b-12de-4f2b-80f7-7870bbeabae0",
            "structured_type": "structured",
            "mapping_index": 2
        },
        "event": "mapping_hover",
        "id": "5QmMc4noYWVqrJjb4DV5"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:09:58.000",
        "data": {
            "detail_level": "high",
            "section_id": "f9b0208b-12de-4f2b-80f7-7870bbeabae0",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "5YprqvpnjnogymHGYh34"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:09:58.000",
        "data": {
            "detail_level": "high",
            "section_id": "f9b0208b-12de-4f2b-80f7-7870bbeabae0",
            "structured_type": "structured",
            "mapping_index": 5
        },
        "event": "mapping_hover",
        "id": "9xDdRc5zbm9C7bNLZWFj"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:09:58.000",
        "data": {
            "detail_level": "high",
            "section_id": "f9b0208b-12de-4f2b-80f7-7870bbeabae0",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "ChcLEmFB6ulOBAWpZ8uS"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:09:58.000",
        "data": {
            "detail_level": "high",
            "section_id": "f9b0208b-12de-4f2b-80f7-7870bbeabae0",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "EYJwg5DncRtvnjYN6T5I"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:09:58.000",
        "data": {
            "detail_level": "high",
            "section_id": "f9b0208b-12de-4f2b-80f7-7870bbeabae0",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "M6zxDNyHHHN9gERCca2s"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:09:58.000",
        "data": {
            "detail_level": "high",
            "section_id": "f9b0208b-12de-4f2b-80f7-7870bbeabae0",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "apWfG1ZbKvfvfpNtqNa0"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:09:58.000",
        "data": {
            "detail_level": "high",
            "section_id": "f9b0208b-12de-4f2b-80f7-7870bbeabae0",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "h02Uz5bKDxdxIB4BsADD"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:09:58.000",
        "data": {
            "detail_level": "high",
            "section_id": "f9b0208b-12de-4f2b-80f7-7870bbeabae0",
            "structured_type": "structured",
            "mapping_index": 5
        },
        "event": "mapping_hover",
        "id": "h4pG50C5Wd1CDTMB3ehG"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:09:58.000",
        "data": {
            "detail_level": "high",
            "section_id": "f9b0208b-12de-4f2b-80f7-7870bbeabae0",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "iFtEtobJTJJA03cKGUKf"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:09:58.000",
        "data": {
            "detail_level": "high",
            "section_id": "f9b0208b-12de-4f2b-80f7-7870bbeabae0",
            "structured_type": "structured",
            "mapping_index": 4
        },
        "event": "mapping_hover",
        "id": "kgjVbVAQJ6H91NPGPCBt"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:09:58.000",
        "data": {
            "detail_level": "high",
            "section_id": "f9b0208b-12de-4f2b-80f7-7870bbeabae0",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "mhaGsQlJC7Xl7L5qiIEN"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:09:58.000",
        "data": {
            "detail_level": "high",
            "section_id": "f9b0208b-12de-4f2b-80f7-7870bbeabae0",
            "structured_type": "structured",
            "mapping_index": 8
        },
        "event": "mapping_hover",
        "id": "qTv4GSxEnAKGvGndDCpe"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:09:58.000",
        "data": {
            "detail_level": "high",
            "section_id": "f9b0208b-12de-4f2b-80f7-7870bbeabae0",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "wEOKoJjBRKj0H6mwVeLH"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:09:58.000",
        "data": {
            "detail_level": "high",
            "section_id": "f9b0208b-12de-4f2b-80f7-7870bbeabae0",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "wy6LIWrp8EKu3qQK0pN2"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:09:58.000",
        "data": {
            "detail_level": "high",
            "section_id": "f9b0208b-12de-4f2b-80f7-7870bbeabae0",
            "structured_type": "structured",
            "mapping_index": 7
        },
        "event": "mapping_hover",
        "id": "xMsE7XngYPD1OaKixmi7"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:09:58.000",
        "data": {
            "detail_level": "high",
            "section_id": "f9b0208b-12de-4f2b-80f7-7870bbeabae0",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "y214ZaR1pVEJLaYmguin"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:09:58.000",
        "data": {
            "detail_level": "high",
            "section_id": "f9b0208b-12de-4f2b-80f7-7870bbeabae0",
            "structured_type": "structured",
            "mapping_index": 0
        },
        "event": "mapping_hover",
        "id": "yIKLHbU9CdC7KoqXgKfB"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:09:58.000",
        "data": {
            "detail_level": "high",
            "section_id": "f9b0208b-12de-4f2b-80f7-7870bbeabae0",
            "structured_type": "structured",
            "mapping_index": 1
        },
        "event": "mapping_hover",
        "id": "z8QxM3k1kgvKyJWKkkLY"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:09:58.000",
        "data": {
            "detail_level": "high",
            "section_id": "f9b0208b-12de-4f2b-80f7-7870bbeabae0",
            "structured_type": "structured",
            "mapping_index": 3
        },
        "event": "mapping_hover",
        "id": "zcsJGVxqKl7KbWaIZrF5"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:10:04.000",
        "data": {
            "detail_level": "high",
            "section_id": "f9b0208b-12de-4f2b-80f7-7870bbeabae0",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "05zIc6GBetixK5X5ZloO"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:10:04.000",
        "data": {
            "detail_level": "high",
            "section_id": "f9b0208b-12de-4f2b-80f7-7870bbeabae0",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "AGHrxSpvbtWmDQrdjEMD"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:10:04.000",
        "data": {
            "detail_level": "high",
            "section_id": "f9b0208b-12de-4f2b-80f7-7870bbeabae0",
            "structured_type": "structured",
            "mapping_index": 1
        },
        "event": "mapping_hover",
        "id": "S6yCXexG9DZ4gBxNPque"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:10:04.000",
        "data": {
            "detail_level": "high",
            "section_id": "f9b0208b-12de-4f2b-80f7-7870bbeabae0",
            "structured_type": "structured",
            "mapping_index": 0
        },
        "event": "mapping_hover",
        "id": "eq6OJ2zYx0OXXB6lnf67"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:10:04.000",
        "data": {
            "detail_level": "high",
            "section_id": "f9b0208b-12de-4f2b-80f7-7870bbeabae0",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "oA8eT2OW9zUAkI6TxydG"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:10:04.000",
        "data": {
            "detail_level": "high",
            "section_id": "f9b0208b-12de-4f2b-80f7-7870bbeabae0",
            "structured_type": "structured",
            "mapping_index": 0
        },
        "event": "mapping_hover",
        "id": "uGAq04mcEjK5QKuSVD8T"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:10:05.000",
        "data": {
            "detail_level": "high",
            "section_id": "f9b0208b-12de-4f2b-80f7-7870bbeabae0",
            "structured_type": "structured",
            "mapping_index": 0
        },
        "event": "mapping_hover",
        "id": "2Ov2CPLO9AhwbqsnQr1N"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:10:05.000",
        "data": {
            "detail_level": "high",
            "section_id": "f9b0208b-12de-4f2b-80f7-7870bbeabae0",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "GmxoXmm6H58cZI20YrQZ"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:10:05.000",
        "data": {},
        "event": "click_summarize_code",
        "id": "jufQspOgsMo8Bz7dUdY0"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:10:06.000",
        "data": {
            "detail_level": "high",
            "section_id": "f9b0208b-12de-4f2b-80f7-7870bbeabae0",
            "structured_type": "structured",
            "mapping_index": 5
        },
        "event": "mapping_hover",
        "id": "14uLjk1QZP5pLAyN9fK1"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:10:06.000",
        "data": {
            "detail_level": "high",
            "section_id": "f9b0208b-12de-4f2b-80f7-7870bbeabae0",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "VFxAnLSIg2n8TLqq5Xl8"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:10:06.000",
        "data": {
            "detail_level": "high",
            "section_id": "f9b0208b-12de-4f2b-80f7-7870bbeabae0",
            "structured_type": "structured",
            "mapping_index": 4
        },
        "event": "mapping_hover",
        "id": "lMEhixlmNS2oQUxYIqu3"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:10:07.000",
        "data": {
            "detail_level": "high",
            "section_id": "f9b0208b-12de-4f2b-80f7-7870bbeabae0",
            "structured_type": "structured",
            "mapping_index": 4
        },
        "event": "mapping_hover",
        "id": "0EzKIzHJFqoLfDTLOteP"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:10:07.000",
        "data": {
            "detail_level": "high",
            "section_id": "f9b0208b-12de-4f2b-80f7-7870bbeabae0",
            "structured_type": "structured",
            "mapping_index": 2
        },
        "event": "mapping_hover",
        "id": "55KSeiHUN3V3al2h7fuR"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:10:07.000",
        "data": {
            "detail_level": "high",
            "section_id": "f9b0208b-12de-4f2b-80f7-7870bbeabae0",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "R7ETKyDBzbU11Yy5hLnM"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:10:07.000",
        "data": {
            "detail_level": "high",
            "section_id": "f9b0208b-12de-4f2b-80f7-7870bbeabae0",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "WLI1MkgtladLVvZr9dYl"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:10:07.000",
        "data": {
            "detail_level": "high",
            "section_id": "f9b0208b-12de-4f2b-80f7-7870bbeabae0",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "cOnsiKjq4KbGxp8rnZCJ"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:10:07.000",
        "data": {
            "detail_level": "high",
            "section_id": "f9b0208b-12de-4f2b-80f7-7870bbeabae0",
            "structured_type": "structured",
            "mapping_index": 4
        },
        "event": "mapping_hover",
        "id": "jvWuytz0mZiB8rLDEGqW"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:10:07.000",
        "data": {
            "detail_level": "high",
            "section_id": "f9b0208b-12de-4f2b-80f7-7870bbeabae0",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "ndGiq1OlTi3I11UoA3sj"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:10:07.000",
        "data": {
            "detail_level": "high",
            "section_id": "f9b0208b-12de-4f2b-80f7-7870bbeabae0",
            "structured_type": "structured",
            "mapping_index": 3
        },
        "event": "mapping_hover",
        "id": "ssBdPToHD83XKiIZPEHn"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:10:07.000",
        "data": {
            "detail_level": "high",
            "section_id": "f9b0208b-12de-4f2b-80f7-7870bbeabae0",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "zShSeUe6R2qv70ZuIHtv"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:10:11.000",
        "data": {
            "detail_level": "high",
            "section_id": "f9b0208b-12de-4f2b-80f7-7870bbeabae0",
            "structured_type": "structured",
            "mapping_index": 0
        },
        "event": "mapping_hover",
        "id": "6WzVhnbFbKlnrjhrHVX3"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:10:11.000",
        "data": {
            "detail_level": "high",
            "section_id": "f9b0208b-12de-4f2b-80f7-7870bbeabae0",
            "structured_type": "structured",
            "mapping_index": 1
        },
        "event": "mapping_hover",
        "id": "B9XsDSi7V2n9EW4bZS5K"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:10:11.000",
        "data": {
            "detail_level": "high",
            "section_id": "f9b0208b-12de-4f2b-80f7-7870bbeabae0",
            "structured_type": "structured",
            "mapping_index": 1
        },
        "event": "mapping_hover",
        "id": "Bu6mCDXWc3AIkl0snvak"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:10:11.000",
        "data": {
            "detail_level": "high",
            "section_id": "f9b0208b-12de-4f2b-80f7-7870bbeabae0",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "EcnJBhmfQMPRiO2CoY7f"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:10:11.000",
        "data": {
            "detail_level": "high",
            "section_id": "f9b0208b-12de-4f2b-80f7-7870bbeabae0",
            "structured_type": "structured",
            "mapping_index": 0
        },
        "event": "mapping_hover",
        "id": "IQI0kQC8zTZFgIewfQQO"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:10:11.000",
        "data": {
            "detail_level": "high",
            "section_id": "f9b0208b-12de-4f2b-80f7-7870bbeabae0",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "MRbZiAahWunvWIaExBpD"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:10:11.000",
        "data": {
            "detail_level": "high",
            "section_id": "f9b0208b-12de-4f2b-80f7-7870bbeabae0",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "ZppiDpsxZq8xOXqN30MT"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:10:11.000",
        "data": {
            "detail_level": "high",
            "section_id": "f9b0208b-12de-4f2b-80f7-7870bbeabae0",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "a7zQoYNyyL8790yWmeBo"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:10:11.000",
        "data": {
            "detail_level": "high",
            "section_id": "f9b0208b-12de-4f2b-80f7-7870bbeabae0",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "kCbFOo9PNiFB5Y1CXics"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:10:11.000",
        "data": {
            "detail_level": "high",
            "section_id": "f9b0208b-12de-4f2b-80f7-7870bbeabae0",
            "structured_type": "structured",
            "mapping_index": 2
        },
        "event": "mapping_hover",
        "id": "v7VFCrbsq8TZz4uh9peZ"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:10:12.000",
        "data": {
            "detail_level": "high",
            "section_id": "f9b0208b-12de-4f2b-80f7-7870bbeabae0",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "46PYkaleHqidgo7vOZ9F"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:10:12.000",
        "data": {
            "detail_level": "high",
            "section_id": "f9b0208b-12de-4f2b-80f7-7870bbeabae0",
            "structured_type": "structured",
            "mapping_index": 4
        },
        "event": "mapping_hover",
        "id": "KRtK1CE3RlIBSD8TJUEf"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:10:12.000",
        "data": {
            "detail_level": "high",
            "section_id": "f9b0208b-12de-4f2b-80f7-7870bbeabae0",
            "structured_type": "structured",
            "mapping_index": 3
        },
        "event": "mapping_hover",
        "id": "N0tqmAYV8eZoHn0Gacwt"
    },
    {
        "source": "backend",
        "timestamp": "2025-08-23 14:10:12.000",
        "data": {
            "summary": {
                "high_unstructured": "This code provides a set of functions to scrape NBA MVP voting results and player per-game statistics from Basketball Reference for seasons 2018 through 2025. The 'scrape_mvp_votes' function fetches MVP tables for each year, renames columns, and concatenates results, while 'scrape_season_stats' retrieves and cleans player stats for a given season, retaining only key columns and valid rows. The 'scrape_multiple_seasons' function aggregates stats across all specified years. When run as a script, it ensures a 'data' directory exists, scrapes both MVP and player stats, and saves them as CSV files, handling missing data gracefully and providing progress output.",
                "low_structured": "• Scrapes MVP votes and player stats from Basketball Reference\n• Processes multiple NBA seasons\n• Saves results as CSV files",
                "high_structured": "• Imports pandas and os modules for data handling and file operations\n• Defines scraping functions:\n  ◦ scrape_mvp_votes: Loops through years, fetches MVP voting tables, renames columns, and aggregates results\n  ◦ scrape_season_stats: Retrieves per-game player stats for a year, cleans data, and selects key columns (Player, Year, PTS, AST, TRB, FG%)\n  ◦ scrape_multiple_seasons: Aggregates player stats across multiple years using scrape_season_stats\n• Main script logic:\n  ◦ Checks for and creates a 'data' directory if needed\n  ◦ Scrapes MVP votes and saves to 'data/mvp_votes.csv'\n  ◦ Scrapes player stats across seasons and saves to 'data/season_stats.csv'\n  ◦ Prints progress messages to the console\n• Handles missing or unparsable data gracefully during scraping",
                "title": "Basketball Reference MVP Votes and Player Stats Scraper",
                "medium_unstructured": "The script collects MVP voting results and player per-game statistics from Basketball Reference for NBA seasons between 2018 and 2025. It defines functions to scrape MVP votes, individual season stats, and aggregate stats across multiple seasons. The gathered data is saved into CSV files in a local 'data' directory.",
                "medium_structured": "• Defines functions to scrape MVP votes and player stats from Basketball Reference\n• Handles multiple seasons from 2018 to 2025\n  ◦ Aggregates data across years for both MVP votes and stats\n• Saves the results as CSV files in a 'data' directory\n• Ensures necessary directories exist before saving",
                "low_unstructured": "This code scrapes MVP votes and player statistics from Basketball Reference for multiple NBA seasons and saves the data as CSV files."
            },
            "selected_code": "import pandas as pd\nimport os\n\n\ndef scrape_mvp_votes(start_year=2018, end_year=2025):\n    all_votes = []\n    for year in range(start_year, end_year + 1):\n        url = f\"https://www.basketball-reference.com/awards/awards_{year}.html\"\n        tables = pd.read_html(url, header=1)\n        try:\n            mvp_table = tables[0]  # MVP table is the first table\n            mvp_table[\"Year\"] = year\n            all_votes.append(mvp_table)\n        except:\n            print(f\"Could not parse year {year}\")\n\n    df = pd.concat(all_votes)\n    df = df.rename(columns={\"Player\": \"Name\", \"Pts Won\": \"MVP_Points\"})\n    return df[[\"Year\", \"Name\", \"MVP_Points\"]]\n\n\ndef scrape_season_stats(year):\n    base_url_reg = (\n        f\"https://www.basketball-reference.com/leagues/NBA_{year}_per_game.html\"\n    )\n    df_reg = pd.read_html(base_url_reg, header=0)[0]\n    df_reg = df_reg[df_reg[\"Player\"] != \"Player\"]  # remove repeated header rows\n    df_reg[\"Year\"] = year\n\n    df_reg = df_reg[\n        [\"Player\", \"Year\", \"PTS\", \"AST\", \"TRB\", \"FG%\"]\n    ]  # Keep only specified columns\n    df_reg = df_reg.dropna(\n        subset=[\"PTS\", \"AST\", \"TRB\", \"FG%\"]\n    )  # Ensure key stats aren't invalid\n    return df_reg\n\n\ndef scrape_multiple_seasons(start_year=2018, end_year=2025):\n    all_stats = []\n    for year in range(start_year, end_year + 1):\n        df = scrape_season_stats(year)\n        all_stats.append(df)\n    return pd.concat(all_stats)\n\n\nif __name__ == \"__main__\":\n    if not os.path.exists(\"data\"):\n        os.makedirs(\"data\")\n\n    print(\"Scraping MVP votes...\")\n    mvp_df = scrape_mvp_votes()\n    mvp_df.to_csv(\"data/mvp_votes.csv\", index=False)\n\n    print(\"Scraping player stats...\")\n    stats_df = scrape_multiple_seasons()\n    stats_df.to_csv(\"data/season_stats.csv\", index=False)\n"
        },
        "event": "summarize_selected_code",
        "id": "PlY4u2IcQtyZz2HYNkmd"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:10:12.000",
        "data": {
            "detail_level": "high",
            "section_id": "f9b0208b-12de-4f2b-80f7-7870bbeabae0",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "nSD5B2AuMghEoIo51NVp"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:10:12.000",
        "data": {
            "detail_level": "high",
            "section_id": "f9b0208b-12de-4f2b-80f7-7870bbeabae0",
            "structured_type": "structured",
            "mapping_index": 3
        },
        "event": "mapping_hover",
        "id": "nuTFEfsAoosF7NBzPeq6"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:10:13.000",
        "data": {
            "detail_level": "high",
            "section_id": "f9b0208b-12de-4f2b-80f7-7870bbeabae0",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "LmqS1q9wHgDsd1WYg1Nk"
    },
    {
        "source": "backend",
        "timestamp": "2025-08-23 14:10:15.000",
        "data": {
            "summary": "• Scrapes MVP votes and player stats from Basketball Reference\n• Processes multiple NBA seasons\n• Saves results as CSV files",
            "code": "1: import pandas as pd\n2: import os\n3: \n4: \n5: def scrape_mvp_votes(start_year=2018, end_year=2025):\n6:     all_votes = []\n7:     for year in range(start_year, end_year + 1):\n8:         url = f\"https://www.basketball-reference.com/awards/awards_{year}.html\"\n9:         tables = pd.read_html(url, header=1)\n10:         try:\n11:             mvp_table = tables[0]  # MVP table is the first table\n12:             mvp_table[\"Year\"] = year\n13:             all_votes.append(mvp_table)\n14:         except:\n15:             print(f\"Could not parse year {year}\")\n16: \n17:     df = pd.concat(all_votes)\n18:     df = df.rename(columns={\"Player\": \"Name\", \"Pts Won\": \"MVP_Points\"})\n19:     return df[[\"Year\", \"Name\", \"MVP_Points\"]]\n20: \n21: \n22: def scrape_season_stats(year):\n23:     base_url_reg = (\n24:         f\"https://www.basketball-reference.com/leagues/NBA_{year}_per_game.html\"\n25:     )\n26:     df_reg = pd.read_html(base_url_reg, header=0)[0]\n27:     df_reg = df_reg[df_reg[\"Player\"] != \"Player\"]  # remove repeated header rows\n28:     df_reg[\"Year\"] = year\n29: \n30:     df_reg = df_reg[\n31:         [\"Player\", \"Year\", \"PTS\", \"AST\", \"TRB\", \"FG%\"]\n32:     ]  # Keep only specified columns\n33:     df_reg = df_reg.dropna(\n34:         subset=[\"PTS\", \"AST\", \"TRB\", \"FG%\"]\n35:     )  # Ensure key stats aren't invalid\n36:     return df_reg\n37: \n38: \n39: def scrape_multiple_seasons(start_year=2018, end_year=2025):\n40:     all_stats = []\n41:     for year in range(start_year, end_year + 1):\n42:         df = scrape_season_stats(year)\n43:         all_stats.append(df)\n44:     return pd.concat(all_stats)\n45: \n46: \n47: if __name__ == \"__main__\":\n48:     if not os.path.exists(\"data\"):\n49:         os.makedirs(\"data\")\n50: \n51:     print(\"Scraping MVP votes...\")\n52:     mvp_df = scrape_mvp_votes()\n53:     mvp_df.to_csv(\"data/mvp_votes.csv\", index=False)\n54: \n55:     print(\"Scraping player stats...\")\n56:     stats_df = scrape_multiple_seasons()\n57:     stats_df.to_csv(\"data/season_stats.csv\", index=False)\n58: ",
            "mapping": [
                {
                    "codeSegments": [
                        {
                            "line": 5,
                            "code": "def scrape_mvp_votes(start_year=2018, end_year=2025):"
                        },
                        {
                            "line": 22,
                            "code": "def scrape_season_stats(year):"
                        },
                        {
                            "line": 39,
                            "code": "def scrape_multiple_seasons(start_year=2018, end_year=2025):"
                        }
                    ],
                    "summaryComponent": "Scrapes MVP votes and player stats from Basketball Reference"
                },
                {
                    "codeSegments": [
                        {
                            "line": 7,
                            "code": "for year in range(start_year, end_year + 1):"
                        },
                        {
                            "line": 41,
                            "code": "for year in range(start_year, end_year + 1):"
                        }
                    ],
                    "summaryComponent": "Processes multiple NBA seasons"
                },
                {
                    "codeSegments": [
                        {
                            "line": 53,
                            "code": "mvp_df.to_csv(\"data/mvp_votes.csv\", index=False)"
                        },
                        {
                            "line": 57,
                            "code": "stats_df.to_csv(\"data/season_stats.csv\", index=False)"
                        }
                    ],
                    "summaryComponent": "Saves results as CSV files"
                }
            ]
        },
        "event": "map_summary_code",
        "id": "pyEhVDddemjjmf0yAEs3"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:10:16.000",
        "data": {
            "detail_level": "medium",
            "section_id": "c57d1459-fc0c-4521-815d-a88a0fc33c55",
            "structured_type": "unstructured",
            "mapping_index": 6
        },
        "event": "mapping_hover",
        "id": "676ZC1PfLoma0Q7rcXVS"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:10:16.000",
        "data": {
            "detail_level": "medium",
            "section_id": "c57d1459-fc0c-4521-815d-a88a0fc33c55",
            "structured_type": "unstructured"
        },
        "event": "mapping_unhover",
        "id": "Hx0zCZrOcEgPs1fmUAXt"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:10:16.000",
        "data": {
            "detail_level": "medium",
            "section_id": "c57d1459-fc0c-4521-815d-a88a0fc33c55",
            "structured_type": "unstructured",
            "mapping_index": 3
        },
        "event": "mapping_hover",
        "id": "Jn0J4ffX7gOhTgph9kM6"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:10:16.000",
        "data": {
            "detail_level": "medium",
            "section_id": "c57d1459-fc0c-4521-815d-a88a0fc33c55",
            "structured_type": "unstructured",
            "mapping_index": 1
        },
        "event": "mapping_hover",
        "id": "NzyiRosO8KbQIdMoA3jU"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:10:16.000",
        "data": {
            "detail_level": "medium",
            "section_id": "c57d1459-fc0c-4521-815d-a88a0fc33c55",
            "structured_type": "unstructured"
        },
        "event": "mapping_unhover",
        "id": "RSwRT8lyCjYl7Zd6JO4x"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:10:16.000",
        "data": {
            "detail_level": "medium",
            "section_id": "c57d1459-fc0c-4521-815d-a88a0fc33c55",
            "structured_type": "unstructured"
        },
        "event": "mapping_unhover",
        "id": "VnsGHGCjBxXIuRwFgRyu"
    },
    {
        "source": "backend",
        "timestamp": "2025-08-23 14:10:16.000",
        "data": {
            "summary": "• Defines functions to scrape MVP votes and player stats from Basketball Reference\n• Handles multiple seasons from 2018 to 2025\n  ◦ Aggregates data across years for both MVP votes and stats\n• Saves the results as CSV files in a 'data' directory\n• Ensures necessary directories exist before saving",
            "code": "1: import pandas as pd\n2: import os\n3: \n4: \n5: def scrape_mvp_votes(start_year=2018, end_year=2025):\n6:     all_votes = []\n7:     for year in range(start_year, end_year + 1):\n8:         url = f\"https://www.basketball-reference.com/awards/awards_{year}.html\"\n9:         tables = pd.read_html(url, header=1)\n10:         try:\n11:             mvp_table = tables[0]  # MVP table is the first table\n12:             mvp_table[\"Year\"] = year\n13:             all_votes.append(mvp_table)\n14:         except:\n15:             print(f\"Could not parse year {year}\")\n16: \n17:     df = pd.concat(all_votes)\n18:     df = df.rename(columns={\"Player\": \"Name\", \"Pts Won\": \"MVP_Points\"})\n19:     return df[[\"Year\", \"Name\", \"MVP_Points\"]]\n20: \n21: \n22: def scrape_season_stats(year):\n23:     base_url_reg = (\n24:         f\"https://www.basketball-reference.com/leagues/NBA_{year}_per_game.html\"\n25:     )\n26:     df_reg = pd.read_html(base_url_reg, header=0)[0]\n27:     df_reg = df_reg[df_reg[\"Player\"] != \"Player\"]  # remove repeated header rows\n28:     df_reg[\"Year\"] = year\n29: \n30:     df_reg = df_reg[\n31:         [\"Player\", \"Year\", \"PTS\", \"AST\", \"TRB\", \"FG%\"]\n32:     ]  # Keep only specified columns\n33:     df_reg = df_reg.dropna(\n34:         subset=[\"PTS\", \"AST\", \"TRB\", \"FG%\"]\n35:     )  # Ensure key stats aren't invalid\n36:     return df_reg\n37: \n38: \n39: def scrape_multiple_seasons(start_year=2018, end_year=2025):\n40:     all_stats = []\n41:     for year in range(start_year, end_year + 1):\n42:         df = scrape_season_stats(year)\n43:         all_stats.append(df)\n44:     return pd.concat(all_stats)\n45: \n46: \n47: if __name__ == \"__main__\":\n48:     if not os.path.exists(\"data\"):\n49:         os.makedirs(\"data\")\n50: \n51:     print(\"Scraping MVP votes...\")\n52:     mvp_df = scrape_mvp_votes()\n53:     mvp_df.to_csv(\"data/mvp_votes.csv\", index=False)\n54: \n55:     print(\"Scraping player stats...\")\n56:     stats_df = scrape_multiple_seasons()\n57:     stats_df.to_csv(\"data/season_stats.csv\", index=False)\n58: ",
            "mapping": [
                {
                    "codeSegments": [
                        {
                            "line": 5,
                            "code": "def scrape_mvp_votes(start_year=2018, end_year=2025):"
                        },
                        {
                            "line": 22,
                            "code": "def scrape_season_stats(year):"
                        },
                        {
                            "line": 39,
                            "code": "def scrape_multiple_seasons(start_year=2018, end_year=2025):"
                        }
                    ],
                    "summaryComponent": "Defines functions to scrape MVP votes and player stats from Basketball Reference"
                },
                {
                    "codeSegments": [
                        {
                            "line": 7,
                            "code": "for year in range(start_year, end_year + 1):"
                        },
                        {
                            "line": 41,
                            "code": "for year in range(start_year, end_year + 1):"
                        }
                    ],
                    "summaryComponent": "Handles multiple seasons from 2018 to 2025"
                },
                {
                    "codeSegments": [
                        {
                            "line": 13,
                            "code": "all_votes.append(mvp_table)"
                        },
                        {
                            "line": 17,
                            "code": "df = pd.concat(all_votes)"
                        },
                        {
                            "line": 43,
                            "code": "all_stats.append(df)"
                        },
                        {
                            "line": 44,
                            "code": "return pd.concat(all_stats)"
                        }
                    ],
                    "summaryComponent": "Aggregates data across years for both MVP votes and stats"
                },
                {
                    "codeSegments": [
                        {
                            "line": 53,
                            "code": "mvp_df.to_csv(\"data/mvp_votes.csv\", index=False)"
                        },
                        {
                            "line": 57,
                            "code": "stats_df.to_csv(\"data/season_stats.csv\", index=False)"
                        }
                    ],
                    "summaryComponent": "Saves the results as CSV files in a 'data' directory"
                },
                {
                    "codeSegments": [
                        {
                            "line": 48,
                            "code": "if not os.path.exists(\"data\"):"
                        },
                        {
                            "line": 49,
                            "code": "os.makedirs(\"data\")"
                        }
                    ],
                    "summaryComponent": "Ensures necessary directories exist before saving"
                }
            ]
        },
        "event": "map_summary_code",
        "id": "ZoX0n5gw0hXJZHkmSjEA"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:10:16.000",
        "data": {
            "detail_level": "medium",
            "section_id": "c57d1459-fc0c-4521-815d-a88a0fc33c55",
            "structured_type": "unstructured",
            "mapping_index": 2
        },
        "event": "mapping_hover",
        "id": "bJ9T1W8iFevIJZQQ0yhx"
    },
    {
        "source": "backend",
        "timestamp": "2025-08-23 14:10:16.000",
        "data": {
            "summary": "This code scrapes MVP votes and player statistics from Basketball Reference for multiple NBA seasons and saves the data as CSV files.",
            "code": "1: import pandas as pd\n2: import os\n3: \n4: \n5: def scrape_mvp_votes(start_year=2018, end_year=2025):\n6:     all_votes = []\n7:     for year in range(start_year, end_year + 1):\n8:         url = f\"https://www.basketball-reference.com/awards/awards_{year}.html\"\n9:         tables = pd.read_html(url, header=1)\n10:         try:\n11:             mvp_table = tables[0]  # MVP table is the first table\n12:             mvp_table[\"Year\"] = year\n13:             all_votes.append(mvp_table)\n14:         except:\n15:             print(f\"Could not parse year {year}\")\n16: \n17:     df = pd.concat(all_votes)\n18:     df = df.rename(columns={\"Player\": \"Name\", \"Pts Won\": \"MVP_Points\"})\n19:     return df[[\"Year\", \"Name\", \"MVP_Points\"]]\n20: \n21: \n22: def scrape_season_stats(year):\n23:     base_url_reg = (\n24:         f\"https://www.basketball-reference.com/leagues/NBA_{year}_per_game.html\"\n25:     )\n26:     df_reg = pd.read_html(base_url_reg, header=0)[0]\n27:     df_reg = df_reg[df_reg[\"Player\"] != \"Player\"]  # remove repeated header rows\n28:     df_reg[\"Year\"] = year\n29: \n30:     df_reg = df_reg[\n31:         [\"Player\", \"Year\", \"PTS\", \"AST\", \"TRB\", \"FG%\"]\n32:     ]  # Keep only specified columns\n33:     df_reg = df_reg.dropna(\n34:         subset=[\"PTS\", \"AST\", \"TRB\", \"FG%\"]\n35:     )  # Ensure key stats aren't invalid\n36:     return df_reg\n37: \n38: \n39: def scrape_multiple_seasons(start_year=2018, end_year=2025):\n40:     all_stats = []\n41:     for year in range(start_year, end_year + 1):\n42:         df = scrape_season_stats(year)\n43:         all_stats.append(df)\n44:     return pd.concat(all_stats)\n45: \n46: \n47: if __name__ == \"__main__\":\n48:     if not os.path.exists(\"data\"):\n49:         os.makedirs(\"data\")\n50: \n51:     print(\"Scraping MVP votes...\")\n52:     mvp_df = scrape_mvp_votes()\n53:     mvp_df.to_csv(\"data/mvp_votes.csv\", index=False)\n54: \n55:     print(\"Scraping player stats...\")\n56:     stats_df = scrape_multiple_seasons()\n57:     stats_df.to_csv(\"data/season_stats.csv\", index=False)\n58: ",
            "mapping": [
                {
                    "codeSegments": [
                        {
                            "line": 5,
                            "code": "def scrape_mvp_votes(start_year=2018, end_year=2025):"
                        },
                        {
                            "line": 52,
                            "code": "mvp_df = scrape_mvp_votes()"
                        }
                    ],
                    "summaryComponent": "scrapes MVP votes"
                },
                {
                    "codeSegments": [
                        {
                            "line": 22,
                            "code": "def scrape_season_stats(year):"
                        },
                        {
                            "line": 39,
                            "code": "def scrape_multiple_seasons(start_year=2018, end_year=2025):"
                        },
                        {
                            "line": 56,
                            "code": "stats_df = scrape_multiple_seasons()"
                        }
                    ],
                    "summaryComponent": "and player statistics"
                },
                {
                    "codeSegments": [
                        {
                            "line": 8,
                            "code": "url = f\"https://www.basketball-reference.com/awards/awards_{year}.html\""
                        },
                        {
                            "line": 23,
                            "code": "base_url_reg = (\n    f\"https://www.basketball-reference.com/leagues/NBA_{year}_per_game.html\"\n)"
                        }
                    ],
                    "summaryComponent": "from Basketball Reference"
                },
                {
                    "codeSegments": [
                        {
                            "line": 7,
                            "code": "for year in range(start_year, end_year + 1):"
                        },
                        {
                            "line": 41,
                            "code": "for year in range(start_year, end_year + 1):"
                        }
                    ],
                    "summaryComponent": "for multiple NBA seasons"
                },
                {
                    "codeSegments": [
                        {
                            "line": 53,
                            "code": "mvp_df.to_csv(\"data/mvp_votes.csv\", index=False)"
                        },
                        {
                            "line": 57,
                            "code": "stats_df.to_csv(\"data/season_stats.csv\", index=False)"
                        }
                    ],
                    "summaryComponent": "and saves the data as CSV files."
                }
            ]
        },
        "event": "map_summary_code",
        "id": "iQmqB5xv1Ig4sDGMKTkR"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:10:16.000",
        "data": {
            "after_section_id": "c57d1459-fc0c-4521-815d-a88a0fc33c55",
            "before_section_id": "f9b0208b-12de-4f2b-80f7-7870bbeabae0"
        },
        "event": "toggle_section",
        "id": "nXZ0Tc8gx97eLWGEzF4A"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:10:16.000",
        "data": {
            "detail_level": "medium",
            "section_id": "c57d1459-fc0c-4521-815d-a88a0fc33c55",
            "structured_type": "unstructured"
        },
        "event": "mapping_unhover",
        "id": "orksq9uCRJGSqFJLS99z"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:10:16.000",
        "data": {
            "detail_level": "medium",
            "section_id": "c57d1459-fc0c-4521-815d-a88a0fc33c55",
            "structured_type": "unstructured",
            "mapping_index": 5
        },
        "event": "mapping_hover",
        "id": "w1qdH4uMoXvHQewrnUZc"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:10:16.000",
        "data": {
            "detail_level": "medium",
            "section_id": "c57d1459-fc0c-4521-815d-a88a0fc33c55",
            "structured_type": "unstructured"
        },
        "event": "mapping_unhover",
        "id": "yd0mJXcjtM4oAZoRNps8"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:10:19.000",
        "data": {
            "detail_level": "medium",
            "section_id": "c57d1459-fc0c-4521-815d-a88a0fc33c55",
            "structured_type": "unstructured"
        },
        "event": "mapping_unhover",
        "id": "07JsWjqAsEZbYFmzx94E"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:10:19.000",
        "data": {
            "detail_level": "medium",
            "section_id": "c57d1459-fc0c-4521-815d-a88a0fc33c55",
            "structured_type": "unstructured"
        },
        "event": "mapping_unhover",
        "id": "2gN60VbXTlz0XXFVVuqF"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:10:19.000",
        "data": {
            "detail_level": "medium",
            "section_id": "c57d1459-fc0c-4521-815d-a88a0fc33c55",
            "structured_type": "unstructured",
            "mapping_index": 4
        },
        "event": "mapping_hover",
        "id": "9IUbKSGNx5AJorb8KvBO"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:10:19.000",
        "data": {
            "detail_level": "medium",
            "section_id": "c57d1459-fc0c-4521-815d-a88a0fc33c55",
            "structured_type": "unstructured",
            "mapping_index": 3
        },
        "event": "mapping_hover",
        "id": "DRJrcnBpHDceGPB2pAXv"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:10:19.000",
        "data": {
            "detail_level": "medium",
            "section_id": "95822364-a873-4e0e-960e-c1e8aeb35a12",
            "structured_type": "unstructured"
        },
        "event": "mapping_unhover",
        "id": "F5AGIiWmPauWfbur2oi6"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:10:19.000",
        "data": {
            "detail_level": "medium",
            "section_id": "c57d1459-fc0c-4521-815d-a88a0fc33c55",
            "structured_type": "unstructured",
            "mapping_index": 6
        },
        "event": "mapping_hover",
        "id": "IYD7KbTVvV5lygUT0WKK"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:10:19.000",
        "data": {
            "detail_level": "medium",
            "section_id": "c57d1459-fc0c-4521-815d-a88a0fc33c55",
            "structured_type": "unstructured",
            "mapping_index": 2
        },
        "event": "mapping_hover",
        "id": "YjZB9CnWu299LpstErxW"
    },
    {
        "source": "backend",
        "timestamp": "2025-08-23 14:10:19.000",
        "data": {
            "summary": "The script collects MVP voting results and player per-game statistics from Basketball Reference for NBA seasons between 2018 and 2025. It defines functions to scrape MVP votes, individual season stats, and aggregate stats across multiple seasons. The gathered data is saved into CSV files in a local 'data' directory.",
            "code": "1: import pandas as pd\n2: import os\n3: \n4: \n5: def scrape_mvp_votes(start_year=2018, end_year=2025):\n6:     all_votes = []\n7:     for year in range(start_year, end_year + 1):\n8:         url = f\"https://www.basketball-reference.com/awards/awards_{year}.html\"\n9:         tables = pd.read_html(url, header=1)\n10:         try:\n11:             mvp_table = tables[0]  # MVP table is the first table\n12:             mvp_table[\"Year\"] = year\n13:             all_votes.append(mvp_table)\n14:         except:\n15:             print(f\"Could not parse year {year}\")\n16: \n17:     df = pd.concat(all_votes)\n18:     df = df.rename(columns={\"Player\": \"Name\", \"Pts Won\": \"MVP_Points\"})\n19:     return df[[\"Year\", \"Name\", \"MVP_Points\"]]\n20: \n21: \n22: def scrape_season_stats(year):\n23:     base_url_reg = (\n24:         f\"https://www.basketball-reference.com/leagues/NBA_{year}_per_game.html\"\n25:     )\n26:     df_reg = pd.read_html(base_url_reg, header=0)[0]\n27:     df_reg = df_reg[df_reg[\"Player\"] != \"Player\"]  # remove repeated header rows\n28:     df_reg[\"Year\"] = year\n29: \n30:     df_reg = df_reg[\n31:         [\"Player\", \"Year\", \"PTS\", \"AST\", \"TRB\", \"FG%\"]\n32:     ]  # Keep only specified columns\n33:     df_reg = df_reg.dropna(\n34:         subset=[\"PTS\", \"AST\", \"TRB\", \"FG%\"]\n35:     )  # Ensure key stats aren't invalid\n36:     return df_reg\n37: \n38: \n39: def scrape_multiple_seasons(start_year=2018, end_year=2025):\n40:     all_stats = []\n41:     for year in range(start_year, end_year + 1):\n42:         df = scrape_season_stats(year)\n43:         all_stats.append(df)\n44:     return pd.concat(all_stats)\n45: \n46: \n47: if __name__ == \"__main__\":\n48:     if not os.path.exists(\"data\"):\n49:         os.makedirs(\"data\")\n50: \n51:     print(\"Scraping MVP votes...\")\n52:     mvp_df = scrape_mvp_votes()\n53:     mvp_df.to_csv(\"data/mvp_votes.csv\", index=False)\n54: \n55:     print(\"Scraping player stats...\")\n56:     stats_df = scrape_multiple_seasons()\n57:     stats_df.to_csv(\"data/season_stats.csv\", index=False)\n58: ",
            "mapping": [
                {
                    "codeSegments": [
                        {
                            "line": 5,
                            "code": "def scrape_mvp_votes(start_year=2018, end_year=2025):"
                        },
                        {
                            "line": 52,
                            "code": "mvp_df = scrape_mvp_votes()"
                        }
                    ],
                    "summaryComponent": "collects MVP voting results"
                },
                {
                    "codeSegments": [
                        {
                            "line": 22,
                            "code": "def scrape_season_stats(year):"
                        },
                        {
                            "line": 39,
                            "code": "def scrape_multiple_seasons(start_year=2018, end_year=2025):"
                        }
                    ],
                    "summaryComponent": "player per-game statistics"
                },
                {
                    "codeSegments": [
                        {
                            "line": 8,
                            "code": "url = f\"https://www.basketball-reference.com/awards/awards_{year}.html\""
                        },
                        {
                            "line": 23,
                            "code": "base_url_reg = ("
                        },
                        {
                            "line": 24,
                            "code": "f\"https://www.basketball-reference.com/leagues/NBA_{year}_per_game.html\""
                        }
                    ],
                    "summaryComponent": "from Basketball Reference"
                },
                {
                    "codeSegments": [
                        {
                            "line": 7,
                            "code": "for year in range(start_year, end_year + 1):"
                        },
                        {
                            "line": 41,
                            "code": "for year in range(start_year, end_year + 1):"
                        }
                    ],
                    "summaryComponent": "for NBA seasons between 2018 and 2025"
                },
                {
                    "codeSegments": [
                        {
                            "line": 5,
                            "code": "def scrape_mvp_votes(start_year=2018, end_year=2025):"
                        }
                    ],
                    "summaryComponent": "defines functions to scrape MVP votes"
                },
                {
                    "codeSegments": [
                        {
                            "line": 22,
                            "code": "def scrape_season_stats(year):"
                        }
                    ],
                    "summaryComponent": "individual season stats"
                },
                {
                    "codeSegments": [
                        {
                            "line": 39,
                            "code": "def scrape_multiple_seasons(start_year=2018, end_year=2025):"
                        }
                    ],
                    "summaryComponent": "aggregate stats across multiple seasons"
                },
                {
                    "codeSegments": [
                        {
                            "line": 53,
                            "code": "mvp_df.to_csv(\"data/mvp_votes.csv\", index=False)"
                        },
                        {
                            "line": 57,
                            "code": "stats_df.to_csv(\"data/season_stats.csv\", index=False)"
                        }
                    ],
                    "summaryComponent": "gathered data is saved into CSV files"
                },
                {
                    "codeSegments": [
                        {
                            "line": 48,
                            "code": "if not os.path.exists(\"data\"):"
                        },
                        {
                            "line": 49,
                            "code": "os.makedirs(\"data\")"
                        },
                        {
                            "line": 53,
                            "code": "\"data/mvp_votes.csv\""
                        },
                        {
                            "line": 57,
                            "code": "\"data/season_stats.csv\""
                        }
                    ],
                    "summaryComponent": "in a local 'data' directory"
                }
            ]
        },
        "event": "map_summary_code",
        "id": "aAcfx4GDRfqh9kwLh0GM"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:10:19.000",
        "data": {
            "after_section_id": "95822364-a873-4e0e-960e-c1e8aeb35a12",
            "before_section_id": "c57d1459-fc0c-4521-815d-a88a0fc33c55"
        },
        "event": "autotransit_section",
        "id": "e2YvHH9tMA0VRgjkv0lv"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:10:19.000",
        "data": {
            "detail_level": "medium",
            "section_id": "c57d1459-fc0c-4521-815d-a88a0fc33c55",
            "structured_type": "unstructured"
        },
        "event": "mapping_unhover",
        "id": "hF2Mt0DSugnXSgy1tgDV"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:10:19.000",
        "data": {
            "detail_level": "medium",
            "section_id": "95822364-a873-4e0e-960e-c1e8aeb35a12",
            "structured_type": "unstructured",
            "mapping_index": 0
        },
        "event": "mapping_hover",
        "id": "iNzuKPF2suVQ7ZcAT4zu"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:10:19.000",
        "data": {
            "detail_level": "medium",
            "section_id": "c57d1459-fc0c-4521-815d-a88a0fc33c55",
            "structured_type": "unstructured"
        },
        "event": "mapping_unhover",
        "id": "oxXnqv4Z66R0cmPX57yi"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:10:19.000",
        "data": {
            "detail_level": "medium",
            "section_id": "c57d1459-fc0c-4521-815d-a88a0fc33c55",
            "structured_type": "unstructured"
        },
        "event": "mapping_unhover",
        "id": "rj2sHSvZvDrDJiRGcqSH"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:10:19.000",
        "data": {
            "section_data": {
                "editPromptValue": "",
                "summaryData": {
                    "high_unstructured": "This code provides a set of functions to scrape NBA MVP voting results and player per-game statistics from Basketball Reference for seasons 2018 through 2025. The 'scrape_mvp_votes' function fetches MVP tables for each year, renames columns, and concatenates results, while 'scrape_season_stats' retrieves and cleans player stats for a given season, retaining only key columns and valid rows. The 'scrape_multiple_seasons' function aggregates stats across all specified years. When run as a script, it ensures a 'data' directory exists, scrapes both MVP and player stats, and saves them as CSV files, handling missing data gracefully and providing progress output.",
                    "low_structured": "• Scrapes MVP votes and player stats from Basketball Reference\n• Processes multiple NBA seasons\n• Saves results as CSV files",
                    "high_structured": "• Imports pandas and os modules for data handling and file operations\n• Defines scraping functions:\n  ◦ scrape_mvp_votes: Loops through years, fetches MVP voting tables, renames columns, and aggregates results\n  ◦ scrape_season_stats: Retrieves per-game player stats for a year, cleans data, and selects key columns (Player, Year, PTS, AST, TRB, FG%)\n  ◦ scrape_multiple_seasons: Aggregates player stats across multiple years using scrape_season_stats\n• Main script logic:\n  ◦ Checks for and creates a 'data' directory if needed\n  ◦ Scrapes MVP votes and saves to 'data/mvp_votes.csv'\n  ◦ Scrapes player stats across seasons and saves to 'data/season_stats.csv'\n  ◦ Prints progress messages to the console\n• Handles missing or unparsable data gracefully during scraping",
                    "title": "Basketball Reference MVP Votes and Player Stats Scraper",
                    "medium_unstructured": "The script collects MVP voting results and player per-game statistics from Basketball Reference for NBA seasons between 2018 and 2025. It defines functions to scrape MVP votes, individual season stats, and aggregate stats across multiple seasons. The gathered data is saved into CSV files in a local 'data' directory.",
                    "medium_structured": "• Defines functions to scrape MVP votes and player stats from Basketball Reference\n• Handles multiple seasons from 2018 to 2025\n  ◦ Aggregates data across years for both MVP votes and stats\n• Saves the results as CSV files in a 'data' directory\n• Ensures necessary directories exist before saving",
                    "low_unstructured": "This code scrapes MVP votes and player statistics from Basketball Reference for multiple NBA seasons and saves the data as CSV files."
                },
                "selectedDetailLevel": "medium",
                "title": "Basketball Reference MVP Votes and Player Stats Scraper",
                "summaryMappings": {
                    "low_structured": [
                        {
                            "codeSegments": [
                                {
                                    "line": 5,
                                    "code": "def scrape_mvp_votes(start_year=2018, end_year=2025):"
                                },
                                {
                                    "line": 22,
                                    "code": "def scrape_season_stats(year):"
                                },
                                {
                                    "line": 39,
                                    "code": "def scrape_multiple_seasons(start_year=2018, end_year=2025):"
                                }
                            ],
                            "summaryComponent": "Scrapes MVP votes and player stats from Basketball Reference"
                        },
                        {
                            "codeSegments": [
                                {
                                    "line": 7,
                                    "code": "for year in range(start_year, end_year + 1):"
                                },
                                {
                                    "line": 41,
                                    "code": "for year in range(start_year, end_year + 1):"
                                }
                            ],
                            "summaryComponent": "Processes multiple NBA seasons"
                        },
                        {
                            "codeSegments": [
                                {
                                    "line": 53,
                                    "code": "mvp_df.to_csv(\"data/mvp_votes.csv\", index=False)"
                                },
                                {
                                    "line": 57,
                                    "code": "stats_df.to_csv(\"data/season_stats.csv\", index=False)"
                                }
                            ],
                            "summaryComponent": "Saves results as CSV files"
                        }
                    ],
                    "high_structured": [
                        {
                            "codeSegments": [
                                {
                                    "line": 1,
                                    "code": "import pandas as pd"
                                },
                                {
                                    "line": 2,
                                    "code": "import os"
                                }
                            ],
                            "summaryComponent": "Imports pandas and os modules for data handling and file operations"
                        },
                        {
                            "codeSegments": [
                                {
                                    "line": 5,
                                    "code": "def scrape_mvp_votes(start_year=2018, end_year=2025):"
                                },
                                {
                                    "line": 22,
                                    "code": "def scrape_season_stats(year):"
                                },
                                {
                                    "line": 39,
                                    "code": "def scrape_multiple_seasons(start_year=2018, end_year=2025):"
                                }
                            ],
                            "summaryComponent": "Defines scraping functions:"
                        },
                        {
                            "codeSegments": [
                                {
                                    "line": 7,
                                    "code": "for year in range(start_year, end_year + 1):"
                                },
                                {
                                    "line": 8,
                                    "code": "url = f\"https://www.basketball-reference.com/awards/awards_{year}.html\""
                                },
                                {
                                    "line": 9,
                                    "code": "tables = pd.read_html(url, header=1)"
                                },
                                {
                                    "line": 11,
                                    "code": "mvp_table = tables[0]  # MVP table is the first table"
                                },
                                {
                                    "line": 12,
                                    "code": "mvp_table[\"Year\"] = year"
                                },
                                {
                                    "line": 13,
                                    "code": "all_votes.append(mvp_table)"
                                },
                                {
                                    "line": 17,
                                    "code": "df = pd.concat(all_votes)"
                                },
                                {
                                    "line": 18,
                                    "code": "df = df.rename(columns={\"Player\": \"Name\", \"Pts Won\": \"MVP_Points\"})"
                                }
                            ],
                            "summaryComponent": "scrape_mvp_votes: Loops through years, fetches MVP voting tables, renames columns, and aggregates results"
                        },
                        {
                            "codeSegments": [
                                {
                                    "line": 26,
                                    "code": "df_reg = pd.read_html(base_url_reg, header=0)[0]"
                                },
                                {
                                    "line": 27,
                                    "code": "df_reg = df_reg[df_reg[\"Player\"] != \"Player\"]  # remove repeated header rows"
                                },
                                {
                                    "line": 28,
                                    "code": "df_reg[\"Year\"] = year"
                                },
                                {
                                    "line": 30,
                                    "code": "df_reg = df_reg[\n    [\"Player\", \"Year\", \"PTS\", \"AST\", \"TRB\", \"FG%\"]\n]"
                                },
                                {
                                    "line": 33,
                                    "code": "df_reg = df_reg.dropna(\n    subset=[\"PTS\", \"AST\", \"TRB\", \"FG%\"]\n)"
                                }
                            ],
                            "summaryComponent": "scrape_season_stats: Retrieves per-game player stats for a year, cleans data, and selects key columns (Player, Year, PTS, AST, TRB, FG%)"
                        },
                        {
                            "codeSegments": [
                                {
                                    "line": 41,
                                    "code": "for year in range(start_year, end_year + 1):"
                                },
                                {
                                    "line": 42,
                                    "code": "df = scrape_season_stats(year)"
                                },
                                {
                                    "line": 43,
                                    "code": "all_stats.append(df)"
                                },
                                {
                                    "line": 44,
                                    "code": "return pd.concat(all_stats)"
                                }
                            ],
                            "summaryComponent": "scrape_multiple_seasons: Aggregates player stats across multiple years using scrape_season_stats"
                        },
                        {
                            "codeSegments": [
                                {
                                    "line": 47,
                                    "code": "if __name__ == \"__main__\":"
                                }
                            ],
                            "summaryComponent": "Main script logic:"
                        },
                        {
                            "codeSegments": [
                                {
                                    "line": 48,
                                    "code": "if not os.path.exists(\"data\"):"
                                },
                                {
                                    "line": 49,
                                    "code": "os.makedirs(\"data\")"
                                }
                            ],
                            "summaryComponent": "Checks for and creates a 'data' directory if needed"
                        },
                        {
                            "codeSegments": [
                                {
                                    "line": 52,
                                    "code": "mvp_df = scrape_mvp_votes()"
                                },
                                {
                                    "line": 53,
                                    "code": "mvp_df.to_csv(\"data/mvp_votes.csv\", index=False)"
                                }
                            ],
                            "summaryComponent": "Scrapes MVP votes and saves to 'data/mvp_votes.csv'"
                        },
                        {
                            "codeSegments": [
                                {
                                    "line": 56,
                                    "code": "stats_df = scrape_multiple_seasons()"
                                },
                                {
                                    "line": 57,
                                    "code": "stats_df.to_csv(\"data/season_stats.csv\", index=False)"
                                }
                            ],
                            "summaryComponent": "Scrapes player stats across seasons and saves to 'data/season_stats.csv'"
                        },
                        {
                            "codeSegments": [
                                {
                                    "line": 51,
                                    "code": "print(\"Scraping MVP votes...\")"
                                },
                                {
                                    "line": 55,
                                    "code": "print(\"Scraping player stats...\")"
                                }
                            ],
                            "summaryComponent": "Prints progress messages to the console"
                        },
                        {
                            "codeSegments": [
                                {
                                    "line": 14,
                                    "code": "except:"
                                },
                                {
                                    "line": 15,
                                    "code": "print(f\"Could not parse year {year}\")"
                                }
                            ],
                            "summaryComponent": "Handles missing or unparsable data gracefully during scraping"
                        }
                    ],
                    "medium_structured": [
                        {
                            "codeSegments": [
                                {
                                    "line": 5,
                                    "code": "def scrape_mvp_votes(start_year=2018, end_year=2025):"
                                },
                                {
                                    "line": 22,
                                    "code": "def scrape_season_stats(year):"
                                },
                                {
                                    "line": 39,
                                    "code": "def scrape_multiple_seasons(start_year=2018, end_year=2025):"
                                }
                            ],
                            "summaryComponent": "Defines functions to scrape MVP votes and player stats from Basketball Reference"
                        },
                        {
                            "codeSegments": [
                                {
                                    "line": 7,
                                    "code": "for year in range(start_year, end_year + 1):"
                                },
                                {
                                    "line": 41,
                                    "code": "for year in range(start_year, end_year + 1):"
                                }
                            ],
                            "summaryComponent": "Handles multiple seasons from 2018 to 2025"
                        },
                        {
                            "codeSegments": [
                                {
                                    "line": 13,
                                    "code": "all_votes.append(mvp_table)"
                                },
                                {
                                    "line": 17,
                                    "code": "df = pd.concat(all_votes)"
                                },
                                {
                                    "line": 43,
                                    "code": "all_stats.append(df)"
                                },
                                {
                                    "line": 44,
                                    "code": "return pd.concat(all_stats)"
                                }
                            ],
                            "summaryComponent": "Aggregates data across years for both MVP votes and stats"
                        },
                        {
                            "codeSegments": [
                                {
                                    "line": 53,
                                    "code": "mvp_df.to_csv(\"data/mvp_votes.csv\", index=False)"
                                },
                                {
                                    "line": 57,
                                    "code": "stats_df.to_csv(\"data/season_stats.csv\", index=False)"
                                }
                            ],
                            "summaryComponent": "Saves the results as CSV files in a 'data' directory"
                        },
                        {
                            "codeSegments": [
                                {
                                    "line": 48,
                                    "code": "if not os.path.exists(\"data\"):"
                                },
                                {
                                    "line": 49,
                                    "code": "os.makedirs(\"data\")"
                                }
                            ],
                            "summaryComponent": "Ensures necessary directories exist before saving"
                        }
                    ],
                    "medium_unstructured": [
                        {
                            "codeSegments": [
                                {
                                    "line": 5,
                                    "code": "def scrape_mvp_votes(start_year=2018, end_year=2025):"
                                },
                                {
                                    "line": 52,
                                    "code": "mvp_df = scrape_mvp_votes()"
                                }
                            ],
                            "summaryComponent": "collects MVP voting results"
                        },
                        {
                            "codeSegments": [
                                {
                                    "line": 22,
                                    "code": "def scrape_season_stats(year):"
                                },
                                {
                                    "line": 39,
                                    "code": "def scrape_multiple_seasons(start_year=2018, end_year=2025):"
                                }
                            ],
                            "summaryComponent": "player per-game statistics"
                        },
                        {
                            "codeSegments": [
                                {
                                    "line": 8,
                                    "code": "url = f\"https://www.basketball-reference.com/awards/awards_{year}.html\""
                                },
                                {
                                    "line": 23,
                                    "code": "base_url_reg = ("
                                },
                                {
                                    "line": 24,
                                    "code": "f\"https://www.basketball-reference.com/leagues/NBA_{year}_per_game.html\""
                                }
                            ],
                            "summaryComponent": "from Basketball Reference"
                        },
                        {
                            "codeSegments": [
                                {
                                    "line": 7,
                                    "code": "for year in range(start_year, end_year + 1):"
                                },
                                {
                                    "line": 41,
                                    "code": "for year in range(start_year, end_year + 1):"
                                }
                            ],
                            "summaryComponent": "for NBA seasons between 2018 and 2025"
                        },
                        {
                            "codeSegments": [
                                {
                                    "line": 5,
                                    "code": "def scrape_mvp_votes(start_year=2018, end_year=2025):"
                                }
                            ],
                            "summaryComponent": "defines functions to scrape MVP votes"
                        },
                        {
                            "codeSegments": [
                                {
                                    "line": 22,
                                    "code": "def scrape_season_stats(year):"
                                }
                            ],
                            "summaryComponent": "individual season stats"
                        },
                        {
                            "codeSegments": [
                                {
                                    "line": 39,
                                    "code": "def scrape_multiple_seasons(start_year=2018, end_year=2025):"
                                }
                            ],
                            "summaryComponent": "aggregate stats across multiple seasons"
                        },
                        {
                            "codeSegments": [
                                {
                                    "line": 53,
                                    "code": "mvp_df.to_csv(\"data/mvp_votes.csv\", index=False)"
                                },
                                {
                                    "line": 57,
                                    "code": "stats_df.to_csv(\"data/season_stats.csv\", index=False)"
                                }
                            ],
                            "summaryComponent": "gathered data is saved into CSV files"
                        },
                        {
                            "codeSegments": [
                                {
                                    "line": 48,
                                    "code": "if not os.path.exists(\"data\"):"
                                },
                                {
                                    "line": 49,
                                    "code": "os.makedirs(\"data\")"
                                },
                                {
                                    "line": 53,
                                    "code": "\"data/mvp_votes.csv\""
                                },
                                {
                                    "line": 57,
                                    "code": "\"data/season_stats.csv\""
                                }
                            ],
                            "summaryComponent": "in a local 'data' directory"
                        }
                    ],
                    "high_unstructured": [
                        {
                            "codeSegments": [
                                {
                                    "line": 5,
                                    "code": "def scrape_mvp_votes(start_year=2018, end_year=2025):"
                                },
                                {
                                    "line": 22,
                                    "code": "def scrape_season_stats(year):"
                                },
                                {
                                    "line": 39,
                                    "code": "def scrape_multiple_seasons(start_year=2018, end_year=2025):"
                                }
                            ],
                            "summaryComponent": "provides a set of functions to scrape NBA MVP voting results and player per-game statistics from Basketball Reference for seasons 2018 through 2025"
                        },
                        {
                            "codeSegments": [
                                {
                                    "line": 5,
                                    "code": "def scrape_mvp_votes(start_year=2018, end_year=2025):"
                                },
                                {
                                    "line": 7,
                                    "code": "for year in range(start_year, end_year + 1):"
                                },
                                {
                                    "line": 8,
                                    "code": "url = f\"https://www.basketball-reference.com/awards/awards_{year}.html\""
                                },
                                {
                                    "line": 9,
                                    "code": "tables = pd.read_html(url, header=1)"
                                }
                            ],
                            "summaryComponent": "The 'scrape_mvp_votes' function fetches MVP tables for each year"
                        },
                        {
                            "codeSegments": [
                                {
                                    "line": 18,
                                    "code": "df = df.rename(columns={\"Player\": \"Name\", \"Pts Won\": \"MVP_Points\"})"
                                }
                            ],
                            "summaryComponent": "renames columns"
                        },
                        {
                            "codeSegments": [
                                {
                                    "line": 17,
                                    "code": "df = pd.concat(all_votes)"
                                }
                            ],
                            "summaryComponent": "and concatenates results"
                        },
                        {
                            "codeSegments": [
                                {
                                    "line": 22,
                                    "code": "def scrape_season_stats(year):"
                                },
                                {
                                    "line": 26,
                                    "code": "df_reg = pd.read_html(base_url_reg, header=0)[0]"
                                },
                                {
                                    "line": 27,
                                    "code": "df_reg = df_reg[df_reg[\"Player\"] != \"Player\"]  # remove repeated header rows"
                                }
                            ],
                            "summaryComponent": "while 'scrape_season_stats' retrieves and cleans player stats for a given season"
                        },
                        {
                            "codeSegments": [
                                {
                                    "line": 30,
                                    "code": "df_reg = df_reg[\n    [\"Player\", \"Year\", \"PTS\", \"AST\", \"TRB\", \"FG%\"]\n]  # Keep only specified columns"
                                },
                                {
                                    "line": 33,
                                    "code": "df_reg = df_reg.dropna(\n    subset=[\"PTS\", \"AST\", \"TRB\", \"FG%\"]\n)  # Ensure key stats aren't invalid"
                                }
                            ],
                            "summaryComponent": "retaining only key columns and valid rows"
                        },
                        {
                            "codeSegments": [
                                {
                                    "line": 39,
                                    "code": "def scrape_multiple_seasons(start_year=2018, end_year=2025):"
                                },
                                {
                                    "line": 41,
                                    "code": "for year in range(start_year, end_year + 1):"
                                },
                                {
                                    "line": 42,
                                    "code": "df = scrape_season_stats(year)"
                                },
                                {
                                    "line": 43,
                                    "code": "all_stats.append(df)"
                                },
                                {
                                    "line": 44,
                                    "code": "return pd.concat(all_stats)"
                                }
                            ],
                            "summaryComponent": "The 'scrape_multiple_seasons' function aggregates stats across all specified years"
                        },
                        {
                            "codeSegments": [
                                {
                                    "line": 47,
                                    "code": "if __name__ == \"__main__\":"
                                },
                                {
                                    "line": 48,
                                    "code": "if not os.path.exists(\"data\"):"
                                },
                                {
                                    "line": 49,
                                    "code": "os.makedirs(\"data\")"
                                }
                            ],
                            "summaryComponent": "When run as a script, it ensures a 'data' directory exists"
                        },
                        {
                            "codeSegments": [
                                {
                                    "line": 52,
                                    "code": "mvp_df = scrape_mvp_votes()"
                                },
                                {
                                    "line": 53,
                                    "code": "mvp_df.to_csv(\"data/mvp_votes.csv\", index=False)"
                                },
                                {
                                    "line": 56,
                                    "code": "stats_df = scrape_multiple_seasons()"
                                },
                                {
                                    "line": 57,
                                    "code": "stats_df.to_csv(\"data/season_stats.csv\", index=False)"
                                }
                            ],
                            "summaryComponent": "scrapes both MVP and player stats, and saves them as CSV files"
                        },
                        {
                            "codeSegments": [
                                {
                                    "line": 14,
                                    "code": "except:"
                                },
                                {
                                    "line": 15,
                                    "code": "print(f\"Could not parse year {year}\")"
                                },
                                {
                                    "line": 51,
                                    "code": "print(\"Scraping MVP votes...\")"
                                },
                                {
                                    "line": 55,
                                    "code": "print(\"Scraping player stats...\")"
                                }
                            ],
                            "summaryComponent": "handling missing data gracefully and providing progress output"
                        }
                    ],
                    "low_unstructured": [
                        {
                            "codeSegments": [
                                {
                                    "line": 5,
                                    "code": "def scrape_mvp_votes(start_year=2018, end_year=2025):"
                                },
                                {
                                    "line": 52,
                                    "code": "mvp_df = scrape_mvp_votes()"
                                }
                            ],
                            "summaryComponent": "scrapes MVP votes"
                        },
                        {
                            "codeSegments": [
                                {
                                    "line": 22,
                                    "code": "def scrape_season_stats(year):"
                                },
                                {
                                    "line": 39,
                                    "code": "def scrape_multiple_seasons(start_year=2018, end_year=2025):"
                                },
                                {
                                    "line": 56,
                                    "code": "stats_df = scrape_multiple_seasons()"
                                }
                            ],
                            "summaryComponent": "and player statistics"
                        },
                        {
                            "codeSegments": [
                                {
                                    "line": 8,
                                    "code": "url = f\"https://www.basketball-reference.com/awards/awards_{year}.html\""
                                },
                                {
                                    "line": 23,
                                    "code": "base_url_reg = (\n    f\"https://www.basketball-reference.com/leagues/NBA_{year}_per_game.html\"\n)"
                                }
                            ],
                            "summaryComponent": "from Basketball Reference"
                        },
                        {
                            "codeSegments": [
                                {
                                    "line": 7,
                                    "code": "for year in range(start_year, end_year + 1):"
                                },
                                {
                                    "line": 41,
                                    "code": "for year in range(start_year, end_year + 1):"
                                }
                            ],
                            "summaryComponent": "for multiple NBA seasons"
                        },
                        {
                            "codeSegments": [
                                {
                                    "line": 53,
                                    "code": "mvp_df.to_csv(\"data/mvp_votes.csv\", index=False)"
                                },
                                {
                                    "line": 57,
                                    "code": "stats_df.to_csv(\"data/season_stats.csv\", index=False)"
                                }
                            ],
                            "summaryComponent": "and saves the data as CSV files."
                        }
                    ]
                },
                "metadata": {
                    "id": "95822364-a873-4e0e-960e-c1e8aeb35a12",
                    "filename": "scraper.py",
                    "offset": 0,
                    "fullPath": "/project/workspace/scraper.py",
                    "originalCode": "import pandas as pd\nimport os\n\n\ndef scrape_mvp_votes(start_year=2018, end_year=2025):\n    all_votes = []\n    for year in range(start_year, end_year + 1):\n        url = f\"https://www.basketball-reference.com/awards/awards_{year}.html\"\n        tables = pd.read_html(url, header=1)\n        try:\n            mvp_table = tables[0]  # MVP table is the first table\n            mvp_table[\"Year\"] = year\n            all_votes.append(mvp_table)\n        except:\n            print(f\"Could not parse year {year}\")\n\n    df = pd.concat(all_votes)\n    df = df.rename(columns={\"Player\": \"Name\", \"Pts Won\": \"MVP_Points\"})\n    return df[[\"Year\", \"Name\", \"MVP_Points\"]]\n\n\ndef scrape_season_stats(year):\n    base_url_reg = (\n        f\"https://www.basketball-reference.com/leagues/NBA_{year}_per_game.html\"\n    )\n    df_reg = pd.read_html(base_url_reg, header=0)[0]\n    df_reg = df_reg[df_reg[\"Player\"] != \"Player\"]  # remove repeated header rows\n    df_reg[\"Year\"] = year\n\n    df_reg = df_reg[\n        [\"Player\", \"Year\", \"PTS\", \"AST\", \"TRB\", \"FG%\"]\n    ]  # Keep only specified columns\n    df_reg = df_reg.dropna(\n        subset=[\"PTS\", \"AST\", \"TRB\", \"FG%\"]\n    )  # Ensure key stats aren't invalid\n    return df_reg\n\n\ndef scrape_multiple_seasons(start_year=2018, end_year=2025):\n    all_stats = []\n    for year in range(start_year, end_year + 1):\n        df = scrape_season_stats(year)\n        all_stats.append(df)\n    return pd.concat(all_stats)\n\n\nif __name__ == \"__main__\":\n    if not os.path.exists(\"data\"):\n        os.makedirs(\"data\")\n\n    print(\"Scraping MVP votes...\")\n    mvp_df = scrape_mvp_votes()\n    mvp_df.to_csv(\"data/mvp_votes.csv\", index=False)\n\n    print(\"Scraping player stats...\")\n    stats_df = scrape_multiple_seasons()\n    stats_df.to_csv(\"data/season_stats.csv\", index=False)\n"
                },
                "createdAt": 1755987020000,
                "lines": [
                    1,
                    58
                ],
                "editPromptStructured": null,
                "selectedStructured": "unstructured",
                "editPromptDetailLevel": null
            },
            "section_id": "95822364-a873-4e0e-960e-c1e8aeb35a12"
        },
        "event": "create_new_section",
        "id": "syF2Y3fkIVGLSoJkfU5B"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:10:19.000",
        "data": {
            "detail_level": "medium",
            "section_id": "c57d1459-fc0c-4521-815d-a88a0fc33c55",
            "structured_type": "unstructured",
            "mapping_index": 1
        },
        "event": "mapping_hover",
        "id": "vQsTjRzyVom8mKyVvTJA"
    },
    {
        "source": "backend",
        "timestamp": "2025-08-23 14:10:20.000",
        "data": {
            "summary": "This code provides a set of functions to scrape NBA MVP voting results and player per-game statistics from Basketball Reference for seasons 2018 through 2025. The 'scrape_mvp_votes' function fetches MVP tables for each year, renames columns, and concatenates results, while 'scrape_season_stats' retrieves and cleans player stats for a given season, retaining only key columns and valid rows. The 'scrape_multiple_seasons' function aggregates stats across all specified years. When run as a script, it ensures a 'data' directory exists, scrapes both MVP and player stats, and saves them as CSV files, handling missing data gracefully and providing progress output.",
            "code": "1: import pandas as pd\n2: import os\n3: \n4: \n5: def scrape_mvp_votes(start_year=2018, end_year=2025):\n6:     all_votes = []\n7:     for year in range(start_year, end_year + 1):\n8:         url = f\"https://www.basketball-reference.com/awards/awards_{year}.html\"\n9:         tables = pd.read_html(url, header=1)\n10:         try:\n11:             mvp_table = tables[0]  # MVP table is the first table\n12:             mvp_table[\"Year\"] = year\n13:             all_votes.append(mvp_table)\n14:         except:\n15:             print(f\"Could not parse year {year}\")\n16: \n17:     df = pd.concat(all_votes)\n18:     df = df.rename(columns={\"Player\": \"Name\", \"Pts Won\": \"MVP_Points\"})\n19:     return df[[\"Year\", \"Name\", \"MVP_Points\"]]\n20: \n21: \n22: def scrape_season_stats(year):\n23:     base_url_reg = (\n24:         f\"https://www.basketball-reference.com/leagues/NBA_{year}_per_game.html\"\n25:     )\n26:     df_reg = pd.read_html(base_url_reg, header=0)[0]\n27:     df_reg = df_reg[df_reg[\"Player\"] != \"Player\"]  # remove repeated header rows\n28:     df_reg[\"Year\"] = year\n29: \n30:     df_reg = df_reg[\n31:         [\"Player\", \"Year\", \"PTS\", \"AST\", \"TRB\", \"FG%\"]\n32:     ]  # Keep only specified columns\n33:     df_reg = df_reg.dropna(\n34:         subset=[\"PTS\", \"AST\", \"TRB\", \"FG%\"]\n35:     )  # Ensure key stats aren't invalid\n36:     return df_reg\n37: \n38: \n39: def scrape_multiple_seasons(start_year=2018, end_year=2025):\n40:     all_stats = []\n41:     for year in range(start_year, end_year + 1):\n42:         df = scrape_season_stats(year)\n43:         all_stats.append(df)\n44:     return pd.concat(all_stats)\n45: \n46: \n47: if __name__ == \"__main__\":\n48:     if not os.path.exists(\"data\"):\n49:         os.makedirs(\"data\")\n50: \n51:     print(\"Scraping MVP votes...\")\n52:     mvp_df = scrape_mvp_votes()\n53:     mvp_df.to_csv(\"data/mvp_votes.csv\", index=False)\n54: \n55:     print(\"Scraping player stats...\")\n56:     stats_df = scrape_multiple_seasons()\n57:     stats_df.to_csv(\"data/season_stats.csv\", index=False)\n58: ",
            "mapping": [
                {
                    "codeSegments": [
                        {
                            "line": 5,
                            "code": "def scrape_mvp_votes(start_year=2018, end_year=2025):"
                        },
                        {
                            "line": 22,
                            "code": "def scrape_season_stats(year):"
                        },
                        {
                            "line": 39,
                            "code": "def scrape_multiple_seasons(start_year=2018, end_year=2025):"
                        }
                    ],
                    "summaryComponent": "provides a set of functions to scrape NBA MVP voting results and player per-game statistics from Basketball Reference for seasons 2018 through 2025"
                },
                {
                    "codeSegments": [
                        {
                            "line": 5,
                            "code": "def scrape_mvp_votes(start_year=2018, end_year=2025):"
                        },
                        {
                            "line": 7,
                            "code": "for year in range(start_year, end_year + 1):"
                        },
                        {
                            "line": 8,
                            "code": "url = f\"https://www.basketball-reference.com/awards/awards_{year}.html\""
                        },
                        {
                            "line": 9,
                            "code": "tables = pd.read_html(url, header=1)"
                        }
                    ],
                    "summaryComponent": "The 'scrape_mvp_votes' function fetches MVP tables for each year"
                },
                {
                    "codeSegments": [
                        {
                            "line": 18,
                            "code": "df = df.rename(columns={\"Player\": \"Name\", \"Pts Won\": \"MVP_Points\"})"
                        }
                    ],
                    "summaryComponent": "renames columns"
                },
                {
                    "codeSegments": [
                        {
                            "line": 17,
                            "code": "df = pd.concat(all_votes)"
                        }
                    ],
                    "summaryComponent": "and concatenates results"
                },
                {
                    "codeSegments": [
                        {
                            "line": 22,
                            "code": "def scrape_season_stats(year):"
                        },
                        {
                            "line": 26,
                            "code": "df_reg = pd.read_html(base_url_reg, header=0)[0]"
                        },
                        {
                            "line": 27,
                            "code": "df_reg = df_reg[df_reg[\"Player\"] != \"Player\"]  # remove repeated header rows"
                        }
                    ],
                    "summaryComponent": "while 'scrape_season_stats' retrieves and cleans player stats for a given season"
                },
                {
                    "codeSegments": [
                        {
                            "line": 30,
                            "code": "df_reg = df_reg[\n    [\"Player\", \"Year\", \"PTS\", \"AST\", \"TRB\", \"FG%\"]\n]  # Keep only specified columns"
                        },
                        {
                            "line": 33,
                            "code": "df_reg = df_reg.dropna(\n    subset=[\"PTS\", \"AST\", \"TRB\", \"FG%\"]\n)  # Ensure key stats aren't invalid"
                        }
                    ],
                    "summaryComponent": "retaining only key columns and valid rows"
                },
                {
                    "codeSegments": [
                        {
                            "line": 39,
                            "code": "def scrape_multiple_seasons(start_year=2018, end_year=2025):"
                        },
                        {
                            "line": 41,
                            "code": "for year in range(start_year, end_year + 1):"
                        },
                        {
                            "line": 42,
                            "code": "df = scrape_season_stats(year)"
                        },
                        {
                            "line": 43,
                            "code": "all_stats.append(df)"
                        },
                        {
                            "line": 44,
                            "code": "return pd.concat(all_stats)"
                        }
                    ],
                    "summaryComponent": "The 'scrape_multiple_seasons' function aggregates stats across all specified years"
                },
                {
                    "codeSegments": [
                        {
                            "line": 47,
                            "code": "if __name__ == \"__main__\":"
                        },
                        {
                            "line": 48,
                            "code": "if not os.path.exists(\"data\"):"
                        },
                        {
                            "line": 49,
                            "code": "os.makedirs(\"data\")"
                        }
                    ],
                    "summaryComponent": "When run as a script, it ensures a 'data' directory exists"
                },
                {
                    "codeSegments": [
                        {
                            "line": 52,
                            "code": "mvp_df = scrape_mvp_votes()"
                        },
                        {
                            "line": 53,
                            "code": "mvp_df.to_csv(\"data/mvp_votes.csv\", index=False)"
                        },
                        {
                            "line": 56,
                            "code": "stats_df = scrape_multiple_seasons()"
                        },
                        {
                            "line": 57,
                            "code": "stats_df.to_csv(\"data/season_stats.csv\", index=False)"
                        }
                    ],
                    "summaryComponent": "scrapes both MVP and player stats, and saves them as CSV files"
                },
                {
                    "codeSegments": [
                        {
                            "line": 14,
                            "code": "except:"
                        },
                        {
                            "line": 15,
                            "code": "print(f\"Could not parse year {year}\")"
                        },
                        {
                            "line": 51,
                            "code": "print(\"Scraping MVP votes...\")"
                        },
                        {
                            "line": 55,
                            "code": "print(\"Scraping player stats...\")"
                        }
                    ],
                    "summaryComponent": "handling missing data gracefully and providing progress output"
                }
            ]
        },
        "event": "map_summary_code",
        "id": "MxCSzmA39BeENUXRghcl"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:10:20.000",
        "data": {
            "detail_level": "medium",
            "section_id": "95822364-a873-4e0e-960e-c1e8aeb35a12",
            "structured_type": "unstructured",
            "mapping_index": 0
        },
        "event": "mapping_hover",
        "id": "YeMXWG6hSfL2gFxMkGWF"
    },
    {
        "source": "backend",
        "timestamp": "2025-08-23 14:10:20.000",
        "data": {
            "summary": "• Imports pandas and os modules for data handling and file operations\n• Defines scraping functions:\n  ◦ scrape_mvp_votes: Loops through years, fetches MVP voting tables, renames columns, and aggregates results\n  ◦ scrape_season_stats: Retrieves per-game player stats for a year, cleans data, and selects key columns (Player, Year, PTS, AST, TRB, FG%)\n  ◦ scrape_multiple_seasons: Aggregates player stats across multiple years using scrape_season_stats\n• Main script logic:\n  ◦ Checks for and creates a 'data' directory if needed\n  ◦ Scrapes MVP votes and saves to 'data/mvp_votes.csv'\n  ◦ Scrapes player stats across seasons and saves to 'data/season_stats.csv'\n  ◦ Prints progress messages to the console\n• Handles missing or unparsable data gracefully during scraping",
            "code": "1: import pandas as pd\n2: import os\n3: \n4: \n5: def scrape_mvp_votes(start_year=2018, end_year=2025):\n6:     all_votes = []\n7:     for year in range(start_year, end_year + 1):\n8:         url = f\"https://www.basketball-reference.com/awards/awards_{year}.html\"\n9:         tables = pd.read_html(url, header=1)\n10:         try:\n11:             mvp_table = tables[0]  # MVP table is the first table\n12:             mvp_table[\"Year\"] = year\n13:             all_votes.append(mvp_table)\n14:         except:\n15:             print(f\"Could not parse year {year}\")\n16: \n17:     df = pd.concat(all_votes)\n18:     df = df.rename(columns={\"Player\": \"Name\", \"Pts Won\": \"MVP_Points\"})\n19:     return df[[\"Year\", \"Name\", \"MVP_Points\"]]\n20: \n21: \n22: def scrape_season_stats(year):\n23:     base_url_reg = (\n24:         f\"https://www.basketball-reference.com/leagues/NBA_{year}_per_game.html\"\n25:     )\n26:     df_reg = pd.read_html(base_url_reg, header=0)[0]\n27:     df_reg = df_reg[df_reg[\"Player\"] != \"Player\"]  # remove repeated header rows\n28:     df_reg[\"Year\"] = year\n29: \n30:     df_reg = df_reg[\n31:         [\"Player\", \"Year\", \"PTS\", \"AST\", \"TRB\", \"FG%\"]\n32:     ]  # Keep only specified columns\n33:     df_reg = df_reg.dropna(\n34:         subset=[\"PTS\", \"AST\", \"TRB\", \"FG%\"]\n35:     )  # Ensure key stats aren't invalid\n36:     return df_reg\n37: \n38: \n39: def scrape_multiple_seasons(start_year=2018, end_year=2025):\n40:     all_stats = []\n41:     for year in range(start_year, end_year + 1):\n42:         df = scrape_season_stats(year)\n43:         all_stats.append(df)\n44:     return pd.concat(all_stats)\n45: \n46: \n47: if __name__ == \"__main__\":\n48:     if not os.path.exists(\"data\"):\n49:         os.makedirs(\"data\")\n50: \n51:     print(\"Scraping MVP votes...\")\n52:     mvp_df = scrape_mvp_votes()\n53:     mvp_df.to_csv(\"data/mvp_votes.csv\", index=False)\n54: \n55:     print(\"Scraping player stats...\")\n56:     stats_df = scrape_multiple_seasons()\n57:     stats_df.to_csv(\"data/season_stats.csv\", index=False)\n58: ",
            "mapping": [
                {
                    "codeSegments": [
                        {
                            "line": 1,
                            "code": "import pandas as pd"
                        },
                        {
                            "line": 2,
                            "code": "import os"
                        }
                    ],
                    "summaryComponent": "Imports pandas and os modules for data handling and file operations"
                },
                {
                    "codeSegments": [
                        {
                            "line": 5,
                            "code": "def scrape_mvp_votes(start_year=2018, end_year=2025):"
                        },
                        {
                            "line": 22,
                            "code": "def scrape_season_stats(year):"
                        },
                        {
                            "line": 39,
                            "code": "def scrape_multiple_seasons(start_year=2018, end_year=2025):"
                        }
                    ],
                    "summaryComponent": "Defines scraping functions:"
                },
                {
                    "codeSegments": [
                        {
                            "line": 7,
                            "code": "for year in range(start_year, end_year + 1):"
                        },
                        {
                            "line": 8,
                            "code": "url = f\"https://www.basketball-reference.com/awards/awards_{year}.html\""
                        },
                        {
                            "line": 9,
                            "code": "tables = pd.read_html(url, header=1)"
                        },
                        {
                            "line": 11,
                            "code": "mvp_table = tables[0]  # MVP table is the first table"
                        },
                        {
                            "line": 12,
                            "code": "mvp_table[\"Year\"] = year"
                        },
                        {
                            "line": 13,
                            "code": "all_votes.append(mvp_table)"
                        },
                        {
                            "line": 17,
                            "code": "df = pd.concat(all_votes)"
                        },
                        {
                            "line": 18,
                            "code": "df = df.rename(columns={\"Player\": \"Name\", \"Pts Won\": \"MVP_Points\"})"
                        }
                    ],
                    "summaryComponent": "scrape_mvp_votes: Loops through years, fetches MVP voting tables, renames columns, and aggregates results"
                },
                {
                    "codeSegments": [
                        {
                            "line": 26,
                            "code": "df_reg = pd.read_html(base_url_reg, header=0)[0]"
                        },
                        {
                            "line": 27,
                            "code": "df_reg = df_reg[df_reg[\"Player\"] != \"Player\"]  # remove repeated header rows"
                        },
                        {
                            "line": 28,
                            "code": "df_reg[\"Year\"] = year"
                        },
                        {
                            "line": 30,
                            "code": "df_reg = df_reg[\n    [\"Player\", \"Year\", \"PTS\", \"AST\", \"TRB\", \"FG%\"]\n]"
                        },
                        {
                            "line": 33,
                            "code": "df_reg = df_reg.dropna(\n    subset=[\"PTS\", \"AST\", \"TRB\", \"FG%\"]\n)"
                        }
                    ],
                    "summaryComponent": "scrape_season_stats: Retrieves per-game player stats for a year, cleans data, and selects key columns (Player, Year, PTS, AST, TRB, FG%)"
                },
                {
                    "codeSegments": [
                        {
                            "line": 41,
                            "code": "for year in range(start_year, end_year + 1):"
                        },
                        {
                            "line": 42,
                            "code": "df = scrape_season_stats(year)"
                        },
                        {
                            "line": 43,
                            "code": "all_stats.append(df)"
                        },
                        {
                            "line": 44,
                            "code": "return pd.concat(all_stats)"
                        }
                    ],
                    "summaryComponent": "scrape_multiple_seasons: Aggregates player stats across multiple years using scrape_season_stats"
                },
                {
                    "codeSegments": [
                        {
                            "line": 47,
                            "code": "if __name__ == \"__main__\":"
                        }
                    ],
                    "summaryComponent": "Main script logic:"
                },
                {
                    "codeSegments": [
                        {
                            "line": 48,
                            "code": "if not os.path.exists(\"data\"):"
                        },
                        {
                            "line": 49,
                            "code": "os.makedirs(\"data\")"
                        }
                    ],
                    "summaryComponent": "Checks for and creates a 'data' directory if needed"
                },
                {
                    "codeSegments": [
                        {
                            "line": 52,
                            "code": "mvp_df = scrape_mvp_votes()"
                        },
                        {
                            "line": 53,
                            "code": "mvp_df.to_csv(\"data/mvp_votes.csv\", index=False)"
                        }
                    ],
                    "summaryComponent": "Scrapes MVP votes and saves to 'data/mvp_votes.csv'"
                },
                {
                    "codeSegments": [
                        {
                            "line": 56,
                            "code": "stats_df = scrape_multiple_seasons()"
                        },
                        {
                            "line": 57,
                            "code": "stats_df.to_csv(\"data/season_stats.csv\", index=False)"
                        }
                    ],
                    "summaryComponent": "Scrapes player stats across seasons and saves to 'data/season_stats.csv'"
                },
                {
                    "codeSegments": [
                        {
                            "line": 51,
                            "code": "print(\"Scraping MVP votes...\")"
                        },
                        {
                            "line": 55,
                            "code": "print(\"Scraping player stats...\")"
                        }
                    ],
                    "summaryComponent": "Prints progress messages to the console"
                },
                {
                    "codeSegments": [
                        {
                            "line": 14,
                            "code": "except:"
                        },
                        {
                            "line": 15,
                            "code": "print(f\"Could not parse year {year}\")"
                        }
                    ],
                    "summaryComponent": "Handles missing or unparsable data gracefully during scraping"
                }
            ]
        },
        "event": "map_summary_code",
        "id": "Z9w1PB8ZbfPCiJiHvZ0F"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:10:21.000",
        "data": {
            "detail_level": "medium",
            "section_id": "95822364-a873-4e0e-960e-c1e8aeb35a12",
            "structured_type": "unstructured",
            "mapping_index": 1
        },
        "event": "mapping_hover",
        "id": "3qpuC4W0pdTIo989MewY"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:10:21.000",
        "data": {
            "detail_level": "medium",
            "section_id": "95822364-a873-4e0e-960e-c1e8aeb35a12",
            "structured_type": "unstructured"
        },
        "event": "mapping_unhover",
        "id": "Lb333INsAW5HOd3qhFuI"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:10:21.000",
        "data": {
            "detail_level": "medium",
            "section_id": "95822364-a873-4e0e-960e-c1e8aeb35a12",
            "structured_type": "unstructured"
        },
        "event": "mapping_unhover",
        "id": "PWYQ8jhcfYRsd4CVakSD"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:10:21.000",
        "data": {
            "detail_level": "medium",
            "section_id": "95822364-a873-4e0e-960e-c1e8aeb35a12",
            "structured_type": "unstructured"
        },
        "event": "mapping_unhover",
        "id": "cf84MupZrK3FvzQPrefb"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:10:21.000",
        "data": {
            "detail_level": "medium",
            "section_id": "95822364-a873-4e0e-960e-c1e8aeb35a12",
            "structured_type": "unstructured",
            "mapping_index": 3
        },
        "event": "mapping_hover",
        "id": "gbmE4aDmknqMR0Ac0qBG"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:10:21.000",
        "data": {
            "detail_level": "medium",
            "section_id": "95822364-a873-4e0e-960e-c1e8aeb35a12",
            "structured_type": "unstructured",
            "mapping_index": 7
        },
        "event": "mapping_hover",
        "id": "htMyBLvp4r7ztHsF7rDd"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:10:21.000",
        "data": {
            "detail_level": "medium",
            "section_id": "95822364-a873-4e0e-960e-c1e8aeb35a12",
            "structured_type": "unstructured"
        },
        "event": "mapping_unhover",
        "id": "yIiVi3X1xm19xMQbmxfB"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:10:22.000",
        "data": {
            "detail_level": "medium",
            "section_id": "95822364-a873-4e0e-960e-c1e8aeb35a12",
            "structured_type": "unstructured",
            "mapping_index": 7
        },
        "event": "mapping_hover",
        "id": "HYg1ATZ4ixrih052gd4t"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:10:22.000",
        "data": {
            "detail_level": "medium",
            "section_id": "95822364-a873-4e0e-960e-c1e8aeb35a12",
            "structured_type": "unstructured"
        },
        "event": "mapping_unhover",
        "id": "Hk6ouFWUZtm37SD7pVTm"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:10:22.000",
        "data": {
            "detail_level": "medium",
            "section_id": "95822364-a873-4e0e-960e-c1e8aeb35a12",
            "structured_type": "unstructured"
        },
        "event": "mapping_unhover",
        "id": "QEHckpU4sEip5uKpWnPV"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:10:22.000",
        "data": {
            "detail_level": "medium",
            "section_id": "95822364-a873-4e0e-960e-c1e8aeb35a12",
            "structured_type": "unstructured"
        },
        "event": "mapping_unhover",
        "id": "QdXsyv5p4JVAcLLUHcnG"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:10:22.000",
        "data": {
            "detail_level": "medium",
            "section_id": "95822364-a873-4e0e-960e-c1e8aeb35a12",
            "structured_type": "unstructured"
        },
        "event": "mapping_unhover",
        "id": "QqwJoMtl3198WOK3F4zE"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:10:22.000",
        "data": {
            "detail_level": "medium",
            "section_id": "95822364-a873-4e0e-960e-c1e8aeb35a12",
            "structured_type": "unstructured",
            "mapping_index": 0
        },
        "event": "mapping_hover",
        "id": "cEjC5ZfPN1qPxXBdYzLe"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:10:22.000",
        "data": {
            "detail_level": "medium",
            "section_id": "95822364-a873-4e0e-960e-c1e8aeb35a12",
            "structured_type": "unstructured",
            "mapping_index": 5
        },
        "event": "mapping_hover",
        "id": "dZARamnJ7ibsBDXDrIYj"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:10:22.000",
        "data": {
            "detail_level": "medium",
            "section_id": "95822364-a873-4e0e-960e-c1e8aeb35a12",
            "structured_type": "unstructured",
            "mapping_index": 3
        },
        "event": "mapping_hover",
        "id": "g05nZPdA9srxr7pLLWG0"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:10:23.000",
        "data": {
            "before_detail_level": "medium",
            "before_structured": "unstructured",
            "section_id": "95822364-a873-4e0e-960e-c1e8aeb35a12",
            "after_detail_level": "medium",
            "after_structured": "structured"
        },
        "event": "change_summary_level",
        "id": "Mo1JEnG0VRRa8lEXrDns"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:10:23.000",
        "data": {
            "before_detail_level": "medium",
            "before_structured": "structured",
            "section_id": "95822364-a873-4e0e-960e-c1e8aeb35a12",
            "after_detail_level": "high",
            "after_structured": "structured"
        },
        "event": "change_summary_level",
        "id": "iGNo3hORJxM0s0IrAr7P"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:10:24.000",
        "data": {
            "detail_level": "high",
            "section_id": "95822364-a873-4e0e-960e-c1e8aeb35a12",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "1E7iJseFyLurZMp3RPuk"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:10:24.000",
        "data": {
            "detail_level": "high",
            "section_id": "95822364-a873-4e0e-960e-c1e8aeb35a12",
            "structured_type": "structured",
            "mapping_index": 3
        },
        "event": "mapping_hover",
        "id": "48ZnsNQhWGFVW5EfPOFm"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:10:24.000",
        "data": {
            "detail_level": "high",
            "section_id": "95822364-a873-4e0e-960e-c1e8aeb35a12",
            "structured_type": "structured",
            "mapping_index": 0
        },
        "event": "mapping_hover",
        "id": "IYfbg0kGiq1Z4NFi9HrA"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:10:24.000",
        "data": {
            "detail_level": "high",
            "section_id": "95822364-a873-4e0e-960e-c1e8aeb35a12",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "J02NIiEybyNe0xXk5P6x"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:10:24.000",
        "data": {
            "detail_level": "high",
            "section_id": "95822364-a873-4e0e-960e-c1e8aeb35a12",
            "structured_type": "structured",
            "mapping_index": 2
        },
        "event": "mapping_hover",
        "id": "JUprtfhiBp8oju2osL1w"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:10:24.000",
        "data": {
            "detail_level": "high",
            "section_id": "95822364-a873-4e0e-960e-c1e8aeb35a12",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "cOkQ7ajXa9HW6Madrh2J"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:10:33.000",
        "data": {},
        "event": "click_summarize_code",
        "id": "2ye9ACKC0ho1YIQNxnrZ"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:10:33.000",
        "data": {
            "detail_level": "high",
            "section_id": "95822364-a873-4e0e-960e-c1e8aeb35a12",
            "structured_type": "structured",
            "mapping_index": 0
        },
        "event": "mapping_hover",
        "id": "PxGQWbjNA2ul2LEGiWC6"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:10:33.000",
        "data": {
            "detail_level": "high",
            "section_id": "95822364-a873-4e0e-960e-c1e8aeb35a12",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "afPrNyt8dQ0F6aWB5bFs"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:10:34.000",
        "data": {
            "detail_level": "high",
            "section_id": "95822364-a873-4e0e-960e-c1e8aeb35a12",
            "structured_type": "structured",
            "mapping_index": 2
        },
        "event": "mapping_hover",
        "id": "fQ4BHvwxqkiXQ3G6HNLW"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:10:35.000",
        "data": {
            "detail_level": "high",
            "section_id": "95822364-a873-4e0e-960e-c1e8aeb35a12",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "4AwZTG6UUVNV2UqS2jOQ"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:10:35.000",
        "data": {
            "detail_level": "high",
            "section_id": "95822364-a873-4e0e-960e-c1e8aeb35a12",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "9dNmlTGpBvl8rixaJArb"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:10:35.000",
        "data": {
            "detail_level": "high",
            "section_id": "95822364-a873-4e0e-960e-c1e8aeb35a12",
            "structured_type": "structured",
            "mapping_index": 1
        },
        "event": "mapping_hover",
        "id": "Gkp1Rm55aoMx4TxXXNm0"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:10:35.000",
        "data": {
            "detail_level": "high",
            "section_id": "95822364-a873-4e0e-960e-c1e8aeb35a12",
            "structured_type": "structured",
            "mapping_index": 0
        },
        "event": "mapping_hover",
        "id": "crhSptFV6Skch17rFJch"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:10:35.000",
        "data": {
            "detail_level": "high",
            "section_id": "95822364-a873-4e0e-960e-c1e8aeb35a12",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "y0IWTILooAlM5osRl6QY"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:10:37.000",
        "data": {
            "after_section_id": null,
            "before_section_id": "95822364-a873-4e0e-960e-c1e8aeb35a12"
        },
        "event": "toggle_section",
        "id": "Op3g4dFFrq4NJiZfGSSn"
    },
    {
        "source": "backend",
        "timestamp": "2025-08-23 14:10:39.000",
        "data": {
            "summary": {
                "high_unstructured": "The scrape_season_stats function downloads NBA per-game player statistics for a specified season from basketball-reference.com using pandas' read_html. It processes the resulting DataFrame by removing any repeated header rows, adds a 'Year' column to indicate the season, and selects only the columns for player name, year, points, assists, rebounds, and field goal percentage. To ensure data quality, it drops any rows where these key statistics are missing. The function finally returns the cleaned and filtered DataFrame containing the relevant player stats for the given year.",
                "low_structured": "• Scrapes NBA per-game stats for a specified year\n• Filters and cleans the data\n• Returns selected player statistics",
                "high_structured": "• Downloads NBA per-game player statistics for a specified year from basketball-reference.com\n• Processes the DataFrame:\n  ◦ Removes rows where the 'Player' column contains the string 'Player' (eliminating repeated headers)\n  ◦ Adds a 'Year' column to indicate the season\n• Selects only the following columns:\n  ◦ Player\n  ◦ Year\n  ◦ PTS (points per game)\n  ◦ AST (assists per game)\n  ◦ TRB (rebounds per game)\n  ◦ FG% (field goal percentage)\n• Drops any rows with missing values in the selected stat columns to ensure data integrity\n• Returns the cleaned DataFrame containing only the relevant statistics for each player in the specified year",
                "title": "Summary of scrape_season_stats Function",
                "medium_unstructured": "The scrape_season_stats function retrieves NBA per-game player statistics for a specified year from basketball-reference.com. It cleans the data by removing repeated header rows and keeps only relevant columns like player name, year, points, assists, rebounds, and field goal percentage. The function also ensures that rows with missing key stats are excluded before returning the processed DataFrame.",
                "medium_structured": "• Fetches NBA per-game stats for a given year from basketball-reference.com\n• Cleans the data:\n  ◦ Removes repeated header rows\n  ◦ Adds a 'Year' column\n• Selects only key columns: Player, Year, PTS, AST, TRB, FG%\n• Drops rows with missing values in these columns\n• Returns the cleaned DataFrame",
                "low_unstructured": "This function scrapes and processes NBA per-game player statistics for a given year."
            },
            "selected_code": "def scrape_season_stats(year):\n    base_url_reg = (\n        f\"https://www.basketball-reference.com/leagues/NBA_{year}_per_game.html\"\n    )\n    df_reg = pd.read_html(base_url_reg, header=0)[0]\n    df_reg = df_reg[df_reg[\"Player\"] != \"Player\"]  # remove repeated header rows\n    df_reg[\"Year\"] = year\n\n    df_reg = df_reg[\n        [\"Player\", \"Year\", \"PTS\", \"AST\", \"TRB\", \"FG%\"]\n    ]  # Keep only specified columns\n    df_reg = df_reg.dropna(\n        subset=[\"PTS\", \"AST\", \"TRB\", \"FG%\"]\n    )  # Ensure key stats aren't invalid\n    return df_reg"
        },
        "event": "summarize_selected_code",
        "id": "a7Aabglxjj0gq1PovBUZ"
    },
    {
        "source": "backend",
        "timestamp": "2025-08-23 14:10:42.000",
        "data": {
            "summary": "The scrape_season_stats function retrieves NBA per-game player statistics for a specified year from basketball-reference.com. It cleans the data by removing repeated header rows and keeps only relevant columns like player name, year, points, assists, rebounds, and field goal percentage. The function also ensures that rows with missing key stats are excluded before returning the processed DataFrame.",
            "code": "22: def scrape_season_stats(year):\n23:     base_url_reg = (\n24:         f\"https://www.basketball-reference.com/leagues/NBA_{year}_per_game.html\"\n25:     )\n26:     df_reg = pd.read_html(base_url_reg, header=0)[0]\n27:     df_reg = df_reg[df_reg[\"Player\"] != \"Player\"]  # remove repeated header rows\n28:     df_reg[\"Year\"] = year\n29: \n30:     df_reg = df_reg[\n31:         [\"Player\", \"Year\", \"PTS\", \"AST\", \"TRB\", \"FG%\"]\n32:     ]  # Keep only specified columns\n33:     df_reg = df_reg.dropna(\n34:         subset=[\"PTS\", \"AST\", \"TRB\", \"FG%\"]\n35:     )  # Ensure key stats aren't invalid\n36:     return df_reg",
            "mapping": [
                {
                    "codeSegments": [
                        {
                            "line": 22,
                            "code": "def scrape_season_stats(year):"
                        }
                    ],
                    "summaryComponent": "The scrape_season_stats function"
                },
                {
                    "codeSegments": [
                        {
                            "line": 23,
                            "code": "base_url_reg = ("
                        },
                        {
                            "line": 24,
                            "code": "f\"https://www.basketball-reference.com/leagues/NBA_{year}_per_game.html\""
                        },
                        {
                            "line": 26,
                            "code": "df_reg = pd.read_html(base_url_reg, header=0)[0]"
                        }
                    ],
                    "summaryComponent": "retrieves NBA per-game player statistics for a specified year"
                },
                {
                    "codeSegments": [
                        {
                            "line": 24,
                            "code": "f\"https://www.basketball-reference.com/leagues/NBA_{year}_per_game.html\""
                        }
                    ],
                    "summaryComponent": "from basketball-reference.com"
                },
                {
                    "codeSegments": [
                        {
                            "line": 27,
                            "code": "df_reg = df_reg[df_reg[\"Player\"] != \"Player\"]  # remove repeated header rows"
                        }
                    ],
                    "summaryComponent": "It cleans the data by removing repeated header rows"
                },
                {
                    "codeSegments": [
                        {
                            "line": 30,
                            "code": "df_reg = df_reg["
                        },
                        {
                            "line": 31,
                            "code": "[\"Player\", \"Year\", \"PTS\", \"AST\", \"TRB\", \"FG%\"]"
                        }
                    ],
                    "summaryComponent": "keeps only relevant columns like player name, year, points, assists, rebounds, and field goal percentage"
                },
                {
                    "codeSegments": [
                        {
                            "line": 33,
                            "code": "df_reg = df_reg.dropna("
                        },
                        {
                            "line": 34,
                            "code": "subset=[\"PTS\", \"AST\", \"TRB\", \"FG%\"]"
                        }
                    ],
                    "summaryComponent": "The function also ensures that rows with missing key stats are excluded"
                },
                {
                    "codeSegments": [
                        {
                            "line": 36,
                            "code": "return df_reg"
                        }
                    ],
                    "summaryComponent": "before returning the processed DataFrame."
                }
            ]
        },
        "event": "map_summary_code",
        "id": "BOgMNDcbtw207X7on6KL"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:10:42.000",
        "data": {},
        "event": "click_summarize_code",
        "id": "NUMrTGlVIhLLTQMWHBcl"
    },
    {
        "source": "backend",
        "timestamp": "2025-08-23 14:10:42.000",
        "data": {
            "summary": "• Fetches NBA per-game stats for a given year from basketball-reference.com\n• Cleans the data:\n  ◦ Removes repeated header rows\n  ◦ Adds a 'Year' column\n• Selects only key columns: Player, Year, PTS, AST, TRB, FG%\n• Drops rows with missing values in these columns\n• Returns the cleaned DataFrame",
            "code": "22: def scrape_season_stats(year):\n23:     base_url_reg = (\n24:         f\"https://www.basketball-reference.com/leagues/NBA_{year}_per_game.html\"\n25:     )\n26:     df_reg = pd.read_html(base_url_reg, header=0)[0]\n27:     df_reg = df_reg[df_reg[\"Player\"] != \"Player\"]  # remove repeated header rows\n28:     df_reg[\"Year\"] = year\n29: \n30:     df_reg = df_reg[\n31:         [\"Player\", \"Year\", \"PTS\", \"AST\", \"TRB\", \"FG%\"]\n32:     ]  # Keep only specified columns\n33:     df_reg = df_reg.dropna(\n34:         subset=[\"PTS\", \"AST\", \"TRB\", \"FG%\"]\n35:     )  # Ensure key stats aren't invalid\n36:     return df_reg",
            "mapping": [
                {
                    "codeSegments": [
                        {
                            "line": 23,
                            "code": "base_url_reg = (\n    f\"https://www.basketball-reference.com/leagues/NBA_{year}_per_game.html\"\n)"
                        },
                        {
                            "line": 26,
                            "code": "df_reg = pd.read_html(base_url_reg, header=0)[0]"
                        }
                    ],
                    "summaryComponent": "Fetches NBA per-game stats for a given year from basketball-reference.com"
                },
                {
                    "codeSegments": [
                        {
                            "line": 27,
                            "code": "df_reg = df_reg[df_reg[\"Player\"] != \"Player\"]  # remove repeated header rows"
                        }
                    ],
                    "summaryComponent": "Removes repeated header rows"
                },
                {
                    "codeSegments": [
                        {
                            "line": 28,
                            "code": "df_reg[\"Year\"] = year"
                        }
                    ],
                    "summaryComponent": "Adds a 'Year' column"
                },
                {
                    "codeSegments": [
                        {
                            "line": 30,
                            "code": "df_reg = df_reg[\n    [\"Player\", \"Year\", \"PTS\", \"AST\", \"TRB\", \"FG%\"]\n]"
                        }
                    ],
                    "summaryComponent": "Selects only key columns: Player, Year, PTS, AST, TRB, FG%"
                },
                {
                    "codeSegments": [
                        {
                            "line": 33,
                            "code": "df_reg = df_reg.dropna(\n    subset=[\"PTS\", \"AST\", \"TRB\", \"FG%\"]\n)"
                        }
                    ],
                    "summaryComponent": "Drops rows with missing values in these columns"
                },
                {
                    "codeSegments": [
                        {
                            "line": 36,
                            "code": "return df_reg"
                        }
                    ],
                    "summaryComponent": "Returns the cleaned DataFrame"
                }
            ]
        },
        "event": "map_summary_code",
        "id": "aXFRey3YeLygqjuAJioS"
    },
    {
        "source": "backend",
        "timestamp": "2025-08-23 14:10:43.000",
        "data": {
            "summary": "The scrape_season_stats function downloads NBA per-game player statistics for a specified season from basketball-reference.com using pandas' read_html. It processes the resulting DataFrame by removing any repeated header rows, adds a 'Year' column to indicate the season, and selects only the columns for player name, year, points, assists, rebounds, and field goal percentage. To ensure data quality, it drops any rows where these key statistics are missing. The function finally returns the cleaned and filtered DataFrame containing the relevant player stats for the given year.",
            "code": "22: def scrape_season_stats(year):\n23:     base_url_reg = (\n24:         f\"https://www.basketball-reference.com/leagues/NBA_{year}_per_game.html\"\n25:     )\n26:     df_reg = pd.read_html(base_url_reg, header=0)[0]\n27:     df_reg = df_reg[df_reg[\"Player\"] != \"Player\"]  # remove repeated header rows\n28:     df_reg[\"Year\"] = year\n29: \n30:     df_reg = df_reg[\n31:         [\"Player\", \"Year\", \"PTS\", \"AST\", \"TRB\", \"FG%\"]\n32:     ]  # Keep only specified columns\n33:     df_reg = df_reg.dropna(\n34:         subset=[\"PTS\", \"AST\", \"TRB\", \"FG%\"]\n35:     )  # Ensure key stats aren't invalid\n36:     return df_reg",
            "mapping": [
                {
                    "codeSegments": [
                        {
                            "line": 22,
                            "code": "def scrape_season_stats(year):"
                        }
                    ],
                    "summaryComponent": "The scrape_season_stats function"
                },
                {
                    "codeSegments": [
                        {
                            "line": 23,
                            "code": "base_url_reg = ("
                        },
                        {
                            "line": 24,
                            "code": "f\"https://www.basketball-reference.com/leagues/NBA_{year}_per_game.html\""
                        },
                        {
                            "line": 26,
                            "code": "df_reg = pd.read_html(base_url_reg, header=0)[0]"
                        }
                    ],
                    "summaryComponent": "downloads NBA per-game player statistics for a specified season from basketball-reference.com"
                },
                {
                    "codeSegments": [
                        {
                            "line": 26,
                            "code": "pd.read_html(base_url_reg, header=0)[0]"
                        }
                    ],
                    "summaryComponent": "using pandas' read_html"
                },
                {
                    "codeSegments": [
                        {
                            "line": 27,
                            "code": "df_reg = df_reg[df_reg[\"Player\"] != \"Player\"]  # remove repeated header rows"
                        }
                    ],
                    "summaryComponent": "It processes the resulting DataFrame by removing any repeated header rows"
                },
                {
                    "codeSegments": [
                        {
                            "line": 28,
                            "code": "df_reg[\"Year\"] = year"
                        }
                    ],
                    "summaryComponent": "adds a 'Year' column to indicate the season"
                },
                {
                    "codeSegments": [
                        {
                            "line": 30,
                            "code": "df_reg = df_reg["
                        },
                        {
                            "line": 31,
                            "code": "[\"Player\", \"Year\", \"PTS\", \"AST\", \"TRB\", \"FG%\"]"
                        }
                    ],
                    "summaryComponent": "and selects only the columns for player name, year, points, assists, rebounds, and field goal percentage"
                },
                {
                    "codeSegments": [
                        {
                            "line": 33,
                            "code": "df_reg = df_reg.dropna("
                        },
                        {
                            "line": 34,
                            "code": "subset=[\"PTS\", \"AST\", \"TRB\", \"FG%\"]"
                        }
                    ],
                    "summaryComponent": "To ensure data quality, it drops any rows where these key statistics are missing"
                },
                {
                    "codeSegments": [
                        {
                            "line": 36,
                            "code": "return df_reg"
                        }
                    ],
                    "summaryComponent": "The function finally returns the cleaned and filtered DataFrame containing the relevant player stats for the given year."
                }
            ]
        },
        "event": "map_summary_code",
        "id": "hCR2BwE3iuhcu2jOW5aP"
    },
    {
        "source": "backend",
        "timestamp": "2025-08-23 14:10:44.000",
        "data": {
            "summary": "• Downloads NBA per-game player statistics for a specified year from basketball-reference.com\n• Processes the DataFrame:\n  ◦ Removes rows where the 'Player' column contains the string 'Player' (eliminating repeated headers)\n  ◦ Adds a 'Year' column to indicate the season\n• Selects only the following columns:\n  ◦ Player\n  ◦ Year\n  ◦ PTS (points per game)\n  ◦ AST (assists per game)\n  ◦ TRB (rebounds per game)\n  ◦ FG% (field goal percentage)\n• Drops any rows with missing values in the selected stat columns to ensure data integrity\n• Returns the cleaned DataFrame containing only the relevant statistics for each player in the specified year",
            "code": "22: def scrape_season_stats(year):\n23:     base_url_reg = (\n24:         f\"https://www.basketball-reference.com/leagues/NBA_{year}_per_game.html\"\n25:     )\n26:     df_reg = pd.read_html(base_url_reg, header=0)[0]\n27:     df_reg = df_reg[df_reg[\"Player\"] != \"Player\"]  # remove repeated header rows\n28:     df_reg[\"Year\"] = year\n29: \n30:     df_reg = df_reg[\n31:         [\"Player\", \"Year\", \"PTS\", \"AST\", \"TRB\", \"FG%\"]\n32:     ]  # Keep only specified columns\n33:     df_reg = df_reg.dropna(\n34:         subset=[\"PTS\", \"AST\", \"TRB\", \"FG%\"]\n35:     )  # Ensure key stats aren't invalid\n36:     return df_reg",
            "mapping": [
                {
                    "codeSegments": [
                        {
                            "line": 23,
                            "code": "base_url_reg = (\n    f\"https://www.basketball-reference.com/leagues/NBA_{year}_per_game.html\"\n)"
                        },
                        {
                            "line": 26,
                            "code": "df_reg = pd.read_html(base_url_reg, header=0)[0]"
                        }
                    ],
                    "summaryComponent": "Downloads NBA per-game player statistics for a specified year from basketball-reference.com"
                },
                {
                    "codeSegments": [
                        {
                            "line": 27,
                            "code": "df_reg = df_reg[df_reg[\"Player\"] != \"Player\"]  # remove repeated header rows"
                        }
                    ],
                    "summaryComponent": "Removes rows where the 'Player' column contains the string 'Player' (eliminating repeated headers)"
                },
                {
                    "codeSegments": [
                        {
                            "line": 28,
                            "code": "df_reg[\"Year\"] = year"
                        }
                    ],
                    "summaryComponent": "Adds a 'Year' column to indicate the season"
                },
                {
                    "codeSegments": [
                        {
                            "line": 30,
                            "code": "df_reg = df_reg[\n    [\"Player\", \"Year\", \"PTS\", \"AST\", \"TRB\", \"FG%\"]\n]"
                        }
                    ],
                    "summaryComponent": "Selects only the following columns:"
                },
                {
                    "codeSegments": [
                        {
                            "line": 31,
                            "code": "\"Player\""
                        }
                    ],
                    "summaryComponent": "Player"
                },
                {
                    "codeSegments": [
                        {
                            "line": 31,
                            "code": "\"Year\""
                        }
                    ],
                    "summaryComponent": "Year"
                },
                {
                    "codeSegments": [
                        {
                            "line": 31,
                            "code": "\"PTS\""
                        }
                    ],
                    "summaryComponent": "PTS (points per game)"
                },
                {
                    "codeSegments": [
                        {
                            "line": 31,
                            "code": "\"AST\""
                        }
                    ],
                    "summaryComponent": "AST (assists per game)"
                },
                {
                    "codeSegments": [
                        {
                            "line": 31,
                            "code": "\"TRB\""
                        }
                    ],
                    "summaryComponent": "TRB (rebounds per game)"
                },
                {
                    "codeSegments": [
                        {
                            "line": 31,
                            "code": "\"FG%\""
                        }
                    ],
                    "summaryComponent": "FG% (field goal percentage)"
                },
                {
                    "codeSegments": [
                        {
                            "line": 33,
                            "code": "df_reg = df_reg.dropna(\n    subset=[\"PTS\", \"AST\", \"TRB\", \"FG%\"]\n)"
                        }
                    ],
                    "summaryComponent": "Drops any rows with missing values in the selected stat columns to ensure data integrity"
                },
                {
                    "codeSegments": [
                        {
                            "line": 36,
                            "code": "return df_reg"
                        }
                    ],
                    "summaryComponent": "Returns the cleaned DataFrame containing only the relevant statistics for each player in the specified year"
                }
            ]
        },
        "event": "map_summary_code",
        "id": "FXRLPBWI4YFJr2aAAn8z"
    },
    {
        "source": "backend",
        "timestamp": "2025-08-23 14:10:46.000",
        "data": {
            "summary": "• Scrapes NBA per-game stats for a specified year\n• Filters and cleans the data\n• Returns selected player statistics",
            "code": "22: def scrape_season_stats(year):\n23:     base_url_reg = (\n24:         f\"https://www.basketball-reference.com/leagues/NBA_{year}_per_game.html\"\n25:     )\n26:     df_reg = pd.read_html(base_url_reg, header=0)[0]\n27:     df_reg = df_reg[df_reg[\"Player\"] != \"Player\"]  # remove repeated header rows\n28:     df_reg[\"Year\"] = year\n29: \n30:     df_reg = df_reg[\n31:         [\"Player\", \"Year\", \"PTS\", \"AST\", \"TRB\", \"FG%\"]\n32:     ]  # Keep only specified columns\n33:     df_reg = df_reg.dropna(\n34:         subset=[\"PTS\", \"AST\", \"TRB\", \"FG%\"]\n35:     )  # Ensure key stats aren't invalid\n36:     return df_reg",
            "mapping": [
                {
                    "codeSegments": [
                        {
                            "line": 22,
                            "code": "def scrape_season_stats(year):"
                        },
                        {
                            "line": 23,
                            "code": "base_url_reg = ("
                        },
                        {
                            "line": 24,
                            "code": "f\"https://www.basketball-reference.com/leagues/NBA_{year}_per_game.html\""
                        },
                        {
                            "line": 26,
                            "code": "df_reg = pd.read_html(base_url_reg, header=0)[0]"
                        }
                    ],
                    "summaryComponent": "Scrapes NBA per-game stats for a specified year"
                },
                {
                    "codeSegments": [
                        {
                            "line": 27,
                            "code": "df_reg = df_reg[df_reg[\"Player\"] != \"Player\"]  # remove repeated header rows"
                        },
                        {
                            "line": 33,
                            "code": "df_reg = df_reg.dropna("
                        },
                        {
                            "line": 34,
                            "code": "subset=[\"PTS\", \"AST\", \"TRB\", \"FG%\"]"
                        }
                    ],
                    "summaryComponent": "Filters and cleans the data"
                },
                {
                    "codeSegments": [
                        {
                            "line": 30,
                            "code": "df_reg = df_reg["
                        },
                        {
                            "line": 31,
                            "code": "[\"Player\", \"Year\", \"PTS\", \"AST\", \"TRB\", \"FG%\"]"
                        },
                        {
                            "line": 36,
                            "code": "return df_reg"
                        }
                    ],
                    "summaryComponent": "Returns selected player statistics"
                }
            ]
        },
        "event": "map_summary_code",
        "id": "vjH54EUgNeprWiZlTAfL"
    },
    {
        "source": "backend",
        "timestamp": "2025-08-23 14:10:48.000",
        "data": {
            "summary": {
                "high_unstructured": "The scrape_season_stats function fetches per-game NBA player statistics for a specific year from Basketball Reference by constructing the appropriate URL and reading the first table from the page. It removes any repeated header rows that may appear in the data, adds a 'Year' column, and selects only the columns for player name, year, points, assists, rebounds, and field goal percentage. The function further ensures data quality by dropping any rows with missing values in the key statistical columns. The resulting DataFrame is returned for further analysis or storage.",
                "low_structured": "• Fetches NBA per-game stats for a specified year\n• Cleans and filters the data\n• Returns selected player statistics",
                "high_structured": "• Constructs the URL for the NBA per-game stats page for the specified year\n• Reads the first table from the page using pandas\n• Cleans the data:\n  ◦ Removes rows where the 'Player' column is a repeated header\n  ◦ Adds a 'Year' column with the specified year\n• Selects only the relevant columns:\n  ◦ Player, Year, PTS, AST, TRB, FG%\n• Drops rows with missing values in any of the key stat columns\n• Returns the cleaned and filtered DataFrame for further use",
                "title": "Summary of scrape_season_stats Function",
                "medium_unstructured": "The scrape_season_stats function downloads NBA per-game statistics for a specified year from Basketball Reference. It cleans the data by removing duplicate header rows and keeps only relevant columns for each player. The function returns a DataFrame containing player names, year, and key stats like points, assists, rebounds, and field goal percentage.",
                "medium_structured": "• Downloads per-game NBA stats for a given year from Basketball Reference\n• Removes repeated header rows from the data\n• Keeps only the columns: Player, Year, PTS, AST, TRB, and FG%\n• Drops rows with missing values in key stat columns\n• Returns the cleaned DataFrame",
                "low_unstructured": "This function retrieves and processes NBA player per-game statistics for a given year."
            },
            "selected_code": "def scrape_season_stats(year):\n    base_url_reg = (\n        f\"https://www.basketball-reference.com/leagues/NBA_{year}_per_game.html\"\n    )\n    df_reg = pd.read_html(base_url_reg, header=0)[0]\n    df_reg = df_reg[df_reg[\"Player\"] != \"Player\"]  # remove repeated header rows\n    df_reg[\"Year\"] = year\n\n    df_reg = df_reg[\n        [\"Player\", \"Year\", \"PTS\", \"AST\", \"TRB\", \"FG%\"]\n    ]  # Keep only specified columns\n    df_reg = df_reg.dropna(\n        subset=[\"PTS\", \"AST\", \"TRB\", \"FG%\"]\n    )  # Ensure key stats aren't invalid\n    return df_reg"
        },
        "event": "summarize_selected_code",
        "id": "XmTDSHM1CmNQWncIJFfT"
    },
    {
        "source": "backend",
        "timestamp": "2025-08-23 14:10:50.000",
        "data": {
            "summary": "• Downloads per-game NBA stats for a given year from Basketball Reference\n• Removes repeated header rows from the data\n• Keeps only the columns: Player, Year, PTS, AST, TRB, and FG%\n• Drops rows with missing values in key stat columns\n• Returns the cleaned DataFrame",
            "code": "22: def scrape_season_stats(year):\n23:     base_url_reg = (\n24:         f\"https://www.basketball-reference.com/leagues/NBA_{year}_per_game.html\"\n25:     )\n26:     df_reg = pd.read_html(base_url_reg, header=0)[0]\n27:     df_reg = df_reg[df_reg[\"Player\"] != \"Player\"]  # remove repeated header rows\n28:     df_reg[\"Year\"] = year\n29: \n30:     df_reg = df_reg[\n31:         [\"Player\", \"Year\", \"PTS\", \"AST\", \"TRB\", \"FG%\"]\n32:     ]  # Keep only specified columns\n33:     df_reg = df_reg.dropna(\n34:         subset=[\"PTS\", \"AST\", \"TRB\", \"FG%\"]\n35:     )  # Ensure key stats aren't invalid\n36:     return df_reg",
            "mapping": [
                {
                    "codeSegments": [
                        {
                            "line": 23,
                            "code": "base_url_reg = (\n    f\"https://www.basketball-reference.com/leagues/NBA_{year}_per_game.html\"\n)"
                        },
                        {
                            "line": 26,
                            "code": "df_reg = pd.read_html(base_url_reg, header=0)[0]"
                        }
                    ],
                    "summaryComponent": "Downloads per-game NBA stats for a given year from Basketball Reference"
                },
                {
                    "codeSegments": [
                        {
                            "line": 27,
                            "code": "df_reg = df_reg[df_reg[\"Player\"] != \"Player\"]  # remove repeated header rows"
                        }
                    ],
                    "summaryComponent": "Removes repeated header rows from the data"
                },
                {
                    "codeSegments": [
                        {
                            "line": 30,
                            "code": "df_reg = df_reg[\n    [\"Player\", \"Year\", \"PTS\", \"AST\", \"TRB\", \"FG%\"]\n]"
                        }
                    ],
                    "summaryComponent": "Keeps only the columns: Player, Year, PTS, AST, TRB, and FG%"
                },
                {
                    "codeSegments": [
                        {
                            "line": 33,
                            "code": "df_reg = df_reg.dropna(\n    subset=[\"PTS\", \"AST\", \"TRB\", \"FG%\"]\n)"
                        }
                    ],
                    "summaryComponent": "Drops rows with missing values in key stat columns"
                },
                {
                    "codeSegments": [
                        {
                            "line": 36,
                            "code": "return df_reg"
                        }
                    ],
                    "summaryComponent": "Returns the cleaned DataFrame"
                }
            ]
        },
        "event": "map_summary_code",
        "id": "8tYrBff9nCKRJZQNfM0T"
    },
    {
        "source": "backend",
        "timestamp": "2025-08-23 14:10:50.000",
        "data": {
            "summary": "• Fetches NBA per-game stats for a specified year\n• Cleans and filters the data\n• Returns selected player statistics",
            "code": "22: def scrape_season_stats(year):\n23:     base_url_reg = (\n24:         f\"https://www.basketball-reference.com/leagues/NBA_{year}_per_game.html\"\n25:     )\n26:     df_reg = pd.read_html(base_url_reg, header=0)[0]\n27:     df_reg = df_reg[df_reg[\"Player\"] != \"Player\"]  # remove repeated header rows\n28:     df_reg[\"Year\"] = year\n29: \n30:     df_reg = df_reg[\n31:         [\"Player\", \"Year\", \"PTS\", \"AST\", \"TRB\", \"FG%\"]\n32:     ]  # Keep only specified columns\n33:     df_reg = df_reg.dropna(\n34:         subset=[\"PTS\", \"AST\", \"TRB\", \"FG%\"]\n35:     )  # Ensure key stats aren't invalid\n36:     return df_reg",
            "mapping": [
                {
                    "codeSegments": [
                        {
                            "line": 22,
                            "code": "def scrape_season_stats(year):"
                        },
                        {
                            "line": 23,
                            "code": "base_url_reg = ("
                        },
                        {
                            "line": 24,
                            "code": "f\"https://www.basketball-reference.com/leagues/NBA_{year}_per_game.html\""
                        },
                        {
                            "line": 26,
                            "code": "df_reg = pd.read_html(base_url_reg, header=0)[0]"
                        }
                    ],
                    "summaryComponent": "Fetches NBA per-game stats for a specified year"
                },
                {
                    "codeSegments": [
                        {
                            "line": 27,
                            "code": "df_reg = df_reg[df_reg[\"Player\"] != \"Player\"]  # remove repeated header rows"
                        },
                        {
                            "line": 28,
                            "code": "df_reg[\"Year\"] = year"
                        },
                        {
                            "line": 30,
                            "code": "df_reg = df_reg["
                        },
                        {
                            "line": 31,
                            "code": "[\"Player\", \"Year\", \"PTS\", \"AST\", \"TRB\", \"FG%\"]"
                        },
                        {
                            "line": 33,
                            "code": "df_reg = df_reg.dropna("
                        },
                        {
                            "line": 34,
                            "code": "subset=[\"PTS\", \"AST\", \"TRB\", \"FG%\"]"
                        }
                    ],
                    "summaryComponent": "Cleans and filters the data"
                },
                {
                    "codeSegments": [
                        {
                            "line": 36,
                            "code": "return df_reg"
                        }
                    ],
                    "summaryComponent": "Returns selected player statistics"
                }
            ]
        },
        "event": "map_summary_code",
        "id": "T3Z4XQMJ4ZLouEVmFMjG"
    },
    {
        "source": "backend",
        "timestamp": "2025-08-23 14:10:51.000",
        "data": {
            "summary": "• Constructs the URL for the NBA per-game stats page for the specified year\n• Reads the first table from the page using pandas\n• Cleans the data:\n  ◦ Removes rows where the 'Player' column is a repeated header\n  ◦ Adds a 'Year' column with the specified year\n• Selects only the relevant columns:\n  ◦ Player, Year, PTS, AST, TRB, FG%\n• Drops rows with missing values in any of the key stat columns\n• Returns the cleaned and filtered DataFrame for further use",
            "code": "22: def scrape_season_stats(year):\n23:     base_url_reg = (\n24:         f\"https://www.basketball-reference.com/leagues/NBA_{year}_per_game.html\"\n25:     )\n26:     df_reg = pd.read_html(base_url_reg, header=0)[0]\n27:     df_reg = df_reg[df_reg[\"Player\"] != \"Player\"]  # remove repeated header rows\n28:     df_reg[\"Year\"] = year\n29: \n30:     df_reg = df_reg[\n31:         [\"Player\", \"Year\", \"PTS\", \"AST\", \"TRB\", \"FG%\"]\n32:     ]  # Keep only specified columns\n33:     df_reg = df_reg.dropna(\n34:         subset=[\"PTS\", \"AST\", \"TRB\", \"FG%\"]\n35:     )  # Ensure key stats aren't invalid\n36:     return df_reg",
            "mapping": [
                {
                    "codeSegments": [
                        {
                            "line": 23,
                            "code": "base_url_reg = ("
                        },
                        {
                            "line": 24,
                            "code": "f\"https://www.basketball-reference.com/leagues/NBA_{year}_per_game.html\""
                        }
                    ],
                    "summaryComponent": "Constructs the URL for the NBA per-game stats page for the specified year"
                },
                {
                    "codeSegments": [
                        {
                            "line": 26,
                            "code": "df_reg = pd.read_html(base_url_reg, header=0)[0]"
                        }
                    ],
                    "summaryComponent": "Reads the first table from the page using pandas"
                },
                {
                    "codeSegments": [
                        {
                            "line": 27,
                            "code": "df_reg = df_reg[df_reg[\"Player\"] != \"Player\"]  # remove repeated header rows"
                        }
                    ],
                    "summaryComponent": "Removes rows where the 'Player' column is a repeated header"
                },
                {
                    "codeSegments": [
                        {
                            "line": 28,
                            "code": "df_reg[\"Year\"] = year"
                        }
                    ],
                    "summaryComponent": "Adds a 'Year' column with the specified year"
                },
                {
                    "codeSegments": [
                        {
                            "line": 30,
                            "code": "df_reg = df_reg["
                        },
                        {
                            "line": 31,
                            "code": "[\"Player\", \"Year\", \"PTS\", \"AST\", \"TRB\", \"FG%\"]"
                        }
                    ],
                    "summaryComponent": "Selects only the relevant columns:"
                },
                {
                    "codeSegments": [
                        {
                            "line": 31,
                            "code": "[\"Player\", \"Year\", \"PTS\", \"AST\", \"TRB\", \"FG%\"]"
                        }
                    ],
                    "summaryComponent": "Player, Year, PTS, AST, TRB, FG%"
                },
                {
                    "codeSegments": [
                        {
                            "line": 33,
                            "code": "df_reg = df_reg.dropna("
                        },
                        {
                            "line": 34,
                            "code": "subset=[\"PTS\", \"AST\", \"TRB\", \"FG%\"]"
                        }
                    ],
                    "summaryComponent": "Drops rows with missing values in any of the key stat columns"
                },
                {
                    "codeSegments": [
                        {
                            "line": 36,
                            "code": "return df_reg"
                        }
                    ],
                    "summaryComponent": "Returns the cleaned and filtered DataFrame for further use"
                }
            ]
        },
        "event": "map_summary_code",
        "id": "1niDvFFYShPUxUNTRjn2"
    },
    {
        "source": "backend",
        "timestamp": "2025-08-23 14:10:51.000",
        "data": {
            "summary": "The scrape_season_stats function downloads NBA per-game statistics for a specified year from Basketball Reference. It cleans the data by removing duplicate header rows and keeps only relevant columns for each player. The function returns a DataFrame containing player names, year, and key stats like points, assists, rebounds, and field goal percentage.",
            "code": "22: def scrape_season_stats(year):\n23:     base_url_reg = (\n24:         f\"https://www.basketball-reference.com/leagues/NBA_{year}_per_game.html\"\n25:     )\n26:     df_reg = pd.read_html(base_url_reg, header=0)[0]\n27:     df_reg = df_reg[df_reg[\"Player\"] != \"Player\"]  # remove repeated header rows\n28:     df_reg[\"Year\"] = year\n29: \n30:     df_reg = df_reg[\n31:         [\"Player\", \"Year\", \"PTS\", \"AST\", \"TRB\", \"FG%\"]\n32:     ]  # Keep only specified columns\n33:     df_reg = df_reg.dropna(\n34:         subset=[\"PTS\", \"AST\", \"TRB\", \"FG%\"]\n35:     )  # Ensure key stats aren't invalid\n36:     return df_reg",
            "mapping": [
                {
                    "codeSegments": [
                        {
                            "line": 22,
                            "code": "def scrape_season_stats(year):"
                        }
                    ],
                    "summaryComponent": "The scrape_season_stats function"
                },
                {
                    "codeSegments": [
                        {
                            "line": 23,
                            "code": "base_url_reg = ("
                        },
                        {
                            "line": 24,
                            "code": "f\"https://www.basketball-reference.com/leagues/NBA_{year}_per_game.html\""
                        },
                        {
                            "line": 26,
                            "code": "df_reg = pd.read_html(base_url_reg, header=0)[0]"
                        }
                    ],
                    "summaryComponent": "downloads NBA per-game statistics for a specified year from Basketball Reference"
                },
                {
                    "codeSegments": [
                        {
                            "line": 27,
                            "code": "df_reg = df_reg[df_reg[\"Player\"] != \"Player\"]  # remove repeated header rows"
                        }
                    ],
                    "summaryComponent": "It cleans the data by removing duplicate header rows"
                },
                {
                    "codeSegments": [
                        {
                            "line": 30,
                            "code": "df_reg = df_reg["
                        },
                        {
                            "line": 31,
                            "code": "[\"Player\", \"Year\", \"PTS\", \"AST\", \"TRB\", \"FG%\"]"
                        }
                    ],
                    "summaryComponent": "and keeps only relevant columns for each player"
                },
                {
                    "codeSegments": [
                        {
                            "line": 36,
                            "code": "return df_reg"
                        }
                    ],
                    "summaryComponent": "The function returns a DataFrame"
                },
                {
                    "codeSegments": [
                        {
                            "line": 31,
                            "code": "[\"Player\", \"Year\", \"PTS\", \"AST\", \"TRB\", \"FG%\"]"
                        }
                    ],
                    "summaryComponent": "containing player names, year, and key stats like points, assists, rebounds, and field goal percentage"
                }
            ]
        },
        "event": "map_summary_code",
        "id": "H2J51VG0S07B6HkzcXWH"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:10:51.000",
        "data": {
            "section_data": {
                "editPromptValue": "",
                "summaryData": {
                    "high_unstructured": "The scrape_season_stats function fetches per-game NBA player statistics for a specific year from Basketball Reference by constructing the appropriate URL and reading the first table from the page. It removes any repeated header rows that may appear in the data, adds a 'Year' column, and selects only the columns for player name, year, points, assists, rebounds, and field goal percentage. The function further ensures data quality by dropping any rows with missing values in the key statistical columns. The resulting DataFrame is returned for further analysis or storage.",
                    "low_structured": "• Fetches NBA per-game stats for a specified year\n• Cleans and filters the data\n• Returns selected player statistics",
                    "high_structured": "• Constructs the URL for the NBA per-game stats page for the specified year\n• Reads the first table from the page using pandas\n• Cleans the data:\n  ◦ Removes rows where the 'Player' column is a repeated header\n  ◦ Adds a 'Year' column with the specified year\n• Selects only the relevant columns:\n  ◦ Player, Year, PTS, AST, TRB, FG%\n• Drops rows with missing values in any of the key stat columns\n• Returns the cleaned and filtered DataFrame for further use",
                    "title": "Summary of scrape_season_stats Function",
                    "medium_unstructured": "The scrape_season_stats function downloads NBA per-game statistics for a specified year from Basketball Reference. It cleans the data by removing duplicate header rows and keeps only relevant columns for each player. The function returns a DataFrame containing player names, year, and key stats like points, assists, rebounds, and field goal percentage.",
                    "medium_structured": "• Downloads per-game NBA stats for a given year from Basketball Reference\n• Removes repeated header rows from the data\n• Keeps only the columns: Player, Year, PTS, AST, TRB, and FG%\n• Drops rows with missing values in key stat columns\n• Returns the cleaned DataFrame",
                    "low_unstructured": "This function retrieves and processes NBA player per-game statistics for a given year."
                },
                "selectedDetailLevel": "medium",
                "title": "Summary of scrape_season_stats Function",
                "summaryMappings": {
                    "low_structured": [
                        {
                            "codeSegments": [
                                {
                                    "line": 22,
                                    "code": "def scrape_season_stats(year):"
                                },
                                {
                                    "line": 23,
                                    "code": "base_url_reg = ("
                                },
                                {
                                    "line": 24,
                                    "code": "f\"https://www.basketball-reference.com/leagues/NBA_{year}_per_game.html\""
                                },
                                {
                                    "line": 26,
                                    "code": "df_reg = pd.read_html(base_url_reg, header=0)[0]"
                                }
                            ],
                            "summaryComponent": "Fetches NBA per-game stats for a specified year"
                        },
                        {
                            "codeSegments": [
                                {
                                    "line": 27,
                                    "code": "df_reg = df_reg[df_reg[\"Player\"] != \"Player\"]  # remove repeated header rows"
                                },
                                {
                                    "line": 28,
                                    "code": "df_reg[\"Year\"] = year"
                                },
                                {
                                    "line": 30,
                                    "code": "df_reg = df_reg["
                                },
                                {
                                    "line": 31,
                                    "code": "[\"Player\", \"Year\", \"PTS\", \"AST\", \"TRB\", \"FG%\"]"
                                },
                                {
                                    "line": 33,
                                    "code": "df_reg = df_reg.dropna("
                                },
                                {
                                    "line": 34,
                                    "code": "subset=[\"PTS\", \"AST\", \"TRB\", \"FG%\"]"
                                }
                            ],
                            "summaryComponent": "Cleans and filters the data"
                        },
                        {
                            "codeSegments": [
                                {
                                    "line": 36,
                                    "code": "return df_reg"
                                }
                            ],
                            "summaryComponent": "Returns selected player statistics"
                        }
                    ],
                    "high_structured": [
                        {
                            "codeSegments": [
                                {
                                    "line": 23,
                                    "code": "base_url_reg = ("
                                },
                                {
                                    "line": 24,
                                    "code": "f\"https://www.basketball-reference.com/leagues/NBA_{year}_per_game.html\""
                                }
                            ],
                            "summaryComponent": "Constructs the URL for the NBA per-game stats page for the specified year"
                        },
                        {
                            "codeSegments": [
                                {
                                    "line": 26,
                                    "code": "df_reg = pd.read_html(base_url_reg, header=0)[0]"
                                }
                            ],
                            "summaryComponent": "Reads the first table from the page using pandas"
                        },
                        {
                            "codeSegments": [
                                {
                                    "line": 27,
                                    "code": "df_reg = df_reg[df_reg[\"Player\"] != \"Player\"]  # remove repeated header rows"
                                }
                            ],
                            "summaryComponent": "Removes rows where the 'Player' column is a repeated header"
                        },
                        {
                            "codeSegments": [
                                {
                                    "line": 28,
                                    "code": "df_reg[\"Year\"] = year"
                                }
                            ],
                            "summaryComponent": "Adds a 'Year' column with the specified year"
                        },
                        {
                            "codeSegments": [
                                {
                                    "line": 30,
                                    "code": "df_reg = df_reg["
                                },
                                {
                                    "line": 31,
                                    "code": "[\"Player\", \"Year\", \"PTS\", \"AST\", \"TRB\", \"FG%\"]"
                                }
                            ],
                            "summaryComponent": "Selects only the relevant columns:"
                        },
                        {
                            "codeSegments": [
                                {
                                    "line": 31,
                                    "code": "[\"Player\", \"Year\", \"PTS\", \"AST\", \"TRB\", \"FG%\"]"
                                }
                            ],
                            "summaryComponent": "Player, Year, PTS, AST, TRB, FG%"
                        },
                        {
                            "codeSegments": [
                                {
                                    "line": 33,
                                    "code": "df_reg = df_reg.dropna("
                                },
                                {
                                    "line": 34,
                                    "code": "subset=[\"PTS\", \"AST\", \"TRB\", \"FG%\"]"
                                }
                            ],
                            "summaryComponent": "Drops rows with missing values in any of the key stat columns"
                        },
                        {
                            "codeSegments": [
                                {
                                    "line": 36,
                                    "code": "return df_reg"
                                }
                            ],
                            "summaryComponent": "Returns the cleaned and filtered DataFrame for further use"
                        }
                    ],
                    "medium_structured": [
                        {
                            "codeSegments": [
                                {
                                    "line": 23,
                                    "code": "base_url_reg = (\n    f\"https://www.basketball-reference.com/leagues/NBA_{year}_per_game.html\"\n)"
                                },
                                {
                                    "line": 26,
                                    "code": "df_reg = pd.read_html(base_url_reg, header=0)[0]"
                                }
                            ],
                            "summaryComponent": "Downloads per-game NBA stats for a given year from Basketball Reference"
                        },
                        {
                            "codeSegments": [
                                {
                                    "line": 27,
                                    "code": "df_reg = df_reg[df_reg[\"Player\"] != \"Player\"]  # remove repeated header rows"
                                }
                            ],
                            "summaryComponent": "Removes repeated header rows from the data"
                        },
                        {
                            "codeSegments": [
                                {
                                    "line": 30,
                                    "code": "df_reg = df_reg[\n    [\"Player\", \"Year\", \"PTS\", \"AST\", \"TRB\", \"FG%\"]\n]"
                                }
                            ],
                            "summaryComponent": "Keeps only the columns: Player, Year, PTS, AST, TRB, and FG%"
                        },
                        {
                            "codeSegments": [
                                {
                                    "line": 33,
                                    "code": "df_reg = df_reg.dropna(\n    subset=[\"PTS\", \"AST\", \"TRB\", \"FG%\"]\n)"
                                }
                            ],
                            "summaryComponent": "Drops rows with missing values in key stat columns"
                        },
                        {
                            "codeSegments": [
                                {
                                    "line": 36,
                                    "code": "return df_reg"
                                }
                            ],
                            "summaryComponent": "Returns the cleaned DataFrame"
                        }
                    ],
                    "medium_unstructured": [
                        {
                            "codeSegments": [
                                {
                                    "line": 22,
                                    "code": "def scrape_season_stats(year):"
                                }
                            ],
                            "summaryComponent": "The scrape_season_stats function"
                        },
                        {
                            "codeSegments": [
                                {
                                    "line": 23,
                                    "code": "base_url_reg = ("
                                },
                                {
                                    "line": 24,
                                    "code": "f\"https://www.basketball-reference.com/leagues/NBA_{year}_per_game.html\""
                                },
                                {
                                    "line": 26,
                                    "code": "df_reg = pd.read_html(base_url_reg, header=0)[0]"
                                }
                            ],
                            "summaryComponent": "downloads NBA per-game statistics for a specified year from Basketball Reference"
                        },
                        {
                            "codeSegments": [
                                {
                                    "line": 27,
                                    "code": "df_reg = df_reg[df_reg[\"Player\"] != \"Player\"]  # remove repeated header rows"
                                }
                            ],
                            "summaryComponent": "It cleans the data by removing duplicate header rows"
                        },
                        {
                            "codeSegments": [
                                {
                                    "line": 30,
                                    "code": "df_reg = df_reg["
                                },
                                {
                                    "line": 31,
                                    "code": "[\"Player\", \"Year\", \"PTS\", \"AST\", \"TRB\", \"FG%\"]"
                                }
                            ],
                            "summaryComponent": "and keeps only relevant columns for each player"
                        },
                        {
                            "codeSegments": [
                                {
                                    "line": 36,
                                    "code": "return df_reg"
                                }
                            ],
                            "summaryComponent": "The function returns a DataFrame"
                        },
                        {
                            "codeSegments": [
                                {
                                    "line": 31,
                                    "code": "[\"Player\", \"Year\", \"PTS\", \"AST\", \"TRB\", \"FG%\"]"
                                }
                            ],
                            "summaryComponent": "containing player names, year, and key stats like points, assists, rebounds, and field goal percentage"
                        }
                    ],
                    "high_unstructured": [
                        {
                            "codeSegments": [
                                {
                                    "line": 22,
                                    "code": "def scrape_season_stats(year):"
                                }
                            ],
                            "summaryComponent": "The scrape_season_stats function"
                        },
                        {
                            "codeSegments": [
                                {
                                    "line": 23,
                                    "code": "base_url_reg = ("
                                },
                                {
                                    "line": 24,
                                    "code": "f\"https://www.basketball-reference.com/leagues/NBA_{year}_per_game.html\""
                                },
                                {
                                    "line": 26,
                                    "code": "df_reg = pd.read_html(base_url_reg, header=0)[0]"
                                }
                            ],
                            "summaryComponent": "fetches per-game NBA player statistics for a specific year from Basketball Reference"
                        },
                        {
                            "codeSegments": [
                                {
                                    "line": 23,
                                    "code": "base_url_reg = ("
                                },
                                {
                                    "line": 24,
                                    "code": "f\"https://www.basketball-reference.com/leagues/NBA_{year}_per_game.html\""
                                }
                            ],
                            "summaryComponent": "by constructing the appropriate URL"
                        },
                        {
                            "codeSegments": [
                                {
                                    "line": 26,
                                    "code": "df_reg = pd.read_html(base_url_reg, header=0)[0]"
                                }
                            ],
                            "summaryComponent": "and reading the first table from the page"
                        },
                        {
                            "codeSegments": [
                                {
                                    "line": 27,
                                    "code": "df_reg = df_reg[df_reg[\"Player\"] != \"Player\"]  # remove repeated header rows"
                                }
                            ],
                            "summaryComponent": "It removes any repeated header rows that may appear in the data"
                        },
                        {
                            "codeSegments": [
                                {
                                    "line": 28,
                                    "code": "df_reg[\"Year\"] = year"
                                }
                            ],
                            "summaryComponent": "adds a 'Year' column"
                        },
                        {
                            "codeSegments": [
                                {
                                    "line": 30,
                                    "code": "df_reg = df_reg["
                                },
                                {
                                    "line": 31,
                                    "code": "[\"Player\", \"Year\", \"PTS\", \"AST\", \"TRB\", \"FG%\"]"
                                }
                            ],
                            "summaryComponent": "and selects only the columns for player name, year, points, assists, rebounds, and field goal percentage"
                        },
                        {
                            "codeSegments": [
                                {
                                    "line": 33,
                                    "code": "df_reg = df_reg.dropna("
                                },
                                {
                                    "line": 34,
                                    "code": "subset=[\"PTS\", \"AST\", \"TRB\", \"FG%\"]"
                                }
                            ],
                            "summaryComponent": "The function further ensures data quality by dropping any rows with missing values in the key statistical columns"
                        },
                        {
                            "codeSegments": [
                                {
                                    "line": 36,
                                    "code": "return df_reg"
                                }
                            ],
                            "summaryComponent": "The resulting DataFrame is returned for further analysis or storage."
                        }
                    ],
                    "low_unstructured": [
                        {
                            "codeSegments": [
                                {
                                    "line": 22,
                                    "code": "def scrape_season_stats(year):"
                                }
                            ],
                            "summaryComponent": "This function"
                        },
                        {
                            "codeSegments": [
                                {
                                    "line": 26,
                                    "code": "df_reg = pd.read_html(base_url_reg, header=0)[0]"
                                }
                            ],
                            "summaryComponent": "retrieves"
                        },
                        {
                            "codeSegments": [
                                {
                                    "line": 27,
                                    "code": "df_reg = df_reg[df_reg[\"Player\"] != \"Player\"]  # remove repeated header rows"
                                },
                                {
                                    "line": 28,
                                    "code": "df_reg[\"Year\"] = year"
                                },
                                {
                                    "line": 30,
                                    "code": "df_reg = df_reg[\n    [\"Player\", \"Year\", \"PTS\", \"AST\", \"TRB\", \"FG%\"]\n]"
                                },
                                {
                                    "line": 33,
                                    "code": "df_reg = df_reg.dropna(\n    subset=[\"PTS\", \"AST\", \"TRB\", \"FG%\"]\n)"
                                }
                            ],
                            "summaryComponent": "and processes"
                        },
                        {
                            "codeSegments": [
                                {
                                    "line": 24,
                                    "code": "f\"https://www.basketball-reference.com/leagues/NBA_{year}_per_game.html\""
                                }
                            ],
                            "summaryComponent": "NBA player per-game statistics"
                        },
                        {
                            "codeSegments": [
                                {
                                    "line": 22,
                                    "code": "def scrape_season_stats(year):"
                                },
                                {
                                    "line": 28,
                                    "code": "df_reg[\"Year\"] = year"
                                }
                            ],
                            "summaryComponent": "for a given year."
                        }
                    ]
                },
                "metadata": {
                    "id": "db3307f5-ee3f-492a-bd71-efea25f4e903",
                    "filename": "scraper.py",
                    "offset": 652,
                    "fullPath": "/project/workspace/scraper.py",
                    "originalCode": "def scrape_season_stats(year):\n    base_url_reg = (\n        f\"https://www.basketball-reference.com/leagues/NBA_{year}_per_game.html\"\n    )\n    df_reg = pd.read_html(base_url_reg, header=0)[0]\n    df_reg = df_reg[df_reg[\"Player\"] != \"Player\"]  # remove repeated header rows\n    df_reg[\"Year\"] = year\n\n    df_reg = df_reg[\n        [\"Player\", \"Year\", \"PTS\", \"AST\", \"TRB\", \"FG%\"]\n    ]  # Keep only specified columns\n    df_reg = df_reg.dropna(\n        subset=[\"PTS\", \"AST\", \"TRB\", \"FG%\"]\n    )  # Ensure key stats aren't invalid\n    return df_reg"
                },
                "createdAt": 1755987052000,
                "lines": [
                    22,
                    36
                ],
                "editPromptStructured": null,
                "selectedStructured": "unstructured",
                "editPromptDetailLevel": null
            },
            "section_id": "db3307f5-ee3f-492a-bd71-efea25f4e903"
        },
        "event": "create_new_section",
        "id": "WbjzXHdmkvxWWit1C38F"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:10:51.000",
        "data": {
            "after_section_id": "db3307f5-ee3f-492a-bd71-efea25f4e903",
            "before_section_id": null
        },
        "event": "autotransit_section",
        "id": "kEAR6uyhxIIwjesxhIFQ"
    },
    {
        "source": "backend",
        "timestamp": "2025-08-23 14:10:51.000",
        "data": {
            "summary": "This function retrieves and processes NBA player per-game statistics for a given year.",
            "code": "22: def scrape_season_stats(year):\n23:     base_url_reg = (\n24:         f\"https://www.basketball-reference.com/leagues/NBA_{year}_per_game.html\"\n25:     )\n26:     df_reg = pd.read_html(base_url_reg, header=0)[0]\n27:     df_reg = df_reg[df_reg[\"Player\"] != \"Player\"]  # remove repeated header rows\n28:     df_reg[\"Year\"] = year\n29: \n30:     df_reg = df_reg[\n31:         [\"Player\", \"Year\", \"PTS\", \"AST\", \"TRB\", \"FG%\"]\n32:     ]  # Keep only specified columns\n33:     df_reg = df_reg.dropna(\n34:         subset=[\"PTS\", \"AST\", \"TRB\", \"FG%\"]\n35:     )  # Ensure key stats aren't invalid\n36:     return df_reg",
            "mapping": [
                {
                    "codeSegments": [
                        {
                            "line": 22,
                            "code": "def scrape_season_stats(year):"
                        }
                    ],
                    "summaryComponent": "This function"
                },
                {
                    "codeSegments": [
                        {
                            "line": 26,
                            "code": "df_reg = pd.read_html(base_url_reg, header=0)[0]"
                        }
                    ],
                    "summaryComponent": "retrieves"
                },
                {
                    "codeSegments": [
                        {
                            "line": 27,
                            "code": "df_reg = df_reg[df_reg[\"Player\"] != \"Player\"]  # remove repeated header rows"
                        },
                        {
                            "line": 28,
                            "code": "df_reg[\"Year\"] = year"
                        },
                        {
                            "line": 30,
                            "code": "df_reg = df_reg[\n    [\"Player\", \"Year\", \"PTS\", \"AST\", \"TRB\", \"FG%\"]\n]"
                        },
                        {
                            "line": 33,
                            "code": "df_reg = df_reg.dropna(\n    subset=[\"PTS\", \"AST\", \"TRB\", \"FG%\"]\n)"
                        }
                    ],
                    "summaryComponent": "and processes"
                },
                {
                    "codeSegments": [
                        {
                            "line": 24,
                            "code": "f\"https://www.basketball-reference.com/leagues/NBA_{year}_per_game.html\""
                        }
                    ],
                    "summaryComponent": "NBA player per-game statistics"
                },
                {
                    "codeSegments": [
                        {
                            "line": 22,
                            "code": "def scrape_season_stats(year):"
                        },
                        {
                            "line": 28,
                            "code": "df_reg[\"Year\"] = year"
                        }
                    ],
                    "summaryComponent": "for a given year."
                }
            ]
        },
        "event": "map_summary_code",
        "id": "ugJvMokUsBMCNd40N5qq"
    },
    {
        "source": "backend",
        "timestamp": "2025-08-23 14:10:52.000",
        "data": {
            "summary": "The scrape_season_stats function fetches per-game NBA player statistics for a specific year from Basketball Reference by constructing the appropriate URL and reading the first table from the page. It removes any repeated header rows that may appear in the data, adds a 'Year' column, and selects only the columns for player name, year, points, assists, rebounds, and field goal percentage. The function further ensures data quality by dropping any rows with missing values in the key statistical columns. The resulting DataFrame is returned for further analysis or storage.",
            "code": "22: def scrape_season_stats(year):\n23:     base_url_reg = (\n24:         f\"https://www.basketball-reference.com/leagues/NBA_{year}_per_game.html\"\n25:     )\n26:     df_reg = pd.read_html(base_url_reg, header=0)[0]\n27:     df_reg = df_reg[df_reg[\"Player\"] != \"Player\"]  # remove repeated header rows\n28:     df_reg[\"Year\"] = year\n29: \n30:     df_reg = df_reg[\n31:         [\"Player\", \"Year\", \"PTS\", \"AST\", \"TRB\", \"FG%\"]\n32:     ]  # Keep only specified columns\n33:     df_reg = df_reg.dropna(\n34:         subset=[\"PTS\", \"AST\", \"TRB\", \"FG%\"]\n35:     )  # Ensure key stats aren't invalid\n36:     return df_reg",
            "mapping": [
                {
                    "codeSegments": [
                        {
                            "line": 22,
                            "code": "def scrape_season_stats(year):"
                        }
                    ],
                    "summaryComponent": "The scrape_season_stats function"
                },
                {
                    "codeSegments": [
                        {
                            "line": 23,
                            "code": "base_url_reg = ("
                        },
                        {
                            "line": 24,
                            "code": "f\"https://www.basketball-reference.com/leagues/NBA_{year}_per_game.html\""
                        },
                        {
                            "line": 26,
                            "code": "df_reg = pd.read_html(base_url_reg, header=0)[0]"
                        }
                    ],
                    "summaryComponent": "fetches per-game NBA player statistics for a specific year from Basketball Reference"
                },
                {
                    "codeSegments": [
                        {
                            "line": 23,
                            "code": "base_url_reg = ("
                        },
                        {
                            "line": 24,
                            "code": "f\"https://www.basketball-reference.com/leagues/NBA_{year}_per_game.html\""
                        }
                    ],
                    "summaryComponent": "by constructing the appropriate URL"
                },
                {
                    "codeSegments": [
                        {
                            "line": 26,
                            "code": "df_reg = pd.read_html(base_url_reg, header=0)[0]"
                        }
                    ],
                    "summaryComponent": "and reading the first table from the page"
                },
                {
                    "codeSegments": [
                        {
                            "line": 27,
                            "code": "df_reg = df_reg[df_reg[\"Player\"] != \"Player\"]  # remove repeated header rows"
                        }
                    ],
                    "summaryComponent": "It removes any repeated header rows that may appear in the data"
                },
                {
                    "codeSegments": [
                        {
                            "line": 28,
                            "code": "df_reg[\"Year\"] = year"
                        }
                    ],
                    "summaryComponent": "adds a 'Year' column"
                },
                {
                    "codeSegments": [
                        {
                            "line": 30,
                            "code": "df_reg = df_reg["
                        },
                        {
                            "line": 31,
                            "code": "[\"Player\", \"Year\", \"PTS\", \"AST\", \"TRB\", \"FG%\"]"
                        }
                    ],
                    "summaryComponent": "and selects only the columns for player name, year, points, assists, rebounds, and field goal percentage"
                },
                {
                    "codeSegments": [
                        {
                            "line": 33,
                            "code": "df_reg = df_reg.dropna("
                        },
                        {
                            "line": 34,
                            "code": "subset=[\"PTS\", \"AST\", \"TRB\", \"FG%\"]"
                        }
                    ],
                    "summaryComponent": "The function further ensures data quality by dropping any rows with missing values in the key statistical columns"
                },
                {
                    "codeSegments": [
                        {
                            "line": 36,
                            "code": "return df_reg"
                        }
                    ],
                    "summaryComponent": "The resulting DataFrame is returned for further analysis or storage."
                }
            ]
        },
        "event": "map_summary_code",
        "id": "AYDWKYRjlHpnjhY0wn1M"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:10:53.000",
        "data": {
            "detail_level": "medium",
            "section_id": "db3307f5-ee3f-492a-bd71-efea25f4e903",
            "structured_type": "unstructured"
        },
        "event": "mapping_unhover",
        "id": "6BqwJndbZqHWlq5KmRpu"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:10:53.000",
        "data": {
            "detail_level": "medium",
            "section_id": "db3307f5-ee3f-492a-bd71-efea25f4e903",
            "structured_type": "unstructured"
        },
        "event": "mapping_unhover",
        "id": "PszjwBgiOM7vLZ724fxz"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:10:53.000",
        "data": {
            "detail_level": "medium",
            "section_id": "db3307f5-ee3f-492a-bd71-efea25f4e903",
            "structured_type": "unstructured",
            "mapping_index": 2
        },
        "event": "mapping_hover",
        "id": "PwE8LcyVSTj0N0UqxoRb"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:10:53.000",
        "data": {
            "detail_level": "medium",
            "section_id": "db3307f5-ee3f-492a-bd71-efea25f4e903",
            "structured_type": "unstructured"
        },
        "event": "mapping_unhover",
        "id": "S0vB2UiCrnwWB0fJ0b7N"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:10:53.000",
        "data": {
            "detail_level": "medium",
            "section_id": "db3307f5-ee3f-492a-bd71-efea25f4e903",
            "structured_type": "unstructured",
            "mapping_index": 1
        },
        "event": "mapping_hover",
        "id": "S8sDr1bpglQyI5MmagDd"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:10:53.000",
        "data": {
            "detail_level": "medium",
            "section_id": "db3307f5-ee3f-492a-bd71-efea25f4e903",
            "structured_type": "unstructured",
            "mapping_index": 4
        },
        "event": "mapping_hover",
        "id": "hrgg1QnR2dhAwTSNLoZB"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:10:53.000",
        "data": {
            "detail_level": "medium",
            "section_id": "db3307f5-ee3f-492a-bd71-efea25f4e903",
            "structured_type": "unstructured"
        },
        "event": "mapping_unhover",
        "id": "iQth8sdAmECplEyyFkHi"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:10:53.000",
        "data": {
            "before_detail_level": "medium",
            "before_structured": "unstructured",
            "section_id": "db3307f5-ee3f-492a-bd71-efea25f4e903",
            "after_detail_level": "high",
            "after_structured": "unstructured"
        },
        "event": "change_summary_level",
        "id": "isTl75hcwo1RABThIBg2"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:10:53.000",
        "data": {
            "detail_level": "medium",
            "section_id": "db3307f5-ee3f-492a-bd71-efea25f4e903",
            "structured_type": "unstructured",
            "mapping_index": 0
        },
        "event": "mapping_hover",
        "id": "tBb0XZmQN3fTqYGBTJe3"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:10:54.000",
        "data": {
            "detail_level": "high",
            "section_id": "db3307f5-ee3f-492a-bd71-efea25f4e903",
            "structured_type": "structured",
            "mapping_index": 5
        },
        "event": "mapping_hover",
        "id": "4AkblcupDjJbHx6YZP7w"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:10:54.000",
        "data": {
            "detail_level": "high",
            "section_id": "db3307f5-ee3f-492a-bd71-efea25f4e903",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "5CjabMFAZqCZdOpsi7D6"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:10:54.000",
        "data": {
            "detail_level": "high",
            "section_id": "db3307f5-ee3f-492a-bd71-efea25f4e903",
            "structured_type": "structured",
            "mapping_index": 7
        },
        "event": "mapping_hover",
        "id": "7UT5qNJIr71QYFjRCc5l"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:10:54.000",
        "data": {
            "detail_level": "high",
            "section_id": "db3307f5-ee3f-492a-bd71-efea25f4e903",
            "structured_type": "structured",
            "mapping_index": 0
        },
        "event": "mapping_hover",
        "id": "B9Y2pPe0ilWHTG3ToZjV"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:10:54.000",
        "data": {
            "detail_level": "high",
            "section_id": "db3307f5-ee3f-492a-bd71-efea25f4e903",
            "structured_type": "structured",
            "mapping_index": 1
        },
        "event": "mapping_hover",
        "id": "BLdatGsXAfC4QlvqcNAP"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:10:54.000",
        "data": {
            "before_detail_level": "high",
            "before_structured": "unstructured",
            "section_id": "db3307f5-ee3f-492a-bd71-efea25f4e903",
            "after_detail_level": "high",
            "after_structured": "structured"
        },
        "event": "change_summary_level",
        "id": "FGf7q9tL7sUosha6J3u7"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:10:54.000",
        "data": {
            "detail_level": "high",
            "section_id": "db3307f5-ee3f-492a-bd71-efea25f4e903",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "GHFmlY2RxJsCYD0n9LW2"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:10:54.000",
        "data": {
            "detail_level": "high",
            "section_id": "db3307f5-ee3f-492a-bd71-efea25f4e903",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "MdAw69Wvkgx5AMynlul9"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:10:54.000",
        "data": {
            "detail_level": "high",
            "section_id": "db3307f5-ee3f-492a-bd71-efea25f4e903",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "NuwFNSCujXdiFpbPx9Q5"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:10:54.000",
        "data": {
            "detail_level": "high",
            "section_id": "db3307f5-ee3f-492a-bd71-efea25f4e903",
            "structured_type": "structured",
            "mapping_index": 4
        },
        "event": "mapping_hover",
        "id": "PGw3Gn65hYVRuKxUWQm7"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:10:54.000",
        "data": {
            "detail_level": "high",
            "section_id": "db3307f5-ee3f-492a-bd71-efea25f4e903",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "VeYfkNKZhd0KwCNiNUPg"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:10:54.000",
        "data": {
            "detail_level": "high",
            "section_id": "db3307f5-ee3f-492a-bd71-efea25f4e903",
            "structured_type": "structured",
            "mapping_index": 6
        },
        "event": "mapping_hover",
        "id": "WT7RDg9Tte30Q9F3HcSo"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:10:54.000",
        "data": {
            "detail_level": "high",
            "section_id": "db3307f5-ee3f-492a-bd71-efea25f4e903",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "gRlDRUONR1LpotrqD3N4"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:10:54.000",
        "data": {
            "detail_level": "high",
            "section_id": "db3307f5-ee3f-492a-bd71-efea25f4e903",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "hfqVttphfNtGU5iO2Wd3"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:10:54.000",
        "data": {
            "detail_level": "high",
            "section_id": "db3307f5-ee3f-492a-bd71-efea25f4e903",
            "structured_type": "structured",
            "mapping_index": 2
        },
        "event": "mapping_hover",
        "id": "n8MvxMSfkktC0VlL9hlh"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:10:54.000",
        "data": {
            "detail_level": "high",
            "section_id": "db3307f5-ee3f-492a-bd71-efea25f4e903",
            "structured_type": "structured",
            "mapping_index": 3
        },
        "event": "mapping_hover",
        "id": "yeOqn69hHkxEndf4Rvu5"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:10:54.000",
        "data": {
            "detail_level": "high",
            "section_id": "db3307f5-ee3f-492a-bd71-efea25f4e903",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "zTYsPjV7JkzqCnhowjI7"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:10:56.000",
        "data": {
            "detail_level": "high",
            "section_id": "db3307f5-ee3f-492a-bd71-efea25f4e903",
            "structured_type": "structured",
            "mapping_index": 7
        },
        "event": "mapping_hover",
        "id": "UvZrkIGwIugTnKY2gWSo"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:10:56.000",
        "data": {
            "detail_level": "high",
            "section_id": "db3307f5-ee3f-492a-bd71-efea25f4e903",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "V7qb4Snl4kf2EsGcjyye"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:11:08.000",
        "data": {
            "detail_level": "high",
            "section_id": "db3307f5-ee3f-492a-bd71-efea25f4e903",
            "structured_type": "structured",
            "mapping_index": 6
        },
        "event": "mapping_hover",
        "id": "4Rt77dlouAQlwObnzyum"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:11:08.000",
        "data": {
            "detail_level": "high",
            "section_id": "db3307f5-ee3f-492a-bd71-efea25f4e903",
            "structured_type": "structured",
            "mapping_index": 3
        },
        "event": "mapping_hover",
        "id": "6aJ2lzG0mOHqBnZEqRZZ"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:11:08.000",
        "data": {
            "detail_level": "high",
            "section_id": "db3307f5-ee3f-492a-bd71-efea25f4e903",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "K5N1d3N8Z3ZA2sYB7Oaa"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:11:08.000",
        "data": {
            "detail_level": "high",
            "section_id": "db3307f5-ee3f-492a-bd71-efea25f4e903",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "QaesWBmKEnPsFMUK2lPr"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:11:08.000",
        "data": {
            "detail_level": "high",
            "section_id": "db3307f5-ee3f-492a-bd71-efea25f4e903",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "cxhbgGLQLif7ZYzMupfy"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:11:08.000",
        "data": {
            "detail_level": "high",
            "section_id": "db3307f5-ee3f-492a-bd71-efea25f4e903",
            "structured_type": "structured",
            "mapping_index": 7
        },
        "event": "mapping_hover",
        "id": "eR3CofOiKIH43G10nkvU"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:11:08.000",
        "data": {
            "detail_level": "high",
            "section_id": "db3307f5-ee3f-492a-bd71-efea25f4e903",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "fWNKuQYwtWjl5YUpvKOt"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:11:08.000",
        "data": {
            "detail_level": "high",
            "section_id": "db3307f5-ee3f-492a-bd71-efea25f4e903",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "k0pra9kVA8psSaOtp4G8"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:11:08.000",
        "data": {
            "detail_level": "high",
            "section_id": "db3307f5-ee3f-492a-bd71-efea25f4e903",
            "structured_type": "structured",
            "mapping_index": 2
        },
        "event": "mapping_hover",
        "id": "kacor6Mp8XwK2SzpL8tY"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:11:08.000",
        "data": {
            "detail_level": "high",
            "section_id": "db3307f5-ee3f-492a-bd71-efea25f4e903",
            "structured_type": "structured",
            "mapping_index": 0
        },
        "event": "mapping_hover",
        "id": "u5I34QAQXYeoqPTRyyZL"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:11:38.000",
        "data": {
            "structured": "structured",
            "detail_level": "high",
            "summary": "• Constructs the URL for the NBA per-game stats page for the specified year\n• Reads the first table from the page using pandas\n• Cleans the data:\n  ◦ Removes rows where the 'Player' column is a repeated header\n  ◦ Adds a 'Year' column with the specified year\n• Selects only the relevant columns:\n  ◦ Player, Year, PTS, AST, TRB, FG%\n• Drops rows with missing values in any of the key stat columns\n• Returns the cleaned and filtered DataFrame for further use",
            "section_id": "db3307f5-ee3f-492a-bd71-efea25f4e903"
        },
        "event": "click_edit_in_prompt",
        "id": "5Ia2EyfnrjgLbEvdXfXW"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:11:39.000",
        "data": {
            "structured": "structured",
            "detail_level": "high",
            "instruction": "change the url_reg to https://www.basketball-reference.com/leagues/NBA_2025_advanced.html\nand scrape more attributes like, BPM WS/48",
            "original_summary": "• Constructs the URL for the NBA per-game stats page for the specified year\n• Reads the first table from the page using pandas\n• Cleans the data:\n  ◦ Removes rows where the 'Player' column is a repeated header\n  ◦ Adds a 'Year' column with the specified year\n• Selects only the relevant columns:\n  ◦ Player, Year, PTS, AST, TRB, FG%\n• Drops rows with missing values in any of the key stat columns\n• Returns the cleaned and filtered DataFrame for further use",
            "section_id": "db3307f5-ee3f-492a-bd71-efea25f4e903"
        },
        "event": "apply_instruction_summary",
        "id": "4DzNrLqJ3nkexMud3pfO"
    },
    {
        "source": "backend",
        "timestamp": "2025-08-23 14:11:42.000",
        "data": {
            "original_code": "def scrape_season_stats(year):\n    base_url_reg = (\n        f\"https://www.basketball-reference.com/leagues/NBA_{year}_per_game.html\"\n    )\n    df_reg = pd.read_html(base_url_reg, header=0)[0]\n    df_reg = df_reg[df_reg[\"Player\"] != \"Player\"]  # remove repeated header rows\n    df_reg[\"Year\"] = year\n\n    df_reg = df_reg[\n        [\"Player\", \"Year\", \"PTS\", \"AST\", \"TRB\", \"FG%\"]\n    ]  # Keep only specified columns\n    df_reg = df_reg.dropna(\n        subset=[\"PTS\", \"AST\", \"TRB\", \"FG%\"]\n    )  # Ensure key stats aren't invalid\n    return df_reg",
            "instruction": "change the url_reg to https://www.basketball-reference.com/leagues/NBA_2025_advanced.html\nand scrape more attributes like, BPM WS/48",
            "original_summary": "• Constructs the URL for the NBA per-game stats page for the specified year\n• Reads the first table from the page using pandas\n• Cleans the data:\n  ◦ Removes rows where the 'Player' column is a repeated header\n  ◦ Adds a 'Year' column with the specified year\n• Selects only the relevant columns:\n  ◦ Player, Year, PTS, AST, TRB, FG%\n• Drops rows with missing values in any of the key stat columns\n• Returns the cleaned and filtered DataFrame for further use",
            "updated_summary": "• Constructs the URL for the NBA advanced stats page for the 2025 season: https://www.basketball-reference.com/leagues/NBA_2025_advanced.html  \n• Reads the first table from the page using pandas  \n• Cleans the data:  \n  ◦ Removes rows where the 'Player' column is a repeated header  \n  ◦ Adds a 'Year' column with the specified year  \n• Selects only the relevant columns:  \n  ◦ Player, Year, PTS, AST, TRB, FG%, BPM, WS/48  \n• Drops rows with missing values in any of the key stat columns  \n• Returns the cleaned and filtered DataFrame for further use"
        },
        "event": "apply_instruction_summary",
        "id": "mjOlAETXkGqcw1z6xMBk"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:11:45.000",
        "data": {
            "structured": "structured",
            "detail_level": "high",
            "edited_summary": "• Constructs the URL for the NBA advanced stats page for the 2025 season: https://www.basketball-reference.com/leagues/NBA_2025_advanced.html  \n• Reads the first table from the page using pandas  \n• Cleans the data:  \n  ◦ Removes rows where the 'Player' column is a repeated header  \n  ◦ Adds a 'Year' column with the specified year  \n• Selects only the relevant columns:  \n  ◦ Player, Year, PTS, AST, TRB, FG%, BPM, WS/48  \n• Drops rows with missing values in any of the key stat columns  \n• Returns the cleaned and filtered DataFrame for further use",
            "section_id": "db3307f5-ee3f-492a-bd71-efea25f4e903",
            "original_summary": "• Constructs the URL for the NBA per-game stats page for the specified year\n• Reads the first table from the page using pandas\n• Cleans the data:\n  ◦ Removes rows where the 'Player' column is a repeated header\n  ◦ Adds a 'Year' column with the specified year\n• Selects only the relevant columns:\n  ◦ Player, Year, PTS, AST, TRB, FG%\n• Drops rows with missing values in any of the key stat columns\n• Returns the cleaned and filtered DataFrame for further use"
        },
        "event": "commit_modified_summary",
        "id": "IFBUbQHfbnd1c3QxAQIa"
    },
    {
        "source": "backend",
        "timestamp": "2025-08-23 14:11:48.000",
        "data": {
            "original_code": "def scrape_season_stats(year):\n    base_url_reg = (\n        f\"https://www.basketball-reference.com/leagues/NBA_{year}_per_game.html\"\n    )\n    df_reg = pd.read_html(base_url_reg, header=0)[0]\n    df_reg = df_reg[df_reg[\"Player\"] != \"Player\"]  # remove repeated header rows\n    df_reg[\"Year\"] = year\n\n    df_reg = df_reg[\n        [\"Player\", \"Year\", \"PTS\", \"AST\", \"TRB\", \"FG%\"]\n    ]  # Keep only specified columns\n    df_reg = df_reg.dropna(\n        subset=[\"PTS\", \"AST\", \"TRB\", \"FG%\"]\n    )  # Ensure key stats aren't invalid\n    return df_reg",
            "updated_code": "def scrape_season_stats(year):\n    base_url_adv = (\n        f\"https://www.basketball-reference.com/leagues/NBA_{year}_advanced.html\"\n    )\n    df_adv = pd.read_html(base_url_adv, header=0)[0]\n    df_adv = df_adv[df_adv[\"Player\"] != \"Player\"]  # remove repeated header rows\n    df_adv[\"Year\"] = year\n\n    df_adv = df_adv[\n        [\"Player\", \"Year\", \"PTS\", \"AST\", \"TRB\", \"FG%\", \"BPM\", \"WS/48\"]\n    ]  # Keep only specified columns\n    df_adv = df_adv.dropna(\n        subset=[\"PTS\", \"AST\", \"TRB\", \"FG%\", \"BPM\", \"WS/48\"]\n    )  # Ensure key stats aren't invalid\n    return df_adv",
            "detail_level": "high",
            "original_summary": "• Constructs the URL for the NBA per-game stats page for the specified year\n• Reads the first table from the page using pandas\n• Cleans the data:\n  ◦ Removes rows where the 'Player' column is a repeated header\n  ◦ Adds a 'Year' column with the specified year\n• Selects only the relevant columns:\n  ◦ Player, Year, PTS, AST, TRB, FG%\n• Drops rows with missing values in any of the key stat columns\n• Returns the cleaned and filtered DataFrame for further use",
            "edited_summary": "• Constructs the URL for the NBA advanced stats page for the 2025 season: https://www.basketball-reference.com/leagues/NBA_2025_advanced.html  \n• Reads the first table from the page using pandas  \n• Cleans the data:  \n  ◦ Removes rows where the 'Player' column is a repeated header  \n  ◦ Adds a 'Year' column with the specified year  \n• Selects only the relevant columns:  \n  ◦ Player, Year, PTS, AST, TRB, FG%, BPM, WS/48  \n• Drops rows with missing values in any of the key stat columns  \n• Returns the cleaned and filtered DataFrame for further use",
            "structured_type": "structured"
        },
        "event": "modify_summary_mediation",
        "id": "7KTzlYAXJOzGRomqUtZ0"
    },
    {
        "source": "backend",
        "timestamp": "2025-08-23 14:11:53.000",
        "data": {
            "original_code": "def scrape_season_stats(year):\n    base_url_adv = (\n        f\"https://www.basketball-reference.com/leagues/NBA_{year}_advanced.html\"\n    )\n    df_adv = pd.read_html(base_url_adv, header=0)[0]\n    df_adv = df_adv[df_adv[\"Player\"] != \"Player\"]  # remove repeated header rows\n    df_adv[\"Year\"] = year\n\n    df_adv = df_adv[\n        [\"Player\", \"Year\", \"PTS\", \"AST\", \"TRB\", \"FG%\", \"BPM\", \"WS/48\"]\n    ]  # Keep only specified columns\n    df_adv = df_adv.dropna(\n        subset=[\"PTS\", \"AST\", \"TRB\", \"FG%\", \"BPM\", \"WS/48\"]\n    )  # Ensure key stats aren't invalid\n    return df_adv",
            "old_summary": {
                "high_unstructured": "The scrape_season_stats function fetches per-game NBA player statistics for a specific year from Basketball Reference by constructing the appropriate URL and reading the first table from the page. It removes any repeated header rows that may appear in the data, adds a 'Year' column, and selects only the columns for player name, year, points, assists, rebounds, and field goal percentage. The function further ensures data quality by dropping any rows with missing values in the key statistical columns. The resulting DataFrame is returned for further analysis or storage.",
                "low_structured": "• Fetches NBA per-game stats for a specified year\n• Cleans and filters the data\n• Returns selected player statistics",
                "high_structured": "• Constructs the URL for the NBA per-game stats page for the specified year\n• Reads the first table from the page using pandas\n• Cleans the data:\n  ◦ Removes rows where the 'Player' column is a repeated header\n  ◦ Adds a 'Year' column with the specified year\n• Selects only the relevant columns:\n  ◦ Player, Year, PTS, AST, TRB, FG%\n• Drops rows with missing values in any of the key stat columns\n• Returns the cleaned and filtered DataFrame for further use",
                "title": "Summary of scrape_season_stats Function",
                "medium_unstructured": "The scrape_season_stats function downloads NBA per-game statistics for a specified year from Basketball Reference. It cleans the data by removing duplicate header rows and keeps only relevant columns for each player. The function returns a DataFrame containing player names, year, and key stats like points, assists, rebounds, and field goal percentage.",
                "medium_structured": "• Downloads per-game NBA stats for a given year from Basketball Reference\n• Removes repeated header rows from the data\n• Keeps only the columns: Player, Year, PTS, AST, TRB, and FG%\n• Drops rows with missing values in key stat columns\n• Returns the cleaned DataFrame",
                "low_unstructured": "This function retrieves and processes NBA player per-game statistics for a given year."
            },
            "new_summary": {
                "high_unstructured": "The scrape_season_stats function fetches per-game NBA player statistics for a specific year from Basketball Reference by constructing the appropriate URL and reading the first table from the page. It removes any repeated header rows that may appear in the data, adds a 'Year' column, and now selects the columns for player name, year, points, assists, rebounds, field goal percentage, as well as the newly included advanced stats BPM and WS/48. The function further ensures data quality by dropping any rows with missing values in the key statistical columns, now also considering BPM and WS/48. The resulting DataFrame is returned for further analysis or storage.",
                "low_structured": "• Fetches NBA per-game stats for a specified year\n• Cleans and filters the data\n• Returns selected player statistics, now also including BPM and WS/48 columns",
                "high_structured": "• Constructs the URL for the NBA per-game stats page for the specified year\n• Reads the first table from the page using pandas\n• Cleans the data:\n  ◦ Removes rows where the 'Player' column is a repeated header\n  ◦ Adds a 'Year' column with the specified year\n• Selects only the relevant columns:\n  ◦ Player, Year, PTS, AST, TRB, FG%, BPM, WS/48 (BPM and WS/48 are newly included)\n• Drops rows with missing values in any of the key stat columns (now including BPM and WS/48)\n• Returns the cleaned and filtered DataFrame for further use",
                "title": "Summary of scrape_season_stats Function (with Advanced Stats Columns)",
                "medium_unstructured": "The scrape_season_stats function downloads NBA per-game statistics for a specified year from Basketball Reference. It cleans the data by removing duplicate header rows and keeps only relevant columns for each player, now expanded to include BPM and WS/48 advanced stats. The function returns a DataFrame containing player names, year, key stats like points, assists, rebounds, field goal percentage, and the new advanced metrics.",
                "medium_structured": "• Downloads per-game NBA stats for a given year from Basketball Reference\n• Removes repeated header rows from the data\n• Keeps only the columns: Player, Year, PTS, AST, TRB, FG%, BPM, and WS/48 (with BPM and WS/48 newly added)\n• Drops rows with missing values in key stat columns (now also including BPM and WS/48)\n• Returns the cleaned DataFrame",
                "low_unstructured": "This function retrieves and processes NBA player per-game statistics for a given year, now including advanced stats columns BPM and WS/48 in addition to the original stats."
            },
            "new_code": "def scrape_season_stats(year):\n    base_url_adv = (\n        f\"https://www.basketball-reference.com/leagues/NBA_{year}_advanced.html\"\n    )\n    df_adv = pd.read_html(base_url_adv, header=0)[0]\n    df_adv = df_adv[df_adv[\"Player\"] != \"Player\"]  # remove repeated header rows\n    df_adv[\"Year\"] = year\n\n    df_adv = df_adv[\n        [\"Player\", \"Year\", \"PTS\", \"AST\", \"TRB\", \"FG%\", \"BPM\", \"WS/48\"]\n    ]  # Keep only specified columns\n    df_adv = df_adv.dropna(\n        subset=[\"PTS\", \"AST\", \"TRB\", \"FG%\", \"BPM\", \"WS/48\"]\n    )  # Ensure key stats aren't invalid\n    return df_adv"
        },
        "event": "summarize_modified_code",
        "id": "Fy6ZNK6m9rKa40eBXsww"
    },
    {
        "source": "backend",
        "timestamp": "2025-08-23 14:11:56.000",
        "data": {
            "summary": "• Downloads per-game NBA stats for a given year from Basketball Reference\n• Removes repeated header rows from the data\n• Keeps only the columns: Player, Year, PTS, AST, TRB, FG%, BPM, and WS/48 (with BPM and WS/48 newly added)\n• Drops rows with missing values in key stat columns (now also including BPM and WS/48)\n• Returns the cleaned DataFrame",
            "code": "22: def scrape_season_stats(year):\n23:     base_url_adv = (\n24:         f\"https://www.basketball-reference.com/leagues/NBA_{year}_advanced.html\"\n25:     )\n26:     df_adv = pd.read_html(base_url_adv, header=0)[0]\n27:     df_adv = df_adv[df_adv[\"Player\"] != \"Player\"]  # remove repeated header rows\n28:     df_adv[\"Year\"] = year\n29: \n30:     df_adv = df_adv[\n31:         [\"Player\", \"Year\", \"PTS\", \"AST\", \"TRB\", \"FG%\", \"BPM\", \"WS/48\"]\n32:     ]  # Keep only specified columns\n33:     df_adv = df_adv.dropna(\n34:         subset=[\"PTS\", \"AST\", \"TRB\", \"FG%\", \"BPM\", \"WS/48\"]\n35:     )  # Ensure key stats aren't invalid\n36:     return df_adv",
            "mapping": [
                {
                    "codeSegments": [
                        {
                            "line": 23,
                            "code": "base_url_adv = (\n    f\"https://www.basketball-reference.com/leagues/NBA_{year}_advanced.html\"\n)"
                        },
                        {
                            "line": 26,
                            "code": "df_adv = pd.read_html(base_url_adv, header=0)[0]"
                        }
                    ],
                    "summaryComponent": "Downloads per-game NBA stats for a given year from Basketball Reference"
                },
                {
                    "codeSegments": [
                        {
                            "line": 27,
                            "code": "df_adv = df_adv[df_adv[\"Player\"] != \"Player\"]  # remove repeated header rows"
                        }
                    ],
                    "summaryComponent": "Removes repeated header rows from the data"
                },
                {
                    "codeSegments": [
                        {
                            "line": 30,
                            "code": "df_adv = df_adv[\n    [\"Player\", \"Year\", \"PTS\", \"AST\", \"TRB\", \"FG%\", \"BPM\", \"WS/48\"]\n]"
                        }
                    ],
                    "summaryComponent": "Keeps only the columns: Player, Year, PTS, AST, TRB, FG%, BPM, and WS/48 (with BPM and WS/48 newly added)"
                },
                {
                    "codeSegments": [
                        {
                            "line": 33,
                            "code": "df_adv = df_adv.dropna(\n    subset=[\"PTS\", \"AST\", \"TRB\", \"FG%\", \"BPM\", \"WS/48\"]\n)"
                        }
                    ],
                    "summaryComponent": "Drops rows with missing values in key stat columns (now also including BPM and WS/48)"
                },
                {
                    "codeSegments": [
                        {
                            "line": 36,
                            "code": "return df_adv"
                        }
                    ],
                    "summaryComponent": "Returns the cleaned DataFrame"
                }
            ]
        },
        "event": "map_summary_code",
        "id": "pFvt0li9SXOKPgZAJJus"
    },
    {
        "source": "backend",
        "timestamp": "2025-08-23 14:11:56.000",
        "data": {
            "summary": "This function retrieves and processes NBA player per-game statistics for a given year, now including advanced stats columns BPM and WS/48 in addition to the original stats.",
            "code": "22: def scrape_season_stats(year):\n23:     base_url_adv = (\n24:         f\"https://www.basketball-reference.com/leagues/NBA_{year}_advanced.html\"\n25:     )\n26:     df_adv = pd.read_html(base_url_adv, header=0)[0]\n27:     df_adv = df_adv[df_adv[\"Player\"] != \"Player\"]  # remove repeated header rows\n28:     df_adv[\"Year\"] = year\n29: \n30:     df_adv = df_adv[\n31:         [\"Player\", \"Year\", \"PTS\", \"AST\", \"TRB\", \"FG%\", \"BPM\", \"WS/48\"]\n32:     ]  # Keep only specified columns\n33:     df_adv = df_adv.dropna(\n34:         subset=[\"PTS\", \"AST\", \"TRB\", \"FG%\", \"BPM\", \"WS/48\"]\n35:     )  # Ensure key stats aren't invalid\n36:     return df_adv",
            "mapping": [
                {
                    "codeSegments": [
                        {
                            "line": 22,
                            "code": "def scrape_season_stats(year):"
                        },
                        {
                            "line": 26,
                            "code": "df_adv = pd.read_html(base_url_adv, header=0)[0]"
                        },
                        {
                            "line": 27,
                            "code": "df_adv = df_adv[df_adv[\"Player\"] != \"Player\"]  # remove repeated header rows"
                        }
                    ],
                    "summaryComponent": "retrieves and processes NBA player per-game statistics"
                },
                {
                    "codeSegments": [
                        {
                            "line": 22,
                            "code": "def scrape_season_stats(year):"
                        },
                        {
                            "line": 24,
                            "code": "f\"https://www.basketball-reference.com/leagues/NBA_{year}_advanced.html\""
                        },
                        {
                            "line": 28,
                            "code": "df_adv[\"Year\"] = year"
                        }
                    ],
                    "summaryComponent": "for a given year"
                },
                {
                    "codeSegments": [
                        {
                            "line": 31,
                            "code": "[\"Player\", \"Year\", \"PTS\", \"AST\", \"TRB\", \"FG%\", \"BPM\", \"WS/48\"]"
                        }
                    ],
                    "summaryComponent": "now including advanced stats columns BPM and WS/48"
                },
                {
                    "codeSegments": [
                        {
                            "line": 31,
                            "code": "[\"Player\", \"Year\", \"PTS\", \"AST\", \"TRB\", \"FG%\", \"BPM\", \"WS/48\"]"
                        }
                    ],
                    "summaryComponent": "in addition to the original stats"
                }
            ]
        },
        "event": "map_summary_code",
        "id": "uDOtO44urjec0LRSNvv8"
    },
    {
        "source": "backend",
        "timestamp": "2025-08-23 14:11:57.000",
        "data": {
            "summary": "• Constructs the URL for the NBA per-game stats page for the specified year\n• Reads the first table from the page using pandas\n• Cleans the data:\n  ◦ Removes rows where the 'Player' column is a repeated header\n  ◦ Adds a 'Year' column with the specified year\n• Selects only the relevant columns:\n  ◦ Player, Year, PTS, AST, TRB, FG%, BPM, WS/48 (BPM and WS/48 are newly included)\n• Drops rows with missing values in any of the key stat columns (now including BPM and WS/48)\n• Returns the cleaned and filtered DataFrame for further use",
            "code": "22: def scrape_season_stats(year):\n23:     base_url_adv = (\n24:         f\"https://www.basketball-reference.com/leagues/NBA_{year}_advanced.html\"\n25:     )\n26:     df_adv = pd.read_html(base_url_adv, header=0)[0]\n27:     df_adv = df_adv[df_adv[\"Player\"] != \"Player\"]  # remove repeated header rows\n28:     df_adv[\"Year\"] = year\n29: \n30:     df_adv = df_adv[\n31:         [\"Player\", \"Year\", \"PTS\", \"AST\", \"TRB\", \"FG%\", \"BPM\", \"WS/48\"]\n32:     ]  # Keep only specified columns\n33:     df_adv = df_adv.dropna(\n34:         subset=[\"PTS\", \"AST\", \"TRB\", \"FG%\", \"BPM\", \"WS/48\"]\n35:     )  # Ensure key stats aren't invalid\n36:     return df_adv",
            "mapping": [
                {
                    "codeSegments": [
                        {
                            "line": 23,
                            "code": "base_url_adv = ("
                        },
                        {
                            "line": 24,
                            "code": "f\"https://www.basketball-reference.com/leagues/NBA_{year}_advanced.html\""
                        }
                    ],
                    "summaryComponent": "Constructs the URL for the NBA per-game stats page for the specified year"
                },
                {
                    "codeSegments": [
                        {
                            "line": 26,
                            "code": "df_adv = pd.read_html(base_url_adv, header=0)[0]"
                        }
                    ],
                    "summaryComponent": "Reads the first table from the page using pandas"
                },
                {
                    "codeSegments": [
                        {
                            "line": 27,
                            "code": "df_adv = df_adv[df_adv[\"Player\"] != \"Player\"]  # remove repeated header rows"
                        }
                    ],
                    "summaryComponent": "Removes rows where the 'Player' column is a repeated header"
                },
                {
                    "codeSegments": [
                        {
                            "line": 28,
                            "code": "df_adv[\"Year\"] = year"
                        }
                    ],
                    "summaryComponent": "Adds a 'Year' column with the specified year"
                },
                {
                    "codeSegments": [
                        {
                            "line": 30,
                            "code": "df_adv = df_adv["
                        },
                        {
                            "line": 31,
                            "code": "[\"Player\", \"Year\", \"PTS\", \"AST\", \"TRB\", \"FG%\", \"BPM\", \"WS/48\"]"
                        }
                    ],
                    "summaryComponent": "Selects only the relevant columns:"
                },
                {
                    "codeSegments": [
                        {
                            "line": 31,
                            "code": "[\"Player\", \"Year\", \"PTS\", \"AST\", \"TRB\", \"FG%\", \"BPM\", \"WS/48\"]"
                        }
                    ],
                    "summaryComponent": "Player, Year, PTS, AST, TRB, FG%, BPM, WS/48 (BPM and WS/48 are newly included)"
                },
                {
                    "codeSegments": [
                        {
                            "line": 33,
                            "code": "df_adv = df_adv.dropna("
                        },
                        {
                            "line": 34,
                            "code": "subset=[\"PTS\", \"AST\", \"TRB\", \"FG%\", \"BPM\", \"WS/48\"]"
                        }
                    ],
                    "summaryComponent": "Drops rows with missing values in any of the key stat columns (now including BPM and WS/48)"
                },
                {
                    "codeSegments": [
                        {
                            "line": 36,
                            "code": "return df_adv"
                        }
                    ],
                    "summaryComponent": "Returns the cleaned and filtered DataFrame for further use"
                }
            ]
        },
        "event": "map_summary_code",
        "id": "DfEEpeYpWDm2pv9FctUf"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:11:57.000",
        "data": {
            "section_data": {
                "editPromptValue": "",
                "summaryData": {
                    "high_unstructured": "The scrape_season_stats function fetches per-game NBA player statistics for a specific year from Basketball Reference by constructing the appropriate URL and reading the first table from the page. It removes any repeated header rows that may appear in the data, adds a 'Year' column, and now selects the columns for player name, year, points, assists, rebounds, field goal percentage, as well as the newly included advanced stats BPM and WS/48. The function further ensures data quality by dropping any rows with missing values in the key statistical columns, now also considering BPM and WS/48. The resulting DataFrame is returned for further analysis or storage.",
                    "low_structured": "• Fetches NBA per-game stats for a specified year\n• Cleans and filters the data\n• Returns selected player statistics, now also including BPM and WS/48 columns",
                    "high_structured": "• Constructs the URL for the NBA per-game stats page for the specified year\n• Reads the first table from the page using pandas\n• Cleans the data:\n  ◦ Removes rows where the 'Player' column is a repeated header\n  ◦ Adds a 'Year' column with the specified year\n• Selects only the relevant columns:\n  ◦ Player, Year, PTS, AST, TRB, FG%, BPM, WS/48 (BPM and WS/48 are newly included)\n• Drops rows with missing values in any of the key stat columns (now including BPM and WS/48)\n• Returns the cleaned and filtered DataFrame for further use",
                    "title": "Summary of scrape_season_stats Function (with Advanced Stats Columns)",
                    "medium_unstructured": "The scrape_season_stats function downloads NBA per-game statistics for a specified year from Basketball Reference. It cleans the data by removing duplicate header rows and keeps only relevant columns for each player, now expanded to include BPM and WS/48 advanced stats. The function returns a DataFrame containing player names, year, key stats like points, assists, rebounds, field goal percentage, and the new advanced metrics.",
                    "medium_structured": "• Downloads per-game NBA stats for a given year from Basketball Reference\n• Removes repeated header rows from the data\n• Keeps only the columns: Player, Year, PTS, AST, TRB, FG%, BPM, and WS/48 (with BPM and WS/48 newly added)\n• Drops rows with missing values in key stat columns (now also including BPM and WS/48)\n• Returns the cleaned DataFrame",
                    "low_unstructured": "This function retrieves and processes NBA player per-game statistics for a given year, now including advanced stats columns BPM and WS/48 in addition to the original stats."
                },
                "selectedDetailLevel": "medium",
                "title": "Summary of scrape_season_stats Function (with Advanced Stats Columns)",
                "summaryMappings": {
                    "low_structured": [
                        {
                            "codeSegments": [
                                {
                                    "line": 22,
                                    "code": "def scrape_season_stats(year):"
                                },
                                {
                                    "line": 23,
                                    "code": "base_url_adv = ("
                                },
                                {
                                    "line": 24,
                                    "code": "f\"https://www.basketball-reference.com/leagues/NBA_{year}_advanced.html\""
                                },
                                {
                                    "line": 26,
                                    "code": "df_adv = pd.read_html(base_url_adv, header=0)[0]"
                                }
                            ],
                            "summaryComponent": "Fetches NBA per-game stats for a specified year"
                        },
                        {
                            "codeSegments": [
                                {
                                    "line": 27,
                                    "code": "df_adv = df_adv[df_adv[\"Player\"] != \"Player\"]  # remove repeated header rows"
                                },
                                {
                                    "line": 33,
                                    "code": "df_adv = df_adv.dropna("
                                },
                                {
                                    "line": 34,
                                    "code": "subset=[\"PTS\", \"AST\", \"TRB\", \"FG%\", \"BPM\", \"WS/48\"]"
                                }
                            ],
                            "summaryComponent": "Cleans and filters the data"
                        },
                        {
                            "codeSegments": [
                                {
                                    "line": 30,
                                    "code": "df_adv = df_adv["
                                },
                                {
                                    "line": 31,
                                    "code": "[\"Player\", \"Year\", \"PTS\", \"AST\", \"TRB\", \"FG%\", \"BPM\", \"WS/48\"]"
                                },
                                {
                                    "line": 36,
                                    "code": "return df_adv"
                                }
                            ],
                            "summaryComponent": "Returns selected player statistics, now also including BPM and WS/48 columns"
                        }
                    ],
                    "high_structured": [
                        {
                            "codeSegments": [
                                {
                                    "line": 23,
                                    "code": "base_url_adv = ("
                                },
                                {
                                    "line": 24,
                                    "code": "f\"https://www.basketball-reference.com/leagues/NBA_{year}_advanced.html\""
                                }
                            ],
                            "summaryComponent": "Constructs the URL for the NBA per-game stats page for the specified year"
                        },
                        {
                            "codeSegments": [
                                {
                                    "line": 26,
                                    "code": "df_adv = pd.read_html(base_url_adv, header=0)[0]"
                                }
                            ],
                            "summaryComponent": "Reads the first table from the page using pandas"
                        },
                        {
                            "codeSegments": [
                                {
                                    "line": 27,
                                    "code": "df_adv = df_adv[df_adv[\"Player\"] != \"Player\"]  # remove repeated header rows"
                                }
                            ],
                            "summaryComponent": "Removes rows where the 'Player' column is a repeated header"
                        },
                        {
                            "codeSegments": [
                                {
                                    "line": 28,
                                    "code": "df_adv[\"Year\"] = year"
                                }
                            ],
                            "summaryComponent": "Adds a 'Year' column with the specified year"
                        },
                        {
                            "codeSegments": [
                                {
                                    "line": 30,
                                    "code": "df_adv = df_adv["
                                },
                                {
                                    "line": 31,
                                    "code": "[\"Player\", \"Year\", \"PTS\", \"AST\", \"TRB\", \"FG%\", \"BPM\", \"WS/48\"]"
                                }
                            ],
                            "summaryComponent": "Selects only the relevant columns:"
                        },
                        {
                            "codeSegments": [
                                {
                                    "line": 31,
                                    "code": "[\"Player\", \"Year\", \"PTS\", \"AST\", \"TRB\", \"FG%\", \"BPM\", \"WS/48\"]"
                                }
                            ],
                            "summaryComponent": "Player, Year, PTS, AST, TRB, FG%, BPM, WS/48 (BPM and WS/48 are newly included)"
                        },
                        {
                            "codeSegments": [
                                {
                                    "line": 33,
                                    "code": "df_adv = df_adv.dropna("
                                },
                                {
                                    "line": 34,
                                    "code": "subset=[\"PTS\", \"AST\", \"TRB\", \"FG%\", \"BPM\", \"WS/48\"]"
                                }
                            ],
                            "summaryComponent": "Drops rows with missing values in any of the key stat columns (now including BPM and WS/48)"
                        },
                        {
                            "codeSegments": [
                                {
                                    "line": 36,
                                    "code": "return df_adv"
                                }
                            ],
                            "summaryComponent": "Returns the cleaned and filtered DataFrame for further use"
                        }
                    ],
                    "medium_structured": [
                        {
                            "codeSegments": [
                                {
                                    "line": 23,
                                    "code": "base_url_adv = (\n    f\"https://www.basketball-reference.com/leagues/NBA_{year}_advanced.html\"\n)"
                                },
                                {
                                    "line": 26,
                                    "code": "df_adv = pd.read_html(base_url_adv, header=0)[0]"
                                }
                            ],
                            "summaryComponent": "Downloads per-game NBA stats for a given year from Basketball Reference"
                        },
                        {
                            "codeSegments": [
                                {
                                    "line": 27,
                                    "code": "df_adv = df_adv[df_adv[\"Player\"] != \"Player\"]  # remove repeated header rows"
                                }
                            ],
                            "summaryComponent": "Removes repeated header rows from the data"
                        },
                        {
                            "codeSegments": [
                                {
                                    "line": 30,
                                    "code": "df_adv = df_adv[\n    [\"Player\", \"Year\", \"PTS\", \"AST\", \"TRB\", \"FG%\", \"BPM\", \"WS/48\"]\n]"
                                }
                            ],
                            "summaryComponent": "Keeps only the columns: Player, Year, PTS, AST, TRB, FG%, BPM, and WS/48 (with BPM and WS/48 newly added)"
                        },
                        {
                            "codeSegments": [
                                {
                                    "line": 33,
                                    "code": "df_adv = df_adv.dropna(\n    subset=[\"PTS\", \"AST\", \"TRB\", \"FG%\", \"BPM\", \"WS/48\"]\n)"
                                }
                            ],
                            "summaryComponent": "Drops rows with missing values in key stat columns (now also including BPM and WS/48)"
                        },
                        {
                            "codeSegments": [
                                {
                                    "line": 36,
                                    "code": "return df_adv"
                                }
                            ],
                            "summaryComponent": "Returns the cleaned DataFrame"
                        }
                    ],
                    "medium_unstructured": [
                        {
                            "codeSegments": [
                                {
                                    "line": 22,
                                    "code": "def scrape_season_stats(year):"
                                }
                            ],
                            "summaryComponent": "The scrape_season_stats function"
                        },
                        {
                            "codeSegments": [
                                {
                                    "line": 23,
                                    "code": "base_url_adv = ("
                                },
                                {
                                    "line": 24,
                                    "code": "f\"https://www.basketball-reference.com/leagues/NBA_{year}_advanced.html\""
                                },
                                {
                                    "line": 26,
                                    "code": "df_adv = pd.read_html(base_url_adv, header=0)[0]"
                                }
                            ],
                            "summaryComponent": "downloads NBA per-game statistics for a specified year from Basketball Reference"
                        },
                        {
                            "codeSegments": [
                                {
                                    "line": 27,
                                    "code": "df_adv = df_adv[df_adv[\"Player\"] != \"Player\"]  # remove repeated header rows"
                                }
                            ],
                            "summaryComponent": "It cleans the data by removing duplicate header rows"
                        },
                        {
                            "codeSegments": [
                                {
                                    "line": 30,
                                    "code": "df_adv = df_adv["
                                },
                                {
                                    "line": 31,
                                    "code": "[\"Player\", \"Year\", \"PTS\", \"AST\", \"TRB\", \"FG%\", \"BPM\", \"WS/48\"]"
                                }
                            ],
                            "summaryComponent": "keeps only relevant columns for each player"
                        },
                        {
                            "codeSegments": [
                                {
                                    "line": 31,
                                    "code": "\"BPM\", \"WS/48\""
                                }
                            ],
                            "summaryComponent": "now expanded to include BPM and WS/48 advanced stats"
                        },
                        {
                            "codeSegments": [
                                {
                                    "line": 36,
                                    "code": "return df_adv"
                                }
                            ],
                            "summaryComponent": "The function returns a DataFrame"
                        },
                        {
                            "codeSegments": [
                                {
                                    "line": 31,
                                    "code": "[\"Player\", \"Year\", \"PTS\", \"AST\", \"TRB\", \"FG%\", \"BPM\", \"WS/48\"]"
                                }
                            ],
                            "summaryComponent": "containing player names, year, key stats like points, assists, rebounds, field goal percentage, and the new advanced metrics"
                        }
                    ],
                    "high_unstructured": [
                        {
                            "codeSegments": [
                                {
                                    "line": 22,
                                    "code": "def scrape_season_stats(year):"
                                }
                            ],
                            "summaryComponent": "The scrape_season_stats function"
                        },
                        {
                            "codeSegments": [
                                {
                                    "line": 23,
                                    "code": "base_url_adv = (\n    f\"https://www.basketball-reference.com/leagues/NBA_{year}_advanced.html\"\n)"
                                },
                                {
                                    "line": 26,
                                    "code": "df_adv = pd.read_html(base_url_adv, header=0)[0]"
                                }
                            ],
                            "summaryComponent": "fetches per-game NBA player statistics for a specific year from Basketball Reference"
                        },
                        {
                            "codeSegments": [
                                {
                                    "line": 23,
                                    "code": "base_url_adv = (\n    f\"https://www.basketball-reference.com/leagues/NBA_{year}_advanced.html\"\n)"
                                }
                            ],
                            "summaryComponent": "by constructing the appropriate URL"
                        },
                        {
                            "codeSegments": [
                                {
                                    "line": 26,
                                    "code": "df_adv = pd.read_html(base_url_adv, header=0)[0]"
                                }
                            ],
                            "summaryComponent": "and reading the first table from the page"
                        },
                        {
                            "codeSegments": [
                                {
                                    "line": 27,
                                    "code": "df_adv = df_adv[df_adv[\"Player\"] != \"Player\"]  # remove repeated header rows"
                                }
                            ],
                            "summaryComponent": "It removes any repeated header rows that may appear in the data"
                        },
                        {
                            "codeSegments": [
                                {
                                    "line": 28,
                                    "code": "df_adv[\"Year\"] = year"
                                }
                            ],
                            "summaryComponent": "adds a 'Year' column"
                        },
                        {
                            "codeSegments": [
                                {
                                    "line": 30,
                                    "code": "df_adv = df_adv[\n    [\"Player\", \"Year\", \"PTS\", \"AST\", \"TRB\", \"FG%\", \"BPM\", \"WS/48\"]\n]"
                                }
                            ],
                            "summaryComponent": "and now selects the columns for player name, year, points, assists, rebounds, field goal percentage, as well as the newly included advanced stats BPM and WS/48"
                        },
                        {
                            "codeSegments": [
                                {
                                    "line": 33,
                                    "code": "df_adv = df_adv.dropna(\n    subset=[\"PTS\", \"AST\", \"TRB\", \"FG%\", \"BPM\", \"WS/48\"]\n)"
                                }
                            ],
                            "summaryComponent": "The function further ensures data quality by dropping any rows with missing values in the key statistical columns, now also considering BPM and WS/48"
                        },
                        {
                            "codeSegments": [
                                {
                                    "line": 36,
                                    "code": "return df_adv"
                                }
                            ],
                            "summaryComponent": "The resulting DataFrame is returned for further analysis or storage."
                        }
                    ],
                    "low_unstructured": [
                        {
                            "codeSegments": [
                                {
                                    "line": 22,
                                    "code": "def scrape_season_stats(year):"
                                },
                                {
                                    "line": 26,
                                    "code": "df_adv = pd.read_html(base_url_adv, header=0)[0]"
                                },
                                {
                                    "line": 27,
                                    "code": "df_adv = df_adv[df_adv[\"Player\"] != \"Player\"]  # remove repeated header rows"
                                }
                            ],
                            "summaryComponent": "retrieves and processes NBA player per-game statistics"
                        },
                        {
                            "codeSegments": [
                                {
                                    "line": 22,
                                    "code": "def scrape_season_stats(year):"
                                },
                                {
                                    "line": 24,
                                    "code": "f\"https://www.basketball-reference.com/leagues/NBA_{year}_advanced.html\""
                                },
                                {
                                    "line": 28,
                                    "code": "df_adv[\"Year\"] = year"
                                }
                            ],
                            "summaryComponent": "for a given year"
                        },
                        {
                            "codeSegments": [
                                {
                                    "line": 31,
                                    "code": "[\"Player\", \"Year\", \"PTS\", \"AST\", \"TRB\", \"FG%\", \"BPM\", \"WS/48\"]"
                                }
                            ],
                            "summaryComponent": "now including advanced stats columns BPM and WS/48"
                        },
                        {
                            "codeSegments": [
                                {
                                    "line": 31,
                                    "code": "[\"Player\", \"Year\", \"PTS\", \"AST\", \"TRB\", \"FG%\", \"BPM\", \"WS/48\"]"
                                }
                            ],
                            "summaryComponent": "in addition to the original stats"
                        }
                    ]
                },
                "oldSummaryData": {
                    "high_unstructured": "The scrape_season_stats function fetches per-game NBA player statistics for a specific year from Basketball Reference by constructing the appropriate URL and reading the first table from the page. It removes any repeated header rows that may appear in the data, adds a 'Year' column, and selects only the columns for player name, year, points, assists, rebounds, and field goal percentage. The function further ensures data quality by dropping any rows with missing values in the key statistical columns. The resulting DataFrame is returned for further analysis or storage.",
                    "low_structured": "• Fetches NBA per-game stats for a specified year\n• Cleans and filters the data\n• Returns selected player statistics",
                    "high_structured": "• Constructs the URL for the NBA per-game stats page for the specified year\n• Reads the first table from the page using pandas\n• Cleans the data:\n  ◦ Removes rows where the 'Player' column is a repeated header\n  ◦ Adds a 'Year' column with the specified year\n• Selects only the relevant columns:\n  ◦ Player, Year, PTS, AST, TRB, FG%\n• Drops rows with missing values in any of the key stat columns\n• Returns the cleaned and filtered DataFrame for further use",
                    "title": "Summary of scrape_season_stats Function",
                    "medium_unstructured": "The scrape_season_stats function downloads NBA per-game statistics for a specified year from Basketball Reference. It cleans the data by removing duplicate header rows and keeps only relevant columns for each player. The function returns a DataFrame containing player names, year, and key stats like points, assists, rebounds, and field goal percentage.",
                    "medium_structured": "• Downloads per-game NBA stats for a given year from Basketball Reference\n• Removes repeated header rows from the data\n• Keeps only the columns: Player, Year, PTS, AST, TRB, and FG%\n• Drops rows with missing values in key stat columns\n• Returns the cleaned DataFrame",
                    "low_unstructured": "This function retrieves and processes NBA player per-game statistics for a given year."
                },
                "metadata": {
                    "id": "80f40258-e8bb-4846-94c2-3966f69ac9d6",
                    "filename": "scraper.py",
                    "offset": 652,
                    "fullPath": "/project/workspace/scraper.py",
                    "originalCode": "def scrape_season_stats(year):\n    base_url_adv = (\n        f\"https://www.basketball-reference.com/leagues/NBA_{year}_advanced.html\"\n    )\n    df_adv = pd.read_html(base_url_adv, header=0)[0]\n    df_adv = df_adv[df_adv[\"Player\"] != \"Player\"]  # remove repeated header rows\n    df_adv[\"Year\"] = year\n\n    df_adv = df_adv[\n        [\"Player\", \"Year\", \"PTS\", \"AST\", \"TRB\", \"FG%\", \"BPM\", \"WS/48\"]\n    ]  # Keep only specified columns\n    df_adv = df_adv.dropna(\n        subset=[\"PTS\", \"AST\", \"TRB\", \"FG%\", \"BPM\", \"WS/48\"]\n    )  # Ensure key stats aren't invalid\n    return df_adv"
                },
                "createdAt": 1755987118000,
                "lines": [
                    22,
                    36
                ],
                "editPromptStructured": null,
                "selectedStructured": "unstructured",
                "editPromptDetailLevel": null
            },
            "section_id": "80f40258-e8bb-4846-94c2-3966f69ac9d6"
        },
        "event": "create_new_section",
        "id": "EAftZMI5P7AyQ0qw2cWj"
    },
    {
        "source": "backend",
        "timestamp": "2025-08-23 14:11:57.000",
        "data": {
            "summary": "The scrape_season_stats function downloads NBA per-game statistics for a specified year from Basketball Reference. It cleans the data by removing duplicate header rows and keeps only relevant columns for each player, now expanded to include BPM and WS/48 advanced stats. The function returns a DataFrame containing player names, year, key stats like points, assists, rebounds, field goal percentage, and the new advanced metrics.",
            "code": "22: def scrape_season_stats(year):\n23:     base_url_adv = (\n24:         f\"https://www.basketball-reference.com/leagues/NBA_{year}_advanced.html\"\n25:     )\n26:     df_adv = pd.read_html(base_url_adv, header=0)[0]\n27:     df_adv = df_adv[df_adv[\"Player\"] != \"Player\"]  # remove repeated header rows\n28:     df_adv[\"Year\"] = year\n29: \n30:     df_adv = df_adv[\n31:         [\"Player\", \"Year\", \"PTS\", \"AST\", \"TRB\", \"FG%\", \"BPM\", \"WS/48\"]\n32:     ]  # Keep only specified columns\n33:     df_adv = df_adv.dropna(\n34:         subset=[\"PTS\", \"AST\", \"TRB\", \"FG%\", \"BPM\", \"WS/48\"]\n35:     )  # Ensure key stats aren't invalid\n36:     return df_adv",
            "mapping": [
                {
                    "codeSegments": [
                        {
                            "line": 22,
                            "code": "def scrape_season_stats(year):"
                        }
                    ],
                    "summaryComponent": "The scrape_season_stats function"
                },
                {
                    "codeSegments": [
                        {
                            "line": 23,
                            "code": "base_url_adv = ("
                        },
                        {
                            "line": 24,
                            "code": "f\"https://www.basketball-reference.com/leagues/NBA_{year}_advanced.html\""
                        },
                        {
                            "line": 26,
                            "code": "df_adv = pd.read_html(base_url_adv, header=0)[0]"
                        }
                    ],
                    "summaryComponent": "downloads NBA per-game statistics for a specified year from Basketball Reference"
                },
                {
                    "codeSegments": [
                        {
                            "line": 27,
                            "code": "df_adv = df_adv[df_adv[\"Player\"] != \"Player\"]  # remove repeated header rows"
                        }
                    ],
                    "summaryComponent": "It cleans the data by removing duplicate header rows"
                },
                {
                    "codeSegments": [
                        {
                            "line": 30,
                            "code": "df_adv = df_adv["
                        },
                        {
                            "line": 31,
                            "code": "[\"Player\", \"Year\", \"PTS\", \"AST\", \"TRB\", \"FG%\", \"BPM\", \"WS/48\"]"
                        }
                    ],
                    "summaryComponent": "keeps only relevant columns for each player"
                },
                {
                    "codeSegments": [
                        {
                            "line": 31,
                            "code": "\"BPM\", \"WS/48\""
                        }
                    ],
                    "summaryComponent": "now expanded to include BPM and WS/48 advanced stats"
                },
                {
                    "codeSegments": [
                        {
                            "line": 36,
                            "code": "return df_adv"
                        }
                    ],
                    "summaryComponent": "The function returns a DataFrame"
                },
                {
                    "codeSegments": [
                        {
                            "line": 31,
                            "code": "[\"Player\", \"Year\", \"PTS\", \"AST\", \"TRB\", \"FG%\", \"BPM\", \"WS/48\"]"
                        }
                    ],
                    "summaryComponent": "containing player names, year, key stats like points, assists, rebounds, field goal percentage, and the new advanced metrics"
                }
            ]
        },
        "event": "map_summary_code",
        "id": "G5LqoCZVzigwKJSaT3w4"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:11:57.000",
        "data": {
            "after_section_id": "80f40258-e8bb-4846-94c2-3966f69ac9d6",
            "before_section_id": "db3307f5-ee3f-492a-bd71-efea25f4e903"
        },
        "event": "autotransit_section",
        "id": "H8QK4fiD6WxOszP9kisC"
    },
    {
        "source": "backend",
        "timestamp": "2025-08-23 14:11:57.000",
        "data": {
            "summary": "• Fetches NBA per-game stats for a specified year\n• Cleans and filters the data\n• Returns selected player statistics, now also including BPM and WS/48 columns",
            "code": "22: def scrape_season_stats(year):\n23:     base_url_adv = (\n24:         f\"https://www.basketball-reference.com/leagues/NBA_{year}_advanced.html\"\n25:     )\n26:     df_adv = pd.read_html(base_url_adv, header=0)[0]\n27:     df_adv = df_adv[df_adv[\"Player\"] != \"Player\"]  # remove repeated header rows\n28:     df_adv[\"Year\"] = year\n29: \n30:     df_adv = df_adv[\n31:         [\"Player\", \"Year\", \"PTS\", \"AST\", \"TRB\", \"FG%\", \"BPM\", \"WS/48\"]\n32:     ]  # Keep only specified columns\n33:     df_adv = df_adv.dropna(\n34:         subset=[\"PTS\", \"AST\", \"TRB\", \"FG%\", \"BPM\", \"WS/48\"]\n35:     )  # Ensure key stats aren't invalid\n36:     return df_adv",
            "mapping": [
                {
                    "codeSegments": [
                        {
                            "line": 22,
                            "code": "def scrape_season_stats(year):"
                        },
                        {
                            "line": 23,
                            "code": "base_url_adv = ("
                        },
                        {
                            "line": 24,
                            "code": "f\"https://www.basketball-reference.com/leagues/NBA_{year}_advanced.html\""
                        },
                        {
                            "line": 26,
                            "code": "df_adv = pd.read_html(base_url_adv, header=0)[0]"
                        }
                    ],
                    "summaryComponent": "Fetches NBA per-game stats for a specified year"
                },
                {
                    "codeSegments": [
                        {
                            "line": 27,
                            "code": "df_adv = df_adv[df_adv[\"Player\"] != \"Player\"]  # remove repeated header rows"
                        },
                        {
                            "line": 33,
                            "code": "df_adv = df_adv.dropna("
                        },
                        {
                            "line": 34,
                            "code": "subset=[\"PTS\", \"AST\", \"TRB\", \"FG%\", \"BPM\", \"WS/48\"]"
                        }
                    ],
                    "summaryComponent": "Cleans and filters the data"
                },
                {
                    "codeSegments": [
                        {
                            "line": 30,
                            "code": "df_adv = df_adv["
                        },
                        {
                            "line": 31,
                            "code": "[\"Player\", \"Year\", \"PTS\", \"AST\", \"TRB\", \"FG%\", \"BPM\", \"WS/48\"]"
                        },
                        {
                            "line": 36,
                            "code": "return df_adv"
                        }
                    ],
                    "summaryComponent": "Returns selected player statistics, now also including BPM and WS/48 columns"
                }
            ]
        },
        "event": "map_summary_code",
        "id": "l6ssfNO4qXqvZLQLSefK"
    },
    {
        "source": "backend",
        "timestamp": "2025-08-23 14:11:58.000",
        "data": {
            "summary": "The scrape_season_stats function fetches per-game NBA player statistics for a specific year from Basketball Reference by constructing the appropriate URL and reading the first table from the page. It removes any repeated header rows that may appear in the data, adds a 'Year' column, and now selects the columns for player name, year, points, assists, rebounds, field goal percentage, as well as the newly included advanced stats BPM and WS/48. The function further ensures data quality by dropping any rows with missing values in the key statistical columns, now also considering BPM and WS/48. The resulting DataFrame is returned for further analysis or storage.",
            "code": "22: def scrape_season_stats(year):\n23:     base_url_adv = (\n24:         f\"https://www.basketball-reference.com/leagues/NBA_{year}_advanced.html\"\n25:     )\n26:     df_adv = pd.read_html(base_url_adv, header=0)[0]\n27:     df_adv = df_adv[df_adv[\"Player\"] != \"Player\"]  # remove repeated header rows\n28:     df_adv[\"Year\"] = year\n29: \n30:     df_adv = df_adv[\n31:         [\"Player\", \"Year\", \"PTS\", \"AST\", \"TRB\", \"FG%\", \"BPM\", \"WS/48\"]\n32:     ]  # Keep only specified columns\n33:     df_adv = df_adv.dropna(\n34:         subset=[\"PTS\", \"AST\", \"TRB\", \"FG%\", \"BPM\", \"WS/48\"]\n35:     )  # Ensure key stats aren't invalid\n36:     return df_adv",
            "mapping": [
                {
                    "codeSegments": [
                        {
                            "line": 22,
                            "code": "def scrape_season_stats(year):"
                        }
                    ],
                    "summaryComponent": "The scrape_season_stats function"
                },
                {
                    "codeSegments": [
                        {
                            "line": 23,
                            "code": "base_url_adv = (\n    f\"https://www.basketball-reference.com/leagues/NBA_{year}_advanced.html\"\n)"
                        },
                        {
                            "line": 26,
                            "code": "df_adv = pd.read_html(base_url_adv, header=0)[0]"
                        }
                    ],
                    "summaryComponent": "fetches per-game NBA player statistics for a specific year from Basketball Reference"
                },
                {
                    "codeSegments": [
                        {
                            "line": 23,
                            "code": "base_url_adv = (\n    f\"https://www.basketball-reference.com/leagues/NBA_{year}_advanced.html\"\n)"
                        }
                    ],
                    "summaryComponent": "by constructing the appropriate URL"
                },
                {
                    "codeSegments": [
                        {
                            "line": 26,
                            "code": "df_adv = pd.read_html(base_url_adv, header=0)[0]"
                        }
                    ],
                    "summaryComponent": "and reading the first table from the page"
                },
                {
                    "codeSegments": [
                        {
                            "line": 27,
                            "code": "df_adv = df_adv[df_adv[\"Player\"] != \"Player\"]  # remove repeated header rows"
                        }
                    ],
                    "summaryComponent": "It removes any repeated header rows that may appear in the data"
                },
                {
                    "codeSegments": [
                        {
                            "line": 28,
                            "code": "df_adv[\"Year\"] = year"
                        }
                    ],
                    "summaryComponent": "adds a 'Year' column"
                },
                {
                    "codeSegments": [
                        {
                            "line": 30,
                            "code": "df_adv = df_adv[\n    [\"Player\", \"Year\", \"PTS\", \"AST\", \"TRB\", \"FG%\", \"BPM\", \"WS/48\"]\n]"
                        }
                    ],
                    "summaryComponent": "and now selects the columns for player name, year, points, assists, rebounds, field goal percentage, as well as the newly included advanced stats BPM and WS/48"
                },
                {
                    "codeSegments": [
                        {
                            "line": 33,
                            "code": "df_adv = df_adv.dropna(\n    subset=[\"PTS\", \"AST\", \"TRB\", \"FG%\", \"BPM\", \"WS/48\"]\n)"
                        }
                    ],
                    "summaryComponent": "The function further ensures data quality by dropping any rows with missing values in the key statistical columns, now also considering BPM and WS/48"
                },
                {
                    "codeSegments": [
                        {
                            "line": 36,
                            "code": "return df_adv"
                        }
                    ],
                    "summaryComponent": "The resulting DataFrame is returned for further analysis or storage."
                }
            ]
        },
        "event": "map_summary_code",
        "id": "XN9zn1dxMUALmkSAdykM"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:13:26.000",
        "data": {
            "detail_level": "medium",
            "section_id": "80f40258-e8bb-4846-94c2-3966f69ac9d6",
            "structured_type": "unstructured"
        },
        "event": "mapping_unhover",
        "id": "6ogdPsyvYXC2HYox3uFz"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:13:26.000",
        "data": {
            "detail_level": "medium",
            "section_id": "80f40258-e8bb-4846-94c2-3966f69ac9d6",
            "structured_type": "unstructured"
        },
        "event": "mapping_unhover",
        "id": "GZyNSRdcXPJqyNkK1dU7"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:13:26.000",
        "data": {
            "detail_level": "medium",
            "section_id": "80f40258-e8bb-4846-94c2-3966f69ac9d6",
            "structured_type": "unstructured",
            "mapping_index": 1
        },
        "event": "mapping_hover",
        "id": "NPyMO6XHerj5AulYrUpR"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:13:26.000",
        "data": {
            "detail_level": "medium",
            "section_id": "80f40258-e8bb-4846-94c2-3966f69ac9d6",
            "structured_type": "unstructured"
        },
        "event": "mapping_unhover",
        "id": "QftQ5LguMiF4fDNVvTO7"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:13:26.000",
        "data": {
            "detail_level": "medium",
            "section_id": "80f40258-e8bb-4846-94c2-3966f69ac9d6",
            "structured_type": "unstructured",
            "mapping_index": 6
        },
        "event": "mapping_hover",
        "id": "X38PxWEewYEbIJf73Kuv"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:13:26.000",
        "data": {
            "detail_level": "medium",
            "section_id": "80f40258-e8bb-4846-94c2-3966f69ac9d6",
            "structured_type": "unstructured"
        },
        "event": "mapping_unhover",
        "id": "XKoGCDSHT2aGmS0w8DTF"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:13:26.000",
        "data": {
            "detail_level": "medium",
            "section_id": "80f40258-e8bb-4846-94c2-3966f69ac9d6",
            "structured_type": "unstructured",
            "mapping_index": 4
        },
        "event": "mapping_hover",
        "id": "a1FsUkemn7mtf5oSyX8f"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:13:26.000",
        "data": {
            "detail_level": "medium",
            "section_id": "80f40258-e8bb-4846-94c2-3966f69ac9d6",
            "structured_type": "unstructured",
            "mapping_index": 0
        },
        "event": "mapping_hover",
        "id": "sMVr2J4n2usu5oOdB9wl"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:13:31.000",
        "data": {},
        "event": "click_summarize_code",
        "id": "C1mvAoAdhoL1DAlsq4lJ"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:13:31.000",
        "data": {
            "detail_level": "medium",
            "section_id": "80f40258-e8bb-4846-94c2-3966f69ac9d6",
            "structured_type": "unstructured"
        },
        "event": "mapping_unhover",
        "id": "Pi634rXdHjSJo8Z45ig5"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:13:31.000",
        "data": {
            "detail_level": "medium",
            "section_id": "80f40258-e8bb-4846-94c2-3966f69ac9d6",
            "structured_type": "unstructured",
            "mapping_index": 1
        },
        "event": "mapping_hover",
        "id": "RnCAG8OmfGocfHuwIB0y"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:13:31.000",
        "data": {
            "detail_level": "medium",
            "section_id": "80f40258-e8bb-4846-94c2-3966f69ac9d6",
            "structured_type": "unstructured"
        },
        "event": "mapping_unhover",
        "id": "TndTaiLfv4xTll18c0ol"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:13:31.000",
        "data": {
            "detail_level": "medium",
            "section_id": "80f40258-e8bb-4846-94c2-3966f69ac9d6",
            "structured_type": "unstructured",
            "mapping_index": 3
        },
        "event": "mapping_hover",
        "id": "ahXkXanL0LVtIMs3lr0X"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:13:31.000",
        "data": {
            "detail_level": "medium",
            "section_id": "80f40258-e8bb-4846-94c2-3966f69ac9d6",
            "structured_type": "unstructured",
            "mapping_index": 6
        },
        "event": "mapping_hover",
        "id": "b6PVhMqu9EwLsrFhOnHJ"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:13:31.000",
        "data": {
            "detail_level": "medium",
            "section_id": "80f40258-e8bb-4846-94c2-3966f69ac9d6",
            "structured_type": "unstructured"
        },
        "event": "mapping_unhover",
        "id": "kJ2dRglaCfCLybaVtSDc"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:13:31.000",
        "data": {
            "detail_level": "medium",
            "section_id": "80f40258-e8bb-4846-94c2-3966f69ac9d6",
            "structured_type": "unstructured",
            "mapping_index": 4
        },
        "event": "mapping_hover",
        "id": "lwioebFehDovRemDZZ00"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:13:31.000",
        "data": {
            "detail_level": "medium",
            "section_id": "80f40258-e8bb-4846-94c2-3966f69ac9d6",
            "structured_type": "unstructured"
        },
        "event": "mapping_unhover",
        "id": "rDTfbb6j2tPab7tryul4"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:13:33.000",
        "data": {
            "detail_level": "medium",
            "section_id": "80f40258-e8bb-4846-94c2-3966f69ac9d6",
            "structured_type": "unstructured",
            "mapping_index": 6
        },
        "event": "mapping_hover",
        "id": "ArQLpmSnnsfx9WNPFs40"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:13:33.000",
        "data": {
            "detail_level": "medium",
            "section_id": "80f40258-e8bb-4846-94c2-3966f69ac9d6",
            "structured_type": "unstructured"
        },
        "event": "mapping_unhover",
        "id": "BvzYWj25ZS2jlhiG5NqN"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:13:33.000",
        "data": {
            "detail_level": "medium",
            "section_id": "80f40258-e8bb-4846-94c2-3966f69ac9d6",
            "structured_type": "unstructured",
            "mapping_index": 1
        },
        "event": "mapping_hover",
        "id": "MJL0MEbL8wNv6esKM9Y5"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:13:33.000",
        "data": {
            "detail_level": "medium",
            "section_id": "80f40258-e8bb-4846-94c2-3966f69ac9d6",
            "structured_type": "unstructured"
        },
        "event": "mapping_unhover",
        "id": "SOsdKYI9w2BHjUsADISU"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:13:33.000",
        "data": {
            "detail_level": "medium",
            "section_id": "80f40258-e8bb-4846-94c2-3966f69ac9d6",
            "structured_type": "unstructured",
            "mapping_index": 0
        },
        "event": "mapping_hover",
        "id": "XfDiOH0Of8JODMHhHJqv"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:13:33.000",
        "data": {
            "detail_level": "medium",
            "section_id": "80f40258-e8bb-4846-94c2-3966f69ac9d6",
            "structured_type": "unstructured"
        },
        "event": "mapping_unhover",
        "id": "aO8maqYnW4Ll6yV1ryHf"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:13:33.000",
        "data": {
            "detail_level": "medium",
            "section_id": "80f40258-e8bb-4846-94c2-3966f69ac9d6",
            "structured_type": "unstructured"
        },
        "event": "mapping_unhover",
        "id": "qRiMkPm3WDoyV2W2uJkt"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:13:33.000",
        "data": {
            "detail_level": "medium",
            "section_id": "80f40258-e8bb-4846-94c2-3966f69ac9d6",
            "structured_type": "unstructured",
            "mapping_index": 4
        },
        "event": "mapping_hover",
        "id": "s8dRujSBd5pkmQdTIYEJ"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:13:39.000",
        "data": {
            "detail_level": "medium",
            "section_id": "80f40258-e8bb-4846-94c2-3966f69ac9d6",
            "structured_type": "unstructured"
        },
        "event": "mapping_unhover",
        "id": "1dTUAtEXMI6MwcobXcVo"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:13:39.000",
        "data": {
            "detail_level": "medium",
            "section_id": "80f40258-e8bb-4846-94c2-3966f69ac9d6",
            "structured_type": "unstructured",
            "mapping_index": 6
        },
        "event": "mapping_hover",
        "id": "9A8YS9xMzrHWCtBadndP"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:13:39.000",
        "data": {
            "detail_level": "medium",
            "section_id": "80f40258-e8bb-4846-94c2-3966f69ac9d6",
            "structured_type": "unstructured",
            "mapping_index": 2
        },
        "event": "mapping_hover",
        "id": "X7s0S5gTAlnHWz8lh7J1"
    },
    {
        "source": "backend",
        "timestamp": "2025-08-23 14:13:39.000",
        "data": {
            "summary": {
                "high_unstructured": "The scrape_season_stats function takes a year as input and constructs the URL for that season's per-game NBA statistics on Basketball Reference. It reads the HTML table into a DataFrame, removes any repeated header rows, and adds a 'Year' column to the data. The function then filters the DataFrame to retain only the Player, Year, PTS, AST, TRB, and FG% columns, ensuring that all rows have valid values for these statistics by dropping any with missing data. The final cleaned DataFrame is returned, providing structured per-player stats for the specified season.",
                "low_structured": "• Scrapes NBA per-game stats for a specified year\n• Keeps only key player statistics\n• Returns cleaned data",
                "high_structured": "• Accepts a year as input and builds the corresponding Basketball Reference per-game stats URL\n• Reads the first table from the web page into a DataFrame\n  ◦ Removes rows where the 'Player' column equals 'Player' to eliminate repeated headers\n• Adds a 'Year' column to indicate the season\n• Filters the DataFrame to include only the following columns:\n  ◦ Player, Year, PTS, AST, TRB, FG%\n• Drops any rows with missing values in PTS, AST, TRB, or FG% to ensure data quality\n• Returns the cleaned DataFrame with per-player statistics for that NBA season",
                "title": "Summary of scrape_season_stats Function",
                "medium_unstructured": "The scrape_season_stats function retrieves NBA player per-game statistics from Basketball Reference for a specified year. It processes the data to remove duplicate header rows, adds the year, selects key columns, and drops rows with missing values in important stats. The function returns a cleaned DataFrame containing player names, year, and selected statistics.",
                "medium_structured": "• Fetches NBA per-game stats for a given year from Basketball Reference\n• Cleans the data by removing repeated header rows\n• Adds a 'Year' column to the DataFrame\n• Selects only the Player, Year, PTS, AST, TRB, and FG% columns\n• Drops rows with missing values in key statistics",
                "low_unstructured": "This function scrapes and processes NBA player per-game statistics for a given year."
            },
            "selected_code": "def scrape_season_stats(year):\n    base_url_reg = (\n        f\"https://www.basketball-reference.com/leagues/NBA_{year}_per_game.html\"\n    )\n    df_reg = pd.read_html(base_url_reg, header=0)[0]\n    df_reg = df_reg[df_reg[\"Player\"] != \"Player\"]  # remove repeated header rows\n    df_reg[\"Year\"] = year\n\n    df_reg = df_reg[\n        [\"Player\", \"Year\", \"PTS\", \"AST\", \"TRB\", \"FG%\"]\n    ]  # Keep only specified columns\n    df_reg = df_reg.dropna(\n        subset=[\"PTS\", \"AST\", \"TRB\", \"FG%\"]\n    )  # Ensure key stats aren't invalid\n    return df_reg\n"
        },
        "event": "summarize_selected_code",
        "id": "iVSyvTd3EEJJxnV8eGBv"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:13:39.000",
        "data": {
            "detail_level": "medium",
            "section_id": "80f40258-e8bb-4846-94c2-3966f69ac9d6",
            "structured_type": "unstructured"
        },
        "event": "mapping_unhover",
        "id": "oDoRnvrV1AGyneWdmEoi"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:13:40.000",
        "data": {
            "detail_level": "medium",
            "section_id": "80f40258-e8bb-4846-94c2-3966f69ac9d6",
            "structured_type": "unstructured"
        },
        "event": "mapping_unhover",
        "id": "2ZA7JNTokZJWwpVacgMr"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:13:40.000",
        "data": {
            "detail_level": "medium",
            "section_id": "80f40258-e8bb-4846-94c2-3966f69ac9d6",
            "structured_type": "unstructured"
        },
        "event": "mapping_unhover",
        "id": "8pepS2OiAj6Y2PKQNAxi"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:13:40.000",
        "data": {
            "detail_level": "medium",
            "section_id": "80f40258-e8bb-4846-94c2-3966f69ac9d6",
            "structured_type": "unstructured",
            "mapping_index": 2
        },
        "event": "mapping_hover",
        "id": "DN63BXkUHIII4vmLpd8p"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:13:40.000",
        "data": {
            "detail_level": "medium",
            "section_id": "80f40258-e8bb-4846-94c2-3966f69ac9d6",
            "structured_type": "unstructured"
        },
        "event": "mapping_unhover",
        "id": "HOk0fL6IbV9fOlA9Baq4"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:13:40.000",
        "data": {
            "detail_level": "medium",
            "section_id": "80f40258-e8bb-4846-94c2-3966f69ac9d6",
            "structured_type": "unstructured",
            "mapping_index": 6
        },
        "event": "mapping_hover",
        "id": "Rsr9vmR7zQGbMgv8rkOc"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:13:40.000",
        "data": {
            "detail_level": "medium",
            "section_id": "80f40258-e8bb-4846-94c2-3966f69ac9d6",
            "structured_type": "unstructured",
            "mapping_index": 1
        },
        "event": "mapping_hover",
        "id": "Ytg2H1j54StoMyeDGRet"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:13:40.000",
        "data": {
            "detail_level": "medium",
            "section_id": "80f40258-e8bb-4846-94c2-3966f69ac9d6",
            "structured_type": "unstructured",
            "mapping_index": 4
        },
        "event": "mapping_hover",
        "id": "ZRq7xCCn2cCw1yBgwX6i"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:13:40.000",
        "data": {
            "detail_level": "medium",
            "section_id": "80f40258-e8bb-4846-94c2-3966f69ac9d6",
            "structured_type": "unstructured"
        },
        "event": "mapping_unhover",
        "id": "f1OF18M02SqwCYOGxLlk"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:13:40.000",
        "data": {
            "detail_level": "medium",
            "section_id": "80f40258-e8bb-4846-94c2-3966f69ac9d6",
            "structured_type": "unstructured"
        },
        "event": "mapping_unhover",
        "id": "tRAn9PMxfKJqMnHlf65A"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:13:40.000",
        "data": {
            "detail_level": "medium",
            "section_id": "80f40258-e8bb-4846-94c2-3966f69ac9d6",
            "structured_type": "unstructured",
            "mapping_index": 5
        },
        "event": "mapping_hover",
        "id": "y9nhSvcSmkDqCZ4NMEgb"
    },
    {
        "source": "backend",
        "timestamp": "2025-08-23 14:13:41.000",
        "data": {
            "summary": "• Fetches NBA per-game stats for a given year from Basketball Reference\n• Cleans the data by removing repeated header rows\n• Adds a 'Year' column to the DataFrame\n• Selects only the Player, Year, PTS, AST, TRB, and FG% columns\n• Drops rows with missing values in key statistics",
            "code": "22: def scrape_season_stats(year):\n23:     base_url_reg = (\n24:         f\"https://www.basketball-reference.com/leagues/NBA_{year}_per_game.html\"\n25:     )\n26:     df_reg = pd.read_html(base_url_reg, header=0)[0]\n27:     df_reg = df_reg[df_reg[\"Player\"] != \"Player\"]  # remove repeated header rows\n28:     df_reg[\"Year\"] = year\n29: \n30:     df_reg = df_reg[\n31:         [\"Player\", \"Year\", \"PTS\", \"AST\", \"TRB\", \"FG%\"]\n32:     ]  # Keep only specified columns\n33:     df_reg = df_reg.dropna(\n34:         subset=[\"PTS\", \"AST\", \"TRB\", \"FG%\"]\n35:     )  # Ensure key stats aren't invalid\n36:     return df_reg\n37: ",
            "mapping": [
                {
                    "codeSegments": [
                        {
                            "line": 23,
                            "code": "base_url_reg = (\n    f\"https://www.basketball-reference.com/leagues/NBA_{year}_per_game.html\"\n)"
                        },
                        {
                            "line": 26,
                            "code": "df_reg = pd.read_html(base_url_reg, header=0)[0]"
                        }
                    ],
                    "summaryComponent": "Fetches NBA per-game stats for a given year from Basketball Reference"
                },
                {
                    "codeSegments": [
                        {
                            "line": 27,
                            "code": "df_reg = df_reg[df_reg[\"Player\"] != \"Player\"]  # remove repeated header rows"
                        }
                    ],
                    "summaryComponent": "Cleans the data by removing repeated header rows"
                },
                {
                    "codeSegments": [
                        {
                            "line": 28,
                            "code": "df_reg[\"Year\"] = year"
                        }
                    ],
                    "summaryComponent": "Adds a 'Year' column to the DataFrame"
                },
                {
                    "codeSegments": [
                        {
                            "line": 30,
                            "code": "df_reg = df_reg[\n    [\"Player\", \"Year\", \"PTS\", \"AST\", \"TRB\", \"FG%\"]\n]"
                        }
                    ],
                    "summaryComponent": "Selects only the Player, Year, PTS, AST, TRB, and FG% columns"
                },
                {
                    "codeSegments": [
                        {
                            "line": 33,
                            "code": "df_reg = df_reg.dropna(\n    subset=[\"PTS\", \"AST\", \"TRB\", \"FG%\"]\n)"
                        }
                    ],
                    "summaryComponent": "Drops rows with missing values in key statistics"
                }
            ]
        },
        "event": "map_summary_code",
        "id": "ZpDsftkZvs0dysnGS5js"
    },
    {
        "source": "backend",
        "timestamp": "2025-08-23 14:13:41.000",
        "data": {
            "summary": "• Scrapes NBA per-game stats for a specified year\n• Keeps only key player statistics\n• Returns cleaned data",
            "code": "22: def scrape_season_stats(year):\n23:     base_url_reg = (\n24:         f\"https://www.basketball-reference.com/leagues/NBA_{year}_per_game.html\"\n25:     )\n26:     df_reg = pd.read_html(base_url_reg, header=0)[0]\n27:     df_reg = df_reg[df_reg[\"Player\"] != \"Player\"]  # remove repeated header rows\n28:     df_reg[\"Year\"] = year\n29: \n30:     df_reg = df_reg[\n31:         [\"Player\", \"Year\", \"PTS\", \"AST\", \"TRB\", \"FG%\"]\n32:     ]  # Keep only specified columns\n33:     df_reg = df_reg.dropna(\n34:         subset=[\"PTS\", \"AST\", \"TRB\", \"FG%\"]\n35:     )  # Ensure key stats aren't invalid\n36:     return df_reg\n37: ",
            "mapping": [
                {
                    "codeSegments": [
                        {
                            "line": 22,
                            "code": "def scrape_season_stats(year):"
                        },
                        {
                            "line": 23,
                            "code": "base_url_reg = (\n    f\"https://www.basketball-reference.com/leagues/NBA_{year}_per_game.html\"\n)"
                        },
                        {
                            "line": 26,
                            "code": "df_reg = pd.read_html(base_url_reg, header=0)[0]"
                        }
                    ],
                    "summaryComponent": "Scrapes NBA per-game stats for a specified year"
                },
                {
                    "codeSegments": [
                        {
                            "line": 30,
                            "code": "df_reg = df_reg[\n    [\"Player\", \"Year\", \"PTS\", \"AST\", \"TRB\", \"FG%\"]\n]"
                        }
                    ],
                    "summaryComponent": "Keeps only key player statistics"
                },
                {
                    "codeSegments": [
                        {
                            "line": 33,
                            "code": "df_reg = df_reg.dropna(\n    subset=[\"PTS\", \"AST\", \"TRB\", \"FG%\"]\n)"
                        },
                        {
                            "line": 36,
                            "code": "return df_reg"
                        }
                    ],
                    "summaryComponent": "Returns cleaned data"
                }
            ]
        },
        "event": "map_summary_code",
        "id": "tRQOIliGTFxvzgVQKho5"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:13:42.000",
        "data": {
            "detail_level": "medium",
            "section_id": "d2d7491d-a066-44a9-9aed-d0392ced7ca7",
            "structured_type": "unstructured"
        },
        "event": "mapping_unhover",
        "id": "0HaOah1hXW3cNtzKdQM4"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:13:42.000",
        "data": {
            "detail_level": "medium",
            "section_id": "d2d7491d-a066-44a9-9aed-d0392ced7ca7",
            "structured_type": "unstructured"
        },
        "event": "mapping_unhover",
        "id": "6nPgTU4MNVc53rWA3ftY"
    },
    {
        "source": "backend",
        "timestamp": "2025-08-23 14:13:42.000",
        "data": {
            "summary": "This function scrapes and processes NBA player per-game statistics for a given year.",
            "code": "22: def scrape_season_stats(year):\n23:     base_url_reg = (\n24:         f\"https://www.basketball-reference.com/leagues/NBA_{year}_per_game.html\"\n25:     )\n26:     df_reg = pd.read_html(base_url_reg, header=0)[0]\n27:     df_reg = df_reg[df_reg[\"Player\"] != \"Player\"]  # remove repeated header rows\n28:     df_reg[\"Year\"] = year\n29: \n30:     df_reg = df_reg[\n31:         [\"Player\", \"Year\", \"PTS\", \"AST\", \"TRB\", \"FG%\"]\n32:     ]  # Keep only specified columns\n33:     df_reg = df_reg.dropna(\n34:         subset=[\"PTS\", \"AST\", \"TRB\", \"FG%\"]\n35:     )  # Ensure key stats aren't invalid\n36:     return df_reg\n37: ",
            "mapping": [
                {
                    "codeSegments": [
                        {
                            "line": 22,
                            "code": "def scrape_season_stats(year):"
                        }
                    ],
                    "summaryComponent": "This function"
                },
                {
                    "codeSegments": [
                        {
                            "line": 26,
                            "code": "df_reg = pd.read_html(base_url_reg, header=0)[0]"
                        }
                    ],
                    "summaryComponent": "scrapes"
                },
                {
                    "codeSegments": [
                        {
                            "line": 27,
                            "code": "df_reg = df_reg[df_reg[\"Player\"] != \"Player\"]  # remove repeated header rows"
                        },
                        {
                            "line": 28,
                            "code": "df_reg[\"Year\"] = year"
                        },
                        {
                            "line": 30,
                            "code": "df_reg = df_reg[\n    [\"Player\", \"Year\", \"PTS\", \"AST\", \"TRB\", \"FG%\"]\n]"
                        },
                        {
                            "line": 33,
                            "code": "df_reg = df_reg.dropna(\n    subset=[\"PTS\", \"AST\", \"TRB\", \"FG%\"]\n)"
                        }
                    ],
                    "summaryComponent": "processes"
                },
                {
                    "codeSegments": [
                        {
                            "line": 24,
                            "code": "f\"https://www.basketball-reference.com/leagues/NBA_{year}_per_game.html\""
                        }
                    ],
                    "summaryComponent": "NBA player per-game statistics"
                },
                {
                    "codeSegments": [
                        {
                            "line": 22,
                            "code": "def scrape_season_stats(year):"
                        },
                        {
                            "line": 28,
                            "code": "df_reg[\"Year\"] = year"
                        }
                    ],
                    "summaryComponent": "for a given year"
                }
            ]
        },
        "event": "map_summary_code",
        "id": "CCzbx7RdUKkYRCxz8s4V"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:13:42.000",
        "data": {
            "detail_level": "medium",
            "section_id": "d2d7491d-a066-44a9-9aed-d0392ced7ca7",
            "structured_type": "unstructured"
        },
        "event": "mapping_unhover",
        "id": "IM0aQyDQbOdFEHabPSDC"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:13:42.000",
        "data": {
            "detail_level": "medium",
            "section_id": "d2d7491d-a066-44a9-9aed-d0392ced7ca7",
            "structured_type": "unstructured",
            "mapping_index": 3
        },
        "event": "mapping_hover",
        "id": "NM7SNFoBBurhsOUnDfTw"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:13:42.000",
        "data": {
            "detail_level": "medium",
            "section_id": "d2d7491d-a066-44a9-9aed-d0392ced7ca7",
            "structured_type": "unstructured",
            "mapping_index": 5
        },
        "event": "mapping_hover",
        "id": "QzR7uiGC1AEWe8gZts2u"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:13:42.000",
        "data": {
            "after_section_id": "d2d7491d-a066-44a9-9aed-d0392ced7ca7",
            "before_section_id": "80f40258-e8bb-4846-94c2-3966f69ac9d6"
        },
        "event": "autotransit_section",
        "id": "UenjB9igMY88B2DucBnJ"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:13:42.000",
        "data": {
            "detail_level": "medium",
            "section_id": "d2d7491d-a066-44a9-9aed-d0392ced7ca7",
            "structured_type": "unstructured",
            "mapping_index": 0
        },
        "event": "mapping_hover",
        "id": "WDYa7gUIadWyBjVyhhSm"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:13:42.000",
        "data": {
            "detail_level": "medium",
            "section_id": "d2d7491d-a066-44a9-9aed-d0392ced7ca7",
            "structured_type": "unstructured",
            "mapping_index": 7
        },
        "event": "mapping_hover",
        "id": "ds7JySFBrSayJOwBvwBI"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:13:42.000",
        "data": {
            "detail_level": "medium",
            "section_id": "d2d7491d-a066-44a9-9aed-d0392ced7ca7",
            "structured_type": "unstructured"
        },
        "event": "mapping_unhover",
        "id": "gRXAjoRmp71w50LKcTlS"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:13:42.000",
        "data": {
            "detail_level": "medium",
            "section_id": "d2d7491d-a066-44a9-9aed-d0392ced7ca7",
            "structured_type": "unstructured",
            "mapping_index": 1
        },
        "event": "mapping_hover",
        "id": "pcNt97DC0z6zAezmrC8O"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:13:42.000",
        "data": {
            "detail_level": "medium",
            "section_id": "d2d7491d-a066-44a9-9aed-d0392ced7ca7",
            "structured_type": "unstructured"
        },
        "event": "mapping_unhover",
        "id": "seaRLQY897M59EifD6Mq"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:13:42.000",
        "data": {
            "section_data": {
                "editPromptValue": "",
                "summaryData": {
                    "high_unstructured": "The scrape_season_stats function takes a year as input and constructs the URL for that season's per-game NBA statistics on Basketball Reference. It reads the HTML table into a DataFrame, removes any repeated header rows, and adds a 'Year' column to the data. The function then filters the DataFrame to retain only the Player, Year, PTS, AST, TRB, and FG% columns, ensuring that all rows have valid values for these statistics by dropping any with missing data. The final cleaned DataFrame is returned, providing structured per-player stats for the specified season.",
                    "low_structured": "• Scrapes NBA per-game stats for a specified year\n• Keeps only key player statistics\n• Returns cleaned data",
                    "high_structured": "• Accepts a year as input and builds the corresponding Basketball Reference per-game stats URL\n• Reads the first table from the web page into a DataFrame\n  ◦ Removes rows where the 'Player' column equals 'Player' to eliminate repeated headers\n• Adds a 'Year' column to indicate the season\n• Filters the DataFrame to include only the following columns:\n  ◦ Player, Year, PTS, AST, TRB, FG%\n• Drops any rows with missing values in PTS, AST, TRB, or FG% to ensure data quality\n• Returns the cleaned DataFrame with per-player statistics for that NBA season",
                    "title": "Summary of scrape_season_stats Function",
                    "medium_unstructured": "The scrape_season_stats function retrieves NBA player per-game statistics from Basketball Reference for a specified year. It processes the data to remove duplicate header rows, adds the year, selects key columns, and drops rows with missing values in important stats. The function returns a cleaned DataFrame containing player names, year, and selected statistics.",
                    "medium_structured": "• Fetches NBA per-game stats for a given year from Basketball Reference\n• Cleans the data by removing repeated header rows\n• Adds a 'Year' column to the DataFrame\n• Selects only the Player, Year, PTS, AST, TRB, and FG% columns\n• Drops rows with missing values in key statistics",
                    "low_unstructured": "This function scrapes and processes NBA player per-game statistics for a given year."
                },
                "selectedDetailLevel": "medium",
                "title": "Summary of scrape_season_stats Function",
                "summaryMappings": {
                    "low_structured": [
                        {
                            "codeSegments": [
                                {
                                    "line": 22,
                                    "code": "def scrape_season_stats(year):"
                                },
                                {
                                    "line": 23,
                                    "code": "base_url_reg = (\n    f\"https://www.basketball-reference.com/leagues/NBA_{year}_per_game.html\"\n)"
                                },
                                {
                                    "line": 26,
                                    "code": "df_reg = pd.read_html(base_url_reg, header=0)[0]"
                                }
                            ],
                            "summaryComponent": "Scrapes NBA per-game stats for a specified year"
                        },
                        {
                            "codeSegments": [
                                {
                                    "line": 30,
                                    "code": "df_reg = df_reg[\n    [\"Player\", \"Year\", \"PTS\", \"AST\", \"TRB\", \"FG%\"]\n]"
                                }
                            ],
                            "summaryComponent": "Keeps only key player statistics"
                        },
                        {
                            "codeSegments": [
                                {
                                    "line": 33,
                                    "code": "df_reg = df_reg.dropna(\n    subset=[\"PTS\", \"AST\", \"TRB\", \"FG%\"]\n)"
                                },
                                {
                                    "line": 36,
                                    "code": "return df_reg"
                                }
                            ],
                            "summaryComponent": "Returns cleaned data"
                        }
                    ],
                    "high_structured": [
                        {
                            "codeSegments": [
                                {
                                    "line": 22,
                                    "code": "def scrape_season_stats(year):"
                                },
                                {
                                    "line": 23,
                                    "code": "base_url_reg = ("
                                },
                                {
                                    "line": 24,
                                    "code": "f\"https://www.basketball-reference.com/leagues/NBA_{year}_per_game.html\""
                                }
                            ],
                            "summaryComponent": "Accepts a year as input and builds the corresponding Basketball Reference per-game stats URL"
                        },
                        {
                            "codeSegments": [
                                {
                                    "line": 26,
                                    "code": "df_reg = pd.read_html(base_url_reg, header=0)[0]"
                                }
                            ],
                            "summaryComponent": "Reads the first table from the web page into a DataFrame"
                        },
                        {
                            "codeSegments": [
                                {
                                    "line": 27,
                                    "code": "df_reg = df_reg[df_reg[\"Player\"] != \"Player\"]  # remove repeated header rows"
                                }
                            ],
                            "summaryComponent": "Removes rows where the 'Player' column equals 'Player' to eliminate repeated headers"
                        },
                        {
                            "codeSegments": [
                                {
                                    "line": 28,
                                    "code": "df_reg[\"Year\"] = year"
                                }
                            ],
                            "summaryComponent": "Adds a 'Year' column to indicate the season"
                        },
                        {
                            "codeSegments": [
                                {
                                    "line": 30,
                                    "code": "df_reg = df_reg["
                                },
                                {
                                    "line": 31,
                                    "code": "[\"Player\", \"Year\", \"PTS\", \"AST\", \"TRB\", \"FG%\"]"
                                }
                            ],
                            "summaryComponent": "Filters the DataFrame to include only the following columns:"
                        },
                        {
                            "codeSegments": [
                                {
                                    "line": 31,
                                    "code": "[\"Player\", \"Year\", \"PTS\", \"AST\", \"TRB\", \"FG%\"]"
                                }
                            ],
                            "summaryComponent": "Player, Year, PTS, AST, TRB, FG%"
                        },
                        {
                            "codeSegments": [
                                {
                                    "line": 33,
                                    "code": "df_reg = df_reg.dropna("
                                },
                                {
                                    "line": 34,
                                    "code": "subset=[\"PTS\", \"AST\", \"TRB\", \"FG%\"]"
                                }
                            ],
                            "summaryComponent": "Drops any rows with missing values in PTS, AST, TRB, or FG% to ensure data quality"
                        },
                        {
                            "codeSegments": [
                                {
                                    "line": 36,
                                    "code": "return df_reg"
                                }
                            ],
                            "summaryComponent": "Returns the cleaned DataFrame with per-player statistics for that NBA season"
                        }
                    ],
                    "medium_structured": [
                        {
                            "codeSegments": [
                                {
                                    "line": 23,
                                    "code": "base_url_reg = (\n    f\"https://www.basketball-reference.com/leagues/NBA_{year}_per_game.html\"\n)"
                                },
                                {
                                    "line": 26,
                                    "code": "df_reg = pd.read_html(base_url_reg, header=0)[0]"
                                }
                            ],
                            "summaryComponent": "Fetches NBA per-game stats for a given year from Basketball Reference"
                        },
                        {
                            "codeSegments": [
                                {
                                    "line": 27,
                                    "code": "df_reg = df_reg[df_reg[\"Player\"] != \"Player\"]  # remove repeated header rows"
                                }
                            ],
                            "summaryComponent": "Cleans the data by removing repeated header rows"
                        },
                        {
                            "codeSegments": [
                                {
                                    "line": 28,
                                    "code": "df_reg[\"Year\"] = year"
                                }
                            ],
                            "summaryComponent": "Adds a 'Year' column to the DataFrame"
                        },
                        {
                            "codeSegments": [
                                {
                                    "line": 30,
                                    "code": "df_reg = df_reg[\n    [\"Player\", \"Year\", \"PTS\", \"AST\", \"TRB\", \"FG%\"]\n]"
                                }
                            ],
                            "summaryComponent": "Selects only the Player, Year, PTS, AST, TRB, and FG% columns"
                        },
                        {
                            "codeSegments": [
                                {
                                    "line": 33,
                                    "code": "df_reg = df_reg.dropna(\n    subset=[\"PTS\", \"AST\", \"TRB\", \"FG%\"]\n)"
                                }
                            ],
                            "summaryComponent": "Drops rows with missing values in key statistics"
                        }
                    ],
                    "medium_unstructured": [
                        {
                            "codeSegments": [
                                {
                                    "line": 22,
                                    "code": "def scrape_season_stats(year):"
                                }
                            ],
                            "summaryComponent": "The scrape_season_stats function"
                        },
                        {
                            "codeSegments": [
                                {
                                    "line": 23,
                                    "code": "base_url_reg = ("
                                },
                                {
                                    "line": 24,
                                    "code": "f\"https://www.basketball-reference.com/leagues/NBA_{year}_per_game.html\""
                                },
                                {
                                    "line": 26,
                                    "code": "df_reg = pd.read_html(base_url_reg, header=0)[0]"
                                }
                            ],
                            "summaryComponent": "retrieves NBA player per-game statistics from Basketball Reference for a specified year"
                        },
                        {
                            "codeSegments": [
                                {
                                    "line": 27,
                                    "code": "df_reg = df_reg[df_reg[\"Player\"] != \"Player\"]  # remove repeated header rows"
                                }
                            ],
                            "summaryComponent": "It processes the data to remove duplicate header rows"
                        },
                        {
                            "codeSegments": [
                                {
                                    "line": 28,
                                    "code": "df_reg[\"Year\"] = year"
                                }
                            ],
                            "summaryComponent": "adds the year"
                        },
                        {
                            "codeSegments": [
                                {
                                    "line": 30,
                                    "code": "df_reg = df_reg["
                                },
                                {
                                    "line": 31,
                                    "code": "[\"Player\", \"Year\", \"PTS\", \"AST\", \"TRB\", \"FG%\"]"
                                }
                            ],
                            "summaryComponent": "selects key columns"
                        },
                        {
                            "codeSegments": [
                                {
                                    "line": 33,
                                    "code": "df_reg = df_reg.dropna("
                                },
                                {
                                    "line": 34,
                                    "code": "subset=[\"PTS\", \"AST\", \"TRB\", \"FG%\"]"
                                }
                            ],
                            "summaryComponent": "drops rows with missing values in important stats"
                        },
                        {
                            "codeSegments": [
                                {
                                    "line": 36,
                                    "code": "return df_reg"
                                }
                            ],
                            "summaryComponent": "The function returns a cleaned DataFrame"
                        },
                        {
                            "codeSegments": [
                                {
                                    "line": 31,
                                    "code": "[\"Player\", \"Year\", \"PTS\", \"AST\", \"TRB\", \"FG%\"]"
                                }
                            ],
                            "summaryComponent": "containing player names, year, and selected statistics"
                        }
                    ],
                    "high_unstructured": [
                        {
                            "codeSegments": [
                                {
                                    "line": 22,
                                    "code": "def scrape_season_stats(year):"
                                }
                            ],
                            "summaryComponent": "The scrape_season_stats function takes a year as input"
                        },
                        {
                            "codeSegments": [
                                {
                                    "line": 23,
                                    "code": "base_url_reg = ("
                                },
                                {
                                    "line": 24,
                                    "code": "f\"https://www.basketball-reference.com/leagues/NBA_{year}_per_game.html\""
                                }
                            ],
                            "summaryComponent": "constructs the URL for that season's per-game NBA statistics on Basketball Reference"
                        },
                        {
                            "codeSegments": [
                                {
                                    "line": 26,
                                    "code": "df_reg = pd.read_html(base_url_reg, header=0)[0]"
                                }
                            ],
                            "summaryComponent": "reads the HTML table into a DataFrame"
                        },
                        {
                            "codeSegments": [
                                {
                                    "line": 27,
                                    "code": "df_reg = df_reg[df_reg[\"Player\"] != \"Player\"]  # remove repeated header rows"
                                }
                            ],
                            "summaryComponent": "removes any repeated header rows"
                        },
                        {
                            "codeSegments": [
                                {
                                    "line": 28,
                                    "code": "df_reg[\"Year\"] = year"
                                }
                            ],
                            "summaryComponent": "adds a 'Year' column to the data"
                        },
                        {
                            "codeSegments": [
                                {
                                    "line": 30,
                                    "code": "df_reg = df_reg["
                                },
                                {
                                    "line": 31,
                                    "code": "[\"Player\", \"Year\", \"PTS\", \"AST\", \"TRB\", \"FG%\"]"
                                }
                            ],
                            "summaryComponent": "filters the DataFrame to retain only the Player, Year, PTS, AST, TRB, and FG% columns"
                        },
                        {
                            "codeSegments": [
                                {
                                    "line": 33,
                                    "code": "df_reg = df_reg.dropna("
                                },
                                {
                                    "line": 34,
                                    "code": "subset=[\"PTS\", \"AST\", \"TRB\", \"FG%\"]"
                                }
                            ],
                            "summaryComponent": "ensuring that all rows have valid values for these statistics by dropping any with missing data"
                        },
                        {
                            "codeSegments": [
                                {
                                    "line": 36,
                                    "code": "return df_reg"
                                }
                            ],
                            "summaryComponent": "The final cleaned DataFrame is returned"
                        },
                        {
                            "codeSegments": [
                                {
                                    "line": 36,
                                    "code": "return df_reg"
                                }
                            ],
                            "summaryComponent": "providing structured per-player stats for the specified season"
                        }
                    ],
                    "low_unstructured": [
                        {
                            "codeSegments": [
                                {
                                    "line": 22,
                                    "code": "def scrape_season_stats(year):"
                                }
                            ],
                            "summaryComponent": "This function"
                        },
                        {
                            "codeSegments": [
                                {
                                    "line": 26,
                                    "code": "df_reg = pd.read_html(base_url_reg, header=0)[0]"
                                }
                            ],
                            "summaryComponent": "scrapes"
                        },
                        {
                            "codeSegments": [
                                {
                                    "line": 27,
                                    "code": "df_reg = df_reg[df_reg[\"Player\"] != \"Player\"]  # remove repeated header rows"
                                },
                                {
                                    "line": 28,
                                    "code": "df_reg[\"Year\"] = year"
                                },
                                {
                                    "line": 30,
                                    "code": "df_reg = df_reg[\n    [\"Player\", \"Year\", \"PTS\", \"AST\", \"TRB\", \"FG%\"]\n]"
                                },
                                {
                                    "line": 33,
                                    "code": "df_reg = df_reg.dropna(\n    subset=[\"PTS\", \"AST\", \"TRB\", \"FG%\"]\n)"
                                }
                            ],
                            "summaryComponent": "processes"
                        },
                        {
                            "codeSegments": [
                                {
                                    "line": 24,
                                    "code": "f\"https://www.basketball-reference.com/leagues/NBA_{year}_per_game.html\""
                                }
                            ],
                            "summaryComponent": "NBA player per-game statistics"
                        },
                        {
                            "codeSegments": [
                                {
                                    "line": 22,
                                    "code": "def scrape_season_stats(year):"
                                },
                                {
                                    "line": 28,
                                    "code": "df_reg[\"Year\"] = year"
                                }
                            ],
                            "summaryComponent": "for a given year"
                        }
                    ]
                },
                "metadata": {
                    "id": "d2d7491d-a066-44a9-9aed-d0392ced7ca7",
                    "filename": "scraper.py",
                    "offset": 652,
                    "fullPath": "/project/workspace/scraper.py",
                    "originalCode": "def scrape_season_stats(year):\n    base_url_reg = (\n        f\"https://www.basketball-reference.com/leagues/NBA_{year}_per_game.html\"\n    )\n    df_reg = pd.read_html(base_url_reg, header=0)[0]\n    df_reg = df_reg[df_reg[\"Player\"] != \"Player\"]  # remove repeated header rows\n    df_reg[\"Year\"] = year\n\n    df_reg = df_reg[\n        [\"Player\", \"Year\", \"PTS\", \"AST\", \"TRB\", \"FG%\"]\n    ]  # Keep only specified columns\n    df_reg = df_reg.dropna(\n        subset=[\"PTS\", \"AST\", \"TRB\", \"FG%\"]\n    )  # Ensure key stats aren't invalid\n    return df_reg\n"
                },
                "createdAt": 1755987223000,
                "lines": [
                    22,
                    37
                ],
                "editPromptStructured": null,
                "selectedStructured": "unstructured",
                "editPromptDetailLevel": null
            },
            "section_id": "d2d7491d-a066-44a9-9aed-d0392ced7ca7"
        },
        "event": "create_new_section",
        "id": "tWDCNqgv8r4kt1nSdpF7"
    },
    {
        "source": "backend",
        "timestamp": "2025-08-23 14:13:43.000",
        "data": {
            "summary": "The scrape_season_stats function retrieves NBA player per-game statistics from Basketball Reference for a specified year. It processes the data to remove duplicate header rows, adds the year, selects key columns, and drops rows with missing values in important stats. The function returns a cleaned DataFrame containing player names, year, and selected statistics.",
            "code": "22: def scrape_season_stats(year):\n23:     base_url_reg = (\n24:         f\"https://www.basketball-reference.com/leagues/NBA_{year}_per_game.html\"\n25:     )\n26:     df_reg = pd.read_html(base_url_reg, header=0)[0]\n27:     df_reg = df_reg[df_reg[\"Player\"] != \"Player\"]  # remove repeated header rows\n28:     df_reg[\"Year\"] = year\n29: \n30:     df_reg = df_reg[\n31:         [\"Player\", \"Year\", \"PTS\", \"AST\", \"TRB\", \"FG%\"]\n32:     ]  # Keep only specified columns\n33:     df_reg = df_reg.dropna(\n34:         subset=[\"PTS\", \"AST\", \"TRB\", \"FG%\"]\n35:     )  # Ensure key stats aren't invalid\n36:     return df_reg\n37: ",
            "mapping": [
                {
                    "codeSegments": [
                        {
                            "line": 22,
                            "code": "def scrape_season_stats(year):"
                        }
                    ],
                    "summaryComponent": "The scrape_season_stats function"
                },
                {
                    "codeSegments": [
                        {
                            "line": 23,
                            "code": "base_url_reg = ("
                        },
                        {
                            "line": 24,
                            "code": "f\"https://www.basketball-reference.com/leagues/NBA_{year}_per_game.html\""
                        },
                        {
                            "line": 26,
                            "code": "df_reg = pd.read_html(base_url_reg, header=0)[0]"
                        }
                    ],
                    "summaryComponent": "retrieves NBA player per-game statistics from Basketball Reference for a specified year"
                },
                {
                    "codeSegments": [
                        {
                            "line": 27,
                            "code": "df_reg = df_reg[df_reg[\"Player\"] != \"Player\"]  # remove repeated header rows"
                        }
                    ],
                    "summaryComponent": "It processes the data to remove duplicate header rows"
                },
                {
                    "codeSegments": [
                        {
                            "line": 28,
                            "code": "df_reg[\"Year\"] = year"
                        }
                    ],
                    "summaryComponent": "adds the year"
                },
                {
                    "codeSegments": [
                        {
                            "line": 30,
                            "code": "df_reg = df_reg["
                        },
                        {
                            "line": 31,
                            "code": "[\"Player\", \"Year\", \"PTS\", \"AST\", \"TRB\", \"FG%\"]"
                        }
                    ],
                    "summaryComponent": "selects key columns"
                },
                {
                    "codeSegments": [
                        {
                            "line": 33,
                            "code": "df_reg = df_reg.dropna("
                        },
                        {
                            "line": 34,
                            "code": "subset=[\"PTS\", \"AST\", \"TRB\", \"FG%\"]"
                        }
                    ],
                    "summaryComponent": "drops rows with missing values in important stats"
                },
                {
                    "codeSegments": [
                        {
                            "line": 36,
                            "code": "return df_reg"
                        }
                    ],
                    "summaryComponent": "The function returns a cleaned DataFrame"
                },
                {
                    "codeSegments": [
                        {
                            "line": 31,
                            "code": "[\"Player\", \"Year\", \"PTS\", \"AST\", \"TRB\", \"FG%\"]"
                        }
                    ],
                    "summaryComponent": "containing player names, year, and selected statistics"
                }
            ]
        },
        "event": "map_summary_code",
        "id": "Lr3i7pWlVKkWkRx9feZR"
    },
    {
        "source": "backend",
        "timestamp": "2025-08-23 14:13:43.000",
        "data": {
            "summary": "The scrape_season_stats function takes a year as input and constructs the URL for that season's per-game NBA statistics on Basketball Reference. It reads the HTML table into a DataFrame, removes any repeated header rows, and adds a 'Year' column to the data. The function then filters the DataFrame to retain only the Player, Year, PTS, AST, TRB, and FG% columns, ensuring that all rows have valid values for these statistics by dropping any with missing data. The final cleaned DataFrame is returned, providing structured per-player stats for the specified season.",
            "code": "22: def scrape_season_stats(year):\n23:     base_url_reg = (\n24:         f\"https://www.basketball-reference.com/leagues/NBA_{year}_per_game.html\"\n25:     )\n26:     df_reg = pd.read_html(base_url_reg, header=0)[0]\n27:     df_reg = df_reg[df_reg[\"Player\"] != \"Player\"]  # remove repeated header rows\n28:     df_reg[\"Year\"] = year\n29: \n30:     df_reg = df_reg[\n31:         [\"Player\", \"Year\", \"PTS\", \"AST\", \"TRB\", \"FG%\"]\n32:     ]  # Keep only specified columns\n33:     df_reg = df_reg.dropna(\n34:         subset=[\"PTS\", \"AST\", \"TRB\", \"FG%\"]\n35:     )  # Ensure key stats aren't invalid\n36:     return df_reg\n37: ",
            "mapping": [
                {
                    "codeSegments": [
                        {
                            "line": 22,
                            "code": "def scrape_season_stats(year):"
                        }
                    ],
                    "summaryComponent": "The scrape_season_stats function takes a year as input"
                },
                {
                    "codeSegments": [
                        {
                            "line": 23,
                            "code": "base_url_reg = ("
                        },
                        {
                            "line": 24,
                            "code": "f\"https://www.basketball-reference.com/leagues/NBA_{year}_per_game.html\""
                        }
                    ],
                    "summaryComponent": "constructs the URL for that season's per-game NBA statistics on Basketball Reference"
                },
                {
                    "codeSegments": [
                        {
                            "line": 26,
                            "code": "df_reg = pd.read_html(base_url_reg, header=0)[0]"
                        }
                    ],
                    "summaryComponent": "reads the HTML table into a DataFrame"
                },
                {
                    "codeSegments": [
                        {
                            "line": 27,
                            "code": "df_reg = df_reg[df_reg[\"Player\"] != \"Player\"]  # remove repeated header rows"
                        }
                    ],
                    "summaryComponent": "removes any repeated header rows"
                },
                {
                    "codeSegments": [
                        {
                            "line": 28,
                            "code": "df_reg[\"Year\"] = year"
                        }
                    ],
                    "summaryComponent": "adds a 'Year' column to the data"
                },
                {
                    "codeSegments": [
                        {
                            "line": 30,
                            "code": "df_reg = df_reg["
                        },
                        {
                            "line": 31,
                            "code": "[\"Player\", \"Year\", \"PTS\", \"AST\", \"TRB\", \"FG%\"]"
                        }
                    ],
                    "summaryComponent": "filters the DataFrame to retain only the Player, Year, PTS, AST, TRB, and FG% columns"
                },
                {
                    "codeSegments": [
                        {
                            "line": 33,
                            "code": "df_reg = df_reg.dropna("
                        },
                        {
                            "line": 34,
                            "code": "subset=[\"PTS\", \"AST\", \"TRB\", \"FG%\"]"
                        }
                    ],
                    "summaryComponent": "ensuring that all rows have valid values for these statistics by dropping any with missing data"
                },
                {
                    "codeSegments": [
                        {
                            "line": 36,
                            "code": "return df_reg"
                        }
                    ],
                    "summaryComponent": "The final cleaned DataFrame is returned"
                },
                {
                    "codeSegments": [
                        {
                            "line": 36,
                            "code": "return df_reg"
                        }
                    ],
                    "summaryComponent": "providing structured per-player stats for the specified season"
                }
            ]
        },
        "event": "map_summary_code",
        "id": "ZdrvMSDBgyAackXPh5MM"
    },
    {
        "source": "backend",
        "timestamp": "2025-08-23 14:13:43.000",
        "data": {
            "summary": "• Accepts a year as input and builds the corresponding Basketball Reference per-game stats URL\n• Reads the first table from the web page into a DataFrame\n  ◦ Removes rows where the 'Player' column equals 'Player' to eliminate repeated headers\n• Adds a 'Year' column to indicate the season\n• Filters the DataFrame to include only the following columns:\n  ◦ Player, Year, PTS, AST, TRB, FG%\n• Drops any rows with missing values in PTS, AST, TRB, or FG% to ensure data quality\n• Returns the cleaned DataFrame with per-player statistics for that NBA season",
            "code": "22: def scrape_season_stats(year):\n23:     base_url_reg = (\n24:         f\"https://www.basketball-reference.com/leagues/NBA_{year}_per_game.html\"\n25:     )\n26:     df_reg = pd.read_html(base_url_reg, header=0)[0]\n27:     df_reg = df_reg[df_reg[\"Player\"] != \"Player\"]  # remove repeated header rows\n28:     df_reg[\"Year\"] = year\n29: \n30:     df_reg = df_reg[\n31:         [\"Player\", \"Year\", \"PTS\", \"AST\", \"TRB\", \"FG%\"]\n32:     ]  # Keep only specified columns\n33:     df_reg = df_reg.dropna(\n34:         subset=[\"PTS\", \"AST\", \"TRB\", \"FG%\"]\n35:     )  # Ensure key stats aren't invalid\n36:     return df_reg\n37: ",
            "mapping": [
                {
                    "codeSegments": [
                        {
                            "line": 22,
                            "code": "def scrape_season_stats(year):"
                        },
                        {
                            "line": 23,
                            "code": "base_url_reg = ("
                        },
                        {
                            "line": 24,
                            "code": "f\"https://www.basketball-reference.com/leagues/NBA_{year}_per_game.html\""
                        }
                    ],
                    "summaryComponent": "Accepts a year as input and builds the corresponding Basketball Reference per-game stats URL"
                },
                {
                    "codeSegments": [
                        {
                            "line": 26,
                            "code": "df_reg = pd.read_html(base_url_reg, header=0)[0]"
                        }
                    ],
                    "summaryComponent": "Reads the first table from the web page into a DataFrame"
                },
                {
                    "codeSegments": [
                        {
                            "line": 27,
                            "code": "df_reg = df_reg[df_reg[\"Player\"] != \"Player\"]  # remove repeated header rows"
                        }
                    ],
                    "summaryComponent": "Removes rows where the 'Player' column equals 'Player' to eliminate repeated headers"
                },
                {
                    "codeSegments": [
                        {
                            "line": 28,
                            "code": "df_reg[\"Year\"] = year"
                        }
                    ],
                    "summaryComponent": "Adds a 'Year' column to indicate the season"
                },
                {
                    "codeSegments": [
                        {
                            "line": 30,
                            "code": "df_reg = df_reg["
                        },
                        {
                            "line": 31,
                            "code": "[\"Player\", \"Year\", \"PTS\", \"AST\", \"TRB\", \"FG%\"]"
                        }
                    ],
                    "summaryComponent": "Filters the DataFrame to include only the following columns:"
                },
                {
                    "codeSegments": [
                        {
                            "line": 31,
                            "code": "[\"Player\", \"Year\", \"PTS\", \"AST\", \"TRB\", \"FG%\"]"
                        }
                    ],
                    "summaryComponent": "Player, Year, PTS, AST, TRB, FG%"
                },
                {
                    "codeSegments": [
                        {
                            "line": 33,
                            "code": "df_reg = df_reg.dropna("
                        },
                        {
                            "line": 34,
                            "code": "subset=[\"PTS\", \"AST\", \"TRB\", \"FG%\"]"
                        }
                    ],
                    "summaryComponent": "Drops any rows with missing values in PTS, AST, TRB, or FG% to ensure data quality"
                },
                {
                    "codeSegments": [
                        {
                            "line": 36,
                            "code": "return df_reg"
                        }
                    ],
                    "summaryComponent": "Returns the cleaned DataFrame with per-player statistics for that NBA season"
                }
            ]
        },
        "event": "map_summary_code",
        "id": "gwrwVIzCsxkjwKSLFHFc"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:13:44.000",
        "data": {
            "detail_level": "medium",
            "section_id": "d2d7491d-a066-44a9-9aed-d0392ced7ca7",
            "structured_type": "unstructured",
            "mapping_index": 7
        },
        "event": "mapping_hover",
        "id": "Cm7ffIDmKX9dIlNGpzCx"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:13:44.000",
        "data": {
            "detail_level": "medium",
            "section_id": "d2d7491d-a066-44a9-9aed-d0392ced7ca7",
            "structured_type": "unstructured"
        },
        "event": "mapping_unhover",
        "id": "fridyHSWSh7hoOVg8IzM"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:13:44.000",
        "data": {
            "detail_level": "medium",
            "section_id": "d2d7491d-a066-44a9-9aed-d0392ced7ca7",
            "structured_type": "unstructured",
            "mapping_index": 5
        },
        "event": "mapping_hover",
        "id": "jPTN8KSnFPUYi4JT1xIJ"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:13:45.000",
        "data": {
            "detail_level": "medium",
            "section_id": "d2d7491d-a066-44a9-9aed-d0392ced7ca7",
            "structured_type": "unstructured",
            "mapping_index": 0
        },
        "event": "mapping_hover",
        "id": "BQoimxJzsJxC3PdXD9Bi"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:13:45.000",
        "data": {
            "detail_level": "medium",
            "section_id": "d2d7491d-a066-44a9-9aed-d0392ced7ca7",
            "structured_type": "unstructured"
        },
        "event": "mapping_unhover",
        "id": "HCXZKZJV95BEsUO2NUiV"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:13:45.000",
        "data": {
            "detail_level": "medium",
            "section_id": "d2d7491d-a066-44a9-9aed-d0392ced7ca7",
            "structured_type": "unstructured"
        },
        "event": "mapping_unhover",
        "id": "MlwrcX9nXDZAHmYL5bsU"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:13:45.000",
        "data": {
            "detail_level": "medium",
            "section_id": "d2d7491d-a066-44a9-9aed-d0392ced7ca7",
            "structured_type": "unstructured",
            "mapping_index": 2
        },
        "event": "mapping_hover",
        "id": "OtYJo1VPMZqt6zBGPpWL"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:13:45.000",
        "data": {
            "detail_level": "medium",
            "section_id": "d2d7491d-a066-44a9-9aed-d0392ced7ca7",
            "structured_type": "unstructured",
            "mapping_index": 5
        },
        "event": "mapping_hover",
        "id": "SMAyIsexPZxui9JzeF2w"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:13:45.000",
        "data": {
            "detail_level": "medium",
            "section_id": "d2d7491d-a066-44a9-9aed-d0392ced7ca7",
            "structured_type": "unstructured",
            "mapping_index": 7
        },
        "event": "mapping_hover",
        "id": "UCUr2Cxv65vwGwp7Fwe8"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:13:45.000",
        "data": {
            "detail_level": "medium",
            "section_id": "d2d7491d-a066-44a9-9aed-d0392ced7ca7",
            "structured_type": "unstructured"
        },
        "event": "mapping_unhover",
        "id": "bRafUGGadnESQO9IwvHD"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:13:45.000",
        "data": {
            "detail_level": "medium",
            "section_id": "d2d7491d-a066-44a9-9aed-d0392ced7ca7",
            "structured_type": "unstructured"
        },
        "event": "mapping_unhover",
        "id": "bsBOiUIV9PqvWQlWfFZb"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:13:45.000",
        "data": {
            "detail_level": "medium",
            "section_id": "d2d7491d-a066-44a9-9aed-d0392ced7ca7",
            "structured_type": "unstructured",
            "mapping_index": 1
        },
        "event": "mapping_hover",
        "id": "g61tJbOAxv96KMuFrtky"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:13:45.000",
        "data": {
            "detail_level": "medium",
            "section_id": "d2d7491d-a066-44a9-9aed-d0392ced7ca7",
            "structured_type": "unstructured"
        },
        "event": "mapping_unhover",
        "id": "irV8cdnINI4aIbZ6C0IB"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:13:45.000",
        "data": {
            "detail_level": "medium",
            "section_id": "d2d7491d-a066-44a9-9aed-d0392ced7ca7",
            "structured_type": "unstructured",
            "mapping_index": 7
        },
        "event": "mapping_hover",
        "id": "kU2rRGmaV2LrcYymbABz"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:13:45.000",
        "data": {
            "detail_level": "medium",
            "section_id": "d2d7491d-a066-44a9-9aed-d0392ced7ca7",
            "structured_type": "unstructured"
        },
        "event": "mapping_unhover",
        "id": "pyWlVjLmgpCaWyg4U9Lk"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:13:45.000",
        "data": {
            "detail_level": "medium",
            "section_id": "d2d7491d-a066-44a9-9aed-d0392ced7ca7",
            "structured_type": "unstructured"
        },
        "event": "mapping_unhover",
        "id": "q9bUxAU0os4AIzZQLkRz"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:13:46.000",
        "data": {
            "before_detail_level": "medium",
            "before_structured": "unstructured",
            "section_id": "d2d7491d-a066-44a9-9aed-d0392ced7ca7",
            "after_detail_level": "high",
            "after_structured": "unstructured"
        },
        "event": "change_summary_level",
        "id": "fAW4knKjYMAEohDmiYlB"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:13:47.000",
        "data": {
            "detail_level": "high",
            "section_id": "d2d7491d-a066-44a9-9aed-d0392ced7ca7",
            "structured_type": "structured",
            "mapping_index": 0
        },
        "event": "mapping_hover",
        "id": "3G80vGYXlrqryVvVeRLL"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:13:47.000",
        "data": {
            "detail_level": "high",
            "section_id": "d2d7491d-a066-44a9-9aed-d0392ced7ca7",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "5ldzUot4clNtOusSK12K"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:13:47.000",
        "data": {
            "detail_level": "high",
            "section_id": "d2d7491d-a066-44a9-9aed-d0392ced7ca7",
            "structured_type": "structured",
            "mapping_index": 7
        },
        "event": "mapping_hover",
        "id": "7VOUTGLt8MtMgfLooK5S"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:13:47.000",
        "data": {
            "detail_level": "high",
            "section_id": "d2d7491d-a066-44a9-9aed-d0392ced7ca7",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "AZ7vcz7s7oGkCHln98po"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:13:47.000",
        "data": {
            "detail_level": "high",
            "section_id": "d2d7491d-a066-44a9-9aed-d0392ced7ca7",
            "structured_type": "structured",
            "mapping_index": 5
        },
        "event": "mapping_hover",
        "id": "Agy5Eyvh39pTHlx6Dshn"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:13:47.000",
        "data": {
            "detail_level": "high",
            "section_id": "d2d7491d-a066-44a9-9aed-d0392ced7ca7",
            "structured_type": "structured",
            "mapping_index": 2
        },
        "event": "mapping_hover",
        "id": "GsMTJ2wuKsyZuSxH2mue"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:13:47.000",
        "data": {
            "detail_level": "high",
            "section_id": "d2d7491d-a066-44a9-9aed-d0392ced7ca7",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "OAkA7J7q6Juwpttsocun"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:13:47.000",
        "data": {
            "detail_level": "high",
            "section_id": "d2d7491d-a066-44a9-9aed-d0392ced7ca7",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "P5kqqXjTIBNlmOalvk9n"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:13:47.000",
        "data": {
            "detail_level": "high",
            "section_id": "d2d7491d-a066-44a9-9aed-d0392ced7ca7",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "WiQgxDXhWy7ILgthntsP"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:13:47.000",
        "data": {
            "detail_level": "high",
            "section_id": "d2d7491d-a066-44a9-9aed-d0392ced7ca7",
            "structured_type": "structured",
            "mapping_index": 1
        },
        "event": "mapping_hover",
        "id": "XsdpSNLiLFOZAzTCmSkX"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:13:47.000",
        "data": {
            "detail_level": "high",
            "section_id": "d2d7491d-a066-44a9-9aed-d0392ced7ca7",
            "structured_type": "structured",
            "mapping_index": 4
        },
        "event": "mapping_hover",
        "id": "Zo68R87odZ4i1L8p0rN7"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:13:47.000",
        "data": {
            "detail_level": "high",
            "section_id": "d2d7491d-a066-44a9-9aed-d0392ced7ca7",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "bYRjWAHjhkFlZK6hrOtK"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:13:47.000",
        "data": {
            "detail_level": "high",
            "section_id": "d2d7491d-a066-44a9-9aed-d0392ced7ca7",
            "structured_type": "structured",
            "mapping_index": 3
        },
        "event": "mapping_hover",
        "id": "egDKjhMvtl0JXDclegef"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:13:47.000",
        "data": {
            "detail_level": "high",
            "section_id": "d2d7491d-a066-44a9-9aed-d0392ced7ca7",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "gjIexXXaXTpLaWqFgzd7"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:13:47.000",
        "data": {
            "detail_level": "high",
            "section_id": "d2d7491d-a066-44a9-9aed-d0392ced7ca7",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "jyIai8MbYyDfLSUn8UNY"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:13:47.000",
        "data": {
            "before_detail_level": "high",
            "before_structured": "unstructured",
            "section_id": "d2d7491d-a066-44a9-9aed-d0392ced7ca7",
            "after_detail_level": "high",
            "after_structured": "structured"
        },
        "event": "change_summary_level",
        "id": "nLzqq9DwdISwErDcEFaH"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:13:47.000",
        "data": {
            "detail_level": "high",
            "section_id": "d2d7491d-a066-44a9-9aed-d0392ced7ca7",
            "structured_type": "structured",
            "mapping_index": 6
        },
        "event": "mapping_hover",
        "id": "ufyWNhkiqarzWFXxBWGV"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:14:15.000",
        "data": {
            "detail_level": "high",
            "section_id": "d2d7491d-a066-44a9-9aed-d0392ced7ca7",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "Flth55LDlV4N8qXNMnIW"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:14:15.000",
        "data": {
            "detail_level": "high",
            "section_id": "d2d7491d-a066-44a9-9aed-d0392ced7ca7",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "exJpRwU1AWya8GJaPr6q"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:14:15.000",
        "data": {
            "detail_level": "high",
            "section_id": "d2d7491d-a066-44a9-9aed-d0392ced7ca7",
            "structured_type": "structured",
            "mapping_index": 5
        },
        "event": "mapping_hover",
        "id": "qORSCTBWCq7lE0jTCa44"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:14:15.000",
        "data": {
            "detail_level": "high",
            "section_id": "d2d7491d-a066-44a9-9aed-d0392ced7ca7",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "svyjetNu6Bah6qOUBkHI"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:14:15.000",
        "data": {
            "detail_level": "high",
            "section_id": "d2d7491d-a066-44a9-9aed-d0392ced7ca7",
            "structured_type": "structured",
            "mapping_index": 7
        },
        "event": "mapping_hover",
        "id": "tOG5BUhJh5S4GlsBiixr"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:14:15.000",
        "data": {
            "detail_level": "high",
            "section_id": "d2d7491d-a066-44a9-9aed-d0392ced7ca7",
            "structured_type": "structured",
            "mapping_index": 2
        },
        "event": "mapping_hover",
        "id": "ufnvFh55jvBbIAhA3ewx"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:14:24.000",
        "data": {
            "detail_level": "high",
            "section_id": "d2d7491d-a066-44a9-9aed-d0392ced7ca7",
            "structured_type": "structured",
            "mapping_index": 6
        },
        "event": "mapping_hover",
        "id": "3J73y8WYULVZwmjuyBqw"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:14:24.000",
        "data": {
            "detail_level": "high",
            "section_id": "d2d7491d-a066-44a9-9aed-d0392ced7ca7",
            "structured_type": "structured",
            "mapping_index": 7
        },
        "event": "mapping_hover",
        "id": "8UrGr1tbC4AsqkTZ4Q76"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:14:24.000",
        "data": {
            "detail_level": "high",
            "section_id": "d2d7491d-a066-44a9-9aed-d0392ced7ca7",
            "structured_type": "structured",
            "mapping_index": 1
        },
        "event": "mapping_hover",
        "id": "9vd3Fh6ta2mzxCL6aucx"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:14:24.000",
        "data": {
            "detail_level": "high",
            "section_id": "d2d7491d-a066-44a9-9aed-d0392ced7ca7",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "B19OvTufyKJyugo3B8yY"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:14:24.000",
        "data": {
            "detail_level": "high",
            "section_id": "d2d7491d-a066-44a9-9aed-d0392ced7ca7",
            "structured_type": "structured",
            "mapping_index": 0
        },
        "event": "mapping_hover",
        "id": "PLTBE2SQmHA9Aj0UsBwZ"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:14:24.000",
        "data": {
            "detail_level": "high",
            "section_id": "d2d7491d-a066-44a9-9aed-d0392ced7ca7",
            "structured_type": "structured",
            "mapping_index": 4
        },
        "event": "mapping_hover",
        "id": "PTgNCIVZDbpntUo1UraD"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:14:24.000",
        "data": {
            "detail_level": "high",
            "section_id": "d2d7491d-a066-44a9-9aed-d0392ced7ca7",
            "structured_type": "structured",
            "mapping_index": 3
        },
        "event": "mapping_hover",
        "id": "PsZum50D8wMVMuor4pnN"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:14:24.000",
        "data": {
            "detail_level": "high",
            "section_id": "d2d7491d-a066-44a9-9aed-d0392ced7ca7",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "SR7jINtRZvHB6gHwlMtH"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:14:24.000",
        "data": {
            "detail_level": "high",
            "section_id": "d2d7491d-a066-44a9-9aed-d0392ced7ca7",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "TvFzAwRxkridUJAtC1rS"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:14:24.000",
        "data": {
            "detail_level": "high",
            "section_id": "d2d7491d-a066-44a9-9aed-d0392ced7ca7",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "YEEEB1wZgiARBLPRaWxw"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:14:24.000",
        "data": {
            "detail_level": "high",
            "section_id": "d2d7491d-a066-44a9-9aed-d0392ced7ca7",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "aP4TvbeGGIOrxOoEleHh"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:14:24.000",
        "data": {
            "detail_level": "high",
            "section_id": "d2d7491d-a066-44a9-9aed-d0392ced7ca7",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "ry9KdqtbESwjO2yi28na"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:14:27.000",
        "data": {
            "detail_level": "high",
            "section_id": "d2d7491d-a066-44a9-9aed-d0392ced7ca7",
            "structured_type": "structured",
            "mapping_index": 0
        },
        "event": "mapping_hover",
        "id": "VHzxriKi6HIJY8BuV0Sh"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:14:27.000",
        "data": {
            "detail_level": "high",
            "section_id": "d2d7491d-a066-44a9-9aed-d0392ced7ca7",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "x5JGh9rsPK1gCVFFI6AV"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:14:28.000",
        "data": {
            "detail_level": "high",
            "section_id": "d2d7491d-a066-44a9-9aed-d0392ced7ca7",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "4SixeKXtyWdPS9RxSf2N"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:14:28.000",
        "data": {
            "detail_level": "high",
            "section_id": "d2d7491d-a066-44a9-9aed-d0392ced7ca7",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "IvHKZwLTaX1jGgLUyfmU"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:14:28.000",
        "data": {
            "structured": "structured",
            "detail_level": "high",
            "summary": "• Accepts a year as input and builds the corresponding Basketball Reference per-game stats URL\n• Reads the first table from the web page into a DataFrame\n  ◦ Removes rows where the 'Player' column equals 'Player' to eliminate repeated headers\n• Adds a 'Year' column to indicate the season\n• Filters the DataFrame to include only the following columns:\n  ◦ Player, Year, PTS, AST, TRB, FG%\n• Drops any rows with missing values in PTS, AST, TRB, or FG% to ensure data quality\n• Returns the cleaned DataFrame with per-player statistics for that NBA season",
            "section_id": "d2d7491d-a066-44a9-9aed-d0392ced7ca7"
        },
        "event": "click_edit_in_prompt",
        "id": "JaQHjrDjCgmHmTw0aDzX"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:14:28.000",
        "data": {
            "detail_level": "high",
            "section_id": "d2d7491d-a066-44a9-9aed-d0392ced7ca7",
            "structured_type": "structured",
            "mapping_index": 0
        },
        "event": "mapping_hover",
        "id": "KKU8rlhx8VJCIhUmSNil"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:14:28.000",
        "data": {
            "detail_level": "high",
            "section_id": "d2d7491d-a066-44a9-9aed-d0392ced7ca7",
            "structured_type": "structured",
            "mapping_index": 2
        },
        "event": "mapping_hover",
        "id": "RcmIlDJqj94V3zDOajuq"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:14:29.000",
        "data": {
            "structured": "structured",
            "detail_level": "high",
            "instruction": "you need to scrape more attributes such as BPM and WS/48 in another url: https://www.basketball-reference.com/leagues/NBA_2025_advanced.html",
            "original_summary": "• Accepts a year as input and builds the corresponding Basketball Reference per-game stats URL\n• Reads the first table from the web page into a DataFrame\n  ◦ Removes rows where the 'Player' column equals 'Player' to eliminate repeated headers\n• Adds a 'Year' column to indicate the season\n• Filters the DataFrame to include only the following columns:\n  ◦ Player, Year, PTS, AST, TRB, FG%\n• Drops any rows with missing values in PTS, AST, TRB, or FG% to ensure data quality\n• Returns the cleaned DataFrame with per-player statistics for that NBA season",
            "section_id": "d2d7491d-a066-44a9-9aed-d0392ced7ca7"
        },
        "event": "apply_instruction_summary",
        "id": "cGRXX3R7PXYkH9fleLEO"
    },
    {
        "source": "backend",
        "timestamp": "2025-08-23 14:14:33.000",
        "data": {
            "original_code": "def scrape_season_stats(year):\n    base_url_reg = (\n        f\"https://www.basketball-reference.com/leagues/NBA_{year}_per_game.html\"\n    )\n    df_reg = pd.read_html(base_url_reg, header=0)[0]\n    df_reg = df_reg[df_reg[\"Player\"] != \"Player\"]  # remove repeated header rows\n    df_reg[\"Year\"] = year\n\n    df_reg = df_reg[\n        [\"Player\", \"Year\", \"PTS\", \"AST\", \"TRB\", \"FG%\"]\n    ]  # Keep only specified columns\n    df_reg = df_reg.dropna(\n        subset=[\"PTS\", \"AST\", \"TRB\", \"FG%\"]\n    )  # Ensure key stats aren't invalid\n    return df_reg\n",
            "instruction": "you need to scrape more attributes such as BPM and WS/48 in another url: https://www.basketball-reference.com/leagues/NBA_2025_advanced.html",
            "original_summary": "• Accepts a year as input and builds the corresponding Basketball Reference per-game stats URL\n• Reads the first table from the web page into a DataFrame\n  ◦ Removes rows where the 'Player' column equals 'Player' to eliminate repeated headers\n• Adds a 'Year' column to indicate the season\n• Filters the DataFrame to include only the following columns:\n  ◦ Player, Year, PTS, AST, TRB, FG%\n• Drops any rows with missing values in PTS, AST, TRB, or FG% to ensure data quality\n• Returns the cleaned DataFrame with per-player statistics for that NBA season",
            "updated_summary": "• Accepts a year as input and builds the corresponding Basketball Reference per-game stats URL  \n• Reads the first table from the per-game stats web page into a DataFrame  \n  ◦ Removes rows where the 'Player' column equals 'Player' to eliminate repeated headers  \n• Adds a 'Year' column to indicate the season  \n• Filters the DataFrame to include only the following columns:  \n  ◦ Player, Year, PTS, AST, TRB, FG%  \n• Drops any rows with missing values in PTS, AST, TRB, or FG% to ensure data quality  \n• Additionally, scrapes advanced statistics such as BPM and WS/48 from the advanced stats URL (https://www.basketball-reference.com/leagues/NBA_{year}_advanced.html)  \n• Integrates the BPM and WS/48 attributes into the main DataFrame, ensuring each player's statistics include these advanced metrics  \n• Returns the cleaned DataFrame with per-player statistics for that NBA season, now including BPM and WS/48"
        },
        "event": "apply_instruction_summary",
        "id": "FlAm2zr3wITN34ngeMgf"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:14:36.000",
        "data": {
            "structured": "structured",
            "detail_level": "high",
            "edited_summary": "• Accepts a year as input and builds the corresponding Basketball Reference per-game stats URL  \n• Reads the first table from the per-game stats web page into a DataFrame  \n  ◦ Removes rows where the 'Player' column equals 'Player' to eliminate repeated headers  \n• Adds a 'Year' column to indicate the season  \n• Filters the DataFrame to include only the following columns:  \n  ◦ Player, Year, PTS, AST, TRB, FG%  \n• Drops any rows with missing values in PTS, AST, TRB, or FG% to ensure data quality  \n• Additionally, scrapes advanced statistics such as BPM and WS/48 from the advanced stats URL (https://www.basketball-reference.com/leagues/NBA_{year}_advanced.html)  \n• Integrates the BPM and WS/48 attributes into the main DataFrame, ensuring each player's statistics include these advanced metrics  \n• Returns the cleaned DataFrame with per-player statistics for that NBA season, now including BPM and WS/48",
            "section_id": "d2d7491d-a066-44a9-9aed-d0392ced7ca7",
            "original_summary": "• Accepts a year as input and builds the corresponding Basketball Reference per-game stats URL\n• Reads the first table from the web page into a DataFrame\n  ◦ Removes rows where the 'Player' column equals 'Player' to eliminate repeated headers\n• Adds a 'Year' column to indicate the season\n• Filters the DataFrame to include only the following columns:\n  ◦ Player, Year, PTS, AST, TRB, FG%\n• Drops any rows with missing values in PTS, AST, TRB, or FG% to ensure data quality\n• Returns the cleaned DataFrame with per-player statistics for that NBA season"
        },
        "event": "commit_modified_summary",
        "id": "sMVimZ9rJOrwV2aUqE8H"
    },
    {
        "source": "backend",
        "timestamp": "2025-08-23 14:14:40.000",
        "data": {
            "original_code": "def scrape_season_stats(year):\n    base_url_reg = (\n        f\"https://www.basketball-reference.com/leagues/NBA_{year}_per_game.html\"\n    )\n    df_reg = pd.read_html(base_url_reg, header=0)[0]\n    df_reg = df_reg[df_reg[\"Player\"] != \"Player\"]  # remove repeated header rows\n    df_reg[\"Year\"] = year\n\n    df_reg = df_reg[\n        [\"Player\", \"Year\", \"PTS\", \"AST\", \"TRB\", \"FG%\"]\n    ]  # Keep only specified columns\n    df_reg = df_reg.dropna(\n        subset=[\"PTS\", \"AST\", \"TRB\", \"FG%\"]\n    )  # Ensure key stats aren't invalid\n    return df_reg\n",
            "updated_code": "def scrape_season_stats(year):\n    base_url_reg = (\n        f\"https://www.basketball-reference.com/leagues/NBA_{year}_per_game.html\"\n    )\n    base_url_adv = (\n        f\"https://www.basketball-reference.com/leagues/NBA_{year}_advanced.html\"\n    )\n\n    # Scrape per-game stats\n    df_reg = pd.read_html(base_url_reg, header=0)[0]\n    df_reg = df_reg[df_reg[\"Player\"] != \"Player\"]  # remove repeated header rows\n    df_reg[\"Year\"] = year\n\n    df_reg = df_reg[\n        [\"Player\", \"Year\", \"PTS\", \"AST\", \"TRB\", \"FG%\"]\n    ]  # Keep only specified columns\n    df_reg = df_reg.dropna(\n        subset=[\"PTS\", \"AST\", \"TRB\", \"FG%\"]\n    )  # Ensure key stats aren't invalid\n\n    # Scrape advanced stats (BPM, WS/48)\n    df_adv = pd.read_html(base_url_adv, header=0)[0]\n    df_adv = df_adv[df_adv[\"Player\"] != \"Player\"]  # remove repeated header rows\n    df_adv = df_adv[[\"Player\", \"BPM\", \"WS/48\"]]\n\n    # Merge advanced stats into per-game stats\n    df_merged = pd.merge(df_reg, df_adv, on=\"Player\", how=\"left\")\n\n    return df_merged",
            "detail_level": "high",
            "original_summary": "• Accepts a year as input and builds the corresponding Basketball Reference per-game stats URL\n• Reads the first table from the web page into a DataFrame\n  ◦ Removes rows where the 'Player' column equals 'Player' to eliminate repeated headers\n• Adds a 'Year' column to indicate the season\n• Filters the DataFrame to include only the following columns:\n  ◦ Player, Year, PTS, AST, TRB, FG%\n• Drops any rows with missing values in PTS, AST, TRB, or FG% to ensure data quality\n• Returns the cleaned DataFrame with per-player statistics for that NBA season",
            "edited_summary": "• Accepts a year as input and builds the corresponding Basketball Reference per-game stats URL  \n• Reads the first table from the per-game stats web page into a DataFrame  \n  ◦ Removes rows where the 'Player' column equals 'Player' to eliminate repeated headers  \n• Adds a 'Year' column to indicate the season  \n• Filters the DataFrame to include only the following columns:  \n  ◦ Player, Year, PTS, AST, TRB, FG%  \n• Drops any rows with missing values in PTS, AST, TRB, or FG% to ensure data quality  \n• Additionally, scrapes advanced statistics such as BPM and WS/48 from the advanced stats URL (https://www.basketball-reference.com/leagues/NBA_{year}_advanced.html)  \n• Integrates the BPM and WS/48 attributes into the main DataFrame, ensuring each player's statistics include these advanced metrics  \n• Returns the cleaned DataFrame with per-player statistics for that NBA season, now including BPM and WS/48",
            "structured_type": "structured"
        },
        "event": "modify_summary_mediation",
        "id": "Oj7P3B1n3vN7pTTVZA4Y"
    },
    {
        "source": "backend",
        "timestamp": "2025-08-23 14:14:50.000",
        "data": {
            "original_code": "def scrape_season_stats(year):\n    base_url_reg = (\n        f\"https://www.basketball-reference.com/leagues/NBA_{year}_per_game.html\"\n    )\n    base_url_adv = (\n        f\"https://www.basketball-reference.com/leagues/NBA_{year}_advanced.html\"\n    )\n\n    # Scrape per-game stats\n    df_reg = pd.read_html(base_url_reg, header=0)[0]\n    df_reg = df_reg[df_reg[\"Player\"] != \"Player\"]  # remove repeated header rows\n    df_reg[\"Year\"] = year\n\n    df_reg = df_reg[\n        [\"Player\", \"Year\", \"PTS\", \"AST\", \"TRB\", \"FG%\"]\n    ]  # Keep only specified columns\n    df_reg = df_reg.dropna(\n        subset=[\"PTS\", \"AST\", \"TRB\", \"FG%\"]\n    )  # Ensure key stats aren't invalid\n\n    # Scrape advanced stats (BPM, WS/48)\n    df_adv = pd.read_html(base_url_adv, header=0)[0]\n    df_adv = df_adv[df_adv[\"Player\"] != \"Player\"]  # remove repeated header rows\n    df_adv = df_adv[[\"Player\", \"BPM\", \"WS/48\"]]\n\n    # Merge advanced stats into per-game stats\n    df_merged = pd.merge(df_reg, df_adv, on=\"Player\", how=\"left\")\n\n    return df_merged",
            "old_summary": {
                "high_unstructured": "The scrape_season_stats function takes a year as input and constructs the URL for that season's per-game NBA statistics on Basketball Reference. It reads the HTML table into a DataFrame, removes any repeated header rows, and adds a 'Year' column to the data. The function then filters the DataFrame to retain only the Player, Year, PTS, AST, TRB, and FG% columns, ensuring that all rows have valid values for these statistics by dropping any with missing data. The final cleaned DataFrame is returned, providing structured per-player stats for the specified season.",
                "low_structured": "• Scrapes NBA per-game stats for a specified year\n• Keeps only key player statistics\n• Returns cleaned data",
                "high_structured": "• Accepts a year as input and builds the corresponding Basketball Reference per-game stats URL\n• Reads the first table from the web page into a DataFrame\n  ◦ Removes rows where the 'Player' column equals 'Player' to eliminate repeated headers\n• Adds a 'Year' column to indicate the season\n• Filters the DataFrame to include only the following columns:\n  ◦ Player, Year, PTS, AST, TRB, FG%\n• Drops any rows with missing values in PTS, AST, TRB, or FG% to ensure data quality\n• Returns the cleaned DataFrame with per-player statistics for that NBA season",
                "title": "Summary of scrape_season_stats Function",
                "medium_unstructured": "The scrape_season_stats function retrieves NBA player per-game statistics from Basketball Reference for a specified year. It processes the data to remove duplicate header rows, adds the year, selects key columns, and drops rows with missing values in important stats. The function returns a cleaned DataFrame containing player names, year, and selected statistics.",
                "medium_structured": "• Fetches NBA per-game stats for a given year from Basketball Reference\n• Cleans the data by removing repeated header rows\n• Adds a 'Year' column to the DataFrame\n• Selects only the Player, Year, PTS, AST, TRB, and FG% columns\n• Drops rows with missing values in key statistics",
                "low_unstructured": "This function scrapes and processes NBA player per-game statistics for a given year."
            },
            "new_summary": {
                "high_unstructured": "The scrape_season_stats function takes a year as input and constructs the URL for that season's per-game NBA statistics on Basketball Reference. It reads the HTML table into a DataFrame, removes any repeated header rows, and adds a 'Year' column to the data. The function then filters the DataFrame to retain only the Player, Year, PTS, AST, TRB, and FG% columns, ensuring that all rows have valid values for these statistics by dropping any with missing data. Additionally, the function now fetches advanced statistics (BPM and WS/48) for the same year, cleans that data, and merges it into the per-game stats DataFrame before returning the final result. The final cleaned DataFrame is returned, providing structured per-player stats and advanced metrics for the specified season.",
                "low_structured": "• Scrapes NBA per-game stats for a specified year\n• Keeps only key player statistics\n• Merges advanced stats (BPM, WS/48) into the per-game stats\n• Returns cleaned data",
                "high_structured": "• Accepts a year as input and builds the corresponding Basketball Reference per-game stats URL\n• Reads the first table from the web page into a DataFrame\n  ◦ Removes rows where the 'Player' column equals 'Player' to eliminate repeated headers\n• Adds a 'Year' column to indicate the season\n• Filters the DataFrame to include only the following columns:\n  ◦ Player, Year, PTS, AST, TRB, FG%\n• Drops any rows with missing values in PTS, AST, TRB, or FG% to ensure data quality\n• Fetches advanced stats (BPM, WS/48) from the advanced stats page for the same year\n  ◦ Removes repeated header rows and selects only Player, BPM, and WS/48 columns\n• Merges the advanced stats DataFrame into the per-game stats DataFrame on the Player column\n• Returns the cleaned DataFrame with per-player statistics and advanced metrics for that NBA season",
                "title": "Summary of scrape_season_stats Function (with Advanced Stats Merge)",
                "medium_unstructured": "The scrape_season_stats function retrieves NBA player per-game statistics from Basketball Reference for a specified year. In addition to processing the data to remove duplicate header rows, adding the year, selecting key columns, and dropping rows with missing values in important stats, the function now also fetches advanced statistics (BPM and WS/48) and merges them into the per-game stats DataFrame. The function returns a cleaned DataFrame containing player names, year, selected statistics, and advanced metrics.",
                "medium_structured": "• Fetches NBA per-game stats for a given year from Basketball Reference\n• Cleans the data by removing repeated header rows\n• Adds a 'Year' column to the DataFrame\n• Selects only the Player, Year, PTS, AST, TRB, and FG% columns\n• Drops rows with missing values in key statistics\n• Fetches advanced stats (BPM, WS/48) for the same year\n• Merges advanced stats into the per-game stats DataFrame",
                "low_unstructured": "This function scrapes and processes NBA player per-game statistics for a given year, and now also merges advanced statistics (BPM and WS/48) into the result."
            },
            "new_code": "def scrape_season_stats(year):\n    base_url_reg = (\n        f\"https://www.basketball-reference.com/leagues/NBA_{year}_per_game.html\"\n    )\n    base_url_adv = (\n        f\"https://www.basketball-reference.com/leagues/NBA_{year}_advanced.html\"\n    )\n\n    # Scrape per-game stats\n    df_reg = pd.read_html(base_url_reg, header=0)[0]\n    df_reg = df_reg[df_reg[\"Player\"] != \"Player\"]  # remove repeated header rows\n    df_reg[\"Year\"] = year\n\n    df_reg = df_reg[\n        [\"Player\", \"Year\", \"PTS\", \"AST\", \"TRB\", \"FG%\"]\n    ]  # Keep only specified columns\n    df_reg = df_reg.dropna(\n        subset=[\"PTS\", \"AST\", \"TRB\", \"FG%\"]\n    )  # Ensure key stats aren't invalid\n\n    # Scrape advanced stats (BPM, WS/48)\n    df_adv = pd.read_html(base_url_adv, header=0)[0]\n    df_adv = df_adv[df_adv[\"Player\"] != \"Player\"]  # remove repeated header rows\n    df_adv = df_adv[[\"Player\", \"BPM\", \"WS/48\"]]\n\n    # Merge advanced stats into per-game stats\n    df_merged = pd.merge(df_reg, df_adv, on=\"Player\", how=\"left\")\n\n    return df_merged"
        },
        "event": "summarize_modified_code",
        "id": "cMgzmUjMz2SUfPdIoYgG"
    },
    {
        "source": "backend",
        "timestamp": "2025-08-23 14:14:53.000",
        "data": {
            "summary": "This function scrapes and processes NBA player per-game statistics for a given year, and now also merges advanced statistics (BPM and WS/48) into the result.",
            "code": "22: def scrape_season_stats(year):\n23:     base_url_reg = (\n24:         f\"https://www.basketball-reference.com/leagues/NBA_{year}_per_game.html\"\n25:     )\n26:     base_url_adv = (\n27:         f\"https://www.basketball-reference.com/leagues/NBA_{year}_advanced.html\"\n28:     )\n29: \n30:     # Scrape per-game stats\n31:     df_reg = pd.read_html(base_url_reg, header=0)[0]\n32:     df_reg = df_reg[df_reg[\"Player\"] != \"Player\"]  # remove repeated header rows\n33:     df_reg[\"Year\"] = year\n34: \n35:     df_reg = df_reg[\n36:         [\"Player\", \"Year\", \"PTS\", \"AST\", \"TRB\", \"FG%\"]\n37:     ]  # Keep only specified columns\n38:     df_reg = df_reg.dropna(\n39:         subset=[\"PTS\", \"AST\", \"TRB\", \"FG%\"]\n40:     )  # Ensure key stats aren't invalid\n41: \n42:     # Scrape advanced stats (BPM, WS/48)\n43:     df_adv = pd.read_html(base_url_adv, header=0)[0]\n44:     df_adv = df_adv[df_adv[\"Player\"] != \"Player\"]  # remove repeated header rows\n45:     df_adv = df_adv[[\"Player\", \"BPM\", \"WS/48\"]]\n46: \n47:     # Merge advanced stats into per-game stats\n48:     df_merged = pd.merge(df_reg, df_adv, on=\"Player\", how=\"left\")\n49: \n50:     return df_merged",
            "mapping": [
                {
                    "codeSegments": [
                        {
                            "line": 22,
                            "code": "def scrape_season_stats(year):"
                        },
                        {
                            "line": 31,
                            "code": "df_reg = pd.read_html(base_url_reg, header=0)[0]"
                        },
                        {
                            "line": 32,
                            "code": "df_reg = df_reg[df_reg[\"Player\"] != \"Player\"]  # remove repeated header rows"
                        },
                        {
                            "line": 33,
                            "code": "df_reg[\"Year\"] = year"
                        },
                        {
                            "line": 35,
                            "code": "df_reg = df_reg[\n    [\"Player\", \"Year\", \"PTS\", \"AST\", \"TRB\", \"FG%\"]\n]  # Keep only specified columns"
                        },
                        {
                            "line": 38,
                            "code": "df_reg = df_reg.dropna(\n    subset=[\"PTS\", \"AST\", \"TRB\", \"FG%\"]\n)  # Ensure key stats aren't invalid"
                        }
                    ],
                    "summaryComponent": "scrapes and processes NBA player per-game statistics for a given year"
                },
                {
                    "codeSegments": [
                        {
                            "line": 43,
                            "code": "df_adv = pd.read_html(base_url_adv, header=0)[0]"
                        },
                        {
                            "line": 44,
                            "code": "df_adv = df_adv[df_adv[\"Player\"] != \"Player\"]  # remove repeated header rows"
                        },
                        {
                            "line": 45,
                            "code": "df_adv = df_adv[[\"Player\", \"BPM\", \"WS/48\"]]"
                        },
                        {
                            "line": 48,
                            "code": "df_merged = pd.merge(df_reg, df_adv, on=\"Player\", how=\"left\")"
                        }
                    ],
                    "summaryComponent": "now also merges advanced statistics (BPM and WS/48) into the result"
                }
            ]
        },
        "event": "map_summary_code",
        "id": "KusVqjXH8YYjlERAQuoY"
    },
    {
        "source": "backend",
        "timestamp": "2025-08-23 14:14:53.000",
        "data": {
            "summary": "• Scrapes NBA per-game stats for a specified year\n• Keeps only key player statistics\n• Merges advanced stats (BPM, WS/48) into the per-game stats\n• Returns cleaned data",
            "code": "22: def scrape_season_stats(year):\n23:     base_url_reg = (\n24:         f\"https://www.basketball-reference.com/leagues/NBA_{year}_per_game.html\"\n25:     )\n26:     base_url_adv = (\n27:         f\"https://www.basketball-reference.com/leagues/NBA_{year}_advanced.html\"\n28:     )\n29: \n30:     # Scrape per-game stats\n31:     df_reg = pd.read_html(base_url_reg, header=0)[0]\n32:     df_reg = df_reg[df_reg[\"Player\"] != \"Player\"]  # remove repeated header rows\n33:     df_reg[\"Year\"] = year\n34: \n35:     df_reg = df_reg[\n36:         [\"Player\", \"Year\", \"PTS\", \"AST\", \"TRB\", \"FG%\"]\n37:     ]  # Keep only specified columns\n38:     df_reg = df_reg.dropna(\n39:         subset=[\"PTS\", \"AST\", \"TRB\", \"FG%\"]\n40:     )  # Ensure key stats aren't invalid\n41: \n42:     # Scrape advanced stats (BPM, WS/48)\n43:     df_adv = pd.read_html(base_url_adv, header=0)[0]\n44:     df_adv = df_adv[df_adv[\"Player\"] != \"Player\"]  # remove repeated header rows\n45:     df_adv = df_adv[[\"Player\", \"BPM\", \"WS/48\"]]\n46: \n47:     # Merge advanced stats into per-game stats\n48:     df_merged = pd.merge(df_reg, df_adv, on=\"Player\", how=\"left\")\n49: \n50:     return df_merged",
            "mapping": [
                {
                    "codeSegments": [
                        {
                            "line": 31,
                            "code": "df_reg = pd.read_html(base_url_reg, header=0)[0]"
                        }
                    ],
                    "summaryComponent": "Scrapes NBA per-game stats for a specified year"
                },
                {
                    "codeSegments": [
                        {
                            "line": 35,
                            "code": "df_reg = df_reg[\n    [\"Player\", \"Year\", \"PTS\", \"AST\", \"TRB\", \"FG%\"]\n]"
                        },
                        {
                            "line": 38,
                            "code": "df_reg = df_reg.dropna(\n    subset=[\"PTS\", \"AST\", \"TRB\", \"FG%\"]\n)"
                        }
                    ],
                    "summaryComponent": "Keeps only key player statistics"
                },
                {
                    "codeSegments": [
                        {
                            "line": 43,
                            "code": "df_adv = pd.read_html(base_url_adv, header=0)[0]"
                        },
                        {
                            "line": 45,
                            "code": "df_adv = df_adv[[\"Player\", \"BPM\", \"WS/48\"]]"
                        },
                        {
                            "line": 48,
                            "code": "df_merged = pd.merge(df_reg, df_adv, on=\"Player\", how=\"left\")"
                        }
                    ],
                    "summaryComponent": "Merges advanced stats (BPM, WS/48) into the per-game stats"
                },
                {
                    "codeSegments": [
                        {
                            "line": 50,
                            "code": "return df_merged"
                        }
                    ],
                    "summaryComponent": "Returns cleaned data"
                }
            ]
        },
        "event": "map_summary_code",
        "id": "nPNCTu7pK48fDiUBLPMp"
    },
    {
        "source": "backend",
        "timestamp": "2025-08-23 14:14:54.000",
        "data": {
            "summary": "• Fetches NBA per-game stats for a given year from Basketball Reference\n• Cleans the data by removing repeated header rows\n• Adds a 'Year' column to the DataFrame\n• Selects only the Player, Year, PTS, AST, TRB, and FG% columns\n• Drops rows with missing values in key statistics\n• Fetches advanced stats (BPM, WS/48) for the same year\n• Merges advanced stats into the per-game stats DataFrame",
            "code": "22: def scrape_season_stats(year):\n23:     base_url_reg = (\n24:         f\"https://www.basketball-reference.com/leagues/NBA_{year}_per_game.html\"\n25:     )\n26:     base_url_adv = (\n27:         f\"https://www.basketball-reference.com/leagues/NBA_{year}_advanced.html\"\n28:     )\n29: \n30:     # Scrape per-game stats\n31:     df_reg = pd.read_html(base_url_reg, header=0)[0]\n32:     df_reg = df_reg[df_reg[\"Player\"] != \"Player\"]  # remove repeated header rows\n33:     df_reg[\"Year\"] = year\n34: \n35:     df_reg = df_reg[\n36:         [\"Player\", \"Year\", \"PTS\", \"AST\", \"TRB\", \"FG%\"]\n37:     ]  # Keep only specified columns\n38:     df_reg = df_reg.dropna(\n39:         subset=[\"PTS\", \"AST\", \"TRB\", \"FG%\"]\n40:     )  # Ensure key stats aren't invalid\n41: \n42:     # Scrape advanced stats (BPM, WS/48)\n43:     df_adv = pd.read_html(base_url_adv, header=0)[0]\n44:     df_adv = df_adv[df_adv[\"Player\"] != \"Player\"]  # remove repeated header rows\n45:     df_adv = df_adv[[\"Player\", \"BPM\", \"WS/48\"]]\n46: \n47:     # Merge advanced stats into per-game stats\n48:     df_merged = pd.merge(df_reg, df_adv, on=\"Player\", how=\"left\")\n49: \n50:     return df_merged",
            "mapping": [
                {
                    "codeSegments": [
                        {
                            "line": 23,
                            "code": "base_url_reg = (\n    f\"https://www.basketball-reference.com/leagues/NBA_{year}_per_game.html\"\n)"
                        },
                        {
                            "line": 31,
                            "code": "df_reg = pd.read_html(base_url_reg, header=0)[0]"
                        }
                    ],
                    "summaryComponent": "Fetches NBA per-game stats for a given year from Basketball Reference"
                },
                {
                    "codeSegments": [
                        {
                            "line": 32,
                            "code": "df_reg = df_reg[df_reg[\"Player\"] != \"Player\"]  # remove repeated header rows"
                        }
                    ],
                    "summaryComponent": "Cleans the data by removing repeated header rows"
                },
                {
                    "codeSegments": [
                        {
                            "line": 33,
                            "code": "df_reg[\"Year\"] = year"
                        }
                    ],
                    "summaryComponent": "Adds a 'Year' column to the DataFrame"
                },
                {
                    "codeSegments": [
                        {
                            "line": 35,
                            "code": "df_reg = df_reg[\n    [\"Player\", \"Year\", \"PTS\", \"AST\", \"TRB\", \"FG%\"]\n]"
                        }
                    ],
                    "summaryComponent": "Selects only the Player, Year, PTS, AST, TRB, and FG% columns"
                },
                {
                    "codeSegments": [
                        {
                            "line": 38,
                            "code": "df_reg = df_reg.dropna(\n    subset=[\"PTS\", \"AST\", \"TRB\", \"FG%\"]\n)"
                        }
                    ],
                    "summaryComponent": "Drops rows with missing values in key statistics"
                },
                {
                    "codeSegments": [
                        {
                            "line": 26,
                            "code": "base_url_adv = (\n    f\"https://www.basketball-reference.com/leagues/NBA_{year}_advanced.html\"\n)"
                        },
                        {
                            "line": 43,
                            "code": "df_adv = pd.read_html(base_url_adv, header=0)[0]"
                        },
                        {
                            "line": 44,
                            "code": "df_adv = df_adv[df_adv[\"Player\"] != \"Player\"]  # remove repeated header rows"
                        },
                        {
                            "line": 45,
                            "code": "df_adv = df_adv[[\"Player\", \"BPM\", \"WS/48\"]]"
                        }
                    ],
                    "summaryComponent": "Fetches advanced stats (BPM, WS/48) for the same year"
                },
                {
                    "codeSegments": [
                        {
                            "line": 48,
                            "code": "df_merged = pd.merge(df_reg, df_adv, on=\"Player\", how=\"left\")"
                        }
                    ],
                    "summaryComponent": "Merges advanced stats into the per-game stats DataFrame"
                }
            ]
        },
        "event": "map_summary_code",
        "id": "Mf3Q3uWx7Tq7l65KqfvS"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:14:55.000",
        "data": {
            "after_section_id": "8601f798-3c59-4556-a453-7d49959a0360",
            "before_section_id": "d2d7491d-a066-44a9-9aed-d0392ced7ca7"
        },
        "event": "autotransit_section",
        "id": "E4hyRYYebnZAhsc818Zp"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:14:55.000",
        "data": {
            "section_data": {
                "editPromptValue": "",
                "summaryData": {
                    "high_unstructured": "The scrape_season_stats function takes a year as input and constructs the URL for that season's per-game NBA statistics on Basketball Reference. It reads the HTML table into a DataFrame, removes any repeated header rows, and adds a 'Year' column to the data. The function then filters the DataFrame to retain only the Player, Year, PTS, AST, TRB, and FG% columns, ensuring that all rows have valid values for these statistics by dropping any with missing data. Additionally, the function now fetches advanced statistics (BPM and WS/48) for the same year, cleans that data, and merges it into the per-game stats DataFrame before returning the final result. The final cleaned DataFrame is returned, providing structured per-player stats and advanced metrics for the specified season.",
                    "low_structured": "• Scrapes NBA per-game stats for a specified year\n• Keeps only key player statistics\n• Merges advanced stats (BPM, WS/48) into the per-game stats\n• Returns cleaned data",
                    "high_structured": "• Accepts a year as input and builds the corresponding Basketball Reference per-game stats URL\n• Reads the first table from the web page into a DataFrame\n  ◦ Removes rows where the 'Player' column equals 'Player' to eliminate repeated headers\n• Adds a 'Year' column to indicate the season\n• Filters the DataFrame to include only the following columns:\n  ◦ Player, Year, PTS, AST, TRB, FG%\n• Drops any rows with missing values in PTS, AST, TRB, or FG% to ensure data quality\n• Fetches advanced stats (BPM, WS/48) from the advanced stats page for the same year\n  ◦ Removes repeated header rows and selects only Player, BPM, and WS/48 columns\n• Merges the advanced stats DataFrame into the per-game stats DataFrame on the Player column\n• Returns the cleaned DataFrame with per-player statistics and advanced metrics for that NBA season",
                    "title": "Summary of scrape_season_stats Function (with Advanced Stats Merge)",
                    "medium_unstructured": "The scrape_season_stats function retrieves NBA player per-game statistics from Basketball Reference for a specified year. In addition to processing the data to remove duplicate header rows, adding the year, selecting key columns, and dropping rows with missing values in important stats, the function now also fetches advanced statistics (BPM and WS/48) and merges them into the per-game stats DataFrame. The function returns a cleaned DataFrame containing player names, year, selected statistics, and advanced metrics.",
                    "medium_structured": "• Fetches NBA per-game stats for a given year from Basketball Reference\n• Cleans the data by removing repeated header rows\n• Adds a 'Year' column to the DataFrame\n• Selects only the Player, Year, PTS, AST, TRB, and FG% columns\n• Drops rows with missing values in key statistics\n• Fetches advanced stats (BPM, WS/48) for the same year\n• Merges advanced stats into the per-game stats DataFrame",
                    "low_unstructured": "This function scrapes and processes NBA player per-game statistics for a given year, and now also merges advanced statistics (BPM and WS/48) into the result."
                },
                "selectedDetailLevel": "medium",
                "title": "Summary of scrape_season_stats Function (with Advanced Stats Merge)",
                "summaryMappings": {
                    "low_structured": [
                        {
                            "codeSegments": [
                                {
                                    "line": 31,
                                    "code": "df_reg = pd.read_html(base_url_reg, header=0)[0]"
                                }
                            ],
                            "summaryComponent": "Scrapes NBA per-game stats for a specified year"
                        },
                        {
                            "codeSegments": [
                                {
                                    "line": 35,
                                    "code": "df_reg = df_reg[\n    [\"Player\", \"Year\", \"PTS\", \"AST\", \"TRB\", \"FG%\"]\n]"
                                },
                                {
                                    "line": 38,
                                    "code": "df_reg = df_reg.dropna(\n    subset=[\"PTS\", \"AST\", \"TRB\", \"FG%\"]\n)"
                                }
                            ],
                            "summaryComponent": "Keeps only key player statistics"
                        },
                        {
                            "codeSegments": [
                                {
                                    "line": 43,
                                    "code": "df_adv = pd.read_html(base_url_adv, header=0)[0]"
                                },
                                {
                                    "line": 45,
                                    "code": "df_adv = df_adv[[\"Player\", \"BPM\", \"WS/48\"]]"
                                },
                                {
                                    "line": 48,
                                    "code": "df_merged = pd.merge(df_reg, df_adv, on=\"Player\", how=\"left\")"
                                }
                            ],
                            "summaryComponent": "Merges advanced stats (BPM, WS/48) into the per-game stats"
                        },
                        {
                            "codeSegments": [
                                {
                                    "line": 50,
                                    "code": "return df_merged"
                                }
                            ],
                            "summaryComponent": "Returns cleaned data"
                        }
                    ],
                    "high_structured": [
                        {
                            "codeSegments": [
                                {
                                    "line": 22,
                                    "code": "def scrape_season_stats(year):"
                                },
                                {
                                    "line": 23,
                                    "code": "base_url_reg = (\n    f\"https://www.basketball-reference.com/leagues/NBA_{year}_per_game.html\"\n)"
                                }
                            ],
                            "summaryComponent": "Accepts a year as input and builds the corresponding Basketball Reference per-game stats URL"
                        },
                        {
                            "codeSegments": [
                                {
                                    "line": 31,
                                    "code": "df_reg = pd.read_html(base_url_reg, header=0)[0]"
                                }
                            ],
                            "summaryComponent": "Reads the first table from the web page into a DataFrame"
                        },
                        {
                            "codeSegments": [
                                {
                                    "line": 32,
                                    "code": "df_reg = df_reg[df_reg[\"Player\"] != \"Player\"]  # remove repeated header rows"
                                }
                            ],
                            "summaryComponent": "Removes rows where the 'Player' column equals 'Player' to eliminate repeated headers"
                        },
                        {
                            "codeSegments": [
                                {
                                    "line": 33,
                                    "code": "df_reg[\"Year\"] = year"
                                }
                            ],
                            "summaryComponent": "Adds a 'Year' column to indicate the season"
                        },
                        {
                            "codeSegments": [
                                {
                                    "line": 35,
                                    "code": "df_reg = df_reg[\n    [\"Player\", \"Year\", \"PTS\", \"AST\", \"TRB\", \"FG%\"]\n]"
                                }
                            ],
                            "summaryComponent": "Filters the DataFrame to include only the following columns:"
                        },
                        {
                            "codeSegments": [
                                {
                                    "line": 38,
                                    "code": "df_reg = df_reg.dropna(\n    subset=[\"PTS\", \"AST\", \"TRB\", \"FG%\"]\n)"
                                }
                            ],
                            "summaryComponent": "Drops any rows with missing values in PTS, AST, TRB, or FG% to ensure data quality"
                        },
                        {
                            "codeSegments": [
                                {
                                    "line": 26,
                                    "code": "base_url_adv = (\n    f\"https://www.basketball-reference.com/leagues/NBA_{year}_advanced.html\"\n)"
                                },
                                {
                                    "line": 43,
                                    "code": "df_adv = pd.read_html(base_url_adv, header=0)[0]"
                                }
                            ],
                            "summaryComponent": "Fetches advanced stats (BPM, WS/48) from the advanced stats page for the same year"
                        },
                        {
                            "codeSegments": [
                                {
                                    "line": 44,
                                    "code": "df_adv = df_adv[df_adv[\"Player\"] != \"Player\"]  # remove repeated header rows"
                                },
                                {
                                    "line": 45,
                                    "code": "df_adv = df_adv[[\"Player\", \"BPM\", \"WS/48\"]]"
                                }
                            ],
                            "summaryComponent": "Removes repeated header rows and selects only Player, BPM, and WS/48 columns"
                        },
                        {
                            "codeSegments": [
                                {
                                    "line": 48,
                                    "code": "df_merged = pd.merge(df_reg, df_adv, on=\"Player\", how=\"left\")"
                                }
                            ],
                            "summaryComponent": "Merges the advanced stats DataFrame into the per-game stats DataFrame on the Player column"
                        },
                        {
                            "codeSegments": [
                                {
                                    "line": 50,
                                    "code": "return df_merged"
                                }
                            ],
                            "summaryComponent": "Returns the cleaned DataFrame with per-player statistics and advanced metrics for that NBA season"
                        }
                    ],
                    "medium_structured": [
                        {
                            "codeSegments": [
                                {
                                    "line": 23,
                                    "code": "base_url_reg = (\n    f\"https://www.basketball-reference.com/leagues/NBA_{year}_per_game.html\"\n)"
                                },
                                {
                                    "line": 31,
                                    "code": "df_reg = pd.read_html(base_url_reg, header=0)[0]"
                                }
                            ],
                            "summaryComponent": "Fetches NBA per-game stats for a given year from Basketball Reference"
                        },
                        {
                            "codeSegments": [
                                {
                                    "line": 32,
                                    "code": "df_reg = df_reg[df_reg[\"Player\"] != \"Player\"]  # remove repeated header rows"
                                }
                            ],
                            "summaryComponent": "Cleans the data by removing repeated header rows"
                        },
                        {
                            "codeSegments": [
                                {
                                    "line": 33,
                                    "code": "df_reg[\"Year\"] = year"
                                }
                            ],
                            "summaryComponent": "Adds a 'Year' column to the DataFrame"
                        },
                        {
                            "codeSegments": [
                                {
                                    "line": 35,
                                    "code": "df_reg = df_reg[\n    [\"Player\", \"Year\", \"PTS\", \"AST\", \"TRB\", \"FG%\"]\n]"
                                }
                            ],
                            "summaryComponent": "Selects only the Player, Year, PTS, AST, TRB, and FG% columns"
                        },
                        {
                            "codeSegments": [
                                {
                                    "line": 38,
                                    "code": "df_reg = df_reg.dropna(\n    subset=[\"PTS\", \"AST\", \"TRB\", \"FG%\"]\n)"
                                }
                            ],
                            "summaryComponent": "Drops rows with missing values in key statistics"
                        },
                        {
                            "codeSegments": [
                                {
                                    "line": 26,
                                    "code": "base_url_adv = (\n    f\"https://www.basketball-reference.com/leagues/NBA_{year}_advanced.html\"\n)"
                                },
                                {
                                    "line": 43,
                                    "code": "df_adv = pd.read_html(base_url_adv, header=0)[0]"
                                },
                                {
                                    "line": 44,
                                    "code": "df_adv = df_adv[df_adv[\"Player\"] != \"Player\"]  # remove repeated header rows"
                                },
                                {
                                    "line": 45,
                                    "code": "df_adv = df_adv[[\"Player\", \"BPM\", \"WS/48\"]]"
                                }
                            ],
                            "summaryComponent": "Fetches advanced stats (BPM, WS/48) for the same year"
                        },
                        {
                            "codeSegments": [
                                {
                                    "line": 48,
                                    "code": "df_merged = pd.merge(df_reg, df_adv, on=\"Player\", how=\"left\")"
                                }
                            ],
                            "summaryComponent": "Merges advanced stats into the per-game stats DataFrame"
                        }
                    ],
                    "medium_unstructured": [
                        {
                            "codeSegments": [
                                {
                                    "line": 22,
                                    "code": "def scrape_season_stats(year):"
                                }
                            ],
                            "summaryComponent": "The scrape_season_stats function"
                        },
                        {
                            "codeSegments": [
                                {
                                    "line": 23,
                                    "code": "base_url_reg = ("
                                },
                                {
                                    "line": 24,
                                    "code": "f\"https://www.basketball-reference.com/leagues/NBA_{year}_per_game.html\""
                                },
                                {
                                    "line": 31,
                                    "code": "df_reg = pd.read_html(base_url_reg, header=0)[0]"
                                }
                            ],
                            "summaryComponent": "retrieves NBA player per-game statistics from Basketball Reference for a specified year"
                        },
                        {
                            "codeSegments": [
                                {
                                    "line": 32,
                                    "code": "df_reg = df_reg[df_reg[\"Player\"] != \"Player\"]  # remove repeated header rows"
                                }
                            ],
                            "summaryComponent": "processing the data to remove duplicate header rows"
                        },
                        {
                            "codeSegments": [
                                {
                                    "line": 33,
                                    "code": "df_reg[\"Year\"] = year"
                                }
                            ],
                            "summaryComponent": "adding the year"
                        },
                        {
                            "codeSegments": [
                                {
                                    "line": 35,
                                    "code": "df_reg = df_reg["
                                },
                                {
                                    "line": 36,
                                    "code": "[\"Player\", \"Year\", \"PTS\", \"AST\", \"TRB\", \"FG%\"]"
                                }
                            ],
                            "summaryComponent": "selecting key columns"
                        },
                        {
                            "codeSegments": [
                                {
                                    "line": 38,
                                    "code": "df_reg = df_reg.dropna("
                                },
                                {
                                    "line": 39,
                                    "code": "subset=[\"PTS\", \"AST\", \"TRB\", \"FG%\"]"
                                }
                            ],
                            "summaryComponent": "dropping rows with missing values in important stats"
                        },
                        {
                            "codeSegments": [
                                {
                                    "line": 26,
                                    "code": "base_url_adv = ("
                                },
                                {
                                    "line": 27,
                                    "code": "f\"https://www.basketball-reference.com/leagues/NBA_{year}_advanced.html\""
                                },
                                {
                                    "line": 43,
                                    "code": "df_adv = pd.read_html(base_url_adv, header=0)[0]"
                                },
                                {
                                    "line": 44,
                                    "code": "df_adv = df_adv[df_adv[\"Player\"] != \"Player\"]  # remove repeated header rows"
                                },
                                {
                                    "line": 45,
                                    "code": "df_adv = df_adv[[\"Player\", \"BPM\", \"WS/48\"]]"
                                }
                            ],
                            "summaryComponent": "fetches advanced statistics (BPM and WS/48)"
                        },
                        {
                            "codeSegments": [
                                {
                                    "line": 48,
                                    "code": "df_merged = pd.merge(df_reg, df_adv, on=\"Player\", how=\"left\")"
                                }
                            ],
                            "summaryComponent": "merges them into the per-game stats DataFrame"
                        },
                        {
                            "codeSegments": [
                                {
                                    "line": 50,
                                    "code": "return df_merged"
                                }
                            ],
                            "summaryComponent": "returns a cleaned DataFrame"
                        },
                        {
                            "codeSegments": [
                                {
                                    "line": 36,
                                    "code": "[\"Player\", \"Year\", \"PTS\", \"AST\", \"TRB\", \"FG%\"]"
                                },
                                {
                                    "line": 45,
                                    "code": "df_adv = df_adv[[\"Player\", \"BPM\", \"WS/48\"]]"
                                }
                            ],
                            "summaryComponent": "containing player names, year, selected statistics, and advanced metrics"
                        }
                    ],
                    "high_unstructured": [
                        {
                            "codeSegments": [
                                {
                                    "line": 22,
                                    "code": "def scrape_season_stats(year):"
                                }
                            ],
                            "summaryComponent": "The scrape_season_stats function takes a year as input"
                        },
                        {
                            "codeSegments": [
                                {
                                    "line": 23,
                                    "code": "base_url_reg = ("
                                },
                                {
                                    "line": 24,
                                    "code": "f\"https://www.basketball-reference.com/leagues/NBA_{year}_per_game.html\""
                                }
                            ],
                            "summaryComponent": "constructs the URL for that season's per-game NBA statistics on Basketball Reference"
                        },
                        {
                            "codeSegments": [
                                {
                                    "line": 31,
                                    "code": "df_reg = pd.read_html(base_url_reg, header=0)[0]"
                                }
                            ],
                            "summaryComponent": "It reads the HTML table into a DataFrame"
                        },
                        {
                            "codeSegments": [
                                {
                                    "line": 32,
                                    "code": "df_reg = df_reg[df_reg[\"Player\"] != \"Player\"]  # remove repeated header rows"
                                }
                            ],
                            "summaryComponent": "removes any repeated header rows"
                        },
                        {
                            "codeSegments": [
                                {
                                    "line": 33,
                                    "code": "df_reg[\"Year\"] = year"
                                }
                            ],
                            "summaryComponent": "adds a 'Year' column to the data"
                        },
                        {
                            "codeSegments": [
                                {
                                    "line": 35,
                                    "code": "df_reg = df_reg["
                                },
                                {
                                    "line": 36,
                                    "code": "[\"Player\", \"Year\", \"PTS\", \"AST\", \"TRB\", \"FG%\"]"
                                }
                            ],
                            "summaryComponent": "filters the DataFrame to retain only the Player, Year, PTS, AST, TRB, and FG% columns"
                        },
                        {
                            "codeSegments": [
                                {
                                    "line": 38,
                                    "code": "df_reg = df_reg.dropna("
                                },
                                {
                                    "line": 39,
                                    "code": "subset=[\"PTS\", \"AST\", \"TRB\", \"FG%\"]"
                                }
                            ],
                            "summaryComponent": "ensuring that all rows have valid values for these statistics by dropping any with missing data"
                        },
                        {
                            "codeSegments": [
                                {
                                    "line": 26,
                                    "code": "base_url_adv = ("
                                },
                                {
                                    "line": 27,
                                    "code": "f\"https://www.basketball-reference.com/leagues/NBA_{year}_advanced.html\""
                                },
                                {
                                    "line": 43,
                                    "code": "df_adv = pd.read_html(base_url_adv, header=0)[0]"
                                },
                                {
                                    "line": 45,
                                    "code": "df_adv = df_adv[[\"Player\", \"BPM\", \"WS/48\"]]"
                                }
                            ],
                            "summaryComponent": "fetches advanced statistics (BPM and WS/48) for the same year"
                        },
                        {
                            "codeSegments": [
                                {
                                    "line": 44,
                                    "code": "df_adv = df_adv[df_adv[\"Player\"] != \"Player\"]  # remove repeated header rows"
                                }
                            ],
                            "summaryComponent": "cleans that data"
                        },
                        {
                            "codeSegments": [
                                {
                                    "line": 48,
                                    "code": "df_merged = pd.merge(df_reg, df_adv, on=\"Player\", how=\"left\")"
                                }
                            ],
                            "summaryComponent": "merges it into the per-game stats DataFrame before returning the final result"
                        },
                        {
                            "codeSegments": [
                                {
                                    "line": 50,
                                    "code": "return df_merged"
                                }
                            ],
                            "summaryComponent": "The final cleaned DataFrame is returned, providing structured per-player stats and advanced metrics for the specified season."
                        }
                    ],
                    "low_unstructured": [
                        {
                            "codeSegments": [
                                {
                                    "line": 22,
                                    "code": "def scrape_season_stats(year):"
                                },
                                {
                                    "line": 31,
                                    "code": "df_reg = pd.read_html(base_url_reg, header=0)[0]"
                                },
                                {
                                    "line": 32,
                                    "code": "df_reg = df_reg[df_reg[\"Player\"] != \"Player\"]  # remove repeated header rows"
                                },
                                {
                                    "line": 33,
                                    "code": "df_reg[\"Year\"] = year"
                                },
                                {
                                    "line": 35,
                                    "code": "df_reg = df_reg[\n    [\"Player\", \"Year\", \"PTS\", \"AST\", \"TRB\", \"FG%\"]\n]  # Keep only specified columns"
                                },
                                {
                                    "line": 38,
                                    "code": "df_reg = df_reg.dropna(\n    subset=[\"PTS\", \"AST\", \"TRB\", \"FG%\"]\n)  # Ensure key stats aren't invalid"
                                }
                            ],
                            "summaryComponent": "scrapes and processes NBA player per-game statistics for a given year"
                        },
                        {
                            "codeSegments": [
                                {
                                    "line": 43,
                                    "code": "df_adv = pd.read_html(base_url_adv, header=0)[0]"
                                },
                                {
                                    "line": 44,
                                    "code": "df_adv = df_adv[df_adv[\"Player\"] != \"Player\"]  # remove repeated header rows"
                                },
                                {
                                    "line": 45,
                                    "code": "df_adv = df_adv[[\"Player\", \"BPM\", \"WS/48\"]]"
                                },
                                {
                                    "line": 48,
                                    "code": "df_merged = pd.merge(df_reg, df_adv, on=\"Player\", how=\"left\")"
                                }
                            ],
                            "summaryComponent": "now also merges advanced statistics (BPM and WS/48) into the result"
                        }
                    ]
                },
                "oldSummaryData": {
                    "high_unstructured": "The scrape_season_stats function takes a year as input and constructs the URL for that season's per-game NBA statistics on Basketball Reference. It reads the HTML table into a DataFrame, removes any repeated header rows, and adds a 'Year' column to the data. The function then filters the DataFrame to retain only the Player, Year, PTS, AST, TRB, and FG% columns, ensuring that all rows have valid values for these statistics by dropping any with missing data. The final cleaned DataFrame is returned, providing structured per-player stats for the specified season.",
                    "low_structured": "• Scrapes NBA per-game stats for a specified year\n• Keeps only key player statistics\n• Returns cleaned data",
                    "high_structured": "• Accepts a year as input and builds the corresponding Basketball Reference per-game stats URL\n• Reads the first table from the web page into a DataFrame\n  ◦ Removes rows where the 'Player' column equals 'Player' to eliminate repeated headers\n• Adds a 'Year' column to indicate the season\n• Filters the DataFrame to include only the following columns:\n  ◦ Player, Year, PTS, AST, TRB, FG%\n• Drops any rows with missing values in PTS, AST, TRB, or FG% to ensure data quality\n• Returns the cleaned DataFrame with per-player statistics for that NBA season",
                    "title": "Summary of scrape_season_stats Function",
                    "medium_unstructured": "The scrape_season_stats function retrieves NBA player per-game statistics from Basketball Reference for a specified year. It processes the data to remove duplicate header rows, adds the year, selects key columns, and drops rows with missing values in important stats. The function returns a cleaned DataFrame containing player names, year, and selected statistics.",
                    "medium_structured": "• Fetches NBA per-game stats for a given year from Basketball Reference\n• Cleans the data by removing repeated header rows\n• Adds a 'Year' column to the DataFrame\n• Selects only the Player, Year, PTS, AST, TRB, and FG% columns\n• Drops rows with missing values in key statistics",
                    "low_unstructured": "This function scrapes and processes NBA player per-game statistics for a given year."
                },
                "metadata": {
                    "id": "8601f798-3c59-4556-a453-7d49959a0360",
                    "filename": "scraper.py",
                    "offset": 652,
                    "fullPath": "/project/workspace/scraper.py",
                    "originalCode": "def scrape_season_stats(year):\n    base_url_reg = (\n        f\"https://www.basketball-reference.com/leagues/NBA_{year}_per_game.html\"\n    )\n    base_url_adv = (\n        f\"https://www.basketball-reference.com/leagues/NBA_{year}_advanced.html\"\n    )\n\n    # Scrape per-game stats\n    df_reg = pd.read_html(base_url_reg, header=0)[0]\n    df_reg = df_reg[df_reg[\"Player\"] != \"Player\"]  # remove repeated header rows\n    df_reg[\"Year\"] = year\n\n    df_reg = df_reg[\n        [\"Player\", \"Year\", \"PTS\", \"AST\", \"TRB\", \"FG%\"]\n    ]  # Keep only specified columns\n    df_reg = df_reg.dropna(\n        subset=[\"PTS\", \"AST\", \"TRB\", \"FG%\"]\n    )  # Ensure key stats aren't invalid\n\n    # Scrape advanced stats (BPM, WS/48)\n    df_adv = pd.read_html(base_url_adv, header=0)[0]\n    df_adv = df_adv[df_adv[\"Player\"] != \"Player\"]  # remove repeated header rows\n    df_adv = df_adv[[\"Player\", \"BPM\", \"WS/48\"]]\n\n    # Merge advanced stats into per-game stats\n    df_merged = pd.merge(df_reg, df_adv, on=\"Player\", how=\"left\")\n\n    return df_merged"
                },
                "createdAt": 1755987296000,
                "lines": [
                    22,
                    50
                ],
                "editPromptStructured": null,
                "selectedStructured": "unstructured",
                "editPromptDetailLevel": null
            },
            "section_id": "8601f798-3c59-4556-a453-7d49959a0360"
        },
        "event": "create_new_section",
        "id": "RqwdZxtb2EqyBD5fWEEW"
    },
    {
        "source": "backend",
        "timestamp": "2025-08-23 14:14:56.000",
        "data": {
            "summary": "The scrape_season_stats function takes a year as input and constructs the URL for that season's per-game NBA statistics on Basketball Reference. It reads the HTML table into a DataFrame, removes any repeated header rows, and adds a 'Year' column to the data. The function then filters the DataFrame to retain only the Player, Year, PTS, AST, TRB, and FG% columns, ensuring that all rows have valid values for these statistics by dropping any with missing data. Additionally, the function now fetches advanced statistics (BPM and WS/48) for the same year, cleans that data, and merges it into the per-game stats DataFrame before returning the final result. The final cleaned DataFrame is returned, providing structured per-player stats and advanced metrics for the specified season.",
            "code": "22: def scrape_season_stats(year):\n23:     base_url_reg = (\n24:         f\"https://www.basketball-reference.com/leagues/NBA_{year}_per_game.html\"\n25:     )\n26:     base_url_adv = (\n27:         f\"https://www.basketball-reference.com/leagues/NBA_{year}_advanced.html\"\n28:     )\n29: \n30:     # Scrape per-game stats\n31:     df_reg = pd.read_html(base_url_reg, header=0)[0]\n32:     df_reg = df_reg[df_reg[\"Player\"] != \"Player\"]  # remove repeated header rows\n33:     df_reg[\"Year\"] = year\n34: \n35:     df_reg = df_reg[\n36:         [\"Player\", \"Year\", \"PTS\", \"AST\", \"TRB\", \"FG%\"]\n37:     ]  # Keep only specified columns\n38:     df_reg = df_reg.dropna(\n39:         subset=[\"PTS\", \"AST\", \"TRB\", \"FG%\"]\n40:     )  # Ensure key stats aren't invalid\n41: \n42:     # Scrape advanced stats (BPM, WS/48)\n43:     df_adv = pd.read_html(base_url_adv, header=0)[0]\n44:     df_adv = df_adv[df_adv[\"Player\"] != \"Player\"]  # remove repeated header rows\n45:     df_adv = df_adv[[\"Player\", \"BPM\", \"WS/48\"]]\n46: \n47:     # Merge advanced stats into per-game stats\n48:     df_merged = pd.merge(df_reg, df_adv, on=\"Player\", how=\"left\")\n49: \n50:     return df_merged",
            "mapping": [
                {
                    "codeSegments": [
                        {
                            "line": 22,
                            "code": "def scrape_season_stats(year):"
                        }
                    ],
                    "summaryComponent": "The scrape_season_stats function takes a year as input"
                },
                {
                    "codeSegments": [
                        {
                            "line": 23,
                            "code": "base_url_reg = ("
                        },
                        {
                            "line": 24,
                            "code": "f\"https://www.basketball-reference.com/leagues/NBA_{year}_per_game.html\""
                        }
                    ],
                    "summaryComponent": "constructs the URL for that season's per-game NBA statistics on Basketball Reference"
                },
                {
                    "codeSegments": [
                        {
                            "line": 31,
                            "code": "df_reg = pd.read_html(base_url_reg, header=0)[0]"
                        }
                    ],
                    "summaryComponent": "It reads the HTML table into a DataFrame"
                },
                {
                    "codeSegments": [
                        {
                            "line": 32,
                            "code": "df_reg = df_reg[df_reg[\"Player\"] != \"Player\"]  # remove repeated header rows"
                        }
                    ],
                    "summaryComponent": "removes any repeated header rows"
                },
                {
                    "codeSegments": [
                        {
                            "line": 33,
                            "code": "df_reg[\"Year\"] = year"
                        }
                    ],
                    "summaryComponent": "adds a 'Year' column to the data"
                },
                {
                    "codeSegments": [
                        {
                            "line": 35,
                            "code": "df_reg = df_reg["
                        },
                        {
                            "line": 36,
                            "code": "[\"Player\", \"Year\", \"PTS\", \"AST\", \"TRB\", \"FG%\"]"
                        }
                    ],
                    "summaryComponent": "filters the DataFrame to retain only the Player, Year, PTS, AST, TRB, and FG% columns"
                },
                {
                    "codeSegments": [
                        {
                            "line": 38,
                            "code": "df_reg = df_reg.dropna("
                        },
                        {
                            "line": 39,
                            "code": "subset=[\"PTS\", \"AST\", \"TRB\", \"FG%\"]"
                        }
                    ],
                    "summaryComponent": "ensuring that all rows have valid values for these statistics by dropping any with missing data"
                },
                {
                    "codeSegments": [
                        {
                            "line": 26,
                            "code": "base_url_adv = ("
                        },
                        {
                            "line": 27,
                            "code": "f\"https://www.basketball-reference.com/leagues/NBA_{year}_advanced.html\""
                        },
                        {
                            "line": 43,
                            "code": "df_adv = pd.read_html(base_url_adv, header=0)[0]"
                        },
                        {
                            "line": 45,
                            "code": "df_adv = df_adv[[\"Player\", \"BPM\", \"WS/48\"]]"
                        }
                    ],
                    "summaryComponent": "fetches advanced statistics (BPM and WS/48) for the same year"
                },
                {
                    "codeSegments": [
                        {
                            "line": 44,
                            "code": "df_adv = df_adv[df_adv[\"Player\"] != \"Player\"]  # remove repeated header rows"
                        }
                    ],
                    "summaryComponent": "cleans that data"
                },
                {
                    "codeSegments": [
                        {
                            "line": 48,
                            "code": "df_merged = pd.merge(df_reg, df_adv, on=\"Player\", how=\"left\")"
                        }
                    ],
                    "summaryComponent": "merges it into the per-game stats DataFrame before returning the final result"
                },
                {
                    "codeSegments": [
                        {
                            "line": 50,
                            "code": "return df_merged"
                        }
                    ],
                    "summaryComponent": "The final cleaned DataFrame is returned, providing structured per-player stats and advanced metrics for the specified season."
                }
            ]
        },
        "event": "map_summary_code",
        "id": "hQ93NndiqJo55zZZgeNy"
    },
    {
        "source": "backend",
        "timestamp": "2025-08-23 14:14:56.000",
        "data": {
            "summary": "• Accepts a year as input and builds the corresponding Basketball Reference per-game stats URL\n• Reads the first table from the web page into a DataFrame\n  ◦ Removes rows where the 'Player' column equals 'Player' to eliminate repeated headers\n• Adds a 'Year' column to indicate the season\n• Filters the DataFrame to include only the following columns:\n  ◦ Player, Year, PTS, AST, TRB, FG%\n• Drops any rows with missing values in PTS, AST, TRB, or FG% to ensure data quality\n• Fetches advanced stats (BPM, WS/48) from the advanced stats page for the same year\n  ◦ Removes repeated header rows and selects only Player, BPM, and WS/48 columns\n• Merges the advanced stats DataFrame into the per-game stats DataFrame on the Player column\n• Returns the cleaned DataFrame with per-player statistics and advanced metrics for that NBA season",
            "code": "22: def scrape_season_stats(year):\n23:     base_url_reg = (\n24:         f\"https://www.basketball-reference.com/leagues/NBA_{year}_per_game.html\"\n25:     )\n26:     base_url_adv = (\n27:         f\"https://www.basketball-reference.com/leagues/NBA_{year}_advanced.html\"\n28:     )\n29: \n30:     # Scrape per-game stats\n31:     df_reg = pd.read_html(base_url_reg, header=0)[0]\n32:     df_reg = df_reg[df_reg[\"Player\"] != \"Player\"]  # remove repeated header rows\n33:     df_reg[\"Year\"] = year\n34: \n35:     df_reg = df_reg[\n36:         [\"Player\", \"Year\", \"PTS\", \"AST\", \"TRB\", \"FG%\"]\n37:     ]  # Keep only specified columns\n38:     df_reg = df_reg.dropna(\n39:         subset=[\"PTS\", \"AST\", \"TRB\", \"FG%\"]\n40:     )  # Ensure key stats aren't invalid\n41: \n42:     # Scrape advanced stats (BPM, WS/48)\n43:     df_adv = pd.read_html(base_url_adv, header=0)[0]\n44:     df_adv = df_adv[df_adv[\"Player\"] != \"Player\"]  # remove repeated header rows\n45:     df_adv = df_adv[[\"Player\", \"BPM\", \"WS/48\"]]\n46: \n47:     # Merge advanced stats into per-game stats\n48:     df_merged = pd.merge(df_reg, df_adv, on=\"Player\", how=\"left\")\n49: \n50:     return df_merged",
            "mapping": [
                {
                    "codeSegments": [
                        {
                            "line": 22,
                            "code": "def scrape_season_stats(year):"
                        },
                        {
                            "line": 23,
                            "code": "base_url_reg = (\n    f\"https://www.basketball-reference.com/leagues/NBA_{year}_per_game.html\"\n)"
                        }
                    ],
                    "summaryComponent": "Accepts a year as input and builds the corresponding Basketball Reference per-game stats URL"
                },
                {
                    "codeSegments": [
                        {
                            "line": 31,
                            "code": "df_reg = pd.read_html(base_url_reg, header=0)[0]"
                        }
                    ],
                    "summaryComponent": "Reads the first table from the web page into a DataFrame"
                },
                {
                    "codeSegments": [
                        {
                            "line": 32,
                            "code": "df_reg = df_reg[df_reg[\"Player\"] != \"Player\"]  # remove repeated header rows"
                        }
                    ],
                    "summaryComponent": "Removes rows where the 'Player' column equals 'Player' to eliminate repeated headers"
                },
                {
                    "codeSegments": [
                        {
                            "line": 33,
                            "code": "df_reg[\"Year\"] = year"
                        }
                    ],
                    "summaryComponent": "Adds a 'Year' column to indicate the season"
                },
                {
                    "codeSegments": [
                        {
                            "line": 35,
                            "code": "df_reg = df_reg[\n    [\"Player\", \"Year\", \"PTS\", \"AST\", \"TRB\", \"FG%\"]\n]"
                        }
                    ],
                    "summaryComponent": "Filters the DataFrame to include only the following columns:"
                },
                {
                    "codeSegments": [
                        {
                            "line": 38,
                            "code": "df_reg = df_reg.dropna(\n    subset=[\"PTS\", \"AST\", \"TRB\", \"FG%\"]\n)"
                        }
                    ],
                    "summaryComponent": "Drops any rows with missing values in PTS, AST, TRB, or FG% to ensure data quality"
                },
                {
                    "codeSegments": [
                        {
                            "line": 26,
                            "code": "base_url_adv = (\n    f\"https://www.basketball-reference.com/leagues/NBA_{year}_advanced.html\"\n)"
                        },
                        {
                            "line": 43,
                            "code": "df_adv = pd.read_html(base_url_adv, header=0)[0]"
                        }
                    ],
                    "summaryComponent": "Fetches advanced stats (BPM, WS/48) from the advanced stats page for the same year"
                },
                {
                    "codeSegments": [
                        {
                            "line": 44,
                            "code": "df_adv = df_adv[df_adv[\"Player\"] != \"Player\"]  # remove repeated header rows"
                        },
                        {
                            "line": 45,
                            "code": "df_adv = df_adv[[\"Player\", \"BPM\", \"WS/48\"]]"
                        }
                    ],
                    "summaryComponent": "Removes repeated header rows and selects only Player, BPM, and WS/48 columns"
                },
                {
                    "codeSegments": [
                        {
                            "line": 48,
                            "code": "df_merged = pd.merge(df_reg, df_adv, on=\"Player\", how=\"left\")"
                        }
                    ],
                    "summaryComponent": "Merges the advanced stats DataFrame into the per-game stats DataFrame on the Player column"
                },
                {
                    "codeSegments": [
                        {
                            "line": 50,
                            "code": "return df_merged"
                        }
                    ],
                    "summaryComponent": "Returns the cleaned DataFrame with per-player statistics and advanced metrics for that NBA season"
                }
            ]
        },
        "event": "map_summary_code",
        "id": "nw5lnmKqoR1CyuquTkcC"
    },
    {
        "source": "backend",
        "timestamp": "2025-08-23 14:14:56.000",
        "data": {
            "summary": "The scrape_season_stats function retrieves NBA player per-game statistics from Basketball Reference for a specified year. In addition to processing the data to remove duplicate header rows, adding the year, selecting key columns, and dropping rows with missing values in important stats, the function now also fetches advanced statistics (BPM and WS/48) and merges them into the per-game stats DataFrame. The function returns a cleaned DataFrame containing player names, year, selected statistics, and advanced metrics.",
            "code": "22: def scrape_season_stats(year):\n23:     base_url_reg = (\n24:         f\"https://www.basketball-reference.com/leagues/NBA_{year}_per_game.html\"\n25:     )\n26:     base_url_adv = (\n27:         f\"https://www.basketball-reference.com/leagues/NBA_{year}_advanced.html\"\n28:     )\n29: \n30:     # Scrape per-game stats\n31:     df_reg = pd.read_html(base_url_reg, header=0)[0]\n32:     df_reg = df_reg[df_reg[\"Player\"] != \"Player\"]  # remove repeated header rows\n33:     df_reg[\"Year\"] = year\n34: \n35:     df_reg = df_reg[\n36:         [\"Player\", \"Year\", \"PTS\", \"AST\", \"TRB\", \"FG%\"]\n37:     ]  # Keep only specified columns\n38:     df_reg = df_reg.dropna(\n39:         subset=[\"PTS\", \"AST\", \"TRB\", \"FG%\"]\n40:     )  # Ensure key stats aren't invalid\n41: \n42:     # Scrape advanced stats (BPM, WS/48)\n43:     df_adv = pd.read_html(base_url_adv, header=0)[0]\n44:     df_adv = df_adv[df_adv[\"Player\"] != \"Player\"]  # remove repeated header rows\n45:     df_adv = df_adv[[\"Player\", \"BPM\", \"WS/48\"]]\n46: \n47:     # Merge advanced stats into per-game stats\n48:     df_merged = pd.merge(df_reg, df_adv, on=\"Player\", how=\"left\")\n49: \n50:     return df_merged",
            "mapping": [
                {
                    "codeSegments": [
                        {
                            "line": 22,
                            "code": "def scrape_season_stats(year):"
                        }
                    ],
                    "summaryComponent": "The scrape_season_stats function"
                },
                {
                    "codeSegments": [
                        {
                            "line": 23,
                            "code": "base_url_reg = ("
                        },
                        {
                            "line": 24,
                            "code": "f\"https://www.basketball-reference.com/leagues/NBA_{year}_per_game.html\""
                        },
                        {
                            "line": 31,
                            "code": "df_reg = pd.read_html(base_url_reg, header=0)[0]"
                        }
                    ],
                    "summaryComponent": "retrieves NBA player per-game statistics from Basketball Reference for a specified year"
                },
                {
                    "codeSegments": [
                        {
                            "line": 32,
                            "code": "df_reg = df_reg[df_reg[\"Player\"] != \"Player\"]  # remove repeated header rows"
                        }
                    ],
                    "summaryComponent": "processing the data to remove duplicate header rows"
                },
                {
                    "codeSegments": [
                        {
                            "line": 33,
                            "code": "df_reg[\"Year\"] = year"
                        }
                    ],
                    "summaryComponent": "adding the year"
                },
                {
                    "codeSegments": [
                        {
                            "line": 35,
                            "code": "df_reg = df_reg["
                        },
                        {
                            "line": 36,
                            "code": "[\"Player\", \"Year\", \"PTS\", \"AST\", \"TRB\", \"FG%\"]"
                        }
                    ],
                    "summaryComponent": "selecting key columns"
                },
                {
                    "codeSegments": [
                        {
                            "line": 38,
                            "code": "df_reg = df_reg.dropna("
                        },
                        {
                            "line": 39,
                            "code": "subset=[\"PTS\", \"AST\", \"TRB\", \"FG%\"]"
                        }
                    ],
                    "summaryComponent": "dropping rows with missing values in important stats"
                },
                {
                    "codeSegments": [
                        {
                            "line": 26,
                            "code": "base_url_adv = ("
                        },
                        {
                            "line": 27,
                            "code": "f\"https://www.basketball-reference.com/leagues/NBA_{year}_advanced.html\""
                        },
                        {
                            "line": 43,
                            "code": "df_adv = pd.read_html(base_url_adv, header=0)[0]"
                        },
                        {
                            "line": 44,
                            "code": "df_adv = df_adv[df_adv[\"Player\"] != \"Player\"]  # remove repeated header rows"
                        },
                        {
                            "line": 45,
                            "code": "df_adv = df_adv[[\"Player\", \"BPM\", \"WS/48\"]]"
                        }
                    ],
                    "summaryComponent": "fetches advanced statistics (BPM and WS/48)"
                },
                {
                    "codeSegments": [
                        {
                            "line": 48,
                            "code": "df_merged = pd.merge(df_reg, df_adv, on=\"Player\", how=\"left\")"
                        }
                    ],
                    "summaryComponent": "merges them into the per-game stats DataFrame"
                },
                {
                    "codeSegments": [
                        {
                            "line": 50,
                            "code": "return df_merged"
                        }
                    ],
                    "summaryComponent": "returns a cleaned DataFrame"
                },
                {
                    "codeSegments": [
                        {
                            "line": 36,
                            "code": "[\"Player\", \"Year\", \"PTS\", \"AST\", \"TRB\", \"FG%\"]"
                        },
                        {
                            "line": 45,
                            "code": "df_adv = df_adv[[\"Player\", \"BPM\", \"WS/48\"]]"
                        }
                    ],
                    "summaryComponent": "containing player names, year, selected statistics, and advanced metrics"
                }
            ]
        },
        "event": "map_summary_code",
        "id": "zXOBCcGd4sgQLf61NBYd"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:18:07.000",
        "data": {
            "detail_level": "medium",
            "section_id": "8601f798-3c59-4556-a453-7d49959a0360",
            "structured_type": "unstructured"
        },
        "event": "mapping_unhover",
        "id": "qifm3yJaq2Xkd52JsanJ"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:18:07.000",
        "data": {
            "detail_level": "medium",
            "section_id": "8601f798-3c59-4556-a453-7d49959a0360",
            "structured_type": "unstructured",
            "mapping_index": 1
        },
        "event": "mapping_hover",
        "id": "v3UpOzjiIcTcWwo62XDT"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:18:08.000",
        "data": {
            "detail_level": "medium",
            "section_id": "8601f798-3c59-4556-a453-7d49959a0360",
            "structured_type": "unstructured"
        },
        "event": "mapping_unhover",
        "id": "4C03PxfHsuTHX7voH3PL"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:18:08.000",
        "data": {
            "detail_level": "medium",
            "section_id": "8601f798-3c59-4556-a453-7d49959a0360",
            "structured_type": "unstructured",
            "mapping_index": 5
        },
        "event": "mapping_hover",
        "id": "DDe7mQ3bnx6OKeGEbFKT"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:18:08.000",
        "data": {
            "detail_level": "medium",
            "section_id": "8601f798-3c59-4556-a453-7d49959a0360",
            "structured_type": "unstructured",
            "mapping_index": 1
        },
        "event": "mapping_hover",
        "id": "GonBGBCt81D9uv1ffEGM"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:18:08.000",
        "data": {
            "detail_level": "medium",
            "section_id": "8601f798-3c59-4556-a453-7d49959a0360",
            "structured_type": "unstructured",
            "mapping_index": 3
        },
        "event": "mapping_hover",
        "id": "QeZzb6o4z2aGHr5ufyV9"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:18:08.000",
        "data": {
            "detail_level": "medium",
            "section_id": "8601f798-3c59-4556-a453-7d49959a0360",
            "structured_type": "unstructured"
        },
        "event": "mapping_unhover",
        "id": "RoaL0Fh1G93938twYPqw"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:18:08.000",
        "data": {
            "detail_level": "medium",
            "section_id": "8601f798-3c59-4556-a453-7d49959a0360",
            "structured_type": "unstructured"
        },
        "event": "mapping_unhover",
        "id": "UhRQ0gUYdDwp7JbXgBmv"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:18:08.000",
        "data": {
            "detail_level": "medium",
            "section_id": "8601f798-3c59-4556-a453-7d49959a0360",
            "structured_type": "unstructured",
            "mapping_index": 3
        },
        "event": "mapping_hover",
        "id": "fQlAC3oRE5lAUgwXxTBE"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:18:08.000",
        "data": {
            "detail_level": "medium",
            "section_id": "8601f798-3c59-4556-a453-7d49959a0360",
            "structured_type": "unstructured"
        },
        "event": "mapping_unhover",
        "id": "fvPF2e7cMXoCfP1gIzh5"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:18:08.000",
        "data": {},
        "event": "click_summarize_code",
        "id": "p9C8hxqujbqef4ccZM8l"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:18:08.000",
        "data": {
            "detail_level": "medium",
            "section_id": "8601f798-3c59-4556-a453-7d49959a0360",
            "structured_type": "unstructured",
            "mapping_index": 5
        },
        "event": "mapping_hover",
        "id": "x8jdcg9ON291b6bBb5bQ"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:18:08.000",
        "data": {
            "detail_level": "medium",
            "section_id": "8601f798-3c59-4556-a453-7d49959a0360",
            "structured_type": "unstructured",
            "mapping_index": 8
        },
        "event": "mapping_hover",
        "id": "xSIgOdBB8LbIz6YjSh80"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:18:08.000",
        "data": {
            "detail_level": "medium",
            "section_id": "8601f798-3c59-4556-a453-7d49959a0360",
            "structured_type": "unstructured"
        },
        "event": "mapping_unhover",
        "id": "yrakQNdNfCcKBwGgiPLV"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:18:09.000",
        "data": {
            "detail_level": "medium",
            "section_id": "8601f798-3c59-4556-a453-7d49959a0360",
            "structured_type": "unstructured"
        },
        "event": "mapping_unhover",
        "id": "DiWjijNsXeTHPej8w0I2"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:18:09.000",
        "data": {
            "detail_level": "medium",
            "section_id": "8601f798-3c59-4556-a453-7d49959a0360",
            "structured_type": "unstructured",
            "mapping_index": 1
        },
        "event": "mapping_hover",
        "id": "JyUVTFOGCiQBhVb19KFC"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:18:09.000",
        "data": {
            "detail_level": "medium",
            "section_id": "8601f798-3c59-4556-a453-7d49959a0360",
            "structured_type": "unstructured"
        },
        "event": "mapping_unhover",
        "id": "sWRDudOe4v4SHUKz7wzx"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:18:10.000",
        "data": {
            "detail_level": "medium",
            "section_id": "8601f798-3c59-4556-a453-7d49959a0360",
            "structured_type": "unstructured"
        },
        "event": "mapping_unhover",
        "id": "91PQofn3l3rhAerbiUyF"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:18:10.000",
        "data": {
            "detail_level": "medium",
            "section_id": "8601f798-3c59-4556-a453-7d49959a0360",
            "structured_type": "unstructured"
        },
        "event": "mapping_unhover",
        "id": "HjYR3yTJnp2QNauxaf7d"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:18:10.000",
        "data": {
            "detail_level": "medium",
            "section_id": "8601f798-3c59-4556-a453-7d49959a0360",
            "structured_type": "unstructured"
        },
        "event": "mapping_unhover",
        "id": "LH56sdRkWydTKrkDDPP2"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:18:10.000",
        "data": {
            "detail_level": "medium",
            "section_id": "8601f798-3c59-4556-a453-7d49959a0360",
            "structured_type": "unstructured",
            "mapping_index": 1
        },
        "event": "mapping_hover",
        "id": "NXyrcMxl5rBMbKbAIVyP"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:18:10.000",
        "data": {
            "detail_level": "medium",
            "section_id": "8601f798-3c59-4556-a453-7d49959a0360",
            "structured_type": "unstructured",
            "mapping_index": 4
        },
        "event": "mapping_hover",
        "id": "P4IEJZ7lxMBQxEDd4NON"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:18:10.000",
        "data": {
            "detail_level": "medium",
            "section_id": "8601f798-3c59-4556-a453-7d49959a0360",
            "structured_type": "unstructured",
            "mapping_index": 6
        },
        "event": "mapping_hover",
        "id": "kzPIcmBJGUMjUdWJXgSE"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:18:10.000",
        "data": {
            "detail_level": "medium",
            "section_id": "8601f798-3c59-4556-a453-7d49959a0360",
            "structured_type": "unstructured"
        },
        "event": "mapping_unhover",
        "id": "rTml7ykneB5xCjqG8G9v"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:18:10.000",
        "data": {
            "detail_level": "medium",
            "section_id": "8601f798-3c59-4556-a453-7d49959a0360",
            "structured_type": "unstructured",
            "mapping_index": 2
        },
        "event": "mapping_hover",
        "id": "vnyFKUDyJUcJ75poC6QW"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:18:11.000",
        "data": {
            "detail_level": "medium",
            "section_id": "8601f798-3c59-4556-a453-7d49959a0360",
            "structured_type": "unstructured"
        },
        "event": "mapping_unhover",
        "id": "7Qq3RaeAKpMudEsHjbGW"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:18:11.000",
        "data": {
            "detail_level": "medium",
            "section_id": "8601f798-3c59-4556-a453-7d49959a0360",
            "structured_type": "unstructured",
            "mapping_index": 1
        },
        "event": "mapping_hover",
        "id": "pqUIXlaHSlFElXiOFgBv"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:18:11.000",
        "data": {
            "after_section_id": null,
            "before_section_id": "8601f798-3c59-4556-a453-7d49959a0360"
        },
        "event": "toggle_section",
        "id": "tnhiO1rdjJ6gvpu5Xnoq"
    },
    {
        "source": "backend",
        "timestamp": "2025-08-23 14:18:16.000",
        "data": {
            "summary": {
                "high_unstructured": "This code is designed to train and evaluate an XGBoost-based ranking model for basketball MVP predictions. It begins by loading and cleaning a dataset of player statistics, selecting relevant features, and removing incomplete entries. The data is split into training and test sets by year, and group sizes are computed for ranking tasks. The model is trained using a pairwise ranking objective, predictions are made for the test years, and the results are evaluated using the NDCG metric. Finally, the code visualizes prediction errors for each player in the test years, saving the plots and printing detailed results.",
                "low_structured": "• Loads and preprocesses player data\n• Trains and evaluates a ranking model\n• Plots prediction errors for specific years",
                "high_structured": "• Loads player statistics from a CSV file and selects relevant features\n  ◦ Drops rows with missing values in selected features or rank\n  ◦ Sorts data by year and rank for consistency\n• Splits data into training (all but last two years) and testing (last two years) sets\n  ◦ Computes group sizes for each year to support ranking tasks\n• Trains an XGBoost ranking model with specified hyperparameters\n  ◦ Uses a pairwise ranking objective for learning\n• Makes predictions on the test set and assigns predicted ranks within each year\n• Evaluates model performance using the NDCG metric across test groups\n• Prints detailed prediction results for the test years\n• Visualizes and saves bar plots of prediction errors for each player in the test years",
                "title": "Summary of MVP Ranking Model Training and Evaluation Code",
                "medium_unstructured": "The code loads basketball player statistics, cleans and prepares the data, and splits it into training and testing sets based on years. It then trains an XGBoost ranking model to predict player ranks, evaluates the model using NDCG, and visualizes prediction errors for recent years. Results and evaluation metrics are printed and saved as plots.",
                "medium_structured": "• Loads and preprocesses player statistics from a CSV file\n• Splits data into training and testing sets by year\n• Trains an XGBoost ranking model on the training data\n• Evaluates model performance using NDCG score\n• Plots and saves prediction error visualizations for selected years",
                "low_unstructured": "This code loads basketball player data, trains an XGBoost ranking model, evaluates its performance, and visualizes prediction errors."
            },
            "selected_code": "import pandas as pd\nfrom xgboost import XGBRanker\nfrom sklearn.metrics import ndcg_score\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport seaborn as sns\n\n\ndef load_data(path=\"data/merged_data.csv\"):\n    df = pd.read_csv(path)\n\n    # Features to use\n    feature_cols = [\n        \"PTS\",\n        \"AST\",\n        \"TRB\",\n        \"FG%\",\n        \"BPM\",\n        \"WS/48\",\n        \"TS%\",\n        \"VORP\",\n        \"WS\",\n        \"PER\",\n    ]\n    feature_cols = [\n        col for col in feature_cols if col in df.columns\n    ]  # only keep existing features\n    df = df.dropna(subset=feature_cols + [\"Rank\"])\n\n    # Sort by Year and Rank for consistency\n    df = df.sort_values(by=[\"Year\", \"Rank\"])\n\n    X = df[feature_cols]\n    y = df[\"Rank\"]\n    groups = df.groupby(\"Year\").size().to_numpy()\n\n    return X, y, groups, df\n\n\ndef evaluate_ndcg(y_true, y_pred, group_sizes):\n    scores = []\n    start = 0\n    for size in group_sizes:\n        true_ranks = y_true[start : start + size]\n        true_relevance = (max(true_ranks) + 1) - true_ranks\n        pred_scores = y_pred[start : start + size]\n        scores.append(ndcg_score([true_relevance], [pred_scores]))\n        start += size\n    return np.mean(scores)\n\n\ndef plot_ranking_predictions(df, year):\n    \"\"\"\n    Plot prediction error for a specific year.\n\n    Args:\n        df: DataFrame containing prediction results\n        year: Year to plot prediction errors for\n    \"\"\"\n    df[\"RankError\"] = df[\"PredictedRank\"] - df[\"Rank\"]\n    year_df = df[df[\"Year\"] == year].copy()\n    year_df.sort_values(\"Rank\", inplace=True)\n\n    plt.figure(figsize=(12, 6))\n    sns.barplot(x=\"Name\", y=\"RankError\", data=year_df, hue=\"Name\", palette=\"coolwarm\")\n    plt.axhline(0, color=\"black\", linestyle=\"--\")\n    plt.xticks(rotation=45, ha=\"right\")\n    plt.ylabel(\"Predicted Rank - True Rank\")\n    plt.title(f\"MVP Ranking Predictions ({year})\")\n    plt.tight_layout()\n    plt.savefig(f\"data/ranking_predictions_{year}.png\")\n\n\ndef main():\n    X, y, group, df = load_data()\n\n    # Train-test split on years\n    unique_years = df[\"Year\"].unique()\n    train_years, test_years = (\n        unique_years[:-2],  # train: 2015-2023\n        unique_years[-2:],  # test: 2024-2025\n    )\n\n    train_idx = df[\"Year\"].isin(train_years)\n    test_idx = df[\"Year\"].isin(test_years)\n\n    X_train, X_test = X[train_idx], X[test_idx]\n    y_train, y_test = y[train_idx], y[test_idx]\n\n    # Group sizes\n    train_groups = df[train_idx].groupby(\"Year\").size().to_numpy()\n    test_groups = df[test_idx].groupby(\"Year\").size().to_numpy()\n\n    # Model\n    model = XGBRanker(\n        objective=\"rank:pairwise\",\n        learning_rate=0.1,\n        n_estimators=100,\n        max_depth=4,\n        random_state=42,\n    )\n\n    print(\"Training XGBoostRanker...\")\n    model.fit(X_train, y_train, group=train_groups)\n\n    # Predict, sort, and evaluate\n    y_pred = model.predict(X_test)\n    df.loc[test_idx, \"PredictedScore\"] = y_pred\n    df.loc[test_idx, \"PredictedRank\"] = (\n        df.loc[test_idx]\n        .groupby(\"Year\")[\"PredictedScore\"]\n        .rank(ascending=False, method=\"first\")\n    )\n\n    ndcg = evaluate_ndcg(y_test.to_numpy(), y_pred, test_groups)\n    print(f\"NDCG Score on test years {test_years.tolist()}: {ndcg:.4f}\")\n\n    # Show results\n    print(df[test_idx][[\"Year\", \"Name\", \"Rank\", \"PredictedScore\", \"PredictedRank\"]])\n    plot_ranking_predictions(df, 2024)\n    plot_ranking_predictions(df, 2025)\n\n\nif __name__ == \"__main__\":\n    main()\n"
        },
        "event": "summarize_selected_code",
        "id": "7Z8Gpypx4ipRbT4x13uP"
    },
    {
        "source": "backend",
        "timestamp": "2025-08-23 14:18:18.000",
        "data": {
            "summary": "This code loads basketball player data, trains an XGBoost ranking model, evaluates its performance, and visualizes prediction errors.",
            "code": "1: import pandas as pd\n2: from xgboost import XGBRanker\n3: from sklearn.metrics import ndcg_score\n4: import numpy as np\n5: import matplotlib.pyplot as plt\n6: import seaborn as sns\n7: \n8: \n9: def load_data(path=\"data/merged_data.csv\"):\n10:     df = pd.read_csv(path)\n11: \n12:     # Features to use\n13:     feature_cols = [\n14:         \"PTS\",\n15:         \"AST\",\n16:         \"TRB\",\n17:         \"FG%\",\n18:         \"BPM\",\n19:         \"WS/48\",\n20:         \"TS%\",\n21:         \"VORP\",\n22:         \"WS\",\n23:         \"PER\",\n24:     ]\n25:     feature_cols = [\n26:         col for col in feature_cols if col in df.columns\n27:     ]  # only keep existing features\n28:     df = df.dropna(subset=feature_cols + [\"Rank\"])\n29: \n30:     # Sort by Year and Rank for consistency\n31:     df = df.sort_values(by=[\"Year\", \"Rank\"])\n32: \n33:     X = df[feature_cols]\n34:     y = df[\"Rank\"]\n35:     groups = df.groupby(\"Year\").size().to_numpy()\n36: \n37:     return X, y, groups, df\n38: \n39: \n40: def evaluate_ndcg(y_true, y_pred, group_sizes):\n41:     scores = []\n42:     start = 0\n43:     for size in group_sizes:\n44:         true_ranks = y_true[start : start + size]\n45:         true_relevance = (max(true_ranks) + 1) - true_ranks\n46:         pred_scores = y_pred[start : start + size]\n47:         scores.append(ndcg_score([true_relevance], [pred_scores]))\n48:         start += size\n49:     return np.mean(scores)\n50: \n51: \n52: def plot_ranking_predictions(df, year):\n53:     \"\"\"\n54:     Plot prediction error for a specific year.\n55: \n56:     Args:\n57:         df: DataFrame containing prediction results\n58:         year: Year to plot prediction errors for\n59:     \"\"\"\n60:     df[\"RankError\"] = df[\"PredictedRank\"] - df[\"Rank\"]\n61:     year_df = df[df[\"Year\"] == year].copy()\n62:     year_df.sort_values(\"Rank\", inplace=True)\n63: \n64:     plt.figure(figsize=(12, 6))\n65:     sns.barplot(x=\"Name\", y=\"RankError\", data=year_df, hue=\"Name\", palette=\"coolwarm\")\n66:     plt.axhline(0, color=\"black\", linestyle=\"--\")\n67:     plt.xticks(rotation=45, ha=\"right\")\n68:     plt.ylabel(\"Predicted Rank - True Rank\")\n69:     plt.title(f\"MVP Ranking Predictions ({year})\")\n70:     plt.tight_layout()\n71:     plt.savefig(f\"data/ranking_predictions_{year}.png\")\n72: \n73: \n74: def main():\n75:     X, y, group, df = load_data()\n76: \n77:     # Train-test split on years\n78:     unique_years = df[\"Year\"].unique()\n79:     train_years, test_years = (\n80:         unique_years[:-2],  # train: 2015-2023\n81:         unique_years[-2:],  # test: 2024-2025\n82:     )\n83: \n84:     train_idx = df[\"Year\"].isin(train_years)\n85:     test_idx = df[\"Year\"].isin(test_years)\n86: \n87:     X_train, X_test = X[train_idx], X[test_idx]\n88:     y_train, y_test = y[train_idx], y[test_idx]\n89: \n90:     # Group sizes\n91:     train_groups = df[train_idx].groupby(\"Year\").size().to_numpy()\n92:     test_groups = df[test_idx].groupby(\"Year\").size().to_numpy()\n93: \n94:     # Model\n95:     model = XGBRanker(\n96:         objective=\"rank:pairwise\",\n97:         learning_rate=0.1,\n98:         n_estimators=100,\n99:         max_depth=4,\n100:         random_state=42,\n101:     )\n102: \n103:     print(\"Training XGBoostRanker...\")\n104:     model.fit(X_train, y_train, group=train_groups)\n105: \n106:     # Predict, sort, and evaluate\n107:     y_pred = model.predict(X_test)\n108:     df.loc[test_idx, \"PredictedScore\"] = y_pred\n109:     df.loc[test_idx, \"PredictedRank\"] = (\n110:         df.loc[test_idx]\n111:         .groupby(\"Year\")[\"PredictedScore\"]\n112:         .rank(ascending=False, method=\"first\")\n113:     )\n114: \n115:     ndcg = evaluate_ndcg(y_test.to_numpy(), y_pred, test_groups)\n116:     print(f\"NDCG Score on test years {test_years.tolist()}: {ndcg:.4f}\")\n117: \n118:     # Show results\n119:     print(df[test_idx][[\"Year\", \"Name\", \"Rank\", \"PredictedScore\", \"PredictedRank\"]])\n120:     plot_ranking_predictions(df, 2024)\n121:     plot_ranking_predictions(df, 2025)\n122: \n123: \n124: if __name__ == \"__main__\":\n125:     main()\n126: ",
            "mapping": [
                {
                    "codeSegments": [
                        {
                            "line": 9,
                            "code": "def load_data(path=\"data/merged_data.csv\"):"
                        },
                        {
                            "line": 10,
                            "code": "df = pd.read_csv(path)"
                        }
                    ],
                    "summaryComponent": "loads basketball player data"
                },
                {
                    "codeSegments": [
                        {
                            "line": 95,
                            "code": "model = XGBRanker("
                        },
                        {
                            "line": 104,
                            "code": "model.fit(X_train, y_train, group=train_groups)"
                        }
                    ],
                    "summaryComponent": "trains an XGBoost ranking model"
                },
                {
                    "codeSegments": [
                        {
                            "line": 115,
                            "code": "ndcg = evaluate_ndcg(y_test.to_numpy(), y_pred, test_groups)"
                        },
                        {
                            "line": 116,
                            "code": "print(f\"NDCG Score on test years {test_years.tolist()}: {ndcg:.4f}\")"
                        }
                    ],
                    "summaryComponent": "evaluates its performance"
                },
                {
                    "codeSegments": [
                        {
                            "line": 120,
                            "code": "plot_ranking_predictions(df, 2024)"
                        },
                        {
                            "line": 121,
                            "code": "plot_ranking_predictions(df, 2025)"
                        }
                    ],
                    "summaryComponent": "visualizes prediction errors"
                }
            ]
        },
        "event": "map_summary_code",
        "id": "dAKcZlr670w93uk1mBU9"
    },
    {
        "source": "backend",
        "timestamp": "2025-08-23 14:18:19.000",
        "data": {
            "summary": "• Loads and preprocesses player statistics from a CSV file\n• Splits data into training and testing sets by year\n• Trains an XGBoost ranking model on the training data\n• Evaluates model performance using NDCG score\n• Plots and saves prediction error visualizations for selected years",
            "code": "1: import pandas as pd\n2: from xgboost import XGBRanker\n3: from sklearn.metrics import ndcg_score\n4: import numpy as np\n5: import matplotlib.pyplot as plt\n6: import seaborn as sns\n7: \n8: \n9: def load_data(path=\"data/merged_data.csv\"):\n10:     df = pd.read_csv(path)\n11: \n12:     # Features to use\n13:     feature_cols = [\n14:         \"PTS\",\n15:         \"AST\",\n16:         \"TRB\",\n17:         \"FG%\",\n18:         \"BPM\",\n19:         \"WS/48\",\n20:         \"TS%\",\n21:         \"VORP\",\n22:         \"WS\",\n23:         \"PER\",\n24:     ]\n25:     feature_cols = [\n26:         col for col in feature_cols if col in df.columns\n27:     ]  # only keep existing features\n28:     df = df.dropna(subset=feature_cols + [\"Rank\"])\n29: \n30:     # Sort by Year and Rank for consistency\n31:     df = df.sort_values(by=[\"Year\", \"Rank\"])\n32: \n33:     X = df[feature_cols]\n34:     y = df[\"Rank\"]\n35:     groups = df.groupby(\"Year\").size().to_numpy()\n36: \n37:     return X, y, groups, df\n38: \n39: \n40: def evaluate_ndcg(y_true, y_pred, group_sizes):\n41:     scores = []\n42:     start = 0\n43:     for size in group_sizes:\n44:         true_ranks = y_true[start : start + size]\n45:         true_relevance = (max(true_ranks) + 1) - true_ranks\n46:         pred_scores = y_pred[start : start + size]\n47:         scores.append(ndcg_score([true_relevance], [pred_scores]))\n48:         start += size\n49:     return np.mean(scores)\n50: \n51: \n52: def plot_ranking_predictions(df, year):\n53:     \"\"\"\n54:     Plot prediction error for a specific year.\n55: \n56:     Args:\n57:         df: DataFrame containing prediction results\n58:         year: Year to plot prediction errors for\n59:     \"\"\"\n60:     df[\"RankError\"] = df[\"PredictedRank\"] - df[\"Rank\"]\n61:     year_df = df[df[\"Year\"] == year].copy()\n62:     year_df.sort_values(\"Rank\", inplace=True)\n63: \n64:     plt.figure(figsize=(12, 6))\n65:     sns.barplot(x=\"Name\", y=\"RankError\", data=year_df, hue=\"Name\", palette=\"coolwarm\")\n66:     plt.axhline(0, color=\"black\", linestyle=\"--\")\n67:     plt.xticks(rotation=45, ha=\"right\")\n68:     plt.ylabel(\"Predicted Rank - True Rank\")\n69:     plt.title(f\"MVP Ranking Predictions ({year})\")\n70:     plt.tight_layout()\n71:     plt.savefig(f\"data/ranking_predictions_{year}.png\")\n72: \n73: \n74: def main():\n75:     X, y, group, df = load_data()\n76: \n77:     # Train-test split on years\n78:     unique_years = df[\"Year\"].unique()\n79:     train_years, test_years = (\n80:         unique_years[:-2],  # train: 2015-2023\n81:         unique_years[-2:],  # test: 2024-2025\n82:     )\n83: \n84:     train_idx = df[\"Year\"].isin(train_years)\n85:     test_idx = df[\"Year\"].isin(test_years)\n86: \n87:     X_train, X_test = X[train_idx], X[test_idx]\n88:     y_train, y_test = y[train_idx], y[test_idx]\n89: \n90:     # Group sizes\n91:     train_groups = df[train_idx].groupby(\"Year\").size().to_numpy()\n92:     test_groups = df[test_idx].groupby(\"Year\").size().to_numpy()\n93: \n94:     # Model\n95:     model = XGBRanker(\n96:         objective=\"rank:pairwise\",\n97:         learning_rate=0.1,\n98:         n_estimators=100,\n99:         max_depth=4,\n100:         random_state=42,\n101:     )\n102: \n103:     print(\"Training XGBoostRanker...\")\n104:     model.fit(X_train, y_train, group=train_groups)\n105: \n106:     # Predict, sort, and evaluate\n107:     y_pred = model.predict(X_test)\n108:     df.loc[test_idx, \"PredictedScore\"] = y_pred\n109:     df.loc[test_idx, \"PredictedRank\"] = (\n110:         df.loc[test_idx]\n111:         .groupby(\"Year\")[\"PredictedScore\"]\n112:         .rank(ascending=False, method=\"first\")\n113:     )\n114: \n115:     ndcg = evaluate_ndcg(y_test.to_numpy(), y_pred, test_groups)\n116:     print(f\"NDCG Score on test years {test_years.tolist()}: {ndcg:.4f}\")\n117: \n118:     # Show results\n119:     print(df[test_idx][[\"Year\", \"Name\", \"Rank\", \"PredictedScore\", \"PredictedRank\"]])\n120:     plot_ranking_predictions(df, 2024)\n121:     plot_ranking_predictions(df, 2025)\n122: \n123: \n124: if __name__ == \"__main__\":\n125:     main()\n126: ",
            "mapping": [
                {
                    "codeSegments": [
                        {
                            "line": 9,
                            "code": "def load_data(path=\"data/merged_data.csv\"):"
                        },
                        {
                            "line": 10,
                            "code": "df = pd.read_csv(path)"
                        },
                        {
                            "line": 13,
                            "code": "feature_cols = ["
                        },
                        {
                            "line": 28,
                            "code": "df = df.dropna(subset=feature_cols + [\"Rank\"])"
                        }
                    ],
                    "summaryComponent": "Loads and preprocesses player statistics from a CSV file"
                },
                {
                    "codeSegments": [
                        {
                            "line": 78,
                            "code": "unique_years = df[\"Year\"].unique()"
                        },
                        {
                            "line": 79,
                            "code": "train_years, test_years = ("
                        },
                        {
                            "line": 84,
                            "code": "train_idx = df[\"Year\"].isin(train_years)"
                        },
                        {
                            "line": 85,
                            "code": "test_idx = df[\"Year\"].isin(test_years)"
                        },
                        {
                            "line": 87,
                            "code": "X_train, X_test = X[train_idx], X[test_idx]"
                        },
                        {
                            "line": 88,
                            "code": "y_train, y_test = y[train_idx], y[test_idx]"
                        }
                    ],
                    "summaryComponent": "Splits data into training and testing sets by year"
                },
                {
                    "codeSegments": [
                        {
                            "line": 95,
                            "code": "model = XGBRanker("
                        },
                        {
                            "line": 104,
                            "code": "model.fit(X_train, y_train, group=train_groups)"
                        }
                    ],
                    "summaryComponent": "Trains an XGBoost ranking model on the training data"
                },
                {
                    "codeSegments": [
                        {
                            "line": 115,
                            "code": "ndcg = evaluate_ndcg(y_test.to_numpy(), y_pred, test_groups)"
                        },
                        {
                            "line": 40,
                            "code": "def evaluate_ndcg(y_true, y_pred, group_sizes):"
                        }
                    ],
                    "summaryComponent": "Evaluates model performance using NDCG score"
                },
                {
                    "codeSegments": [
                        {
                            "line": 52,
                            "code": "def plot_ranking_predictions(df, year):"
                        },
                        {
                            "line": 120,
                            "code": "plot_ranking_predictions(df, 2024)"
                        },
                        {
                            "line": 121,
                            "code": "plot_ranking_predictions(df, 2025)"
                        },
                        {
                            "line": 71,
                            "code": "plt.savefig(f\"data/ranking_predictions_{year}.png\")"
                        }
                    ],
                    "summaryComponent": "Plots and saves prediction error visualizations for selected years"
                }
            ]
        },
        "event": "map_summary_code",
        "id": "6RnviIhZk6QkoJnahowm"
    },
    {
        "source": "backend",
        "timestamp": "2025-08-23 14:18:20.000",
        "data": {
            "summary": "The code loads basketball player statistics, cleans and prepares the data, and splits it into training and testing sets based on years. It then trains an XGBoost ranking model to predict player ranks, evaluates the model using NDCG, and visualizes prediction errors for recent years. Results and evaluation metrics are printed and saved as plots.",
            "code": "1: import pandas as pd\n2: from xgboost import XGBRanker\n3: from sklearn.metrics import ndcg_score\n4: import numpy as np\n5: import matplotlib.pyplot as plt\n6: import seaborn as sns\n7: \n8: \n9: def load_data(path=\"data/merged_data.csv\"):\n10:     df = pd.read_csv(path)\n11: \n12:     # Features to use\n13:     feature_cols = [\n14:         \"PTS\",\n15:         \"AST\",\n16:         \"TRB\",\n17:         \"FG%\",\n18:         \"BPM\",\n19:         \"WS/48\",\n20:         \"TS%\",\n21:         \"VORP\",\n22:         \"WS\",\n23:         \"PER\",\n24:     ]\n25:     feature_cols = [\n26:         col for col in feature_cols if col in df.columns\n27:     ]  # only keep existing features\n28:     df = df.dropna(subset=feature_cols + [\"Rank\"])\n29: \n30:     # Sort by Year and Rank for consistency\n31:     df = df.sort_values(by=[\"Year\", \"Rank\"])\n32: \n33:     X = df[feature_cols]\n34:     y = df[\"Rank\"]\n35:     groups = df.groupby(\"Year\").size().to_numpy()\n36: \n37:     return X, y, groups, df\n38: \n39: \n40: def evaluate_ndcg(y_true, y_pred, group_sizes):\n41:     scores = []\n42:     start = 0\n43:     for size in group_sizes:\n44:         true_ranks = y_true[start : start + size]\n45:         true_relevance = (max(true_ranks) + 1) - true_ranks\n46:         pred_scores = y_pred[start : start + size]\n47:         scores.append(ndcg_score([true_relevance], [pred_scores]))\n48:         start += size\n49:     return np.mean(scores)\n50: \n51: \n52: def plot_ranking_predictions(df, year):\n53:     \"\"\"\n54:     Plot prediction error for a specific year.\n55: \n56:     Args:\n57:         df: DataFrame containing prediction results\n58:         year: Year to plot prediction errors for\n59:     \"\"\"\n60:     df[\"RankError\"] = df[\"PredictedRank\"] - df[\"Rank\"]\n61:     year_df = df[df[\"Year\"] == year].copy()\n62:     year_df.sort_values(\"Rank\", inplace=True)\n63: \n64:     plt.figure(figsize=(12, 6))\n65:     sns.barplot(x=\"Name\", y=\"RankError\", data=year_df, hue=\"Name\", palette=\"coolwarm\")\n66:     plt.axhline(0, color=\"black\", linestyle=\"--\")\n67:     plt.xticks(rotation=45, ha=\"right\")\n68:     plt.ylabel(\"Predicted Rank - True Rank\")\n69:     plt.title(f\"MVP Ranking Predictions ({year})\")\n70:     plt.tight_layout()\n71:     plt.savefig(f\"data/ranking_predictions_{year}.png\")\n72: \n73: \n74: def main():\n75:     X, y, group, df = load_data()\n76: \n77:     # Train-test split on years\n78:     unique_years = df[\"Year\"].unique()\n79:     train_years, test_years = (\n80:         unique_years[:-2],  # train: 2015-2023\n81:         unique_years[-2:],  # test: 2024-2025\n82:     )\n83: \n84:     train_idx = df[\"Year\"].isin(train_years)\n85:     test_idx = df[\"Year\"].isin(test_years)\n86: \n87:     X_train, X_test = X[train_idx], X[test_idx]\n88:     y_train, y_test = y[train_idx], y[test_idx]\n89: \n90:     # Group sizes\n91:     train_groups = df[train_idx].groupby(\"Year\").size().to_numpy()\n92:     test_groups = df[test_idx].groupby(\"Year\").size().to_numpy()\n93: \n94:     # Model\n95:     model = XGBRanker(\n96:         objective=\"rank:pairwise\",\n97:         learning_rate=0.1,\n98:         n_estimators=100,\n99:         max_depth=4,\n100:         random_state=42,\n101:     )\n102: \n103:     print(\"Training XGBoostRanker...\")\n104:     model.fit(X_train, y_train, group=train_groups)\n105: \n106:     # Predict, sort, and evaluate\n107:     y_pred = model.predict(X_test)\n108:     df.loc[test_idx, \"PredictedScore\"] = y_pred\n109:     df.loc[test_idx, \"PredictedRank\"] = (\n110:         df.loc[test_idx]\n111:         .groupby(\"Year\")[\"PredictedScore\"]\n112:         .rank(ascending=False, method=\"first\")\n113:     )\n114: \n115:     ndcg = evaluate_ndcg(y_test.to_numpy(), y_pred, test_groups)\n116:     print(f\"NDCG Score on test years {test_years.tolist()}: {ndcg:.4f}\")\n117: \n118:     # Show results\n119:     print(df[test_idx][[\"Year\", \"Name\", \"Rank\", \"PredictedScore\", \"PredictedRank\"]])\n120:     plot_ranking_predictions(df, 2024)\n121:     plot_ranking_predictions(df, 2025)\n122: \n123: \n124: if __name__ == \"__main__\":\n125:     main()\n126: ",
            "mapping": [
                {
                    "codeSegments": [
                        {
                            "line": 10,
                            "code": "df = pd.read_csv(path)"
                        }
                    ],
                    "summaryComponent": "loads basketball player statistics"
                },
                {
                    "codeSegments": [
                        {
                            "line": 13,
                            "code": "feature_cols = ["
                        },
                        {
                            "line": 25,
                            "code": "feature_cols = ["
                        },
                        {
                            "line": 28,
                            "code": "df = df.dropna(subset=feature_cols + [\"Rank\"])"
                        },
                        {
                            "line": 31,
                            "code": "df = df.sort_values(by=[\"Year\", \"Rank\"])"
                        }
                    ],
                    "summaryComponent": "cleans and prepares the data"
                },
                {
                    "codeSegments": [
                        {
                            "line": 78,
                            "code": "unique_years = df[\"Year\"].unique()"
                        },
                        {
                            "line": 79,
                            "code": "train_years, test_years = ("
                        },
                        {
                            "line": 84,
                            "code": "train_idx = df[\"Year\"].isin(train_years)"
                        },
                        {
                            "line": 85,
                            "code": "test_idx = df[\"Year\"].isin(test_years)"
                        },
                        {
                            "line": 87,
                            "code": "X_train, X_test = X[train_idx], X[test_idx]"
                        },
                        {
                            "line": 88,
                            "code": "y_train, y_test = y[train_idx], y[test_idx]"
                        }
                    ],
                    "summaryComponent": "splits it into training and testing sets based on years"
                },
                {
                    "codeSegments": [
                        {
                            "line": 95,
                            "code": "model = XGBRanker("
                        },
                        {
                            "line": 104,
                            "code": "model.fit(X_train, y_train, group=train_groups)"
                        }
                    ],
                    "summaryComponent": "trains an XGBoost ranking model to predict player ranks"
                },
                {
                    "codeSegments": [
                        {
                            "line": 115,
                            "code": "ndcg = evaluate_ndcg(y_test.to_numpy(), y_pred, test_groups)"
                        }
                    ],
                    "summaryComponent": "evaluates the model using NDCG"
                },
                {
                    "codeSegments": [
                        {
                            "line": 120,
                            "code": "plot_ranking_predictions(df, 2024)"
                        },
                        {
                            "line": 121,
                            "code": "plot_ranking_predictions(df, 2025)"
                        }
                    ],
                    "summaryComponent": "visualizes prediction errors for recent years"
                },
                {
                    "codeSegments": [
                        {
                            "line": 116,
                            "code": "print(f\"NDCG Score on test years {test_years.tolist()}: {ndcg:.4f}\")"
                        },
                        {
                            "line": 119,
                            "code": "print(df[test_idx][[\"Year\", \"Name\", \"Rank\", \"PredictedScore\", \"PredictedRank\"]])"
                        }
                    ],
                    "summaryComponent": "Results and evaluation metrics are printed"
                },
                {
                    "codeSegments": [
                        {
                            "line": 71,
                            "code": "plt.savefig(f\"data/ranking_predictions_{year}.png\")"
                        }
                    ],
                    "summaryComponent": "saved as plots"
                }
            ]
        },
        "event": "map_summary_code",
        "id": "z3Mg6j207wEbA58NgYie"
    },
    {
        "source": "backend",
        "timestamp": "2025-08-23 14:18:22.000",
        "data": {
            "summary": "This code is designed to train and evaluate an XGBoost-based ranking model for basketball MVP predictions. It begins by loading and cleaning a dataset of player statistics, selecting relevant features, and removing incomplete entries. The data is split into training and test sets by year, and group sizes are computed for ranking tasks. The model is trained using a pairwise ranking objective, predictions are made for the test years, and the results are evaluated using the NDCG metric. Finally, the code visualizes prediction errors for each player in the test years, saving the plots and printing detailed results.",
            "code": "1: import pandas as pd\n2: from xgboost import XGBRanker\n3: from sklearn.metrics import ndcg_score\n4: import numpy as np\n5: import matplotlib.pyplot as plt\n6: import seaborn as sns\n7: \n8: \n9: def load_data(path=\"data/merged_data.csv\"):\n10:     df = pd.read_csv(path)\n11: \n12:     # Features to use\n13:     feature_cols = [\n14:         \"PTS\",\n15:         \"AST\",\n16:         \"TRB\",\n17:         \"FG%\",\n18:         \"BPM\",\n19:         \"WS/48\",\n20:         \"TS%\",\n21:         \"VORP\",\n22:         \"WS\",\n23:         \"PER\",\n24:     ]\n25:     feature_cols = [\n26:         col for col in feature_cols if col in df.columns\n27:     ]  # only keep existing features\n28:     df = df.dropna(subset=feature_cols + [\"Rank\"])\n29: \n30:     # Sort by Year and Rank for consistency\n31:     df = df.sort_values(by=[\"Year\", \"Rank\"])\n32: \n33:     X = df[feature_cols]\n34:     y = df[\"Rank\"]\n35:     groups = df.groupby(\"Year\").size().to_numpy()\n36: \n37:     return X, y, groups, df\n38: \n39: \n40: def evaluate_ndcg(y_true, y_pred, group_sizes):\n41:     scores = []\n42:     start = 0\n43:     for size in group_sizes:\n44:         true_ranks = y_true[start : start + size]\n45:         true_relevance = (max(true_ranks) + 1) - true_ranks\n46:         pred_scores = y_pred[start : start + size]\n47:         scores.append(ndcg_score([true_relevance], [pred_scores]))\n48:         start += size\n49:     return np.mean(scores)\n50: \n51: \n52: def plot_ranking_predictions(df, year):\n53:     \"\"\"\n54:     Plot prediction error for a specific year.\n55: \n56:     Args:\n57:         df: DataFrame containing prediction results\n58:         year: Year to plot prediction errors for\n59:     \"\"\"\n60:     df[\"RankError\"] = df[\"PredictedRank\"] - df[\"Rank\"]\n61:     year_df = df[df[\"Year\"] == year].copy()\n62:     year_df.sort_values(\"Rank\", inplace=True)\n63: \n64:     plt.figure(figsize=(12, 6))\n65:     sns.barplot(x=\"Name\", y=\"RankError\", data=year_df, hue=\"Name\", palette=\"coolwarm\")\n66:     plt.axhline(0, color=\"black\", linestyle=\"--\")\n67:     plt.xticks(rotation=45, ha=\"right\")\n68:     plt.ylabel(\"Predicted Rank - True Rank\")\n69:     plt.title(f\"MVP Ranking Predictions ({year})\")\n70:     plt.tight_layout()\n71:     plt.savefig(f\"data/ranking_predictions_{year}.png\")\n72: \n73: \n74: def main():\n75:     X, y, group, df = load_data()\n76: \n77:     # Train-test split on years\n78:     unique_years = df[\"Year\"].unique()\n79:     train_years, test_years = (\n80:         unique_years[:-2],  # train: 2015-2023\n81:         unique_years[-2:],  # test: 2024-2025\n82:     )\n83: \n84:     train_idx = df[\"Year\"].isin(train_years)\n85:     test_idx = df[\"Year\"].isin(test_years)\n86: \n87:     X_train, X_test = X[train_idx], X[test_idx]\n88:     y_train, y_test = y[train_idx], y[test_idx]\n89: \n90:     # Group sizes\n91:     train_groups = df[train_idx].groupby(\"Year\").size().to_numpy()\n92:     test_groups = df[test_idx].groupby(\"Year\").size().to_numpy()\n93: \n94:     # Model\n95:     model = XGBRanker(\n96:         objective=\"rank:pairwise\",\n97:         learning_rate=0.1,\n98:         n_estimators=100,\n99:         max_depth=4,\n100:         random_state=42,\n101:     )\n102: \n103:     print(\"Training XGBoostRanker...\")\n104:     model.fit(X_train, y_train, group=train_groups)\n105: \n106:     # Predict, sort, and evaluate\n107:     y_pred = model.predict(X_test)\n108:     df.loc[test_idx, \"PredictedScore\"] = y_pred\n109:     df.loc[test_idx, \"PredictedRank\"] = (\n110:         df.loc[test_idx]\n111:         .groupby(\"Year\")[\"PredictedScore\"]\n112:         .rank(ascending=False, method=\"first\")\n113:     )\n114: \n115:     ndcg = evaluate_ndcg(y_test.to_numpy(), y_pred, test_groups)\n116:     print(f\"NDCG Score on test years {test_years.tolist()}: {ndcg:.4f}\")\n117: \n118:     # Show results\n119:     print(df[test_idx][[\"Year\", \"Name\", \"Rank\", \"PredictedScore\", \"PredictedRank\"]])\n120:     plot_ranking_predictions(df, 2024)\n121:     plot_ranking_predictions(df, 2025)\n122: \n123: \n124: if __name__ == \"__main__\":\n125:     main()\n126: ",
            "mapping": [
                {
                    "codeSegments": [
                        {
                            "line": 95,
                            "code": "model = XGBRanker("
                        },
                        {
                            "line": 104,
                            "code": "model.fit(X_train, y_train, group=train_groups)"
                        },
                        {
                            "line": 107,
                            "code": "y_pred = model.predict(X_test)"
                        }
                    ],
                    "summaryComponent": "train and evaluate an XGBoost-based ranking model"
                },
                {
                    "codeSegments": [
                        {
                            "line": 9,
                            "code": "def load_data(path=\"data/merged_data.csv\"):"
                        },
                        {
                            "line": 10,
                            "code": "df = pd.read_csv(path)"
                        },
                        {
                            "line": 28,
                            "code": "df = df.dropna(subset=feature_cols + [\"Rank\"])"
                        }
                    ],
                    "summaryComponent": "loading and cleaning a dataset of player statistics"
                },
                {
                    "codeSegments": [
                        {
                            "line": 13,
                            "code": "feature_cols = ["
                        },
                        {
                            "line": 25,
                            "code": "feature_cols = ["
                        }
                    ],
                    "summaryComponent": "selecting relevant features"
                },
                {
                    "codeSegments": [
                        {
                            "line": 28,
                            "code": "df = df.dropna(subset=feature_cols + [\"Rank\"])"
                        }
                    ],
                    "summaryComponent": "removing incomplete entries"
                },
                {
                    "codeSegments": [
                        {
                            "line": 79,
                            "code": "train_years, test_years = ("
                        },
                        {
                            "line": 84,
                            "code": "train_idx = df[\"Year\"].isin(train_years)"
                        },
                        {
                            "line": 85,
                            "code": "test_idx = df[\"Year\"].isin(test_years)"
                        },
                        {
                            "line": 87,
                            "code": "X_train, X_test = X[train_idx], X[test_idx]"
                        },
                        {
                            "line": 88,
                            "code": "y_train, y_test = y[train_idx], y[test_idx]"
                        }
                    ],
                    "summaryComponent": "data is split into training and test sets by year"
                },
                {
                    "codeSegments": [
                        {
                            "line": 91,
                            "code": "train_groups = df[train_idx].groupby(\"Year\").size().to_numpy()"
                        },
                        {
                            "line": 92,
                            "code": "test_groups = df[test_idx].groupby(\"Year\").size().to_numpy()"
                        }
                    ],
                    "summaryComponent": "group sizes are computed for ranking tasks"
                },
                {
                    "codeSegments": [
                        {
                            "line": 96,
                            "code": "objective=\"rank:pairwise\","
                        },
                        {
                            "line": 104,
                            "code": "model.fit(X_train, y_train, group=train_groups)"
                        }
                    ],
                    "summaryComponent": "model is trained using a pairwise ranking objective"
                },
                {
                    "codeSegments": [
                        {
                            "line": 107,
                            "code": "y_pred = model.predict(X_test)"
                        },
                        {
                            "line": 108,
                            "code": "df.loc[test_idx, \"PredictedScore\"] = y_pred"
                        },
                        {
                            "line": 109,
                            "code": "df.loc[test_idx, \"PredictedRank\"] = ("
                        }
                    ],
                    "summaryComponent": "predictions are made for the test years"
                },
                {
                    "codeSegments": [
                        {
                            "line": 115,
                            "code": "ndcg = evaluate_ndcg(y_test.to_numpy(), y_pred, test_groups)"
                        },
                        {
                            "line": 40,
                            "code": "def evaluate_ndcg(y_true, y_pred, group_sizes):"
                        }
                    ],
                    "summaryComponent": "results are evaluated using the NDCG metric"
                },
                {
                    "codeSegments": [
                        {
                            "line": 120,
                            "code": "plot_ranking_predictions(df, 2024)"
                        },
                        {
                            "line": 121,
                            "code": "plot_ranking_predictions(df, 2025)"
                        },
                        {
                            "line": 71,
                            "code": "plt.savefig(f\"data/ranking_predictions_{year}.png\")"
                        },
                        {
                            "line": 119,
                            "code": "print(df[test_idx][[\"Year\", \"Name\", \"Rank\", \"PredictedScore\", \"PredictedRank\"]])"
                        }
                    ],
                    "summaryComponent": "visualizes prediction errors for each player in the test years, saving the plots and printing detailed results"
                }
            ]
        },
        "event": "map_summary_code",
        "id": "8aGA3d5VppMFoUmzHeUA"
    },
    {
        "source": "backend",
        "timestamp": "2025-08-23 14:18:29.000",
        "data": {
            "summary": "• Loads player statistics from a CSV file and selects relevant features\n  ◦ Drops rows with missing values in selected features or rank\n  ◦ Sorts data by year and rank for consistency\n• Splits data into training (all but last two years) and testing (last two years) sets\n  ◦ Computes group sizes for each year to support ranking tasks\n• Trains an XGBoost ranking model with specified hyperparameters\n  ◦ Uses a pairwise ranking objective for learning\n• Makes predictions on the test set and assigns predicted ranks within each year\n• Evaluates model performance using the NDCG metric across test groups\n• Prints detailed prediction results for the test years\n• Visualizes and saves bar plots of prediction errors for each player in the test years",
            "code": "1: import pandas as pd\n2: from xgboost import XGBRanker\n3: from sklearn.metrics import ndcg_score\n4: import numpy as np\n5: import matplotlib.pyplot as plt\n6: import seaborn as sns\n7: \n8: \n9: def load_data(path=\"data/merged_data.csv\"):\n10:     df = pd.read_csv(path)\n11: \n12:     # Features to use\n13:     feature_cols = [\n14:         \"PTS\",\n15:         \"AST\",\n16:         \"TRB\",\n17:         \"FG%\",\n18:         \"BPM\",\n19:         \"WS/48\",\n20:         \"TS%\",\n21:         \"VORP\",\n22:         \"WS\",\n23:         \"PER\",\n24:     ]\n25:     feature_cols = [\n26:         col for col in feature_cols if col in df.columns\n27:     ]  # only keep existing features\n28:     df = df.dropna(subset=feature_cols + [\"Rank\"])\n29: \n30:     # Sort by Year and Rank for consistency\n31:     df = df.sort_values(by=[\"Year\", \"Rank\"])\n32: \n33:     X = df[feature_cols]\n34:     y = df[\"Rank\"]\n35:     groups = df.groupby(\"Year\").size().to_numpy()\n36: \n37:     return X, y, groups, df\n38: \n39: \n40: def evaluate_ndcg(y_true, y_pred, group_sizes):\n41:     scores = []\n42:     start = 0\n43:     for size in group_sizes:\n44:         true_ranks = y_true[start : start + size]\n45:         true_relevance = (max(true_ranks) + 1) - true_ranks\n46:         pred_scores = y_pred[start : start + size]\n47:         scores.append(ndcg_score([true_relevance], [pred_scores]))\n48:         start += size\n49:     return np.mean(scores)\n50: \n51: \n52: def plot_ranking_predictions(df, year):\n53:     \"\"\"\n54:     Plot prediction error for a specific year.\n55: \n56:     Args:\n57:         df: DataFrame containing prediction results\n58:         year: Year to plot prediction errors for\n59:     \"\"\"\n60:     df[\"RankError\"] = df[\"PredictedRank\"] - df[\"Rank\"]\n61:     year_df = df[df[\"Year\"] == year].copy()\n62:     year_df.sort_values(\"Rank\", inplace=True)\n63: \n64:     plt.figure(figsize=(12, 6))\n65:     sns.barplot(x=\"Name\", y=\"RankError\", data=year_df, hue=\"Name\", palette=\"coolwarm\")\n66:     plt.axhline(0, color=\"black\", linestyle=\"--\")\n67:     plt.xticks(rotation=45, ha=\"right\")\n68:     plt.ylabel(\"Predicted Rank - True Rank\")\n69:     plt.title(f\"MVP Ranking Predictions ({year})\")\n70:     plt.tight_layout()\n71:     plt.savefig(f\"data/ranking_predictions_{year}.png\")\n72: \n73: \n74: def main():\n75:     X, y, group, df = load_data()\n76: \n77:     # Train-test split on years\n78:     unique_years = df[\"Year\"].unique()\n79:     train_years, test_years = (\n80:         unique_years[:-2],  # train: 2015-2023\n81:         unique_years[-2:],  # test: 2024-2025\n82:     )\n83: \n84:     train_idx = df[\"Year\"].isin(train_years)\n85:     test_idx = df[\"Year\"].isin(test_years)\n86: \n87:     X_train, X_test = X[train_idx], X[test_idx]\n88:     y_train, y_test = y[train_idx], y[test_idx]\n89: \n90:     # Group sizes\n91:     train_groups = df[train_idx].groupby(\"Year\").size().to_numpy()\n92:     test_groups = df[test_idx].groupby(\"Year\").size().to_numpy()\n93: \n94:     # Model\n95:     model = XGBRanker(\n96:         objective=\"rank:pairwise\",\n97:         learning_rate=0.1,\n98:         n_estimators=100,\n99:         max_depth=4,\n100:         random_state=42,\n101:     )\n102: \n103:     print(\"Training XGBoostRanker...\")\n104:     model.fit(X_train, y_train, group=train_groups)\n105: \n106:     # Predict, sort, and evaluate\n107:     y_pred = model.predict(X_test)\n108:     df.loc[test_idx, \"PredictedScore\"] = y_pred\n109:     df.loc[test_idx, \"PredictedRank\"] = (\n110:         df.loc[test_idx]\n111:         .groupby(\"Year\")[\"PredictedScore\"]\n112:         .rank(ascending=False, method=\"first\")\n113:     )\n114: \n115:     ndcg = evaluate_ndcg(y_test.to_numpy(), y_pred, test_groups)\n116:     print(f\"NDCG Score on test years {test_years.tolist()}: {ndcg:.4f}\")\n117: \n118:     # Show results\n119:     print(df[test_idx][[\"Year\", \"Name\", \"Rank\", \"PredictedScore\", \"PredictedRank\"]])\n120:     plot_ranking_predictions(df, 2024)\n121:     plot_ranking_predictions(df, 2025)\n122: \n123: \n124: if __name__ == \"__main__\":\n125:     main()\n126: ",
            "mapping": [
                {
                    "codeSegments": [
                        {
                            "line": 9,
                            "code": "def load_data(path=\"data/merged_data.csv\"):"
                        },
                        {
                            "line": 10,
                            "code": "df = pd.read_csv(path)"
                        },
                        {
                            "line": 13,
                            "code": "feature_cols = ["
                        }
                    ],
                    "summaryComponent": "Loads player statistics from a CSV file and selects relevant features"
                },
                {
                    "codeSegments": [
                        {
                            "line": 28,
                            "code": "df = df.dropna(subset=feature_cols + [\"Rank\"])"
                        }
                    ],
                    "summaryComponent": "Drops rows with missing values in selected features or rank"
                },
                {
                    "codeSegments": [
                        {
                            "line": 31,
                            "code": "df = df.sort_values(by=[\"Year\", \"Rank\"])"
                        }
                    ],
                    "summaryComponent": "Sorts data by year and rank for consistency"
                },
                {
                    "codeSegments": [
                        {
                            "line": 78,
                            "code": "unique_years = df[\"Year\"].unique()"
                        },
                        {
                            "line": 79,
                            "code": "train_years, test_years = ("
                        },
                        {
                            "line": 84,
                            "code": "train_idx = df[\"Year\"].isin(train_years)"
                        },
                        {
                            "line": 85,
                            "code": "test_idx = df[\"Year\"].isin(test_years)"
                        },
                        {
                            "line": 87,
                            "code": "X_train, X_test = X[train_idx], X[test_idx]"
                        },
                        {
                            "line": 88,
                            "code": "y_train, y_test = y[train_idx], y[test_idx]"
                        }
                    ],
                    "summaryComponent": "Splits data into training (all but last two years) and testing (last two years) sets"
                },
                {
                    "codeSegments": [
                        {
                            "line": 91,
                            "code": "train_groups = df[train_idx].groupby(\"Year\").size().to_numpy()"
                        },
                        {
                            "line": 92,
                            "code": "test_groups = df[test_idx].groupby(\"Year\").size().to_numpy()"
                        }
                    ],
                    "summaryComponent": "Computes group sizes for each year to support ranking tasks"
                },
                {
                    "codeSegments": [
                        {
                            "line": 95,
                            "code": "model = XGBRanker("
                        },
                        {
                            "line": 104,
                            "code": "model.fit(X_train, y_train, group=train_groups)"
                        }
                    ],
                    "summaryComponent": "Trains an XGBoost ranking model with specified hyperparameters"
                },
                {
                    "codeSegments": [
                        {
                            "line": 96,
                            "code": "objective=\"rank:pairwise\","
                        }
                    ],
                    "summaryComponent": "Uses a pairwise ranking objective for learning"
                },
                {
                    "codeSegments": [
                        {
                            "line": 107,
                            "code": "y_pred = model.predict(X_test)"
                        },
                        {
                            "line": 108,
                            "code": "df.loc[test_idx, \"PredictedScore\"] = y_pred"
                        },
                        {
                            "line": 109,
                            "code": "df.loc[test_idx, \"PredictedRank\"] = ("
                        }
                    ],
                    "summaryComponent": "Makes predictions on the test set and assigns predicted ranks within each year"
                },
                {
                    "codeSegments": [
                        {
                            "line": 115,
                            "code": "ndcg = evaluate_ndcg(y_test.to_numpy(), y_pred, test_groups)"
                        }
                    ],
                    "summaryComponent": "Evaluates model performance using the NDCG metric across test groups"
                },
                {
                    "codeSegments": [
                        {
                            "line": 119,
                            "code": "print(df[test_idx][[\"Year\", \"Name\", \"Rank\", \"PredictedScore\", \"PredictedRank\"]])"
                        }
                    ],
                    "summaryComponent": "Prints detailed prediction results for the test years"
                },
                {
                    "codeSegments": [
                        {
                            "line": 120,
                            "code": "plot_ranking_predictions(df, 2024)"
                        },
                        {
                            "line": 121,
                            "code": "plot_ranking_predictions(df, 2025)"
                        }
                    ],
                    "summaryComponent": "Visualizes and saves bar plots of prediction errors for each player in the test years"
                }
            ]
        },
        "event": "map_summary_code",
        "id": "N3uaKFNzd9cQAXll6KKa"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:18:30.000",
        "data": {
            "after_section_id": "11ae5d57-f80f-4ae7-8c27-e6490cbed62e",
            "before_section_id": null
        },
        "event": "autotransit_section",
        "id": "Zoxlf9HYYuqBpn8o2tCC"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:18:30.000",
        "data": {
            "section_data": {
                "editPromptValue": "",
                "summaryData": {
                    "high_unstructured": "This code is designed to train and evaluate an XGBoost-based ranking model for basketball MVP predictions. It begins by loading and cleaning a dataset of player statistics, selecting relevant features, and removing incomplete entries. The data is split into training and test sets by year, and group sizes are computed for ranking tasks. The model is trained using a pairwise ranking objective, predictions are made for the test years, and the results are evaluated using the NDCG metric. Finally, the code visualizes prediction errors for each player in the test years, saving the plots and printing detailed results.",
                    "low_structured": "• Loads and preprocesses player data\n• Trains and evaluates a ranking model\n• Plots prediction errors for specific years",
                    "high_structured": "• Loads player statistics from a CSV file and selects relevant features\n  ◦ Drops rows with missing values in selected features or rank\n  ◦ Sorts data by year and rank for consistency\n• Splits data into training (all but last two years) and testing (last two years) sets\n  ◦ Computes group sizes for each year to support ranking tasks\n• Trains an XGBoost ranking model with specified hyperparameters\n  ◦ Uses a pairwise ranking objective for learning\n• Makes predictions on the test set and assigns predicted ranks within each year\n• Evaluates model performance using the NDCG metric across test groups\n• Prints detailed prediction results for the test years\n• Visualizes and saves bar plots of prediction errors for each player in the test years",
                    "title": "Summary of MVP Ranking Model Training and Evaluation Code",
                    "medium_unstructured": "The code loads basketball player statistics, cleans and prepares the data, and splits it into training and testing sets based on years. It then trains an XGBoost ranking model to predict player ranks, evaluates the model using NDCG, and visualizes prediction errors for recent years. Results and evaluation metrics are printed and saved as plots.",
                    "medium_structured": "• Loads and preprocesses player statistics from a CSV file\n• Splits data into training and testing sets by year\n• Trains an XGBoost ranking model on the training data\n• Evaluates model performance using NDCG score\n• Plots and saves prediction error visualizations for selected years",
                    "low_unstructured": "This code loads basketball player data, trains an XGBoost ranking model, evaluates its performance, and visualizes prediction errors."
                },
                "selectedDetailLevel": "medium",
                "title": "Summary of MVP Ranking Model Training and Evaluation Code",
                "summaryMappings": {
                    "low_structured": [
                        {
                            "codeSegments": [
                                {
                                    "line": 9,
                                    "code": "def load_data(path=\"data/merged_data.csv\"):"
                                },
                                {
                                    "line": 10,
                                    "code": "df = pd.read_csv(path)"
                                },
                                {
                                    "line": 13,
                                    "code": "feature_cols = ["
                                },
                                {
                                    "line": 28,
                                    "code": "df = df.dropna(subset=feature_cols + [\"Rank\"])"
                                },
                                {
                                    "line": 31,
                                    "code": "df = df.sort_values(by=[\"Year\", \"Rank\"])"
                                },
                                {
                                    "line": 37,
                                    "code": "return X, y, groups, df"
                                },
                                {
                                    "line": 75,
                                    "code": "X, y, group, df = load_data()"
                                }
                            ],
                            "summaryComponent": "Loads and preprocesses player data"
                        },
                        {
                            "codeSegments": [
                                {
                                    "line": 95,
                                    "code": "model = XGBRanker("
                                },
                                {
                                    "line": 104,
                                    "code": "model.fit(X_train, y_train, group=train_groups)"
                                },
                                {
                                    "line": 107,
                                    "code": "y_pred = model.predict(X_test)"
                                },
                                {
                                    "line": 115,
                                    "code": "ndcg = evaluate_ndcg(y_test.to_numpy(), y_pred, test_groups)"
                                },
                                {
                                    "line": 116,
                                    "code": "print(f\"NDCG Score on test years {test_years.tolist()}: {ndcg:.4f}\")"
                                }
                            ],
                            "summaryComponent": "Trains and evaluates a ranking model"
                        },
                        {
                            "codeSegments": [
                                {
                                    "line": 52,
                                    "code": "def plot_ranking_predictions(df, year):"
                                },
                                {
                                    "line": 120,
                                    "code": "plot_ranking_predictions(df, 2024)"
                                },
                                {
                                    "line": 121,
                                    "code": "plot_ranking_predictions(df, 2025)"
                                }
                            ],
                            "summaryComponent": "Plots prediction errors for specific years"
                        }
                    ],
                    "high_structured": [
                        {
                            "codeSegments": [
                                {
                                    "line": 9,
                                    "code": "def load_data(path=\"data/merged_data.csv\"):"
                                },
                                {
                                    "line": 10,
                                    "code": "df = pd.read_csv(path)"
                                },
                                {
                                    "line": 13,
                                    "code": "feature_cols = ["
                                }
                            ],
                            "summaryComponent": "Loads player statistics from a CSV file and selects relevant features"
                        },
                        {
                            "codeSegments": [
                                {
                                    "line": 28,
                                    "code": "df = df.dropna(subset=feature_cols + [\"Rank\"])"
                                }
                            ],
                            "summaryComponent": "Drops rows with missing values in selected features or rank"
                        },
                        {
                            "codeSegments": [
                                {
                                    "line": 31,
                                    "code": "df = df.sort_values(by=[\"Year\", \"Rank\"])"
                                }
                            ],
                            "summaryComponent": "Sorts data by year and rank for consistency"
                        },
                        {
                            "codeSegments": [
                                {
                                    "line": 78,
                                    "code": "unique_years = df[\"Year\"].unique()"
                                },
                                {
                                    "line": 79,
                                    "code": "train_years, test_years = ("
                                },
                                {
                                    "line": 84,
                                    "code": "train_idx = df[\"Year\"].isin(train_years)"
                                },
                                {
                                    "line": 85,
                                    "code": "test_idx = df[\"Year\"].isin(test_years)"
                                },
                                {
                                    "line": 87,
                                    "code": "X_train, X_test = X[train_idx], X[test_idx]"
                                },
                                {
                                    "line": 88,
                                    "code": "y_train, y_test = y[train_idx], y[test_idx]"
                                }
                            ],
                            "summaryComponent": "Splits data into training (all but last two years) and testing (last two years) sets"
                        },
                        {
                            "codeSegments": [
                                {
                                    "line": 91,
                                    "code": "train_groups = df[train_idx].groupby(\"Year\").size().to_numpy()"
                                },
                                {
                                    "line": 92,
                                    "code": "test_groups = df[test_idx].groupby(\"Year\").size().to_numpy()"
                                }
                            ],
                            "summaryComponent": "Computes group sizes for each year to support ranking tasks"
                        },
                        {
                            "codeSegments": [
                                {
                                    "line": 95,
                                    "code": "model = XGBRanker("
                                },
                                {
                                    "line": 104,
                                    "code": "model.fit(X_train, y_train, group=train_groups)"
                                }
                            ],
                            "summaryComponent": "Trains an XGBoost ranking model with specified hyperparameters"
                        },
                        {
                            "codeSegments": [
                                {
                                    "line": 96,
                                    "code": "objective=\"rank:pairwise\","
                                }
                            ],
                            "summaryComponent": "Uses a pairwise ranking objective for learning"
                        },
                        {
                            "codeSegments": [
                                {
                                    "line": 107,
                                    "code": "y_pred = model.predict(X_test)"
                                },
                                {
                                    "line": 108,
                                    "code": "df.loc[test_idx, \"PredictedScore\"] = y_pred"
                                },
                                {
                                    "line": 109,
                                    "code": "df.loc[test_idx, \"PredictedRank\"] = ("
                                }
                            ],
                            "summaryComponent": "Makes predictions on the test set and assigns predicted ranks within each year"
                        },
                        {
                            "codeSegments": [
                                {
                                    "line": 115,
                                    "code": "ndcg = evaluate_ndcg(y_test.to_numpy(), y_pred, test_groups)"
                                }
                            ],
                            "summaryComponent": "Evaluates model performance using the NDCG metric across test groups"
                        },
                        {
                            "codeSegments": [
                                {
                                    "line": 119,
                                    "code": "print(df[test_idx][[\"Year\", \"Name\", \"Rank\", \"PredictedScore\", \"PredictedRank\"]])"
                                }
                            ],
                            "summaryComponent": "Prints detailed prediction results for the test years"
                        },
                        {
                            "codeSegments": [
                                {
                                    "line": 120,
                                    "code": "plot_ranking_predictions(df, 2024)"
                                },
                                {
                                    "line": 121,
                                    "code": "plot_ranking_predictions(df, 2025)"
                                }
                            ],
                            "summaryComponent": "Visualizes and saves bar plots of prediction errors for each player in the test years"
                        }
                    ],
                    "medium_structured": [
                        {
                            "codeSegments": [
                                {
                                    "line": 9,
                                    "code": "def load_data(path=\"data/merged_data.csv\"):"
                                },
                                {
                                    "line": 10,
                                    "code": "df = pd.read_csv(path)"
                                },
                                {
                                    "line": 13,
                                    "code": "feature_cols = ["
                                },
                                {
                                    "line": 28,
                                    "code": "df = df.dropna(subset=feature_cols + [\"Rank\"])"
                                }
                            ],
                            "summaryComponent": "Loads and preprocesses player statistics from a CSV file"
                        },
                        {
                            "codeSegments": [
                                {
                                    "line": 78,
                                    "code": "unique_years = df[\"Year\"].unique()"
                                },
                                {
                                    "line": 79,
                                    "code": "train_years, test_years = ("
                                },
                                {
                                    "line": 84,
                                    "code": "train_idx = df[\"Year\"].isin(train_years)"
                                },
                                {
                                    "line": 85,
                                    "code": "test_idx = df[\"Year\"].isin(test_years)"
                                },
                                {
                                    "line": 87,
                                    "code": "X_train, X_test = X[train_idx], X[test_idx]"
                                },
                                {
                                    "line": 88,
                                    "code": "y_train, y_test = y[train_idx], y[test_idx]"
                                }
                            ],
                            "summaryComponent": "Splits data into training and testing sets by year"
                        },
                        {
                            "codeSegments": [
                                {
                                    "line": 95,
                                    "code": "model = XGBRanker("
                                },
                                {
                                    "line": 104,
                                    "code": "model.fit(X_train, y_train, group=train_groups)"
                                }
                            ],
                            "summaryComponent": "Trains an XGBoost ranking model on the training data"
                        },
                        {
                            "codeSegments": [
                                {
                                    "line": 115,
                                    "code": "ndcg = evaluate_ndcg(y_test.to_numpy(), y_pred, test_groups)"
                                },
                                {
                                    "line": 40,
                                    "code": "def evaluate_ndcg(y_true, y_pred, group_sizes):"
                                }
                            ],
                            "summaryComponent": "Evaluates model performance using NDCG score"
                        },
                        {
                            "codeSegments": [
                                {
                                    "line": 52,
                                    "code": "def plot_ranking_predictions(df, year):"
                                },
                                {
                                    "line": 120,
                                    "code": "plot_ranking_predictions(df, 2024)"
                                },
                                {
                                    "line": 121,
                                    "code": "plot_ranking_predictions(df, 2025)"
                                },
                                {
                                    "line": 71,
                                    "code": "plt.savefig(f\"data/ranking_predictions_{year}.png\")"
                                }
                            ],
                            "summaryComponent": "Plots and saves prediction error visualizations for selected years"
                        }
                    ],
                    "medium_unstructured": [
                        {
                            "codeSegments": [
                                {
                                    "line": 10,
                                    "code": "df = pd.read_csv(path)"
                                }
                            ],
                            "summaryComponent": "loads basketball player statistics"
                        },
                        {
                            "codeSegments": [
                                {
                                    "line": 13,
                                    "code": "feature_cols = ["
                                },
                                {
                                    "line": 25,
                                    "code": "feature_cols = ["
                                },
                                {
                                    "line": 28,
                                    "code": "df = df.dropna(subset=feature_cols + [\"Rank\"])"
                                },
                                {
                                    "line": 31,
                                    "code": "df = df.sort_values(by=[\"Year\", \"Rank\"])"
                                }
                            ],
                            "summaryComponent": "cleans and prepares the data"
                        },
                        {
                            "codeSegments": [
                                {
                                    "line": 78,
                                    "code": "unique_years = df[\"Year\"].unique()"
                                },
                                {
                                    "line": 79,
                                    "code": "train_years, test_years = ("
                                },
                                {
                                    "line": 84,
                                    "code": "train_idx = df[\"Year\"].isin(train_years)"
                                },
                                {
                                    "line": 85,
                                    "code": "test_idx = df[\"Year\"].isin(test_years)"
                                },
                                {
                                    "line": 87,
                                    "code": "X_train, X_test = X[train_idx], X[test_idx]"
                                },
                                {
                                    "line": 88,
                                    "code": "y_train, y_test = y[train_idx], y[test_idx]"
                                }
                            ],
                            "summaryComponent": "splits it into training and testing sets based on years"
                        },
                        {
                            "codeSegments": [
                                {
                                    "line": 95,
                                    "code": "model = XGBRanker("
                                },
                                {
                                    "line": 104,
                                    "code": "model.fit(X_train, y_train, group=train_groups)"
                                }
                            ],
                            "summaryComponent": "trains an XGBoost ranking model to predict player ranks"
                        },
                        {
                            "codeSegments": [
                                {
                                    "line": 115,
                                    "code": "ndcg = evaluate_ndcg(y_test.to_numpy(), y_pred, test_groups)"
                                }
                            ],
                            "summaryComponent": "evaluates the model using NDCG"
                        },
                        {
                            "codeSegments": [
                                {
                                    "line": 120,
                                    "code": "plot_ranking_predictions(df, 2024)"
                                },
                                {
                                    "line": 121,
                                    "code": "plot_ranking_predictions(df, 2025)"
                                }
                            ],
                            "summaryComponent": "visualizes prediction errors for recent years"
                        },
                        {
                            "codeSegments": [
                                {
                                    "line": 116,
                                    "code": "print(f\"NDCG Score on test years {test_years.tolist()}: {ndcg:.4f}\")"
                                },
                                {
                                    "line": 119,
                                    "code": "print(df[test_idx][[\"Year\", \"Name\", \"Rank\", \"PredictedScore\", \"PredictedRank\"]])"
                                }
                            ],
                            "summaryComponent": "Results and evaluation metrics are printed"
                        },
                        {
                            "codeSegments": [
                                {
                                    "line": 71,
                                    "code": "plt.savefig(f\"data/ranking_predictions_{year}.png\")"
                                }
                            ],
                            "summaryComponent": "saved as plots"
                        }
                    ],
                    "high_unstructured": [
                        {
                            "codeSegments": [
                                {
                                    "line": 95,
                                    "code": "model = XGBRanker("
                                },
                                {
                                    "line": 104,
                                    "code": "model.fit(X_train, y_train, group=train_groups)"
                                },
                                {
                                    "line": 107,
                                    "code": "y_pred = model.predict(X_test)"
                                }
                            ],
                            "summaryComponent": "train and evaluate an XGBoost-based ranking model"
                        },
                        {
                            "codeSegments": [
                                {
                                    "line": 9,
                                    "code": "def load_data(path=\"data/merged_data.csv\"):"
                                },
                                {
                                    "line": 10,
                                    "code": "df = pd.read_csv(path)"
                                },
                                {
                                    "line": 28,
                                    "code": "df = df.dropna(subset=feature_cols + [\"Rank\"])"
                                }
                            ],
                            "summaryComponent": "loading and cleaning a dataset of player statistics"
                        },
                        {
                            "codeSegments": [
                                {
                                    "line": 13,
                                    "code": "feature_cols = ["
                                },
                                {
                                    "line": 25,
                                    "code": "feature_cols = ["
                                }
                            ],
                            "summaryComponent": "selecting relevant features"
                        },
                        {
                            "codeSegments": [
                                {
                                    "line": 28,
                                    "code": "df = df.dropna(subset=feature_cols + [\"Rank\"])"
                                }
                            ],
                            "summaryComponent": "removing incomplete entries"
                        },
                        {
                            "codeSegments": [
                                {
                                    "line": 79,
                                    "code": "train_years, test_years = ("
                                },
                                {
                                    "line": 84,
                                    "code": "train_idx = df[\"Year\"].isin(train_years)"
                                },
                                {
                                    "line": 85,
                                    "code": "test_idx = df[\"Year\"].isin(test_years)"
                                },
                                {
                                    "line": 87,
                                    "code": "X_train, X_test = X[train_idx], X[test_idx]"
                                },
                                {
                                    "line": 88,
                                    "code": "y_train, y_test = y[train_idx], y[test_idx]"
                                }
                            ],
                            "summaryComponent": "data is split into training and test sets by year"
                        },
                        {
                            "codeSegments": [
                                {
                                    "line": 91,
                                    "code": "train_groups = df[train_idx].groupby(\"Year\").size().to_numpy()"
                                },
                                {
                                    "line": 92,
                                    "code": "test_groups = df[test_idx].groupby(\"Year\").size().to_numpy()"
                                }
                            ],
                            "summaryComponent": "group sizes are computed for ranking tasks"
                        },
                        {
                            "codeSegments": [
                                {
                                    "line": 96,
                                    "code": "objective=\"rank:pairwise\","
                                },
                                {
                                    "line": 104,
                                    "code": "model.fit(X_train, y_train, group=train_groups)"
                                }
                            ],
                            "summaryComponent": "model is trained using a pairwise ranking objective"
                        },
                        {
                            "codeSegments": [
                                {
                                    "line": 107,
                                    "code": "y_pred = model.predict(X_test)"
                                },
                                {
                                    "line": 108,
                                    "code": "df.loc[test_idx, \"PredictedScore\"] = y_pred"
                                },
                                {
                                    "line": 109,
                                    "code": "df.loc[test_idx, \"PredictedRank\"] = ("
                                }
                            ],
                            "summaryComponent": "predictions are made for the test years"
                        },
                        {
                            "codeSegments": [
                                {
                                    "line": 115,
                                    "code": "ndcg = evaluate_ndcg(y_test.to_numpy(), y_pred, test_groups)"
                                },
                                {
                                    "line": 40,
                                    "code": "def evaluate_ndcg(y_true, y_pred, group_sizes):"
                                }
                            ],
                            "summaryComponent": "results are evaluated using the NDCG metric"
                        },
                        {
                            "codeSegments": [
                                {
                                    "line": 120,
                                    "code": "plot_ranking_predictions(df, 2024)"
                                },
                                {
                                    "line": 121,
                                    "code": "plot_ranking_predictions(df, 2025)"
                                },
                                {
                                    "line": 71,
                                    "code": "plt.savefig(f\"data/ranking_predictions_{year}.png\")"
                                },
                                {
                                    "line": 119,
                                    "code": "print(df[test_idx][[\"Year\", \"Name\", \"Rank\", \"PredictedScore\", \"PredictedRank\"]])"
                                }
                            ],
                            "summaryComponent": "visualizes prediction errors for each player in the test years, saving the plots and printing detailed results"
                        }
                    ],
                    "low_unstructured": [
                        {
                            "codeSegments": [
                                {
                                    "line": 9,
                                    "code": "def load_data(path=\"data/merged_data.csv\"):"
                                },
                                {
                                    "line": 10,
                                    "code": "df = pd.read_csv(path)"
                                }
                            ],
                            "summaryComponent": "loads basketball player data"
                        },
                        {
                            "codeSegments": [
                                {
                                    "line": 95,
                                    "code": "model = XGBRanker("
                                },
                                {
                                    "line": 104,
                                    "code": "model.fit(X_train, y_train, group=train_groups)"
                                }
                            ],
                            "summaryComponent": "trains an XGBoost ranking model"
                        },
                        {
                            "codeSegments": [
                                {
                                    "line": 115,
                                    "code": "ndcg = evaluate_ndcg(y_test.to_numpy(), y_pred, test_groups)"
                                },
                                {
                                    "line": 116,
                                    "code": "print(f\"NDCG Score on test years {test_years.tolist()}: {ndcg:.4f}\")"
                                }
                            ],
                            "summaryComponent": "evaluates its performance"
                        },
                        {
                            "codeSegments": [
                                {
                                    "line": 120,
                                    "code": "plot_ranking_predictions(df, 2024)"
                                },
                                {
                                    "line": 121,
                                    "code": "plot_ranking_predictions(df, 2025)"
                                }
                            ],
                            "summaryComponent": "visualizes prediction errors"
                        }
                    ]
                },
                "metadata": {
                    "id": "11ae5d57-f80f-4ae7-8c27-e6490cbed62e",
                    "filename": "rank_model.py",
                    "offset": 0,
                    "fullPath": "/project/workspace/rank_model.py",
                    "originalCode": "import pandas as pd\nfrom xgboost import XGBRanker\nfrom sklearn.metrics import ndcg_score\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport seaborn as sns\n\n\ndef load_data(path=\"data/merged_data.csv\"):\n    df = pd.read_csv(path)\n\n    # Features to use\n    feature_cols = [\n        \"PTS\",\n        \"AST\",\n        \"TRB\",\n        \"FG%\",\n        \"BPM\",\n        \"WS/48\",\n        \"TS%\",\n        \"VORP\",\n        \"WS\",\n        \"PER\",\n    ]\n    feature_cols = [\n        col for col in feature_cols if col in df.columns\n    ]  # only keep existing features\n    df = df.dropna(subset=feature_cols + [\"Rank\"])\n\n    # Sort by Year and Rank for consistency\n    df = df.sort_values(by=[\"Year\", \"Rank\"])\n\n    X = df[feature_cols]\n    y = df[\"Rank\"]\n    groups = df.groupby(\"Year\").size().to_numpy()\n\n    return X, y, groups, df\n\n\ndef evaluate_ndcg(y_true, y_pred, group_sizes):\n    scores = []\n    start = 0\n    for size in group_sizes:\n        true_ranks = y_true[start : start + size]\n        true_relevance = (max(true_ranks) + 1) - true_ranks\n        pred_scores = y_pred[start : start + size]\n        scores.append(ndcg_score([true_relevance], [pred_scores]))\n        start += size\n    return np.mean(scores)\n\n\ndef plot_ranking_predictions(df, year):\n    \"\"\"\n    Plot prediction error for a specific year.\n\n    Args:\n        df: DataFrame containing prediction results\n        year: Year to plot prediction errors for\n    \"\"\"\n    df[\"RankError\"] = df[\"PredictedRank\"] - df[\"Rank\"]\n    year_df = df[df[\"Year\"] == year].copy()\n    year_df.sort_values(\"Rank\", inplace=True)\n\n    plt.figure(figsize=(12, 6))\n    sns.barplot(x=\"Name\", y=\"RankError\", data=year_df, hue=\"Name\", palette=\"coolwarm\")\n    plt.axhline(0, color=\"black\", linestyle=\"--\")\n    plt.xticks(rotation=45, ha=\"right\")\n    plt.ylabel(\"Predicted Rank - True Rank\")\n    plt.title(f\"MVP Ranking Predictions ({year})\")\n    plt.tight_layout()\n    plt.savefig(f\"data/ranking_predictions_{year}.png\")\n\n\ndef main():\n    X, y, group, df = load_data()\n\n    # Train-test split on years\n    unique_years = df[\"Year\"].unique()\n    train_years, test_years = (\n        unique_years[:-2],  # train: 2015-2023\n        unique_years[-2:],  # test: 2024-2025\n    )\n\n    train_idx = df[\"Year\"].isin(train_years)\n    test_idx = df[\"Year\"].isin(test_years)\n\n    X_train, X_test = X[train_idx], X[test_idx]\n    y_train, y_test = y[train_idx], y[test_idx]\n\n    # Group sizes\n    train_groups = df[train_idx].groupby(\"Year\").size().to_numpy()\n    test_groups = df[test_idx].groupby(\"Year\").size().to_numpy()\n\n    # Model\n    model = XGBRanker(\n        objective=\"rank:pairwise\",\n        learning_rate=0.1,\n        n_estimators=100,\n        max_depth=4,\n        random_state=42,\n    )\n\n    print(\"Training XGBoostRanker...\")\n    model.fit(X_train, y_train, group=train_groups)\n\n    # Predict, sort, and evaluate\n    y_pred = model.predict(X_test)\n    df.loc[test_idx, \"PredictedScore\"] = y_pred\n    df.loc[test_idx, \"PredictedRank\"] = (\n        df.loc[test_idx]\n        .groupby(\"Year\")[\"PredictedScore\"]\n        .rank(ascending=False, method=\"first\")\n    )\n\n    ndcg = evaluate_ndcg(y_test.to_numpy(), y_pred, test_groups)\n    print(f\"NDCG Score on test years {test_years.tolist()}: {ndcg:.4f}\")\n\n    # Show results\n    print(df[test_idx][[\"Year\", \"Name\", \"Rank\", \"PredictedScore\", \"PredictedRank\"]])\n    plot_ranking_predictions(df, 2024)\n    plot_ranking_predictions(df, 2025)\n\n\nif __name__ == \"__main__\":\n    main()\n"
                },
                "createdAt": 1755987511000,
                "lines": [
                    1,
                    126
                ],
                "editPromptStructured": null,
                "selectedStructured": "unstructured",
                "editPromptDetailLevel": null
            },
            "section_id": "11ae5d57-f80f-4ae7-8c27-e6490cbed62e"
        },
        "event": "create_new_section",
        "id": "tyYqMnQkeE9VyXwOZIgR"
    },
    {
        "source": "backend",
        "timestamp": "2025-08-23 14:18:31.000",
        "data": {
            "summary": "• Loads and preprocesses player data\n• Trains and evaluates a ranking model\n• Plots prediction errors for specific years",
            "code": "1: import pandas as pd\n2: from xgboost import XGBRanker\n3: from sklearn.metrics import ndcg_score\n4: import numpy as np\n5: import matplotlib.pyplot as plt\n6: import seaborn as sns\n7: \n8: \n9: def load_data(path=\"data/merged_data.csv\"):\n10:     df = pd.read_csv(path)\n11: \n12:     # Features to use\n13:     feature_cols = [\n14:         \"PTS\",\n15:         \"AST\",\n16:         \"TRB\",\n17:         \"FG%\",\n18:         \"BPM\",\n19:         \"WS/48\",\n20:         \"TS%\",\n21:         \"VORP\",\n22:         \"WS\",\n23:         \"PER\",\n24:     ]\n25:     feature_cols = [\n26:         col for col in feature_cols if col in df.columns\n27:     ]  # only keep existing features\n28:     df = df.dropna(subset=feature_cols + [\"Rank\"])\n29: \n30:     # Sort by Year and Rank for consistency\n31:     df = df.sort_values(by=[\"Year\", \"Rank\"])\n32: \n33:     X = df[feature_cols]\n34:     y = df[\"Rank\"]\n35:     groups = df.groupby(\"Year\").size().to_numpy()\n36: \n37:     return X, y, groups, df\n38: \n39: \n40: def evaluate_ndcg(y_true, y_pred, group_sizes):\n41:     scores = []\n42:     start = 0\n43:     for size in group_sizes:\n44:         true_ranks = y_true[start : start + size]\n45:         true_relevance = (max(true_ranks) + 1) - true_ranks\n46:         pred_scores = y_pred[start : start + size]\n47:         scores.append(ndcg_score([true_relevance], [pred_scores]))\n48:         start += size\n49:     return np.mean(scores)\n50: \n51: \n52: def plot_ranking_predictions(df, year):\n53:     \"\"\"\n54:     Plot prediction error for a specific year.\n55: \n56:     Args:\n57:         df: DataFrame containing prediction results\n58:         year: Year to plot prediction errors for\n59:     \"\"\"\n60:     df[\"RankError\"] = df[\"PredictedRank\"] - df[\"Rank\"]\n61:     year_df = df[df[\"Year\"] == year].copy()\n62:     year_df.sort_values(\"Rank\", inplace=True)\n63: \n64:     plt.figure(figsize=(12, 6))\n65:     sns.barplot(x=\"Name\", y=\"RankError\", data=year_df, hue=\"Name\", palette=\"coolwarm\")\n66:     plt.axhline(0, color=\"black\", linestyle=\"--\")\n67:     plt.xticks(rotation=45, ha=\"right\")\n68:     plt.ylabel(\"Predicted Rank - True Rank\")\n69:     plt.title(f\"MVP Ranking Predictions ({year})\")\n70:     plt.tight_layout()\n71:     plt.savefig(f\"data/ranking_predictions_{year}.png\")\n72: \n73: \n74: def main():\n75:     X, y, group, df = load_data()\n76: \n77:     # Train-test split on years\n78:     unique_years = df[\"Year\"].unique()\n79:     train_years, test_years = (\n80:         unique_years[:-2],  # train: 2015-2023\n81:         unique_years[-2:],  # test: 2024-2025\n82:     )\n83: \n84:     train_idx = df[\"Year\"].isin(train_years)\n85:     test_idx = df[\"Year\"].isin(test_years)\n86: \n87:     X_train, X_test = X[train_idx], X[test_idx]\n88:     y_train, y_test = y[train_idx], y[test_idx]\n89: \n90:     # Group sizes\n91:     train_groups = df[train_idx].groupby(\"Year\").size().to_numpy()\n92:     test_groups = df[test_idx].groupby(\"Year\").size().to_numpy()\n93: \n94:     # Model\n95:     model = XGBRanker(\n96:         objective=\"rank:pairwise\",\n97:         learning_rate=0.1,\n98:         n_estimators=100,\n99:         max_depth=4,\n100:         random_state=42,\n101:     )\n102: \n103:     print(\"Training XGBoostRanker...\")\n104:     model.fit(X_train, y_train, group=train_groups)\n105: \n106:     # Predict, sort, and evaluate\n107:     y_pred = model.predict(X_test)\n108:     df.loc[test_idx, \"PredictedScore\"] = y_pred\n109:     df.loc[test_idx, \"PredictedRank\"] = (\n110:         df.loc[test_idx]\n111:         .groupby(\"Year\")[\"PredictedScore\"]\n112:         .rank(ascending=False, method=\"first\")\n113:     )\n114: \n115:     ndcg = evaluate_ndcg(y_test.to_numpy(), y_pred, test_groups)\n116:     print(f\"NDCG Score on test years {test_years.tolist()}: {ndcg:.4f}\")\n117: \n118:     # Show results\n119:     print(df[test_idx][[\"Year\", \"Name\", \"Rank\", \"PredictedScore\", \"PredictedRank\"]])\n120:     plot_ranking_predictions(df, 2024)\n121:     plot_ranking_predictions(df, 2025)\n122: \n123: \n124: if __name__ == \"__main__\":\n125:     main()\n126: ",
            "mapping": [
                {
                    "codeSegments": [
                        {
                            "line": 9,
                            "code": "def load_data(path=\"data/merged_data.csv\"):"
                        },
                        {
                            "line": 10,
                            "code": "df = pd.read_csv(path)"
                        },
                        {
                            "line": 13,
                            "code": "feature_cols = ["
                        },
                        {
                            "line": 28,
                            "code": "df = df.dropna(subset=feature_cols + [\"Rank\"])"
                        },
                        {
                            "line": 31,
                            "code": "df = df.sort_values(by=[\"Year\", \"Rank\"])"
                        },
                        {
                            "line": 37,
                            "code": "return X, y, groups, df"
                        },
                        {
                            "line": 75,
                            "code": "X, y, group, df = load_data()"
                        }
                    ],
                    "summaryComponent": "Loads and preprocesses player data"
                },
                {
                    "codeSegments": [
                        {
                            "line": 95,
                            "code": "model = XGBRanker("
                        },
                        {
                            "line": 104,
                            "code": "model.fit(X_train, y_train, group=train_groups)"
                        },
                        {
                            "line": 107,
                            "code": "y_pred = model.predict(X_test)"
                        },
                        {
                            "line": 115,
                            "code": "ndcg = evaluate_ndcg(y_test.to_numpy(), y_pred, test_groups)"
                        },
                        {
                            "line": 116,
                            "code": "print(f\"NDCG Score on test years {test_years.tolist()}: {ndcg:.4f}\")"
                        }
                    ],
                    "summaryComponent": "Trains and evaluates a ranking model"
                },
                {
                    "codeSegments": [
                        {
                            "line": 52,
                            "code": "def plot_ranking_predictions(df, year):"
                        },
                        {
                            "line": 120,
                            "code": "plot_ranking_predictions(df, 2024)"
                        },
                        {
                            "line": 121,
                            "code": "plot_ranking_predictions(df, 2025)"
                        }
                    ],
                    "summaryComponent": "Plots prediction errors for specific years"
                }
            ]
        },
        "event": "map_summary_code",
        "id": "D27HREO3UQqCjMu0bFE1"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:18:32.000",
        "data": {
            "detail_level": "medium",
            "section_id": "11ae5d57-f80f-4ae7-8c27-e6490cbed62e",
            "structured_type": "unstructured"
        },
        "event": "mapping_unhover",
        "id": "9a5cnZ91FcwVHYkBESkl"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:18:32.000",
        "data": {
            "detail_level": "medium",
            "section_id": "11ae5d57-f80f-4ae7-8c27-e6490cbed62e",
            "structured_type": "unstructured"
        },
        "event": "mapping_unhover",
        "id": "C3GWZPqKEcY1un7W1L5N"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:18:32.000",
        "data": {
            "detail_level": "medium",
            "section_id": "11ae5d57-f80f-4ae7-8c27-e6490cbed62e",
            "structured_type": "unstructured"
        },
        "event": "mapping_unhover",
        "id": "E13e4GMxKXQDn5xIMBu9"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:18:32.000",
        "data": {
            "detail_level": "medium",
            "section_id": "11ae5d57-f80f-4ae7-8c27-e6490cbed62e",
            "structured_type": "unstructured",
            "mapping_index": 2
        },
        "event": "mapping_hover",
        "id": "FhRoMIsDlSHElJ2AuYm3"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:18:32.000",
        "data": {
            "detail_level": "medium",
            "section_id": "11ae5d57-f80f-4ae7-8c27-e6490cbed62e",
            "structured_type": "unstructured",
            "mapping_index": 5
        },
        "event": "mapping_hover",
        "id": "XKIMyYbXMBDgvp77Y87b"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:18:32.000",
        "data": {
            "detail_level": "medium",
            "section_id": "11ae5d57-f80f-4ae7-8c27-e6490cbed62e",
            "structured_type": "unstructured"
        },
        "event": "mapping_unhover",
        "id": "bEwRKbzPlF1rQT4cTyrA"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:18:32.000",
        "data": {
            "detail_level": "medium",
            "section_id": "11ae5d57-f80f-4ae7-8c27-e6490cbed62e",
            "structured_type": "unstructured",
            "mapping_index": 7
        },
        "event": "mapping_hover",
        "id": "e7LE5ipqe6ymVERWgzZd"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:18:32.000",
        "data": {
            "detail_level": "medium",
            "section_id": "11ae5d57-f80f-4ae7-8c27-e6490cbed62e",
            "structured_type": "unstructured"
        },
        "event": "mapping_unhover",
        "id": "ohRgUOjndRfB5bvWZ0lt"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:18:32.000",
        "data": {
            "detail_level": "medium",
            "section_id": "11ae5d57-f80f-4ae7-8c27-e6490cbed62e",
            "structured_type": "unstructured",
            "mapping_index": 3
        },
        "event": "mapping_hover",
        "id": "uoRprgDjbHR6Pd3bMFb4"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:18:32.000",
        "data": {
            "detail_level": "medium",
            "section_id": "11ae5d57-f80f-4ae7-8c27-e6490cbed62e",
            "structured_type": "unstructured",
            "mapping_index": 0
        },
        "event": "mapping_hover",
        "id": "yRefJI6JOFn406OcNzST"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:18:33.000",
        "data": {
            "detail_level": "medium",
            "section_id": "11ae5d57-f80f-4ae7-8c27-e6490cbed62e",
            "structured_type": "unstructured"
        },
        "event": "mapping_unhover",
        "id": "DG1jjhN7EiojbwGQs3zP"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:18:33.000",
        "data": {
            "detail_level": "medium",
            "section_id": "11ae5d57-f80f-4ae7-8c27-e6490cbed62e",
            "structured_type": "unstructured"
        },
        "event": "mapping_unhover",
        "id": "Ldj4sIcMo1VMgwmq1m65"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:18:33.000",
        "data": {
            "detail_level": "medium",
            "section_id": "11ae5d57-f80f-4ae7-8c27-e6490cbed62e",
            "structured_type": "unstructured",
            "mapping_index": 2
        },
        "event": "mapping_hover",
        "id": "SmyxleZMcIyHzFydyA2Z"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:18:33.000",
        "data": {
            "detail_level": "medium",
            "section_id": "11ae5d57-f80f-4ae7-8c27-e6490cbed62e",
            "structured_type": "unstructured",
            "mapping_index": 7
        },
        "event": "mapping_hover",
        "id": "ZJNRmVK0YDVm5KKcON4U"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:18:33.000",
        "data": {
            "detail_level": "medium",
            "section_id": "11ae5d57-f80f-4ae7-8c27-e6490cbed62e",
            "structured_type": "unstructured"
        },
        "event": "mapping_unhover",
        "id": "mezHD6Nc5gDab1mDMY96"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:18:33.000",
        "data": {
            "detail_level": "medium",
            "section_id": "11ae5d57-f80f-4ae7-8c27-e6490cbed62e",
            "structured_type": "unstructured"
        },
        "event": "mapping_unhover",
        "id": "tgMXgwj9EkP4qegRHmHk"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:18:33.000",
        "data": {
            "detail_level": "medium",
            "section_id": "11ae5d57-f80f-4ae7-8c27-e6490cbed62e",
            "structured_type": "unstructured",
            "mapping_index": 5
        },
        "event": "mapping_hover",
        "id": "xmWuZ9w4bwymb0hnSMpH"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:18:33.000",
        "data": {
            "detail_level": "medium",
            "section_id": "11ae5d57-f80f-4ae7-8c27-e6490cbed62e",
            "structured_type": "unstructured",
            "mapping_index": 5
        },
        "event": "mapping_hover",
        "id": "xnkYvSTv1x8vua4jWAgD"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:18:33.000",
        "data": {
            "detail_level": "medium",
            "section_id": "11ae5d57-f80f-4ae7-8c27-e6490cbed62e",
            "structured_type": "unstructured",
            "mapping_index": 4
        },
        "event": "mapping_hover",
        "id": "yR8xdgT8IXVRjCqmglBp"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:18:34.000",
        "data": {
            "before_detail_level": "medium",
            "before_structured": "unstructured",
            "section_id": "11ae5d57-f80f-4ae7-8c27-e6490cbed62e",
            "after_detail_level": "high",
            "after_structured": "unstructured"
        },
        "event": "change_summary_level",
        "id": "F0jPWxHQYWAjyyxmdHyr"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:18:34.000",
        "data": {
            "detail_level": "medium",
            "section_id": "11ae5d57-f80f-4ae7-8c27-e6490cbed62e",
            "structured_type": "unstructured"
        },
        "event": "mapping_unhover",
        "id": "Q4o9lhbTQibwupI8ebNb"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:18:34.000",
        "data": {
            "detail_level": "medium",
            "section_id": "11ae5d57-f80f-4ae7-8c27-e6490cbed62e",
            "structured_type": "unstructured",
            "mapping_index": 0
        },
        "event": "mapping_hover",
        "id": "XD3uVRTSFa19SfmNsQlw"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:18:34.000",
        "data": {
            "detail_level": "medium",
            "section_id": "11ae5d57-f80f-4ae7-8c27-e6490cbed62e",
            "structured_type": "unstructured"
        },
        "event": "mapping_unhover",
        "id": "ov2o5HHVWrvCuw7UozTl"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:18:35.000",
        "data": {
            "detail_level": "high",
            "section_id": "11ae5d57-f80f-4ae7-8c27-e6490cbed62e",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "8pBZuz2RxKazqK1c19Zk"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:18:35.000",
        "data": {
            "detail_level": "high",
            "section_id": "11ae5d57-f80f-4ae7-8c27-e6490cbed62e",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "Fmx7zpmwtirJH7wbaMGM"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:18:35.000",
        "data": {
            "detail_level": "high",
            "section_id": "11ae5d57-f80f-4ae7-8c27-e6490cbed62e",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "HBuX79jASYjlJqojtCOO"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:18:35.000",
        "data": {
            "before_detail_level": "high",
            "before_structured": "unstructured",
            "section_id": "11ae5d57-f80f-4ae7-8c27-e6490cbed62e",
            "after_detail_level": "high",
            "after_structured": "structured"
        },
        "event": "change_summary_level",
        "id": "HiLG2nfzpBpCDOkwNMTT"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:18:35.000",
        "data": {
            "detail_level": "high",
            "section_id": "11ae5d57-f80f-4ae7-8c27-e6490cbed62e",
            "structured_type": "structured",
            "mapping_index": 0
        },
        "event": "mapping_hover",
        "id": "KeQWp144o2hNWrRXwO3x"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:18:35.000",
        "data": {
            "detail_level": "high",
            "section_id": "11ae5d57-f80f-4ae7-8c27-e6490cbed62e",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "OmBuV8hl58amqxNMg3os"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:18:35.000",
        "data": {
            "detail_level": "high",
            "section_id": "11ae5d57-f80f-4ae7-8c27-e6490cbed62e",
            "structured_type": "structured",
            "mapping_index": 3
        },
        "event": "mapping_hover",
        "id": "TUzT9G2DpIm8QlbpAaDO"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:18:35.000",
        "data": {
            "detail_level": "high",
            "section_id": "11ae5d57-f80f-4ae7-8c27-e6490cbed62e",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "UrkoHYDKII6iy9TRf2Sx"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:18:35.000",
        "data": {
            "detail_level": "high",
            "section_id": "11ae5d57-f80f-4ae7-8c27-e6490cbed62e",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "YuzSksmug2G9ILFltgQG"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:18:35.000",
        "data": {
            "detail_level": "high",
            "section_id": "11ae5d57-f80f-4ae7-8c27-e6490cbed62e",
            "structured_type": "structured",
            "mapping_index": 1
        },
        "event": "mapping_hover",
        "id": "aWW8m7ZzsIryOpBlUM2h"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:18:35.000",
        "data": {
            "detail_level": "high",
            "section_id": "11ae5d57-f80f-4ae7-8c27-e6490cbed62e",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "bAMQ11kcqGs54EsdssN7"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:18:35.000",
        "data": {
            "detail_level": "high",
            "section_id": "11ae5d57-f80f-4ae7-8c27-e6490cbed62e",
            "structured_type": "structured",
            "mapping_index": 4
        },
        "event": "mapping_hover",
        "id": "nkP2MiiQmASMwg8OPIA2"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:18:35.000",
        "data": {
            "detail_level": "high",
            "section_id": "11ae5d57-f80f-4ae7-8c27-e6490cbed62e",
            "structured_type": "structured",
            "mapping_index": 0
        },
        "event": "mapping_hover",
        "id": "rJZSJMI6KBvkRBbKRLoU"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:18:35.000",
        "data": {
            "detail_level": "high",
            "section_id": "11ae5d57-f80f-4ae7-8c27-e6490cbed62e",
            "structured_type": "structured",
            "mapping_index": 2
        },
        "event": "mapping_hover",
        "id": "rMz3IdZe32QALfN3AnJN"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:18:35.000",
        "data": {
            "detail_level": "high",
            "section_id": "11ae5d57-f80f-4ae7-8c27-e6490cbed62e",
            "structured_type": "structured",
            "mapping_index": 1
        },
        "event": "mapping_hover",
        "id": "svUcv6tdzbL6EU2lQzho"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:18:35.000",
        "data": {
            "detail_level": "high",
            "section_id": "11ae5d57-f80f-4ae7-8c27-e6490cbed62e",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "xOrPVy6J9wfxHxuXkAwd"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:18:35.000",
        "data": {
            "detail_level": "high",
            "section_id": "11ae5d57-f80f-4ae7-8c27-e6490cbed62e",
            "structured_type": "structured",
            "mapping_index": 3
        },
        "event": "mapping_hover",
        "id": "xZo5kORXv7GXkEYqDH3N"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:18:35.000",
        "data": {
            "detail_level": "high",
            "section_id": "11ae5d57-f80f-4ae7-8c27-e6490cbed62e",
            "structured_type": "structured",
            "mapping_index": 2
        },
        "event": "mapping_hover",
        "id": "za5bWAKIAOarg2EV0hzo"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:18:36.000",
        "data": {
            "detail_level": "high",
            "section_id": "11ae5d57-f80f-4ae7-8c27-e6490cbed62e",
            "structured_type": "structured",
            "mapping_index": 0
        },
        "event": "mapping_hover",
        "id": "F8MW6ktLPZpSJNW4sSPt"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:18:36.000",
        "data": {
            "detail_level": "high",
            "section_id": "11ae5d57-f80f-4ae7-8c27-e6490cbed62e",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "z3KA4JQCTS5uFmwLOZrh"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:18:37.000",
        "data": {
            "detail_level": "high",
            "section_id": "11ae5d57-f80f-4ae7-8c27-e6490cbed62e",
            "structured_type": "structured",
            "mapping_index": 1
        },
        "event": "mapping_hover",
        "id": "EDSYEiQ2TNJTeQtEkMDF"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:18:37.000",
        "data": {
            "detail_level": "high",
            "section_id": "11ae5d57-f80f-4ae7-8c27-e6490cbed62e",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "al9LAUXw7HFBlRwKVFXa"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:18:40.000",
        "data": {
            "detail_level": "high",
            "section_id": "11ae5d57-f80f-4ae7-8c27-e6490cbed62e",
            "structured_type": "structured",
            "mapping_index": 2
        },
        "event": "mapping_hover",
        "id": "LqDEe16sKODU3k9oVqwF"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:18:40.000",
        "data": {
            "detail_level": "high",
            "section_id": "11ae5d57-f80f-4ae7-8c27-e6490cbed62e",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "XipHtlWJPGWk7iwTKweP"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:18:41.000",
        "data": {
            "detail_level": "high",
            "section_id": "11ae5d57-f80f-4ae7-8c27-e6490cbed62e",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "13G8aUOVqGWmxcf2EPWn"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:18:41.000",
        "data": {
            "detail_level": "high",
            "section_id": "11ae5d57-f80f-4ae7-8c27-e6490cbed62e",
            "structured_type": "structured",
            "mapping_index": 10
        },
        "event": "mapping_hover",
        "id": "2lmUWzbmxcDgi3nrebHj"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:18:41.000",
        "data": {
            "detail_level": "high",
            "section_id": "11ae5d57-f80f-4ae7-8c27-e6490cbed62e",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "47srzpZdD5UURR7SThVQ"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:18:41.000",
        "data": {
            "detail_level": "high",
            "section_id": "11ae5d57-f80f-4ae7-8c27-e6490cbed62e",
            "structured_type": "structured",
            "mapping_index": 4
        },
        "event": "mapping_hover",
        "id": "6xiodpR9XZ7Evz5DorEQ"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:18:41.000",
        "data": {
            "detail_level": "high",
            "section_id": "11ae5d57-f80f-4ae7-8c27-e6490cbed62e",
            "structured_type": "structured",
            "mapping_index": 9
        },
        "event": "mapping_hover",
        "id": "9k8FfkZbeV1yVMDiNf55"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:18:41.000",
        "data": {
            "detail_level": "high",
            "section_id": "11ae5d57-f80f-4ae7-8c27-e6490cbed62e",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "EwfriyUIf7iGuVN1Fr37"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:18:41.000",
        "data": {
            "detail_level": "high",
            "section_id": "11ae5d57-f80f-4ae7-8c27-e6490cbed62e",
            "structured_type": "structured",
            "mapping_index": 6
        },
        "event": "mapping_hover",
        "id": "QAvfGCa4DXbmjjTDdcX3"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:18:41.000",
        "data": {
            "detail_level": "high",
            "section_id": "11ae5d57-f80f-4ae7-8c27-e6490cbed62e",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "Wgi282SnU4nZ4v3lwYeO"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:18:41.000",
        "data": {
            "detail_level": "high",
            "section_id": "11ae5d57-f80f-4ae7-8c27-e6490cbed62e",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "YkQlGpwAisVa5sAF5Jlu"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:18:41.000",
        "data": {
            "detail_level": "high",
            "section_id": "11ae5d57-f80f-4ae7-8c27-e6490cbed62e",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "b8lBI1O6v7XTwfUH8BF2"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:18:41.000",
        "data": {
            "detail_level": "high",
            "section_id": "11ae5d57-f80f-4ae7-8c27-e6490cbed62e",
            "structured_type": "structured",
            "mapping_index": 8
        },
        "event": "mapping_hover",
        "id": "cFaXsEoCPqlaL05ZopQy"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:18:41.000",
        "data": {
            "detail_level": "high",
            "section_id": "11ae5d57-f80f-4ae7-8c27-e6490cbed62e",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "pFCSZ2AH0chTCMoTLiKu"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:18:41.000",
        "data": {
            "detail_level": "high",
            "section_id": "11ae5d57-f80f-4ae7-8c27-e6490cbed62e",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "qquCGZpVyIOlTq5G1E1S"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:18:41.000",
        "data": {
            "detail_level": "high",
            "section_id": "11ae5d57-f80f-4ae7-8c27-e6490cbed62e",
            "structured_type": "structured",
            "mapping_index": 5
        },
        "event": "mapping_hover",
        "id": "shJgZKKJGtUnXkCo8vxg"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:18:41.000",
        "data": {
            "detail_level": "high",
            "section_id": "11ae5d57-f80f-4ae7-8c27-e6490cbed62e",
            "structured_type": "structured",
            "mapping_index": 7
        },
        "event": "mapping_hover",
        "id": "tlMAQdfQ78M42WYedzxL"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:18:41.000",
        "data": {
            "detail_level": "high",
            "section_id": "11ae5d57-f80f-4ae7-8c27-e6490cbed62e",
            "structured_type": "structured",
            "mapping_index": 7
        },
        "event": "mapping_hover",
        "id": "xDHKcylCRYP6gq5qzS54"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:18:41.000",
        "data": {
            "detail_level": "high",
            "section_id": "11ae5d57-f80f-4ae7-8c27-e6490cbed62e",
            "structured_type": "structured",
            "mapping_index": 9
        },
        "event": "mapping_hover",
        "id": "ygxPeKvG4XduAeQAVRJp"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:18:41.000",
        "data": {
            "detail_level": "high",
            "section_id": "11ae5d57-f80f-4ae7-8c27-e6490cbed62e",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "ykrS30OpS4KjlvQtCeCt"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:18:42.000",
        "data": {
            "detail_level": "high",
            "section_id": "11ae5d57-f80f-4ae7-8c27-e6490cbed62e",
            "structured_type": "structured",
            "mapping_index": 2
        },
        "event": "mapping_hover",
        "id": "Bd3yA5ijaIrGBKzgn7K5"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:18:42.000",
        "data": {
            "detail_level": "high",
            "section_id": "11ae5d57-f80f-4ae7-8c27-e6490cbed62e",
            "structured_type": "structured",
            "mapping_index": 3
        },
        "event": "mapping_hover",
        "id": "pS6gmoYbFSJaKKcNLRQT"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:18:42.000",
        "data": {
            "detail_level": "high",
            "section_id": "11ae5d57-f80f-4ae7-8c27-e6490cbed62e",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "rWPcXEWFq4VM2HrkEQEC"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:18:42.000",
        "data": {
            "detail_level": "high",
            "section_id": "11ae5d57-f80f-4ae7-8c27-e6490cbed62e",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "uISOqVccJtPI7GN9dhkG"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:18:43.000",
        "data": {
            "detail_level": "high",
            "section_id": "11ae5d57-f80f-4ae7-8c27-e6490cbed62e",
            "structured_type": "structured",
            "mapping_index": 4
        },
        "event": "mapping_hover",
        "id": "eMKJvbBzt0YbAtzzm5cc"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:18:43.000",
        "data": {
            "detail_level": "high",
            "section_id": "11ae5d57-f80f-4ae7-8c27-e6490cbed62e",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "jkDSbhJjyog06tJQl9kV"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:18:43.000",
        "data": {
            "detail_level": "high",
            "section_id": "11ae5d57-f80f-4ae7-8c27-e6490cbed62e",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "pNmNR9NM5rX7RW6RVlU8"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:18:43.000",
        "data": {
            "detail_level": "high",
            "section_id": "11ae5d57-f80f-4ae7-8c27-e6490cbed62e",
            "structured_type": "structured",
            "mapping_index": 3
        },
        "event": "mapping_hover",
        "id": "ua9Ro6SOK4S9rcZmkz0b"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:18:44.000",
        "data": {
            "detail_level": "high",
            "section_id": "11ae5d57-f80f-4ae7-8c27-e6490cbed62e",
            "structured_type": "structured",
            "mapping_index": 3
        },
        "event": "mapping_hover",
        "id": "t375A7JjJWGk5hUIC2rv"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:18:44.000",
        "data": {
            "detail_level": "high",
            "section_id": "11ae5d57-f80f-4ae7-8c27-e6490cbed62e",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "uMYOeL0JtM2gq7WZvSWh"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:18:46.000",
        "data": {
            "detail_level": "high",
            "section_id": "11ae5d57-f80f-4ae7-8c27-e6490cbed62e",
            "structured_type": "structured",
            "mapping_index": 4
        },
        "event": "mapping_hover",
        "id": "NRBQ7uh4uGyp0G4sdPGQ"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:18:46.000",
        "data": {
            "detail_level": "high",
            "section_id": "11ae5d57-f80f-4ae7-8c27-e6490cbed62e",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "kIyFba7T7ggbIku1Eymm"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:18:47.000",
        "data": {
            "detail_level": "high",
            "section_id": "11ae5d57-f80f-4ae7-8c27-e6490cbed62e",
            "structured_type": "structured",
            "mapping_index": 3
        },
        "event": "mapping_hover",
        "id": "8rgkuBAuQtOxmehLParu"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:18:47.000",
        "data": {
            "detail_level": "high",
            "section_id": "11ae5d57-f80f-4ae7-8c27-e6490cbed62e",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "CE7GWTEfQ48hcu7tNQIa"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:18:50.000",
        "data": {
            "detail_level": "high",
            "section_id": "11ae5d57-f80f-4ae7-8c27-e6490cbed62e",
            "structured_type": "structured",
            "mapping_index": 2
        },
        "event": "mapping_hover",
        "id": "JN309TdVzd44f3kj1RIb"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:18:50.000",
        "data": {
            "detail_level": "high",
            "section_id": "11ae5d57-f80f-4ae7-8c27-e6490cbed62e",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "Ml48dzwgqhfogN7ubOkL"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:18:51.000",
        "data": {
            "detail_level": "high",
            "section_id": "11ae5d57-f80f-4ae7-8c27-e6490cbed62e",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "9S7XTfpKQRPQCHdJUXFc"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:18:51.000",
        "data": {
            "detail_level": "high",
            "section_id": "11ae5d57-f80f-4ae7-8c27-e6490cbed62e",
            "structured_type": "structured",
            "mapping_index": 3
        },
        "event": "mapping_hover",
        "id": "tDdy1JgPuTREJcoUWvAU"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:18:52.000",
        "data": {
            "detail_level": "high",
            "section_id": "11ae5d57-f80f-4ae7-8c27-e6490cbed62e",
            "structured_type": "structured",
            "mapping_index": 4
        },
        "event": "mapping_hover",
        "id": "Czx0cK3HC7n94qA1IZMJ"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:18:52.000",
        "data": {
            "detail_level": "high",
            "section_id": "11ae5d57-f80f-4ae7-8c27-e6490cbed62e",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "OhFpoMb7l1WeoQHGuMob"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:18:53.000",
        "data": {
            "detail_level": "high",
            "section_id": "11ae5d57-f80f-4ae7-8c27-e6490cbed62e",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "ENo5zKIVJKn6K7J08TXO"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:18:53.000",
        "data": {
            "detail_level": "high",
            "section_id": "11ae5d57-f80f-4ae7-8c27-e6490cbed62e",
            "structured_type": "structured",
            "mapping_index": 5
        },
        "event": "mapping_hover",
        "id": "fM0CLRIx8yBl3ZPThZQb"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:18:54.000",
        "data": {
            "detail_level": "high",
            "section_id": "11ae5d57-f80f-4ae7-8c27-e6490cbed62e",
            "structured_type": "structured",
            "mapping_index": 6
        },
        "event": "mapping_hover",
        "id": "2SuNAfBxrC6DI85TIcci"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:18:54.000",
        "data": {
            "detail_level": "high",
            "section_id": "11ae5d57-f80f-4ae7-8c27-e6490cbed62e",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "StxrcM2OVMR80ZgrItHa"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:18:55.000",
        "data": {
            "detail_level": "high",
            "section_id": "11ae5d57-f80f-4ae7-8c27-e6490cbed62e",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "1ZMpqZ5XWjlVx0ntqjKg"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:18:55.000",
        "data": {
            "detail_level": "high",
            "section_id": "11ae5d57-f80f-4ae7-8c27-e6490cbed62e",
            "structured_type": "structured",
            "mapping_index": 10
        },
        "event": "mapping_hover",
        "id": "5XcopB0nqjdpoQh7TIb4"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:18:55.000",
        "data": {
            "detail_level": "high",
            "section_id": "11ae5d57-f80f-4ae7-8c27-e6490cbed62e",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "De4p5fL8IIm0wBgHVNb9"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:18:55.000",
        "data": {
            "detail_level": "high",
            "section_id": "11ae5d57-f80f-4ae7-8c27-e6490cbed62e",
            "structured_type": "structured",
            "mapping_index": 8
        },
        "event": "mapping_hover",
        "id": "KxaIneoUiRCj6IYHcuBu"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:18:55.000",
        "data": {
            "detail_level": "high",
            "section_id": "11ae5d57-f80f-4ae7-8c27-e6490cbed62e",
            "structured_type": "structured",
            "mapping_index": 9
        },
        "event": "mapping_hover",
        "id": "Q7Ec4HcQ8YoAh1tPMKWy"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:18:55.000",
        "data": {
            "detail_level": "high",
            "section_id": "11ae5d57-f80f-4ae7-8c27-e6490cbed62e",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "gyk9kSp3TdwpUgURVNCo"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:18:55.000",
        "data": {
            "detail_level": "high",
            "section_id": "11ae5d57-f80f-4ae7-8c27-e6490cbed62e",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "iSl5zrgpnpFel3qYIsb8"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:18:55.000",
        "data": {
            "detail_level": "high",
            "section_id": "11ae5d57-f80f-4ae7-8c27-e6490cbed62e",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "up5tP6zTcW7b1Wrbs6Cv"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:18:55.000",
        "data": {
            "detail_level": "high",
            "section_id": "11ae5d57-f80f-4ae7-8c27-e6490cbed62e",
            "structured_type": "structured",
            "mapping_index": 7
        },
        "event": "mapping_hover",
        "id": "xdOvOkKLb4E5HPGcQDZx"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:18:56.000",
        "data": {
            "detail_level": "high",
            "section_id": "11ae5d57-f80f-4ae7-8c27-e6490cbed62e",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "35E28Xkn2Z18E7J75ieu"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:18:56.000",
        "data": {
            "detail_level": "high",
            "section_id": "11ae5d57-f80f-4ae7-8c27-e6490cbed62e",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "3Cuk9jprqGibUUmCbIUd"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:18:56.000",
        "data": {
            "detail_level": "high",
            "section_id": "11ae5d57-f80f-4ae7-8c27-e6490cbed62e",
            "structured_type": "structured",
            "mapping_index": 9
        },
        "event": "mapping_hover",
        "id": "JXKRCZ6R5eIMtSQneLKh"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:18:56.000",
        "data": {
            "detail_level": "high",
            "section_id": "11ae5d57-f80f-4ae7-8c27-e6490cbed62e",
            "structured_type": "structured",
            "mapping_index": 7
        },
        "event": "mapping_hover",
        "id": "MXaWjSJ5hczsJDXNjhhJ"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:18:56.000",
        "data": {
            "detail_level": "high",
            "section_id": "11ae5d57-f80f-4ae7-8c27-e6490cbed62e",
            "structured_type": "structured",
            "mapping_index": 9
        },
        "event": "mapping_hover",
        "id": "OFtVhI6sPEtcZR0nWJPQ"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:18:56.000",
        "data": {
            "detail_level": "high",
            "section_id": "11ae5d57-f80f-4ae7-8c27-e6490cbed62e",
            "structured_type": "structured",
            "mapping_index": 8
        },
        "event": "mapping_hover",
        "id": "aODzd3A0XhcJ5XoyfZr0"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:18:56.000",
        "data": {
            "detail_level": "high",
            "section_id": "11ae5d57-f80f-4ae7-8c27-e6490cbed62e",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "adZ5WsgE8DJEk9IXm4Hi"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:18:56.000",
        "data": {
            "detail_level": "high",
            "section_id": "11ae5d57-f80f-4ae7-8c27-e6490cbed62e",
            "structured_type": "structured",
            "mapping_index": 10
        },
        "event": "mapping_hover",
        "id": "ggm5z8wZRgBKUerr3F31"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:18:56.000",
        "data": {
            "detail_level": "high",
            "section_id": "11ae5d57-f80f-4ae7-8c27-e6490cbed62e",
            "structured_type": "structured",
            "mapping_index": 8
        },
        "event": "mapping_hover",
        "id": "knTFMdLWsbvCio7tDPS0"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:18:56.000",
        "data": {
            "detail_level": "high",
            "section_id": "11ae5d57-f80f-4ae7-8c27-e6490cbed62e",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "tVCUmv9s2GjJ9GMh8LMr"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:18:56.000",
        "data": {
            "detail_level": "high",
            "section_id": "11ae5d57-f80f-4ae7-8c27-e6490cbed62e",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "xwPyvyJo91dmDu6CCGRo"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:18:57.000",
        "data": {
            "detail_level": "high",
            "section_id": "11ae5d57-f80f-4ae7-8c27-e6490cbed62e",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "2nWk7XXSkixmYuyO1Mg4"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:18:57.000",
        "data": {
            "detail_level": "high",
            "section_id": "11ae5d57-f80f-4ae7-8c27-e6490cbed62e",
            "structured_type": "structured",
            "mapping_index": 9
        },
        "event": "mapping_hover",
        "id": "RPIfFWHL9WqieNsnqL0h"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:18:57.000",
        "data": {
            "detail_level": "high",
            "section_id": "11ae5d57-f80f-4ae7-8c27-e6490cbed62e",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "RuxKc5hviLRED5hkicdU"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:18:57.000",
        "data": {
            "detail_level": "high",
            "section_id": "11ae5d57-f80f-4ae7-8c27-e6490cbed62e",
            "structured_type": "structured",
            "mapping_index": 10
        },
        "event": "mapping_hover",
        "id": "cvzSNHdTsFHQE7AjePe8"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:18:57.000",
        "data": {
            "detail_level": "high",
            "section_id": "11ae5d57-f80f-4ae7-8c27-e6490cbed62e",
            "structured_type": "structured",
            "mapping_index": 10
        },
        "event": "mapping_hover",
        "id": "gnskC243dZTdN6K1v4W3"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:18:57.000",
        "data": {
            "detail_level": "high",
            "section_id": "11ae5d57-f80f-4ae7-8c27-e6490cbed62e",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "kD5ud5ChwtQi7AxgAkvK"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:18:58.000",
        "data": {
            "detail_level": "high",
            "section_id": "11ae5d57-f80f-4ae7-8c27-e6490cbed62e",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "0N6oWezStGwp5keXtFw0"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:18:58.000",
        "data": {
            "detail_level": "high",
            "section_id": "11ae5d57-f80f-4ae7-8c27-e6490cbed62e",
            "structured_type": "structured",
            "mapping_index": 9
        },
        "event": "mapping_hover",
        "id": "1MOZYzuovKSSI7Vtd0dj"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:18:58.000",
        "data": {
            "detail_level": "high",
            "section_id": "11ae5d57-f80f-4ae7-8c27-e6490cbed62e",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "EggL9bT7DzhllnE7OCfz"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:18:58.000",
        "data": {
            "detail_level": "high",
            "section_id": "11ae5d57-f80f-4ae7-8c27-e6490cbed62e",
            "structured_type": "structured",
            "mapping_index": 10
        },
        "event": "mapping_hover",
        "id": "SjhKYfXTjT7SomPcxTp1"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:18:58.000",
        "data": {
            "detail_level": "high",
            "section_id": "11ae5d57-f80f-4ae7-8c27-e6490cbed62e",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "faPnvkVTjZuVvylRJ8MO"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:18:58.000",
        "data": {
            "detail_level": "high",
            "section_id": "11ae5d57-f80f-4ae7-8c27-e6490cbed62e",
            "structured_type": "structured",
            "mapping_index": 8
        },
        "event": "mapping_hover",
        "id": "jjdf6NU7SbIc0ZkuiGcc"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:18:58.000",
        "data": {
            "detail_level": "high",
            "section_id": "11ae5d57-f80f-4ae7-8c27-e6490cbed62e",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "pOGiZcKTVxpQ5L0WFNyP"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:19:01.000",
        "data": {
            "detail_level": "high",
            "section_id": "11ae5d57-f80f-4ae7-8c27-e6490cbed62e",
            "structured_type": "structured",
            "mapping_index": 8
        },
        "event": "mapping_hover",
        "id": "33hoYg1dsS2Vvk6QvMe0"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:19:01.000",
        "data": {
            "detail_level": "high",
            "section_id": "11ae5d57-f80f-4ae7-8c27-e6490cbed62e",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "QKljYuOS5ScPdUSHmKxR"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:19:01.000",
        "data": {
            "detail_level": "high",
            "section_id": "11ae5d57-f80f-4ae7-8c27-e6490cbed62e",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "fVBtop92fYLwFRNjn9OM"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:19:01.000",
        "data": {
            "detail_level": "high",
            "section_id": "11ae5d57-f80f-4ae7-8c27-e6490cbed62e",
            "structured_type": "structured",
            "mapping_index": 9
        },
        "event": "mapping_hover",
        "id": "j82sydsb6ddaqC7a6VFD"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:19:01.000",
        "data": {
            "detail_level": "high",
            "section_id": "11ae5d57-f80f-4ae7-8c27-e6490cbed62e",
            "structured_type": "structured",
            "mapping_index": 10
        },
        "event": "mapping_hover",
        "id": "uKs1Yhi3NToiKewi4Ouv"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:19:02.000",
        "data": {
            "detail_level": "high",
            "section_id": "11ae5d57-f80f-4ae7-8c27-e6490cbed62e",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "e988SFqmtUVWzDUfJTnr"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:19:03.000",
        "data": {
            "detail_level": "high",
            "section_id": "11ae5d57-f80f-4ae7-8c27-e6490cbed62e",
            "structured_type": "structured",
            "mapping_index": 9
        },
        "event": "mapping_hover",
        "id": "CTBxWTut7fZ7hRBlnkE2"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:19:04.000",
        "data": {
            "detail_level": "high",
            "section_id": "11ae5d57-f80f-4ae7-8c27-e6490cbed62e",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "3vOHs80ePYqSN7Ltn2Rk"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:19:04.000",
        "data": {
            "detail_level": "high",
            "section_id": "11ae5d57-f80f-4ae7-8c27-e6490cbed62e",
            "structured_type": "structured",
            "mapping_index": 9
        },
        "event": "mapping_hover",
        "id": "9AiXUlnl2AMX42U84B7A"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:19:04.000",
        "data": {
            "detail_level": "high",
            "section_id": "11ae5d57-f80f-4ae7-8c27-e6490cbed62e",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "grikCyXDXdfBfnHaMxeg"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:19:04.000",
        "data": {
            "detail_level": "high",
            "section_id": "11ae5d57-f80f-4ae7-8c27-e6490cbed62e",
            "structured_type": "structured",
            "mapping_index": 10
        },
        "event": "mapping_hover",
        "id": "kGePRUoaWx5IWz7jxvkQ"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:19:05.000",
        "data": {
            "detail_level": "high",
            "section_id": "11ae5d57-f80f-4ae7-8c27-e6490cbed62e",
            "structured_type": "structured",
            "mapping_index": 9
        },
        "event": "mapping_hover",
        "id": "RPJBLfOmhHrcZPTaC0Wq"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:19:05.000",
        "data": {
            "detail_level": "high",
            "section_id": "11ae5d57-f80f-4ae7-8c27-e6490cbed62e",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "i5PXmdylwvAmbDXxZtCJ"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:19:06.000",
        "data": {
            "detail_level": "high",
            "section_id": "11ae5d57-f80f-4ae7-8c27-e6490cbed62e",
            "structured_type": "structured",
            "mapping_index": 10
        },
        "event": "mapping_hover",
        "id": "NGPL9YdmXqOnPLZ3cu5R"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:19:06.000",
        "data": {
            "detail_level": "high",
            "section_id": "11ae5d57-f80f-4ae7-8c27-e6490cbed62e",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "s8ngDMYcjI6CP1tBBYuL"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:19:06.000",
        "data": {
            "detail_level": "high",
            "section_id": "11ae5d57-f80f-4ae7-8c27-e6490cbed62e",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "uIRhzfJtd6EXHlSyBWuO"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:19:11.000",
        "data": {
            "detail_level": "high",
            "section_id": "11ae5d57-f80f-4ae7-8c27-e6490cbed62e",
            "structured_type": "structured",
            "mapping_index": 3
        },
        "event": "mapping_hover",
        "id": "lrd91CZuHb2Cej6TdAFO"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:19:12.000",
        "data": {
            "detail_level": "high",
            "section_id": "11ae5d57-f80f-4ae7-8c27-e6490cbed62e",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "1KAmQF44zgv3gNO1yWKQ"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:19:12.000",
        "data": {
            "detail_level": "high",
            "section_id": "11ae5d57-f80f-4ae7-8c27-e6490cbed62e",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "1oT6FhV9fA0o3aULt6r4"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:19:12.000",
        "data": {
            "detail_level": "high",
            "section_id": "11ae5d57-f80f-4ae7-8c27-e6490cbed62e",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "21TjC8gFN0s4Cnxj0CxB"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:19:12.000",
        "data": {
            "detail_level": "high",
            "section_id": "11ae5d57-f80f-4ae7-8c27-e6490cbed62e",
            "structured_type": "structured",
            "mapping_index": 3
        },
        "event": "mapping_hover",
        "id": "5BIC8cQ6VA6PAid3nILa"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:19:12.000",
        "data": {
            "detail_level": "high",
            "section_id": "11ae5d57-f80f-4ae7-8c27-e6490cbed62e",
            "structured_type": "structured",
            "mapping_index": 4
        },
        "event": "mapping_hover",
        "id": "Ig8budqB9G7TWZbQz7iQ"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:19:12.000",
        "data": {
            "detail_level": "high",
            "section_id": "11ae5d57-f80f-4ae7-8c27-e6490cbed62e",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "ZMNg89Lm2KLbiQRvar2T"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:19:12.000",
        "data": {
            "detail_level": "high",
            "section_id": "11ae5d57-f80f-4ae7-8c27-e6490cbed62e",
            "structured_type": "structured",
            "mapping_index": 10
        },
        "event": "mapping_hover",
        "id": "aTxIpE7svQghySrmMe67"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:19:12.000",
        "data": {
            "detail_level": "high",
            "section_id": "11ae5d57-f80f-4ae7-8c27-e6490cbed62e",
            "structured_type": "structured",
            "mapping_index": 2
        },
        "event": "mapping_hover",
        "id": "tDnS1hTP5vmpbiDwMUWY"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:19:12.000",
        "data": {
            "detail_level": "high",
            "section_id": "11ae5d57-f80f-4ae7-8c27-e6490cbed62e",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "vV5JD7j6uD0hEVfmEZSi"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:19:13.000",
        "data": {
            "detail_level": "high",
            "section_id": "11ae5d57-f80f-4ae7-8c27-e6490cbed62e",
            "structured_type": "structured",
            "mapping_index": 9
        },
        "event": "mapping_hover",
        "id": "BCyIyWv3xmVjYObh2Nt5"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:19:13.000",
        "data": {
            "detail_level": "high",
            "section_id": "11ae5d57-f80f-4ae7-8c27-e6490cbed62e",
            "structured_type": "structured",
            "mapping_index": 4
        },
        "event": "mapping_hover",
        "id": "iZ5Cn48d1iJ6IQQCEOBI"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:19:13.000",
        "data": {
            "detail_level": "high",
            "section_id": "11ae5d57-f80f-4ae7-8c27-e6490cbed62e",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "oIUZn4Z7OVMF3kto2HC6"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:19:14.000",
        "data": {
            "detail_level": "high",
            "section_id": "11ae5d57-f80f-4ae7-8c27-e6490cbed62e",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "2EeYK5GmCvUq7COFezGh"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:19:14.000",
        "data": {
            "detail_level": "high",
            "section_id": "11ae5d57-f80f-4ae7-8c27-e6490cbed62e",
            "structured_type": "structured",
            "mapping_index": 5
        },
        "event": "mapping_hover",
        "id": "3L8ue8zfiPacW7yWR6Gw"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:19:14.000",
        "data": {
            "detail_level": "high",
            "section_id": "11ae5d57-f80f-4ae7-8c27-e6490cbed62e",
            "structured_type": "structured",
            "mapping_index": 4
        },
        "event": "mapping_hover",
        "id": "AOX9PcvHpxxgwMIMYReF"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:19:14.000",
        "data": {
            "detail_level": "high",
            "section_id": "11ae5d57-f80f-4ae7-8c27-e6490cbed62e",
            "structured_type": "structured",
            "mapping_index": 3
        },
        "event": "mapping_hover",
        "id": "BIFfaubV1D2ThggeuM0B"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:19:14.000",
        "data": {
            "detail_level": "high",
            "section_id": "11ae5d57-f80f-4ae7-8c27-e6490cbed62e",
            "structured_type": "structured",
            "mapping_index": 2
        },
        "event": "mapping_hover",
        "id": "EZL2akyFOt97UOBnY4Ed"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:19:14.000",
        "data": {
            "detail_level": "high",
            "section_id": "11ae5d57-f80f-4ae7-8c27-e6490cbed62e",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "HcBfRYqIvaWRH0YSOMo3"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:19:14.000",
        "data": {
            "detail_level": "high",
            "section_id": "11ae5d57-f80f-4ae7-8c27-e6490cbed62e",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "LElUH2fM0Ie8BwZKTei2"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:19:14.000",
        "data": {
            "detail_level": "high",
            "section_id": "11ae5d57-f80f-4ae7-8c27-e6490cbed62e",
            "structured_type": "structured",
            "mapping_index": 1
        },
        "event": "mapping_hover",
        "id": "UEG22p6dBFf9yHNPrepq"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:19:14.000",
        "data": {
            "detail_level": "high",
            "section_id": "11ae5d57-f80f-4ae7-8c27-e6490cbed62e",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "Yd4wBeDXja27dLK6gCsu"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:19:14.000",
        "data": {
            "detail_level": "high",
            "section_id": "11ae5d57-f80f-4ae7-8c27-e6490cbed62e",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "xSzSYdLaLbFAKrvaboBf"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:19:15.000",
        "data": {
            "detail_level": "high",
            "section_id": "11ae5d57-f80f-4ae7-8c27-e6490cbed62e",
            "structured_type": "structured",
            "mapping_index": 9
        },
        "event": "mapping_hover",
        "id": "4nzitOmR6eWmpehdsGh9"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:19:15.000",
        "data": {
            "detail_level": "high",
            "section_id": "11ae5d57-f80f-4ae7-8c27-e6490cbed62e",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "6lomermnFjQB2jIl4822"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:19:15.000",
        "data": {
            "detail_level": "high",
            "section_id": "11ae5d57-f80f-4ae7-8c27-e6490cbed62e",
            "structured_type": "structured",
            "mapping_index": 10
        },
        "event": "mapping_hover",
        "id": "EMu8MlOFAu7o0p6wsc4d"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:19:15.000",
        "data": {
            "detail_level": "high",
            "section_id": "11ae5d57-f80f-4ae7-8c27-e6490cbed62e",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "GSWh0ClHJYQJgak1B48o"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:19:15.000",
        "data": {
            "detail_level": "high",
            "section_id": "11ae5d57-f80f-4ae7-8c27-e6490cbed62e",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "JQFcBbNUm1aHK43Ynrfr"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:19:15.000",
        "data": {
            "detail_level": "high",
            "section_id": "11ae5d57-f80f-4ae7-8c27-e6490cbed62e",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "JUjWUVLDfyEysJlJxNrH"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:19:15.000",
        "data": {
            "detail_level": "high",
            "section_id": "11ae5d57-f80f-4ae7-8c27-e6490cbed62e",
            "structured_type": "structured",
            "mapping_index": 5
        },
        "event": "mapping_hover",
        "id": "M2JVYU1z53hWMxb7bvPD"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:19:15.000",
        "data": {
            "detail_level": "high",
            "section_id": "11ae5d57-f80f-4ae7-8c27-e6490cbed62e",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "To1yl1pcFr3l3NfFXAF1"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:19:15.000",
        "data": {
            "detail_level": "high",
            "section_id": "11ae5d57-f80f-4ae7-8c27-e6490cbed62e",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "WR5Di7COUZQC9UB48ZCN"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:19:15.000",
        "data": {
            "detail_level": "high",
            "section_id": "11ae5d57-f80f-4ae7-8c27-e6490cbed62e",
            "structured_type": "structured",
            "mapping_index": 7
        },
        "event": "mapping_hover",
        "id": "XITTgP2cK557GAKFptrS"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:19:15.000",
        "data": {
            "detail_level": "high",
            "section_id": "11ae5d57-f80f-4ae7-8c27-e6490cbed62e",
            "structured_type": "structured",
            "mapping_index": 6
        },
        "event": "mapping_hover",
        "id": "Y9jQGuEoPMAfwMqZZGJC"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:19:15.000",
        "data": {
            "detail_level": "high",
            "section_id": "11ae5d57-f80f-4ae7-8c27-e6490cbed62e",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "YI97nTLaHjs54B6zCtA8"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:19:15.000",
        "data": {
            "detail_level": "high",
            "section_id": "11ae5d57-f80f-4ae7-8c27-e6490cbed62e",
            "structured_type": "structured",
            "mapping_index": 8
        },
        "event": "mapping_hover",
        "id": "aaajuIarWJPJuat8YboQ"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:19:15.000",
        "data": {
            "detail_level": "high",
            "section_id": "11ae5d57-f80f-4ae7-8c27-e6490cbed62e",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "hGM8fHLoCnfZkjpjQApw"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:19:15.000",
        "data": {
            "detail_level": "high",
            "section_id": "11ae5d57-f80f-4ae7-8c27-e6490cbed62e",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "jjJWFgox6JnSiBLoz66Q"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:19:15.000",
        "data": {
            "detail_level": "high",
            "section_id": "11ae5d57-f80f-4ae7-8c27-e6490cbed62e",
            "structured_type": "structured",
            "mapping_index": 2
        },
        "event": "mapping_hover",
        "id": "lFrmFRHhCB8KdCwzb2MJ"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:19:15.000",
        "data": {
            "detail_level": "high",
            "section_id": "11ae5d57-f80f-4ae7-8c27-e6490cbed62e",
            "structured_type": "structured",
            "mapping_index": 4
        },
        "event": "mapping_hover",
        "id": "lG76Agf2mikdmNHIHLTW"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:19:15.000",
        "data": {
            "detail_level": "high",
            "section_id": "11ae5d57-f80f-4ae7-8c27-e6490cbed62e",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "wExawcL5GHwWNALrIep9"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:19:15.000",
        "data": {
            "detail_level": "high",
            "section_id": "11ae5d57-f80f-4ae7-8c27-e6490cbed62e",
            "structured_type": "structured",
            "mapping_index": 3
        },
        "event": "mapping_hover",
        "id": "xtiTLyR9QWvZNygkCHeA"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:19:27.000",
        "data": {
            "detail_level": "high",
            "section_id": "11ae5d57-f80f-4ae7-8c27-e6490cbed62e",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "8EL8B9AqLgJth6OrcxkL"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:19:27.000",
        "data": {
            "detail_level": "high",
            "section_id": "11ae5d57-f80f-4ae7-8c27-e6490cbed62e",
            "structured_type": "structured",
            "mapping_index": 5
        },
        "event": "mapping_hover",
        "id": "BzpX5lEuXoFTZhDpA0Y4"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:19:27.000",
        "data": {
            "detail_level": "high",
            "section_id": "11ae5d57-f80f-4ae7-8c27-e6490cbed62e",
            "structured_type": "structured",
            "mapping_index": 10
        },
        "event": "mapping_hover",
        "id": "GhfSkBrDA2UDxNeMyiD6"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:19:27.000",
        "data": {
            "detail_level": "high",
            "section_id": "11ae5d57-f80f-4ae7-8c27-e6490cbed62e",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "K9D1OwKHcYLKIAaeglV9"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:19:27.000",
        "data": {
            "detail_level": "high",
            "section_id": "11ae5d57-f80f-4ae7-8c27-e6490cbed62e",
            "structured_type": "structured",
            "mapping_index": 8
        },
        "event": "mapping_hover",
        "id": "NOZUF1d0Cl2mnjhp1wPZ"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:19:27.000",
        "data": {
            "detail_level": "high",
            "section_id": "11ae5d57-f80f-4ae7-8c27-e6490cbed62e",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "a8rr3eapg1U7oG8oeXOw"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:19:27.000",
        "data": {
            "detail_level": "high",
            "section_id": "11ae5d57-f80f-4ae7-8c27-e6490cbed62e",
            "structured_type": "structured",
            "mapping_index": 5
        },
        "event": "mapping_hover",
        "id": "iwYJjNgpnNxHvUVsKgQx"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:19:27.000",
        "data": {
            "detail_level": "high",
            "section_id": "11ae5d57-f80f-4ae7-8c27-e6490cbed62e",
            "structured_type": "structured",
            "mapping_index": 4
        },
        "event": "mapping_hover",
        "id": "mTmuMeBkXmdw0JGjEzxt"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:19:27.000",
        "data": {
            "detail_level": "high",
            "section_id": "11ae5d57-f80f-4ae7-8c27-e6490cbed62e",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "tLA19ygDrC9KMP7FKMmY"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:19:27.000",
        "data": {
            "detail_level": "high",
            "section_id": "11ae5d57-f80f-4ae7-8c27-e6490cbed62e",
            "structured_type": "structured",
            "mapping_index": 7
        },
        "event": "mapping_hover",
        "id": "uibMgelg0CVgSuaJCAau"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:19:27.000",
        "data": {
            "detail_level": "high",
            "section_id": "11ae5d57-f80f-4ae7-8c27-e6490cbed62e",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "yVwta3peWP8cpvrL5ReY"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:19:29.000",
        "data": {
            "detail_level": "high",
            "section_id": "11ae5d57-f80f-4ae7-8c27-e6490cbed62e",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "p4mCVpa4DY3SJItzycvQ"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:19:30.000",
        "data": {
            "detail_level": "high",
            "section_id": "11ae5d57-f80f-4ae7-8c27-e6490cbed62e",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "1p76cy0KfhFGSI09gNY3"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:19:30.000",
        "data": {
            "detail_level": "high",
            "section_id": "11ae5d57-f80f-4ae7-8c27-e6490cbed62e",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "3xmu4gDrE6Fqp180g2VN"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:19:30.000",
        "data": {
            "detail_level": "high",
            "section_id": "11ae5d57-f80f-4ae7-8c27-e6490cbed62e",
            "structured_type": "structured",
            "mapping_index": 5
        },
        "event": "mapping_hover",
        "id": "5k5kDzpC7FnxLrwRiPtn"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:19:30.000",
        "data": {
            "detail_level": "high",
            "section_id": "11ae5d57-f80f-4ae7-8c27-e6490cbed62e",
            "structured_type": "structured",
            "mapping_index": 7
        },
        "event": "mapping_hover",
        "id": "6281S7TEwwHEmqFdYZaF"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:19:30.000",
        "data": {
            "detail_level": "high",
            "section_id": "11ae5d57-f80f-4ae7-8c27-e6490cbed62e",
            "structured_type": "structured",
            "mapping_index": 8
        },
        "event": "mapping_hover",
        "id": "BsoOu5UKBUXfl7vbxHvM"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:19:30.000",
        "data": {
            "detail_level": "high",
            "section_id": "11ae5d57-f80f-4ae7-8c27-e6490cbed62e",
            "structured_type": "structured",
            "mapping_index": 6
        },
        "event": "mapping_hover",
        "id": "GqSfTugXEl3Tr2zghVRm"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:19:30.000",
        "data": {
            "detail_level": "high",
            "section_id": "11ae5d57-f80f-4ae7-8c27-e6490cbed62e",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "eCeQZrFhjoQm5YGyQH0x"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:19:32.000",
        "data": {
            "detail_level": "high",
            "section_id": "11ae5d57-f80f-4ae7-8c27-e6490cbed62e",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "0sk5gkr7LWGxilFw5N9P"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:19:32.000",
        "data": {
            "detail_level": "high",
            "section_id": "11ae5d57-f80f-4ae7-8c27-e6490cbed62e",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "1PFVgO3HkOh2qtJuNEFh"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:19:32.000",
        "data": {
            "detail_level": "high",
            "section_id": "11ae5d57-f80f-4ae7-8c27-e6490cbed62e",
            "structured_type": "structured",
            "mapping_index": 7
        },
        "event": "mapping_hover",
        "id": "1SnUnHYodYlTpiThk8Eg"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:19:32.000",
        "data": {
            "detail_level": "high",
            "section_id": "11ae5d57-f80f-4ae7-8c27-e6490cbed62e",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "IKYVZrA5sDCH7R4fBb6b"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:19:32.000",
        "data": {
            "detail_level": "high",
            "section_id": "11ae5d57-f80f-4ae7-8c27-e6490cbed62e",
            "structured_type": "structured",
            "mapping_index": 6
        },
        "event": "mapping_hover",
        "id": "e4xvoqBlio2AqO2qSBiw"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:19:58.000",
        "data": {},
        "event": "click_summarize_code",
        "id": "eLhoOGZUDKYDfkRtl3rD"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:19:59.000",
        "data": {
            "detail_level": "high",
            "section_id": "11ae5d57-f80f-4ae7-8c27-e6490cbed62e",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "1npoaWkbEdw7vEZt3Yok"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:19:59.000",
        "data": {
            "detail_level": "high",
            "section_id": "11ae5d57-f80f-4ae7-8c27-e6490cbed62e",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "2xfzDLj77GXM0obI2rJx"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:19:59.000",
        "data": {
            "detail_level": "high",
            "section_id": "11ae5d57-f80f-4ae7-8c27-e6490cbed62e",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "5t0ND3bqNNu9vHwJVi8S"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:19:59.000",
        "data": {
            "detail_level": "high",
            "section_id": "11ae5d57-f80f-4ae7-8c27-e6490cbed62e",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "8xSLLCXylhwhfZDhQ1BG"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:19:59.000",
        "data": {
            "detail_level": "high",
            "section_id": "11ae5d57-f80f-4ae7-8c27-e6490cbed62e",
            "structured_type": "structured",
            "mapping_index": 8
        },
        "event": "mapping_hover",
        "id": "AiT07rNN69aOyrHvemOq"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:19:59.000",
        "data": {
            "detail_level": "high",
            "section_id": "11ae5d57-f80f-4ae7-8c27-e6490cbed62e",
            "structured_type": "structured",
            "mapping_index": 9
        },
        "event": "mapping_hover",
        "id": "GJTlcYBS3u8xxIMYrAQk"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:19:59.000",
        "data": {
            "detail_level": "high",
            "section_id": "11ae5d57-f80f-4ae7-8c27-e6490cbed62e",
            "structured_type": "structured",
            "mapping_index": 7
        },
        "event": "mapping_hover",
        "id": "ONNECmzXMRJuGSnkSGqe"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:19:59.000",
        "data": {
            "detail_level": "high",
            "section_id": "11ae5d57-f80f-4ae7-8c27-e6490cbed62e",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "gPoCnjsA3YDuTYvx8bMO"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:19:59.000",
        "data": {
            "detail_level": "high",
            "section_id": "11ae5d57-f80f-4ae7-8c27-e6490cbed62e",
            "structured_type": "structured",
            "mapping_index": 5
        },
        "event": "mapping_hover",
        "id": "iFaCeEBruSL2KWsEJXB1"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:19:59.000",
        "data": {
            "detail_level": "high",
            "section_id": "11ae5d57-f80f-4ae7-8c27-e6490cbed62e",
            "structured_type": "structured",
            "mapping_index": 3
        },
        "event": "mapping_hover",
        "id": "iR724HdRXHeUqLTiZn11"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:19:59.000",
        "data": {
            "detail_level": "high",
            "section_id": "11ae5d57-f80f-4ae7-8c27-e6490cbed62e",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "nFZaA63AHNv364HlVd0B"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:19:59.000",
        "data": {
            "detail_level": "high",
            "section_id": "11ae5d57-f80f-4ae7-8c27-e6490cbed62e",
            "structured_type": "structured",
            "mapping_index": 0
        },
        "event": "mapping_hover",
        "id": "sSbgUM204NsIiMvHQlQI"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:20:02.000",
        "data": {
            "detail_level": "high",
            "section_id": "11ae5d57-f80f-4ae7-8c27-e6490cbed62e",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "8Upsh1RpNbBu3njRcJyV"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:20:02.000",
        "data": {
            "detail_level": "high",
            "section_id": "11ae5d57-f80f-4ae7-8c27-e6490cbed62e",
            "structured_type": "structured",
            "mapping_index": 5
        },
        "event": "mapping_hover",
        "id": "8g2kFhOifhOtOC3G1Ig6"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:20:02.000",
        "data": {
            "detail_level": "high",
            "section_id": "11ae5d57-f80f-4ae7-8c27-e6490cbed62e",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "H4lAPEm16GNhiUo4rRpk"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:20:02.000",
        "data": {
            "detail_level": "high",
            "section_id": "11ae5d57-f80f-4ae7-8c27-e6490cbed62e",
            "structured_type": "structured",
            "mapping_index": 4
        },
        "event": "mapping_hover",
        "id": "ThjJWAix9Sps3qIgwHd9"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:20:02.000",
        "data": {
            "detail_level": "high",
            "section_id": "11ae5d57-f80f-4ae7-8c27-e6490cbed62e",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "b33TL3nPgVWZCjYUjiQG"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:20:02.000",
        "data": {
            "detail_level": "high",
            "section_id": "11ae5d57-f80f-4ae7-8c27-e6490cbed62e",
            "structured_type": "structured",
            "mapping_index": 3
        },
        "event": "mapping_hover",
        "id": "cdpisr07huuxSDN1hcBl"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:20:02.000",
        "data": {
            "detail_level": "high",
            "section_id": "11ae5d57-f80f-4ae7-8c27-e6490cbed62e",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "eMAywZOxkoVs5yg7ZFJj"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:20:02.000",
        "data": {
            "detail_level": "high",
            "section_id": "11ae5d57-f80f-4ae7-8c27-e6490cbed62e",
            "structured_type": "structured",
            "mapping_index": 4
        },
        "event": "mapping_hover",
        "id": "qBm0WeFrzHF8K7HMtgIY"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:20:02.000",
        "data": {
            "detail_level": "high",
            "section_id": "11ae5d57-f80f-4ae7-8c27-e6490cbed62e",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "tIxZcCDq6zJNUpZaaJbK"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:20:02.000",
        "data": {
            "detail_level": "high",
            "section_id": "11ae5d57-f80f-4ae7-8c27-e6490cbed62e",
            "structured_type": "structured",
            "mapping_index": 5
        },
        "event": "mapping_hover",
        "id": "udXVBGx501yBzwxSstXM"
    },
    {
        "source": "backend",
        "timestamp": "2025-08-23 14:20:05.000",
        "data": {
            "summary": {
                "high_unstructured": "The main() function begins by loading the dataset and extracting features, labels, and group information. It then splits the data into training and testing sets based on year, with the most recent two years reserved for testing. An XGBoost ranking model is configured and trained on the training data, after which it predicts scores for the test set. The function evaluates the model's performance using the NDCG metric, prints detailed prediction results for each player in the test years, and generates bar plots visualizing prediction errors for the years 2024 and 2025.",
                "low_structured": "• Loads data and splits it into training and testing sets\n• Trains an XGBoost ranking model and evaluates it\n• Outputs and visualizes prediction results",
                "high_structured": "• Loads data and extracts features, labels, and group sizes\n• Splits data into training (all but last two years) and testing (last two years) sets\n  ◦ Identifies indices for training and testing based on year\n  ◦ Separates features and labels accordingly\n• Computes group sizes for both training and test sets for ranking purposes\n• Initializes and configures an XGBoost ranking model with specified hyperparameters\n• Trains the model on the training data using group information\n• Predicts ranking scores for the test set\n  ◦ Assigns predicted scores and computes predicted ranks within each year\n• Evaluates the model using the NDCG metric on the test set\n• Prints detailed prediction results (year, name, true rank, predicted score, predicted rank)\n• Visualizes prediction errors for the years 2024 and 2025 using bar plots",
                "title": "Summary of the main() Function for MVP Ranking Prediction",
                "medium_unstructured": "The main() function orchestrates the process of loading MVP ranking data, splitting it into training and test sets based on years, and training an XGBoost ranking model. It predicts rankings for the test years, evaluates the model using the NDCG metric, and prints as well as visualizes the results for the most recent years. This workflow enables assessment and visualization of the model's ranking performance.",
                "medium_structured": "• Loads data and splits it into training (past years) and testing (recent years) sets\n• Trains an XGBoost ranking model on the training data\n• Predicts and assigns ranking scores for the test years\n• Evaluates model performance using the NDCG metric\n• Prints and visualizes the prediction results for the test years",
                "low_unstructured": "This function loads data, trains an XGBoost ranking model, evaluates its performance, and visualizes prediction results for recent years."
            },
            "selected_code": "def main():\n    X, y, group, df = load_data()\n\n    # Train-test split on years\n    unique_years = df[\"Year\"].unique()\n    train_years, test_years = (\n        unique_years[:-2],  # train: 2015-2023\n        unique_years[-2:],  # test: 2024-2025\n    )\n\n    train_idx = df[\"Year\"].isin(train_years)\n    test_idx = df[\"Year\"].isin(test_years)\n\n    X_train, X_test = X[train_idx], X[test_idx]\n    y_train, y_test = y[train_idx], y[test_idx]\n\n    # Group sizes\n    train_groups = df[train_idx].groupby(\"Year\").size().to_numpy()\n    test_groups = df[test_idx].groupby(\"Year\").size().to_numpy()\n\n    # Model\n    model = XGBRanker(\n        objective=\"rank:pairwise\",\n        learning_rate=0.1,\n        n_estimators=100,\n        max_depth=4,\n        random_state=42,\n    )\n\n    print(\"Training XGBoostRanker...\")\n    model.fit(X_train, y_train, group=train_groups)\n\n    # Predict, sort, and evaluate\n    y_pred = model.predict(X_test)\n    df.loc[test_idx, \"PredictedScore\"] = y_pred\n    df.loc[test_idx, \"PredictedRank\"] = (\n        df.loc[test_idx]\n        .groupby(\"Year\")[\"PredictedScore\"]\n        .rank(ascending=False, method=\"first\")\n    )\n\n    ndcg = evaluate_ndcg(y_test.to_numpy(), y_pred, test_groups)\n    print(f\"NDCG Score on test years {test_years.tolist()}: {ndcg:.4f}\")\n\n    # Show results\n    print(df[test_idx][[\"Year\", \"Name\", \"Rank\", \"PredictedScore\", \"PredictedRank\"]])\n    plot_ranking_predictions(df, 2024)\n    plot_ranking_predictions(df, 2025)"
        },
        "event": "summarize_selected_code",
        "id": "iRi2aOypwcx1XxUWBoKc"
    },
    {
        "source": "backend",
        "timestamp": "2025-08-23 14:20:07.000",
        "data": {
            "summary": "This function loads data, trains an XGBoost ranking model, evaluates its performance, and visualizes prediction results for recent years.",
            "code": "74: def main():\n75:     X, y, group, df = load_data()\n76: \n77:     # Train-test split on years\n78:     unique_years = df[\"Year\"].unique()\n79:     train_years, test_years = (\n80:         unique_years[:-2],  # train: 2015-2023\n81:         unique_years[-2:],  # test: 2024-2025\n82:     )\n83: \n84:     train_idx = df[\"Year\"].isin(train_years)\n85:     test_idx = df[\"Year\"].isin(test_years)\n86: \n87:     X_train, X_test = X[train_idx], X[test_idx]\n88:     y_train, y_test = y[train_idx], y[test_idx]\n89: \n90:     # Group sizes\n91:     train_groups = df[train_idx].groupby(\"Year\").size().to_numpy()\n92:     test_groups = df[test_idx].groupby(\"Year\").size().to_numpy()\n93: \n94:     # Model\n95:     model = XGBRanker(\n96:         objective=\"rank:pairwise\",\n97:         learning_rate=0.1,\n98:         n_estimators=100,\n99:         max_depth=4,\n100:         random_state=42,\n101:     )\n102: \n103:     print(\"Training XGBoostRanker...\")\n104:     model.fit(X_train, y_train, group=train_groups)\n105: \n106:     # Predict, sort, and evaluate\n107:     y_pred = model.predict(X_test)\n108:     df.loc[test_idx, \"PredictedScore\"] = y_pred\n109:     df.loc[test_idx, \"PredictedRank\"] = (\n110:         df.loc[test_idx]\n111:         .groupby(\"Year\")[\"PredictedScore\"]\n112:         .rank(ascending=False, method=\"first\")\n113:     )\n114: \n115:     ndcg = evaluate_ndcg(y_test.to_numpy(), y_pred, test_groups)\n116:     print(f\"NDCG Score on test years {test_years.tolist()}: {ndcg:.4f}\")\n117: \n118:     # Show results\n119:     print(df[test_idx][[\"Year\", \"Name\", \"Rank\", \"PredictedScore\", \"PredictedRank\"]])\n120:     plot_ranking_predictions(df, 2024)\n121:     plot_ranking_predictions(df, 2025)",
            "mapping": [
                {
                    "codeSegments": [
                        {
                            "line": 75,
                            "code": "X, y, group, df = load_data()"
                        }
                    ],
                    "summaryComponent": "loads data"
                },
                {
                    "codeSegments": [
                        {
                            "line": 95,
                            "code": "model = XGBRanker("
                        },
                        {
                            "line": 104,
                            "code": "model.fit(X_train, y_train, group=train_groups)"
                        }
                    ],
                    "summaryComponent": "trains an XGBoost ranking model"
                },
                {
                    "codeSegments": [
                        {
                            "line": 115,
                            "code": "ndcg = evaluate_ndcg(y_test.to_numpy(), y_pred, test_groups)"
                        }
                    ],
                    "summaryComponent": "evaluates its performance"
                },
                {
                    "codeSegments": [
                        {
                            "line": 120,
                            "code": "plot_ranking_predictions(df, 2024)"
                        },
                        {
                            "line": 121,
                            "code": "plot_ranking_predictions(df, 2025)"
                        }
                    ],
                    "summaryComponent": "visualizes prediction results for recent years"
                }
            ]
        },
        "event": "map_summary_code",
        "id": "GyYzzFXrBBA1jDDoFdeH"
    },
    {
        "source": "backend",
        "timestamp": "2025-08-23 14:20:08.000",
        "data": {
            "summary": "• Loads data and splits it into training and testing sets\n• Trains an XGBoost ranking model and evaluates it\n• Outputs and visualizes prediction results",
            "code": "74: def main():\n75:     X, y, group, df = load_data()\n76: \n77:     # Train-test split on years\n78:     unique_years = df[\"Year\"].unique()\n79:     train_years, test_years = (\n80:         unique_years[:-2],  # train: 2015-2023\n81:         unique_years[-2:],  # test: 2024-2025\n82:     )\n83: \n84:     train_idx = df[\"Year\"].isin(train_years)\n85:     test_idx = df[\"Year\"].isin(test_years)\n86: \n87:     X_train, X_test = X[train_idx], X[test_idx]\n88:     y_train, y_test = y[train_idx], y[test_idx]\n89: \n90:     # Group sizes\n91:     train_groups = df[train_idx].groupby(\"Year\").size().to_numpy()\n92:     test_groups = df[test_idx].groupby(\"Year\").size().to_numpy()\n93: \n94:     # Model\n95:     model = XGBRanker(\n96:         objective=\"rank:pairwise\",\n97:         learning_rate=0.1,\n98:         n_estimators=100,\n99:         max_depth=4,\n100:         random_state=42,\n101:     )\n102: \n103:     print(\"Training XGBoostRanker...\")\n104:     model.fit(X_train, y_train, group=train_groups)\n105: \n106:     # Predict, sort, and evaluate\n107:     y_pred = model.predict(X_test)\n108:     df.loc[test_idx, \"PredictedScore\"] = y_pred\n109:     df.loc[test_idx, \"PredictedRank\"] = (\n110:         df.loc[test_idx]\n111:         .groupby(\"Year\")[\"PredictedScore\"]\n112:         .rank(ascending=False, method=\"first\")\n113:     )\n114: \n115:     ndcg = evaluate_ndcg(y_test.to_numpy(), y_pred, test_groups)\n116:     print(f\"NDCG Score on test years {test_years.tolist()}: {ndcg:.4f}\")\n117: \n118:     # Show results\n119:     print(df[test_idx][[\"Year\", \"Name\", \"Rank\", \"PredictedScore\", \"PredictedRank\"]])\n120:     plot_ranking_predictions(df, 2024)\n121:     plot_ranking_predictions(df, 2025)",
            "mapping": [
                {
                    "codeSegments": [
                        {
                            "line": 75,
                            "code": "X, y, group, df = load_data()"
                        }
                    ],
                    "summaryComponent": "Loads data"
                },
                {
                    "codeSegments": [
                        {
                            "line": 78,
                            "code": "unique_years = df[\"Year\"].unique()"
                        },
                        {
                            "line": 79,
                            "code": "train_years, test_years = ("
                        },
                        {
                            "line": 84,
                            "code": "train_idx = df[\"Year\"].isin(train_years)"
                        },
                        {
                            "line": 85,
                            "code": "test_idx = df[\"Year\"].isin(test_years)"
                        },
                        {
                            "line": 87,
                            "code": "X_train, X_test = X[train_idx], X[test_idx]"
                        },
                        {
                            "line": 88,
                            "code": "y_train, y_test = y[train_idx], y[test_idx]"
                        }
                    ],
                    "summaryComponent": "and splits it into training and testing sets"
                },
                {
                    "codeSegments": [
                        {
                            "line": 95,
                            "code": "model = XGBRanker("
                        },
                        {
                            "line": 104,
                            "code": "model.fit(X_train, y_train, group=train_groups)"
                        }
                    ],
                    "summaryComponent": "Trains an XGBoost ranking model"
                },
                {
                    "codeSegments": [
                        {
                            "line": 115,
                            "code": "ndcg = evaluate_ndcg(y_test.to_numpy(), y_pred, test_groups)"
                        }
                    ],
                    "summaryComponent": "and evaluates it"
                },
                {
                    "codeSegments": [
                        {
                            "line": 119,
                            "code": "print(df[test_idx][[\"Year\", \"Name\", \"Rank\", \"PredictedScore\", \"PredictedRank\"]])"
                        },
                        {
                            "line": 120,
                            "code": "plot_ranking_predictions(df, 2024)"
                        },
                        {
                            "line": 121,
                            "code": "plot_ranking_predictions(df, 2025)"
                        }
                    ],
                    "summaryComponent": "Outputs and visualizes prediction results"
                }
            ]
        },
        "event": "map_summary_code",
        "id": "AxSHbk6gWxla61uJhlmz"
    },
    {
        "source": "backend",
        "timestamp": "2025-08-23 14:20:09.000",
        "data": {
            "summary": "• Loads data and splits it into training (past years) and testing (recent years) sets\n• Trains an XGBoost ranking model on the training data\n• Predicts and assigns ranking scores for the test years\n• Evaluates model performance using the NDCG metric\n• Prints and visualizes the prediction results for the test years",
            "code": "74: def main():\n75:     X, y, group, df = load_data()\n76: \n77:     # Train-test split on years\n78:     unique_years = df[\"Year\"].unique()\n79:     train_years, test_years = (\n80:         unique_years[:-2],  # train: 2015-2023\n81:         unique_years[-2:],  # test: 2024-2025\n82:     )\n83: \n84:     train_idx = df[\"Year\"].isin(train_years)\n85:     test_idx = df[\"Year\"].isin(test_years)\n86: \n87:     X_train, X_test = X[train_idx], X[test_idx]\n88:     y_train, y_test = y[train_idx], y[test_idx]\n89: \n90:     # Group sizes\n91:     train_groups = df[train_idx].groupby(\"Year\").size().to_numpy()\n92:     test_groups = df[test_idx].groupby(\"Year\").size().to_numpy()\n93: \n94:     # Model\n95:     model = XGBRanker(\n96:         objective=\"rank:pairwise\",\n97:         learning_rate=0.1,\n98:         n_estimators=100,\n99:         max_depth=4,\n100:         random_state=42,\n101:     )\n102: \n103:     print(\"Training XGBoostRanker...\")\n104:     model.fit(X_train, y_train, group=train_groups)\n105: \n106:     # Predict, sort, and evaluate\n107:     y_pred = model.predict(X_test)\n108:     df.loc[test_idx, \"PredictedScore\"] = y_pred\n109:     df.loc[test_idx, \"PredictedRank\"] = (\n110:         df.loc[test_idx]\n111:         .groupby(\"Year\")[\"PredictedScore\"]\n112:         .rank(ascending=False, method=\"first\")\n113:     )\n114: \n115:     ndcg = evaluate_ndcg(y_test.to_numpy(), y_pred, test_groups)\n116:     print(f\"NDCG Score on test years {test_years.tolist()}: {ndcg:.4f}\")\n117: \n118:     # Show results\n119:     print(df[test_idx][[\"Year\", \"Name\", \"Rank\", \"PredictedScore\", \"PredictedRank\"]])\n120:     plot_ranking_predictions(df, 2024)\n121:     plot_ranking_predictions(df, 2025)",
            "mapping": [
                {
                    "codeSegments": [
                        {
                            "line": 75,
                            "code": "X, y, group, df = load_data()"
                        },
                        {
                            "line": 78,
                            "code": "unique_years = df[\"Year\"].unique()"
                        },
                        {
                            "line": 79,
                            "code": "train_years, test_years = ("
                        },
                        {
                            "line": 84,
                            "code": "train_idx = df[\"Year\"].isin(train_years)"
                        },
                        {
                            "line": 85,
                            "code": "test_idx = df[\"Year\"].isin(test_years)"
                        },
                        {
                            "line": 87,
                            "code": "X_train, X_test = X[train_idx], X[test_idx]"
                        },
                        {
                            "line": 88,
                            "code": "y_train, y_test = y[train_idx], y[test_idx]"
                        }
                    ],
                    "summaryComponent": "Loads data and splits it into training (past years) and testing (recent years) sets"
                },
                {
                    "codeSegments": [
                        {
                            "line": 95,
                            "code": "model = XGBRanker("
                        },
                        {
                            "line": 104,
                            "code": "model.fit(X_train, y_train, group=train_groups)"
                        }
                    ],
                    "summaryComponent": "Trains an XGBoost ranking model on the training data"
                },
                {
                    "codeSegments": [
                        {
                            "line": 107,
                            "code": "y_pred = model.predict(X_test)"
                        },
                        {
                            "line": 108,
                            "code": "df.loc[test_idx, \"PredictedScore\"] = y_pred"
                        },
                        {
                            "line": 109,
                            "code": "df.loc[test_idx, \"PredictedRank\"] = ("
                        }
                    ],
                    "summaryComponent": "Predicts and assigns ranking scores for the test years"
                },
                {
                    "codeSegments": [
                        {
                            "line": 115,
                            "code": "ndcg = evaluate_ndcg(y_test.to_numpy(), y_pred, test_groups)"
                        },
                        {
                            "line": 116,
                            "code": "print(f\"NDCG Score on test years {test_years.tolist()}: {ndcg:.4f}\")"
                        }
                    ],
                    "summaryComponent": "Evaluates model performance using the NDCG metric"
                },
                {
                    "codeSegments": [
                        {
                            "line": 119,
                            "code": "print(df[test_idx][[\"Year\", \"Name\", \"Rank\", \"PredictedScore\", \"PredictedRank\"]])"
                        },
                        {
                            "line": 120,
                            "code": "plot_ranking_predictions(df, 2024)"
                        },
                        {
                            "line": 121,
                            "code": "plot_ranking_predictions(df, 2025)"
                        }
                    ],
                    "summaryComponent": "Prints and visualizes the prediction results for the test years"
                }
            ]
        },
        "event": "map_summary_code",
        "id": "PSSMlMmgTXEOwaFQSgfS"
    },
    {
        "source": "backend",
        "timestamp": "2025-08-23 14:20:10.000",
        "data": {
            "summary": "The main() function orchestrates the process of loading MVP ranking data, splitting it into training and test sets based on years, and training an XGBoost ranking model. It predicts rankings for the test years, evaluates the model using the NDCG metric, and prints as well as visualizes the results for the most recent years. This workflow enables assessment and visualization of the model's ranking performance.",
            "code": "74: def main():\n75:     X, y, group, df = load_data()\n76: \n77:     # Train-test split on years\n78:     unique_years = df[\"Year\"].unique()\n79:     train_years, test_years = (\n80:         unique_years[:-2],  # train: 2015-2023\n81:         unique_years[-2:],  # test: 2024-2025\n82:     )\n83: \n84:     train_idx = df[\"Year\"].isin(train_years)\n85:     test_idx = df[\"Year\"].isin(test_years)\n86: \n87:     X_train, X_test = X[train_idx], X[test_idx]\n88:     y_train, y_test = y[train_idx], y[test_idx]\n89: \n90:     # Group sizes\n91:     train_groups = df[train_idx].groupby(\"Year\").size().to_numpy()\n92:     test_groups = df[test_idx].groupby(\"Year\").size().to_numpy()\n93: \n94:     # Model\n95:     model = XGBRanker(\n96:         objective=\"rank:pairwise\",\n97:         learning_rate=0.1,\n98:         n_estimators=100,\n99:         max_depth=4,\n100:         random_state=42,\n101:     )\n102: \n103:     print(\"Training XGBoostRanker...\")\n104:     model.fit(X_train, y_train, group=train_groups)\n105: \n106:     # Predict, sort, and evaluate\n107:     y_pred = model.predict(X_test)\n108:     df.loc[test_idx, \"PredictedScore\"] = y_pred\n109:     df.loc[test_idx, \"PredictedRank\"] = (\n110:         df.loc[test_idx]\n111:         .groupby(\"Year\")[\"PredictedScore\"]\n112:         .rank(ascending=False, method=\"first\")\n113:     )\n114: \n115:     ndcg = evaluate_ndcg(y_test.to_numpy(), y_pred, test_groups)\n116:     print(f\"NDCG Score on test years {test_years.tolist()}: {ndcg:.4f}\")\n117: \n118:     # Show results\n119:     print(df[test_idx][[\"Year\", \"Name\", \"Rank\", \"PredictedScore\", \"PredictedRank\"]])\n120:     plot_ranking_predictions(df, 2024)\n121:     plot_ranking_predictions(df, 2025)",
            "mapping": [
                {
                    "codeSegments": [
                        {
                            "line": 74,
                            "code": "def main():"
                        }
                    ],
                    "summaryComponent": "The main() function orchestrates the process"
                },
                {
                    "codeSegments": [
                        {
                            "line": 75,
                            "code": "X, y, group, df = load_data()"
                        }
                    ],
                    "summaryComponent": "loading MVP ranking data"
                },
                {
                    "codeSegments": [
                        {
                            "line": 78,
                            "code": "unique_years = df[\"Year\"].unique()"
                        },
                        {
                            "line": 79,
                            "code": "train_years, test_years = ("
                        },
                        {
                            "line": 84,
                            "code": "train_idx = df[\"Year\"].isin(train_years)"
                        },
                        {
                            "line": 85,
                            "code": "test_idx = df[\"Year\"].isin(test_years)"
                        },
                        {
                            "line": 87,
                            "code": "X_train, X_test = X[train_idx], X[test_idx]"
                        },
                        {
                            "line": 88,
                            "code": "y_train, y_test = y[train_idx], y[test_idx]"
                        }
                    ],
                    "summaryComponent": "splitting it into training and test sets based on years"
                },
                {
                    "codeSegments": [
                        {
                            "line": 95,
                            "code": "model = XGBRanker("
                        },
                        {
                            "line": 104,
                            "code": "model.fit(X_train, y_train, group=train_groups)"
                        }
                    ],
                    "summaryComponent": "training an XGBoost ranking model"
                },
                {
                    "codeSegments": [
                        {
                            "line": 107,
                            "code": "y_pred = model.predict(X_test)"
                        },
                        {
                            "line": 108,
                            "code": "df.loc[test_idx, \"PredictedScore\"] = y_pred"
                        },
                        {
                            "line": 109,
                            "code": "df.loc[test_idx, \"PredictedRank\"] = ("
                        }
                    ],
                    "summaryComponent": "It predicts rankings for the test years"
                },
                {
                    "codeSegments": [
                        {
                            "line": 115,
                            "code": "ndcg = evaluate_ndcg(y_test.to_numpy(), y_pred, test_groups)"
                        }
                    ],
                    "summaryComponent": "evaluates the model using the NDCG metric"
                },
                {
                    "codeSegments": [
                        {
                            "line": 119,
                            "code": "print(df[test_idx][[\"Year\", \"Name\", \"Rank\", \"PredictedScore\", \"PredictedRank\"]])"
                        },
                        {
                            "line": 120,
                            "code": "plot_ranking_predictions(df, 2024)"
                        },
                        {
                            "line": 121,
                            "code": "plot_ranking_predictions(df, 2025)"
                        }
                    ],
                    "summaryComponent": "prints as well as visualizes the results for the most recent years"
                },
                {
                    "codeSegments": [
                        {
                            "line": 115,
                            "code": "ndcg = evaluate_ndcg(y_test.to_numpy(), y_pred, test_groups)"
                        }
                    ],
                    "summaryComponent": "This workflow enables assessment"
                },
                {
                    "codeSegments": [
                        {
                            "line": 120,
                            "code": "plot_ranking_predictions(df, 2024)"
                        },
                        {
                            "line": 121,
                            "code": "plot_ranking_predictions(df, 2025)"
                        }
                    ],
                    "summaryComponent": "and visualization of the model's ranking performance"
                }
            ]
        },
        "event": "map_summary_code",
        "id": "UjqWmYovEv1THyePJIS2"
    },
    {
        "source": "backend",
        "timestamp": "2025-08-23 14:20:10.000",
        "data": {
            "summary": "The main() function begins by loading the dataset and extracting features, labels, and group information. It then splits the data into training and testing sets based on year, with the most recent two years reserved for testing. An XGBoost ranking model is configured and trained on the training data, after which it predicts scores for the test set. The function evaluates the model's performance using the NDCG metric, prints detailed prediction results for each player in the test years, and generates bar plots visualizing prediction errors for the years 2024 and 2025.",
            "code": "74: def main():\n75:     X, y, group, df = load_data()\n76: \n77:     # Train-test split on years\n78:     unique_years = df[\"Year\"].unique()\n79:     train_years, test_years = (\n80:         unique_years[:-2],  # train: 2015-2023\n81:         unique_years[-2:],  # test: 2024-2025\n82:     )\n83: \n84:     train_idx = df[\"Year\"].isin(train_years)\n85:     test_idx = df[\"Year\"].isin(test_years)\n86: \n87:     X_train, X_test = X[train_idx], X[test_idx]\n88:     y_train, y_test = y[train_idx], y[test_idx]\n89: \n90:     # Group sizes\n91:     train_groups = df[train_idx].groupby(\"Year\").size().to_numpy()\n92:     test_groups = df[test_idx].groupby(\"Year\").size().to_numpy()\n93: \n94:     # Model\n95:     model = XGBRanker(\n96:         objective=\"rank:pairwise\",\n97:         learning_rate=0.1,\n98:         n_estimators=100,\n99:         max_depth=4,\n100:         random_state=42,\n101:     )\n102: \n103:     print(\"Training XGBoostRanker...\")\n104:     model.fit(X_train, y_train, group=train_groups)\n105: \n106:     # Predict, sort, and evaluate\n107:     y_pred = model.predict(X_test)\n108:     df.loc[test_idx, \"PredictedScore\"] = y_pred\n109:     df.loc[test_idx, \"PredictedRank\"] = (\n110:         df.loc[test_idx]\n111:         .groupby(\"Year\")[\"PredictedScore\"]\n112:         .rank(ascending=False, method=\"first\")\n113:     )\n114: \n115:     ndcg = evaluate_ndcg(y_test.to_numpy(), y_pred, test_groups)\n116:     print(f\"NDCG Score on test years {test_years.tolist()}: {ndcg:.4f}\")\n117: \n118:     # Show results\n119:     print(df[test_idx][[\"Year\", \"Name\", \"Rank\", \"PredictedScore\", \"PredictedRank\"]])\n120:     plot_ranking_predictions(df, 2024)\n121:     plot_ranking_predictions(df, 2025)",
            "mapping": [
                {
                    "codeSegments": [
                        {
                            "line": 74,
                            "code": "def main():"
                        },
                        {
                            "line": 75,
                            "code": "X, y, group, df = load_data()"
                        }
                    ],
                    "summaryComponent": "The main() function begins by loading the dataset and extracting features, labels, and group information."
                },
                {
                    "codeSegments": [
                        {
                            "line": 78,
                            "code": "unique_years = df[\"Year\"].unique()"
                        },
                        {
                            "line": 79,
                            "code": "train_years, test_years = ("
                        },
                        {
                            "line": 80,
                            "code": "    unique_years[:-2],  # train: 2015-2023"
                        },
                        {
                            "line": 81,
                            "code": "    unique_years[-2:],  # test: 2024-2025"
                        },
                        {
                            "line": 82,
                            "code": ")"
                        },
                        {
                            "line": 84,
                            "code": "train_idx = df[\"Year\"].isin(train_years)"
                        },
                        {
                            "line": 85,
                            "code": "test_idx = df[\"Year\"].isin(test_years)"
                        },
                        {
                            "line": 87,
                            "code": "X_train, X_test = X[train_idx], X[test_idx]"
                        },
                        {
                            "line": 88,
                            "code": "y_train, y_test = y[train_idx], y[test_idx]"
                        }
                    ],
                    "summaryComponent": "It then splits the data into training and testing sets based on year, with the most recent two years reserved for testing."
                },
                {
                    "codeSegments": [
                        {
                            "line": 95,
                            "code": "model = XGBRanker("
                        },
                        {
                            "line": 96,
                            "code": "    objective=\"rank:pairwise\","
                        },
                        {
                            "line": 97,
                            "code": "    learning_rate=0.1,"
                        },
                        {
                            "line": 98,
                            "code": "    n_estimators=100,"
                        },
                        {
                            "line": 99,
                            "code": "    max_depth=4,"
                        },
                        {
                            "line": 100,
                            "code": "    random_state=42,"
                        },
                        {
                            "line": 101,
                            "code": ")"
                        },
                        {
                            "line": 104,
                            "code": "model.fit(X_train, y_train, group=train_groups)"
                        }
                    ],
                    "summaryComponent": "An XGBoost ranking model is configured and trained on the training data,"
                },
                {
                    "codeSegments": [
                        {
                            "line": 107,
                            "code": "y_pred = model.predict(X_test)"
                        }
                    ],
                    "summaryComponent": "after which it predicts scores for the test set."
                },
                {
                    "codeSegments": [
                        {
                            "line": 115,
                            "code": "ndcg = evaluate_ndcg(y_test.to_numpy(), y_pred, test_groups)"
                        }
                    ],
                    "summaryComponent": "The function evaluates the model's performance using the NDCG metric,"
                },
                {
                    "codeSegments": [
                        {
                            "line": 119,
                            "code": "print(df[test_idx][[\"Year\", \"Name\", \"Rank\", \"PredictedScore\", \"PredictedRank\"]])"
                        }
                    ],
                    "summaryComponent": "prints detailed prediction results for each player in the test years,"
                },
                {
                    "codeSegments": [
                        {
                            "line": 120,
                            "code": "plot_ranking_predictions(df, 2024)"
                        },
                        {
                            "line": 121,
                            "code": "plot_ranking_predictions(df, 2025)"
                        }
                    ],
                    "summaryComponent": "and generates bar plots visualizing prediction errors for the years 2024 and 2025."
                }
            ]
        },
        "event": "map_summary_code",
        "id": "u5WQq4eVcOB7LASX3XqK"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:20:11.000",
        "data": {
            "section_data": {
                "editPromptValue": "",
                "summaryData": {
                    "high_unstructured": "The main() function begins by loading the dataset and extracting features, labels, and group information. It then splits the data into training and testing sets based on year, with the most recent two years reserved for testing. An XGBoost ranking model is configured and trained on the training data, after which it predicts scores for the test set. The function evaluates the model's performance using the NDCG metric, prints detailed prediction results for each player in the test years, and generates bar plots visualizing prediction errors for the years 2024 and 2025.",
                    "low_structured": "• Loads data and splits it into training and testing sets\n• Trains an XGBoost ranking model and evaluates it\n• Outputs and visualizes prediction results",
                    "high_structured": "• Loads data and extracts features, labels, and group sizes\n• Splits data into training (all but last two years) and testing (last two years) sets\n  ◦ Identifies indices for training and testing based on year\n  ◦ Separates features and labels accordingly\n• Computes group sizes for both training and test sets for ranking purposes\n• Initializes and configures an XGBoost ranking model with specified hyperparameters\n• Trains the model on the training data using group information\n• Predicts ranking scores for the test set\n  ◦ Assigns predicted scores and computes predicted ranks within each year\n• Evaluates the model using the NDCG metric on the test set\n• Prints detailed prediction results (year, name, true rank, predicted score, predicted rank)\n• Visualizes prediction errors for the years 2024 and 2025 using bar plots",
                    "title": "Summary of the main() Function for MVP Ranking Prediction",
                    "medium_unstructured": "The main() function orchestrates the process of loading MVP ranking data, splitting it into training and test sets based on years, and training an XGBoost ranking model. It predicts rankings for the test years, evaluates the model using the NDCG metric, and prints as well as visualizes the results for the most recent years. This workflow enables assessment and visualization of the model's ranking performance.",
                    "medium_structured": "• Loads data and splits it into training (past years) and testing (recent years) sets\n• Trains an XGBoost ranking model on the training data\n• Predicts and assigns ranking scores for the test years\n• Evaluates model performance using the NDCG metric\n• Prints and visualizes the prediction results for the test years",
                    "low_unstructured": "This function loads data, trains an XGBoost ranking model, evaluates its performance, and visualizes prediction results for recent years."
                },
                "selectedDetailLevel": "medium",
                "title": "Summary of the main() Function for MVP Ranking Prediction",
                "summaryMappings": {
                    "low_structured": [
                        {
                            "codeSegments": [
                                {
                                    "line": 75,
                                    "code": "X, y, group, df = load_data()"
                                }
                            ],
                            "summaryComponent": "Loads data"
                        },
                        {
                            "codeSegments": [
                                {
                                    "line": 78,
                                    "code": "unique_years = df[\"Year\"].unique()"
                                },
                                {
                                    "line": 79,
                                    "code": "train_years, test_years = ("
                                },
                                {
                                    "line": 84,
                                    "code": "train_idx = df[\"Year\"].isin(train_years)"
                                },
                                {
                                    "line": 85,
                                    "code": "test_idx = df[\"Year\"].isin(test_years)"
                                },
                                {
                                    "line": 87,
                                    "code": "X_train, X_test = X[train_idx], X[test_idx]"
                                },
                                {
                                    "line": 88,
                                    "code": "y_train, y_test = y[train_idx], y[test_idx]"
                                }
                            ],
                            "summaryComponent": "and splits it into training and testing sets"
                        },
                        {
                            "codeSegments": [
                                {
                                    "line": 95,
                                    "code": "model = XGBRanker("
                                },
                                {
                                    "line": 104,
                                    "code": "model.fit(X_train, y_train, group=train_groups)"
                                }
                            ],
                            "summaryComponent": "Trains an XGBoost ranking model"
                        },
                        {
                            "codeSegments": [
                                {
                                    "line": 115,
                                    "code": "ndcg = evaluate_ndcg(y_test.to_numpy(), y_pred, test_groups)"
                                }
                            ],
                            "summaryComponent": "and evaluates it"
                        },
                        {
                            "codeSegments": [
                                {
                                    "line": 119,
                                    "code": "print(df[test_idx][[\"Year\", \"Name\", \"Rank\", \"PredictedScore\", \"PredictedRank\"]])"
                                },
                                {
                                    "line": 120,
                                    "code": "plot_ranking_predictions(df, 2024)"
                                },
                                {
                                    "line": 121,
                                    "code": "plot_ranking_predictions(df, 2025)"
                                }
                            ],
                            "summaryComponent": "Outputs and visualizes prediction results"
                        }
                    ],
                    "high_structured": [
                        {
                            "codeSegments": [
                                {
                                    "line": 75,
                                    "code": "X, y, group, df = load_data()"
                                }
                            ],
                            "summaryComponent": "Loads data and extracts features, labels, and group sizes"
                        },
                        {
                            "codeSegments": [
                                {
                                    "line": 78,
                                    "code": "unique_years = df[\"Year\"].unique()"
                                },
                                {
                                    "line": 79,
                                    "code": "train_years, test_years = ("
                                },
                                {
                                    "line": 80,
                                    "code": "    unique_years[:-2],  # train: 2015-2023"
                                },
                                {
                                    "line": 81,
                                    "code": "    unique_years[-2:],  # test: 2024-2025"
                                },
                                {
                                    "line": 82,
                                    "code": ")"
                                }
                            ],
                            "summaryComponent": "Splits data into training (all but last two years) and testing (last two years) sets"
                        },
                        {
                            "codeSegments": [
                                {
                                    "line": 84,
                                    "code": "train_idx = df[\"Year\"].isin(train_years)"
                                },
                                {
                                    "line": 85,
                                    "code": "test_idx = df[\"Year\"].isin(test_years)"
                                }
                            ],
                            "summaryComponent": "Identifies indices for training and testing based on year"
                        },
                        {
                            "codeSegments": [
                                {
                                    "line": 87,
                                    "code": "X_train, X_test = X[train_idx], X[test_idx]"
                                },
                                {
                                    "line": 88,
                                    "code": "y_train, y_test = y[train_idx], y[test_idx]"
                                }
                            ],
                            "summaryComponent": "Separates features and labels accordingly"
                        },
                        {
                            "codeSegments": [
                                {
                                    "line": 91,
                                    "code": "train_groups = df[train_idx].groupby(\"Year\").size().to_numpy()"
                                },
                                {
                                    "line": 92,
                                    "code": "test_groups = df[test_idx].groupby(\"Year\").size().to_numpy()"
                                }
                            ],
                            "summaryComponent": "Computes group sizes for both training and test sets for ranking purposes"
                        },
                        {
                            "codeSegments": [
                                {
                                    "line": 95,
                                    "code": "model = XGBRanker("
                                },
                                {
                                    "line": 96,
                                    "code": "    objective=\"rank:pairwise\","
                                },
                                {
                                    "line": 97,
                                    "code": "    learning_rate=0.1,"
                                },
                                {
                                    "line": 98,
                                    "code": "    n_estimators=100,"
                                },
                                {
                                    "line": 99,
                                    "code": "    max_depth=4,"
                                },
                                {
                                    "line": 100,
                                    "code": "    random_state=42,"
                                },
                                {
                                    "line": 101,
                                    "code": ")"
                                }
                            ],
                            "summaryComponent": "Initializes and configures an XGBoost ranking model with specified hyperparameters"
                        },
                        {
                            "codeSegments": [
                                {
                                    "line": 104,
                                    "code": "model.fit(X_train, y_train, group=train_groups)"
                                }
                            ],
                            "summaryComponent": "Trains the model on the training data using group information"
                        },
                        {
                            "codeSegments": [
                                {
                                    "line": 107,
                                    "code": "y_pred = model.predict(X_test)"
                                }
                            ],
                            "summaryComponent": "Predicts ranking scores for the test set"
                        },
                        {
                            "codeSegments": [
                                {
                                    "line": 108,
                                    "code": "df.loc[test_idx, \"PredictedScore\"] = y_pred"
                                },
                                {
                                    "line": 109,
                                    "code": "df.loc[test_idx, \"PredictedRank\"] = ("
                                },
                                {
                                    "line": 110,
                                    "code": "    df.loc[test_idx]"
                                },
                                {
                                    "line": 111,
                                    "code": "    .groupby(\"Year\")[\"PredictedScore\"]"
                                },
                                {
                                    "line": 112,
                                    "code": "    .rank(ascending=False, method=\"first\")"
                                },
                                {
                                    "line": 113,
                                    "code": ")"
                                }
                            ],
                            "summaryComponent": "Assigns predicted scores and computes predicted ranks within each year"
                        },
                        {
                            "codeSegments": [
                                {
                                    "line": 115,
                                    "code": "ndcg = evaluate_ndcg(y_test.to_numpy(), y_pred, test_groups)"
                                }
                            ],
                            "summaryComponent": "Evaluates the model using the NDCG metric on the test set"
                        },
                        {
                            "codeSegments": [
                                {
                                    "line": 119,
                                    "code": "print(df[test_idx][[\"Year\", \"Name\", \"Rank\", \"PredictedScore\", \"PredictedRank\"]])"
                                }
                            ],
                            "summaryComponent": "Prints detailed prediction results (year, name, true rank, predicted score, predicted rank)"
                        },
                        {
                            "codeSegments": [
                                {
                                    "line": 120,
                                    "code": "plot_ranking_predictions(df, 2024)"
                                },
                                {
                                    "line": 121,
                                    "code": "plot_ranking_predictions(df, 2025)"
                                }
                            ],
                            "summaryComponent": "Visualizes prediction errors for the years 2024 and 2025 using bar plots"
                        }
                    ],
                    "medium_structured": [
                        {
                            "codeSegments": [
                                {
                                    "line": 75,
                                    "code": "X, y, group, df = load_data()"
                                },
                                {
                                    "line": 78,
                                    "code": "unique_years = df[\"Year\"].unique()"
                                },
                                {
                                    "line": 79,
                                    "code": "train_years, test_years = ("
                                },
                                {
                                    "line": 84,
                                    "code": "train_idx = df[\"Year\"].isin(train_years)"
                                },
                                {
                                    "line": 85,
                                    "code": "test_idx = df[\"Year\"].isin(test_years)"
                                },
                                {
                                    "line": 87,
                                    "code": "X_train, X_test = X[train_idx], X[test_idx]"
                                },
                                {
                                    "line": 88,
                                    "code": "y_train, y_test = y[train_idx], y[test_idx]"
                                }
                            ],
                            "summaryComponent": "Loads data and splits it into training (past years) and testing (recent years) sets"
                        },
                        {
                            "codeSegments": [
                                {
                                    "line": 95,
                                    "code": "model = XGBRanker("
                                },
                                {
                                    "line": 104,
                                    "code": "model.fit(X_train, y_train, group=train_groups)"
                                }
                            ],
                            "summaryComponent": "Trains an XGBoost ranking model on the training data"
                        },
                        {
                            "codeSegments": [
                                {
                                    "line": 107,
                                    "code": "y_pred = model.predict(X_test)"
                                },
                                {
                                    "line": 108,
                                    "code": "df.loc[test_idx, \"PredictedScore\"] = y_pred"
                                },
                                {
                                    "line": 109,
                                    "code": "df.loc[test_idx, \"PredictedRank\"] = ("
                                }
                            ],
                            "summaryComponent": "Predicts and assigns ranking scores for the test years"
                        },
                        {
                            "codeSegments": [
                                {
                                    "line": 115,
                                    "code": "ndcg = evaluate_ndcg(y_test.to_numpy(), y_pred, test_groups)"
                                },
                                {
                                    "line": 116,
                                    "code": "print(f\"NDCG Score on test years {test_years.tolist()}: {ndcg:.4f}\")"
                                }
                            ],
                            "summaryComponent": "Evaluates model performance using the NDCG metric"
                        },
                        {
                            "codeSegments": [
                                {
                                    "line": 119,
                                    "code": "print(df[test_idx][[\"Year\", \"Name\", \"Rank\", \"PredictedScore\", \"PredictedRank\"]])"
                                },
                                {
                                    "line": 120,
                                    "code": "plot_ranking_predictions(df, 2024)"
                                },
                                {
                                    "line": 121,
                                    "code": "plot_ranking_predictions(df, 2025)"
                                }
                            ],
                            "summaryComponent": "Prints and visualizes the prediction results for the test years"
                        }
                    ],
                    "medium_unstructured": [
                        {
                            "codeSegments": [
                                {
                                    "line": 74,
                                    "code": "def main():"
                                }
                            ],
                            "summaryComponent": "The main() function orchestrates the process"
                        },
                        {
                            "codeSegments": [
                                {
                                    "line": 75,
                                    "code": "X, y, group, df = load_data()"
                                }
                            ],
                            "summaryComponent": "loading MVP ranking data"
                        },
                        {
                            "codeSegments": [
                                {
                                    "line": 78,
                                    "code": "unique_years = df[\"Year\"].unique()"
                                },
                                {
                                    "line": 79,
                                    "code": "train_years, test_years = ("
                                },
                                {
                                    "line": 84,
                                    "code": "train_idx = df[\"Year\"].isin(train_years)"
                                },
                                {
                                    "line": 85,
                                    "code": "test_idx = df[\"Year\"].isin(test_years)"
                                },
                                {
                                    "line": 87,
                                    "code": "X_train, X_test = X[train_idx], X[test_idx]"
                                },
                                {
                                    "line": 88,
                                    "code": "y_train, y_test = y[train_idx], y[test_idx]"
                                }
                            ],
                            "summaryComponent": "splitting it into training and test sets based on years"
                        },
                        {
                            "codeSegments": [
                                {
                                    "line": 95,
                                    "code": "model = XGBRanker("
                                },
                                {
                                    "line": 104,
                                    "code": "model.fit(X_train, y_train, group=train_groups)"
                                }
                            ],
                            "summaryComponent": "training an XGBoost ranking model"
                        },
                        {
                            "codeSegments": [
                                {
                                    "line": 107,
                                    "code": "y_pred = model.predict(X_test)"
                                },
                                {
                                    "line": 108,
                                    "code": "df.loc[test_idx, \"PredictedScore\"] = y_pred"
                                },
                                {
                                    "line": 109,
                                    "code": "df.loc[test_idx, \"PredictedRank\"] = ("
                                }
                            ],
                            "summaryComponent": "It predicts rankings for the test years"
                        },
                        {
                            "codeSegments": [
                                {
                                    "line": 115,
                                    "code": "ndcg = evaluate_ndcg(y_test.to_numpy(), y_pred, test_groups)"
                                }
                            ],
                            "summaryComponent": "evaluates the model using the NDCG metric"
                        },
                        {
                            "codeSegments": [
                                {
                                    "line": 119,
                                    "code": "print(df[test_idx][[\"Year\", \"Name\", \"Rank\", \"PredictedScore\", \"PredictedRank\"]])"
                                },
                                {
                                    "line": 120,
                                    "code": "plot_ranking_predictions(df, 2024)"
                                },
                                {
                                    "line": 121,
                                    "code": "plot_ranking_predictions(df, 2025)"
                                }
                            ],
                            "summaryComponent": "prints as well as visualizes the results for the most recent years"
                        },
                        {
                            "codeSegments": [
                                {
                                    "line": 115,
                                    "code": "ndcg = evaluate_ndcg(y_test.to_numpy(), y_pred, test_groups)"
                                }
                            ],
                            "summaryComponent": "This workflow enables assessment"
                        },
                        {
                            "codeSegments": [
                                {
                                    "line": 120,
                                    "code": "plot_ranking_predictions(df, 2024)"
                                },
                                {
                                    "line": 121,
                                    "code": "plot_ranking_predictions(df, 2025)"
                                }
                            ],
                            "summaryComponent": "and visualization of the model's ranking performance"
                        }
                    ],
                    "high_unstructured": [
                        {
                            "codeSegments": [
                                {
                                    "line": 74,
                                    "code": "def main():"
                                },
                                {
                                    "line": 75,
                                    "code": "X, y, group, df = load_data()"
                                }
                            ],
                            "summaryComponent": "The main() function begins by loading the dataset and extracting features, labels, and group information."
                        },
                        {
                            "codeSegments": [
                                {
                                    "line": 78,
                                    "code": "unique_years = df[\"Year\"].unique()"
                                },
                                {
                                    "line": 79,
                                    "code": "train_years, test_years = ("
                                },
                                {
                                    "line": 80,
                                    "code": "    unique_years[:-2],  # train: 2015-2023"
                                },
                                {
                                    "line": 81,
                                    "code": "    unique_years[-2:],  # test: 2024-2025"
                                },
                                {
                                    "line": 82,
                                    "code": ")"
                                },
                                {
                                    "line": 84,
                                    "code": "train_idx = df[\"Year\"].isin(train_years)"
                                },
                                {
                                    "line": 85,
                                    "code": "test_idx = df[\"Year\"].isin(test_years)"
                                },
                                {
                                    "line": 87,
                                    "code": "X_train, X_test = X[train_idx], X[test_idx]"
                                },
                                {
                                    "line": 88,
                                    "code": "y_train, y_test = y[train_idx], y[test_idx]"
                                }
                            ],
                            "summaryComponent": "It then splits the data into training and testing sets based on year, with the most recent two years reserved for testing."
                        },
                        {
                            "codeSegments": [
                                {
                                    "line": 95,
                                    "code": "model = XGBRanker("
                                },
                                {
                                    "line": 96,
                                    "code": "    objective=\"rank:pairwise\","
                                },
                                {
                                    "line": 97,
                                    "code": "    learning_rate=0.1,"
                                },
                                {
                                    "line": 98,
                                    "code": "    n_estimators=100,"
                                },
                                {
                                    "line": 99,
                                    "code": "    max_depth=4,"
                                },
                                {
                                    "line": 100,
                                    "code": "    random_state=42,"
                                },
                                {
                                    "line": 101,
                                    "code": ")"
                                },
                                {
                                    "line": 104,
                                    "code": "model.fit(X_train, y_train, group=train_groups)"
                                }
                            ],
                            "summaryComponent": "An XGBoost ranking model is configured and trained on the training data,"
                        },
                        {
                            "codeSegments": [
                                {
                                    "line": 107,
                                    "code": "y_pred = model.predict(X_test)"
                                }
                            ],
                            "summaryComponent": "after which it predicts scores for the test set."
                        },
                        {
                            "codeSegments": [
                                {
                                    "line": 115,
                                    "code": "ndcg = evaluate_ndcg(y_test.to_numpy(), y_pred, test_groups)"
                                }
                            ],
                            "summaryComponent": "The function evaluates the model's performance using the NDCG metric,"
                        },
                        {
                            "codeSegments": [
                                {
                                    "line": 119,
                                    "code": "print(df[test_idx][[\"Year\", \"Name\", \"Rank\", \"PredictedScore\", \"PredictedRank\"]])"
                                }
                            ],
                            "summaryComponent": "prints detailed prediction results for each player in the test years,"
                        },
                        {
                            "codeSegments": [
                                {
                                    "line": 120,
                                    "code": "plot_ranking_predictions(df, 2024)"
                                },
                                {
                                    "line": 121,
                                    "code": "plot_ranking_predictions(df, 2025)"
                                }
                            ],
                            "summaryComponent": "and generates bar plots visualizing prediction errors for the years 2024 and 2025."
                        }
                    ],
                    "low_unstructured": [
                        {
                            "codeSegments": [
                                {
                                    "line": 75,
                                    "code": "X, y, group, df = load_data()"
                                }
                            ],
                            "summaryComponent": "loads data"
                        },
                        {
                            "codeSegments": [
                                {
                                    "line": 95,
                                    "code": "model = XGBRanker("
                                },
                                {
                                    "line": 104,
                                    "code": "model.fit(X_train, y_train, group=train_groups)"
                                }
                            ],
                            "summaryComponent": "trains an XGBoost ranking model"
                        },
                        {
                            "codeSegments": [
                                {
                                    "line": 115,
                                    "code": "ndcg = evaluate_ndcg(y_test.to_numpy(), y_pred, test_groups)"
                                }
                            ],
                            "summaryComponent": "evaluates its performance"
                        },
                        {
                            "codeSegments": [
                                {
                                    "line": 120,
                                    "code": "plot_ranking_predictions(df, 2024)"
                                },
                                {
                                    "line": 121,
                                    "code": "plot_ranking_predictions(df, 2025)"
                                }
                            ],
                            "summaryComponent": "visualizes prediction results for recent years"
                        }
                    ]
                },
                "metadata": {
                    "id": "0ed5da4b-0189-4c5e-be85-742c387e4d53",
                    "filename": "rank_model.py",
                    "offset": 1952,
                    "fullPath": "/project/workspace/rank_model.py",
                    "originalCode": "def main():\n    X, y, group, df = load_data()\n\n    # Train-test split on years\n    unique_years = df[\"Year\"].unique()\n    train_years, test_years = (\n        unique_years[:-2],  # train: 2015-2023\n        unique_years[-2:],  # test: 2024-2025\n    )\n\n    train_idx = df[\"Year\"].isin(train_years)\n    test_idx = df[\"Year\"].isin(test_years)\n\n    X_train, X_test = X[train_idx], X[test_idx]\n    y_train, y_test = y[train_idx], y[test_idx]\n\n    # Group sizes\n    train_groups = df[train_idx].groupby(\"Year\").size().to_numpy()\n    test_groups = df[test_idx].groupby(\"Year\").size().to_numpy()\n\n    # Model\n    model = XGBRanker(\n        objective=\"rank:pairwise\",\n        learning_rate=0.1,\n        n_estimators=100,\n        max_depth=4,\n        random_state=42,\n    )\n\n    print(\"Training XGBoostRanker...\")\n    model.fit(X_train, y_train, group=train_groups)\n\n    # Predict, sort, and evaluate\n    y_pred = model.predict(X_test)\n    df.loc[test_idx, \"PredictedScore\"] = y_pred\n    df.loc[test_idx, \"PredictedRank\"] = (\n        df.loc[test_idx]\n        .groupby(\"Year\")[\"PredictedScore\"]\n        .rank(ascending=False, method=\"first\")\n    )\n\n    ndcg = evaluate_ndcg(y_test.to_numpy(), y_pred, test_groups)\n    print(f\"NDCG Score on test years {test_years.tolist()}: {ndcg:.4f}\")\n\n    # Show results\n    print(df[test_idx][[\"Year\", \"Name\", \"Rank\", \"PredictedScore\", \"PredictedRank\"]])\n    plot_ranking_predictions(df, 2024)\n    plot_ranking_predictions(df, 2025)"
                },
                "createdAt": 1755987612000,
                "lines": [
                    74,
                    121
                ],
                "editPromptStructured": null,
                "selectedStructured": "unstructured",
                "editPromptDetailLevel": null
            },
            "section_id": "0ed5da4b-0189-4c5e-be85-742c387e4d53"
        },
        "event": "create_new_section",
        "id": "BC93SQezHutcOdmUlDg2"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:20:11.000",
        "data": {
            "after_section_id": "0ed5da4b-0189-4c5e-be85-742c387e4d53",
            "before_section_id": "11ae5d57-f80f-4ae7-8c27-e6490cbed62e"
        },
        "event": "autotransit_section",
        "id": "NYwq0PkvvyjrVs33n7rz"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:20:12.000",
        "data": {
            "detail_level": "medium",
            "section_id": "0ed5da4b-0189-4c5e-be85-742c387e4d53",
            "structured_type": "unstructured",
            "mapping_index": 0
        },
        "event": "mapping_hover",
        "id": "2nWua10fzpDbRCTq9vLG"
    },
    {
        "source": "backend",
        "timestamp": "2025-08-23 14:20:12.000",
        "data": {
            "summary": "• Loads data and extracts features, labels, and group sizes\n• Splits data into training (all but last two years) and testing (last two years) sets\n  ◦ Identifies indices for training and testing based on year\n  ◦ Separates features and labels accordingly\n• Computes group sizes for both training and test sets for ranking purposes\n• Initializes and configures an XGBoost ranking model with specified hyperparameters\n• Trains the model on the training data using group information\n• Predicts ranking scores for the test set\n  ◦ Assigns predicted scores and computes predicted ranks within each year\n• Evaluates the model using the NDCG metric on the test set\n• Prints detailed prediction results (year, name, true rank, predicted score, predicted rank)\n• Visualizes prediction errors for the years 2024 and 2025 using bar plots",
            "code": "74: def main():\n75:     X, y, group, df = load_data()\n76: \n77:     # Train-test split on years\n78:     unique_years = df[\"Year\"].unique()\n79:     train_years, test_years = (\n80:         unique_years[:-2],  # train: 2015-2023\n81:         unique_years[-2:],  # test: 2024-2025\n82:     )\n83: \n84:     train_idx = df[\"Year\"].isin(train_years)\n85:     test_idx = df[\"Year\"].isin(test_years)\n86: \n87:     X_train, X_test = X[train_idx], X[test_idx]\n88:     y_train, y_test = y[train_idx], y[test_idx]\n89: \n90:     # Group sizes\n91:     train_groups = df[train_idx].groupby(\"Year\").size().to_numpy()\n92:     test_groups = df[test_idx].groupby(\"Year\").size().to_numpy()\n93: \n94:     # Model\n95:     model = XGBRanker(\n96:         objective=\"rank:pairwise\",\n97:         learning_rate=0.1,\n98:         n_estimators=100,\n99:         max_depth=4,\n100:         random_state=42,\n101:     )\n102: \n103:     print(\"Training XGBoostRanker...\")\n104:     model.fit(X_train, y_train, group=train_groups)\n105: \n106:     # Predict, sort, and evaluate\n107:     y_pred = model.predict(X_test)\n108:     df.loc[test_idx, \"PredictedScore\"] = y_pred\n109:     df.loc[test_idx, \"PredictedRank\"] = (\n110:         df.loc[test_idx]\n111:         .groupby(\"Year\")[\"PredictedScore\"]\n112:         .rank(ascending=False, method=\"first\")\n113:     )\n114: \n115:     ndcg = evaluate_ndcg(y_test.to_numpy(), y_pred, test_groups)\n116:     print(f\"NDCG Score on test years {test_years.tolist()}: {ndcg:.4f}\")\n117: \n118:     # Show results\n119:     print(df[test_idx][[\"Year\", \"Name\", \"Rank\", \"PredictedScore\", \"PredictedRank\"]])\n120:     plot_ranking_predictions(df, 2024)\n121:     plot_ranking_predictions(df, 2025)",
            "mapping": [
                {
                    "codeSegments": [
                        {
                            "line": 75,
                            "code": "X, y, group, df = load_data()"
                        }
                    ],
                    "summaryComponent": "Loads data and extracts features, labels, and group sizes"
                },
                {
                    "codeSegments": [
                        {
                            "line": 78,
                            "code": "unique_years = df[\"Year\"].unique()"
                        },
                        {
                            "line": 79,
                            "code": "train_years, test_years = ("
                        },
                        {
                            "line": 80,
                            "code": "    unique_years[:-2],  # train: 2015-2023"
                        },
                        {
                            "line": 81,
                            "code": "    unique_years[-2:],  # test: 2024-2025"
                        },
                        {
                            "line": 82,
                            "code": ")"
                        }
                    ],
                    "summaryComponent": "Splits data into training (all but last two years) and testing (last two years) sets"
                },
                {
                    "codeSegments": [
                        {
                            "line": 84,
                            "code": "train_idx = df[\"Year\"].isin(train_years)"
                        },
                        {
                            "line": 85,
                            "code": "test_idx = df[\"Year\"].isin(test_years)"
                        }
                    ],
                    "summaryComponent": "Identifies indices for training and testing based on year"
                },
                {
                    "codeSegments": [
                        {
                            "line": 87,
                            "code": "X_train, X_test = X[train_idx], X[test_idx]"
                        },
                        {
                            "line": 88,
                            "code": "y_train, y_test = y[train_idx], y[test_idx]"
                        }
                    ],
                    "summaryComponent": "Separates features and labels accordingly"
                },
                {
                    "codeSegments": [
                        {
                            "line": 91,
                            "code": "train_groups = df[train_idx].groupby(\"Year\").size().to_numpy()"
                        },
                        {
                            "line": 92,
                            "code": "test_groups = df[test_idx].groupby(\"Year\").size().to_numpy()"
                        }
                    ],
                    "summaryComponent": "Computes group sizes for both training and test sets for ranking purposes"
                },
                {
                    "codeSegments": [
                        {
                            "line": 95,
                            "code": "model = XGBRanker("
                        },
                        {
                            "line": 96,
                            "code": "    objective=\"rank:pairwise\","
                        },
                        {
                            "line": 97,
                            "code": "    learning_rate=0.1,"
                        },
                        {
                            "line": 98,
                            "code": "    n_estimators=100,"
                        },
                        {
                            "line": 99,
                            "code": "    max_depth=4,"
                        },
                        {
                            "line": 100,
                            "code": "    random_state=42,"
                        },
                        {
                            "line": 101,
                            "code": ")"
                        }
                    ],
                    "summaryComponent": "Initializes and configures an XGBoost ranking model with specified hyperparameters"
                },
                {
                    "codeSegments": [
                        {
                            "line": 104,
                            "code": "model.fit(X_train, y_train, group=train_groups)"
                        }
                    ],
                    "summaryComponent": "Trains the model on the training data using group information"
                },
                {
                    "codeSegments": [
                        {
                            "line": 107,
                            "code": "y_pred = model.predict(X_test)"
                        }
                    ],
                    "summaryComponent": "Predicts ranking scores for the test set"
                },
                {
                    "codeSegments": [
                        {
                            "line": 108,
                            "code": "df.loc[test_idx, \"PredictedScore\"] = y_pred"
                        },
                        {
                            "line": 109,
                            "code": "df.loc[test_idx, \"PredictedRank\"] = ("
                        },
                        {
                            "line": 110,
                            "code": "    df.loc[test_idx]"
                        },
                        {
                            "line": 111,
                            "code": "    .groupby(\"Year\")[\"PredictedScore\"]"
                        },
                        {
                            "line": 112,
                            "code": "    .rank(ascending=False, method=\"first\")"
                        },
                        {
                            "line": 113,
                            "code": ")"
                        }
                    ],
                    "summaryComponent": "Assigns predicted scores and computes predicted ranks within each year"
                },
                {
                    "codeSegments": [
                        {
                            "line": 115,
                            "code": "ndcg = evaluate_ndcg(y_test.to_numpy(), y_pred, test_groups)"
                        }
                    ],
                    "summaryComponent": "Evaluates the model using the NDCG metric on the test set"
                },
                {
                    "codeSegments": [
                        {
                            "line": 119,
                            "code": "print(df[test_idx][[\"Year\", \"Name\", \"Rank\", \"PredictedScore\", \"PredictedRank\"]])"
                        }
                    ],
                    "summaryComponent": "Prints detailed prediction results (year, name, true rank, predicted score, predicted rank)"
                },
                {
                    "codeSegments": [
                        {
                            "line": 120,
                            "code": "plot_ranking_predictions(df, 2024)"
                        },
                        {
                            "line": 121,
                            "code": "plot_ranking_predictions(df, 2025)"
                        }
                    ],
                    "summaryComponent": "Visualizes prediction errors for the years 2024 and 2025 using bar plots"
                }
            ]
        },
        "event": "map_summary_code",
        "id": "CP7dRKElaZcEMO9I6ppY"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:20:12.000",
        "data": {
            "detail_level": "medium",
            "section_id": "0ed5da4b-0189-4c5e-be85-742c387e4d53",
            "structured_type": "unstructured"
        },
        "event": "mapping_unhover",
        "id": "kvSkP0SpIr0mrVLXam6L"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:20:12.000",
        "data": {
            "before_detail_level": "medium",
            "before_structured": "unstructured",
            "section_id": "0ed5da4b-0189-4c5e-be85-742c387e4d53",
            "after_detail_level": "high",
            "after_structured": "unstructured"
        },
        "event": "change_summary_level",
        "id": "qQdgHHIvozjEwWodfuK0"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:20:13.000",
        "data": {
            "detail_level": "high",
            "section_id": "0ed5da4b-0189-4c5e-be85-742c387e4d53",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "61yy7Ai4akXnjzR8qj58"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:20:13.000",
        "data": {
            "detail_level": "high",
            "section_id": "0ed5da4b-0189-4c5e-be85-742c387e4d53",
            "structured_type": "structured",
            "mapping_index": 0
        },
        "event": "mapping_hover",
        "id": "9mxzQvQ3Mnl8Gs7aU7aN"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:20:13.000",
        "data": {
            "before_detail_level": "high",
            "before_structured": "unstructured",
            "section_id": "0ed5da4b-0189-4c5e-be85-742c387e4d53",
            "after_detail_level": "high",
            "after_structured": "structured"
        },
        "event": "change_summary_level",
        "id": "FreNFJeCYS4XhoqYwuWd"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:20:13.000",
        "data": {
            "detail_level": "high",
            "section_id": "0ed5da4b-0189-4c5e-be85-742c387e4d53",
            "structured_type": "structured",
            "mapping_index": 1
        },
        "event": "mapping_hover",
        "id": "JtnG5xscZnd7CPtgDhdd"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:20:14.000",
        "data": {
            "detail_level": "high",
            "section_id": "0ed5da4b-0189-4c5e-be85-742c387e4d53",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "3MjfbPXBdJhV67XNZ7Vq"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:20:14.000",
        "data": {
            "detail_level": "high",
            "section_id": "0ed5da4b-0189-4c5e-be85-742c387e4d53",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "G8ozav35i3pXSqWjM5Le"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:20:14.000",
        "data": {
            "detail_level": "high",
            "section_id": "0ed5da4b-0189-4c5e-be85-742c387e4d53",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "Gj2sKyOmAQeVg1QOFerl"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:20:14.000",
        "data": {
            "detail_level": "high",
            "section_id": "0ed5da4b-0189-4c5e-be85-742c387e4d53",
            "structured_type": "structured",
            "mapping_index": 2
        },
        "event": "mapping_hover",
        "id": "Y4nMy8hVLnjUqsEyUnqi"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:20:14.000",
        "data": {
            "detail_level": "high",
            "section_id": "0ed5da4b-0189-4c5e-be85-742c387e4d53",
            "structured_type": "structured",
            "mapping_index": 10
        },
        "event": "mapping_hover",
        "id": "YPgvE0zr3fCtlNVEa9tO"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:20:14.000",
        "data": {
            "detail_level": "high",
            "section_id": "0ed5da4b-0189-4c5e-be85-742c387e4d53",
            "structured_type": "structured",
            "mapping_index": 11
        },
        "event": "mapping_hover",
        "id": "exR2UGRzsN1yTruwmAOz"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:20:15.000",
        "data": {
            "detail_level": "high",
            "section_id": "0ed5da4b-0189-4c5e-be85-742c387e4d53",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "3N3QTSoc4786NgWmYfSr"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:20:15.000",
        "data": {
            "detail_level": "high",
            "section_id": "0ed5da4b-0189-4c5e-be85-742c387e4d53",
            "structured_type": "structured",
            "mapping_index": 0
        },
        "event": "mapping_hover",
        "id": "52E7gAp6QZenMXxOzZCT"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:20:15.000",
        "data": {
            "detail_level": "high",
            "section_id": "0ed5da4b-0189-4c5e-be85-742c387e4d53",
            "structured_type": "structured",
            "mapping_index": 1
        },
        "event": "mapping_hover",
        "id": "6bmoyhgfdpAfvmPTdCaf"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:20:15.000",
        "data": {
            "detail_level": "high",
            "section_id": "0ed5da4b-0189-4c5e-be85-742c387e4d53",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "EPuwTaEIIDRKH60reDKK"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:20:15.000",
        "data": {
            "detail_level": "high",
            "section_id": "0ed5da4b-0189-4c5e-be85-742c387e4d53",
            "structured_type": "structured",
            "mapping_index": 5
        },
        "event": "mapping_hover",
        "id": "PegLrsLLG4LDD7OsrSeM"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:20:15.000",
        "data": {
            "detail_level": "high",
            "section_id": "0ed5da4b-0189-4c5e-be85-742c387e4d53",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "kP5sQlfSaXHqwqw7TkwX"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:20:16.000",
        "data": {
            "detail_level": "high",
            "section_id": "0ed5da4b-0189-4c5e-be85-742c387e4d53",
            "structured_type": "structured",
            "mapping_index": 0
        },
        "event": "mapping_hover",
        "id": "LxYasBgFaJbPYQChFOl1"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:20:16.000",
        "data": {
            "detail_level": "high",
            "section_id": "0ed5da4b-0189-4c5e-be85-742c387e4d53",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "rVzHjGiojCsZ43tt0ItC"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:20:17.000",
        "data": {
            "detail_level": "high",
            "section_id": "0ed5da4b-0189-4c5e-be85-742c387e4d53",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "AdNFyzWYjxvq8q29RDKz"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:20:17.000",
        "data": {
            "detail_level": "high",
            "section_id": "0ed5da4b-0189-4c5e-be85-742c387e4d53",
            "structured_type": "structured",
            "mapping_index": 1
        },
        "event": "mapping_hover",
        "id": "LN2R45LdwIRrX7eYwtLP"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:20:17.000",
        "data": {
            "detail_level": "high",
            "section_id": "0ed5da4b-0189-4c5e-be85-742c387e4d53",
            "structured_type": "structured",
            "mapping_index": 2
        },
        "event": "mapping_hover",
        "id": "k2u3NhLKMZ1rQ3UK4OkN"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:20:17.000",
        "data": {
            "detail_level": "high",
            "section_id": "0ed5da4b-0189-4c5e-be85-742c387e4d53",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "uEhA9n6gx0a4D19MXsSG"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:20:18.000",
        "data": {
            "detail_level": "high",
            "section_id": "0ed5da4b-0189-4c5e-be85-742c387e4d53",
            "structured_type": "structured",
            "mapping_index": 3
        },
        "event": "mapping_hover",
        "id": "EKOCeyyvpWhFjWjrZsZ1"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:20:18.000",
        "data": {
            "detail_level": "high",
            "section_id": "0ed5da4b-0189-4c5e-be85-742c387e4d53",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "QI5bhgwWEInxgpG74gXU"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:20:19.000",
        "data": {
            "detail_level": "high",
            "section_id": "0ed5da4b-0189-4c5e-be85-742c387e4d53",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "IL29DGShjRUQJ8d5mGye"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:20:19.000",
        "data": {
            "detail_level": "high",
            "section_id": "0ed5da4b-0189-4c5e-be85-742c387e4d53",
            "structured_type": "structured",
            "mapping_index": 4
        },
        "event": "mapping_hover",
        "id": "TMISn6ZGrzhA63Bbi82d"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:20:20.000",
        "data": {
            "detail_level": "high",
            "section_id": "0ed5da4b-0189-4c5e-be85-742c387e4d53",
            "structured_type": "structured",
            "mapping_index": 5
        },
        "event": "mapping_hover",
        "id": "6XIHBZc3IkU4Af8x6BBo"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:20:20.000",
        "data": {
            "detail_level": "high",
            "section_id": "0ed5da4b-0189-4c5e-be85-742c387e4d53",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "FA6HERPbof2zHaf0nrSj"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:20:20.000",
        "data": {
            "detail_level": "high",
            "section_id": "0ed5da4b-0189-4c5e-be85-742c387e4d53",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "ZUlf9KKVk2ZQadWnLIs6"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:20:21.000",
        "data": {
            "detail_level": "high",
            "section_id": "0ed5da4b-0189-4c5e-be85-742c387e4d53",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "69AlhwuaFuvP5jTTO5yt"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:20:21.000",
        "data": {
            "detail_level": "high",
            "section_id": "0ed5da4b-0189-4c5e-be85-742c387e4d53",
            "structured_type": "structured",
            "mapping_index": 6
        },
        "event": "mapping_hover",
        "id": "RogedwkiqU9Yk3wQHxQ5"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:20:22.000",
        "data": {
            "detail_level": "high",
            "section_id": "0ed5da4b-0189-4c5e-be85-742c387e4d53",
            "structured_type": "structured",
            "mapping_index": 11
        },
        "event": "mapping_hover",
        "id": "RU3GGlcmJFKi5EYyfpUD"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:20:22.000",
        "data": {
            "detail_level": "high",
            "section_id": "0ed5da4b-0189-4c5e-be85-742c387e4d53",
            "structured_type": "structured",
            "mapping_index": 11
        },
        "event": "mapping_hover",
        "id": "g04GnBnbJUnuwui9DPxq"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:20:22.000",
        "data": {
            "detail_level": "high",
            "section_id": "0ed5da4b-0189-4c5e-be85-742c387e4d53",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "kHJFxoFAIkjQ4DGejwJm"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:20:22.000",
        "data": {
            "detail_level": "high",
            "section_id": "0ed5da4b-0189-4c5e-be85-742c387e4d53",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "vtVgoL5X6RlfU5bWQ3Uy"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:20:24.000",
        "data": {
            "detail_level": "high",
            "section_id": "0ed5da4b-0189-4c5e-be85-742c387e4d53",
            "structured_type": "structured",
            "mapping_index": 0
        },
        "event": "mapping_hover",
        "id": "3iVGdYRFKi7FHTuGixLC"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:20:24.000",
        "data": {
            "detail_level": "high",
            "section_id": "0ed5da4b-0189-4c5e-be85-742c387e4d53",
            "structured_type": "structured",
            "mapping_index": 3
        },
        "event": "mapping_hover",
        "id": "5QyeJ8eiNeCG1vapNKus"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:20:24.000",
        "data": {
            "detail_level": "high",
            "section_id": "0ed5da4b-0189-4c5e-be85-742c387e4d53",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "5t6LebuXYWt7RzIaCVK7"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:20:24.000",
        "data": {
            "detail_level": "high",
            "section_id": "0ed5da4b-0189-4c5e-be85-742c387e4d53",
            "structured_type": "structured",
            "mapping_index": 2
        },
        "event": "mapping_hover",
        "id": "IeRduU0dkExN0TmSNcRH"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:20:24.000",
        "data": {
            "detail_level": "high",
            "section_id": "0ed5da4b-0189-4c5e-be85-742c387e4d53",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "Z71hYEAuyYlQo2NRLWdO"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:20:24.000",
        "data": {
            "detail_level": "high",
            "section_id": "0ed5da4b-0189-4c5e-be85-742c387e4d53",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "dH4VdFUxsTCySdkm51yL"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:20:24.000",
        "data": {
            "detail_level": "high",
            "section_id": "0ed5da4b-0189-4c5e-be85-742c387e4d53",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "iIju5qXdxEuIVXt1aji3"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:20:24.000",
        "data": {
            "detail_level": "high",
            "section_id": "0ed5da4b-0189-4c5e-be85-742c387e4d53",
            "structured_type": "structured",
            "mapping_index": 1
        },
        "event": "mapping_hover",
        "id": "iMbxx1ReiI4cCllLY84H"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:20:24.000",
        "data": {
            "detail_level": "high",
            "section_id": "0ed5da4b-0189-4c5e-be85-742c387e4d53",
            "structured_type": "structured",
            "mapping_index": 3
        },
        "event": "mapping_hover",
        "id": "oFHzoLoomrjNV48f7cmb"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:20:24.000",
        "data": {
            "detail_level": "high",
            "section_id": "0ed5da4b-0189-4c5e-be85-742c387e4d53",
            "structured_type": "structured",
            "mapping_index": 4
        },
        "event": "mapping_hover",
        "id": "rEU83iQl8oHgaCQ0esNa"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:20:24.000",
        "data": {
            "detail_level": "high",
            "section_id": "0ed5da4b-0189-4c5e-be85-742c387e4d53",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "vOCVflP9EZxZfi6iJyt7"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:20:25.000",
        "data": {
            "detail_level": "high",
            "section_id": "0ed5da4b-0189-4c5e-be85-742c387e4d53",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "39KWJg6HwCcNUGK4RtVB"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:20:25.000",
        "data": {
            "detail_level": "high",
            "section_id": "0ed5da4b-0189-4c5e-be85-742c387e4d53",
            "structured_type": "structured",
            "mapping_index": 4
        },
        "event": "mapping_hover",
        "id": "AJaJKoR75TNcQpLST77Z"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:20:25.000",
        "data": {
            "detail_level": "high",
            "section_id": "0ed5da4b-0189-4c5e-be85-742c387e4d53",
            "structured_type": "structured",
            "mapping_index": 3
        },
        "event": "mapping_hover",
        "id": "K5OzXlK5KxHm9PX2pq0x"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:20:25.000",
        "data": {
            "detail_level": "high",
            "section_id": "0ed5da4b-0189-4c5e-be85-742c387e4d53",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "PEY3iSEH56CEtd4Q96FR"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:20:25.000",
        "data": {
            "detail_level": "high",
            "section_id": "0ed5da4b-0189-4c5e-be85-742c387e4d53",
            "structured_type": "structured",
            "mapping_index": 0
        },
        "event": "mapping_hover",
        "id": "S4k4ef9h8DSG1Q4ongGz"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:20:25.000",
        "data": {
            "detail_level": "high",
            "section_id": "0ed5da4b-0189-4c5e-be85-742c387e4d53",
            "structured_type": "structured",
            "mapping_index": 2
        },
        "event": "mapping_hover",
        "id": "WRvmOkwL3TpdDxIQEniM"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:20:25.000",
        "data": {
            "detail_level": "high",
            "section_id": "0ed5da4b-0189-4c5e-be85-742c387e4d53",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "Y8rGTehBBezpj4RA2x0b"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:20:25.000",
        "data": {
            "detail_level": "high",
            "section_id": "0ed5da4b-0189-4c5e-be85-742c387e4d53",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "e84cFEExZMwlZOa4MpVk"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:20:25.000",
        "data": {
            "detail_level": "high",
            "section_id": "0ed5da4b-0189-4c5e-be85-742c387e4d53",
            "structured_type": "structured",
            "mapping_index": 1
        },
        "event": "mapping_hover",
        "id": "faTKs2zFwfzWPGHcVLvH"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:20:25.000",
        "data": {
            "detail_level": "high",
            "section_id": "0ed5da4b-0189-4c5e-be85-742c387e4d53",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "kCvGXpfikQHgUqWCjSmE"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:20:25.000",
        "data": {
            "detail_level": "high",
            "section_id": "0ed5da4b-0189-4c5e-be85-742c387e4d53",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "oz6XNgt9c0AtLGn85u3d"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:20:25.000",
        "data": {
            "detail_level": "high",
            "section_id": "0ed5da4b-0189-4c5e-be85-742c387e4d53",
            "structured_type": "structured",
            "mapping_index": 5
        },
        "event": "mapping_hover",
        "id": "vI0NYsA4KaUApt1pSaIt"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:20:25.000",
        "data": {
            "detail_level": "high",
            "section_id": "0ed5da4b-0189-4c5e-be85-742c387e4d53",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "yomkEkAf2oigpfBxX9jE"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:20:26.000",
        "data": {
            "detail_level": "high",
            "section_id": "0ed5da4b-0189-4c5e-be85-742c387e4d53",
            "structured_type": "structured",
            "mapping_index": 3
        },
        "event": "mapping_hover",
        "id": "1ujpC1wpXlVLrLToeoDm"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:20:26.000",
        "data": {
            "detail_level": "high",
            "section_id": "0ed5da4b-0189-4c5e-be85-742c387e4d53",
            "structured_type": "structured",
            "mapping_index": 2
        },
        "event": "mapping_hover",
        "id": "Pdtor5pGzWLuRM8tDpyH"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:20:26.000",
        "data": {
            "detail_level": "high",
            "section_id": "0ed5da4b-0189-4c5e-be85-742c387e4d53",
            "structured_type": "structured",
            "mapping_index": 1
        },
        "event": "mapping_hover",
        "id": "SjMtP08ph1nv6QdOxTlg"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:20:26.000",
        "data": {
            "detail_level": "high",
            "section_id": "0ed5da4b-0189-4c5e-be85-742c387e4d53",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "Uh8ax7rH7s6FekJt9gNg"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:20:26.000",
        "data": {
            "detail_level": "high",
            "section_id": "0ed5da4b-0189-4c5e-be85-742c387e4d53",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "gGxJhIdxVmMX1aXpWlcm"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:20:26.000",
        "data": {
            "detail_level": "high",
            "section_id": "0ed5da4b-0189-4c5e-be85-742c387e4d53",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "i791Bw941ITm2BW9JkgD"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:20:26.000",
        "data": {
            "detail_level": "high",
            "section_id": "0ed5da4b-0189-4c5e-be85-742c387e4d53",
            "structured_type": "structured",
            "mapping_index": 2
        },
        "event": "mapping_hover",
        "id": "vB75TVkLRsSueMN7MVv2"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:20:27.000",
        "data": {
            "detail_level": "high",
            "section_id": "0ed5da4b-0189-4c5e-be85-742c387e4d53",
            "structured_type": "structured",
            "mapping_index": 0
        },
        "event": "mapping_hover",
        "id": "E7ziBiA5Q167Jon8iVH1"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:20:27.000",
        "data": {
            "detail_level": "high",
            "section_id": "0ed5da4b-0189-4c5e-be85-742c387e4d53",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "sSmw4S76pIcVyrxf803S"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:20:28.000",
        "data": {
            "detail_level": "high",
            "section_id": "0ed5da4b-0189-4c5e-be85-742c387e4d53",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "KSas2x8mepbYnv8KeO4i"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:20:28.000",
        "data": {
            "detail_level": "high",
            "section_id": "0ed5da4b-0189-4c5e-be85-742c387e4d53",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "QjwYtkI6go3XNYJt5iyF"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:20:28.000",
        "data": {
            "detail_level": "high",
            "section_id": "0ed5da4b-0189-4c5e-be85-742c387e4d53",
            "structured_type": "structured",
            "mapping_index": 1
        },
        "event": "mapping_hover",
        "id": "gQAOL7Bpk5bIMAPXOwFy"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:20:28.000",
        "data": {
            "detail_level": "high",
            "section_id": "0ed5da4b-0189-4c5e-be85-742c387e4d53",
            "structured_type": "structured",
            "mapping_index": 1
        },
        "event": "mapping_hover",
        "id": "mtp8AYNY9cW3ypJoJ3uP"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:20:28.000",
        "data": {
            "detail_level": "high",
            "section_id": "0ed5da4b-0189-4c5e-be85-742c387e4d53",
            "structured_type": "structured",
            "mapping_index": 2
        },
        "event": "mapping_hover",
        "id": "u162mnS0tz42k9M4qdCc"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:20:28.000",
        "data": {
            "detail_level": "high",
            "section_id": "0ed5da4b-0189-4c5e-be85-742c387e4d53",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "vsH69zMskOvnpptwcnkp"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:20:29.000",
        "data": {
            "detail_level": "high",
            "section_id": "0ed5da4b-0189-4c5e-be85-742c387e4d53",
            "structured_type": "structured",
            "mapping_index": 2
        },
        "event": "mapping_hover",
        "id": "9OLgCvKUl55nAoIdus6g"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:20:29.000",
        "data": {
            "detail_level": "high",
            "section_id": "0ed5da4b-0189-4c5e-be85-742c387e4d53",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "CcEoTLZ2wS2wWhEtevdP"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:20:29.000",
        "data": {
            "detail_level": "high",
            "section_id": "0ed5da4b-0189-4c5e-be85-742c387e4d53",
            "structured_type": "structured",
            "mapping_index": 3
        },
        "event": "mapping_hover",
        "id": "EYnXrp5wZBqRDKy3fTag"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:20:29.000",
        "data": {
            "detail_level": "high",
            "section_id": "0ed5da4b-0189-4c5e-be85-742c387e4d53",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "MUJGOc3t8QhPUNd2NTd9"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:20:29.000",
        "data": {
            "detail_level": "high",
            "section_id": "0ed5da4b-0189-4c5e-be85-742c387e4d53",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "flSxkG5nUyvT9OvxaOX0"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:20:29.000",
        "data": {
            "detail_level": "high",
            "section_id": "0ed5da4b-0189-4c5e-be85-742c387e4d53",
            "structured_type": "structured",
            "mapping_index": 4
        },
        "event": "mapping_hover",
        "id": "uCd0X6UL11pL0WXlQ0JI"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:20:30.000",
        "data": {
            "detail_level": "high",
            "section_id": "0ed5da4b-0189-4c5e-be85-742c387e4d53",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "8e84xKJFr7R42xZ2vO07"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:20:30.000",
        "data": {
            "detail_level": "high",
            "section_id": "0ed5da4b-0189-4c5e-be85-742c387e4d53",
            "structured_type": "structured",
            "mapping_index": 5
        },
        "event": "mapping_hover",
        "id": "n5r4lwDS4uB5tgktKPjc"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:20:31.000",
        "data": {
            "detail_level": "high",
            "section_id": "0ed5da4b-0189-4c5e-be85-742c387e4d53",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "M7M4QHhK1zFhuUv9VoP4"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:20:31.000",
        "data": {
            "detail_level": "high",
            "section_id": "0ed5da4b-0189-4c5e-be85-742c387e4d53",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "hpv6qjoeMlM7NZ8MGa57"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:20:31.000",
        "data": {
            "detail_level": "high",
            "section_id": "0ed5da4b-0189-4c5e-be85-742c387e4d53",
            "structured_type": "structured",
            "mapping_index": 2
        },
        "event": "mapping_hover",
        "id": "r4km8Ggl5Rxo2OzxtnFL"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:20:31.000",
        "data": {
            "detail_level": "high",
            "section_id": "0ed5da4b-0189-4c5e-be85-742c387e4d53",
            "structured_type": "structured",
            "mapping_index": 3
        },
        "event": "mapping_hover",
        "id": "topWWaf5dLVg8WkedoxM"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:20:31.000",
        "data": {
            "detail_level": "high",
            "section_id": "0ed5da4b-0189-4c5e-be85-742c387e4d53",
            "structured_type": "structured",
            "mapping_index": 4
        },
        "event": "mapping_hover",
        "id": "wA3nBNOFbsiwCr9hffz5"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:20:31.000",
        "data": {
            "detail_level": "high",
            "section_id": "0ed5da4b-0189-4c5e-be85-742c387e4d53",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "xwkY1eTxVUi8akg4Qq9A"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:20:32.000",
        "data": {
            "detail_level": "high",
            "section_id": "0ed5da4b-0189-4c5e-be85-742c387e4d53",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "4cxbJGlTc9bPEe3rmA62"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:20:32.000",
        "data": {
            "detail_level": "high",
            "section_id": "0ed5da4b-0189-4c5e-be85-742c387e4d53",
            "structured_type": "structured",
            "mapping_index": 0
        },
        "event": "mapping_hover",
        "id": "aurnT2Ke1AZ4dJBnrpxy"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:20:32.000",
        "data": {
            "detail_level": "high",
            "section_id": "0ed5da4b-0189-4c5e-be85-742c387e4d53",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "hglsUoKK1ZINTNTCsMtI"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:20:32.000",
        "data": {
            "detail_level": "high",
            "section_id": "0ed5da4b-0189-4c5e-be85-742c387e4d53",
            "structured_type": "structured",
            "mapping_index": 1
        },
        "event": "mapping_hover",
        "id": "mK3vehYhDl200rMDwiIc"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:20:33.000",
        "data": {
            "detail_level": "high",
            "section_id": "0ed5da4b-0189-4c5e-be85-742c387e4d53",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "1VmYJnOBRyzunkltV5za"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:20:33.000",
        "data": {
            "detail_level": "high",
            "section_id": "0ed5da4b-0189-4c5e-be85-742c387e4d53",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "MlgLatineVM5DQLxEMPi"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:20:33.000",
        "data": {
            "detail_level": "high",
            "section_id": "0ed5da4b-0189-4c5e-be85-742c387e4d53",
            "structured_type": "structured",
            "mapping_index": 2
        },
        "event": "mapping_hover",
        "id": "UiTcF3lNOvqWQPN2YlqV"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:20:33.000",
        "data": {
            "detail_level": "high",
            "section_id": "0ed5da4b-0189-4c5e-be85-742c387e4d53",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "ctvicP541TKbH7keEH30"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:20:33.000",
        "data": {
            "detail_level": "high",
            "section_id": "0ed5da4b-0189-4c5e-be85-742c387e4d53",
            "structured_type": "structured",
            "mapping_index": 1
        },
        "event": "mapping_hover",
        "id": "kv3uVW17RBLCbkoROOyV"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:20:33.000",
        "data": {
            "detail_level": "high",
            "section_id": "0ed5da4b-0189-4c5e-be85-742c387e4d53",
            "structured_type": "structured",
            "mapping_index": 3
        },
        "event": "mapping_hover",
        "id": "mMs6BlroRi7Z45m6bo9n"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:20:34.000",
        "data": {
            "detail_level": "high",
            "section_id": "0ed5da4b-0189-4c5e-be85-742c387e4d53",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "GKR5KqK0uBdvojVEsS8g"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:20:34.000",
        "data": {
            "detail_level": "high",
            "section_id": "0ed5da4b-0189-4c5e-be85-742c387e4d53",
            "structured_type": "structured",
            "mapping_index": 2
        },
        "event": "mapping_hover",
        "id": "wEIjdlCDJJWSKgykdxcT"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:20:35.000",
        "data": {
            "detail_level": "high",
            "section_id": "0ed5da4b-0189-4c5e-be85-742c387e4d53",
            "structured_type": "structured",
            "mapping_index": 1
        },
        "event": "mapping_hover",
        "id": "3Xlw4uZWQh1bysc0ODJ9"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:20:35.000",
        "data": {
            "detail_level": "high",
            "section_id": "0ed5da4b-0189-4c5e-be85-742c387e4d53",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "FVqk2hJwbDKTXef8RbAC"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:20:37.000",
        "data": {
            "detail_level": "high",
            "section_id": "0ed5da4b-0189-4c5e-be85-742c387e4d53",
            "structured_type": "structured",
            "mapping_index": 2
        },
        "event": "mapping_hover",
        "id": "G0oa0BKoyIUZCpMJ7Zv4"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:20:37.000",
        "data": {
            "detail_level": "high",
            "section_id": "0ed5da4b-0189-4c5e-be85-742c387e4d53",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "daUYY5VDry8anzCaOwXu"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:20:39.000",
        "data": {
            "detail_level": "high",
            "section_id": "0ed5da4b-0189-4c5e-be85-742c387e4d53",
            "structured_type": "structured",
            "mapping_index": 3
        },
        "event": "mapping_hover",
        "id": "2n3kb1htwvBP8x9Moryd"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:20:39.000",
        "data": {
            "detail_level": "high",
            "section_id": "0ed5da4b-0189-4c5e-be85-742c387e4d53",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "M0MHlhgZ14v6D2NGc3Hc"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:20:39.000",
        "data": {
            "detail_level": "high",
            "section_id": "0ed5da4b-0189-4c5e-be85-742c387e4d53",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "ZPDyE2MXW7Ye7mvHPQCb"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:20:39.000",
        "data": {
            "detail_level": "high",
            "section_id": "0ed5da4b-0189-4c5e-be85-742c387e4d53",
            "structured_type": "structured",
            "mapping_index": 4
        },
        "event": "mapping_hover",
        "id": "rCruK5SRADBkEnU0OEqJ"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:20:41.000",
        "data": {
            "detail_level": "high",
            "section_id": "0ed5da4b-0189-4c5e-be85-742c387e4d53",
            "structured_type": "structured",
            "mapping_index": 5
        },
        "event": "mapping_hover",
        "id": "gpYd1ttuRxh84QCpHsqF"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:20:41.000",
        "data": {
            "detail_level": "high",
            "section_id": "0ed5da4b-0189-4c5e-be85-742c387e4d53",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "hlQD36T4G25RiivELcZN"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:20:44.000",
        "data": {
            "detail_level": "high",
            "section_id": "0ed5da4b-0189-4c5e-be85-742c387e4d53",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "YImxPXZ3M8fByKbyWBdO"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:20:46.000",
        "data": {
            "detail_level": "high",
            "section_id": "0ed5da4b-0189-4c5e-be85-742c387e4d53",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "8J8eOL2z0LVz0Ip0kj35"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:20:46.000",
        "data": {
            "detail_level": "high",
            "section_id": "0ed5da4b-0189-4c5e-be85-742c387e4d53",
            "structured_type": "structured",
            "mapping_index": 6
        },
        "event": "mapping_hover",
        "id": "PASDCKi4KFOixIwZaK7B"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:20:46.000",
        "data": {
            "detail_level": "high",
            "section_id": "0ed5da4b-0189-4c5e-be85-742c387e4d53",
            "structured_type": "structured",
            "mapping_index": 4
        },
        "event": "mapping_hover",
        "id": "ULPh5o4vVZsj7ZxQyQUX"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:20:46.000",
        "data": {
            "detail_level": "high",
            "section_id": "0ed5da4b-0189-4c5e-be85-742c387e4d53",
            "structured_type": "structured",
            "mapping_index": 5
        },
        "event": "mapping_hover",
        "id": "UPaUdGYKoeRgIxaxI8Zf"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:20:46.000",
        "data": {
            "detail_level": "high",
            "section_id": "0ed5da4b-0189-4c5e-be85-742c387e4d53",
            "structured_type": "structured",
            "mapping_index": 5
        },
        "event": "mapping_hover",
        "id": "aKR46eYquJ4vgb0W0r8J"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:20:46.000",
        "data": {
            "detail_level": "high",
            "section_id": "0ed5da4b-0189-4c5e-be85-742c387e4d53",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "wS3slsVkSahiKvNoq0di"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:20:46.000",
        "data": {
            "detail_level": "high",
            "section_id": "0ed5da4b-0189-4c5e-be85-742c387e4d53",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "zAmr4GI2vXUFisfqrrHZ"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:20:48.000",
        "data": {
            "detail_level": "high",
            "section_id": "0ed5da4b-0189-4c5e-be85-742c387e4d53",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "eUWUHeZ3TxVPdcGWbrLu"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:20:51.000",
        "data": {
            "detail_level": "high",
            "section_id": "0ed5da4b-0189-4c5e-be85-742c387e4d53",
            "structured_type": "structured",
            "mapping_index": 5
        },
        "event": "mapping_hover",
        "id": "JwW5snohbEYeViqKeb5z"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:20:52.000",
        "data": {
            "detail_level": "high",
            "section_id": "0ed5da4b-0189-4c5e-be85-742c387e4d53",
            "structured_type": "structured",
            "mapping_index": 6
        },
        "event": "mapping_hover",
        "id": "BQ6FqlO5jgqDzavKj9Ed"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:20:52.000",
        "data": {
            "detail_level": "high",
            "section_id": "0ed5da4b-0189-4c5e-be85-742c387e4d53",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "C5hp8hXInONLHXmnU89R"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:20:52.000",
        "data": {
            "detail_level": "high",
            "section_id": "0ed5da4b-0189-4c5e-be85-742c387e4d53",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "aUJtoKWmzJTOP9msk3GA"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:20:52.000",
        "data": {
            "detail_level": "high",
            "section_id": "0ed5da4b-0189-4c5e-be85-742c387e4d53",
            "structured_type": "structured",
            "mapping_index": 7
        },
        "event": "mapping_hover",
        "id": "sgqG2d0FwNNJRAtg9DJz"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:20:53.000",
        "data": {
            "detail_level": "high",
            "section_id": "0ed5da4b-0189-4c5e-be85-742c387e4d53",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "0cSAXZR0Mr4dMYjIkrIQ"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:20:53.000",
        "data": {
            "detail_level": "high",
            "section_id": "0ed5da4b-0189-4c5e-be85-742c387e4d53",
            "structured_type": "structured",
            "mapping_index": 6
        },
        "event": "mapping_hover",
        "id": "NvNfcWFUcHNmVYr4j0k6"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:20:58.000",
        "data": {
            "detail_level": "high",
            "section_id": "0ed5da4b-0189-4c5e-be85-742c387e4d53",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "2mZ8K5DJN59JP8eeBxOs"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:20:58.000",
        "data": {
            "detail_level": "high",
            "section_id": "0ed5da4b-0189-4c5e-be85-742c387e4d53",
            "structured_type": "structured",
            "mapping_index": 11
        },
        "event": "mapping_hover",
        "id": "8Td8J1zjtypMaUSPQr4v"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:20:58.000",
        "data": {
            "detail_level": "high",
            "section_id": "0ed5da4b-0189-4c5e-be85-742c387e4d53",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "E7RMzrBhypUaCl748m1A"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:20:58.000",
        "data": {
            "detail_level": "high",
            "section_id": "0ed5da4b-0189-4c5e-be85-742c387e4d53",
            "structured_type": "structured",
            "mapping_index": 8
        },
        "event": "mapping_hover",
        "id": "EQjW2zRBKnX8OE9Zj76Y"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:20:58.000",
        "data": {
            "detail_level": "high",
            "section_id": "0ed5da4b-0189-4c5e-be85-742c387e4d53",
            "structured_type": "structured",
            "mapping_index": 9
        },
        "event": "mapping_hover",
        "id": "H2T2olidj3PYGiZ2hau1"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:20:58.000",
        "data": {
            "detail_level": "high",
            "section_id": "0ed5da4b-0189-4c5e-be85-742c387e4d53",
            "structured_type": "structured",
            "mapping_index": 10
        },
        "event": "mapping_hover",
        "id": "gZqcdTmsX77LY5iFSJt7"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:20:58.000",
        "data": {
            "detail_level": "high",
            "section_id": "0ed5da4b-0189-4c5e-be85-742c387e4d53",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "nCuhHwXoumj0WbuTeEfQ"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:20:58.000",
        "data": {
            "detail_level": "high",
            "section_id": "0ed5da4b-0189-4c5e-be85-742c387e4d53",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "rzd4ptOFR2hTTyhqxDnQ"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:20:59.000",
        "data": {
            "detail_level": "high",
            "section_id": "0ed5da4b-0189-4c5e-be85-742c387e4d53",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "30m4JritLDh2hKRrQ0sF"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:20:59.000",
        "data": {
            "detail_level": "high",
            "section_id": "0ed5da4b-0189-4c5e-be85-742c387e4d53",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "6kBp9u1p5hMxMw51yqVs"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:20:59.000",
        "data": {
            "detail_level": "high",
            "section_id": "0ed5da4b-0189-4c5e-be85-742c387e4d53",
            "structured_type": "structured",
            "mapping_index": 10
        },
        "event": "mapping_hover",
        "id": "Suc7ToXKSdcvZGLOXfnJ"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:20:59.000",
        "data": {
            "detail_level": "high",
            "section_id": "0ed5da4b-0189-4c5e-be85-742c387e4d53",
            "structured_type": "structured",
            "mapping_index": 9
        },
        "event": "mapping_hover",
        "id": "T4GwRjH4EpP9IdjZbwTJ"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:20:59.000",
        "data": {
            "detail_level": "high",
            "section_id": "0ed5da4b-0189-4c5e-be85-742c387e4d53",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "iHOQ1JCw5iCTffaodJdl"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:21:00.000",
        "data": {
            "detail_level": "high",
            "section_id": "0ed5da4b-0189-4c5e-be85-742c387e4d53",
            "structured_type": "structured",
            "mapping_index": 10
        },
        "event": "mapping_hover",
        "id": "3oKFlnBxcP9oU1P2DZIA"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:21:00.000",
        "data": {
            "detail_level": "high",
            "section_id": "0ed5da4b-0189-4c5e-be85-742c387e4d53",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "9CkWl76j6AXLUG9KkpoO"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:21:00.000",
        "data": {
            "detail_level": "high",
            "section_id": "0ed5da4b-0189-4c5e-be85-742c387e4d53",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "G3YotjaX0bxNJoHmyzdb"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:21:00.000",
        "data": {
            "detail_level": "high",
            "section_id": "0ed5da4b-0189-4c5e-be85-742c387e4d53",
            "structured_type": "structured",
            "mapping_index": 9
        },
        "event": "mapping_hover",
        "id": "KIWoGEU2PEfi0EBRo7C0"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:21:00.000",
        "data": {
            "detail_level": "high",
            "section_id": "0ed5da4b-0189-4c5e-be85-742c387e4d53",
            "structured_type": "structured",
            "mapping_index": 9
        },
        "event": "mapping_hover",
        "id": "LJvILZEJoTqVQcQwyUBr"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:21:00.000",
        "data": {
            "detail_level": "high",
            "section_id": "0ed5da4b-0189-4c5e-be85-742c387e4d53",
            "structured_type": "structured",
            "mapping_index": 8
        },
        "event": "mapping_hover",
        "id": "NtBFOnSbeJHlk0b3APzf"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:21:00.000",
        "data": {
            "detail_level": "high",
            "section_id": "0ed5da4b-0189-4c5e-be85-742c387e4d53",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "TaiD0tILLo5t83OddZhH"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:21:00.000",
        "data": {
            "detail_level": "high",
            "section_id": "0ed5da4b-0189-4c5e-be85-742c387e4d53",
            "structured_type": "structured",
            "mapping_index": 10
        },
        "event": "mapping_hover",
        "id": "UIe8FlO8AJ2Oy8iEdxhh"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:21:00.000",
        "data": {
            "detail_level": "high",
            "section_id": "0ed5da4b-0189-4c5e-be85-742c387e4d53",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "h1WRPDK1JuRSxmfKPJyh"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:21:00.000",
        "data": {
            "detail_level": "high",
            "section_id": "0ed5da4b-0189-4c5e-be85-742c387e4d53",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "rCktQAKacJJDOc0opXc7"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:21:01.000",
        "data": {
            "detail_level": "high",
            "section_id": "0ed5da4b-0189-4c5e-be85-742c387e4d53",
            "structured_type": "structured",
            "mapping_index": 9
        },
        "event": "mapping_hover",
        "id": "5LC5OazlGyoUWJkgzkNG"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:21:01.000",
        "data": {
            "detail_level": "high",
            "section_id": "0ed5da4b-0189-4c5e-be85-742c387e4d53",
            "structured_type": "structured",
            "mapping_index": 8
        },
        "event": "mapping_hover",
        "id": "CAXe09R1qiNTUmMIP32p"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:21:01.000",
        "data": {
            "detail_level": "high",
            "section_id": "0ed5da4b-0189-4c5e-be85-742c387e4d53",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "HDW0Hp6Dov4mZlk8pDgY"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:21:01.000",
        "data": {
            "detail_level": "high",
            "section_id": "0ed5da4b-0189-4c5e-be85-742c387e4d53",
            "structured_type": "structured",
            "mapping_index": 9
        },
        "event": "mapping_hover",
        "id": "N6EVL6bcY6WQOnRcIQHp"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:21:01.000",
        "data": {
            "detail_level": "high",
            "section_id": "0ed5da4b-0189-4c5e-be85-742c387e4d53",
            "structured_type": "structured",
            "mapping_index": 10
        },
        "event": "mapping_hover",
        "id": "Piv7ysxYGdQnFDGDjfxJ"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:21:01.000",
        "data": {
            "detail_level": "high",
            "section_id": "0ed5da4b-0189-4c5e-be85-742c387e4d53",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "oryMIjn1TP0JxEuja5ay"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:21:01.000",
        "data": {
            "detail_level": "high",
            "section_id": "0ed5da4b-0189-4c5e-be85-742c387e4d53",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "qJkmoGaAe8PhpvIgvLR5"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:21:01.000",
        "data": {
            "detail_level": "high",
            "section_id": "0ed5da4b-0189-4c5e-be85-742c387e4d53",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "taoNdjEsHgZydZ2KINaT"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:21:01.000",
        "data": {
            "detail_level": "high",
            "section_id": "0ed5da4b-0189-4c5e-be85-742c387e4d53",
            "structured_type": "structured",
            "mapping_index": 10
        },
        "event": "mapping_hover",
        "id": "tpM8Pu7rccEskQdSn0lY"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:21:02.000",
        "data": {
            "detail_level": "high",
            "section_id": "0ed5da4b-0189-4c5e-be85-742c387e4d53",
            "structured_type": "structured",
            "mapping_index": 11
        },
        "event": "mapping_hover",
        "id": "JmSlZdmXT6nASa9Cfqz0"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:21:02.000",
        "data": {
            "detail_level": "high",
            "section_id": "0ed5da4b-0189-4c5e-be85-742c387e4d53",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "dUDFcX0uN1vjM0RquVZG"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:21:03.000",
        "data": {
            "detail_level": "high",
            "section_id": "0ed5da4b-0189-4c5e-be85-742c387e4d53",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "1cnCIgkASbKQrIcxoOo5"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:21:03.000",
        "data": {
            "detail_level": "high",
            "section_id": "0ed5da4b-0189-4c5e-be85-742c387e4d53",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "56vky9VxhYDP3VF2mrEL"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:21:03.000",
        "data": {
            "detail_level": "high",
            "section_id": "0ed5da4b-0189-4c5e-be85-742c387e4d53",
            "structured_type": "structured",
            "mapping_index": 10
        },
        "event": "mapping_hover",
        "id": "JnidgpweiOinWxEOU2id"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:21:03.000",
        "data": {
            "detail_level": "high",
            "section_id": "0ed5da4b-0189-4c5e-be85-742c387e4d53",
            "structured_type": "structured",
            "mapping_index": 9
        },
        "event": "mapping_hover",
        "id": "eWSnjY882W56LySmMoSo"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:21:03.000",
        "data": {
            "detail_level": "high",
            "section_id": "0ed5da4b-0189-4c5e-be85-742c387e4d53",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "mQxNZnkAE3DXapmflt9x"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:21:23.000",
        "data": {
            "detail_level": "high",
            "section_id": "0ed5da4b-0189-4c5e-be85-742c387e4d53",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "2VvuwSisjxcTFxBG2Gy0"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:21:23.000",
        "data": {
            "detail_level": "high",
            "section_id": "0ed5da4b-0189-4c5e-be85-742c387e4d53",
            "structured_type": "structured",
            "mapping_index": 7
        },
        "event": "mapping_hover",
        "id": "2XTCQy7EWPWlxV1tSXHr"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:21:23.000",
        "data": {
            "detail_level": "high",
            "section_id": "0ed5da4b-0189-4c5e-be85-742c387e4d53",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "4pQ69ZSgO4IOBFRoB4ty"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:21:23.000",
        "data": {
            "detail_level": "high",
            "section_id": "0ed5da4b-0189-4c5e-be85-742c387e4d53",
            "structured_type": "structured",
            "mapping_index": 10
        },
        "event": "mapping_hover",
        "id": "DI59rt9UwWlliw4lPOe9"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:21:23.000",
        "data": {
            "detail_level": "high",
            "section_id": "0ed5da4b-0189-4c5e-be85-742c387e4d53",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "FaC7NlfnCKbWDXb03vO8"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:21:23.000",
        "data": {
            "detail_level": "high",
            "section_id": "0ed5da4b-0189-4c5e-be85-742c387e4d53",
            "structured_type": "structured",
            "mapping_index": 2
        },
        "event": "mapping_hover",
        "id": "HSHMeFGNmMsa9dhw2DWd"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:21:23.000",
        "data": {
            "detail_level": "high",
            "section_id": "0ed5da4b-0189-4c5e-be85-742c387e4d53",
            "structured_type": "structured",
            "mapping_index": 11
        },
        "event": "mapping_hover",
        "id": "IzOJRygEPCxB65AcDMFH"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:21:23.000",
        "data": {
            "detail_level": "high",
            "section_id": "0ed5da4b-0189-4c5e-be85-742c387e4d53",
            "structured_type": "structured",
            "mapping_index": 5
        },
        "event": "mapping_hover",
        "id": "KXaIKVIuw2TaryZcWHEl"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:21:23.000",
        "data": {
            "detail_level": "high",
            "section_id": "0ed5da4b-0189-4c5e-be85-742c387e4d53",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "Kn26BfYpJYVsBo5bVuD5"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:21:23.000",
        "data": {
            "detail_level": "high",
            "section_id": "0ed5da4b-0189-4c5e-be85-742c387e4d53",
            "structured_type": "structured",
            "mapping_index": 9
        },
        "event": "mapping_hover",
        "id": "N7OzB3XUjdDwLkb55FJF"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:21:23.000",
        "data": {
            "detail_level": "high",
            "section_id": "0ed5da4b-0189-4c5e-be85-742c387e4d53",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "YiDwtG9QT0XKsyRGyEsn"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:21:23.000",
        "data": {
            "detail_level": "high",
            "section_id": "0ed5da4b-0189-4c5e-be85-742c387e4d53",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "ZIKUgRxmp1WQoCCWYCcR"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:21:23.000",
        "data": {
            "detail_level": "high",
            "section_id": "0ed5da4b-0189-4c5e-be85-742c387e4d53",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "cCxKPV8ewagyHD6vxJwN"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:21:23.000",
        "data": {
            "detail_level": "high",
            "section_id": "0ed5da4b-0189-4c5e-be85-742c387e4d53",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "cDXlN16y1z0MYAQzTI4f"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:21:23.000",
        "data": {
            "detail_level": "high",
            "section_id": "0ed5da4b-0189-4c5e-be85-742c387e4d53",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "dTQIhxx3uV3s47v5PI5h"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:21:23.000",
        "data": {
            "detail_level": "high",
            "section_id": "0ed5da4b-0189-4c5e-be85-742c387e4d53",
            "structured_type": "structured",
            "mapping_index": 1
        },
        "event": "mapping_hover",
        "id": "eTwIIzaj27NvZBAgrR01"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:21:23.000",
        "data": {
            "detail_level": "high",
            "section_id": "0ed5da4b-0189-4c5e-be85-742c387e4d53",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "irKvXjA1ucUycH2YgSJI"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:21:23.000",
        "data": {
            "detail_level": "high",
            "section_id": "0ed5da4b-0189-4c5e-be85-742c387e4d53",
            "structured_type": "structured",
            "mapping_index": 6
        },
        "event": "mapping_hover",
        "id": "qbpRRnKLxl6UOcJ5Ooe6"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:21:23.000",
        "data": {
            "detail_level": "high",
            "section_id": "0ed5da4b-0189-4c5e-be85-742c387e4d53",
            "structured_type": "structured",
            "mapping_index": 8
        },
        "event": "mapping_hover",
        "id": "tW1OoT9h4ZQGVNaq6FIX"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:21:23.000",
        "data": {
            "detail_level": "high",
            "section_id": "0ed5da4b-0189-4c5e-be85-742c387e4d53",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "udCDc0xTZetDjTbA0pKa"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:21:23.000",
        "data": {
            "detail_level": "high",
            "section_id": "0ed5da4b-0189-4c5e-be85-742c387e4d53",
            "structured_type": "structured",
            "mapping_index": 3
        },
        "event": "mapping_hover",
        "id": "vgxqYqSwm38bYVBSUx0a"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:21:23.000",
        "data": {
            "detail_level": "high",
            "section_id": "0ed5da4b-0189-4c5e-be85-742c387e4d53",
            "structured_type": "structured",
            "mapping_index": 4
        },
        "event": "mapping_hover",
        "id": "wXyVPAtkgbOgZiw63Rc6"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:21:40.000",
        "data": {
            "detail_level": "high",
            "section_id": "0ed5da4b-0189-4c5e-be85-742c387e4d53",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "3f7lAapunUxFM0DNXJRD"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:21:40.000",
        "data": {
            "detail_level": "high",
            "section_id": "0ed5da4b-0189-4c5e-be85-742c387e4d53",
            "structured_type": "structured",
            "mapping_index": 10
        },
        "event": "mapping_hover",
        "id": "5Ajrj0p5eUe6UDFyUv9O"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:21:41.000",
        "data": {
            "structured": "structured",
            "detail_level": "high",
            "summary": "• Loads data and extracts features, labels, and group sizes\n• Splits data into training (all but last two years) and testing (last two years) sets\n  ◦ Identifies indices for training and testing based on year\n  ◦ Separates features and labels accordingly\n• Computes group sizes for both training and test sets for ranking purposes\n• Initializes and configures an XGBoost ranking model with specified hyperparameters\n• Trains the model on the training data using group information\n• Predicts ranking scores for the test set\n  ◦ Assigns predicted scores and computes predicted ranks within each year\n• Evaluates the model using the NDCG metric on the test set\n• Prints detailed prediction results (year, name, true rank, predicted score, predicted rank)\n• Visualizes prediction errors for the years 2024 and 2025 using bar plots",
            "section_id": "0ed5da4b-0189-4c5e-be85-742c387e4d53"
        },
        "event": "click_edit_in_prompt",
        "id": "1hlPJGODK37Ltmhih2c3"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:21:41.000",
        "data": {
            "detail_level": "high",
            "section_id": "0ed5da4b-0189-4c5e-be85-742c387e4d53",
            "structured_type": "structured",
            "mapping_index": 10
        },
        "event": "mapping_hover",
        "id": "8w55iBEQny4iWNxJoGFX"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:21:41.000",
        "data": {
            "detail_level": "high",
            "section_id": "0ed5da4b-0189-4c5e-be85-742c387e4d53",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "9Lm2KSG7f8U1fwtZ2q04"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:21:42.000",
        "data": {
            "structured": "structured",
            "detail_level": "high",
            "instruction": "Which n_estimators is best for XGBRanker from 100, 1000, 2000?\nTry those three out and give the best answer",
            "original_summary": "• Loads data and extracts features, labels, and group sizes\n• Splits data into training (all but last two years) and testing (last two years) sets\n  ◦ Identifies indices for training and testing based on year\n  ◦ Separates features and labels accordingly\n• Computes group sizes for both training and test sets for ranking purposes\n• Initializes and configures an XGBoost ranking model with specified hyperparameters\n• Trains the model on the training data using group information\n• Predicts ranking scores for the test set\n  ◦ Assigns predicted scores and computes predicted ranks within each year\n• Evaluates the model using the NDCG metric on the test set\n• Prints detailed prediction results (year, name, true rank, predicted score, predicted rank)\n• Visualizes prediction errors for the years 2024 and 2025 using bar plots",
            "section_id": "0ed5da4b-0189-4c5e-be85-742c387e4d53"
        },
        "event": "apply_instruction_summary",
        "id": "lzX0nfj0RQufJAEbN9Sp"
    },
    {
        "source": "backend",
        "timestamp": "2025-08-23 14:21:45.000",
        "data": {
            "original_code": "def main():\n    X, y, group, df = load_data()\n\n    # Train-test split on years\n    unique_years = df[\"Year\"].unique()\n    train_years, test_years = (\n        unique_years[:-2],  # train: 2015-2023\n        unique_years[-2:],  # test: 2024-2025\n    )\n\n    train_idx = df[\"Year\"].isin(train_years)\n    test_idx = df[\"Year\"].isin(test_years)\n\n    X_train, X_test = X[train_idx], X[test_idx]\n    y_train, y_test = y[train_idx], y[test_idx]\n\n    # Group sizes\n    train_groups = df[train_idx].groupby(\"Year\").size().to_numpy()\n    test_groups = df[test_idx].groupby(\"Year\").size().to_numpy()\n\n    # Model\n    model = XGBRanker(\n        objective=\"rank:pairwise\",\n        learning_rate=0.1,\n        n_estimators=100,\n        max_depth=4,\n        random_state=42,\n    )\n\n    print(\"Training XGBoostRanker...\")\n    model.fit(X_train, y_train, group=train_groups)\n\n    # Predict, sort, and evaluate\n    y_pred = model.predict(X_test)\n    df.loc[test_idx, \"PredictedScore\"] = y_pred\n    df.loc[test_idx, \"PredictedRank\"] = (\n        df.loc[test_idx]\n        .groupby(\"Year\")[\"PredictedScore\"]\n        .rank(ascending=False, method=\"first\")\n    )\n\n    ndcg = evaluate_ndcg(y_test.to_numpy(), y_pred, test_groups)\n    print(f\"NDCG Score on test years {test_years.tolist()}: {ndcg:.4f}\")\n\n    # Show results\n    print(df[test_idx][[\"Year\", \"Name\", \"Rank\", \"PredictedScore\", \"PredictedRank\"]])\n    plot_ranking_predictions(df, 2024)\n    plot_ranking_predictions(df, 2025)",
            "instruction": "Which n_estimators is best for XGBRanker from 100, 1000, 2000?\nTry those three out and give the best answer",
            "original_summary": "• Loads data and extracts features, labels, and group sizes\n• Splits data into training (all but last two years) and testing (last two years) sets\n  ◦ Identifies indices for training and testing based on year\n  ◦ Separates features and labels accordingly\n• Computes group sizes for both training and test sets for ranking purposes\n• Initializes and configures an XGBoost ranking model with specified hyperparameters\n• Trains the model on the training data using group information\n• Predicts ranking scores for the test set\n  ◦ Assigns predicted scores and computes predicted ranks within each year\n• Evaluates the model using the NDCG metric on the test set\n• Prints detailed prediction results (year, name, true rank, predicted score, predicted rank)\n• Visualizes prediction errors for the years 2024 and 2025 using bar plots",
            "updated_summary": "• Loads data and extracts features, labels, and group sizes  \n• Splits data into training (all but last two years) and testing (last two years) sets  \n  ◦ Identifies indices for training and testing based on year  \n  ◦ Separates features and labels accordingly  \n• Computes group sizes for both training and test sets for ranking purposes  \n• For model selection, tries XGBoost ranking models with n_estimators values of 100, 1000, and 2000  \n  ◦ Initializes and configures an XGBoost ranking model with each n_estimators value and specified hyperparameters  \n  ◦ Trains each model on the training data using group information  \n  ◦ Predicts ranking scores for the test set for each model  \n  ◦ Evaluates each model using the NDCG metric on the test set  \n  ◦ Selects and reports the n_estimators value that yields the best NDCG score  \n• Assigns predicted scores and computes predicted ranks within each year using the best model  \n• Prints detailed prediction results (year, name, true rank, predicted score, predicted rank)  \n• Visualizes prediction errors for the years 2024 and 2025 using bar plots"
        },
        "event": "apply_instruction_summary",
        "id": "Pv936tvKbKZ8Cjd9y9tR"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:21:55.000",
        "data": {
            "structured": "structured",
            "detail_level": "high",
            "edited_summary": "• Loads data and extracts features, labels, and group sizes  \n• Splits data into training (all but last two years) and testing (last two years) sets  \n  ◦ Identifies indices for training and testing based on year  \n  ◦ Separates features and labels accordingly  \n• Computes group sizes for both training and test sets for ranking purposes  \n• For model selection, tries XGBoost ranking models with n_estimators values of 100, 1000, and 2000  \n  ◦ Initializes and configures an XGBoost ranking model with each n_estimators value and specified hyperparameters  \n  ◦ Trains each model on the training data using group information  \n  ◦ Predicts ranking scores for the test set for each model  \n  ◦ Evaluates each model using the NDCG metric on the test set  \n  ◦ Selects and reports the n_estimators value that yields the best NDCG score  \n• Assigns predicted scores and computes predicted ranks within each year using the best model  \n• Prints detailed prediction results (year, name, true rank, predicted score, predicted rank)  \n• Visualizes prediction errors for the years 2024 and 2025 using bar plots",
            "section_id": "0ed5da4b-0189-4c5e-be85-742c387e4d53",
            "original_summary": "• Loads data and extracts features, labels, and group sizes\n• Splits data into training (all but last two years) and testing (last two years) sets\n  ◦ Identifies indices for training and testing based on year\n  ◦ Separates features and labels accordingly\n• Computes group sizes for both training and test sets for ranking purposes\n• Initializes and configures an XGBoost ranking model with specified hyperparameters\n• Trains the model on the training data using group information\n• Predicts ranking scores for the test set\n  ◦ Assigns predicted scores and computes predicted ranks within each year\n• Evaluates the model using the NDCG metric on the test set\n• Prints detailed prediction results (year, name, true rank, predicted score, predicted rank)\n• Visualizes prediction errors for the years 2024 and 2025 using bar plots"
        },
        "event": "commit_modified_summary",
        "id": "xRg9eGaQAENsK72FJWuO"
    },
    {
        "source": "backend",
        "timestamp": "2025-08-23 14:22:06.000",
        "data": {
            "original_code": "def main():\n    X, y, group, df = load_data()\n\n    # Train-test split on years\n    unique_years = df[\"Year\"].unique()\n    train_years, test_years = (\n        unique_years[:-2],  # train: 2015-2023\n        unique_years[-2:],  # test: 2024-2025\n    )\n\n    train_idx = df[\"Year\"].isin(train_years)\n    test_idx = df[\"Year\"].isin(test_years)\n\n    X_train, X_test = X[train_idx], X[test_idx]\n    y_train, y_test = y[train_idx], y[test_idx]\n\n    # Group sizes\n    train_groups = df[train_idx].groupby(\"Year\").size().to_numpy()\n    test_groups = df[test_idx].groupby(\"Year\").size().to_numpy()\n\n    # Model\n    model = XGBRanker(\n        objective=\"rank:pairwise\",\n        learning_rate=0.1,\n        n_estimators=100,\n        max_depth=4,\n        random_state=42,\n    )\n\n    print(\"Training XGBoostRanker...\")\n    model.fit(X_train, y_train, group=train_groups)\n\n    # Predict, sort, and evaluate\n    y_pred = model.predict(X_test)\n    df.loc[test_idx, \"PredictedScore\"] = y_pred\n    df.loc[test_idx, \"PredictedRank\"] = (\n        df.loc[test_idx]\n        .groupby(\"Year\")[\"PredictedScore\"]\n        .rank(ascending=False, method=\"first\")\n    )\n\n    ndcg = evaluate_ndcg(y_test.to_numpy(), y_pred, test_groups)\n    print(f\"NDCG Score on test years {test_years.tolist()}: {ndcg:.4f}\")\n\n    # Show results\n    print(df[test_idx][[\"Year\", \"Name\", \"Rank\", \"PredictedScore\", \"PredictedRank\"]])\n    plot_ranking_predictions(df, 2024)\n    plot_ranking_predictions(df, 2025)",
            "updated_code": "def main():\n    X, y, group, df = load_data()\n\n    # Train-test split on years\n    unique_years = df[\"Year\"].unique()\n    train_years, test_years = (\n        unique_years[:-2],  # train: 2015-2023\n        unique_years[-2:],  # test: 2024-2025\n    )\n\n    train_idx = df[\"Year\"].isin(train_years)\n    test_idx = df[\"Year\"].isin(test_years)\n\n    X_train, X_test = X[train_idx], X[test_idx]\n    y_train, y_test = y[train_idx], y[test_idx]\n\n    # Group sizes\n    train_groups = df[train_idx].groupby(\"Year\").size().to_numpy()\n    test_groups = df[test_idx].groupby(\"Year\").size().to_numpy()\n\n    # Model selection: try different n_estimators\n    best_ndcg = -np.inf\n    best_model = None\n    best_n_estimators = None\n    best_y_pred = None\n\n    n_estimators_list = [100, 1000, 2000]\n    for n_estimators in n_estimators_list:\n        model = XGBRanker(\n            objective=\"rank:pairwise\",\n            learning_rate=0.1,\n            n_estimators=n_estimators,\n            max_depth=4,\n            random_state=42,\n        )\n        print(f\"Training XGBoostRanker with n_estimators={n_estimators}...\")\n        model.fit(X_train, y_train, group=train_groups)\n        y_pred = model.predict(X_test)\n        ndcg = evaluate_ndcg(y_test.to_numpy(), y_pred, test_groups)\n        print(f\"NDCG Score with n_estimators={n_estimators} on test years {test_years.tolist()}: {ndcg:.4f}\")\n        if ndcg > best_ndcg:\n            best_ndcg = ndcg\n            best_model = model\n            best_n_estimators = n_estimators\n            best_y_pred = y_pred\n\n    print(f\"Best n_estimators: {best_n_estimators} with NDCG Score: {best_ndcg:.4f}\")\n\n    # Assign predicted scores and ranks using the best model\n    df.loc[test_idx, \"PredictedScore\"] = best_y_pred\n    df.loc[test_idx, \"PredictedRank\"] = (\n        df.loc[test_idx]\n        .groupby(\"Year\")[\"PredictedScore\"]\n        .rank(ascending=False, method=\"first\")\n    )\n\n    # Show results\n    print(df[test_idx][[\"Year\", \"Name\", \"Rank\", \"PredictedScore\", \"PredictedRank\"]])\n    plot_ranking_predictions(df, 2024)\n    plot_ranking_predictions(df, 2025)",
            "detail_level": "high",
            "original_summary": "• Loads data and extracts features, labels, and group sizes\n• Splits data into training (all but last two years) and testing (last two years) sets\n  ◦ Identifies indices for training and testing based on year\n  ◦ Separates features and labels accordingly\n• Computes group sizes for both training and test sets for ranking purposes\n• Initializes and configures an XGBoost ranking model with specified hyperparameters\n• Trains the model on the training data using group information\n• Predicts ranking scores for the test set\n  ◦ Assigns predicted scores and computes predicted ranks within each year\n• Evaluates the model using the NDCG metric on the test set\n• Prints detailed prediction results (year, name, true rank, predicted score, predicted rank)\n• Visualizes prediction errors for the years 2024 and 2025 using bar plots",
            "edited_summary": "• Loads data and extracts features, labels, and group sizes  \n• Splits data into training (all but last two years) and testing (last two years) sets  \n  ◦ Identifies indices for training and testing based on year  \n  ◦ Separates features and labels accordingly  \n• Computes group sizes for both training and test sets for ranking purposes  \n• For model selection, tries XGBoost ranking models with n_estimators values of 100, 1000, and 2000  \n  ◦ Initializes and configures an XGBoost ranking model with each n_estimators value and specified hyperparameters  \n  ◦ Trains each model on the training data using group information  \n  ◦ Predicts ranking scores for the test set for each model  \n  ◦ Evaluates each model using the NDCG metric on the test set  \n  ◦ Selects and reports the n_estimators value that yields the best NDCG score  \n• Assigns predicted scores and computes predicted ranks within each year using the best model  \n• Prints detailed prediction results (year, name, true rank, predicted score, predicted rank)  \n• Visualizes prediction errors for the years 2024 and 2025 using bar plots",
            "structured_type": "structured"
        },
        "event": "modify_summary_mediation",
        "id": "8XYvbSA9NmJGv2HVHVYb"
    },
    {
        "source": "backend",
        "timestamp": "2025-08-23 14:22:20.000",
        "data": {
            "original_code": "def main():\n    X, y, group, df = load_data()\n\n    # Train-test split on years\n    unique_years = df[\"Year\"].unique()\n    train_years, test_years = (\n        unique_years[:-2],  # train: 2015-2023\n        unique_years[-2:],  # test: 2024-2025\n    )\n\n    train_idx = df[\"Year\"].isin(train_years)\n    test_idx = df[\"Year\"].isin(test_years)\n\n    X_train, X_test = X[train_idx], X[test_idx]\n    y_train, y_test = y[train_idx], y[test_idx]\n\n    # Group sizes\n    train_groups = df[train_idx].groupby(\"Year\").size().to_numpy()\n    test_groups = df[test_idx].groupby(\"Year\").size().to_numpy()\n\n    # Model selection: try different n_estimators\n    best_ndcg = -np.inf\n    best_model = None\n    best_n_estimators = None\n    best_y_pred = None\n\n    n_estimators_list = [100, 1000, 2000]\n    for n_estimators in n_estimators_list:\n        model = XGBRanker(\n            objective=\"rank:pairwise\",\n            learning_rate=0.1,\n            n_estimators=n_estimators,\n            max_depth=4,\n            random_state=42,\n        )\n        print(f\"Training XGBoostRanker with n_estimators={n_estimators}...\")\n        model.fit(X_train, y_train, group=train_groups)\n        y_pred = model.predict(X_test)\n        ndcg = evaluate_ndcg(y_test.to_numpy(), y_pred, test_groups)\n        print(f\"NDCG Score with n_estimators={n_estimators} on test years {test_years.tolist()}: {ndcg:.4f}\")\n        if ndcg > best_ndcg:\n            best_ndcg = ndcg\n            best_model = model\n            best_n_estimators = n_estimators\n            best_y_pred = y_pred\n\n    print(f\"Best n_estimators: {best_n_estimators} with NDCG Score: {best_ndcg:.4f}\")\n\n    # Assign predicted scores and ranks using the best model\n    df.loc[test_idx, \"PredictedScore\"] = best_y_pred\n    df.loc[test_idx, \"PredictedRank\"] = (\n        df.loc[test_idx]\n        .groupby(\"Year\")[\"PredictedScore\"]\n        .rank(ascending=False, method=\"first\")\n    )\n\n    # Show results\n    print(df[test_idx][[\"Year\", \"Name\", \"Rank\", \"PredictedScore\", \"PredictedRank\"]])\n    plot_ranking_predictions(df, 2024)\n    plot_ranking_predictions(df, 2025)",
            "old_summary": {
                "high_unstructured": "The main() function begins by loading the dataset and extracting features, labels, and group information. It then splits the data into training and testing sets based on year, with the most recent two years reserved for testing. An XGBoost ranking model is configured and trained on the training data, after which it predicts scores for the test set. The function evaluates the model's performance using the NDCG metric, prints detailed prediction results for each player in the test years, and generates bar plots visualizing prediction errors for the years 2024 and 2025.",
                "low_structured": "• Loads data and splits it into training and testing sets\n• Trains an XGBoost ranking model and evaluates it\n• Outputs and visualizes prediction results",
                "high_structured": "• Loads data and extracts features, labels, and group sizes\n• Splits data into training (all but last two years) and testing (last two years) sets\n  ◦ Identifies indices for training and testing based on year\n  ◦ Separates features and labels accordingly\n• Computes group sizes for both training and test sets for ranking purposes\n• Initializes and configures an XGBoost ranking model with specified hyperparameters\n• Trains the model on the training data using group information\n• Predicts ranking scores for the test set\n  ◦ Assigns predicted scores and computes predicted ranks within each year\n• Evaluates the model using the NDCG metric on the test set\n• Prints detailed prediction results (year, name, true rank, predicted score, predicted rank)\n• Visualizes prediction errors for the years 2024 and 2025 using bar plots",
                "title": "Summary of the main() Function for MVP Ranking Prediction",
                "medium_unstructured": "The main() function orchestrates the process of loading MVP ranking data, splitting it into training and test sets based on years, and training an XGBoost ranking model. It predicts rankings for the test years, evaluates the model using the NDCG metric, and prints as well as visualizes the results for the most recent years. This workflow enables assessment and visualization of the model's ranking performance.",
                "medium_structured": "• Loads data and splits it into training (past years) and testing (recent years) sets\n• Trains an XGBoost ranking model on the training data\n• Predicts and assigns ranking scores for the test years\n• Evaluates model performance using the NDCG metric\n• Prints and visualizes the prediction results for the test years",
                "low_unstructured": "This function loads data, trains an XGBoost ranking model, evaluates its performance, and visualizes prediction results for recent years."
            },
            "new_summary": {
                "high_unstructured": "The main() function begins by loading the dataset and extracting features, labels, and group information. It then splits the data into training and testing sets based on year, with the most recent two years reserved for testing. Multiple XGBoost ranking models are configured and trained on the training data, each with a different n_estimators value. The function evaluates each model's performance using the NDCG metric, selects the best-performing model, prints detailed prediction results for each player in the test years, and generates bar plots visualizing prediction errors for the years 2024 and 2025.",
                "low_structured": "• Loads data and splits it into training and testing sets\n• Trains multiple XGBoost ranking models with varying n_estimators and selects the best one based on NDCG score\n• Outputs and visualizes prediction results",
                "high_structured": "• Loads data and extracts features, labels, and group sizes\n• Splits data into training (all but last two years) and testing (last two years) sets\n  ◦ Identifies indices for training and testing based on year\n  ◦ Separates features and labels accordingly\n• Computes group sizes for both training and test sets for ranking purposes\n• Initializes and configures multiple XGBoost ranking models with different n_estimators values\n• Trains each model on the training data using group information\n• Evaluates each model using the NDCG metric on the test set and selects the best-performing model\n• Predicts ranking scores for the test set using the best model\n  ◦ Assigns predicted scores and computes predicted ranks within each year\n• Prints detailed prediction results (year, name, true rank, predicted score, predicted rank)\n• Visualizes prediction errors for the years 2024 and 2025 using bar plots",
                "title": "Summary of the main() Function for MVP Ranking Prediction (with Explicit n_estimators Model Selection)",
                "medium_unstructured": "The main() function orchestrates the process of loading MVP ranking data, splitting it into training and test sets based on years, and training several XGBoost ranking models with different n_estimators values. It selects the model with the highest NDCG score, predicts rankings for the test years, evaluates the model using the NDCG metric, and prints as well as visualizes the results for the most recent years. This workflow enables assessment and visualization of the model's ranking performance.",
                "medium_structured": "• Loads data and splits it into training (past years) and testing (recent years) sets\n• Trains multiple XGBoost ranking models on the training data with different n_estimators values\n• Selects the best model based on NDCG score\n• Predicts and assigns ranking scores for the test years using the best model\n• Evaluates model performance using the NDCG metric\n• Prints and visualizes the prediction results for the test years",
                "low_unstructured": "This function loads data, splits it into training and testing sets, trains multiple XGBoost ranking models with different n_estimators values, selects the best model based on NDCG score, and visualizes prediction results for recent years."
            },
            "new_code": "def main():\n    X, y, group, df = load_data()\n\n    # Train-test split on years\n    unique_years = df[\"Year\"].unique()\n    train_years, test_years = (\n        unique_years[:-2],  # train: 2015-2023\n        unique_years[-2:],  # test: 2024-2025\n    )\n\n    train_idx = df[\"Year\"].isin(train_years)\n    test_idx = df[\"Year\"].isin(test_years)\n\n    X_train, X_test = X[train_idx], X[test_idx]\n    y_train, y_test = y[train_idx], y[test_idx]\n\n    # Group sizes\n    train_groups = df[train_idx].groupby(\"Year\").size().to_numpy()\n    test_groups = df[test_idx].groupby(\"Year\").size().to_numpy()\n\n    # Model selection: try different n_estimators\n    best_ndcg = -np.inf\n    best_model = None\n    best_n_estimators = None\n    best_y_pred = None\n\n    n_estimators_list = [100, 1000, 2000]\n    for n_estimators in n_estimators_list:\n        model = XGBRanker(\n            objective=\"rank:pairwise\",\n            learning_rate=0.1,\n            n_estimators=n_estimators,\n            max_depth=4,\n            random_state=42,\n        )\n        print(f\"Training XGBoostRanker with n_estimators={n_estimators}...\")\n        model.fit(X_train, y_train, group=train_groups)\n        y_pred = model.predict(X_test)\n        ndcg = evaluate_ndcg(y_test.to_numpy(), y_pred, test_groups)\n        print(f\"NDCG Score with n_estimators={n_estimators} on test years {test_years.tolist()}: {ndcg:.4f}\")\n        if ndcg > best_ndcg:\n            best_ndcg = ndcg\n            best_model = model\n            best_n_estimators = n_estimators\n            best_y_pred = y_pred\n\n    print(f\"Best n_estimators: {best_n_estimators} with NDCG Score: {best_ndcg:.4f}\")\n\n    # Assign predicted scores and ranks using the best model\n    df.loc[test_idx, \"PredictedScore\"] = best_y_pred\n    df.loc[test_idx, \"PredictedRank\"] = (\n        df.loc[test_idx]\n        .groupby(\"Year\")[\"PredictedScore\"]\n        .rank(ascending=False, method=\"first\")\n    )\n\n    # Show results\n    print(df[test_idx][[\"Year\", \"Name\", \"Rank\", \"PredictedScore\", \"PredictedRank\"]])\n    plot_ranking_predictions(df, 2024)\n    plot_ranking_predictions(df, 2025)"
        },
        "event": "summarize_modified_code",
        "id": "8keeV3ze57V5Akz2B0Uf"
    },
    {
        "source": "backend",
        "timestamp": "2025-08-23 14:22:24.000",
        "data": {
            "summary": "This function loads data, splits it into training and testing sets, trains multiple XGBoost ranking models with different n_estimators values, selects the best model based on NDCG score, and visualizes prediction results for recent years.",
            "code": "74: def main():\n75:     X, y, group, df = load_data()\n76: \n77:     # Train-test split on years\n78:     unique_years = df[\"Year\"].unique()\n79:     train_years, test_years = (\n80:         unique_years[:-2],  # train: 2015-2023\n81:         unique_years[-2:],  # test: 2024-2025\n82:     )\n83: \n84:     train_idx = df[\"Year\"].isin(train_years)\n85:     test_idx = df[\"Year\"].isin(test_years)\n86: \n87:     X_train, X_test = X[train_idx], X[test_idx]\n88:     y_train, y_test = y[train_idx], y[test_idx]\n89: \n90:     # Group sizes\n91:     train_groups = df[train_idx].groupby(\"Year\").size().to_numpy()\n92:     test_groups = df[test_idx].groupby(\"Year\").size().to_numpy()\n93: \n94:     # Model selection: try different n_estimators\n95:     best_ndcg = -np.inf\n96:     best_model = None\n97:     best_n_estimators = None\n98:     best_y_pred = None\n99: \n100:     n_estimators_list = [100, 1000, 2000]\n101:     for n_estimators in n_estimators_list:\n102:         model = XGBRanker(\n103:             objective=\"rank:pairwise\",\n104:             learning_rate=0.1,\n105:             n_estimators=n_estimators,\n106:             max_depth=4,\n107:             random_state=42,\n108:         )\n109:         print(f\"Training XGBoostRanker with n_estimators={n_estimators}...\")\n110:         model.fit(X_train, y_train, group=train_groups)\n111:         y_pred = model.predict(X_test)\n112:         ndcg = evaluate_ndcg(y_test.to_numpy(), y_pred, test_groups)\n113:         print(f\"NDCG Score with n_estimators={n_estimators} on test years {test_years.tolist()}: {ndcg:.4f}\")\n114:         if ndcg > best_ndcg:\n115:             best_ndcg = ndcg\n116:             best_model = model\n117:             best_n_estimators = n_estimators\n118:             best_y_pred = y_pred\n119: \n120:     print(f\"Best n_estimators: {best_n_estimators} with NDCG Score: {best_ndcg:.4f}\")\n121: \n122:     # Assign predicted scores and ranks using the best model\n123:     df.loc[test_idx, \"PredictedScore\"] = best_y_pred\n124:     df.loc[test_idx, \"PredictedRank\"] = (\n125:         df.loc[test_idx]\n126:         .groupby(\"Year\")[\"PredictedScore\"]\n127:         .rank(ascending=False, method=\"first\")\n128:     )\n129: \n130:     # Show results\n131:     print(df[test_idx][[\"Year\", \"Name\", \"Rank\", \"PredictedScore\", \"PredictedRank\"]])\n132:     plot_ranking_predictions(df, 2024)\n133:     plot_ranking_predictions(df, 2025)",
            "mapping": [
                {
                    "codeSegments": [
                        {
                            "line": 75,
                            "code": "X, y, group, df = load_data()"
                        }
                    ],
                    "summaryComponent": "loads data"
                },
                {
                    "codeSegments": [
                        {
                            "line": 78,
                            "code": "unique_years = df[\"Year\"].unique()"
                        },
                        {
                            "line": 79,
                            "code": "train_years, test_years = ("
                        },
                        {
                            "line": 84,
                            "code": "train_idx = df[\"Year\"].isin(train_years)"
                        },
                        {
                            "line": 85,
                            "code": "test_idx = df[\"Year\"].isin(test_years)"
                        },
                        {
                            "line": 87,
                            "code": "X_train, X_test = X[train_idx], X[test_idx]"
                        },
                        {
                            "line": 88,
                            "code": "y_train, y_test = y[train_idx], y[test_idx]"
                        }
                    ],
                    "summaryComponent": "splits it into training and testing sets"
                },
                {
                    "codeSegments": [
                        {
                            "line": 100,
                            "code": "n_estimators_list = [100, 1000, 2000]"
                        },
                        {
                            "line": 101,
                            "code": "for n_estimators in n_estimators_list:"
                        },
                        {
                            "line": 102,
                            "code": "model = XGBRanker("
                        },
                        {
                            "line": 110,
                            "code": "model.fit(X_train, y_train, group=train_groups)"
                        }
                    ],
                    "summaryComponent": "trains multiple XGBoost ranking models with different n_estimators values"
                },
                {
                    "codeSegments": [
                        {
                            "line": 112,
                            "code": "ndcg = evaluate_ndcg(y_test.to_numpy(), y_pred, test_groups)"
                        },
                        {
                            "line": 114,
                            "code": "if ndcg > best_ndcg:"
                        },
                        {
                            "line": 115,
                            "code": "best_ndcg = ndcg"
                        },
                        {
                            "line": 116,
                            "code": "best_model = model"
                        },
                        {
                            "line": 117,
                            "code": "best_n_estimators = n_estimators"
                        },
                        {
                            "line": 118,
                            "code": "best_y_pred = y_pred"
                        }
                    ],
                    "summaryComponent": "selects the best model based on NDCG score"
                },
                {
                    "codeSegments": [
                        {
                            "line": 132,
                            "code": "plot_ranking_predictions(df, 2024)"
                        },
                        {
                            "line": 133,
                            "code": "plot_ranking_predictions(df, 2025)"
                        }
                    ],
                    "summaryComponent": "visualizes prediction results for recent years"
                }
            ]
        },
        "event": "map_summary_code",
        "id": "BCRyz5TCu7qt7EA9pqfV"
    },
    {
        "source": "backend",
        "timestamp": "2025-08-23 14:22:24.000",
        "data": {
            "summary": "• Loads data and splits it into training and testing sets\n• Trains multiple XGBoost ranking models with varying n_estimators and selects the best one based on NDCG score\n• Outputs and visualizes prediction results",
            "code": "74: def main():\n75:     X, y, group, df = load_data()\n76: \n77:     # Train-test split on years\n78:     unique_years = df[\"Year\"].unique()\n79:     train_years, test_years = (\n80:         unique_years[:-2],  # train: 2015-2023\n81:         unique_years[-2:],  # test: 2024-2025\n82:     )\n83: \n84:     train_idx = df[\"Year\"].isin(train_years)\n85:     test_idx = df[\"Year\"].isin(test_years)\n86: \n87:     X_train, X_test = X[train_idx], X[test_idx]\n88:     y_train, y_test = y[train_idx], y[test_idx]\n89: \n90:     # Group sizes\n91:     train_groups = df[train_idx].groupby(\"Year\").size().to_numpy()\n92:     test_groups = df[test_idx].groupby(\"Year\").size().to_numpy()\n93: \n94:     # Model selection: try different n_estimators\n95:     best_ndcg = -np.inf\n96:     best_model = None\n97:     best_n_estimators = None\n98:     best_y_pred = None\n99: \n100:     n_estimators_list = [100, 1000, 2000]\n101:     for n_estimators in n_estimators_list:\n102:         model = XGBRanker(\n103:             objective=\"rank:pairwise\",\n104:             learning_rate=0.1,\n105:             n_estimators=n_estimators,\n106:             max_depth=4,\n107:             random_state=42,\n108:         )\n109:         print(f\"Training XGBoostRanker with n_estimators={n_estimators}...\")\n110:         model.fit(X_train, y_train, group=train_groups)\n111:         y_pred = model.predict(X_test)\n112:         ndcg = evaluate_ndcg(y_test.to_numpy(), y_pred, test_groups)\n113:         print(f\"NDCG Score with n_estimators={n_estimators} on test years {test_years.tolist()}: {ndcg:.4f}\")\n114:         if ndcg > best_ndcg:\n115:             best_ndcg = ndcg\n116:             best_model = model\n117:             best_n_estimators = n_estimators\n118:             best_y_pred = y_pred\n119: \n120:     print(f\"Best n_estimators: {best_n_estimators} with NDCG Score: {best_ndcg:.4f}\")\n121: \n122:     # Assign predicted scores and ranks using the best model\n123:     df.loc[test_idx, \"PredictedScore\"] = best_y_pred\n124:     df.loc[test_idx, \"PredictedRank\"] = (\n125:         df.loc[test_idx]\n126:         .groupby(\"Year\")[\"PredictedScore\"]\n127:         .rank(ascending=False, method=\"first\")\n128:     )\n129: \n130:     # Show results\n131:     print(df[test_idx][[\"Year\", \"Name\", \"Rank\", \"PredictedScore\", \"PredictedRank\"]])\n132:     plot_ranking_predictions(df, 2024)\n133:     plot_ranking_predictions(df, 2025)",
            "mapping": [
                {
                    "codeSegments": [
                        {
                            "line": 75,
                            "code": "X, y, group, df = load_data()"
                        },
                        {
                            "line": 78,
                            "code": "unique_years = df[\"Year\"].unique()"
                        },
                        {
                            "line": 79,
                            "code": "train_years, test_years = ("
                        },
                        {
                            "line": 84,
                            "code": "train_idx = df[\"Year\"].isin(train_years)"
                        },
                        {
                            "line": 85,
                            "code": "test_idx = df[\"Year\"].isin(test_years)"
                        },
                        {
                            "line": 87,
                            "code": "X_train, X_test = X[train_idx], X[test_idx]"
                        },
                        {
                            "line": 88,
                            "code": "y_train, y_test = y[train_idx], y[test_idx]"
                        }
                    ],
                    "summaryComponent": "Loads data and splits it into training and testing sets"
                },
                {
                    "codeSegments": [
                        {
                            "line": 100,
                            "code": "n_estimators_list = [100, 1000, 2000]"
                        },
                        {
                            "line": 101,
                            "code": "for n_estimators in n_estimators_list:"
                        },
                        {
                            "line": 102,
                            "code": "model = XGBRanker("
                        },
                        {
                            "line": 110,
                            "code": "model.fit(X_train, y_train, group=train_groups)"
                        },
                        {
                            "line": 112,
                            "code": "ndcg = evaluate_ndcg(y_test.to_numpy(), y_pred, test_groups)"
                        },
                        {
                            "line": 114,
                            "code": "if ndcg > best_ndcg:"
                        },
                        {
                            "line": 115,
                            "code": "best_ndcg = ndcg"
                        },
                        {
                            "line": 116,
                            "code": "best_model = model"
                        },
                        {
                            "line": 117,
                            "code": "best_n_estimators = n_estimators"
                        },
                        {
                            "line": 118,
                            "code": "best_y_pred = y_pred"
                        }
                    ],
                    "summaryComponent": "Trains multiple XGBoost ranking models with varying n_estimators and selects the best one based on NDCG score"
                },
                {
                    "codeSegments": [
                        {
                            "line": 131,
                            "code": "print(df[test_idx][[\"Year\", \"Name\", \"Rank\", \"PredictedScore\", \"PredictedRank\"]])"
                        },
                        {
                            "line": 132,
                            "code": "plot_ranking_predictions(df, 2024)"
                        },
                        {
                            "line": 133,
                            "code": "plot_ranking_predictions(df, 2025)"
                        }
                    ],
                    "summaryComponent": "Outputs and visualizes prediction results"
                }
            ]
        },
        "event": "map_summary_code",
        "id": "SWIXzBJJmxxZYDGu5pt1"
    },
    {
        "source": "backend",
        "timestamp": "2025-08-23 14:22:25.000",
        "data": {
            "summary": "The main() function orchestrates the process of loading MVP ranking data, splitting it into training and test sets based on years, and training several XGBoost ranking models with different n_estimators values. It selects the model with the highest NDCG score, predicts rankings for the test years, evaluates the model using the NDCG metric, and prints as well as visualizes the results for the most recent years. This workflow enables assessment and visualization of the model's ranking performance.",
            "code": "74: def main():\n75:     X, y, group, df = load_data()\n76: \n77:     # Train-test split on years\n78:     unique_years = df[\"Year\"].unique()\n79:     train_years, test_years = (\n80:         unique_years[:-2],  # train: 2015-2023\n81:         unique_years[-2:],  # test: 2024-2025\n82:     )\n83: \n84:     train_idx = df[\"Year\"].isin(train_years)\n85:     test_idx = df[\"Year\"].isin(test_years)\n86: \n87:     X_train, X_test = X[train_idx], X[test_idx]\n88:     y_train, y_test = y[train_idx], y[test_idx]\n89: \n90:     # Group sizes\n91:     train_groups = df[train_idx].groupby(\"Year\").size().to_numpy()\n92:     test_groups = df[test_idx].groupby(\"Year\").size().to_numpy()\n93: \n94:     # Model selection: try different n_estimators\n95:     best_ndcg = -np.inf\n96:     best_model = None\n97:     best_n_estimators = None\n98:     best_y_pred = None\n99: \n100:     n_estimators_list = [100, 1000, 2000]\n101:     for n_estimators in n_estimators_list:\n102:         model = XGBRanker(\n103:             objective=\"rank:pairwise\",\n104:             learning_rate=0.1,\n105:             n_estimators=n_estimators,\n106:             max_depth=4,\n107:             random_state=42,\n108:         )\n109:         print(f\"Training XGBoostRanker with n_estimators={n_estimators}...\")\n110:         model.fit(X_train, y_train, group=train_groups)\n111:         y_pred = model.predict(X_test)\n112:         ndcg = evaluate_ndcg(y_test.to_numpy(), y_pred, test_groups)\n113:         print(f\"NDCG Score with n_estimators={n_estimators} on test years {test_years.tolist()}: {ndcg:.4f}\")\n114:         if ndcg > best_ndcg:\n115:             best_ndcg = ndcg\n116:             best_model = model\n117:             best_n_estimators = n_estimators\n118:             best_y_pred = y_pred\n119: \n120:     print(f\"Best n_estimators: {best_n_estimators} with NDCG Score: {best_ndcg:.4f}\")\n121: \n122:     # Assign predicted scores and ranks using the best model\n123:     df.loc[test_idx, \"PredictedScore\"] = best_y_pred\n124:     df.loc[test_idx, \"PredictedRank\"] = (\n125:         df.loc[test_idx]\n126:         .groupby(\"Year\")[\"PredictedScore\"]\n127:         .rank(ascending=False, method=\"first\")\n128:     )\n129: \n130:     # Show results\n131:     print(df[test_idx][[\"Year\", \"Name\", \"Rank\", \"PredictedScore\", \"PredictedRank\"]])\n132:     plot_ranking_predictions(df, 2024)\n133:     plot_ranking_predictions(df, 2025)",
            "mapping": [
                {
                    "codeSegments": [
                        {
                            "line": 74,
                            "code": "def main():"
                        },
                        {
                            "line": 75,
                            "code": "X, y, group, df = load_data()"
                        }
                    ],
                    "summaryComponent": "The main() function orchestrates the process of loading MVP ranking data"
                },
                {
                    "codeSegments": [
                        {
                            "line": 78,
                            "code": "unique_years = df[\"Year\"].unique()"
                        },
                        {
                            "line": 79,
                            "code": "train_years, test_years = ("
                        },
                        {
                            "line": 84,
                            "code": "train_idx = df[\"Year\"].isin(train_years)"
                        },
                        {
                            "line": 85,
                            "code": "test_idx = df[\"Year\"].isin(test_years)"
                        },
                        {
                            "line": 87,
                            "code": "X_train, X_test = X[train_idx], X[test_idx]"
                        },
                        {
                            "line": 88,
                            "code": "y_train, y_test = y[train_idx], y[test_idx]"
                        }
                    ],
                    "summaryComponent": "splitting it into training and test sets based on years"
                },
                {
                    "codeSegments": [
                        {
                            "line": 100,
                            "code": "n_estimators_list = [100, 1000, 2000]"
                        },
                        {
                            "line": 101,
                            "code": "for n_estimators in n_estimators_list:"
                        },
                        {
                            "line": 102,
                            "code": "model = XGBRanker("
                        }
                    ],
                    "summaryComponent": "training several XGBoost ranking models with different n_estimators values"
                },
                {
                    "codeSegments": [
                        {
                            "line": 114,
                            "code": "if ndcg > best_ndcg:"
                        },
                        {
                            "line": 115,
                            "code": "best_ndcg = ndcg"
                        },
                        {
                            "line": 116,
                            "code": "best_model = model"
                        },
                        {
                            "line": 117,
                            "code": "best_n_estimators = n_estimators"
                        },
                        {
                            "line": 118,
                            "code": "best_y_pred = y_pred"
                        }
                    ],
                    "summaryComponent": "It selects the model with the highest NDCG score"
                },
                {
                    "codeSegments": [
                        {
                            "line": 123,
                            "code": "df.loc[test_idx, \"PredictedScore\"] = best_y_pred"
                        },
                        {
                            "line": 124,
                            "code": "df.loc[test_idx, \"PredictedRank\"] = ("
                        }
                    ],
                    "summaryComponent": "predicts rankings for the test years"
                },
                {
                    "codeSegments": [
                        {
                            "line": 112,
                            "code": "ndcg = evaluate_ndcg(y_test.to_numpy(), y_pred, test_groups)"
                        }
                    ],
                    "summaryComponent": "evaluates the model using the NDCG metric"
                },
                {
                    "codeSegments": [
                        {
                            "line": 131,
                            "code": "print(df[test_idx][[\"Year\", \"Name\", \"Rank\", \"PredictedScore\", \"PredictedRank\"]])"
                        },
                        {
                            "line": 132,
                            "code": "plot_ranking_predictions(df, 2024)"
                        },
                        {
                            "line": 133,
                            "code": "plot_ranking_predictions(df, 2025)"
                        }
                    ],
                    "summaryComponent": "and prints as well as visualizes the results for the most recent years"
                },
                {
                    "codeSegments": [
                        {
                            "line": 131,
                            "code": "print(df[test_idx][[\"Year\", \"Name\", \"Rank\", \"PredictedScore\", \"PredictedRank\"]])"
                        },
                        {
                            "line": 132,
                            "code": "plot_ranking_predictions(df, 2024)"
                        },
                        {
                            "line": 133,
                            "code": "plot_ranking_predictions(df, 2025)"
                        }
                    ],
                    "summaryComponent": "This workflow enables assessment and visualization of the model's ranking performance."
                }
            ]
        },
        "event": "map_summary_code",
        "id": "cjJqQ8SszDNtZiw1yudn"
    },
    {
        "source": "backend",
        "timestamp": "2025-08-23 14:22:25.000",
        "data": {
            "summary": "The main() function begins by loading the dataset and extracting features, labels, and group information. It then splits the data into training and testing sets based on year, with the most recent two years reserved for testing. Multiple XGBoost ranking models are configured and trained on the training data, each with a different n_estimators value. The function evaluates each model's performance using the NDCG metric, selects the best-performing model, prints detailed prediction results for each player in the test years, and generates bar plots visualizing prediction errors for the years 2024 and 2025.",
            "code": "74: def main():\n75:     X, y, group, df = load_data()\n76: \n77:     # Train-test split on years\n78:     unique_years = df[\"Year\"].unique()\n79:     train_years, test_years = (\n80:         unique_years[:-2],  # train: 2015-2023\n81:         unique_years[-2:],  # test: 2024-2025\n82:     )\n83: \n84:     train_idx = df[\"Year\"].isin(train_years)\n85:     test_idx = df[\"Year\"].isin(test_years)\n86: \n87:     X_train, X_test = X[train_idx], X[test_idx]\n88:     y_train, y_test = y[train_idx], y[test_idx]\n89: \n90:     # Group sizes\n91:     train_groups = df[train_idx].groupby(\"Year\").size().to_numpy()\n92:     test_groups = df[test_idx].groupby(\"Year\").size().to_numpy()\n93: \n94:     # Model selection: try different n_estimators\n95:     best_ndcg = -np.inf\n96:     best_model = None\n97:     best_n_estimators = None\n98:     best_y_pred = None\n99: \n100:     n_estimators_list = [100, 1000, 2000]\n101:     for n_estimators in n_estimators_list:\n102:         model = XGBRanker(\n103:             objective=\"rank:pairwise\",\n104:             learning_rate=0.1,\n105:             n_estimators=n_estimators,\n106:             max_depth=4,\n107:             random_state=42,\n108:         )\n109:         print(f\"Training XGBoostRanker with n_estimators={n_estimators}...\")\n110:         model.fit(X_train, y_train, group=train_groups)\n111:         y_pred = model.predict(X_test)\n112:         ndcg = evaluate_ndcg(y_test.to_numpy(), y_pred, test_groups)\n113:         print(f\"NDCG Score with n_estimators={n_estimators} on test years {test_years.tolist()}: {ndcg:.4f}\")\n114:         if ndcg > best_ndcg:\n115:             best_ndcg = ndcg\n116:             best_model = model\n117:             best_n_estimators = n_estimators\n118:             best_y_pred = y_pred\n119: \n120:     print(f\"Best n_estimators: {best_n_estimators} with NDCG Score: {best_ndcg:.4f}\")\n121: \n122:     # Assign predicted scores and ranks using the best model\n123:     df.loc[test_idx, \"PredictedScore\"] = best_y_pred\n124:     df.loc[test_idx, \"PredictedRank\"] = (\n125:         df.loc[test_idx]\n126:         .groupby(\"Year\")[\"PredictedScore\"]\n127:         .rank(ascending=False, method=\"first\")\n128:     )\n129: \n130:     # Show results\n131:     print(df[test_idx][[\"Year\", \"Name\", \"Rank\", \"PredictedScore\", \"PredictedRank\"]])\n132:     plot_ranking_predictions(df, 2024)\n133:     plot_ranking_predictions(df, 2025)",
            "mapping": [
                {
                    "codeSegments": [
                        {
                            "line": 74,
                            "code": "def main():"
                        },
                        {
                            "line": 75,
                            "code": "X, y, group, df = load_data()"
                        }
                    ],
                    "summaryComponent": "The main() function begins by loading the dataset and extracting features, labels, and group information."
                },
                {
                    "codeSegments": [
                        {
                            "line": 78,
                            "code": "unique_years = df[\"Year\"].unique()"
                        },
                        {
                            "line": 79,
                            "code": "train_years, test_years = ("
                        },
                        {
                            "line": 80,
                            "code": "unique_years[:-2],  # train: 2015-2023"
                        },
                        {
                            "line": 81,
                            "code": "unique_years[-2:],  # test: 2024-2025"
                        },
                        {
                            "line": 84,
                            "code": "train_idx = df[\"Year\"].isin(train_years)"
                        },
                        {
                            "line": 85,
                            "code": "test_idx = df[\"Year\"].isin(test_years)"
                        },
                        {
                            "line": 87,
                            "code": "X_train, X_test = X[train_idx], X[test_idx]"
                        },
                        {
                            "line": 88,
                            "code": "y_train, y_test = y[train_idx], y[test_idx]"
                        }
                    ],
                    "summaryComponent": "It then splits the data into training and testing sets based on year, with the most recent two years reserved for testing."
                },
                {
                    "codeSegments": [
                        {
                            "line": 100,
                            "code": "n_estimators_list = [100, 1000, 2000]"
                        },
                        {
                            "line": 101,
                            "code": "for n_estimators in n_estimators_list:"
                        },
                        {
                            "line": 102,
                            "code": "model = XGBRanker("
                        },
                        {
                            "line": 105,
                            "code": "n_estimators=n_estimators,"
                        },
                        {
                            "line": 110,
                            "code": "model.fit(X_train, y_train, group=train_groups)"
                        }
                    ],
                    "summaryComponent": "Multiple XGBoost ranking models are configured and trained on the training data, each with a different n_estimators value."
                },
                {
                    "codeSegments": [
                        {
                            "line": 112,
                            "code": "ndcg = evaluate_ndcg(y_test.to_numpy(), y_pred, test_groups)"
                        }
                    ],
                    "summaryComponent": "The function evaluates each model's performance using the NDCG metric,"
                },
                {
                    "codeSegments": [
                        {
                            "line": 114,
                            "code": "if ndcg > best_ndcg:"
                        },
                        {
                            "line": 115,
                            "code": "best_ndcg = ndcg"
                        },
                        {
                            "line": 116,
                            "code": "best_model = model"
                        },
                        {
                            "line": 117,
                            "code": "best_n_estimators = n_estimators"
                        },
                        {
                            "line": 118,
                            "code": "best_y_pred = y_pred"
                        }
                    ],
                    "summaryComponent": "selects the best-performing model,"
                },
                {
                    "codeSegments": [
                        {
                            "line": 131,
                            "code": "print(df[test_idx][[\"Year\", \"Name\", \"Rank\", \"PredictedScore\", \"PredictedRank\"]])"
                        }
                    ],
                    "summaryComponent": "prints detailed prediction results for each player in the test years,"
                },
                {
                    "codeSegments": [
                        {
                            "line": 132,
                            "code": "plot_ranking_predictions(df, 2024)"
                        },
                        {
                            "line": 133,
                            "code": "plot_ranking_predictions(df, 2025)"
                        }
                    ],
                    "summaryComponent": "and generates bar plots visualizing prediction errors for the years 2024 and 2025."
                }
            ]
        },
        "event": "map_summary_code",
        "id": "dmFoWLymm3Ze6vwg188z"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:22:26.000",
        "data": {
            "after_section_id": "7dcb4dfb-9fc5-4331-a999-9ca5f71a37eb",
            "before_section_id": "0ed5da4b-0189-4c5e-be85-742c387e4d53"
        },
        "event": "autotransit_section",
        "id": "0mn0g3pUD11dBnBNR5Lb"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:22:26.000",
        "data": {
            "section_data": {
                "editPromptValue": "",
                "summaryData": {
                    "high_unstructured": "The main() function begins by loading the dataset and extracting features, labels, and group information. It then splits the data into training and testing sets based on year, with the most recent two years reserved for testing. Multiple XGBoost ranking models are configured and trained on the training data, each with a different n_estimators value. The function evaluates each model's performance using the NDCG metric, selects the best-performing model, prints detailed prediction results for each player in the test years, and generates bar plots visualizing prediction errors for the years 2024 and 2025.",
                    "low_structured": "• Loads data and splits it into training and testing sets\n• Trains multiple XGBoost ranking models with varying n_estimators and selects the best one based on NDCG score\n• Outputs and visualizes prediction results",
                    "high_structured": "• Loads data and extracts features, labels, and group sizes\n• Splits data into training (all but last two years) and testing (last two years) sets\n  ◦ Identifies indices for training and testing based on year\n  ◦ Separates features and labels accordingly\n• Computes group sizes for both training and test sets for ranking purposes\n• Initializes and configures multiple XGBoost ranking models with different n_estimators values\n• Trains each model on the training data using group information\n• Evaluates each model using the NDCG metric on the test set and selects the best-performing model\n• Predicts ranking scores for the test set using the best model\n  ◦ Assigns predicted scores and computes predicted ranks within each year\n• Prints detailed prediction results (year, name, true rank, predicted score, predicted rank)\n• Visualizes prediction errors for the years 2024 and 2025 using bar plots",
                    "title": "Summary of the main() Function for MVP Ranking Prediction (with Explicit n_estimators Model Selection)",
                    "medium_unstructured": "The main() function orchestrates the process of loading MVP ranking data, splitting it into training and test sets based on years, and training several XGBoost ranking models with different n_estimators values. It selects the model with the highest NDCG score, predicts rankings for the test years, evaluates the model using the NDCG metric, and prints as well as visualizes the results for the most recent years. This workflow enables assessment and visualization of the model's ranking performance.",
                    "medium_structured": "• Loads data and splits it into training (past years) and testing (recent years) sets\n• Trains multiple XGBoost ranking models on the training data with different n_estimators values\n• Selects the best model based on NDCG score\n• Predicts and assigns ranking scores for the test years using the best model\n• Evaluates model performance using the NDCG metric\n• Prints and visualizes the prediction results for the test years",
                    "low_unstructured": "This function loads data, splits it into training and testing sets, trains multiple XGBoost ranking models with different n_estimators values, selects the best model based on NDCG score, and visualizes prediction results for recent years."
                },
                "selectedDetailLevel": "medium",
                "title": "Summary of the main() Function for MVP Ranking Prediction (with Explicit n_estimators Model Selection)",
                "summaryMappings": {
                    "low_structured": [
                        {
                            "codeSegments": [
                                {
                                    "line": 75,
                                    "code": "X, y, group, df = load_data()"
                                },
                                {
                                    "line": 78,
                                    "code": "unique_years = df[\"Year\"].unique()"
                                },
                                {
                                    "line": 79,
                                    "code": "train_years, test_years = ("
                                },
                                {
                                    "line": 84,
                                    "code": "train_idx = df[\"Year\"].isin(train_years)"
                                },
                                {
                                    "line": 85,
                                    "code": "test_idx = df[\"Year\"].isin(test_years)"
                                },
                                {
                                    "line": 87,
                                    "code": "X_train, X_test = X[train_idx], X[test_idx]"
                                },
                                {
                                    "line": 88,
                                    "code": "y_train, y_test = y[train_idx], y[test_idx]"
                                }
                            ],
                            "summaryComponent": "Loads data and splits it into training and testing sets"
                        },
                        {
                            "codeSegments": [
                                {
                                    "line": 100,
                                    "code": "n_estimators_list = [100, 1000, 2000]"
                                },
                                {
                                    "line": 101,
                                    "code": "for n_estimators in n_estimators_list:"
                                },
                                {
                                    "line": 102,
                                    "code": "model = XGBRanker("
                                },
                                {
                                    "line": 110,
                                    "code": "model.fit(X_train, y_train, group=train_groups)"
                                },
                                {
                                    "line": 112,
                                    "code": "ndcg = evaluate_ndcg(y_test.to_numpy(), y_pred, test_groups)"
                                },
                                {
                                    "line": 114,
                                    "code": "if ndcg > best_ndcg:"
                                },
                                {
                                    "line": 115,
                                    "code": "best_ndcg = ndcg"
                                },
                                {
                                    "line": 116,
                                    "code": "best_model = model"
                                },
                                {
                                    "line": 117,
                                    "code": "best_n_estimators = n_estimators"
                                },
                                {
                                    "line": 118,
                                    "code": "best_y_pred = y_pred"
                                }
                            ],
                            "summaryComponent": "Trains multiple XGBoost ranking models with varying n_estimators and selects the best one based on NDCG score"
                        },
                        {
                            "codeSegments": [
                                {
                                    "line": 131,
                                    "code": "print(df[test_idx][[\"Year\", \"Name\", \"Rank\", \"PredictedScore\", \"PredictedRank\"]])"
                                },
                                {
                                    "line": 132,
                                    "code": "plot_ranking_predictions(df, 2024)"
                                },
                                {
                                    "line": 133,
                                    "code": "plot_ranking_predictions(df, 2025)"
                                }
                            ],
                            "summaryComponent": "Outputs and visualizes prediction results"
                        }
                    ],
                    "high_structured": [
                        {
                            "codeSegments": [
                                {
                                    "line": 75,
                                    "code": "X, y, group, df = load_data()"
                                }
                            ],
                            "summaryComponent": "Loads data and extracts features, labels, and group sizes"
                        },
                        {
                            "codeSegments": [
                                {
                                    "line": 78,
                                    "code": "unique_years = df[\"Year\"].unique()"
                                },
                                {
                                    "line": 79,
                                    "code": "train_years, test_years = ("
                                },
                                {
                                    "line": 80,
                                    "code": "unique_years[:-2],  # train: 2015-2023"
                                },
                                {
                                    "line": 81,
                                    "code": "unique_years[-2:],  # test: 2024-2025"
                                }
                            ],
                            "summaryComponent": "Splits data into training (all but last two years) and testing (last two years) sets"
                        },
                        {
                            "codeSegments": [
                                {
                                    "line": 84,
                                    "code": "train_idx = df[\"Year\"].isin(train_years)"
                                },
                                {
                                    "line": 85,
                                    "code": "test_idx = df[\"Year\"].isin(test_years)"
                                }
                            ],
                            "summaryComponent": "Identifies indices for training and testing based on year"
                        },
                        {
                            "codeSegments": [
                                {
                                    "line": 87,
                                    "code": "X_train, X_test = X[train_idx], X[test_idx]"
                                },
                                {
                                    "line": 88,
                                    "code": "y_train, y_test = y[train_idx], y[test_idx]"
                                }
                            ],
                            "summaryComponent": "Separates features and labels accordingly"
                        },
                        {
                            "codeSegments": [
                                {
                                    "line": 91,
                                    "code": "train_groups = df[train_idx].groupby(\"Year\").size().to_numpy()"
                                },
                                {
                                    "line": 92,
                                    "code": "test_groups = df[test_idx].groupby(\"Year\").size().to_numpy()"
                                }
                            ],
                            "summaryComponent": "Computes group sizes for both training and test sets for ranking purposes"
                        },
                        {
                            "codeSegments": [
                                {
                                    "line": 100,
                                    "code": "n_estimators_list = [100, 1000, 2000]"
                                },
                                {
                                    "line": 101,
                                    "code": "for n_estimators in n_estimators_list:"
                                },
                                {
                                    "line": 102,
                                    "code": "model = XGBRanker("
                                },
                                {
                                    "line": 105,
                                    "code": "n_estimators=n_estimators,"
                                }
                            ],
                            "summaryComponent": "Initializes and configures multiple XGBoost ranking models with different n_estimators values"
                        },
                        {
                            "codeSegments": [
                                {
                                    "line": 110,
                                    "code": "model.fit(X_train, y_train, group=train_groups)"
                                }
                            ],
                            "summaryComponent": "Trains each model on the training data using group information"
                        },
                        {
                            "codeSegments": [
                                {
                                    "line": 112,
                                    "code": "ndcg = evaluate_ndcg(y_test.to_numpy(), y_pred, test_groups)"
                                },
                                {
                                    "line": 114,
                                    "code": "if ndcg > best_ndcg:"
                                },
                                {
                                    "line": 115,
                                    "code": "best_ndcg = ndcg"
                                },
                                {
                                    "line": 116,
                                    "code": "best_model = model"
                                },
                                {
                                    "line": 117,
                                    "code": "best_n_estimators = n_estimators"
                                },
                                {
                                    "line": 118,
                                    "code": "best_y_pred = y_pred"
                                }
                            ],
                            "summaryComponent": "Evaluates each model using the NDCG metric on the test set and selects the best-performing model"
                        },
                        {
                            "codeSegments": [
                                {
                                    "line": 123,
                                    "code": "df.loc[test_idx, \"PredictedScore\"] = best_y_pred"
                                }
                            ],
                            "summaryComponent": "Predicts ranking scores for the test set using the best model"
                        },
                        {
                            "codeSegments": [
                                {
                                    "line": 124,
                                    "code": "df.loc[test_idx, \"PredictedRank\"] = ("
                                },
                                {
                                    "line": 125,
                                    "code": "df.loc[test_idx]"
                                },
                                {
                                    "line": 126,
                                    "code": ".groupby(\"Year\")[\"PredictedScore\"]"
                                },
                                {
                                    "line": 127,
                                    "code": ".rank(ascending=False, method=\"first\")"
                                }
                            ],
                            "summaryComponent": "Assigns predicted scores and computes predicted ranks within each year"
                        },
                        {
                            "codeSegments": [
                                {
                                    "line": 131,
                                    "code": "print(df[test_idx][[\"Year\", \"Name\", \"Rank\", \"PredictedScore\", \"PredictedRank\"]])"
                                }
                            ],
                            "summaryComponent": "Prints detailed prediction results (year, name, true rank, predicted score, predicted rank)"
                        },
                        {
                            "codeSegments": [
                                {
                                    "line": 132,
                                    "code": "plot_ranking_predictions(df, 2024)"
                                },
                                {
                                    "line": 133,
                                    "code": "plot_ranking_predictions(df, 2025)"
                                }
                            ],
                            "summaryComponent": "Visualizes prediction errors for the years 2024 and 2025 using bar plots"
                        }
                    ],
                    "medium_structured": [
                        {
                            "codeSegments": [
                                {
                                    "line": 75,
                                    "code": "X, y, group, df = load_data()"
                                },
                                {
                                    "line": 78,
                                    "code": "unique_years = df[\"Year\"].unique()"
                                },
                                {
                                    "line": 79,
                                    "code": "train_years, test_years = (\n    unique_years[:-2],  # train: 2015-2023\n    unique_years[-2:],  # test: 2024-2025\n)"
                                },
                                {
                                    "line": 84,
                                    "code": "train_idx = df[\"Year\"].isin(train_years)"
                                },
                                {
                                    "line": 85,
                                    "code": "test_idx = df[\"Year\"].isin(test_years)"
                                },
                                {
                                    "line": 87,
                                    "code": "X_train, X_test = X[train_idx], X[test_idx]"
                                },
                                {
                                    "line": 88,
                                    "code": "y_train, y_test = y[train_idx], y[test_idx]"
                                }
                            ],
                            "summaryComponent": "Loads data and splits it into training (past years) and testing (recent years) sets"
                        },
                        {
                            "codeSegments": [
                                {
                                    "line": 100,
                                    "code": "n_estimators_list = [100, 1000, 2000]"
                                },
                                {
                                    "line": 101,
                                    "code": "for n_estimators in n_estimators_list:"
                                },
                                {
                                    "line": 102,
                                    "code": "model = XGBRanker(\n    objective=\"rank:pairwise\",\n    learning_rate=0.1,\n    n_estimators=n_estimators,\n    max_depth=4,\n    random_state=42,\n)"
                                },
                                {
                                    "line": 110,
                                    "code": "model.fit(X_train, y_train, group=train_groups)"
                                }
                            ],
                            "summaryComponent": "Trains multiple XGBoost ranking models on the training data with different n_estimators values"
                        },
                        {
                            "codeSegments": [
                                {
                                    "line": 112,
                                    "code": "ndcg = evaluate_ndcg(y_test.to_numpy(), y_pred, test_groups)"
                                },
                                {
                                    "line": 114,
                                    "code": "if ndcg > best_ndcg:"
                                },
                                {
                                    "line": 115,
                                    "code": "best_ndcg = ndcg"
                                },
                                {
                                    "line": 116,
                                    "code": "best_model = model"
                                },
                                {
                                    "line": 117,
                                    "code": "best_n_estimators = n_estimators"
                                },
                                {
                                    "line": 118,
                                    "code": "best_y_pred = y_pred"
                                }
                            ],
                            "summaryComponent": "Selects the best model based on NDCG score"
                        },
                        {
                            "codeSegments": [
                                {
                                    "line": 123,
                                    "code": "df.loc[test_idx, \"PredictedScore\"] = best_y_pred"
                                },
                                {
                                    "line": 124,
                                    "code": "df.loc[test_idx, \"PredictedRank\"] = (\n    df.loc[test_idx]\n    .groupby(\"Year\")[\"PredictedScore\"]\n    .rank(ascending=False, method=\"first\")\n)"
                                }
                            ],
                            "summaryComponent": "Predicts and assigns ranking scores for the test years using the best model"
                        },
                        {
                            "codeSegments": [
                                {
                                    "line": 112,
                                    "code": "ndcg = evaluate_ndcg(y_test.to_numpy(), y_pred, test_groups)"
                                },
                                {
                                    "line": 113,
                                    "code": "print(f\"NDCG Score with n_estimators={n_estimators} on test years {test_years.tolist()}: {ndcg:.4f}\")"
                                },
                                {
                                    "line": 120,
                                    "code": "print(f\"Best n_estimators: {best_n_estimators} with NDCG Score: {best_ndcg:.4f}\")"
                                }
                            ],
                            "summaryComponent": "Evaluates model performance using the NDCG metric"
                        },
                        {
                            "codeSegments": [
                                {
                                    "line": 131,
                                    "code": "print(df[test_idx][[\"Year\", \"Name\", \"Rank\", \"PredictedScore\", \"PredictedRank\"]])"
                                },
                                {
                                    "line": 132,
                                    "code": "plot_ranking_predictions(df, 2024)"
                                },
                                {
                                    "line": 133,
                                    "code": "plot_ranking_predictions(df, 2025)"
                                }
                            ],
                            "summaryComponent": "Prints and visualizes the prediction results for the test years"
                        }
                    ],
                    "medium_unstructured": [
                        {
                            "codeSegments": [
                                {
                                    "line": 74,
                                    "code": "def main():"
                                },
                                {
                                    "line": 75,
                                    "code": "X, y, group, df = load_data()"
                                }
                            ],
                            "summaryComponent": "The main() function orchestrates the process of loading MVP ranking data"
                        },
                        {
                            "codeSegments": [
                                {
                                    "line": 78,
                                    "code": "unique_years = df[\"Year\"].unique()"
                                },
                                {
                                    "line": 79,
                                    "code": "train_years, test_years = ("
                                },
                                {
                                    "line": 84,
                                    "code": "train_idx = df[\"Year\"].isin(train_years)"
                                },
                                {
                                    "line": 85,
                                    "code": "test_idx = df[\"Year\"].isin(test_years)"
                                },
                                {
                                    "line": 87,
                                    "code": "X_train, X_test = X[train_idx], X[test_idx]"
                                },
                                {
                                    "line": 88,
                                    "code": "y_train, y_test = y[train_idx], y[test_idx]"
                                }
                            ],
                            "summaryComponent": "splitting it into training and test sets based on years"
                        },
                        {
                            "codeSegments": [
                                {
                                    "line": 100,
                                    "code": "n_estimators_list = [100, 1000, 2000]"
                                },
                                {
                                    "line": 101,
                                    "code": "for n_estimators in n_estimators_list:"
                                },
                                {
                                    "line": 102,
                                    "code": "model = XGBRanker("
                                }
                            ],
                            "summaryComponent": "training several XGBoost ranking models with different n_estimators values"
                        },
                        {
                            "codeSegments": [
                                {
                                    "line": 114,
                                    "code": "if ndcg > best_ndcg:"
                                },
                                {
                                    "line": 115,
                                    "code": "best_ndcg = ndcg"
                                },
                                {
                                    "line": 116,
                                    "code": "best_model = model"
                                },
                                {
                                    "line": 117,
                                    "code": "best_n_estimators = n_estimators"
                                },
                                {
                                    "line": 118,
                                    "code": "best_y_pred = y_pred"
                                }
                            ],
                            "summaryComponent": "It selects the model with the highest NDCG score"
                        },
                        {
                            "codeSegments": [
                                {
                                    "line": 123,
                                    "code": "df.loc[test_idx, \"PredictedScore\"] = best_y_pred"
                                },
                                {
                                    "line": 124,
                                    "code": "df.loc[test_idx, \"PredictedRank\"] = ("
                                }
                            ],
                            "summaryComponent": "predicts rankings for the test years"
                        },
                        {
                            "codeSegments": [
                                {
                                    "line": 112,
                                    "code": "ndcg = evaluate_ndcg(y_test.to_numpy(), y_pred, test_groups)"
                                }
                            ],
                            "summaryComponent": "evaluates the model using the NDCG metric"
                        },
                        {
                            "codeSegments": [
                                {
                                    "line": 131,
                                    "code": "print(df[test_idx][[\"Year\", \"Name\", \"Rank\", \"PredictedScore\", \"PredictedRank\"]])"
                                },
                                {
                                    "line": 132,
                                    "code": "plot_ranking_predictions(df, 2024)"
                                },
                                {
                                    "line": 133,
                                    "code": "plot_ranking_predictions(df, 2025)"
                                }
                            ],
                            "summaryComponent": "and prints as well as visualizes the results for the most recent years"
                        },
                        {
                            "codeSegments": [
                                {
                                    "line": 131,
                                    "code": "print(df[test_idx][[\"Year\", \"Name\", \"Rank\", \"PredictedScore\", \"PredictedRank\"]])"
                                },
                                {
                                    "line": 132,
                                    "code": "plot_ranking_predictions(df, 2024)"
                                },
                                {
                                    "line": 133,
                                    "code": "plot_ranking_predictions(df, 2025)"
                                }
                            ],
                            "summaryComponent": "This workflow enables assessment and visualization of the model's ranking performance."
                        }
                    ],
                    "high_unstructured": [
                        {
                            "codeSegments": [
                                {
                                    "line": 74,
                                    "code": "def main():"
                                },
                                {
                                    "line": 75,
                                    "code": "X, y, group, df = load_data()"
                                }
                            ],
                            "summaryComponent": "The main() function begins by loading the dataset and extracting features, labels, and group information."
                        },
                        {
                            "codeSegments": [
                                {
                                    "line": 78,
                                    "code": "unique_years = df[\"Year\"].unique()"
                                },
                                {
                                    "line": 79,
                                    "code": "train_years, test_years = ("
                                },
                                {
                                    "line": 80,
                                    "code": "unique_years[:-2],  # train: 2015-2023"
                                },
                                {
                                    "line": 81,
                                    "code": "unique_years[-2:],  # test: 2024-2025"
                                },
                                {
                                    "line": 84,
                                    "code": "train_idx = df[\"Year\"].isin(train_years)"
                                },
                                {
                                    "line": 85,
                                    "code": "test_idx = df[\"Year\"].isin(test_years)"
                                },
                                {
                                    "line": 87,
                                    "code": "X_train, X_test = X[train_idx], X[test_idx]"
                                },
                                {
                                    "line": 88,
                                    "code": "y_train, y_test = y[train_idx], y[test_idx]"
                                }
                            ],
                            "summaryComponent": "It then splits the data into training and testing sets based on year, with the most recent two years reserved for testing."
                        },
                        {
                            "codeSegments": [
                                {
                                    "line": 100,
                                    "code": "n_estimators_list = [100, 1000, 2000]"
                                },
                                {
                                    "line": 101,
                                    "code": "for n_estimators in n_estimators_list:"
                                },
                                {
                                    "line": 102,
                                    "code": "model = XGBRanker("
                                },
                                {
                                    "line": 105,
                                    "code": "n_estimators=n_estimators,"
                                },
                                {
                                    "line": 110,
                                    "code": "model.fit(X_train, y_train, group=train_groups)"
                                }
                            ],
                            "summaryComponent": "Multiple XGBoost ranking models are configured and trained on the training data, each with a different n_estimators value."
                        },
                        {
                            "codeSegments": [
                                {
                                    "line": 112,
                                    "code": "ndcg = evaluate_ndcg(y_test.to_numpy(), y_pred, test_groups)"
                                }
                            ],
                            "summaryComponent": "The function evaluates each model's performance using the NDCG metric,"
                        },
                        {
                            "codeSegments": [
                                {
                                    "line": 114,
                                    "code": "if ndcg > best_ndcg:"
                                },
                                {
                                    "line": 115,
                                    "code": "best_ndcg = ndcg"
                                },
                                {
                                    "line": 116,
                                    "code": "best_model = model"
                                },
                                {
                                    "line": 117,
                                    "code": "best_n_estimators = n_estimators"
                                },
                                {
                                    "line": 118,
                                    "code": "best_y_pred = y_pred"
                                }
                            ],
                            "summaryComponent": "selects the best-performing model,"
                        },
                        {
                            "codeSegments": [
                                {
                                    "line": 131,
                                    "code": "print(df[test_idx][[\"Year\", \"Name\", \"Rank\", \"PredictedScore\", \"PredictedRank\"]])"
                                }
                            ],
                            "summaryComponent": "prints detailed prediction results for each player in the test years,"
                        },
                        {
                            "codeSegments": [
                                {
                                    "line": 132,
                                    "code": "plot_ranking_predictions(df, 2024)"
                                },
                                {
                                    "line": 133,
                                    "code": "plot_ranking_predictions(df, 2025)"
                                }
                            ],
                            "summaryComponent": "and generates bar plots visualizing prediction errors for the years 2024 and 2025."
                        }
                    ],
                    "low_unstructured": [
                        {
                            "codeSegments": [
                                {
                                    "line": 75,
                                    "code": "X, y, group, df = load_data()"
                                }
                            ],
                            "summaryComponent": "loads data"
                        },
                        {
                            "codeSegments": [
                                {
                                    "line": 78,
                                    "code": "unique_years = df[\"Year\"].unique()"
                                },
                                {
                                    "line": 79,
                                    "code": "train_years, test_years = ("
                                },
                                {
                                    "line": 84,
                                    "code": "train_idx = df[\"Year\"].isin(train_years)"
                                },
                                {
                                    "line": 85,
                                    "code": "test_idx = df[\"Year\"].isin(test_years)"
                                },
                                {
                                    "line": 87,
                                    "code": "X_train, X_test = X[train_idx], X[test_idx]"
                                },
                                {
                                    "line": 88,
                                    "code": "y_train, y_test = y[train_idx], y[test_idx]"
                                }
                            ],
                            "summaryComponent": "splits it into training and testing sets"
                        },
                        {
                            "codeSegments": [
                                {
                                    "line": 100,
                                    "code": "n_estimators_list = [100, 1000, 2000]"
                                },
                                {
                                    "line": 101,
                                    "code": "for n_estimators in n_estimators_list:"
                                },
                                {
                                    "line": 102,
                                    "code": "model = XGBRanker("
                                },
                                {
                                    "line": 110,
                                    "code": "model.fit(X_train, y_train, group=train_groups)"
                                }
                            ],
                            "summaryComponent": "trains multiple XGBoost ranking models with different n_estimators values"
                        },
                        {
                            "codeSegments": [
                                {
                                    "line": 112,
                                    "code": "ndcg = evaluate_ndcg(y_test.to_numpy(), y_pred, test_groups)"
                                },
                                {
                                    "line": 114,
                                    "code": "if ndcg > best_ndcg:"
                                },
                                {
                                    "line": 115,
                                    "code": "best_ndcg = ndcg"
                                },
                                {
                                    "line": 116,
                                    "code": "best_model = model"
                                },
                                {
                                    "line": 117,
                                    "code": "best_n_estimators = n_estimators"
                                },
                                {
                                    "line": 118,
                                    "code": "best_y_pred = y_pred"
                                }
                            ],
                            "summaryComponent": "selects the best model based on NDCG score"
                        },
                        {
                            "codeSegments": [
                                {
                                    "line": 132,
                                    "code": "plot_ranking_predictions(df, 2024)"
                                },
                                {
                                    "line": 133,
                                    "code": "plot_ranking_predictions(df, 2025)"
                                }
                            ],
                            "summaryComponent": "visualizes prediction results for recent years"
                        }
                    ]
                },
                "oldSummaryData": {
                    "high_unstructured": "The main() function begins by loading the dataset and extracting features, labels, and group information. It then splits the data into training and testing sets based on year, with the most recent two years reserved for testing. An XGBoost ranking model is configured and trained on the training data, after which it predicts scores for the test set. The function evaluates the model's performance using the NDCG metric, prints detailed prediction results for each player in the test years, and generates bar plots visualizing prediction errors for the years 2024 and 2025.",
                    "low_structured": "• Loads data and splits it into training and testing sets\n• Trains an XGBoost ranking model and evaluates it\n• Outputs and visualizes prediction results",
                    "high_structured": "• Loads data and extracts features, labels, and group sizes\n• Splits data into training (all but last two years) and testing (last two years) sets\n  ◦ Identifies indices for training and testing based on year\n  ◦ Separates features and labels accordingly\n• Computes group sizes for both training and test sets for ranking purposes\n• Initializes and configures an XGBoost ranking model with specified hyperparameters\n• Trains the model on the training data using group information\n• Predicts ranking scores for the test set\n  ◦ Assigns predicted scores and computes predicted ranks within each year\n• Evaluates the model using the NDCG metric on the test set\n• Prints detailed prediction results (year, name, true rank, predicted score, predicted rank)\n• Visualizes prediction errors for the years 2024 and 2025 using bar plots",
                    "title": "Summary of the main() Function for MVP Ranking Prediction",
                    "medium_unstructured": "The main() function orchestrates the process of loading MVP ranking data, splitting it into training and test sets based on years, and training an XGBoost ranking model. It predicts rankings for the test years, evaluates the model using the NDCG metric, and prints as well as visualizes the results for the most recent years. This workflow enables assessment and visualization of the model's ranking performance.",
                    "medium_structured": "• Loads data and splits it into training (past years) and testing (recent years) sets\n• Trains an XGBoost ranking model on the training data\n• Predicts and assigns ranking scores for the test years\n• Evaluates model performance using the NDCG metric\n• Prints and visualizes the prediction results for the test years",
                    "low_unstructured": "This function loads data, trains an XGBoost ranking model, evaluates its performance, and visualizes prediction results for recent years."
                },
                "metadata": {
                    "id": "7dcb4dfb-9fc5-4331-a999-9ca5f71a37eb",
                    "filename": "rank_model.py",
                    "offset": 1952,
                    "fullPath": "/project/workspace/rank_model.py",
                    "originalCode": "def main():\n    X, y, group, df = load_data()\n\n    # Train-test split on years\n    unique_years = df[\"Year\"].unique()\n    train_years, test_years = (\n        unique_years[:-2],  # train: 2015-2023\n        unique_years[-2:],  # test: 2024-2025\n    )\n\n    train_idx = df[\"Year\"].isin(train_years)\n    test_idx = df[\"Year\"].isin(test_years)\n\n    X_train, X_test = X[train_idx], X[test_idx]\n    y_train, y_test = y[train_idx], y[test_idx]\n\n    # Group sizes\n    train_groups = df[train_idx].groupby(\"Year\").size().to_numpy()\n    test_groups = df[test_idx].groupby(\"Year\").size().to_numpy()\n\n    # Model selection: try different n_estimators\n    best_ndcg = -np.inf\n    best_model = None\n    best_n_estimators = None\n    best_y_pred = None\n\n    n_estimators_list = [100, 1000, 2000]\n    for n_estimators in n_estimators_list:\n        model = XGBRanker(\n            objective=\"rank:pairwise\",\n            learning_rate=0.1,\n            n_estimators=n_estimators,\n            max_depth=4,\n            random_state=42,\n        )\n        print(f\"Training XGBoostRanker with n_estimators={n_estimators}...\")\n        model.fit(X_train, y_train, group=train_groups)\n        y_pred = model.predict(X_test)\n        ndcg = evaluate_ndcg(y_test.to_numpy(), y_pred, test_groups)\n        print(f\"NDCG Score with n_estimators={n_estimators} on test years {test_years.tolist()}: {ndcg:.4f}\")\n        if ndcg > best_ndcg:\n            best_ndcg = ndcg\n            best_model = model\n            best_n_estimators = n_estimators\n            best_y_pred = y_pred\n\n    print(f\"Best n_estimators: {best_n_estimators} with NDCG Score: {best_ndcg:.4f}\")\n\n    # Assign predicted scores and ranks using the best model\n    df.loc[test_idx, \"PredictedScore\"] = best_y_pred\n    df.loc[test_idx, \"PredictedRank\"] = (\n        df.loc[test_idx]\n        .groupby(\"Year\")[\"PredictedScore\"]\n        .rank(ascending=False, method=\"first\")\n    )\n\n    # Show results\n    print(df[test_idx][[\"Year\", \"Name\", \"Rank\", \"PredictedScore\", \"PredictedRank\"]])\n    plot_ranking_predictions(df, 2024)\n    plot_ranking_predictions(df, 2025)"
                },
                "createdAt": 1755987747000,
                "lines": [
                    74,
                    133
                ],
                "editPromptStructured": null,
                "selectedStructured": "unstructured",
                "editPromptDetailLevel": null
            },
            "section_id": "7dcb4dfb-9fc5-4331-a999-9ca5f71a37eb"
        },
        "event": "create_new_section",
        "id": "EDjGRvSs4VUl5ucScdwM"
    },
    {
        "source": "backend",
        "timestamp": "2025-08-23 14:22:26.000",
        "data": {
            "summary": "• Loads data and splits it into training (past years) and testing (recent years) sets\n• Trains multiple XGBoost ranking models on the training data with different n_estimators values\n• Selects the best model based on NDCG score\n• Predicts and assigns ranking scores for the test years using the best model\n• Evaluates model performance using the NDCG metric\n• Prints and visualizes the prediction results for the test years",
            "code": "74: def main():\n75:     X, y, group, df = load_data()\n76: \n77:     # Train-test split on years\n78:     unique_years = df[\"Year\"].unique()\n79:     train_years, test_years = (\n80:         unique_years[:-2],  # train: 2015-2023\n81:         unique_years[-2:],  # test: 2024-2025\n82:     )\n83: \n84:     train_idx = df[\"Year\"].isin(train_years)\n85:     test_idx = df[\"Year\"].isin(test_years)\n86: \n87:     X_train, X_test = X[train_idx], X[test_idx]\n88:     y_train, y_test = y[train_idx], y[test_idx]\n89: \n90:     # Group sizes\n91:     train_groups = df[train_idx].groupby(\"Year\").size().to_numpy()\n92:     test_groups = df[test_idx].groupby(\"Year\").size().to_numpy()\n93: \n94:     # Model selection: try different n_estimators\n95:     best_ndcg = -np.inf\n96:     best_model = None\n97:     best_n_estimators = None\n98:     best_y_pred = None\n99: \n100:     n_estimators_list = [100, 1000, 2000]\n101:     for n_estimators in n_estimators_list:\n102:         model = XGBRanker(\n103:             objective=\"rank:pairwise\",\n104:             learning_rate=0.1,\n105:             n_estimators=n_estimators,\n106:             max_depth=4,\n107:             random_state=42,\n108:         )\n109:         print(f\"Training XGBoostRanker with n_estimators={n_estimators}...\")\n110:         model.fit(X_train, y_train, group=train_groups)\n111:         y_pred = model.predict(X_test)\n112:         ndcg = evaluate_ndcg(y_test.to_numpy(), y_pred, test_groups)\n113:         print(f\"NDCG Score with n_estimators={n_estimators} on test years {test_years.tolist()}: {ndcg:.4f}\")\n114:         if ndcg > best_ndcg:\n115:             best_ndcg = ndcg\n116:             best_model = model\n117:             best_n_estimators = n_estimators\n118:             best_y_pred = y_pred\n119: \n120:     print(f\"Best n_estimators: {best_n_estimators} with NDCG Score: {best_ndcg:.4f}\")\n121: \n122:     # Assign predicted scores and ranks using the best model\n123:     df.loc[test_idx, \"PredictedScore\"] = best_y_pred\n124:     df.loc[test_idx, \"PredictedRank\"] = (\n125:         df.loc[test_idx]\n126:         .groupby(\"Year\")[\"PredictedScore\"]\n127:         .rank(ascending=False, method=\"first\")\n128:     )\n129: \n130:     # Show results\n131:     print(df[test_idx][[\"Year\", \"Name\", \"Rank\", \"PredictedScore\", \"PredictedRank\"]])\n132:     plot_ranking_predictions(df, 2024)\n133:     plot_ranking_predictions(df, 2025)",
            "mapping": [
                {
                    "codeSegments": [
                        {
                            "line": 75,
                            "code": "X, y, group, df = load_data()"
                        },
                        {
                            "line": 78,
                            "code": "unique_years = df[\"Year\"].unique()"
                        },
                        {
                            "line": 79,
                            "code": "train_years, test_years = (\n    unique_years[:-2],  # train: 2015-2023\n    unique_years[-2:],  # test: 2024-2025\n)"
                        },
                        {
                            "line": 84,
                            "code": "train_idx = df[\"Year\"].isin(train_years)"
                        },
                        {
                            "line": 85,
                            "code": "test_idx = df[\"Year\"].isin(test_years)"
                        },
                        {
                            "line": 87,
                            "code": "X_train, X_test = X[train_idx], X[test_idx]"
                        },
                        {
                            "line": 88,
                            "code": "y_train, y_test = y[train_idx], y[test_idx]"
                        }
                    ],
                    "summaryComponent": "Loads data and splits it into training (past years) and testing (recent years) sets"
                },
                {
                    "codeSegments": [
                        {
                            "line": 100,
                            "code": "n_estimators_list = [100, 1000, 2000]"
                        },
                        {
                            "line": 101,
                            "code": "for n_estimators in n_estimators_list:"
                        },
                        {
                            "line": 102,
                            "code": "model = XGBRanker(\n    objective=\"rank:pairwise\",\n    learning_rate=0.1,\n    n_estimators=n_estimators,\n    max_depth=4,\n    random_state=42,\n)"
                        },
                        {
                            "line": 110,
                            "code": "model.fit(X_train, y_train, group=train_groups)"
                        }
                    ],
                    "summaryComponent": "Trains multiple XGBoost ranking models on the training data with different n_estimators values"
                },
                {
                    "codeSegments": [
                        {
                            "line": 112,
                            "code": "ndcg = evaluate_ndcg(y_test.to_numpy(), y_pred, test_groups)"
                        },
                        {
                            "line": 114,
                            "code": "if ndcg > best_ndcg:"
                        },
                        {
                            "line": 115,
                            "code": "best_ndcg = ndcg"
                        },
                        {
                            "line": 116,
                            "code": "best_model = model"
                        },
                        {
                            "line": 117,
                            "code": "best_n_estimators = n_estimators"
                        },
                        {
                            "line": 118,
                            "code": "best_y_pred = y_pred"
                        }
                    ],
                    "summaryComponent": "Selects the best model based on NDCG score"
                },
                {
                    "codeSegments": [
                        {
                            "line": 123,
                            "code": "df.loc[test_idx, \"PredictedScore\"] = best_y_pred"
                        },
                        {
                            "line": 124,
                            "code": "df.loc[test_idx, \"PredictedRank\"] = (\n    df.loc[test_idx]\n    .groupby(\"Year\")[\"PredictedScore\"]\n    .rank(ascending=False, method=\"first\")\n)"
                        }
                    ],
                    "summaryComponent": "Predicts and assigns ranking scores for the test years using the best model"
                },
                {
                    "codeSegments": [
                        {
                            "line": 112,
                            "code": "ndcg = evaluate_ndcg(y_test.to_numpy(), y_pred, test_groups)"
                        },
                        {
                            "line": 113,
                            "code": "print(f\"NDCG Score with n_estimators={n_estimators} on test years {test_years.tolist()}: {ndcg:.4f}\")"
                        },
                        {
                            "line": 120,
                            "code": "print(f\"Best n_estimators: {best_n_estimators} with NDCG Score: {best_ndcg:.4f}\")"
                        }
                    ],
                    "summaryComponent": "Evaluates model performance using the NDCG metric"
                },
                {
                    "codeSegments": [
                        {
                            "line": 131,
                            "code": "print(df[test_idx][[\"Year\", \"Name\", \"Rank\", \"PredictedScore\", \"PredictedRank\"]])"
                        },
                        {
                            "line": 132,
                            "code": "plot_ranking_predictions(df, 2024)"
                        },
                        {
                            "line": 133,
                            "code": "plot_ranking_predictions(df, 2025)"
                        }
                    ],
                    "summaryComponent": "Prints and visualizes the prediction results for the test years"
                }
            ]
        },
        "event": "map_summary_code",
        "id": "Ebt8Dktiji2jf62v4TvF"
    },
    {
        "source": "backend",
        "timestamp": "2025-08-23 14:22:27.000",
        "data": {
            "summary": "• Loads data and extracts features, labels, and group sizes\n• Splits data into training (all but last two years) and testing (last two years) sets\n  ◦ Identifies indices for training and testing based on year\n  ◦ Separates features and labels accordingly\n• Computes group sizes for both training and test sets for ranking purposes\n• Initializes and configures multiple XGBoost ranking models with different n_estimators values\n• Trains each model on the training data using group information\n• Evaluates each model using the NDCG metric on the test set and selects the best-performing model\n• Predicts ranking scores for the test set using the best model\n  ◦ Assigns predicted scores and computes predicted ranks within each year\n• Prints detailed prediction results (year, name, true rank, predicted score, predicted rank)\n• Visualizes prediction errors for the years 2024 and 2025 using bar plots",
            "code": "74: def main():\n75:     X, y, group, df = load_data()\n76: \n77:     # Train-test split on years\n78:     unique_years = df[\"Year\"].unique()\n79:     train_years, test_years = (\n80:         unique_years[:-2],  # train: 2015-2023\n81:         unique_years[-2:],  # test: 2024-2025\n82:     )\n83: \n84:     train_idx = df[\"Year\"].isin(train_years)\n85:     test_idx = df[\"Year\"].isin(test_years)\n86: \n87:     X_train, X_test = X[train_idx], X[test_idx]\n88:     y_train, y_test = y[train_idx], y[test_idx]\n89: \n90:     # Group sizes\n91:     train_groups = df[train_idx].groupby(\"Year\").size().to_numpy()\n92:     test_groups = df[test_idx].groupby(\"Year\").size().to_numpy()\n93: \n94:     # Model selection: try different n_estimators\n95:     best_ndcg = -np.inf\n96:     best_model = None\n97:     best_n_estimators = None\n98:     best_y_pred = None\n99: \n100:     n_estimators_list = [100, 1000, 2000]\n101:     for n_estimators in n_estimators_list:\n102:         model = XGBRanker(\n103:             objective=\"rank:pairwise\",\n104:             learning_rate=0.1,\n105:             n_estimators=n_estimators,\n106:             max_depth=4,\n107:             random_state=42,\n108:         )\n109:         print(f\"Training XGBoostRanker with n_estimators={n_estimators}...\")\n110:         model.fit(X_train, y_train, group=train_groups)\n111:         y_pred = model.predict(X_test)\n112:         ndcg = evaluate_ndcg(y_test.to_numpy(), y_pred, test_groups)\n113:         print(f\"NDCG Score with n_estimators={n_estimators} on test years {test_years.tolist()}: {ndcg:.4f}\")\n114:         if ndcg > best_ndcg:\n115:             best_ndcg = ndcg\n116:             best_model = model\n117:             best_n_estimators = n_estimators\n118:             best_y_pred = y_pred\n119: \n120:     print(f\"Best n_estimators: {best_n_estimators} with NDCG Score: {best_ndcg:.4f}\")\n121: \n122:     # Assign predicted scores and ranks using the best model\n123:     df.loc[test_idx, \"PredictedScore\"] = best_y_pred\n124:     df.loc[test_idx, \"PredictedRank\"] = (\n125:         df.loc[test_idx]\n126:         .groupby(\"Year\")[\"PredictedScore\"]\n127:         .rank(ascending=False, method=\"first\")\n128:     )\n129: \n130:     # Show results\n131:     print(df[test_idx][[\"Year\", \"Name\", \"Rank\", \"PredictedScore\", \"PredictedRank\"]])\n132:     plot_ranking_predictions(df, 2024)\n133:     plot_ranking_predictions(df, 2025)",
            "mapping": [
                {
                    "codeSegments": [
                        {
                            "line": 75,
                            "code": "X, y, group, df = load_data()"
                        }
                    ],
                    "summaryComponent": "Loads data and extracts features, labels, and group sizes"
                },
                {
                    "codeSegments": [
                        {
                            "line": 78,
                            "code": "unique_years = df[\"Year\"].unique()"
                        },
                        {
                            "line": 79,
                            "code": "train_years, test_years = ("
                        },
                        {
                            "line": 80,
                            "code": "unique_years[:-2],  # train: 2015-2023"
                        },
                        {
                            "line": 81,
                            "code": "unique_years[-2:],  # test: 2024-2025"
                        }
                    ],
                    "summaryComponent": "Splits data into training (all but last two years) and testing (last two years) sets"
                },
                {
                    "codeSegments": [
                        {
                            "line": 84,
                            "code": "train_idx = df[\"Year\"].isin(train_years)"
                        },
                        {
                            "line": 85,
                            "code": "test_idx = df[\"Year\"].isin(test_years)"
                        }
                    ],
                    "summaryComponent": "Identifies indices for training and testing based on year"
                },
                {
                    "codeSegments": [
                        {
                            "line": 87,
                            "code": "X_train, X_test = X[train_idx], X[test_idx]"
                        },
                        {
                            "line": 88,
                            "code": "y_train, y_test = y[train_idx], y[test_idx]"
                        }
                    ],
                    "summaryComponent": "Separates features and labels accordingly"
                },
                {
                    "codeSegments": [
                        {
                            "line": 91,
                            "code": "train_groups = df[train_idx].groupby(\"Year\").size().to_numpy()"
                        },
                        {
                            "line": 92,
                            "code": "test_groups = df[test_idx].groupby(\"Year\").size().to_numpy()"
                        }
                    ],
                    "summaryComponent": "Computes group sizes for both training and test sets for ranking purposes"
                },
                {
                    "codeSegments": [
                        {
                            "line": 100,
                            "code": "n_estimators_list = [100, 1000, 2000]"
                        },
                        {
                            "line": 101,
                            "code": "for n_estimators in n_estimators_list:"
                        },
                        {
                            "line": 102,
                            "code": "model = XGBRanker("
                        },
                        {
                            "line": 105,
                            "code": "n_estimators=n_estimators,"
                        }
                    ],
                    "summaryComponent": "Initializes and configures multiple XGBoost ranking models with different n_estimators values"
                },
                {
                    "codeSegments": [
                        {
                            "line": 110,
                            "code": "model.fit(X_train, y_train, group=train_groups)"
                        }
                    ],
                    "summaryComponent": "Trains each model on the training data using group information"
                },
                {
                    "codeSegments": [
                        {
                            "line": 112,
                            "code": "ndcg = evaluate_ndcg(y_test.to_numpy(), y_pred, test_groups)"
                        },
                        {
                            "line": 114,
                            "code": "if ndcg > best_ndcg:"
                        },
                        {
                            "line": 115,
                            "code": "best_ndcg = ndcg"
                        },
                        {
                            "line": 116,
                            "code": "best_model = model"
                        },
                        {
                            "line": 117,
                            "code": "best_n_estimators = n_estimators"
                        },
                        {
                            "line": 118,
                            "code": "best_y_pred = y_pred"
                        }
                    ],
                    "summaryComponent": "Evaluates each model using the NDCG metric on the test set and selects the best-performing model"
                },
                {
                    "codeSegments": [
                        {
                            "line": 123,
                            "code": "df.loc[test_idx, \"PredictedScore\"] = best_y_pred"
                        }
                    ],
                    "summaryComponent": "Predicts ranking scores for the test set using the best model"
                },
                {
                    "codeSegments": [
                        {
                            "line": 124,
                            "code": "df.loc[test_idx, \"PredictedRank\"] = ("
                        },
                        {
                            "line": 125,
                            "code": "df.loc[test_idx]"
                        },
                        {
                            "line": 126,
                            "code": ".groupby(\"Year\")[\"PredictedScore\"]"
                        },
                        {
                            "line": 127,
                            "code": ".rank(ascending=False, method=\"first\")"
                        }
                    ],
                    "summaryComponent": "Assigns predicted scores and computes predicted ranks within each year"
                },
                {
                    "codeSegments": [
                        {
                            "line": 131,
                            "code": "print(df[test_idx][[\"Year\", \"Name\", \"Rank\", \"PredictedScore\", \"PredictedRank\"]])"
                        }
                    ],
                    "summaryComponent": "Prints detailed prediction results (year, name, true rank, predicted score, predicted rank)"
                },
                {
                    "codeSegments": [
                        {
                            "line": 132,
                            "code": "plot_ranking_predictions(df, 2024)"
                        },
                        {
                            "line": 133,
                            "code": "plot_ranking_predictions(df, 2025)"
                        }
                    ],
                    "summaryComponent": "Visualizes prediction errors for the years 2024 and 2025 using bar plots"
                }
            ]
        },
        "event": "map_summary_code",
        "id": "RzGyLjQpV151rWDAjLIA"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:23:21.000",
        "data": {
            "detail_level": "medium",
            "section_id": "7dcb4dfb-9fc5-4331-a999-9ca5f71a37eb",
            "structured_type": "unstructured",
            "mapping_index": 3
        },
        "event": "mapping_hover",
        "id": "l1lwX3E9V01YBPavjsWy"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:23:21.000",
        "data": {
            "detail_level": "medium",
            "section_id": "7dcb4dfb-9fc5-4331-a999-9ca5f71a37eb",
            "structured_type": "unstructured"
        },
        "event": "mapping_unhover",
        "id": "o4p0OwXqjCBsNwdwq17p"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:23:21.000",
        "data": {
            "detail_level": "medium",
            "section_id": "7dcb4dfb-9fc5-4331-a999-9ca5f71a37eb",
            "structured_type": "unstructured",
            "mapping_index": 6
        },
        "event": "mapping_hover",
        "id": "wAm4bHzAMeQtCau3QTla"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:23:21.000",
        "data": {
            "detail_level": "medium",
            "section_id": "7dcb4dfb-9fc5-4331-a999-9ca5f71a37eb",
            "structured_type": "unstructured"
        },
        "event": "mapping_unhover",
        "id": "zwni9mWTls787VK8VvHH"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:23:22.000",
        "data": {
            "detail_level": "medium",
            "section_id": "7dcb4dfb-9fc5-4331-a999-9ca5f71a37eb",
            "structured_type": "unstructured"
        },
        "event": "mapping_unhover",
        "id": "1WkLXPwMevEWYtAYLO8t"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:23:22.000",
        "data": {
            "detail_level": "medium",
            "section_id": "7dcb4dfb-9fc5-4331-a999-9ca5f71a37eb",
            "structured_type": "unstructured",
            "mapping_index": 1
        },
        "event": "mapping_hover",
        "id": "1hebck57O2aqRpkfTJ18"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:23:22.000",
        "data": {
            "detail_level": "medium",
            "section_id": "7dcb4dfb-9fc5-4331-a999-9ca5f71a37eb",
            "structured_type": "unstructured"
        },
        "event": "mapping_unhover",
        "id": "ET6Y8wSRyM79Rabw9xQo"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:23:22.000",
        "data": {
            "detail_level": "medium",
            "section_id": "7dcb4dfb-9fc5-4331-a999-9ca5f71a37eb",
            "structured_type": "unstructured",
            "mapping_index": 2
        },
        "event": "mapping_hover",
        "id": "H3pBoJQpcSmh21Sdu308"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:23:22.000",
        "data": {
            "detail_level": "medium",
            "section_id": "7dcb4dfb-9fc5-4331-a999-9ca5f71a37eb",
            "structured_type": "unstructured"
        },
        "event": "mapping_unhover",
        "id": "InleCgBnhba9eJygJdyI"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:23:22.000",
        "data": {
            "detail_level": "medium",
            "section_id": "7dcb4dfb-9fc5-4331-a999-9ca5f71a37eb",
            "structured_type": "unstructured",
            "mapping_index": 0
        },
        "event": "mapping_hover",
        "id": "Ja6EKHZcbiDViEmbGshr"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:23:22.000",
        "data": {
            "detail_level": "medium",
            "section_id": "7dcb4dfb-9fc5-4331-a999-9ca5f71a37eb",
            "structured_type": "unstructured",
            "mapping_index": 1
        },
        "event": "mapping_hover",
        "id": "L6WM1wBaAZkl5MREUFgw"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:23:22.000",
        "data": {
            "detail_level": "medium",
            "section_id": "7dcb4dfb-9fc5-4331-a999-9ca5f71a37eb",
            "structured_type": "unstructured"
        },
        "event": "mapping_unhover",
        "id": "TctizcS24vF6n2OP4qn8"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:23:22.000",
        "data": {
            "detail_level": "medium",
            "section_id": "7dcb4dfb-9fc5-4331-a999-9ca5f71a37eb",
            "structured_type": "unstructured"
        },
        "event": "mapping_unhover",
        "id": "bkldEf6Ef0ng1jak0uy8"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:23:22.000",
        "data": {
            "detail_level": "medium",
            "section_id": "7dcb4dfb-9fc5-4331-a999-9ca5f71a37eb",
            "structured_type": "unstructured",
            "mapping_index": 4
        },
        "event": "mapping_hover",
        "id": "hdKNE6dbeNysacMJafAi"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:23:22.000",
        "data": {
            "detail_level": "medium",
            "section_id": "7dcb4dfb-9fc5-4331-a999-9ca5f71a37eb",
            "structured_type": "unstructured",
            "mapping_index": 0
        },
        "event": "mapping_hover",
        "id": "iegLCejezE9WyP5uAHQA"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:23:22.000",
        "data": {
            "detail_level": "medium",
            "section_id": "7dcb4dfb-9fc5-4331-a999-9ca5f71a37eb",
            "structured_type": "unstructured",
            "mapping_index": 2
        },
        "event": "mapping_hover",
        "id": "nUiIGiwK1U9LmZB2xeBL"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:23:22.000",
        "data": {
            "detail_level": "medium",
            "section_id": "7dcb4dfb-9fc5-4331-a999-9ca5f71a37eb",
            "structured_type": "unstructured"
        },
        "event": "mapping_unhover",
        "id": "ryyv56KNpQb8pnpCAnoP"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:23:22.000",
        "data": {
            "detail_level": "medium",
            "section_id": "7dcb4dfb-9fc5-4331-a999-9ca5f71a37eb",
            "structured_type": "unstructured"
        },
        "event": "mapping_unhover",
        "id": "sLL4cuWdQrlmqX8MJqdu"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:23:22.000",
        "data": {
            "detail_level": "medium",
            "section_id": "7dcb4dfb-9fc5-4331-a999-9ca5f71a37eb",
            "structured_type": "unstructured",
            "mapping_index": 1
        },
        "event": "mapping_hover",
        "id": "uq1bF6OsIGdhpMTu5uXf"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:23:22.000",
        "data": {
            "detail_level": "medium",
            "section_id": "7dcb4dfb-9fc5-4331-a999-9ca5f71a37eb",
            "structured_type": "unstructured"
        },
        "event": "mapping_unhover",
        "id": "zYWXNTeKuG57ybz6he9U"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:23:23.000",
        "data": {},
        "event": "click_summarize_code",
        "id": "dypCcDp0gzvA5eslIs5e"
    },
    {
        "source": "backend",
        "timestamp": "2025-08-23 14:23:30.000",
        "data": {
            "summary": {
                "high_unstructured": "The plot_ranking_predictions function computes the ranking error for each player by subtracting their true rank from the predicted rank in the provided DataFrame. It filters the data for the specified year, sorts players by their actual rank, and creates a horizontal bar plot where each bar represents a player's prediction error. The plot includes a horizontal line at zero for reference, customizes axis labels and title, and rotates x-axis labels for readability. Finally, it saves the plot as a PNG file in the data directory, named according to the year visualized.",
                "low_structured": "• Plots prediction errors for a given year\n• Saves the plot as a PNG file",
                "high_structured": "• Computes 'RankError' as the difference between predicted and actual ranks for each player\n• Filters the DataFrame to include only entries from the specified year\n  ◦ Sorts the filtered data by actual rank for logical ordering\n• Sets up a 12x6 inch figure for plotting\n• Creates a bar plot using seaborn:\n  ◦ X-axis: player names\n  ◦ Y-axis: prediction error (PredictedRank - Rank)\n  ◦ Bars are colored by player name using a 'coolwarm' palette\n• Adds a horizontal dashed line at y=0 to indicate perfect prediction\n• Rotates x-axis labels for better readability and sets axis labels and plot title\n• Adjusts layout for neatness and saves the plot as a PNG file in the data directory, named with the given year",
                "title": "plot_ranking_predictions Function Summary",
                "medium_unstructured": "The plot_ranking_predictions function visualizes the difference between predicted and actual player ranks for a specified year. It generates a bar plot of these errors and saves the figure as a PNG file. The plot helps assess the accuracy of ranking predictions.",
                "medium_structured": "• Calculates prediction error by subtracting actual rank from predicted rank\n• Filters the DataFrame for the specified year and sorts by actual rank\n• Creates a bar plot of prediction errors for each player\n  ◦ Uses player names as x-axis and error as y-axis\n• Saves the plot as a PNG file named for the year",
                "low_unstructured": "This function creates and saves a bar plot showing prediction errors for player rankings in a specified year."
            },
            "selected_code": "def plot_ranking_predictions(df, year):\n    \"\"\"\n    Plot prediction error for a specific year.\n\n    Args:\n        df: DataFrame containing prediction results\n        year: Year to plot prediction errors for\n    \"\"\"\n    df[\"RankError\"] = df[\"PredictedRank\"] - df[\"Rank\"]\n    year_df = df[df[\"Year\"] == year].copy()\n    year_df.sort_values(\"Rank\", inplace=True)\n\n    plt.figure(figsize=(12, 6))\n    sns.barplot(x=\"Name\", y=\"RankError\", data=year_df, hue=\"Name\", palette=\"coolwarm\")\n    plt.axhline(0, color=\"black\", linestyle=\"--\")\n    plt.xticks(rotation=45, ha=\"right\")\n    plt.ylabel(\"Predicted Rank - True Rank\")\n    plt.title(f\"MVP Ranking Predictions ({year})\")\n    plt.tight_layout()\n    plt.savefig(f\"data/ranking_predictions_{year}.png\")"
        },
        "event": "summarize_selected_code",
        "id": "8UAskuHcblA74d4DXPDk"
    },
    {
        "source": "backend",
        "timestamp": "2025-08-23 14:23:32.000",
        "data": {
            "summary": "The plot_ranking_predictions function visualizes the difference between predicted and actual player ranks for a specified year. It generates a bar plot of these errors and saves the figure as a PNG file. The plot helps assess the accuracy of ranking predictions.",
            "code": "52: def plot_ranking_predictions(df, year):\n53:     \"\"\"\n54:     Plot prediction error for a specific year.\n55: \n56:     Args:\n57:         df: DataFrame containing prediction results\n58:         year: Year to plot prediction errors for\n59:     \"\"\"\n60:     df[\"RankError\"] = df[\"PredictedRank\"] - df[\"Rank\"]\n61:     year_df = df[df[\"Year\"] == year].copy()\n62:     year_df.sort_values(\"Rank\", inplace=True)\n63: \n64:     plt.figure(figsize=(12, 6))\n65:     sns.barplot(x=\"Name\", y=\"RankError\", data=year_df, hue=\"Name\", palette=\"coolwarm\")\n66:     plt.axhline(0, color=\"black\", linestyle=\"--\")\n67:     plt.xticks(rotation=45, ha=\"right\")\n68:     plt.ylabel(\"Predicted Rank - True Rank\")\n69:     plt.title(f\"MVP Ranking Predictions ({year})\")\n70:     plt.tight_layout()\n71:     plt.savefig(f\"data/ranking_predictions_{year}.png\")",
            "mapping": [
                {
                    "codeSegments": [
                        {
                            "line": 52,
                            "code": "def plot_ranking_predictions(df, year):"
                        }
                    ],
                    "summaryComponent": "The plot_ranking_predictions function"
                },
                {
                    "codeSegments": [
                        {
                            "line": 60,
                            "code": "df[\"RankError\"] = df[\"PredictedRank\"] - df[\"Rank\"]"
                        }
                    ],
                    "summaryComponent": "visualizes the difference between predicted and actual player ranks"
                },
                {
                    "codeSegments": [
                        {
                            "line": 61,
                            "code": "year_df = df[df[\"Year\"] == year].copy()"
                        }
                    ],
                    "summaryComponent": "for a specified year"
                },
                {
                    "codeSegments": [
                        {
                            "line": 65,
                            "code": "sns.barplot(x=\"Name\", y=\"RankError\", data=year_df, hue=\"Name\", palette=\"coolwarm\")"
                        }
                    ],
                    "summaryComponent": "It generates a bar plot of these errors"
                },
                {
                    "codeSegments": [
                        {
                            "line": 71,
                            "code": "plt.savefig(f\"data/ranking_predictions_{year}.png\")"
                        }
                    ],
                    "summaryComponent": "and saves the figure as a PNG file"
                },
                {
                    "codeSegments": [
                        {
                            "line": 68,
                            "code": "plt.ylabel(\"Predicted Rank - True Rank\")"
                        }
                    ],
                    "summaryComponent": "The plot helps assess the accuracy of ranking predictions."
                }
            ]
        },
        "event": "map_summary_code",
        "id": "2yP5GEJCju48IZDagpX2"
    },
    {
        "source": "backend",
        "timestamp": "2025-08-23 14:23:32.000",
        "data": {
            "summary": "• Plots prediction errors for a given year\n• Saves the plot as a PNG file",
            "code": "52: def plot_ranking_predictions(df, year):\n53:     \"\"\"\n54:     Plot prediction error for a specific year.\n55: \n56:     Args:\n57:         df: DataFrame containing prediction results\n58:         year: Year to plot prediction errors for\n59:     \"\"\"\n60:     df[\"RankError\"] = df[\"PredictedRank\"] - df[\"Rank\"]\n61:     year_df = df[df[\"Year\"] == year].copy()\n62:     year_df.sort_values(\"Rank\", inplace=True)\n63: \n64:     plt.figure(figsize=(12, 6))\n65:     sns.barplot(x=\"Name\", y=\"RankError\", data=year_df, hue=\"Name\", palette=\"coolwarm\")\n66:     plt.axhline(0, color=\"black\", linestyle=\"--\")\n67:     plt.xticks(rotation=45, ha=\"right\")\n68:     plt.ylabel(\"Predicted Rank - True Rank\")\n69:     plt.title(f\"MVP Ranking Predictions ({year})\")\n70:     plt.tight_layout()\n71:     plt.savefig(f\"data/ranking_predictions_{year}.png\")",
            "mapping": [
                {
                    "codeSegments": [
                        {
                            "line": 52,
                            "code": "def plot_ranking_predictions(df, year):"
                        },
                        {
                            "line": 60,
                            "code": "df[\"RankError\"] = df[\"PredictedRank\"] - df[\"Rank\"]"
                        },
                        {
                            "line": 61,
                            "code": "year_df = df[df[\"Year\"] == year].copy()"
                        },
                        {
                            "line": 65,
                            "code": "sns.barplot(x=\"Name\", y=\"RankError\", data=year_df, hue=\"Name\", palette=\"coolwarm\")"
                        }
                    ],
                    "summaryComponent": "Plots prediction errors for a given year"
                },
                {
                    "codeSegments": [
                        {
                            "line": 71,
                            "code": "plt.savefig(f\"data/ranking_predictions_{year}.png\")"
                        }
                    ],
                    "summaryComponent": "Saves the plot as a PNG file"
                }
            ]
        },
        "event": "map_summary_code",
        "id": "iq4UuevjTSDdtiYvaAxz"
    },
    {
        "source": "backend",
        "timestamp": "2025-08-23 14:23:32.000",
        "data": {
            "summary": "• Calculates prediction error by subtracting actual rank from predicted rank\n• Filters the DataFrame for the specified year and sorts by actual rank\n• Creates a bar plot of prediction errors for each player\n  ◦ Uses player names as x-axis and error as y-axis\n• Saves the plot as a PNG file named for the year",
            "code": "52: def plot_ranking_predictions(df, year):\n53:     \"\"\"\n54:     Plot prediction error for a specific year.\n55: \n56:     Args:\n57:         df: DataFrame containing prediction results\n58:         year: Year to plot prediction errors for\n59:     \"\"\"\n60:     df[\"RankError\"] = df[\"PredictedRank\"] - df[\"Rank\"]\n61:     year_df = df[df[\"Year\"] == year].copy()\n62:     year_df.sort_values(\"Rank\", inplace=True)\n63: \n64:     plt.figure(figsize=(12, 6))\n65:     sns.barplot(x=\"Name\", y=\"RankError\", data=year_df, hue=\"Name\", palette=\"coolwarm\")\n66:     plt.axhline(0, color=\"black\", linestyle=\"--\")\n67:     plt.xticks(rotation=45, ha=\"right\")\n68:     plt.ylabel(\"Predicted Rank - True Rank\")\n69:     plt.title(f\"MVP Ranking Predictions ({year})\")\n70:     plt.tight_layout()\n71:     plt.savefig(f\"data/ranking_predictions_{year}.png\")",
            "mapping": [
                {
                    "codeSegments": [
                        {
                            "line": 60,
                            "code": "df[\"RankError\"] = df[\"PredictedRank\"] - df[\"Rank\"]"
                        }
                    ],
                    "summaryComponent": "Calculates prediction error by subtracting actual rank from predicted rank"
                },
                {
                    "codeSegments": [
                        {
                            "line": 61,
                            "code": "year_df = df[df[\"Year\"] == year].copy()"
                        },
                        {
                            "line": 62,
                            "code": "year_df.sort_values(\"Rank\", inplace=True)"
                        }
                    ],
                    "summaryComponent": "Filters the DataFrame for the specified year and sorts by actual rank"
                },
                {
                    "codeSegments": [
                        {
                            "line": 65,
                            "code": "sns.barplot(x=\"Name\", y=\"RankError\", data=year_df, hue=\"Name\", palette=\"coolwarm\")"
                        }
                    ],
                    "summaryComponent": "Creates a bar plot of prediction errors for each player"
                },
                {
                    "codeSegments": [
                        {
                            "line": 65,
                            "code": "x=\"Name\""
                        },
                        {
                            "line": 65,
                            "code": "y=\"RankError\""
                        }
                    ],
                    "summaryComponent": "Uses player names as x-axis and error as y-axis"
                },
                {
                    "codeSegments": [
                        {
                            "line": 71,
                            "code": "plt.savefig(f\"data/ranking_predictions_{year}.png\")"
                        }
                    ],
                    "summaryComponent": "Saves the plot as a PNG file named for the year"
                }
            ]
        },
        "event": "map_summary_code",
        "id": "rGhR6tx7fUbyTyHp5gKD"
    },
    {
        "source": "backend",
        "timestamp": "2025-08-23 14:23:33.000",
        "data": {
            "summary": "This function creates and saves a bar plot showing prediction errors for player rankings in a specified year.",
            "code": "52: def plot_ranking_predictions(df, year):\n53:     \"\"\"\n54:     Plot prediction error for a specific year.\n55: \n56:     Args:\n57:         df: DataFrame containing prediction results\n58:         year: Year to plot prediction errors for\n59:     \"\"\"\n60:     df[\"RankError\"] = df[\"PredictedRank\"] - df[\"Rank\"]\n61:     year_df = df[df[\"Year\"] == year].copy()\n62:     year_df.sort_values(\"Rank\", inplace=True)\n63: \n64:     plt.figure(figsize=(12, 6))\n65:     sns.barplot(x=\"Name\", y=\"RankError\", data=year_df, hue=\"Name\", palette=\"coolwarm\")\n66:     plt.axhline(0, color=\"black\", linestyle=\"--\")\n67:     plt.xticks(rotation=45, ha=\"right\")\n68:     plt.ylabel(\"Predicted Rank - True Rank\")\n69:     plt.title(f\"MVP Ranking Predictions ({year})\")\n70:     plt.tight_layout()\n71:     plt.savefig(f\"data/ranking_predictions_{year}.png\")",
            "mapping": [
                {
                    "codeSegments": [
                        {
                            "line": 52,
                            "code": "def plot_ranking_predictions(df, year):"
                        }
                    ],
                    "summaryComponent": "This function creates"
                },
                {
                    "codeSegments": [
                        {
                            "line": 71,
                            "code": "plt.savefig(f\"data/ranking_predictions_{year}.png\")"
                        }
                    ],
                    "summaryComponent": "saves a bar plot"
                },
                {
                    "codeSegments": [
                        {
                            "line": 60,
                            "code": "df[\"RankError\"] = df[\"PredictedRank\"] - df[\"Rank\"]"
                        },
                        {
                            "line": 65,
                            "code": "sns.barplot(x=\"Name\", y=\"RankError\", data=year_df, hue=\"Name\", palette=\"coolwarm\")"
                        }
                    ],
                    "summaryComponent": "showing prediction errors"
                },
                {
                    "codeSegments": [
                        {
                            "line": 60,
                            "code": "df[\"RankError\"] = df[\"PredictedRank\"] - df[\"Rank\"]"
                        },
                        {
                            "line": 62,
                            "code": "year_df.sort_values(\"Rank\", inplace=True)"
                        }
                    ],
                    "summaryComponent": "for player rankings"
                },
                {
                    "codeSegments": [
                        {
                            "line": 61,
                            "code": "year_df = df[df[\"Year\"] == year].copy()"
                        },
                        {
                            "line": 69,
                            "code": "plt.title(f\"MVP Ranking Predictions ({year})\")"
                        }
                    ],
                    "summaryComponent": "in a specified year"
                }
            ]
        },
        "event": "map_summary_code",
        "id": "0OovCmidO74e1S8ODJz7"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:23:33.000",
        "data": {
            "after_section_id": "ee2f360a-ae00-4e43-a81d-39bf7bf39416",
            "before_section_id": "7dcb4dfb-9fc5-4331-a999-9ca5f71a37eb"
        },
        "event": "autotransit_section",
        "id": "6Yw9GvC30QmnXl78BfLT"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:23:33.000",
        "data": {
            "section_data": {
                "editPromptValue": "",
                "summaryData": {
                    "high_unstructured": "The plot_ranking_predictions function computes the ranking error for each player by subtracting their true rank from the predicted rank in the provided DataFrame. It filters the data for the specified year, sorts players by their actual rank, and creates a horizontal bar plot where each bar represents a player's prediction error. The plot includes a horizontal line at zero for reference, customizes axis labels and title, and rotates x-axis labels for readability. Finally, it saves the plot as a PNG file in the data directory, named according to the year visualized.",
                    "low_structured": "• Plots prediction errors for a given year\n• Saves the plot as a PNG file",
                    "high_structured": "• Computes 'RankError' as the difference between predicted and actual ranks for each player\n• Filters the DataFrame to include only entries from the specified year\n  ◦ Sorts the filtered data by actual rank for logical ordering\n• Sets up a 12x6 inch figure for plotting\n• Creates a bar plot using seaborn:\n  ◦ X-axis: player names\n  ◦ Y-axis: prediction error (PredictedRank - Rank)\n  ◦ Bars are colored by player name using a 'coolwarm' palette\n• Adds a horizontal dashed line at y=0 to indicate perfect prediction\n• Rotates x-axis labels for better readability and sets axis labels and plot title\n• Adjusts layout for neatness and saves the plot as a PNG file in the data directory, named with the given year",
                    "title": "plot_ranking_predictions Function Summary",
                    "medium_unstructured": "The plot_ranking_predictions function visualizes the difference between predicted and actual player ranks for a specified year. It generates a bar plot of these errors and saves the figure as a PNG file. The plot helps assess the accuracy of ranking predictions.",
                    "medium_structured": "• Calculates prediction error by subtracting actual rank from predicted rank\n• Filters the DataFrame for the specified year and sorts by actual rank\n• Creates a bar plot of prediction errors for each player\n  ◦ Uses player names as x-axis and error as y-axis\n• Saves the plot as a PNG file named for the year",
                    "low_unstructured": "This function creates and saves a bar plot showing prediction errors for player rankings in a specified year."
                },
                "selectedDetailLevel": "medium",
                "title": "plot_ranking_predictions Function Summary",
                "summaryMappings": {
                    "low_structured": [
                        {
                            "codeSegments": [
                                {
                                    "line": 52,
                                    "code": "def plot_ranking_predictions(df, year):"
                                },
                                {
                                    "line": 60,
                                    "code": "df[\"RankError\"] = df[\"PredictedRank\"] - df[\"Rank\"]"
                                },
                                {
                                    "line": 61,
                                    "code": "year_df = df[df[\"Year\"] == year].copy()"
                                },
                                {
                                    "line": 65,
                                    "code": "sns.barplot(x=\"Name\", y=\"RankError\", data=year_df, hue=\"Name\", palette=\"coolwarm\")"
                                }
                            ],
                            "summaryComponent": "Plots prediction errors for a given year"
                        },
                        {
                            "codeSegments": [
                                {
                                    "line": 71,
                                    "code": "plt.savefig(f\"data/ranking_predictions_{year}.png\")"
                                }
                            ],
                            "summaryComponent": "Saves the plot as a PNG file"
                        }
                    ],
                    "high_structured": [
                        {
                            "codeSegments": [
                                {
                                    "line": 60,
                                    "code": "df[\"RankError\"] = df[\"PredictedRank\"] - df[\"Rank\"]"
                                }
                            ],
                            "summaryComponent": "Computes 'RankError' as the difference between predicted and actual ranks for each player"
                        },
                        {
                            "codeSegments": [
                                {
                                    "line": 61,
                                    "code": "year_df = df[df[\"Year\"] == year].copy()"
                                }
                            ],
                            "summaryComponent": "Filters the DataFrame to include only entries from the specified year"
                        },
                        {
                            "codeSegments": [
                                {
                                    "line": 62,
                                    "code": "year_df.sort_values(\"Rank\", inplace=True)"
                                }
                            ],
                            "summaryComponent": "Sorts the filtered data by actual rank for logical ordering"
                        },
                        {
                            "codeSegments": [
                                {
                                    "line": 64,
                                    "code": "plt.figure(figsize=(12, 6))"
                                }
                            ],
                            "summaryComponent": "Sets up a 12x6 inch figure for plotting"
                        },
                        {
                            "codeSegments": [
                                {
                                    "line": 65,
                                    "code": "sns.barplot(x=\"Name\", y=\"RankError\", data=year_df, hue=\"Name\", palette=\"coolwarm\")"
                                }
                            ],
                            "summaryComponent": "Creates a bar plot using seaborn:"
                        },
                        {
                            "codeSegments": [
                                {
                                    "line": 65,
                                    "code": "x=\"Name\""
                                }
                            ],
                            "summaryComponent": "X-axis: player names"
                        },
                        {
                            "codeSegments": [
                                {
                                    "line": 65,
                                    "code": "y=\"RankError\""
                                }
                            ],
                            "summaryComponent": "Y-axis: prediction error (PredictedRank - Rank)"
                        },
                        {
                            "codeSegments": [
                                {
                                    "line": 65,
                                    "code": "hue=\"Name\""
                                },
                                {
                                    "line": 65,
                                    "code": "palette=\"coolwarm\""
                                }
                            ],
                            "summaryComponent": "Bars are colored by player name using a 'coolwarm' palette"
                        },
                        {
                            "codeSegments": [
                                {
                                    "line": 66,
                                    "code": "plt.axhline(0, color=\"black\", linestyle=\"--\")"
                                }
                            ],
                            "summaryComponent": "Adds a horizontal dashed line at y=0 to indicate perfect prediction"
                        },
                        {
                            "codeSegments": [
                                {
                                    "line": 67,
                                    "code": "plt.xticks(rotation=45, ha=\"right\")"
                                },
                                {
                                    "line": 68,
                                    "code": "plt.ylabel(\"Predicted Rank - True Rank\")"
                                },
                                {
                                    "line": 69,
                                    "code": "plt.title(f\"MVP Ranking Predictions ({year})\")"
                                }
                            ],
                            "summaryComponent": "Rotates x-axis labels for better readability and sets axis labels and plot title"
                        },
                        {
                            "codeSegments": [
                                {
                                    "line": 70,
                                    "code": "plt.tight_layout()"
                                },
                                {
                                    "line": 71,
                                    "code": "plt.savefig(f\"data/ranking_predictions_{year}.png\")"
                                }
                            ],
                            "summaryComponent": "Adjusts layout for neatness and saves the plot as a PNG file in the data directory, named with the given year"
                        }
                    ],
                    "medium_structured": [
                        {
                            "codeSegments": [
                                {
                                    "line": 60,
                                    "code": "df[\"RankError\"] = df[\"PredictedRank\"] - df[\"Rank\"]"
                                }
                            ],
                            "summaryComponent": "Calculates prediction error by subtracting actual rank from predicted rank"
                        },
                        {
                            "codeSegments": [
                                {
                                    "line": 61,
                                    "code": "year_df = df[df[\"Year\"] == year].copy()"
                                },
                                {
                                    "line": 62,
                                    "code": "year_df.sort_values(\"Rank\", inplace=True)"
                                }
                            ],
                            "summaryComponent": "Filters the DataFrame for the specified year and sorts by actual rank"
                        },
                        {
                            "codeSegments": [
                                {
                                    "line": 65,
                                    "code": "sns.barplot(x=\"Name\", y=\"RankError\", data=year_df, hue=\"Name\", palette=\"coolwarm\")"
                                }
                            ],
                            "summaryComponent": "Creates a bar plot of prediction errors for each player"
                        },
                        {
                            "codeSegments": [
                                {
                                    "line": 65,
                                    "code": "x=\"Name\""
                                },
                                {
                                    "line": 65,
                                    "code": "y=\"RankError\""
                                }
                            ],
                            "summaryComponent": "Uses player names as x-axis and error as y-axis"
                        },
                        {
                            "codeSegments": [
                                {
                                    "line": 71,
                                    "code": "plt.savefig(f\"data/ranking_predictions_{year}.png\")"
                                }
                            ],
                            "summaryComponent": "Saves the plot as a PNG file named for the year"
                        }
                    ],
                    "medium_unstructured": [
                        {
                            "codeSegments": [
                                {
                                    "line": 52,
                                    "code": "def plot_ranking_predictions(df, year):"
                                }
                            ],
                            "summaryComponent": "The plot_ranking_predictions function"
                        },
                        {
                            "codeSegments": [
                                {
                                    "line": 60,
                                    "code": "df[\"RankError\"] = df[\"PredictedRank\"] - df[\"Rank\"]"
                                }
                            ],
                            "summaryComponent": "visualizes the difference between predicted and actual player ranks"
                        },
                        {
                            "codeSegments": [
                                {
                                    "line": 61,
                                    "code": "year_df = df[df[\"Year\"] == year].copy()"
                                }
                            ],
                            "summaryComponent": "for a specified year"
                        },
                        {
                            "codeSegments": [
                                {
                                    "line": 65,
                                    "code": "sns.barplot(x=\"Name\", y=\"RankError\", data=year_df, hue=\"Name\", palette=\"coolwarm\")"
                                }
                            ],
                            "summaryComponent": "It generates a bar plot of these errors"
                        },
                        {
                            "codeSegments": [
                                {
                                    "line": 71,
                                    "code": "plt.savefig(f\"data/ranking_predictions_{year}.png\")"
                                }
                            ],
                            "summaryComponent": "and saves the figure as a PNG file"
                        },
                        {
                            "codeSegments": [
                                {
                                    "line": 68,
                                    "code": "plt.ylabel(\"Predicted Rank - True Rank\")"
                                }
                            ],
                            "summaryComponent": "The plot helps assess the accuracy of ranking predictions."
                        }
                    ],
                    "high_unstructured": [
                        {
                            "codeSegments": [
                                {
                                    "line": 60,
                                    "code": "df[\"RankError\"] = df[\"PredictedRank\"] - df[\"Rank\"]"
                                }
                            ],
                            "summaryComponent": "computes the ranking error for each player by subtracting their true rank from the predicted rank in the provided DataFrame"
                        },
                        {
                            "codeSegments": [
                                {
                                    "line": 61,
                                    "code": "year_df = df[df[\"Year\"] == year].copy()"
                                }
                            ],
                            "summaryComponent": "filters the data for the specified year"
                        },
                        {
                            "codeSegments": [
                                {
                                    "line": 62,
                                    "code": "year_df.sort_values(\"Rank\", inplace=True)"
                                }
                            ],
                            "summaryComponent": "sorts players by their actual rank"
                        },
                        {
                            "codeSegments": [
                                {
                                    "line": 65,
                                    "code": "sns.barplot(x=\"Name\", y=\"RankError\", data=year_df, hue=\"Name\", palette=\"coolwarm\")"
                                }
                            ],
                            "summaryComponent": "creates a horizontal bar plot where each bar represents a player's prediction error"
                        },
                        {
                            "codeSegments": [
                                {
                                    "line": 66,
                                    "code": "plt.axhline(0, color=\"black\", linestyle=\"--\")"
                                }
                            ],
                            "summaryComponent": "includes a horizontal line at zero for reference"
                        },
                        {
                            "codeSegments": [
                                {
                                    "line": 68,
                                    "code": "plt.ylabel(\"Predicted Rank - True Rank\")"
                                },
                                {
                                    "line": 69,
                                    "code": "plt.title(f\"MVP Ranking Predictions ({year})\")"
                                }
                            ],
                            "summaryComponent": "customizes axis labels and title"
                        },
                        {
                            "codeSegments": [
                                {
                                    "line": 67,
                                    "code": "plt.xticks(rotation=45, ha=\"right\")"
                                }
                            ],
                            "summaryComponent": "rotates x-axis labels for readability"
                        },
                        {
                            "codeSegments": [
                                {
                                    "line": 71,
                                    "code": "plt.savefig(f\"data/ranking_predictions_{year}.png\")"
                                }
                            ],
                            "summaryComponent": "saves the plot as a PNG file in the data directory, named according to the year visualized"
                        }
                    ],
                    "low_unstructured": [
                        {
                            "codeSegments": [
                                {
                                    "line": 52,
                                    "code": "def plot_ranking_predictions(df, year):"
                                }
                            ],
                            "summaryComponent": "This function creates"
                        },
                        {
                            "codeSegments": [
                                {
                                    "line": 71,
                                    "code": "plt.savefig(f\"data/ranking_predictions_{year}.png\")"
                                }
                            ],
                            "summaryComponent": "saves a bar plot"
                        },
                        {
                            "codeSegments": [
                                {
                                    "line": 60,
                                    "code": "df[\"RankError\"] = df[\"PredictedRank\"] - df[\"Rank\"]"
                                },
                                {
                                    "line": 65,
                                    "code": "sns.barplot(x=\"Name\", y=\"RankError\", data=year_df, hue=\"Name\", palette=\"coolwarm\")"
                                }
                            ],
                            "summaryComponent": "showing prediction errors"
                        },
                        {
                            "codeSegments": [
                                {
                                    "line": 60,
                                    "code": "df[\"RankError\"] = df[\"PredictedRank\"] - df[\"Rank\"]"
                                },
                                {
                                    "line": 62,
                                    "code": "year_df.sort_values(\"Rank\", inplace=True)"
                                }
                            ],
                            "summaryComponent": "for player rankings"
                        },
                        {
                            "codeSegments": [
                                {
                                    "line": 61,
                                    "code": "year_df = df[df[\"Year\"] == year].copy()"
                                },
                                {
                                    "line": 69,
                                    "code": "plt.title(f\"MVP Ranking Predictions ({year})\")"
                                }
                            ],
                            "summaryComponent": "in a specified year"
                        }
                    ]
                },
                "metadata": {
                    "id": "ee2f360a-ae00-4e43-a81d-39bf7bf39416",
                    "filename": "rank_model.py",
                    "offset": 1205,
                    "fullPath": "/project/workspace/rank_model.py",
                    "originalCode": "def plot_ranking_predictions(df, year):\n    \"\"\"\n    Plot prediction error for a specific year.\n\n    Args:\n        df: DataFrame containing prediction results\n        year: Year to plot prediction errors for\n    \"\"\"\n    df[\"RankError\"] = df[\"PredictedRank\"] - df[\"Rank\"]\n    year_df = df[df[\"Year\"] == year].copy()\n    year_df.sort_values(\"Rank\", inplace=True)\n\n    plt.figure(figsize=(12, 6))\n    sns.barplot(x=\"Name\", y=\"RankError\", data=year_df, hue=\"Name\", palette=\"coolwarm\")\n    plt.axhline(0, color=\"black\", linestyle=\"--\")\n    plt.xticks(rotation=45, ha=\"right\")\n    plt.ylabel(\"Predicted Rank - True Rank\")\n    plt.title(f\"MVP Ranking Predictions ({year})\")\n    plt.tight_layout()\n    plt.savefig(f\"data/ranking_predictions_{year}.png\")"
                },
                "createdAt": 1755987814000,
                "lines": [
                    52,
                    71
                ],
                "editPromptStructured": null,
                "selectedStructured": "unstructured",
                "editPromptDetailLevel": null
            },
            "section_id": "ee2f360a-ae00-4e43-a81d-39bf7bf39416"
        },
        "event": "create_new_section",
        "id": "7oeBbQpMMi4hZbn3hA8M"
    },
    {
        "source": "backend",
        "timestamp": "2025-08-23 14:23:33.000",
        "data": {
            "summary": "The plot_ranking_predictions function computes the ranking error for each player by subtracting their true rank from the predicted rank in the provided DataFrame. It filters the data for the specified year, sorts players by their actual rank, and creates a horizontal bar plot where each bar represents a player's prediction error. The plot includes a horizontal line at zero for reference, customizes axis labels and title, and rotates x-axis labels for readability. Finally, it saves the plot as a PNG file in the data directory, named according to the year visualized.",
            "code": "52: def plot_ranking_predictions(df, year):\n53:     \"\"\"\n54:     Plot prediction error for a specific year.\n55: \n56:     Args:\n57:         df: DataFrame containing prediction results\n58:         year: Year to plot prediction errors for\n59:     \"\"\"\n60:     df[\"RankError\"] = df[\"PredictedRank\"] - df[\"Rank\"]\n61:     year_df = df[df[\"Year\"] == year].copy()\n62:     year_df.sort_values(\"Rank\", inplace=True)\n63: \n64:     plt.figure(figsize=(12, 6))\n65:     sns.barplot(x=\"Name\", y=\"RankError\", data=year_df, hue=\"Name\", palette=\"coolwarm\")\n66:     plt.axhline(0, color=\"black\", linestyle=\"--\")\n67:     plt.xticks(rotation=45, ha=\"right\")\n68:     plt.ylabel(\"Predicted Rank - True Rank\")\n69:     plt.title(f\"MVP Ranking Predictions ({year})\")\n70:     plt.tight_layout()\n71:     plt.savefig(f\"data/ranking_predictions_{year}.png\")",
            "mapping": [
                {
                    "codeSegments": [
                        {
                            "line": 60,
                            "code": "df[\"RankError\"] = df[\"PredictedRank\"] - df[\"Rank\"]"
                        }
                    ],
                    "summaryComponent": "computes the ranking error for each player by subtracting their true rank from the predicted rank in the provided DataFrame"
                },
                {
                    "codeSegments": [
                        {
                            "line": 61,
                            "code": "year_df = df[df[\"Year\"] == year].copy()"
                        }
                    ],
                    "summaryComponent": "filters the data for the specified year"
                },
                {
                    "codeSegments": [
                        {
                            "line": 62,
                            "code": "year_df.sort_values(\"Rank\", inplace=True)"
                        }
                    ],
                    "summaryComponent": "sorts players by their actual rank"
                },
                {
                    "codeSegments": [
                        {
                            "line": 65,
                            "code": "sns.barplot(x=\"Name\", y=\"RankError\", data=year_df, hue=\"Name\", palette=\"coolwarm\")"
                        }
                    ],
                    "summaryComponent": "creates a horizontal bar plot where each bar represents a player's prediction error"
                },
                {
                    "codeSegments": [
                        {
                            "line": 66,
                            "code": "plt.axhline(0, color=\"black\", linestyle=\"--\")"
                        }
                    ],
                    "summaryComponent": "includes a horizontal line at zero for reference"
                },
                {
                    "codeSegments": [
                        {
                            "line": 68,
                            "code": "plt.ylabel(\"Predicted Rank - True Rank\")"
                        },
                        {
                            "line": 69,
                            "code": "plt.title(f\"MVP Ranking Predictions ({year})\")"
                        }
                    ],
                    "summaryComponent": "customizes axis labels and title"
                },
                {
                    "codeSegments": [
                        {
                            "line": 67,
                            "code": "plt.xticks(rotation=45, ha=\"right\")"
                        }
                    ],
                    "summaryComponent": "rotates x-axis labels for readability"
                },
                {
                    "codeSegments": [
                        {
                            "line": 71,
                            "code": "plt.savefig(f\"data/ranking_predictions_{year}.png\")"
                        }
                    ],
                    "summaryComponent": "saves the plot as a PNG file in the data directory, named according to the year visualized"
                }
            ]
        },
        "event": "map_summary_code",
        "id": "xa3KFVn0ZQzQmflDkpgp"
    },
    {
        "source": "backend",
        "timestamp": "2025-08-23 14:23:34.000",
        "data": {
            "summary": "• Computes 'RankError' as the difference between predicted and actual ranks for each player\n• Filters the DataFrame to include only entries from the specified year\n  ◦ Sorts the filtered data by actual rank for logical ordering\n• Sets up a 12x6 inch figure for plotting\n• Creates a bar plot using seaborn:\n  ◦ X-axis: player names\n  ◦ Y-axis: prediction error (PredictedRank - Rank)\n  ◦ Bars are colored by player name using a 'coolwarm' palette\n• Adds a horizontal dashed line at y=0 to indicate perfect prediction\n• Rotates x-axis labels for better readability and sets axis labels and plot title\n• Adjusts layout for neatness and saves the plot as a PNG file in the data directory, named with the given year",
            "code": "52: def plot_ranking_predictions(df, year):\n53:     \"\"\"\n54:     Plot prediction error for a specific year.\n55: \n56:     Args:\n57:         df: DataFrame containing prediction results\n58:         year: Year to plot prediction errors for\n59:     \"\"\"\n60:     df[\"RankError\"] = df[\"PredictedRank\"] - df[\"Rank\"]\n61:     year_df = df[df[\"Year\"] == year].copy()\n62:     year_df.sort_values(\"Rank\", inplace=True)\n63: \n64:     plt.figure(figsize=(12, 6))\n65:     sns.barplot(x=\"Name\", y=\"RankError\", data=year_df, hue=\"Name\", palette=\"coolwarm\")\n66:     plt.axhline(0, color=\"black\", linestyle=\"--\")\n67:     plt.xticks(rotation=45, ha=\"right\")\n68:     plt.ylabel(\"Predicted Rank - True Rank\")\n69:     plt.title(f\"MVP Ranking Predictions ({year})\")\n70:     plt.tight_layout()\n71:     plt.savefig(f\"data/ranking_predictions_{year}.png\")",
            "mapping": [
                {
                    "codeSegments": [
                        {
                            "line": 60,
                            "code": "df[\"RankError\"] = df[\"PredictedRank\"] - df[\"Rank\"]"
                        }
                    ],
                    "summaryComponent": "Computes 'RankError' as the difference between predicted and actual ranks for each player"
                },
                {
                    "codeSegments": [
                        {
                            "line": 61,
                            "code": "year_df = df[df[\"Year\"] == year].copy()"
                        }
                    ],
                    "summaryComponent": "Filters the DataFrame to include only entries from the specified year"
                },
                {
                    "codeSegments": [
                        {
                            "line": 62,
                            "code": "year_df.sort_values(\"Rank\", inplace=True)"
                        }
                    ],
                    "summaryComponent": "Sorts the filtered data by actual rank for logical ordering"
                },
                {
                    "codeSegments": [
                        {
                            "line": 64,
                            "code": "plt.figure(figsize=(12, 6))"
                        }
                    ],
                    "summaryComponent": "Sets up a 12x6 inch figure for plotting"
                },
                {
                    "codeSegments": [
                        {
                            "line": 65,
                            "code": "sns.barplot(x=\"Name\", y=\"RankError\", data=year_df, hue=\"Name\", palette=\"coolwarm\")"
                        }
                    ],
                    "summaryComponent": "Creates a bar plot using seaborn:"
                },
                {
                    "codeSegments": [
                        {
                            "line": 65,
                            "code": "x=\"Name\""
                        }
                    ],
                    "summaryComponent": "X-axis: player names"
                },
                {
                    "codeSegments": [
                        {
                            "line": 65,
                            "code": "y=\"RankError\""
                        }
                    ],
                    "summaryComponent": "Y-axis: prediction error (PredictedRank - Rank)"
                },
                {
                    "codeSegments": [
                        {
                            "line": 65,
                            "code": "hue=\"Name\""
                        },
                        {
                            "line": 65,
                            "code": "palette=\"coolwarm\""
                        }
                    ],
                    "summaryComponent": "Bars are colored by player name using a 'coolwarm' palette"
                },
                {
                    "codeSegments": [
                        {
                            "line": 66,
                            "code": "plt.axhline(0, color=\"black\", linestyle=\"--\")"
                        }
                    ],
                    "summaryComponent": "Adds a horizontal dashed line at y=0 to indicate perfect prediction"
                },
                {
                    "codeSegments": [
                        {
                            "line": 67,
                            "code": "plt.xticks(rotation=45, ha=\"right\")"
                        },
                        {
                            "line": 68,
                            "code": "plt.ylabel(\"Predicted Rank - True Rank\")"
                        },
                        {
                            "line": 69,
                            "code": "plt.title(f\"MVP Ranking Predictions ({year})\")"
                        }
                    ],
                    "summaryComponent": "Rotates x-axis labels for better readability and sets axis labels and plot title"
                },
                {
                    "codeSegments": [
                        {
                            "line": 70,
                            "code": "plt.tight_layout()"
                        },
                        {
                            "line": 71,
                            "code": "plt.savefig(f\"data/ranking_predictions_{year}.png\")"
                        }
                    ],
                    "summaryComponent": "Adjusts layout for neatness and saves the plot as a PNG file in the data directory, named with the given year"
                }
            ]
        },
        "event": "map_summary_code",
        "id": "RSEPvmrCz6srT0eDO0bQ"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:23:36.000",
        "data": {
            "detail_level": "medium",
            "section_id": "ee2f360a-ae00-4e43-a81d-39bf7bf39416",
            "structured_type": "unstructured"
        },
        "event": "mapping_unhover",
        "id": "J31PStjXTg64OlJs1x6N"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:23:36.000",
        "data": {
            "detail_level": "medium",
            "section_id": "ee2f360a-ae00-4e43-a81d-39bf7bf39416",
            "structured_type": "unstructured"
        },
        "event": "mapping_unhover",
        "id": "Q714SQSL2gyNA4UdOK4Z"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:23:36.000",
        "data": {
            "detail_level": "medium",
            "section_id": "ee2f360a-ae00-4e43-a81d-39bf7bf39416",
            "structured_type": "unstructured",
            "mapping_index": 4
        },
        "event": "mapping_hover",
        "id": "cJCQhdV75bzdNNr2gGxX"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:23:36.000",
        "data": {
            "detail_level": "medium",
            "section_id": "ee2f360a-ae00-4e43-a81d-39bf7bf39416",
            "structured_type": "unstructured",
            "mapping_index": 1
        },
        "event": "mapping_hover",
        "id": "drU8Wg2Suss6BUh4yPkC"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:23:37.000",
        "data": {
            "detail_level": "medium",
            "section_id": "ee2f360a-ae00-4e43-a81d-39bf7bf39416",
            "structured_type": "unstructured",
            "mapping_index": 4
        },
        "event": "mapping_hover",
        "id": "4ZIGE4dc9eYrQpjbj50O"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:23:37.000",
        "data": {
            "detail_level": "medium",
            "section_id": "ee2f360a-ae00-4e43-a81d-39bf7bf39416",
            "structured_type": "unstructured",
            "mapping_index": 0
        },
        "event": "mapping_hover",
        "id": "GW4z0Xk72loVDa94wdyg"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:23:37.000",
        "data": {
            "detail_level": "medium",
            "section_id": "ee2f360a-ae00-4e43-a81d-39bf7bf39416",
            "structured_type": "unstructured"
        },
        "event": "mapping_unhover",
        "id": "HSNEMLg09ZUucTCrfx5R"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:23:37.000",
        "data": {
            "before_detail_level": "medium",
            "before_structured": "unstructured",
            "section_id": "ee2f360a-ae00-4e43-a81d-39bf7bf39416",
            "after_detail_level": "medium",
            "after_structured": "structured"
        },
        "event": "change_summary_level",
        "id": "IxUYw9ItdcIVvlIVm5zL"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:23:37.000",
        "data": {
            "detail_level": "medium",
            "section_id": "ee2f360a-ae00-4e43-a81d-39bf7bf39416",
            "structured_type": "unstructured"
        },
        "event": "mapping_unhover",
        "id": "UBLObUiBlNzelFlo09uJ"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:23:37.000",
        "data": {
            "detail_level": "medium",
            "section_id": "ee2f360a-ae00-4e43-a81d-39bf7bf39416",
            "structured_type": "unstructured"
        },
        "event": "mapping_unhover",
        "id": "awc40SFwlH1rS8vEagOJ"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:23:37.000",
        "data": {
            "detail_level": "medium",
            "section_id": "ee2f360a-ae00-4e43-a81d-39bf7bf39416",
            "structured_type": "unstructured",
            "mapping_index": 1
        },
        "event": "mapping_hover",
        "id": "q52lXEOoFrxCSPhmcI0I"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:23:38.000",
        "data": {
            "before_detail_level": "medium",
            "before_structured": "structured",
            "section_id": "ee2f360a-ae00-4e43-a81d-39bf7bf39416",
            "after_detail_level": "high",
            "after_structured": "structured"
        },
        "event": "change_summary_level",
        "id": "ey02L3qSYc0aqcQRL1oB"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:23:38.000",
        "data": {
            "detail_level": "high",
            "section_id": "ee2f360a-ae00-4e43-a81d-39bf7bf39416",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "kTHyj0NQtCqPCJEuA4C4"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:23:38.000",
        "data": {
            "detail_level": "high",
            "section_id": "ee2f360a-ae00-4e43-a81d-39bf7bf39416",
            "structured_type": "structured",
            "mapping_index": 0
        },
        "event": "mapping_hover",
        "id": "tlaLMhHBwuOoBT8Ts1pK"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:23:39.000",
        "data": {
            "detail_level": "high",
            "section_id": "ee2f360a-ae00-4e43-a81d-39bf7bf39416",
            "structured_type": "structured",
            "mapping_index": 1
        },
        "event": "mapping_hover",
        "id": "aUc5b0ZlouVyCDynxlxC"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:23:39.000",
        "data": {
            "detail_level": "high",
            "section_id": "ee2f360a-ae00-4e43-a81d-39bf7bf39416",
            "structured_type": "structured",
            "mapping_index": 0
        },
        "event": "mapping_hover",
        "id": "ksY7EYZaLSxZSHZ799Pw"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:23:39.000",
        "data": {
            "detail_level": "high",
            "section_id": "ee2f360a-ae00-4e43-a81d-39bf7bf39416",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "rqRIKkS4zQGFWa6UqDRU"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:23:41.000",
        "data": {
            "detail_level": "high",
            "section_id": "ee2f360a-ae00-4e43-a81d-39bf7bf39416",
            "structured_type": "structured",
            "mapping_index": 1
        },
        "event": "mapping_hover",
        "id": "8lpyRdvxgiLmg4Rpcwb5"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:23:41.000",
        "data": {
            "detail_level": "high",
            "section_id": "ee2f360a-ae00-4e43-a81d-39bf7bf39416",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "cW1sBthnKZZxs4y9oHa1"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:23:42.000",
        "data": {
            "detail_level": "high",
            "section_id": "ee2f360a-ae00-4e43-a81d-39bf7bf39416",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "OMzDUKr81C4Ipn5WzEPR"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:23:42.000",
        "data": {
            "detail_level": "high",
            "section_id": "ee2f360a-ae00-4e43-a81d-39bf7bf39416",
            "structured_type": "structured",
            "mapping_index": 3
        },
        "event": "mapping_hover",
        "id": "SRABmOMJsM8P8yEYLrD7"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:23:42.000",
        "data": {
            "detail_level": "high",
            "section_id": "ee2f360a-ae00-4e43-a81d-39bf7bf39416",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "p37GJdAuttzwiSCcdE55"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:23:42.000",
        "data": {
            "detail_level": "high",
            "section_id": "ee2f360a-ae00-4e43-a81d-39bf7bf39416",
            "structured_type": "structured",
            "mapping_index": 2
        },
        "event": "mapping_hover",
        "id": "sUqdQpf4iiS0dj9KDlSv"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:23:43.000",
        "data": {
            "detail_level": "high",
            "section_id": "ee2f360a-ae00-4e43-a81d-39bf7bf39416",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "54lBWHR6qW3cUpcP9gHe"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:23:43.000",
        "data": {
            "detail_level": "high",
            "section_id": "ee2f360a-ae00-4e43-a81d-39bf7bf39416",
            "structured_type": "structured",
            "mapping_index": 5
        },
        "event": "mapping_hover",
        "id": "GZOwDPRCMqlBACcZV3T7"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:23:43.000",
        "data": {
            "detail_level": "high",
            "section_id": "ee2f360a-ae00-4e43-a81d-39bf7bf39416",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "KsHJ1cR9p0EvAbYMeEab"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:23:43.000",
        "data": {
            "detail_level": "high",
            "section_id": "ee2f360a-ae00-4e43-a81d-39bf7bf39416",
            "structured_type": "structured",
            "mapping_index": 4
        },
        "event": "mapping_hover",
        "id": "gIScbp5jWzE7GHK5mWXd"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:23:44.000",
        "data": {
            "detail_level": "high",
            "section_id": "ee2f360a-ae00-4e43-a81d-39bf7bf39416",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "UldOOQE5RSz3eWHCShNS"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:23:44.000",
        "data": {
            "detail_level": "high",
            "section_id": "ee2f360a-ae00-4e43-a81d-39bf7bf39416",
            "structured_type": "structured",
            "mapping_index": 6
        },
        "event": "mapping_hover",
        "id": "ssxieiSFEKqSAvxMykUE"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:23:45.000",
        "data": {
            "detail_level": "high",
            "section_id": "ee2f360a-ae00-4e43-a81d-39bf7bf39416",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "2jtA3eOTOT3M1RBXwJoH"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:23:45.000",
        "data": {
            "detail_level": "high",
            "section_id": "ee2f360a-ae00-4e43-a81d-39bf7bf39416",
            "structured_type": "structured",
            "mapping_index": 8
        },
        "event": "mapping_hover",
        "id": "S3o8iIPYyPSCYiEWihcU"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:23:45.000",
        "data": {
            "detail_level": "high",
            "section_id": "ee2f360a-ae00-4e43-a81d-39bf7bf39416",
            "structured_type": "structured",
            "mapping_index": 7
        },
        "event": "mapping_hover",
        "id": "TYUdjNSAHfPAPFXiZfgF"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:23:45.000",
        "data": {
            "detail_level": "high",
            "section_id": "ee2f360a-ae00-4e43-a81d-39bf7bf39416",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "nbWZ5Yjer6FCSN6elZ6D"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:23:46.000",
        "data": {
            "detail_level": "high",
            "section_id": "ee2f360a-ae00-4e43-a81d-39bf7bf39416",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "WBkipwlSdWOXDfvanu8d"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:23:46.000",
        "data": {
            "detail_level": "high",
            "section_id": "ee2f360a-ae00-4e43-a81d-39bf7bf39416",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "Yod30f0iH6P6zkoKHCnh"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:23:46.000",
        "data": {
            "detail_level": "high",
            "section_id": "ee2f360a-ae00-4e43-a81d-39bf7bf39416",
            "structured_type": "structured",
            "mapping_index": 7
        },
        "event": "mapping_hover",
        "id": "mdVKODIJa4cAZtsODzeP"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:23:46.000",
        "data": {
            "detail_level": "high",
            "section_id": "ee2f360a-ae00-4e43-a81d-39bf7bf39416",
            "structured_type": "structured",
            "mapping_index": 8
        },
        "event": "mapping_hover",
        "id": "toJuRm0IGLnhDAu0xwu5"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:23:47.000",
        "data": {
            "detail_level": "high",
            "section_id": "ee2f360a-ae00-4e43-a81d-39bf7bf39416",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "I2X1FVHLi7FXetDdYbuP"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:23:47.000",
        "data": {
            "detail_level": "high",
            "section_id": "ee2f360a-ae00-4e43-a81d-39bf7bf39416",
            "structured_type": "structured",
            "mapping_index": 9
        },
        "event": "mapping_hover",
        "id": "Lb2KMzF42oWMPDHDUqHx"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:23:47.000",
        "data": {
            "detail_level": "high",
            "section_id": "ee2f360a-ae00-4e43-a81d-39bf7bf39416",
            "structured_type": "structured",
            "mapping_index": 10
        },
        "event": "mapping_hover",
        "id": "NBF7RQBFetHwAFUmIRTY"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:23:47.000",
        "data": {
            "detail_level": "high",
            "section_id": "ee2f360a-ae00-4e43-a81d-39bf7bf39416",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "P374n9cjcQP2TbtRBrC8"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:23:48.000",
        "data": {
            "detail_level": "high",
            "section_id": "ee2f360a-ae00-4e43-a81d-39bf7bf39416",
            "structured_type": "structured",
            "mapping_index": 9
        },
        "event": "mapping_hover",
        "id": "PYgCQshYQV44W0wJw5bk"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:23:48.000",
        "data": {
            "detail_level": "high",
            "section_id": "ee2f360a-ae00-4e43-a81d-39bf7bf39416",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "ZEBDNaCCAR8CRmYwsZUC"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:23:49.000",
        "data": {
            "detail_level": "high",
            "section_id": "ee2f360a-ae00-4e43-a81d-39bf7bf39416",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "5xNNcBfZrrm0r2v089Xs"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:23:49.000",
        "data": {
            "detail_level": "high",
            "section_id": "ee2f360a-ae00-4e43-a81d-39bf7bf39416",
            "structured_type": "structured",
            "mapping_index": 10
        },
        "event": "mapping_hover",
        "id": "VuI8tvoyHKNBO53iVolx"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:23:49.000",
        "data": {
            "detail_level": "high",
            "section_id": "ee2f360a-ae00-4e43-a81d-39bf7bf39416",
            "structured_type": "structured",
            "mapping_index": 9
        },
        "event": "mapping_hover",
        "id": "WjukJHCFv4QJo9bMa7wp"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:23:49.000",
        "data": {
            "detail_level": "high",
            "section_id": "ee2f360a-ae00-4e43-a81d-39bf7bf39416",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "iDl1yQMSIw5v3A1BKelu"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:23:50.000",
        "data": {
            "detail_level": "high",
            "section_id": "ee2f360a-ae00-4e43-a81d-39bf7bf39416",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "JLBZ6CG5Vk5N7ULlqvRZ"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:24:07.000",
        "data": {
            "detail_level": "high",
            "section_id": "ee2f360a-ae00-4e43-a81d-39bf7bf39416",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "27NoX1js1DnRvkxMyWbJ"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:24:07.000",
        "data": {
            "detail_level": "high",
            "section_id": "ee2f360a-ae00-4e43-a81d-39bf7bf39416",
            "structured_type": "structured",
            "mapping_index": 4
        },
        "event": "mapping_hover",
        "id": "57liwj3IpQfSyJilGrll"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:24:07.000",
        "data": {
            "detail_level": "high",
            "section_id": "ee2f360a-ae00-4e43-a81d-39bf7bf39416",
            "structured_type": "structured",
            "mapping_index": 2
        },
        "event": "mapping_hover",
        "id": "GUKnsppVQv10QonqakHY"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:24:07.000",
        "data": {
            "detail_level": "high",
            "section_id": "ee2f360a-ae00-4e43-a81d-39bf7bf39416",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "IQjS9BqySYK1cgVxEup1"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:24:07.000",
        "data": {
            "detail_level": "high",
            "section_id": "ee2f360a-ae00-4e43-a81d-39bf7bf39416",
            "structured_type": "structured",
            "mapping_index": 3
        },
        "event": "mapping_hover",
        "id": "M1WISyreqODz3WopZT4U"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:24:07.000",
        "data": {
            "detail_level": "high",
            "section_id": "ee2f360a-ae00-4e43-a81d-39bf7bf39416",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "QL8QTv4lq7LfIKPcB08O"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:24:07.000",
        "data": {
            "detail_level": "high",
            "section_id": "ee2f360a-ae00-4e43-a81d-39bf7bf39416",
            "structured_type": "structured",
            "mapping_index": 0
        },
        "event": "mapping_hover",
        "id": "bQUUzWuFm1H5EkhBOQrf"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:24:07.000",
        "data": {
            "detail_level": "high",
            "section_id": "ee2f360a-ae00-4e43-a81d-39bf7bf39416",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "cIhArlkoqU6f95Mql2i9"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:24:07.000",
        "data": {
            "detail_level": "high",
            "section_id": "ee2f360a-ae00-4e43-a81d-39bf7bf39416",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "gtQ0dCCIBcBhgWpPtIZ9"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:24:07.000",
        "data": {
            "detail_level": "high",
            "section_id": "ee2f360a-ae00-4e43-a81d-39bf7bf39416",
            "structured_type": "structured",
            "mapping_index": 1
        },
        "event": "mapping_hover",
        "id": "jriV1sioSv9biJ5xpyJs"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:24:09.000",
        "data": {
            "detail_level": "high",
            "section_id": "ee2f360a-ae00-4e43-a81d-39bf7bf39416",
            "structured_type": "structured",
            "mapping_index": 0
        },
        "event": "mapping_hover",
        "id": "A9gwhiCschPVw8rzRLMb"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:24:09.000",
        "data": {
            "detail_level": "high",
            "section_id": "ee2f360a-ae00-4e43-a81d-39bf7bf39416",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "L2SLWx78hC5SQKlZSEFE"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:24:09.000",
        "data": {
            "detail_level": "high",
            "section_id": "ee2f360a-ae00-4e43-a81d-39bf7bf39416",
            "structured_type": "structured",
            "mapping_index": 7
        },
        "event": "mapping_hover",
        "id": "eMa0iZGJ3IQNQEU0Z5T7"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:24:09.000",
        "data": {
            "detail_level": "high",
            "section_id": "ee2f360a-ae00-4e43-a81d-39bf7bf39416",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "ef9inZP7G1TRrLtA01VB"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:24:09.000",
        "data": {
            "detail_level": "high",
            "section_id": "ee2f360a-ae00-4e43-a81d-39bf7bf39416",
            "structured_type": "structured",
            "mapping_index": 2
        },
        "event": "mapping_hover",
        "id": "gI9H8jnD8BdxE9sEKALw"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:24:09.000",
        "data": {
            "detail_level": "high",
            "section_id": "ee2f360a-ae00-4e43-a81d-39bf7bf39416",
            "structured_type": "structured",
            "mapping_index": 1
        },
        "event": "mapping_hover",
        "id": "j2p8AFFkptxHqV1RssOk"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:24:09.000",
        "data": {
            "detail_level": "high",
            "section_id": "ee2f360a-ae00-4e43-a81d-39bf7bf39416",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "o32iqIyXkYsuFq9pNcuh"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:24:10.000",
        "data": {
            "detail_level": "high",
            "section_id": "ee2f360a-ae00-4e43-a81d-39bf7bf39416",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "4ibpQqDsI5bbkQR3bjyS"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:24:10.000",
        "data": {
            "detail_level": "high",
            "section_id": "ee2f360a-ae00-4e43-a81d-39bf7bf39416",
            "structured_type": "structured",
            "mapping_index": 4
        },
        "event": "mapping_hover",
        "id": "71R9f14d8RoiebQ8xi5X"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:24:10.000",
        "data": {
            "detail_level": "high",
            "section_id": "ee2f360a-ae00-4e43-a81d-39bf7bf39416",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "Dw41LKQ4wWrPiTXzMimO"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:24:10.000",
        "data": {
            "detail_level": "high",
            "section_id": "ee2f360a-ae00-4e43-a81d-39bf7bf39416",
            "structured_type": "structured",
            "mapping_index": 6
        },
        "event": "mapping_hover",
        "id": "Ef0lH369M9dZJlDbJTp6"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:24:10.000",
        "data": {
            "detail_level": "high",
            "section_id": "ee2f360a-ae00-4e43-a81d-39bf7bf39416",
            "structured_type": "structured",
            "mapping_index": 5
        },
        "event": "mapping_hover",
        "id": "FZmD0CBfNnYhdQ9MEwhJ"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:24:10.000",
        "data": {
            "detail_level": "high",
            "section_id": "ee2f360a-ae00-4e43-a81d-39bf7bf39416",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "ZVlBV3NLLrDRIcuXomSq"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:24:10.000",
        "data": {
            "detail_level": "high",
            "section_id": "ee2f360a-ae00-4e43-a81d-39bf7bf39416",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "ksnPTvbxlS0UaLoFxibZ"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:24:49.000",
        "data": {
            "detail_level": "high",
            "section_id": "ee2f360a-ae00-4e43-a81d-39bf7bf39416",
            "structured_type": "structured",
            "mapping_index": 1
        },
        "event": "mapping_hover",
        "id": "6iEqADbzxzHUEiVFYmsn"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:24:49.000",
        "data": {
            "detail_level": "high",
            "section_id": "ee2f360a-ae00-4e43-a81d-39bf7bf39416",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "liNUQ3kAFwMsES9PtPKl"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:24:49.000",
        "data": {
            "detail_level": "high",
            "section_id": "ee2f360a-ae00-4e43-a81d-39bf7bf39416",
            "structured_type": "structured",
            "mapping_index": 0
        },
        "event": "mapping_hover",
        "id": "tcGMZd9po5MXj3y2aELi"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:24:50.000",
        "data": {
            "detail_level": "high",
            "section_id": "ee2f360a-ae00-4e43-a81d-39bf7bf39416",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "1KkJPVYRUg1Si7bQxY5H"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:24:50.000",
        "data": {
            "detail_level": "high",
            "section_id": "ee2f360a-ae00-4e43-a81d-39bf7bf39416",
            "structured_type": "structured",
            "mapping_index": 3
        },
        "event": "mapping_hover",
        "id": "CJhUYv3E2eQFxWI2I01o"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:24:50.000",
        "data": {
            "detail_level": "high",
            "section_id": "ee2f360a-ae00-4e43-a81d-39bf7bf39416",
            "structured_type": "structured",
            "mapping_index": 2
        },
        "event": "mapping_hover",
        "id": "Ed4TZLwnqNsA4tKouGNd"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:24:50.000",
        "data": {
            "detail_level": "high",
            "section_id": "ee2f360a-ae00-4e43-a81d-39bf7bf39416",
            "structured_type": "structured",
            "mapping_index": 1
        },
        "event": "mapping_hover",
        "id": "GEmR611OorZI1aj9GZPB"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:24:50.000",
        "data": {
            "detail_level": "high",
            "section_id": "ee2f360a-ae00-4e43-a81d-39bf7bf39416",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "VZvdBJFDvbyxFt4Aixo2"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:24:50.000",
        "data": {
            "detail_level": "high",
            "section_id": "ee2f360a-ae00-4e43-a81d-39bf7bf39416",
            "structured_type": "structured",
            "mapping_index": 3
        },
        "event": "mapping_hover",
        "id": "XAbdSOQWL7HklUE0XzXd"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:24:50.000",
        "data": {
            "detail_level": "high",
            "section_id": "ee2f360a-ae00-4e43-a81d-39bf7bf39416",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "g3P3kN9Jc2VZMnnERwSh"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:24:50.000",
        "data": {
            "detail_level": "high",
            "section_id": "ee2f360a-ae00-4e43-a81d-39bf7bf39416",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "kKJGWueBC51pK27QF5N2"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:24:50.000",
        "data": {
            "detail_level": "high",
            "section_id": "ee2f360a-ae00-4e43-a81d-39bf7bf39416",
            "structured_type": "structured",
            "mapping_index": 2
        },
        "event": "mapping_hover",
        "id": "mhqAwtQImsFJzt0G2C3y"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:24:50.000",
        "data": {
            "detail_level": "high",
            "section_id": "ee2f360a-ae00-4e43-a81d-39bf7bf39416",
            "structured_type": "structured",
            "mapping_index": 4
        },
        "event": "mapping_hover",
        "id": "pq01Xq1HWgUUC3IBFuLY"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:24:50.000",
        "data": {
            "detail_level": "high",
            "section_id": "ee2f360a-ae00-4e43-a81d-39bf7bf39416",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "rnbZeLHeN4iGGFy6jiLg"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:24:50.000",
        "data": {
            "detail_level": "high",
            "section_id": "ee2f360a-ae00-4e43-a81d-39bf7bf39416",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "x9VgfrKILkyZNJ5pQbdm"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:24:51.000",
        "data": {
            "detail_level": "high",
            "section_id": "ee2f360a-ae00-4e43-a81d-39bf7bf39416",
            "structured_type": "structured",
            "mapping_index": 7
        },
        "event": "mapping_hover",
        "id": "3z5EFjTqSqorO0YHDxxY"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:24:51.000",
        "data": {
            "detail_level": "high",
            "section_id": "ee2f360a-ae00-4e43-a81d-39bf7bf39416",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "A0cisvmPJq0LE97heZje"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:24:51.000",
        "data": {
            "detail_level": "high",
            "section_id": "ee2f360a-ae00-4e43-a81d-39bf7bf39416",
            "structured_type": "structured",
            "mapping_index": 5
        },
        "event": "mapping_hover",
        "id": "GwlZZdRi5tNVGiYnr9Xj"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:24:51.000",
        "data": {
            "detail_level": "high",
            "section_id": "ee2f360a-ae00-4e43-a81d-39bf7bf39416",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "VkNyyAOR9F4dFhUwrX5J"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:24:51.000",
        "data": {
            "detail_level": "high",
            "section_id": "ee2f360a-ae00-4e43-a81d-39bf7bf39416",
            "structured_type": "structured",
            "mapping_index": 2
        },
        "event": "mapping_hover",
        "id": "ZDPyD3TuMKymp4SJ55K2"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:24:51.000",
        "data": {
            "detail_level": "high",
            "section_id": "ee2f360a-ae00-4e43-a81d-39bf7bf39416",
            "structured_type": "structured",
            "mapping_index": 6
        },
        "event": "mapping_hover",
        "id": "ZIoRKpon24j8IXDp7qLt"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:24:51.000",
        "data": {
            "detail_level": "high",
            "section_id": "ee2f360a-ae00-4e43-a81d-39bf7bf39416",
            "structured_type": "structured",
            "mapping_index": 4
        },
        "event": "mapping_hover",
        "id": "ZzZHjNhvXo4RLX1A4Evj"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:24:51.000",
        "data": {
            "detail_level": "high",
            "section_id": "ee2f360a-ae00-4e43-a81d-39bf7bf39416",
            "structured_type": "structured",
            "mapping_index": 3
        },
        "event": "mapping_hover",
        "id": "dPtlDfNEasrn7D0cmnUk"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:24:51.000",
        "data": {
            "detail_level": "high",
            "section_id": "ee2f360a-ae00-4e43-a81d-39bf7bf39416",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "eC1oycjsKAe2MolRu8CG"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:24:51.000",
        "data": {
            "detail_level": "high",
            "section_id": "ee2f360a-ae00-4e43-a81d-39bf7bf39416",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "iRVXy35CUy3gePMFJH3T"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:24:51.000",
        "data": {
            "detail_level": "high",
            "section_id": "ee2f360a-ae00-4e43-a81d-39bf7bf39416",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "kgbCwbv6WU2WCDjjXoHC"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:24:51.000",
        "data": {
            "detail_level": "high",
            "section_id": "ee2f360a-ae00-4e43-a81d-39bf7bf39416",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "xVpAL7WuhSgaiKmrNW90"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:24:53.000",
        "data": {
            "detail_level": "high",
            "section_id": "ee2f360a-ae00-4e43-a81d-39bf7bf39416",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "8Jdek7ZWcfp3sBt5SYjt"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:24:53.000",
        "data": {
            "detail_level": "high",
            "section_id": "ee2f360a-ae00-4e43-a81d-39bf7bf39416",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "TkO3hGVa1yjT0fLhJmaF"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:24:53.000",
        "data": {
            "detail_level": "high",
            "section_id": "ee2f360a-ae00-4e43-a81d-39bf7bf39416",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "gzOzn5yuLI85oyboNALC"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:24:53.000",
        "data": {
            "detail_level": "high",
            "section_id": "ee2f360a-ae00-4e43-a81d-39bf7bf39416",
            "structured_type": "structured",
            "mapping_index": 7
        },
        "event": "mapping_hover",
        "id": "hO0VqQE60TmozR2Cd5IT"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:24:53.000",
        "data": {
            "detail_level": "high",
            "section_id": "ee2f360a-ae00-4e43-a81d-39bf7bf39416",
            "structured_type": "structured",
            "mapping_index": 8
        },
        "event": "mapping_hover",
        "id": "qaQaKISaL9t21VnnwuK5"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:24:53.000",
        "data": {
            "detail_level": "high",
            "section_id": "ee2f360a-ae00-4e43-a81d-39bf7bf39416",
            "structured_type": "structured",
            "mapping_index": 6
        },
        "event": "mapping_hover",
        "id": "wSbqW9Hlkro3ycyNQ1ee"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:24:54.000",
        "data": {
            "detail_level": "high",
            "section_id": "ee2f360a-ae00-4e43-a81d-39bf7bf39416",
            "structured_type": "structured",
            "mapping_index": 7
        },
        "event": "mapping_hover",
        "id": "KB3AXWInAeaE1xWtui5Z"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:24:54.000",
        "data": {
            "detail_level": "high",
            "section_id": "ee2f360a-ae00-4e43-a81d-39bf7bf39416",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "UkCLkmvSMK7yydr7XLUs"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:24:54.000",
        "data": {
            "detail_level": "high",
            "section_id": "ee2f360a-ae00-4e43-a81d-39bf7bf39416",
            "structured_type": "structured",
            "mapping_index": 8
        },
        "event": "mapping_hover",
        "id": "UlIvEBjomLsqaxyKE6O3"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:24:54.000",
        "data": {
            "detail_level": "high",
            "section_id": "ee2f360a-ae00-4e43-a81d-39bf7bf39416",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "lPK6xHgpRpEiveYBP3LQ"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:24:55.000",
        "data": {
            "detail_level": "high",
            "section_id": "ee2f360a-ae00-4e43-a81d-39bf7bf39416",
            "structured_type": "structured",
            "mapping_index": 9
        },
        "event": "mapping_hover",
        "id": "Ke2NXlGQaYFatGcuiuqe"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:24:55.000",
        "data": {
            "detail_level": "high",
            "section_id": "ee2f360a-ae00-4e43-a81d-39bf7bf39416",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "U1aFHeWYSGlGQFut9xyQ"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:24:57.000",
        "data": {
            "detail_level": "high",
            "section_id": "ee2f360a-ae00-4e43-a81d-39bf7bf39416",
            "structured_type": "structured",
            "mapping_index": 10
        },
        "event": "mapping_hover",
        "id": "3DhpFu9dzq2BUH02JFbV"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:24:57.000",
        "data": {
            "detail_level": "high",
            "section_id": "ee2f360a-ae00-4e43-a81d-39bf7bf39416",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "FcA07sAKtUI8pTxuV2zO"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:24:57.000",
        "data": {
            "detail_level": "high",
            "section_id": "ee2f360a-ae00-4e43-a81d-39bf7bf39416",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "YV6A222BqvxaEm21q17v"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:25:03.000",
        "data": {
            "detail_level": "high",
            "section_id": "ee2f360a-ae00-4e43-a81d-39bf7bf39416",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "93i1LCnifSALCLgsVzyp"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:25:03.000",
        "data": {
            "detail_level": "high",
            "section_id": "ee2f360a-ae00-4e43-a81d-39bf7bf39416",
            "structured_type": "structured",
            "mapping_index": 8
        },
        "event": "mapping_hover",
        "id": "EWSHof3jJmEuDZajMVKZ"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:25:03.000",
        "data": {
            "detail_level": "high",
            "section_id": "ee2f360a-ae00-4e43-a81d-39bf7bf39416",
            "structured_type": "structured",
            "mapping_index": 10
        },
        "event": "mapping_hover",
        "id": "M0UWCHJ95plmEKkjgHXh"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:25:03.000",
        "data": {
            "detail_level": "high",
            "section_id": "ee2f360a-ae00-4e43-a81d-39bf7bf39416",
            "structured_type": "structured",
            "mapping_index": 9
        },
        "event": "mapping_hover",
        "id": "QV4KPpyG2XRMP0vu6Ryr"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:25:03.000",
        "data": {
            "detail_level": "high",
            "section_id": "ee2f360a-ae00-4e43-a81d-39bf7bf39416",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "QcDiqwXeD6Pt6Y1MYakA"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:25:03.000",
        "data": {
            "detail_level": "high",
            "section_id": "ee2f360a-ae00-4e43-a81d-39bf7bf39416",
            "structured_type": "structured",
            "mapping_index": 2
        },
        "event": "mapping_hover",
        "id": "TBEDK2QMjTvzEbnIyvbl"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:25:03.000",
        "data": {
            "detail_level": "high",
            "section_id": "ee2f360a-ae00-4e43-a81d-39bf7bf39416",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "uk6166hvX6OWwUlqs4f6"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:25:05.000",
        "data": {
            "detail_level": "high",
            "section_id": "ee2f360a-ae00-4e43-a81d-39bf7bf39416",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "0usZs7Lk3OJ96Qpyqn0y"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:25:05.000",
        "data": {
            "detail_level": "high",
            "section_id": "ee2f360a-ae00-4e43-a81d-39bf7bf39416",
            "structured_type": "structured",
            "mapping_index": 0
        },
        "event": "mapping_hover",
        "id": "Ag8k35NI4q91oyPFKo1i"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:25:05.000",
        "data": {
            "detail_level": "high",
            "section_id": "ee2f360a-ae00-4e43-a81d-39bf7bf39416",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "LJmxvAO5hOuIaG7HoWN3"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:25:05.000",
        "data": {
            "detail_level": "high",
            "section_id": "ee2f360a-ae00-4e43-a81d-39bf7bf39416",
            "structured_type": "structured",
            "mapping_index": 1
        },
        "event": "mapping_hover",
        "id": "MVh35qOlqv04rydDVYyx"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:25:05.000",
        "data": {
            "detail_level": "high",
            "section_id": "ee2f360a-ae00-4e43-a81d-39bf7bf39416",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "NJI7VDk39cRFqUuMVpK9"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:25:06.000",
        "data": {
            "structured": "structured",
            "detail_level": "high",
            "summary": "• Computes 'RankError' as the difference between predicted and actual ranks for each player\n• Filters the DataFrame to include only entries from the specified year\n  ◦ Sorts the filtered data by actual rank for logical ordering\n• Sets up a 12x6 inch figure for plotting\n• Creates a bar plot using seaborn:\n  ◦ X-axis: player names\n  ◦ Y-axis: prediction error (PredictedRank - Rank)\n  ◦ Bars are colored by player name using a 'coolwarm' palette\n• Adds a horizontal dashed line at y=0 to indicate perfect prediction\n• Rotates x-axis labels for better readability and sets axis labels and plot title\n• Adjusts layout for neatness and saves the plot as a PNG file in the data directory, named with the given year",
            "section_id": "ee2f360a-ae00-4e43-a81d-39bf7bf39416"
        },
        "event": "click_edit_in_prompt",
        "id": "1t54GuHWmoGb0yV4NoIb"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:25:06.000",
        "data": {
            "detail_level": "high",
            "section_id": "ee2f360a-ae00-4e43-a81d-39bf7bf39416",
            "structured_type": "structured",
            "mapping_index": 9
        },
        "event": "mapping_hover",
        "id": "7bqnXgj39zIGslD7qCxa"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:25:06.000",
        "data": {
            "detail_level": "high",
            "section_id": "ee2f360a-ae00-4e43-a81d-39bf7bf39416",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "MuqPGqF8pUFkV2X37qWU"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:25:06.000",
        "data": {
            "detail_level": "high",
            "section_id": "ee2f360a-ae00-4e43-a81d-39bf7bf39416",
            "structured_type": "structured",
            "mapping_index": 8
        },
        "event": "mapping_hover",
        "id": "QnVlwygGNygYUUdZvKGV"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:25:06.000",
        "data": {
            "detail_level": "high",
            "section_id": "ee2f360a-ae00-4e43-a81d-39bf7bf39416",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "aLaeLz2l3ASwsOocwQum"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:25:06.000",
        "data": {
            "detail_level": "high",
            "section_id": "ee2f360a-ae00-4e43-a81d-39bf7bf39416",
            "structured_type": "structured",
            "mapping_index": 10
        },
        "event": "mapping_hover",
        "id": "ae2BH345EIBzmp8WlwlB"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:25:06.000",
        "data": {
            "detail_level": "high",
            "section_id": "ee2f360a-ae00-4e43-a81d-39bf7bf39416",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "c3q9zJrlYkDYnTVBGoH4"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:25:06.000",
        "data": {
            "detail_level": "high",
            "section_id": "ee2f360a-ae00-4e43-a81d-39bf7bf39416",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "iSczQiYrE6MnD0lLSh8J"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:25:06.000",
        "data": {
            "detail_level": "high",
            "section_id": "ee2f360a-ae00-4e43-a81d-39bf7bf39416",
            "structured_type": "structured",
            "mapping_index": 0
        },
        "event": "mapping_hover",
        "id": "nvGwWLRWEyku9HuE3ttV"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:25:08.000",
        "data": {
            "detail_level": "high",
            "section_id": "ee2f360a-ae00-4e43-a81d-39bf7bf39416",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "5PIQ3NuZfKeoBSDyufHz"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:25:08.000",
        "data": {
            "detail_level": "high",
            "section_id": "ee2f360a-ae00-4e43-a81d-39bf7bf39416",
            "structured_type": "structured",
            "mapping_index": 10
        },
        "event": "mapping_hover",
        "id": "8bGjfLtVFMTLj9Vb6uKT"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:25:08.000",
        "data": {
            "detail_level": "high",
            "section_id": "ee2f360a-ae00-4e43-a81d-39bf7bf39416",
            "structured_type": "structured",
            "mapping_index": 9
        },
        "event": "mapping_hover",
        "id": "QFXFm2sNdsg4c2TLZVbg"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:25:09.000",
        "data": {
            "detail_level": "high",
            "section_id": "ee2f360a-ae00-4e43-a81d-39bf7bf39416",
            "structured_type": "structured",
            "mapping_index": 10
        },
        "event": "mapping_hover",
        "id": "dN7IIsZzztTwCRYLa6kg"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:25:09.000",
        "data": {
            "detail_level": "high",
            "section_id": "ee2f360a-ae00-4e43-a81d-39bf7bf39416",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "kwjB65tnfa561IS5xqan"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:25:16.000",
        "data": {
            "detail_level": "high",
            "section_id": "ee2f360a-ae00-4e43-a81d-39bf7bf39416",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "65e7PZRX0iLycMH7YmkD"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:25:16.000",
        "data": {
            "detail_level": "high",
            "section_id": "ee2f360a-ae00-4e43-a81d-39bf7bf39416",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "9gFCM3CtNxr6TG46Bs95"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:25:16.000",
        "data": {
            "detail_level": "high",
            "section_id": "ee2f360a-ae00-4e43-a81d-39bf7bf39416",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "GB4qobkVjvc7GpjsDo5R"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:25:16.000",
        "data": {
            "detail_level": "high",
            "section_id": "ee2f360a-ae00-4e43-a81d-39bf7bf39416",
            "structured_type": "structured",
            "mapping_index": 3
        },
        "event": "mapping_hover",
        "id": "NBTfE0HxdQX8Lrodd7aO"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:25:16.000",
        "data": {
            "detail_level": "high",
            "section_id": "ee2f360a-ae00-4e43-a81d-39bf7bf39416",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "SFFf3IjPdR4KYfNDY4vW"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:25:16.000",
        "data": {
            "detail_level": "high",
            "section_id": "ee2f360a-ae00-4e43-a81d-39bf7bf39416",
            "structured_type": "structured",
            "mapping_index": 1
        },
        "event": "mapping_hover",
        "id": "T8pkJ2E3s0pvIRYdOYdq"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:25:16.000",
        "data": {
            "detail_level": "high",
            "section_id": "ee2f360a-ae00-4e43-a81d-39bf7bf39416",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "W8mLTZesQZl88OeMqc1k"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:25:16.000",
        "data": {
            "detail_level": "high",
            "section_id": "ee2f360a-ae00-4e43-a81d-39bf7bf39416",
            "structured_type": "structured",
            "mapping_index": 9
        },
        "event": "mapping_hover",
        "id": "YO2Tsc6XiiMEIRYDS644"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:25:16.000",
        "data": {
            "detail_level": "high",
            "section_id": "ee2f360a-ae00-4e43-a81d-39bf7bf39416",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "b7lMYhevzhKjZ9P8uQn4"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:25:16.000",
        "data": {
            "detail_level": "high",
            "section_id": "ee2f360a-ae00-4e43-a81d-39bf7bf39416",
            "structured_type": "structured",
            "mapping_index": 6
        },
        "event": "mapping_hover",
        "id": "ckkGNAxkaQDSTxXD4Y1D"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:25:16.000",
        "data": {
            "detail_level": "high",
            "section_id": "ee2f360a-ae00-4e43-a81d-39bf7bf39416",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "hMQHlqWrSq90WxlzEaf4"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:25:16.000",
        "data": {
            "detail_level": "high",
            "section_id": "ee2f360a-ae00-4e43-a81d-39bf7bf39416",
            "structured_type": "structured",
            "mapping_index": 8
        },
        "event": "mapping_hover",
        "id": "nSLueZikCACDOjPbrc0h"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:25:16.000",
        "data": {
            "detail_level": "high",
            "section_id": "ee2f360a-ae00-4e43-a81d-39bf7bf39416",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "njux7zKcUjFx3yEhfQzF"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:25:16.000",
        "data": {
            "detail_level": "high",
            "section_id": "ee2f360a-ae00-4e43-a81d-39bf7bf39416",
            "structured_type": "structured",
            "mapping_index": 2
        },
        "event": "mapping_hover",
        "id": "oRFVNRdRIq8zdSajRmOY"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:25:16.000",
        "data": {
            "detail_level": "high",
            "section_id": "ee2f360a-ae00-4e43-a81d-39bf7bf39416",
            "structured_type": "structured",
            "mapping_index": 4
        },
        "event": "mapping_hover",
        "id": "pZWyQijI3y7grD8Wx7Tj"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:25:17.000",
        "data": {
            "detail_level": "high",
            "section_id": "ee2f360a-ae00-4e43-a81d-39bf7bf39416",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "AcO7ENd1JI1daKW7pssG"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:25:17.000",
        "data": {
            "detail_level": "high",
            "section_id": "ee2f360a-ae00-4e43-a81d-39bf7bf39416",
            "structured_type": "structured",
            "mapping_index": 6
        },
        "event": "mapping_hover",
        "id": "AhDkPfiKTDc3dadbFa19"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:25:17.000",
        "data": {
            "detail_level": "high",
            "section_id": "ee2f360a-ae00-4e43-a81d-39bf7bf39416",
            "structured_type": "structured",
            "mapping_index": 6
        },
        "event": "mapping_hover",
        "id": "LXARttyAUnG3lXHfxdX4"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:25:17.000",
        "data": {
            "detail_level": "high",
            "section_id": "ee2f360a-ae00-4e43-a81d-39bf7bf39416",
            "structured_type": "structured",
            "mapping_index": 7
        },
        "event": "mapping_hover",
        "id": "mSL4kt8iZBTjOwNkkiJu"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:25:17.000",
        "data": {
            "detail_level": "high",
            "section_id": "ee2f360a-ae00-4e43-a81d-39bf7bf39416",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "vczSQrLAMim67gjnsyIo"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:25:18.000",
        "data": {
            "detail_level": "high",
            "section_id": "ee2f360a-ae00-4e43-a81d-39bf7bf39416",
            "structured_type": "structured",
            "mapping_index": 10
        },
        "event": "mapping_hover",
        "id": "CHhbyyLdjTERZ0uZOsVO"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:25:18.000",
        "data": {
            "detail_level": "high",
            "section_id": "ee2f360a-ae00-4e43-a81d-39bf7bf39416",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "JIziUyoCoOWFdX1APCQO"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:25:18.000",
        "data": {
            "detail_level": "high",
            "section_id": "ee2f360a-ae00-4e43-a81d-39bf7bf39416",
            "structured_type": "structured",
            "mapping_index": 8
        },
        "event": "mapping_hover",
        "id": "OjhWpGIwRgxcj5fQQpk5"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:25:18.000",
        "data": {
            "detail_level": "high",
            "section_id": "ee2f360a-ae00-4e43-a81d-39bf7bf39416",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "VwmE5BTCx2ih2RzBH1Sj"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:25:18.000",
        "data": {
            "detail_level": "high",
            "section_id": "ee2f360a-ae00-4e43-a81d-39bf7bf39416",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "Vx4EhQivA3epCuQq55ub"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:25:18.000",
        "data": {
            "detail_level": "high",
            "section_id": "ee2f360a-ae00-4e43-a81d-39bf7bf39416",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "WdKVUeK54eN1ZCTgzjuE"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:25:18.000",
        "data": {
            "detail_level": "high",
            "section_id": "ee2f360a-ae00-4e43-a81d-39bf7bf39416",
            "structured_type": "structured",
            "mapping_index": 9
        },
        "event": "mapping_hover",
        "id": "Yd0zBNJBAhvCXF7PG00b"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:25:18.000",
        "data": {
            "detail_level": "high",
            "section_id": "ee2f360a-ae00-4e43-a81d-39bf7bf39416",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "aIpYpZAWmo5wDQieVwYB"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:25:18.000",
        "data": {
            "detail_level": "high",
            "section_id": "ee2f360a-ae00-4e43-a81d-39bf7bf39416",
            "structured_type": "structured",
            "mapping_index": 7
        },
        "event": "mapping_hover",
        "id": "dWRRpZjmehA9QqzZxkO2"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:25:52.000",
        "data": {
            "detail_level": "high",
            "section_id": "ee2f360a-ae00-4e43-a81d-39bf7bf39416",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "AG2oKaXcqpsSeOqds7rm"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:25:52.000",
        "data": {
            "detail_level": "high",
            "section_id": "ee2f360a-ae00-4e43-a81d-39bf7bf39416",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "CpdSM5KFP1oEffC6GFeA"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:25:52.000",
        "data": {
            "detail_level": "high",
            "section_id": "ee2f360a-ae00-4e43-a81d-39bf7bf39416",
            "structured_type": "structured",
            "mapping_index": 10
        },
        "event": "mapping_hover",
        "id": "Dc6pq5pvA5fnizq3PjB9"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:25:52.000",
        "data": {
            "detail_level": "high",
            "section_id": "ee2f360a-ae00-4e43-a81d-39bf7bf39416",
            "structured_type": "structured",
            "mapping_index": 8
        },
        "event": "mapping_hover",
        "id": "Oh5kn0jDzXzQSKVI3lKO"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:25:52.000",
        "data": {
            "detail_level": "high",
            "section_id": "ee2f360a-ae00-4e43-a81d-39bf7bf39416",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "PEYaBogGHlqgSUP3efwW"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:25:52.000",
        "data": {
            "detail_level": "high",
            "section_id": "ee2f360a-ae00-4e43-a81d-39bf7bf39416",
            "structured_type": "structured",
            "mapping_index": 7
        },
        "event": "mapping_hover",
        "id": "QDQJnvlvZoCbSxq56jxe"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:25:52.000",
        "data": {
            "detail_level": "high",
            "section_id": "ee2f360a-ae00-4e43-a81d-39bf7bf39416",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "TxB2ntKIzw69ejQ9hFZj"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:25:52.000",
        "data": {
            "detail_level": "high",
            "section_id": "ee2f360a-ae00-4e43-a81d-39bf7bf39416",
            "structured_type": "structured",
            "mapping_index": 9
        },
        "event": "mapping_hover",
        "id": "jvmkM05cuw5qpPxLkc9p"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:26:11.000",
        "data": {},
        "event": "click_summarize_code",
        "id": "k1wx7qsfG29YW1D0O71t"
    },
    {
        "source": "backend",
        "timestamp": "2025-08-23 14:26:19.000",
        "data": {
            "summary": {
                "high_unstructured": "The plot_ranking_predictions function generates a bar plot that visualizes the prediction error (difference between predicted and true ranks) for each individual in a specified year. It first computes the error, filters and sorts the data for the given year, and then uses seaborn to create a color-coded bar plot with names on the x-axis and prediction errors on the y-axis. The plot includes a horizontal reference line at zero, rotated x-axis labels for readability, and descriptive axis labels and title. Finally, the plot is saved as a PNG file named according to the year, allowing for easy review of model performance for that specific year.",
                "low_structured": "• Plots prediction errors for a given year.\n• Saves the resulting bar chart as an image.",
                "high_structured": "• Computes the prediction error for each entry as PredictedRank minus Rank.\n• Filters the DataFrame to include only rows from the specified year.\n• Sorts the filtered data by true rank for ordered visualization.\n• Creates a bar plot using seaborn:\n  ◦ X-axis: Player or entry names\n  ◦ Y-axis: Prediction error (PredictedRank - Rank)\n  ◦ Bars are colored by name using a 'coolwarm' palette\n• Adds a horizontal dashed line at y=0 to indicate no prediction error.\n• Rotates x-axis labels for better readability and sets axis labels and plot title.\n• Adjusts layout for appearance and saves the plot as a PNG file named for the year.",
                "title": "plot_ranking_predictions Function Summary",
                "medium_unstructured": "The plot_ranking_predictions function visualizes the difference between predicted and actual ranks for a specific year using a bar plot. It highlights each individual's prediction error and saves the plot as a PNG file. The chart helps assess model performance for that year.",
                "medium_structured": "• Calculates prediction error (PredictedRank - Rank) for each entry.\n• Filters data for the specified year and sorts by true rank.\n• Creates a bar plot of prediction errors by name, with color differentiation.\n• Saves the plot as a PNG file for later review.",
                "low_unstructured": "This function creates and saves a bar plot showing prediction errors for a specified year."
            },
            "selected_code": "def plot_ranking_predictions(df, year):\n    \"\"\"\n    Plot prediction error for a specific year.\n\n    Args:\n        df: DataFrame containing prediction results\n        year: Year to plot prediction errors for\n    \"\"\"\n    df[\"RankError\"] = df[\"PredictedRank\"] - df[\"Rank\"]\n    year_df = df[df[\"Year\"] == year].copy()\n    year_df.sort_values(\"Rank\", inplace=True)\n\n    plt.figure(figsize=(12, 6))\n    sns.barplot(x=\"Name\", y=\"RankError\", data=year_df, hue=\"Name\", palette=\"coolwarm\")\n    plt.axhline(0, color=\"black\", linestyle=\"--\")\n    plt.xticks(rotation=45, ha=\"right\")\n    plt.ylabel(\"Predicted Rank - True Rank\")\n    plt.title(f\"MVP Ranking Predictions ({year})\")\n    plt.tight_layout()\n    plt.savefig(f\"data/ranking_predictions_{year}.png\")"
        },
        "event": "summarize_selected_code",
        "id": "jpnlesJQPmAqI5eJ7bEs"
    },
    {
        "source": "backend",
        "timestamp": "2025-08-23 14:26:21.000",
        "data": {
            "summary": "• Calculates prediction error (PredictedRank - Rank) for each entry.\n• Filters data for the specified year and sorts by true rank.\n• Creates a bar plot of prediction errors by name, with color differentiation.\n• Saves the plot as a PNG file for later review.",
            "code": "52: def plot_ranking_predictions(df, year):\n53:     \"\"\"\n54:     Plot prediction error for a specific year.\n55: \n56:     Args:\n57:         df: DataFrame containing prediction results\n58:         year: Year to plot prediction errors for\n59:     \"\"\"\n60:     df[\"RankError\"] = df[\"PredictedRank\"] - df[\"Rank\"]\n61:     year_df = df[df[\"Year\"] == year].copy()\n62:     year_df.sort_values(\"Rank\", inplace=True)\n63: \n64:     plt.figure(figsize=(12, 6))\n65:     sns.barplot(x=\"Name\", y=\"RankError\", data=year_df, hue=\"Name\", palette=\"coolwarm\")\n66:     plt.axhline(0, color=\"black\", linestyle=\"--\")\n67:     plt.xticks(rotation=45, ha=\"right\")\n68:     plt.ylabel(\"Predicted Rank - True Rank\")\n69:     plt.title(f\"MVP Ranking Predictions ({year})\")\n70:     plt.tight_layout()\n71:     plt.savefig(f\"data/ranking_predictions_{year}.png\")",
            "mapping": [
                {
                    "codeSegments": [
                        {
                            "line": 60,
                            "code": "df[\"RankError\"] = df[\"PredictedRank\"] - df[\"Rank\"]"
                        }
                    ],
                    "summaryComponent": "Calculates prediction error (PredictedRank - Rank) for each entry."
                },
                {
                    "codeSegments": [
                        {
                            "line": 61,
                            "code": "year_df = df[df[\"Year\"] == year].copy()"
                        },
                        {
                            "line": 62,
                            "code": "year_df.sort_values(\"Rank\", inplace=True)"
                        }
                    ],
                    "summaryComponent": "Filters data for the specified year and sorts by true rank."
                },
                {
                    "codeSegments": [
                        {
                            "line": 65,
                            "code": "sns.barplot(x=\"Name\", y=\"RankError\", data=year_df, hue=\"Name\", palette=\"coolwarm\")"
                        }
                    ],
                    "summaryComponent": "Creates a bar plot of prediction errors by name, with color differentiation."
                },
                {
                    "codeSegments": [
                        {
                            "line": 71,
                            "code": "plt.savefig(f\"data/ranking_predictions_{year}.png\")"
                        }
                    ],
                    "summaryComponent": "Saves the plot as a PNG file for later review."
                }
            ]
        },
        "event": "map_summary_code",
        "id": "Xzlysbsskhv127cZKR7S"
    },
    {
        "source": "backend",
        "timestamp": "2025-08-23 14:26:21.000",
        "data": {
            "summary": "• Plots prediction errors for a given year.\n• Saves the resulting bar chart as an image.",
            "code": "52: def plot_ranking_predictions(df, year):\n53:     \"\"\"\n54:     Plot prediction error for a specific year.\n55: \n56:     Args:\n57:         df: DataFrame containing prediction results\n58:         year: Year to plot prediction errors for\n59:     \"\"\"\n60:     df[\"RankError\"] = df[\"PredictedRank\"] - df[\"Rank\"]\n61:     year_df = df[df[\"Year\"] == year].copy()\n62:     year_df.sort_values(\"Rank\", inplace=True)\n63: \n64:     plt.figure(figsize=(12, 6))\n65:     sns.barplot(x=\"Name\", y=\"RankError\", data=year_df, hue=\"Name\", palette=\"coolwarm\")\n66:     plt.axhline(0, color=\"black\", linestyle=\"--\")\n67:     plt.xticks(rotation=45, ha=\"right\")\n68:     plt.ylabel(\"Predicted Rank - True Rank\")\n69:     plt.title(f\"MVP Ranking Predictions ({year})\")\n70:     plt.tight_layout()\n71:     plt.savefig(f\"data/ranking_predictions_{year}.png\")",
            "mapping": [
                {
                    "codeSegments": [
                        {
                            "line": 52,
                            "code": "def plot_ranking_predictions(df, year):"
                        },
                        {
                            "line": 60,
                            "code": "df[\"RankError\"] = df[\"PredictedRank\"] - df[\"Rank\"]"
                        },
                        {
                            "line": 61,
                            "code": "year_df = df[df[\"Year\"] == year].copy()"
                        },
                        {
                            "line": 65,
                            "code": "sns.barplot(x=\"Name\", y=\"RankError\", data=year_df, hue=\"Name\", palette=\"coolwarm\")"
                        }
                    ],
                    "summaryComponent": "Plots prediction errors for a given year."
                },
                {
                    "codeSegments": [
                        {
                            "line": 71,
                            "code": "plt.savefig(f\"data/ranking_predictions_{year}.png\")"
                        }
                    ],
                    "summaryComponent": "Saves the resulting bar chart as an image."
                }
            ]
        },
        "event": "map_summary_code",
        "id": "r6hNbDfEoBlkZsyJfEJC"
    },
    {
        "source": "backend",
        "timestamp": "2025-08-23 14:26:21.000",
        "data": {
            "summary": "This function creates and saves a bar plot showing prediction errors for a specified year.",
            "code": "52: def plot_ranking_predictions(df, year):\n53:     \"\"\"\n54:     Plot prediction error for a specific year.\n55: \n56:     Args:\n57:         df: DataFrame containing prediction results\n58:         year: Year to plot prediction errors for\n59:     \"\"\"\n60:     df[\"RankError\"] = df[\"PredictedRank\"] - df[\"Rank\"]\n61:     year_df = df[df[\"Year\"] == year].copy()\n62:     year_df.sort_values(\"Rank\", inplace=True)\n63: \n64:     plt.figure(figsize=(12, 6))\n65:     sns.barplot(x=\"Name\", y=\"RankError\", data=year_df, hue=\"Name\", palette=\"coolwarm\")\n66:     plt.axhline(0, color=\"black\", linestyle=\"--\")\n67:     plt.xticks(rotation=45, ha=\"right\")\n68:     plt.ylabel(\"Predicted Rank - True Rank\")\n69:     plt.title(f\"MVP Ranking Predictions ({year})\")\n70:     plt.tight_layout()\n71:     plt.savefig(f\"data/ranking_predictions_{year}.png\")",
            "mapping": [
                {
                    "codeSegments": [
                        {
                            "line": 52,
                            "code": "def plot_ranking_predictions(df, year):"
                        }
                    ],
                    "summaryComponent": "This function creates"
                },
                {
                    "codeSegments": [
                        {
                            "line": 65,
                            "code": "sns.barplot(x=\"Name\", y=\"RankError\", data=year_df, hue=\"Name\", palette=\"coolwarm\")"
                        }
                    ],
                    "summaryComponent": "a bar plot"
                },
                {
                    "codeSegments": [
                        {
                            "line": 60,
                            "code": "df[\"RankError\"] = df[\"PredictedRank\"] - df[\"Rank\"]"
                        }
                    ],
                    "summaryComponent": "showing prediction errors"
                },
                {
                    "codeSegments": [
                        {
                            "line": 61,
                            "code": "year_df = df[df[\"Year\"] == year].copy()"
                        }
                    ],
                    "summaryComponent": "for a specified year"
                },
                {
                    "codeSegments": [
                        {
                            "line": 71,
                            "code": "plt.savefig(f\"data/ranking_predictions_{year}.png\")"
                        }
                    ],
                    "summaryComponent": "and saves"
                }
            ]
        },
        "event": "map_summary_code",
        "id": "wYov52TqHsWFeNVEYs5l"
    },
    {
        "source": "backend",
        "timestamp": "2025-08-23 14:26:23.000",
        "data": {
            "summary": "• Computes the prediction error for each entry as PredictedRank minus Rank.\n• Filters the DataFrame to include only rows from the specified year.\n• Sorts the filtered data by true rank for ordered visualization.\n• Creates a bar plot using seaborn:\n  ◦ X-axis: Player or entry names\n  ◦ Y-axis: Prediction error (PredictedRank - Rank)\n  ◦ Bars are colored by name using a 'coolwarm' palette\n• Adds a horizontal dashed line at y=0 to indicate no prediction error.\n• Rotates x-axis labels for better readability and sets axis labels and plot title.\n• Adjusts layout for appearance and saves the plot as a PNG file named for the year.",
            "code": "52: def plot_ranking_predictions(df, year):\n53:     \"\"\"\n54:     Plot prediction error for a specific year.\n55: \n56:     Args:\n57:         df: DataFrame containing prediction results\n58:         year: Year to plot prediction errors for\n59:     \"\"\"\n60:     df[\"RankError\"] = df[\"PredictedRank\"] - df[\"Rank\"]\n61:     year_df = df[df[\"Year\"] == year].copy()\n62:     year_df.sort_values(\"Rank\", inplace=True)\n63: \n64:     plt.figure(figsize=(12, 6))\n65:     sns.barplot(x=\"Name\", y=\"RankError\", data=year_df, hue=\"Name\", palette=\"coolwarm\")\n66:     plt.axhline(0, color=\"black\", linestyle=\"--\")\n67:     plt.xticks(rotation=45, ha=\"right\")\n68:     plt.ylabel(\"Predicted Rank - True Rank\")\n69:     plt.title(f\"MVP Ranking Predictions ({year})\")\n70:     plt.tight_layout()\n71:     plt.savefig(f\"data/ranking_predictions_{year}.png\")",
            "mapping": [
                {
                    "codeSegments": [
                        {
                            "line": 60,
                            "code": "df[\"RankError\"] = df[\"PredictedRank\"] - df[\"Rank\"]"
                        }
                    ],
                    "summaryComponent": "Computes the prediction error for each entry as PredictedRank minus Rank."
                },
                {
                    "codeSegments": [
                        {
                            "line": 61,
                            "code": "year_df = df[df[\"Year\"] == year].copy()"
                        }
                    ],
                    "summaryComponent": "Filters the DataFrame to include only rows from the specified year."
                },
                {
                    "codeSegments": [
                        {
                            "line": 62,
                            "code": "year_df.sort_values(\"Rank\", inplace=True)"
                        }
                    ],
                    "summaryComponent": "Sorts the filtered data by true rank for ordered visualization."
                },
                {
                    "codeSegments": [
                        {
                            "line": 65,
                            "code": "sns.barplot(x=\"Name\", y=\"RankError\", data=year_df, hue=\"Name\", palette=\"coolwarm\")"
                        }
                    ],
                    "summaryComponent": "Creates a bar plot using seaborn:"
                },
                {
                    "codeSegments": [
                        {
                            "line": 65,
                            "code": "x=\"Name\""
                        }
                    ],
                    "summaryComponent": "X-axis: Player or entry names"
                },
                {
                    "codeSegments": [
                        {
                            "line": 65,
                            "code": "y=\"RankError\""
                        }
                    ],
                    "summaryComponent": "Y-axis: Prediction error (PredictedRank - Rank)"
                },
                {
                    "codeSegments": [
                        {
                            "line": 65,
                            "code": "hue=\"Name\""
                        },
                        {
                            "line": 65,
                            "code": "palette=\"coolwarm\""
                        }
                    ],
                    "summaryComponent": "Bars are colored by name using a 'coolwarm' palette"
                },
                {
                    "codeSegments": [
                        {
                            "line": 66,
                            "code": "plt.axhline(0, color=\"black\", linestyle=\"--\")"
                        }
                    ],
                    "summaryComponent": "Adds a horizontal dashed line at y=0 to indicate no prediction error."
                },
                {
                    "codeSegments": [
                        {
                            "line": 67,
                            "code": "plt.xticks(rotation=45, ha=\"right\")"
                        },
                        {
                            "line": 68,
                            "code": "plt.ylabel(\"Predicted Rank - True Rank\")"
                        },
                        {
                            "line": 69,
                            "code": "plt.title(f\"MVP Ranking Predictions ({year})\")"
                        }
                    ],
                    "summaryComponent": "Rotates x-axis labels for better readability and sets axis labels and plot title."
                },
                {
                    "codeSegments": [
                        {
                            "line": 70,
                            "code": "plt.tight_layout()"
                        },
                        {
                            "line": 71,
                            "code": "plt.savefig(f\"data/ranking_predictions_{year}.png\")"
                        }
                    ],
                    "summaryComponent": "Adjusts layout for appearance and saves the plot as a PNG file named for the year."
                }
            ]
        },
        "event": "map_summary_code",
        "id": "UE3VurUYihPU47RW7W0M"
    },
    {
        "source": "backend",
        "timestamp": "2025-08-23 14:26:24.000",
        "data": {
            "summary": "The plot_ranking_predictions function visualizes the difference between predicted and actual ranks for a specific year using a bar plot. It highlights each individual's prediction error and saves the plot as a PNG file. The chart helps assess model performance for that year.",
            "code": "52: def plot_ranking_predictions(df, year):\n53:     \"\"\"\n54:     Plot prediction error for a specific year.\n55: \n56:     Args:\n57:         df: DataFrame containing prediction results\n58:         year: Year to plot prediction errors for\n59:     \"\"\"\n60:     df[\"RankError\"] = df[\"PredictedRank\"] - df[\"Rank\"]\n61:     year_df = df[df[\"Year\"] == year].copy()\n62:     year_df.sort_values(\"Rank\", inplace=True)\n63: \n64:     plt.figure(figsize=(12, 6))\n65:     sns.barplot(x=\"Name\", y=\"RankError\", data=year_df, hue=\"Name\", palette=\"coolwarm\")\n66:     plt.axhline(0, color=\"black\", linestyle=\"--\")\n67:     plt.xticks(rotation=45, ha=\"right\")\n68:     plt.ylabel(\"Predicted Rank - True Rank\")\n69:     plt.title(f\"MVP Ranking Predictions ({year})\")\n70:     plt.tight_layout()\n71:     plt.savefig(f\"data/ranking_predictions_{year}.png\")",
            "mapping": [
                {
                    "codeSegments": [
                        {
                            "line": 52,
                            "code": "def plot_ranking_predictions(df, year):"
                        }
                    ],
                    "summaryComponent": "The plot_ranking_predictions function"
                },
                {
                    "codeSegments": [
                        {
                            "line": 60,
                            "code": "df[\"RankError\"] = df[\"PredictedRank\"] - df[\"Rank\"]"
                        }
                    ],
                    "summaryComponent": "visualizes the difference between predicted and actual ranks"
                },
                {
                    "codeSegments": [
                        {
                            "line": 61,
                            "code": "year_df = df[df[\"Year\"] == year].copy()"
                        }
                    ],
                    "summaryComponent": "for a specific year"
                },
                {
                    "codeSegments": [
                        {
                            "line": 65,
                            "code": "sns.barplot(x=\"Name\", y=\"RankError\", data=year_df, hue=\"Name\", palette=\"coolwarm\")"
                        }
                    ],
                    "summaryComponent": "using a bar plot"
                },
                {
                    "codeSegments": [
                        {
                            "line": 65,
                            "code": "sns.barplot(x=\"Name\", y=\"RankError\", data=year_df, hue=\"Name\", palette=\"coolwarm\")"
                        }
                    ],
                    "summaryComponent": "It highlights each individual's prediction error"
                },
                {
                    "codeSegments": [
                        {
                            "line": 71,
                            "code": "plt.savefig(f\"data/ranking_predictions_{year}.png\")"
                        }
                    ],
                    "summaryComponent": "and saves the plot as a PNG file."
                },
                {
                    "codeSegments": [
                        {
                            "line": 69,
                            "code": "plt.title(f\"MVP Ranking Predictions ({year})\")"
                        }
                    ],
                    "summaryComponent": "The chart helps assess model performance for that year."
                }
            ]
        },
        "event": "map_summary_code",
        "id": "a2hUvK2JEeTxuxmusE6F"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:26:24.000",
        "data": {
            "section_data": {
                "editPromptValue": "",
                "summaryData": {
                    "high_unstructured": "The plot_ranking_predictions function generates a bar plot that visualizes the prediction error (difference between predicted and true ranks) for each individual in a specified year. It first computes the error, filters and sorts the data for the given year, and then uses seaborn to create a color-coded bar plot with names on the x-axis and prediction errors on the y-axis. The plot includes a horizontal reference line at zero, rotated x-axis labels for readability, and descriptive axis labels and title. Finally, the plot is saved as a PNG file named according to the year, allowing for easy review of model performance for that specific year.",
                    "low_structured": "• Plots prediction errors for a given year.\n• Saves the resulting bar chart as an image.",
                    "high_structured": "• Computes the prediction error for each entry as PredictedRank minus Rank.\n• Filters the DataFrame to include only rows from the specified year.\n• Sorts the filtered data by true rank for ordered visualization.\n• Creates a bar plot using seaborn:\n  ◦ X-axis: Player or entry names\n  ◦ Y-axis: Prediction error (PredictedRank - Rank)\n  ◦ Bars are colored by name using a 'coolwarm' palette\n• Adds a horizontal dashed line at y=0 to indicate no prediction error.\n• Rotates x-axis labels for better readability and sets axis labels and plot title.\n• Adjusts layout for appearance and saves the plot as a PNG file named for the year.",
                    "title": "plot_ranking_predictions Function Summary",
                    "medium_unstructured": "The plot_ranking_predictions function visualizes the difference between predicted and actual ranks for a specific year using a bar plot. It highlights each individual's prediction error and saves the plot as a PNG file. The chart helps assess model performance for that year.",
                    "medium_structured": "• Calculates prediction error (PredictedRank - Rank) for each entry.\n• Filters data for the specified year and sorts by true rank.\n• Creates a bar plot of prediction errors by name, with color differentiation.\n• Saves the plot as a PNG file for later review.",
                    "low_unstructured": "This function creates and saves a bar plot showing prediction errors for a specified year."
                },
                "selectedDetailLevel": "medium",
                "title": "plot_ranking_predictions Function Summary",
                "summaryMappings": {
                    "low_structured": [
                        {
                            "codeSegments": [
                                {
                                    "line": 52,
                                    "code": "def plot_ranking_predictions(df, year):"
                                },
                                {
                                    "line": 60,
                                    "code": "df[\"RankError\"] = df[\"PredictedRank\"] - df[\"Rank\"]"
                                },
                                {
                                    "line": 61,
                                    "code": "year_df = df[df[\"Year\"] == year].copy()"
                                },
                                {
                                    "line": 65,
                                    "code": "sns.barplot(x=\"Name\", y=\"RankError\", data=year_df, hue=\"Name\", palette=\"coolwarm\")"
                                }
                            ],
                            "summaryComponent": "Plots prediction errors for a given year."
                        },
                        {
                            "codeSegments": [
                                {
                                    "line": 71,
                                    "code": "plt.savefig(f\"data/ranking_predictions_{year}.png\")"
                                }
                            ],
                            "summaryComponent": "Saves the resulting bar chart as an image."
                        }
                    ],
                    "high_structured": [
                        {
                            "codeSegments": [
                                {
                                    "line": 60,
                                    "code": "df[\"RankError\"] = df[\"PredictedRank\"] - df[\"Rank\"]"
                                }
                            ],
                            "summaryComponent": "Computes the prediction error for each entry as PredictedRank minus Rank."
                        },
                        {
                            "codeSegments": [
                                {
                                    "line": 61,
                                    "code": "year_df = df[df[\"Year\"] == year].copy()"
                                }
                            ],
                            "summaryComponent": "Filters the DataFrame to include only rows from the specified year."
                        },
                        {
                            "codeSegments": [
                                {
                                    "line": 62,
                                    "code": "year_df.sort_values(\"Rank\", inplace=True)"
                                }
                            ],
                            "summaryComponent": "Sorts the filtered data by true rank for ordered visualization."
                        },
                        {
                            "codeSegments": [
                                {
                                    "line": 65,
                                    "code": "sns.barplot(x=\"Name\", y=\"RankError\", data=year_df, hue=\"Name\", palette=\"coolwarm\")"
                                }
                            ],
                            "summaryComponent": "Creates a bar plot using seaborn:"
                        },
                        {
                            "codeSegments": [
                                {
                                    "line": 65,
                                    "code": "x=\"Name\""
                                }
                            ],
                            "summaryComponent": "X-axis: Player or entry names"
                        },
                        {
                            "codeSegments": [
                                {
                                    "line": 65,
                                    "code": "y=\"RankError\""
                                }
                            ],
                            "summaryComponent": "Y-axis: Prediction error (PredictedRank - Rank)"
                        },
                        {
                            "codeSegments": [
                                {
                                    "line": 65,
                                    "code": "hue=\"Name\""
                                },
                                {
                                    "line": 65,
                                    "code": "palette=\"coolwarm\""
                                }
                            ],
                            "summaryComponent": "Bars are colored by name using a 'coolwarm' palette"
                        },
                        {
                            "codeSegments": [
                                {
                                    "line": 66,
                                    "code": "plt.axhline(0, color=\"black\", linestyle=\"--\")"
                                }
                            ],
                            "summaryComponent": "Adds a horizontal dashed line at y=0 to indicate no prediction error."
                        },
                        {
                            "codeSegments": [
                                {
                                    "line": 67,
                                    "code": "plt.xticks(rotation=45, ha=\"right\")"
                                },
                                {
                                    "line": 68,
                                    "code": "plt.ylabel(\"Predicted Rank - True Rank\")"
                                },
                                {
                                    "line": 69,
                                    "code": "plt.title(f\"MVP Ranking Predictions ({year})\")"
                                }
                            ],
                            "summaryComponent": "Rotates x-axis labels for better readability and sets axis labels and plot title."
                        },
                        {
                            "codeSegments": [
                                {
                                    "line": 70,
                                    "code": "plt.tight_layout()"
                                },
                                {
                                    "line": 71,
                                    "code": "plt.savefig(f\"data/ranking_predictions_{year}.png\")"
                                }
                            ],
                            "summaryComponent": "Adjusts layout for appearance and saves the plot as a PNG file named for the year."
                        }
                    ],
                    "medium_structured": [
                        {
                            "codeSegments": [
                                {
                                    "line": 60,
                                    "code": "df[\"RankError\"] = df[\"PredictedRank\"] - df[\"Rank\"]"
                                }
                            ],
                            "summaryComponent": "Calculates prediction error (PredictedRank - Rank) for each entry."
                        },
                        {
                            "codeSegments": [
                                {
                                    "line": 61,
                                    "code": "year_df = df[df[\"Year\"] == year].copy()"
                                },
                                {
                                    "line": 62,
                                    "code": "year_df.sort_values(\"Rank\", inplace=True)"
                                }
                            ],
                            "summaryComponent": "Filters data for the specified year and sorts by true rank."
                        },
                        {
                            "codeSegments": [
                                {
                                    "line": 65,
                                    "code": "sns.barplot(x=\"Name\", y=\"RankError\", data=year_df, hue=\"Name\", palette=\"coolwarm\")"
                                }
                            ],
                            "summaryComponent": "Creates a bar plot of prediction errors by name, with color differentiation."
                        },
                        {
                            "codeSegments": [
                                {
                                    "line": 71,
                                    "code": "plt.savefig(f\"data/ranking_predictions_{year}.png\")"
                                }
                            ],
                            "summaryComponent": "Saves the plot as a PNG file for later review."
                        }
                    ],
                    "medium_unstructured": [
                        {
                            "codeSegments": [
                                {
                                    "line": 52,
                                    "code": "def plot_ranking_predictions(df, year):"
                                }
                            ],
                            "summaryComponent": "The plot_ranking_predictions function"
                        },
                        {
                            "codeSegments": [
                                {
                                    "line": 60,
                                    "code": "df[\"RankError\"] = df[\"PredictedRank\"] - df[\"Rank\"]"
                                }
                            ],
                            "summaryComponent": "visualizes the difference between predicted and actual ranks"
                        },
                        {
                            "codeSegments": [
                                {
                                    "line": 61,
                                    "code": "year_df = df[df[\"Year\"] == year].copy()"
                                }
                            ],
                            "summaryComponent": "for a specific year"
                        },
                        {
                            "codeSegments": [
                                {
                                    "line": 65,
                                    "code": "sns.barplot(x=\"Name\", y=\"RankError\", data=year_df, hue=\"Name\", palette=\"coolwarm\")"
                                }
                            ],
                            "summaryComponent": "using a bar plot"
                        },
                        {
                            "codeSegments": [
                                {
                                    "line": 65,
                                    "code": "sns.barplot(x=\"Name\", y=\"RankError\", data=year_df, hue=\"Name\", palette=\"coolwarm\")"
                                }
                            ],
                            "summaryComponent": "It highlights each individual's prediction error"
                        },
                        {
                            "codeSegments": [
                                {
                                    "line": 71,
                                    "code": "plt.savefig(f\"data/ranking_predictions_{year}.png\")"
                                }
                            ],
                            "summaryComponent": "and saves the plot as a PNG file."
                        },
                        {
                            "codeSegments": [
                                {
                                    "line": 69,
                                    "code": "plt.title(f\"MVP Ranking Predictions ({year})\")"
                                }
                            ],
                            "summaryComponent": "The chart helps assess model performance for that year."
                        }
                    ],
                    "high_unstructured": [
                        {
                            "codeSegments": [
                                {
                                    "line": 52,
                                    "code": "def plot_ranking_predictions(df, year):"
                                },
                                {
                                    "line": 65,
                                    "code": "sns.barplot(x=\"Name\", y=\"RankError\", data=year_df, hue=\"Name\", palette=\"coolwarm\")"
                                }
                            ],
                            "summaryComponent": "The plot_ranking_predictions function generates a bar plot"
                        },
                        {
                            "codeSegments": [
                                {
                                    "line": 60,
                                    "code": "df[\"RankError\"] = df[\"PredictedRank\"] - df[\"Rank\"]"
                                }
                            ],
                            "summaryComponent": "visualizes the prediction error (difference between predicted and true ranks)"
                        },
                        {
                            "codeSegments": [
                                {
                                    "line": 61,
                                    "code": "year_df = df[df[\"Year\"] == year].copy()"
                                }
                            ],
                            "summaryComponent": "for each individual in a specified year"
                        },
                        {
                            "codeSegments": [
                                {
                                    "line": 60,
                                    "code": "df[\"RankError\"] = df[\"PredictedRank\"] - df[\"Rank\"]"
                                }
                            ],
                            "summaryComponent": "It first computes the error"
                        },
                        {
                            "codeSegments": [
                                {
                                    "line": 61,
                                    "code": "year_df = df[df[\"Year\"] == year].copy()"
                                },
                                {
                                    "line": 62,
                                    "code": "year_df.sort_values(\"Rank\", inplace=True)"
                                }
                            ],
                            "summaryComponent": "filters and sorts the data for the given year"
                        },
                        {
                            "codeSegments": [
                                {
                                    "line": 65,
                                    "code": "sns.barplot(x=\"Name\", y=\"RankError\", data=year_df, hue=\"Name\", palette=\"coolwarm\")"
                                }
                            ],
                            "summaryComponent": "uses seaborn to create a color-coded bar plot with names on the x-axis and prediction errors on the y-axis"
                        },
                        {
                            "codeSegments": [
                                {
                                    "line": 66,
                                    "code": "plt.axhline(0, color=\"black\", linestyle=\"--\")"
                                }
                            ],
                            "summaryComponent": "The plot includes a horizontal reference line at zero"
                        },
                        {
                            "codeSegments": [
                                {
                                    "line": 67,
                                    "code": "plt.xticks(rotation=45, ha=\"right\")"
                                }
                            ],
                            "summaryComponent": "rotated x-axis labels for readability"
                        },
                        {
                            "codeSegments": [
                                {
                                    "line": 68,
                                    "code": "plt.ylabel(\"Predicted Rank - True Rank\")"
                                },
                                {
                                    "line": 69,
                                    "code": "plt.title(f\"MVP Ranking Predictions ({year})\")"
                                }
                            ],
                            "summaryComponent": "descriptive axis labels and title"
                        },
                        {
                            "codeSegments": [
                                {
                                    "line": 71,
                                    "code": "plt.savefig(f\"data/ranking_predictions_{year}.png\")"
                                }
                            ],
                            "summaryComponent": "the plot is saved as a PNG file named according to the year"
                        }
                    ],
                    "low_unstructured": [
                        {
                            "codeSegments": [
                                {
                                    "line": 52,
                                    "code": "def plot_ranking_predictions(df, year):"
                                }
                            ],
                            "summaryComponent": "This function creates"
                        },
                        {
                            "codeSegments": [
                                {
                                    "line": 65,
                                    "code": "sns.barplot(x=\"Name\", y=\"RankError\", data=year_df, hue=\"Name\", palette=\"coolwarm\")"
                                }
                            ],
                            "summaryComponent": "a bar plot"
                        },
                        {
                            "codeSegments": [
                                {
                                    "line": 60,
                                    "code": "df[\"RankError\"] = df[\"PredictedRank\"] - df[\"Rank\"]"
                                }
                            ],
                            "summaryComponent": "showing prediction errors"
                        },
                        {
                            "codeSegments": [
                                {
                                    "line": 61,
                                    "code": "year_df = df[df[\"Year\"] == year].copy()"
                                }
                            ],
                            "summaryComponent": "for a specified year"
                        },
                        {
                            "codeSegments": [
                                {
                                    "line": 71,
                                    "code": "plt.savefig(f\"data/ranking_predictions_{year}.png\")"
                                }
                            ],
                            "summaryComponent": "and saves"
                        }
                    ]
                },
                "metadata": {
                    "id": "ce822799-0629-496a-a72f-202b19b8e04d",
                    "filename": "rank_model.py",
                    "offset": 1205,
                    "fullPath": "/project/workspace/rank_model.py",
                    "originalCode": "def plot_ranking_predictions(df, year):\n    \"\"\"\n    Plot prediction error for a specific year.\n\n    Args:\n        df: DataFrame containing prediction results\n        year: Year to plot prediction errors for\n    \"\"\"\n    df[\"RankError\"] = df[\"PredictedRank\"] - df[\"Rank\"]\n    year_df = df[df[\"Year\"] == year].copy()\n    year_df.sort_values(\"Rank\", inplace=True)\n\n    plt.figure(figsize=(12, 6))\n    sns.barplot(x=\"Name\", y=\"RankError\", data=year_df, hue=\"Name\", palette=\"coolwarm\")\n    plt.axhline(0, color=\"black\", linestyle=\"--\")\n    plt.xticks(rotation=45, ha=\"right\")\n    plt.ylabel(\"Predicted Rank - True Rank\")\n    plt.title(f\"MVP Ranking Predictions ({year})\")\n    plt.tight_layout()\n    plt.savefig(f\"data/ranking_predictions_{year}.png\")"
                },
                "createdAt": 1755987985000,
                "lines": [
                    52,
                    71
                ],
                "editPromptStructured": null,
                "selectedStructured": "unstructured",
                "editPromptDetailLevel": null
            },
            "section_id": "ce822799-0629-496a-a72f-202b19b8e04d"
        },
        "event": "create_new_section",
        "id": "uz57UGh9tk122uqPt7jP"
    },
    {
        "source": "backend",
        "timestamp": "2025-08-23 14:26:25.000",
        "data": {
            "summary": "The plot_ranking_predictions function generates a bar plot that visualizes the prediction error (difference between predicted and true ranks) for each individual in a specified year. It first computes the error, filters and sorts the data for the given year, and then uses seaborn to create a color-coded bar plot with names on the x-axis and prediction errors on the y-axis. The plot includes a horizontal reference line at zero, rotated x-axis labels for readability, and descriptive axis labels and title. Finally, the plot is saved as a PNG file named according to the year, allowing for easy review of model performance for that specific year.",
            "code": "52: def plot_ranking_predictions(df, year):\n53:     \"\"\"\n54:     Plot prediction error for a specific year.\n55: \n56:     Args:\n57:         df: DataFrame containing prediction results\n58:         year: Year to plot prediction errors for\n59:     \"\"\"\n60:     df[\"RankError\"] = df[\"PredictedRank\"] - df[\"Rank\"]\n61:     year_df = df[df[\"Year\"] == year].copy()\n62:     year_df.sort_values(\"Rank\", inplace=True)\n63: \n64:     plt.figure(figsize=(12, 6))\n65:     sns.barplot(x=\"Name\", y=\"RankError\", data=year_df, hue=\"Name\", palette=\"coolwarm\")\n66:     plt.axhline(0, color=\"black\", linestyle=\"--\")\n67:     plt.xticks(rotation=45, ha=\"right\")\n68:     plt.ylabel(\"Predicted Rank - True Rank\")\n69:     plt.title(f\"MVP Ranking Predictions ({year})\")\n70:     plt.tight_layout()\n71:     plt.savefig(f\"data/ranking_predictions_{year}.png\")",
            "mapping": [
                {
                    "codeSegments": [
                        {
                            "line": 52,
                            "code": "def plot_ranking_predictions(df, year):"
                        },
                        {
                            "line": 65,
                            "code": "sns.barplot(x=\"Name\", y=\"RankError\", data=year_df, hue=\"Name\", palette=\"coolwarm\")"
                        }
                    ],
                    "summaryComponent": "The plot_ranking_predictions function generates a bar plot"
                },
                {
                    "codeSegments": [
                        {
                            "line": 60,
                            "code": "df[\"RankError\"] = df[\"PredictedRank\"] - df[\"Rank\"]"
                        }
                    ],
                    "summaryComponent": "visualizes the prediction error (difference between predicted and true ranks)"
                },
                {
                    "codeSegments": [
                        {
                            "line": 61,
                            "code": "year_df = df[df[\"Year\"] == year].copy()"
                        }
                    ],
                    "summaryComponent": "for each individual in a specified year"
                },
                {
                    "codeSegments": [
                        {
                            "line": 60,
                            "code": "df[\"RankError\"] = df[\"PredictedRank\"] - df[\"Rank\"]"
                        }
                    ],
                    "summaryComponent": "It first computes the error"
                },
                {
                    "codeSegments": [
                        {
                            "line": 61,
                            "code": "year_df = df[df[\"Year\"] == year].copy()"
                        },
                        {
                            "line": 62,
                            "code": "year_df.sort_values(\"Rank\", inplace=True)"
                        }
                    ],
                    "summaryComponent": "filters and sorts the data for the given year"
                },
                {
                    "codeSegments": [
                        {
                            "line": 65,
                            "code": "sns.barplot(x=\"Name\", y=\"RankError\", data=year_df, hue=\"Name\", palette=\"coolwarm\")"
                        }
                    ],
                    "summaryComponent": "uses seaborn to create a color-coded bar plot with names on the x-axis and prediction errors on the y-axis"
                },
                {
                    "codeSegments": [
                        {
                            "line": 66,
                            "code": "plt.axhline(0, color=\"black\", linestyle=\"--\")"
                        }
                    ],
                    "summaryComponent": "The plot includes a horizontal reference line at zero"
                },
                {
                    "codeSegments": [
                        {
                            "line": 67,
                            "code": "plt.xticks(rotation=45, ha=\"right\")"
                        }
                    ],
                    "summaryComponent": "rotated x-axis labels for readability"
                },
                {
                    "codeSegments": [
                        {
                            "line": 68,
                            "code": "plt.ylabel(\"Predicted Rank - True Rank\")"
                        },
                        {
                            "line": 69,
                            "code": "plt.title(f\"MVP Ranking Predictions ({year})\")"
                        }
                    ],
                    "summaryComponent": "descriptive axis labels and title"
                },
                {
                    "codeSegments": [
                        {
                            "line": 71,
                            "code": "plt.savefig(f\"data/ranking_predictions_{year}.png\")"
                        }
                    ],
                    "summaryComponent": "the plot is saved as a PNG file named according to the year"
                }
            ]
        },
        "event": "map_summary_code",
        "id": "JwjoukiANKDW8H2Qchlu"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:26:25.000",
        "data": {
            "after_section_id": "ce822799-0629-496a-a72f-202b19b8e04d",
            "before_section_id": null
        },
        "event": "autotransit_section",
        "id": "LCSa5LOM249SDk7oSOAC"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:26:28.000",
        "data": {
            "before_detail_level": "medium",
            "before_structured": "unstructured",
            "section_id": "ce822799-0629-496a-a72f-202b19b8e04d",
            "after_detail_level": "high",
            "after_structured": "unstructured"
        },
        "event": "change_summary_level",
        "id": "VI1dYR5xh1rmBABtntK8"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:26:29.000",
        "data": {
            "before_detail_level": "high",
            "before_structured": "unstructured",
            "section_id": "ce822799-0629-496a-a72f-202b19b8e04d",
            "after_detail_level": "high",
            "after_structured": "structured"
        },
        "event": "change_summary_level",
        "id": "IAPogcv8Ifwl6P4eWfgl"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:26:30.000",
        "data": {
            "detail_level": "high",
            "section_id": "ce822799-0629-496a-a72f-202b19b8e04d",
            "structured_type": "structured",
            "mapping_index": 2
        },
        "event": "mapping_hover",
        "id": "0hqaa2tkwEJ5ovpQfZgg"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:26:30.000",
        "data": {
            "detail_level": "high",
            "section_id": "ce822799-0629-496a-a72f-202b19b8e04d",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "229KjBXd2cAqo6hLFOhs"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:26:30.000",
        "data": {
            "detail_level": "high",
            "section_id": "ce822799-0629-496a-a72f-202b19b8e04d",
            "structured_type": "structured",
            "mapping_index": 5
        },
        "event": "mapping_hover",
        "id": "4OR0XXsSnH6Hcgv2Nona"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:26:30.000",
        "data": {
            "detail_level": "high",
            "section_id": "ce822799-0629-496a-a72f-202b19b8e04d",
            "structured_type": "structured",
            "mapping_index": 7
        },
        "event": "mapping_hover",
        "id": "62nRvbuvexZywl2lQOor"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:26:30.000",
        "data": {
            "detail_level": "high",
            "section_id": "ce822799-0629-496a-a72f-202b19b8e04d",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "8JrNyTUnS75n34BViXeC"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:26:30.000",
        "data": {
            "detail_level": "high",
            "section_id": "ce822799-0629-496a-a72f-202b19b8e04d",
            "structured_type": "structured",
            "mapping_index": 1
        },
        "event": "mapping_hover",
        "id": "9aR5V9GSkwyKSdPJnvuP"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:26:30.000",
        "data": {
            "detail_level": "high",
            "section_id": "ce822799-0629-496a-a72f-202b19b8e04d",
            "structured_type": "structured",
            "mapping_index": 9
        },
        "event": "mapping_hover",
        "id": "Ab17P5BujB8kbKKOHhXb"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:26:30.000",
        "data": {
            "detail_level": "high",
            "section_id": "ce822799-0629-496a-a72f-202b19b8e04d",
            "structured_type": "structured",
            "mapping_index": 4
        },
        "event": "mapping_hover",
        "id": "Ej4IE75vMbGZYNYDMh2D"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:26:30.000",
        "data": {
            "detail_level": "high",
            "section_id": "ce822799-0629-496a-a72f-202b19b8e04d",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "GZWTYT6CyePtcYZD0adR"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:26:30.000",
        "data": {
            "detail_level": "high",
            "section_id": "ce822799-0629-496a-a72f-202b19b8e04d",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "NQM8znO6Pl9kyjBzdu36"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:26:30.000",
        "data": {
            "detail_level": "high",
            "section_id": "ce822799-0629-496a-a72f-202b19b8e04d",
            "structured_type": "structured",
            "mapping_index": 6
        },
        "event": "mapping_hover",
        "id": "O8rIMplPhpzjTthHDztk"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:26:30.000",
        "data": {
            "detail_level": "high",
            "section_id": "ce822799-0629-496a-a72f-202b19b8e04d",
            "structured_type": "structured",
            "mapping_index": 8
        },
        "event": "mapping_hover",
        "id": "OBkhM107Wb8DCvqrifkh"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:26:30.000",
        "data": {
            "detail_level": "high",
            "section_id": "ce822799-0629-496a-a72f-202b19b8e04d",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "Q0k9XBQFR19tbFB1Wuz6"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:26:30.000",
        "data": {
            "detail_level": "high",
            "section_id": "ce822799-0629-496a-a72f-202b19b8e04d",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "UdRqLHctE13toa3IT4Or"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:26:30.000",
        "data": {
            "detail_level": "high",
            "section_id": "ce822799-0629-496a-a72f-202b19b8e04d",
            "structured_type": "structured",
            "mapping_index": 0
        },
        "event": "mapping_hover",
        "id": "ckkrJVQbpPPn7toVdXdY"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:26:30.000",
        "data": {
            "detail_level": "high",
            "section_id": "ce822799-0629-496a-a72f-202b19b8e04d",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "hijYeySJ6EuAnS8xij7n"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:26:30.000",
        "data": {
            "detail_level": "high",
            "section_id": "ce822799-0629-496a-a72f-202b19b8e04d",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "ijGrIM6Nyb7jwNYat4pe"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:26:30.000",
        "data": {
            "detail_level": "high",
            "section_id": "ce822799-0629-496a-a72f-202b19b8e04d",
            "structured_type": "structured",
            "mapping_index": 3
        },
        "event": "mapping_hover",
        "id": "jdghXfbk14Ilyy6iSre3"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:26:30.000",
        "data": {
            "detail_level": "high",
            "section_id": "ce822799-0629-496a-a72f-202b19b8e04d",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "rQgkvGQcgqN8RwV4goAL"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:26:30.000",
        "data": {
            "detail_level": "high",
            "section_id": "ce822799-0629-496a-a72f-202b19b8e04d",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "sM2htOaQQIfHRXOjykwD"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:26:32.000",
        "data": {
            "detail_level": "high",
            "section_id": "ce822799-0629-496a-a72f-202b19b8e04d",
            "structured_type": "structured",
            "mapping_index": 8
        },
        "event": "mapping_hover",
        "id": "1pxrY1tOgYLvx31ddaxy"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:26:32.000",
        "data": {
            "detail_level": "high",
            "section_id": "ce822799-0629-496a-a72f-202b19b8e04d",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "2W97OkF6Tnj2Oyg9hwj3"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:26:32.000",
        "data": {
            "detail_level": "high",
            "section_id": "ce822799-0629-496a-a72f-202b19b8e04d",
            "structured_type": "structured",
            "mapping_index": 9
        },
        "event": "mapping_hover",
        "id": "7by3BA6XpfXM2O4hd4Hn"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:26:32.000",
        "data": {
            "detail_level": "high",
            "section_id": "ce822799-0629-496a-a72f-202b19b8e04d",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "OIKQarXZo23gBQo5BOH2"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:26:38.000",
        "data": {
            "detail_level": "high",
            "section_id": "ce822799-0629-496a-a72f-202b19b8e04d",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "gogyV4wyIdBza2LbDZWs"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:26:38.000",
        "data": {
            "structured": "structured",
            "detail_level": "high",
            "summary": "• Computes the prediction error for each entry as PredictedRank minus Rank.\n• Filters the DataFrame to include only rows from the specified year.\n• Sorts the filtered data by true rank for ordered visualization.\n• Creates a bar plot using seaborn:\n  ◦ X-axis: Player or entry names\n  ◦ Y-axis: Prediction error (PredictedRank - Rank)\n  ◦ Bars are colored by name using a 'coolwarm' palette\n• Adds a horizontal dashed line at y=0 to indicate no prediction error.\n• Rotates x-axis labels for better readability and sets axis labels and plot title.\n• Adjusts layout for appearance and saves the plot as a PNG file named for the year.",
            "section_id": "ce822799-0629-496a-a72f-202b19b8e04d"
        },
        "event": "click_edit_in_prompt",
        "id": "l9nGQMifkmfxl3ep7QKh"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:26:38.000",
        "data": {
            "detail_level": "high",
            "section_id": "ce822799-0629-496a-a72f-202b19b8e04d",
            "structured_type": "structured",
            "mapping_index": 9
        },
        "event": "mapping_hover",
        "id": "tQyvZj1fUU4PKOpo4yuG"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:26:54.000",
        "data": {
            "detail_level": "high",
            "section_id": "ce822799-0629-496a-a72f-202b19b8e04d",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "DB5qHnROmbzgAalEsEsP"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:26:54.000",
        "data": {
            "detail_level": "high",
            "section_id": "ce822799-0629-496a-a72f-202b19b8e04d",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "KBsa36mqqeJiN3Ezutcn"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:26:54.000",
        "data": {
            "detail_level": "high",
            "section_id": "ce822799-0629-496a-a72f-202b19b8e04d",
            "structured_type": "structured",
            "mapping_index": 6
        },
        "event": "mapping_hover",
        "id": "KZ3chN4GJOFrDfNGbzZk"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:26:54.000",
        "data": {
            "detail_level": "high",
            "section_id": "ce822799-0629-496a-a72f-202b19b8e04d",
            "structured_type": "structured",
            "mapping_index": 9
        },
        "event": "mapping_hover",
        "id": "bXoQhOfKWcACbnerg5C9"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:26:54.000",
        "data": {
            "detail_level": "high",
            "section_id": "ce822799-0629-496a-a72f-202b19b8e04d",
            "structured_type": "structured",
            "mapping_index": 7
        },
        "event": "mapping_hover",
        "id": "rUB5rLUjplS8D979tnIH"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:26:55.000",
        "data": {
            "detail_level": "high",
            "section_id": "ce822799-0629-496a-a72f-202b19b8e04d",
            "structured_type": "structured",
            "mapping_index": 5
        },
        "event": "mapping_hover",
        "id": "QTTpNKqljBoVrlaCu2Nd"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:26:55.000",
        "data": {
            "detail_level": "high",
            "section_id": "ce822799-0629-496a-a72f-202b19b8e04d",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "y7vZQ9d5Q3GkkKExN4t0"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:26:59.000",
        "data": {
            "detail_level": "high",
            "section_id": "ce822799-0629-496a-a72f-202b19b8e04d",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "J9scdOzG9NzkozSonAPe"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:26:59.000",
        "data": {
            "detail_level": "high",
            "section_id": "ce822799-0629-496a-a72f-202b19b8e04d",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "LX6RygXX7YhM8GuzG4rJ"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:26:59.000",
        "data": {
            "detail_level": "high",
            "section_id": "ce822799-0629-496a-a72f-202b19b8e04d",
            "structured_type": "structured",
            "mapping_index": 8
        },
        "event": "mapping_hover",
        "id": "QBrwydWNvFSw0WgjXVtT"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:26:59.000",
        "data": {
            "detail_level": "high",
            "section_id": "ce822799-0629-496a-a72f-202b19b8e04d",
            "structured_type": "structured",
            "mapping_index": 6
        },
        "event": "mapping_hover",
        "id": "UBEIXFi6fERdVDoeC18C"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:26:59.000",
        "data": {
            "detail_level": "high",
            "section_id": "ce822799-0629-496a-a72f-202b19b8e04d",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "dKWk6gmeaHK5Gih7Hdhf"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:26:59.000",
        "data": {
            "detail_level": "high",
            "section_id": "ce822799-0629-496a-a72f-202b19b8e04d",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "eDYObkaNc60LHhZh2vvo"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:26:59.000",
        "data": {
            "detail_level": "high",
            "section_id": "ce822799-0629-496a-a72f-202b19b8e04d",
            "structured_type": "structured",
            "mapping_index": 7
        },
        "event": "mapping_hover",
        "id": "lSilWI10KjXTBCh8wUgp"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:26:59.000",
        "data": {
            "detail_level": "high",
            "section_id": "ce822799-0629-496a-a72f-202b19b8e04d",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "t7SQvHYtbAWg4QevDytG"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:26:59.000",
        "data": {
            "detail_level": "high",
            "section_id": "ce822799-0629-496a-a72f-202b19b8e04d",
            "structured_type": "structured",
            "mapping_index": 9
        },
        "event": "mapping_hover",
        "id": "xViqJvs4CRaP5dHGyAWN"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:27:20.000",
        "data": {
            "detail_level": "high",
            "section_id": "ce822799-0629-496a-a72f-202b19b8e04d",
            "structured_type": "structured",
            "mapping_index": 9
        },
        "event": "mapping_hover",
        "id": "u58afHwUZi2zDHTUTOdy"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:27:21.000",
        "data": {
            "detail_level": "high",
            "section_id": "ce822799-0629-496a-a72f-202b19b8e04d",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "VsJ7A8aYwL6GV7q7J0cL"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:27:38.000",
        "data": {
            "detail_level": "high",
            "section_id": "ce822799-0629-496a-a72f-202b19b8e04d",
            "structured_type": "structured",
            "mapping_index": 9
        },
        "event": "mapping_hover",
        "id": "12VUTwnN5EPZgQeJvroy"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:27:38.000",
        "data": {
            "detail_level": "high",
            "section_id": "ce822799-0629-496a-a72f-202b19b8e04d",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "hZVjOscNmbJCSKdlPOLc"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:27:56.000",
        "data": {
            "detail_level": "high",
            "section_id": "ce822799-0629-496a-a72f-202b19b8e04d",
            "structured_type": "structured",
            "mapping_index": 1
        },
        "event": "mapping_hover",
        "id": "1iasZIsnefNP1slYamgP"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:27:56.000",
        "data": {
            "detail_level": "high",
            "section_id": "ce822799-0629-496a-a72f-202b19b8e04d",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "9sneDC5GJFlowiXskcrl"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:27:56.000",
        "data": {
            "detail_level": "high",
            "section_id": "ce822799-0629-496a-a72f-202b19b8e04d",
            "structured_type": "structured",
            "mapping_index": 4
        },
        "event": "mapping_hover",
        "id": "BGUfg2mf3c4JIPjub8zx"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:27:56.000",
        "data": {
            "detail_level": "high",
            "section_id": "ce822799-0629-496a-a72f-202b19b8e04d",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "FCV1igVBCL7B3edwvTwH"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:27:56.000",
        "data": {
            "detail_level": "high",
            "section_id": "ce822799-0629-496a-a72f-202b19b8e04d",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "Mne9H12JDI3JVdCufJWX"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:27:56.000",
        "data": {
            "detail_level": "high",
            "section_id": "ce822799-0629-496a-a72f-202b19b8e04d",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "QNUYfhqOF92RV3rxJRue"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:27:56.000",
        "data": {
            "detail_level": "high",
            "section_id": "ce822799-0629-496a-a72f-202b19b8e04d",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "R1B6n4ohiYh5jXf7DHvy"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:27:56.000",
        "data": {
            "detail_level": "high",
            "section_id": "ce822799-0629-496a-a72f-202b19b8e04d",
            "structured_type": "structured",
            "mapping_index": 0
        },
        "event": "mapping_hover",
        "id": "W25Jgq8TZDXY9t4caoGO"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:27:56.000",
        "data": {
            "detail_level": "high",
            "section_id": "ce822799-0629-496a-a72f-202b19b8e04d",
            "structured_type": "structured",
            "mapping_index": 6
        },
        "event": "mapping_hover",
        "id": "aoY4v05eDyYQX4LUj6jL"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:27:56.000",
        "data": {
            "detail_level": "high",
            "section_id": "ce822799-0629-496a-a72f-202b19b8e04d",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "bZpfaBb3xPXMVZjx4jgv"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:27:56.000",
        "data": {
            "detail_level": "high",
            "section_id": "ce822799-0629-496a-a72f-202b19b8e04d",
            "structured_type": "structured",
            "mapping_index": 9
        },
        "event": "mapping_hover",
        "id": "brEUPh4jE0Gxkr69O9pz"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:27:56.000",
        "data": {
            "detail_level": "high",
            "section_id": "ce822799-0629-496a-a72f-202b19b8e04d",
            "structured_type": "structured",
            "mapping_index": 7
        },
        "event": "mapping_hover",
        "id": "frpOYmkydPscsCBUSA2v"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:27:56.000",
        "data": {
            "detail_level": "high",
            "section_id": "ce822799-0629-496a-a72f-202b19b8e04d",
            "structured_type": "structured",
            "mapping_index": 3
        },
        "event": "mapping_hover",
        "id": "q2iO5bvtwzq9rBWEujDw"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:27:56.000",
        "data": {
            "detail_level": "high",
            "section_id": "ce822799-0629-496a-a72f-202b19b8e04d",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "qOX9TnjKkAospVEKopBR"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:27:56.000",
        "data": {
            "detail_level": "high",
            "section_id": "ce822799-0629-496a-a72f-202b19b8e04d",
            "structured_type": "structured",
            "mapping_index": 2
        },
        "event": "mapping_hover",
        "id": "rKZSMCPnpfe0AGh8wUWE"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:27:56.000",
        "data": {
            "detail_level": "high",
            "section_id": "ce822799-0629-496a-a72f-202b19b8e04d",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "s01nidwQYrLMKCx0yX1F"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:28:06.000",
        "data": {
            "detail_level": "high",
            "section_id": "ce822799-0629-496a-a72f-202b19b8e04d",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "5ZuWoGMHdcQSr48UdeX7"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:28:06.000",
        "data": {
            "detail_level": "high",
            "section_id": "ce822799-0629-496a-a72f-202b19b8e04d",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "80ZxHRFLZ9Adb823Glu5"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:28:06.000",
        "data": {
            "detail_level": "high",
            "section_id": "ce822799-0629-496a-a72f-202b19b8e04d",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "8xIgESiZNmA4EQSO8k88"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:28:06.000",
        "data": {
            "detail_level": "high",
            "section_id": "ce822799-0629-496a-a72f-202b19b8e04d",
            "structured_type": "structured",
            "mapping_index": 8
        },
        "event": "mapping_hover",
        "id": "9Sq5d3FukS7v6ELKTPNP"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:28:06.000",
        "data": {
            "detail_level": "high",
            "section_id": "ce822799-0629-496a-a72f-202b19b8e04d",
            "structured_type": "structured",
            "mapping_index": 7
        },
        "event": "mapping_hover",
        "id": "CJVBHv5uzNdgtu3u1F9q"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:28:06.000",
        "data": {
            "detail_level": "high",
            "section_id": "ce822799-0629-496a-a72f-202b19b8e04d",
            "structured_type": "structured",
            "mapping_index": 5
        },
        "event": "mapping_hover",
        "id": "DfyF2OoU2gv1S6R8gauF"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:28:06.000",
        "data": {
            "detail_level": "high",
            "section_id": "ce822799-0629-496a-a72f-202b19b8e04d",
            "structured_type": "structured",
            "mapping_index": 6
        },
        "event": "mapping_hover",
        "id": "S4kLmuyID8jWayFslPFB"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:28:06.000",
        "data": {
            "detail_level": "high",
            "section_id": "ce822799-0629-496a-a72f-202b19b8e04d",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "TRle9ehUhdO12rAq1eEI"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:28:06.000",
        "data": {
            "detail_level": "high",
            "section_id": "ce822799-0629-496a-a72f-202b19b8e04d",
            "structured_type": "structured",
            "mapping_index": 3
        },
        "event": "mapping_hover",
        "id": "UgwY0suGb55BTxZKQmlb"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:28:06.000",
        "data": {
            "detail_level": "high",
            "section_id": "ce822799-0629-496a-a72f-202b19b8e04d",
            "structured_type": "structured",
            "mapping_index": 9
        },
        "event": "mapping_hover",
        "id": "hToMVs6hZCtDwulOaZAL"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:28:06.000",
        "data": {
            "detail_level": "high",
            "section_id": "ce822799-0629-496a-a72f-202b19b8e04d",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "ixwgM6AMJWWAxisyG3IX"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:28:06.000",
        "data": {
            "detail_level": "high",
            "section_id": "ce822799-0629-496a-a72f-202b19b8e04d",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "r00a7uK1bGgjcKlye0V4"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:28:06.000",
        "data": {
            "detail_level": "high",
            "section_id": "ce822799-0629-496a-a72f-202b19b8e04d",
            "structured_type": "structured",
            "mapping_index": 2
        },
        "event": "mapping_hover",
        "id": "xaYm2jt1Uf7EBpk8AfWp"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:28:06.000",
        "data": {
            "detail_level": "high",
            "section_id": "ce822799-0629-496a-a72f-202b19b8e04d",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "yO1yUvLvZbmwlBczqlmh"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:28:27.000",
        "data": {
            "detail_level": "high",
            "section_id": "ce822799-0629-496a-a72f-202b19b8e04d",
            "structured_type": "structured",
            "mapping_index": 9
        },
        "event": "mapping_hover",
        "id": "02eD5AvOBtp2ECs4HriQ"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:28:27.000",
        "data": {
            "detail_level": "high",
            "section_id": "ce822799-0629-496a-a72f-202b19b8e04d",
            "structured_type": "structured"
        },
        "event": "mapping_unhover",
        "id": "oUd4ULT0s4YidejBDqq5"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:28:28.000",
        "data": {
            "structured": "structured",
            "detail_level": "high",
            "instruction": "Do not use Prediction error for visualization. Instead, you should set two bars for every player, #f9d3c2 indicates predicated rank and #a9c7fc indicates true rank, you should also add two legend on the top of the chart to indicate the color meaning",
            "original_summary": "• Computes the prediction error for each entry as PredictedRank minus Rank.\n• Filters the DataFrame to include only rows from the specified year.\n• Sorts the filtered data by true rank for ordered visualization.\n• Creates a bar plot using seaborn:\n  ◦ X-axis: Player or entry names\n  ◦ Y-axis: Prediction error (PredictedRank - Rank)\n  ◦ Bars are colored by name using a 'coolwarm' palette\n• Adds a horizontal dashed line at y=0 to indicate no prediction error.\n• Rotates x-axis labels for better readability and sets axis labels and plot title.\n• Adjusts layout for appearance and saves the plot as a PNG file named for the year.",
            "section_id": "ce822799-0629-496a-a72f-202b19b8e04d"
        },
        "event": "apply_instruction_summary",
        "id": "1yP8OTJbkYQ0X4iXCcTU"
    },
    {
        "source": "backend",
        "timestamp": "2025-08-23 14:28:31.000",
        "data": {
            "original_code": "def plot_ranking_predictions(df, year):\n    \"\"\"\n    Plot prediction error for a specific year.\n\n    Args:\n        df: DataFrame containing prediction results\n        year: Year to plot prediction errors for\n    \"\"\"\n    df[\"RankError\"] = df[\"PredictedRank\"] - df[\"Rank\"]\n    year_df = df[df[\"Year\"] == year].copy()\n    year_df.sort_values(\"Rank\", inplace=True)\n\n    plt.figure(figsize=(12, 6))\n    sns.barplot(x=\"Name\", y=\"RankError\", data=year_df, hue=\"Name\", palette=\"coolwarm\")\n    plt.axhline(0, color=\"black\", linestyle=\"--\")\n    plt.xticks(rotation=45, ha=\"right\")\n    plt.ylabel(\"Predicted Rank - True Rank\")\n    plt.title(f\"MVP Ranking Predictions ({year})\")\n    plt.tight_layout()\n    plt.savefig(f\"data/ranking_predictions_{year}.png\")",
            "instruction": "Do not use Prediction error for visualization. Instead, you should set two bars for every player, #f9d3c2 indicates predicated rank and #a9c7fc indicates true rank, you should also add two legend on the top of the chart to indicate the color meaning",
            "original_summary": "• Computes the prediction error for each entry as PredictedRank minus Rank.\n• Filters the DataFrame to include only rows from the specified year.\n• Sorts the filtered data by true rank for ordered visualization.\n• Creates a bar plot using seaborn:\n  ◦ X-axis: Player or entry names\n  ◦ Y-axis: Prediction error (PredictedRank - Rank)\n  ◦ Bars are colored by name using a 'coolwarm' palette\n• Adds a horizontal dashed line at y=0 to indicate no prediction error.\n• Rotates x-axis labels for better readability and sets axis labels and plot title.\n• Adjusts layout for appearance and saves the plot as a PNG file named for the year.",
            "updated_summary": "• For each player or entry, creates two bars: one representing the predicted rank (colored #f9d3c2) and one representing the true rank (colored #a9c7fc).\n• Does not use prediction error for visualization.\n• Computes the predicted rank and true rank for each entry.\n• Filters the DataFrame to include only rows from the specified year.\n• Sorts the filtered data by true rank for ordered visualization.\n• Creates a grouped bar plot using seaborn or matplotlib:\n  ◦ X-axis: Player or entry names\n  ◦ Y-axis: Rank values (both predicted and true)\n  ◦ Each player has two bars side by side, colored as specified above\n• Adds two legends at the top of the chart to indicate the color meaning for predicted rank and true rank.\n• Rotates x-axis labels for better readability and sets axis labels and plot title.\n• Adjusts layout for appearance and saves the plot as a PNG file named for the year."
        },
        "event": "apply_instruction_summary",
        "id": "Hlcp0LRCuJrgDNYbaQqv"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:28:46.000",
        "data": {
            "structured": "structured",
            "detail_level": "high",
            "edited_summary": "• For each player or entry, creates two bars: one representing the predicted rank (colored #f9d3c2) and one representing the true rank (colored #a9c7fc).\n• Does not use prediction error for visualization.\n• Computes the predicted rank and true rank for each entry.\n• Filters the DataFrame to include only rows from the specified year.\n• Sorts the filtered data by true rank for ordered visualization.\n• Creates a grouped bar plot using seaborn or matplotlib:\n  ◦ X-axis: Player or entry names\n  ◦ Y-axis: Rank values (both predicted and true)\n  ◦ Each player has two bars side by side, colored as specified above\n• Adds two legends at the top of the chart to indicate the color meaning for predicted rank and true rank.\n• Rotates x-axis labels for better readability and sets axis labels and plot title.\n• Adjusts layout for appearance and saves the plot as a PNG file named for the year.",
            "section_id": "ce822799-0629-496a-a72f-202b19b8e04d",
            "original_summary": "• Computes the prediction error for each entry as PredictedRank minus Rank.\n• Filters the DataFrame to include only rows from the specified year.\n• Sorts the filtered data by true rank for ordered visualization.\n• Creates a bar plot using seaborn:\n  ◦ X-axis: Player or entry names\n  ◦ Y-axis: Prediction error (PredictedRank - Rank)\n  ◦ Bars are colored by name using a 'coolwarm' palette\n• Adds a horizontal dashed line at y=0 to indicate no prediction error.\n• Rotates x-axis labels for better readability and sets axis labels and plot title.\n• Adjusts layout for appearance and saves the plot as a PNG file named for the year."
        },
        "event": "commit_modified_summary",
        "id": "Nlhjz3eRR1rRFOaHWPtr"
    },
    {
        "source": "backend",
        "timestamp": "2025-08-23 14:28:50.000",
        "data": {
            "original_code": "def plot_ranking_predictions(df, year):\n    \"\"\"\n    Plot prediction error for a specific year.\n\n    Args:\n        df: DataFrame containing prediction results\n        year: Year to plot prediction errors for\n    \"\"\"\n    df[\"RankError\"] = df[\"PredictedRank\"] - df[\"Rank\"]\n    year_df = df[df[\"Year\"] == year].copy()\n    year_df.sort_values(\"Rank\", inplace=True)\n\n    plt.figure(figsize=(12, 6))\n    sns.barplot(x=\"Name\", y=\"RankError\", data=year_df, hue=\"Name\", palette=\"coolwarm\")\n    plt.axhline(0, color=\"black\", linestyle=\"--\")\n    plt.xticks(rotation=45, ha=\"right\")\n    plt.ylabel(\"Predicted Rank - True Rank\")\n    plt.title(f\"MVP Ranking Predictions ({year})\")\n    plt.tight_layout()\n    plt.savefig(f\"data/ranking_predictions_{year}.png\")",
            "updated_code": "def plot_ranking_predictions(df, year):\n    \"\"\"\n    Plot predicted and true ranks for a specific year.\n\n    Args:\n        df: DataFrame containing prediction results\n        year: Year to plot prediction results for\n    \"\"\"\n    year_df = df[df[\"Year\"] == year].copy()\n    year_df.sort_values(\"Rank\", inplace=True)\n\n    names = year_df[\"Name\"].tolist()\n    predicted_ranks = year_df[\"PredictedRank\"].tolist()\n    true_ranks = year_df[\"Rank\"].tolist()\n    x = np.arange(len(names))\n    bar_width = 0.35\n\n    plt.figure(figsize=(12, 6))\n    plt.bar(x - bar_width/2, predicted_ranks, width=bar_width, color=\"#f9d3c2\", label=\"Predicted Rank\")\n    plt.bar(x + bar_width/2, true_ranks, width=bar_width, color=\"#a9c7fc\", label=\"True Rank\")\n\n    plt.xticks(x, names, rotation=45, ha=\"right\")\n    plt.ylabel(\"Rank\")\n    plt.title(f\"MVP Ranking Predictions ({year})\")\n    plt.legend(loc=\"upper center\", bbox_to_anchor=(0.5, 1.08), ncol=2)\n    plt.tight_layout()\n    plt.savefig(f\"data/ranking_predictions_{year}.png\")",
            "detail_level": "high",
            "original_summary": "• Computes the prediction error for each entry as PredictedRank minus Rank.\n• Filters the DataFrame to include only rows from the specified year.\n• Sorts the filtered data by true rank for ordered visualization.\n• Creates a bar plot using seaborn:\n  ◦ X-axis: Player or entry names\n  ◦ Y-axis: Prediction error (PredictedRank - Rank)\n  ◦ Bars are colored by name using a 'coolwarm' palette\n• Adds a horizontal dashed line at y=0 to indicate no prediction error.\n• Rotates x-axis labels for better readability and sets axis labels and plot title.\n• Adjusts layout for appearance and saves the plot as a PNG file named for the year.",
            "edited_summary": "• For each player or entry, creates two bars: one representing the predicted rank (colored #f9d3c2) and one representing the true rank (colored #a9c7fc).\n• Does not use prediction error for visualization.\n• Computes the predicted rank and true rank for each entry.\n• Filters the DataFrame to include only rows from the specified year.\n• Sorts the filtered data by true rank for ordered visualization.\n• Creates a grouped bar plot using seaborn or matplotlib:\n  ◦ X-axis: Player or entry names\n  ◦ Y-axis: Rank values (both predicted and true)\n  ◦ Each player has two bars side by side, colored as specified above\n• Adds two legends at the top of the chart to indicate the color meaning for predicted rank and true rank.\n• Rotates x-axis labels for better readability and sets axis labels and plot title.\n• Adjusts layout for appearance and saves the plot as a PNG file named for the year.",
            "structured_type": "structured"
        },
        "event": "modify_summary_mediation",
        "id": "P79iGU00S4SlFkkVwRRL"
    },
    {
        "source": "backend",
        "timestamp": "2025-08-23 14:28:54.000",
        "data": {
            "original_code": "def plot_ranking_predictions(df, year):\n    \"\"\"\n    Plot predicted and true ranks for a specific year.\n\n    Args:\n        df: DataFrame containing prediction results\n        year: Year to plot prediction results for\n    \"\"\"\n    year_df = df[df[\"Year\"] == year].copy()\n    year_df.sort_values(\"Rank\", inplace=True)\n\n    names = year_df[\"Name\"].tolist()\n    predicted_ranks = year_df[\"PredictedRank\"].tolist()\n    true_ranks = year_df[\"Rank\"].tolist()\n    x = np.arange(len(names))\n    bar_width = 0.35\n\n    plt.figure(figsize=(12, 6))\n    plt.bar(x - bar_width/2, predicted_ranks, width=bar_width, color=\"#f9d3c2\", label=\"Predicted Rank\")\n    plt.bar(x + bar_width/2, true_ranks, width=bar_width, color=\"#a9c7fc\", label=\"True Rank\")\n\n    plt.xticks(x, names, rotation=45, ha=\"right\")\n    plt.ylabel(\"Rank\")\n    plt.title(f\"MVP Ranking Predictions ({year})\")\n    plt.legend(loc=\"upper center\", bbox_to_anchor=(0.5, 1.08), ncol=2)\n    plt.tight_layout()\n    plt.savefig(f\"data/ranking_predictions_{year}.png\")",
            "old_summary": {
                "high_unstructured": "The plot_ranking_predictions function generates a bar plot that visualizes the prediction error (difference between predicted and true ranks) for each individual in a specified year. It first computes the error, filters and sorts the data for the given year, and then uses seaborn to create a color-coded bar plot with names on the x-axis and prediction errors on the y-axis. The plot includes a horizontal reference line at zero, rotated x-axis labels for readability, and descriptive axis labels and title. Finally, the plot is saved as a PNG file named according to the year, allowing for easy review of model performance for that specific year.",
                "low_structured": "• Plots prediction errors for a given year.\n• Saves the resulting bar chart as an image.",
                "high_structured": "• Computes the prediction error for each entry as PredictedRank minus Rank.\n• Filters the DataFrame to include only rows from the specified year.\n• Sorts the filtered data by true rank for ordered visualization.\n• Creates a bar plot using seaborn:\n  ◦ X-axis: Player or entry names\n  ◦ Y-axis: Prediction error (PredictedRank - Rank)\n  ◦ Bars are colored by name using a 'coolwarm' palette\n• Adds a horizontal dashed line at y=0 to indicate no prediction error.\n• Rotates x-axis labels for better readability and sets axis labels and plot title.\n• Adjusts layout for appearance and saves the plot as a PNG file named for the year.",
                "title": "plot_ranking_predictions Function Summary",
                "medium_unstructured": "The plot_ranking_predictions function visualizes the difference between predicted and actual ranks for a specific year using a bar plot. It highlights each individual's prediction error and saves the plot as a PNG file. The chart helps assess model performance for that year.",
                "medium_structured": "• Calculates prediction error (PredictedRank - Rank) for each entry.\n• Filters data for the specified year and sorts by true rank.\n• Creates a bar plot of prediction errors by name, with color differentiation.\n• Saves the plot as a PNG file for later review.",
                "low_unstructured": "This function creates and saves a bar plot showing prediction errors for a specified year."
            },
            "new_summary": {
                "high_unstructured": "The plot_ranking_predictions function generates a grouped bar plot that visualizes both the predicted and true ranks for each individual in a specified year, instead of plotting the prediction error. It filters and sorts the data for the given year, then uses matplotlib to create a side-by-side bar plot with names on the x-axis and both predicted and true ranks on the y-axis, each with distinct colors and a legend. The plot includes rotated x-axis labels for readability, descriptive axis labels and title, and is saved as a PNG file named according to the year, allowing for easy review of model performance for that specific year.",
                "low_structured": "• Plots both predicted and true ranks for a given year using side-by-side bars.\n• Saves the resulting bar chart as an image.",
                "high_structured": "• Retrieves predicted and true ranks for each entry.\n• Filters the DataFrame to include only rows from the specified year.\n• Sorts the filtered data by true rank for ordered visualization.\n• Creates a grouped bar plot using matplotlib:\n  ◦ X-axis: Player or entry names\n  ◦ Y-axis: Predicted and true ranks (side-by-side bars)\n  ◦ Bars are colored differently for predicted and true ranks, with a legend\n• Rotates x-axis labels for better readability and sets axis labels and plot title.\n• Adjusts layout for appearance and saves the plot as a PNG file named for the year.",
                "title": "plot_ranking_predictions Function Summary",
                "medium_unstructured": "The plot_ranking_predictions function visualizes the predicted and actual ranks for a specific year using a grouped bar plot, rather than highlighting prediction errors. It displays both predicted and true ranks for each individual and saves the plot as a PNG file. The chart helps assess model performance for that year.",
                "medium_structured": "• Retrieves predicted and true ranks for each entry.\n• Filters data for the specified year and sorts by true rank.\n• Creates a grouped bar plot showing both predicted and true ranks by name, with color differentiation.\n• Saves the plot as a PNG file for later review.",
                "low_unstructured": "This function creates and saves a bar plot showing both predicted and true ranks for a specified year, instead of plotting prediction errors."
            },
            "new_code": "def plot_ranking_predictions(df, year):\n    \"\"\"\n    Plot predicted and true ranks for a specific year.\n\n    Args:\n        df: DataFrame containing prediction results\n        year: Year to plot prediction results for\n    \"\"\"\n    year_df = df[df[\"Year\"] == year].copy()\n    year_df.sort_values(\"Rank\", inplace=True)\n\n    names = year_df[\"Name\"].tolist()\n    predicted_ranks = year_df[\"PredictedRank\"].tolist()\n    true_ranks = year_df[\"Rank\"].tolist()\n    x = np.arange(len(names))\n    bar_width = 0.35\n\n    plt.figure(figsize=(12, 6))\n    plt.bar(x - bar_width/2, predicted_ranks, width=bar_width, color=\"#f9d3c2\", label=\"Predicted Rank\")\n    plt.bar(x + bar_width/2, true_ranks, width=bar_width, color=\"#a9c7fc\", label=\"True Rank\")\n\n    plt.xticks(x, names, rotation=45, ha=\"right\")\n    plt.ylabel(\"Rank\")\n    plt.title(f\"MVP Ranking Predictions ({year})\")\n    plt.legend(loc=\"upper center\", bbox_to_anchor=(0.5, 1.08), ncol=2)\n    plt.tight_layout()\n    plt.savefig(f\"data/ranking_predictions_{year}.png\")"
        },
        "event": "summarize_modified_code",
        "id": "nPfD9WOymUmfPaWMFusP"
    },
    {
        "source": "backend",
        "timestamp": "2025-08-23 14:28:55.000",
        "data": {
            "summary": "• Plots both predicted and true ranks for a given year using side-by-side bars.\n• Saves the resulting bar chart as an image.",
            "code": "52: def plot_ranking_predictions(df, year):\n53:     \"\"\"\n54:     Plot predicted and true ranks for a specific year.\n55: \n56:     Args:\n57:         df: DataFrame containing prediction results\n58:         year: Year to plot prediction results for\n59:     \"\"\"\n60:     year_df = df[df[\"Year\"] == year].copy()\n61:     year_df.sort_values(\"Rank\", inplace=True)\n62: \n63:     names = year_df[\"Name\"].tolist()\n64:     predicted_ranks = year_df[\"PredictedRank\"].tolist()\n65:     true_ranks = year_df[\"Rank\"].tolist()\n66:     x = np.arange(len(names))\n67:     bar_width = 0.35\n68: \n69:     plt.figure(figsize=(12, 6))\n70:     plt.bar(x - bar_width/2, predicted_ranks, width=bar_width, color=\"#f9d3c2\", label=\"Predicted Rank\")\n71:     plt.bar(x + bar_width/2, true_ranks, width=bar_width, color=\"#a9c7fc\", label=\"True Rank\")\n72: \n73:     plt.xticks(x, names, rotation=45, ha=\"right\")\n74:     plt.ylabel(\"Rank\")\n75:     plt.title(f\"MVP Ranking Predictions ({year})\")\n76:     plt.legend(loc=\"upper center\", bbox_to_anchor=(0.5, 1.08), ncol=2)\n77:     plt.tight_layout()\n78:     plt.savefig(f\"data/ranking_predictions_{year}.png\")",
            "mapping": [
                {
                    "codeSegments": [
                        {
                            "line": 70,
                            "code": "plt.bar(x - bar_width/2, predicted_ranks, width=bar_width, color=\"#f9d3c2\", label=\"Predicted Rank\")"
                        },
                        {
                            "line": 71,
                            "code": "plt.bar(x + bar_width/2, true_ranks, width=bar_width, color=\"#a9c7fc\", label=\"True Rank\")"
                        }
                    ],
                    "summaryComponent": "Plots both predicted and true ranks for a given year using side-by-side bars."
                },
                {
                    "codeSegments": [
                        {
                            "line": 78,
                            "code": "plt.savefig(f\"data/ranking_predictions_{year}.png\")"
                        }
                    ],
                    "summaryComponent": "Saves the resulting bar chart as an image."
                }
            ]
        },
        "event": "map_summary_code",
        "id": "kFpDiM9x0vPYIpzWgeYF"
    },
    {
        "source": "backend",
        "timestamp": "2025-08-23 14:28:57.000",
        "data": {
            "summary": "This function creates and saves a bar plot showing both predicted and true ranks for a specified year, instead of plotting prediction errors.",
            "code": "52: def plot_ranking_predictions(df, year):\n53:     \"\"\"\n54:     Plot predicted and true ranks for a specific year.\n55: \n56:     Args:\n57:         df: DataFrame containing prediction results\n58:         year: Year to plot prediction results for\n59:     \"\"\"\n60:     year_df = df[df[\"Year\"] == year].copy()\n61:     year_df.sort_values(\"Rank\", inplace=True)\n62: \n63:     names = year_df[\"Name\"].tolist()\n64:     predicted_ranks = year_df[\"PredictedRank\"].tolist()\n65:     true_ranks = year_df[\"Rank\"].tolist()\n66:     x = np.arange(len(names))\n67:     bar_width = 0.35\n68: \n69:     plt.figure(figsize=(12, 6))\n70:     plt.bar(x - bar_width/2, predicted_ranks, width=bar_width, color=\"#f9d3c2\", label=\"Predicted Rank\")\n71:     plt.bar(x + bar_width/2, true_ranks, width=bar_width, color=\"#a9c7fc\", label=\"True Rank\")\n72: \n73:     plt.xticks(x, names, rotation=45, ha=\"right\")\n74:     plt.ylabel(\"Rank\")\n75:     plt.title(f\"MVP Ranking Predictions ({year})\")\n76:     plt.legend(loc=\"upper center\", bbox_to_anchor=(0.5, 1.08), ncol=2)\n77:     plt.tight_layout()\n78:     plt.savefig(f\"data/ranking_predictions_{year}.png\")",
            "mapping": [
                {
                    "codeSegments": [
                        {
                            "line": 52,
                            "code": "def plot_ranking_predictions(df, year):"
                        },
                        {
                            "line": 69,
                            "code": "plt.figure(figsize=(12, 6))"
                        },
                        {
                            "line": 78,
                            "code": "plt.savefig(f\"data/ranking_predictions_{year}.png\")"
                        }
                    ],
                    "summaryComponent": "This function creates and saves a bar plot"
                },
                {
                    "codeSegments": [
                        {
                            "line": 70,
                            "code": "plt.bar(x - bar_width/2, predicted_ranks, width=bar_width, color=\"#f9d3c2\", label=\"Predicted Rank\")"
                        },
                        {
                            "line": 71,
                            "code": "plt.bar(x + bar_width/2, true_ranks, width=bar_width, color=\"#a9c7fc\", label=\"True Rank\")"
                        }
                    ],
                    "summaryComponent": "showing both predicted and true ranks"
                },
                {
                    "codeSegments": [
                        {
                            "line": 60,
                            "code": "year_df = df[df[\"Year\"] == year].copy()"
                        },
                        {
                            "line": 75,
                            "code": "plt.title(f\"MVP Ranking Predictions ({year})\")"
                        },
                        {
                            "line": 78,
                            "code": "plt.savefig(f\"data/ranking_predictions_{year}.png\")"
                        }
                    ],
                    "summaryComponent": "for a specified year"
                },
                {
                    "codeSegments": [
                        {
                            "line": 70,
                            "code": "plt.bar(x - bar_width/2, predicted_ranks, width=bar_width, color=\"#f9d3c2\", label=\"Predicted Rank\")"
                        },
                        {
                            "line": 71,
                            "code": "plt.bar(x + bar_width/2, true_ranks, width=bar_width, color=\"#a9c7fc\", label=\"True Rank\")"
                        }
                    ],
                    "summaryComponent": "instead of plotting prediction errors"
                }
            ]
        },
        "event": "map_summary_code",
        "id": "F1pFbzPoOZNvMwhGtCV9"
    },
    {
        "source": "backend",
        "timestamp": "2025-08-23 14:28:57.000",
        "data": {
            "summary": "• Retrieves predicted and true ranks for each entry.\n• Filters data for the specified year and sorts by true rank.\n• Creates a grouped bar plot showing both predicted and true ranks by name, with color differentiation.\n• Saves the plot as a PNG file for later review.",
            "code": "52: def plot_ranking_predictions(df, year):\n53:     \"\"\"\n54:     Plot predicted and true ranks for a specific year.\n55: \n56:     Args:\n57:         df: DataFrame containing prediction results\n58:         year: Year to plot prediction results for\n59:     \"\"\"\n60:     year_df = df[df[\"Year\"] == year].copy()\n61:     year_df.sort_values(\"Rank\", inplace=True)\n62: \n63:     names = year_df[\"Name\"].tolist()\n64:     predicted_ranks = year_df[\"PredictedRank\"].tolist()\n65:     true_ranks = year_df[\"Rank\"].tolist()\n66:     x = np.arange(len(names))\n67:     bar_width = 0.35\n68: \n69:     plt.figure(figsize=(12, 6))\n70:     plt.bar(x - bar_width/2, predicted_ranks, width=bar_width, color=\"#f9d3c2\", label=\"Predicted Rank\")\n71:     plt.bar(x + bar_width/2, true_ranks, width=bar_width, color=\"#a9c7fc\", label=\"True Rank\")\n72: \n73:     plt.xticks(x, names, rotation=45, ha=\"right\")\n74:     plt.ylabel(\"Rank\")\n75:     plt.title(f\"MVP Ranking Predictions ({year})\")\n76:     plt.legend(loc=\"upper center\", bbox_to_anchor=(0.5, 1.08), ncol=2)\n77:     plt.tight_layout()\n78:     plt.savefig(f\"data/ranking_predictions_{year}.png\")",
            "mapping": [
                {
                    "codeSegments": [
                        {
                            "line": 64,
                            "code": "predicted_ranks = year_df[\"PredictedRank\"].tolist()"
                        },
                        {
                            "line": 65,
                            "code": "true_ranks = year_df[\"Rank\"].tolist()"
                        }
                    ],
                    "summaryComponent": "Retrieves predicted and true ranks for each entry."
                },
                {
                    "codeSegments": [
                        {
                            "line": 60,
                            "code": "year_df = df[df[\"Year\"] == year].copy()"
                        },
                        {
                            "line": 61,
                            "code": "year_df.sort_values(\"Rank\", inplace=True)"
                        }
                    ],
                    "summaryComponent": "Filters data for the specified year and sorts by true rank."
                },
                {
                    "codeSegments": [
                        {
                            "line": 70,
                            "code": "plt.bar(x - bar_width/2, predicted_ranks, width=bar_width, color=\"#f9d3c2\", label=\"Predicted Rank\")"
                        },
                        {
                            "line": 71,
                            "code": "plt.bar(x + bar_width/2, true_ranks, width=bar_width, color=\"#a9c7fc\", label=\"True Rank\")"
                        },
                        {
                            "line": 73,
                            "code": "plt.xticks(x, names, rotation=45, ha=\"right\")"
                        }
                    ],
                    "summaryComponent": "Creates a grouped bar plot showing both predicted and true ranks by name, with color differentiation."
                },
                {
                    "codeSegments": [
                        {
                            "line": 78,
                            "code": "plt.savefig(f\"data/ranking_predictions_{year}.png\")"
                        }
                    ],
                    "summaryComponent": "Saves the plot as a PNG file for later review."
                }
            ]
        },
        "event": "map_summary_code",
        "id": "mXxMBMHkIrKtVcQbVcDA"
    },
    {
        "source": "backend",
        "timestamp": "2025-08-23 14:28:59.000",
        "data": {
            "summary": "The plot_ranking_predictions function visualizes the predicted and actual ranks for a specific year using a grouped bar plot, rather than highlighting prediction errors. It displays both predicted and true ranks for each individual and saves the plot as a PNG file. The chart helps assess model performance for that year.",
            "code": "52: def plot_ranking_predictions(df, year):\n53:     \"\"\"\n54:     Plot predicted and true ranks for a specific year.\n55: \n56:     Args:\n57:         df: DataFrame containing prediction results\n58:         year: Year to plot prediction results for\n59:     \"\"\"\n60:     year_df = df[df[\"Year\"] == year].copy()\n61:     year_df.sort_values(\"Rank\", inplace=True)\n62: \n63:     names = year_df[\"Name\"].tolist()\n64:     predicted_ranks = year_df[\"PredictedRank\"].tolist()\n65:     true_ranks = year_df[\"Rank\"].tolist()\n66:     x = np.arange(len(names))\n67:     bar_width = 0.35\n68: \n69:     plt.figure(figsize=(12, 6))\n70:     plt.bar(x - bar_width/2, predicted_ranks, width=bar_width, color=\"#f9d3c2\", label=\"Predicted Rank\")\n71:     plt.bar(x + bar_width/2, true_ranks, width=bar_width, color=\"#a9c7fc\", label=\"True Rank\")\n72: \n73:     plt.xticks(x, names, rotation=45, ha=\"right\")\n74:     plt.ylabel(\"Rank\")\n75:     plt.title(f\"MVP Ranking Predictions ({year})\")\n76:     plt.legend(loc=\"upper center\", bbox_to_anchor=(0.5, 1.08), ncol=2)\n77:     plt.tight_layout()\n78:     plt.savefig(f\"data/ranking_predictions_{year}.png\")",
            "mapping": [
                {
                    "codeSegments": [
                        {
                            "line": 52,
                            "code": "def plot_ranking_predictions(df, year):"
                        }
                    ],
                    "summaryComponent": "The plot_ranking_predictions function"
                },
                {
                    "codeSegments": [
                        {
                            "line": 60,
                            "code": "year_df = df[df[\"Year\"] == year].copy()"
                        },
                        {
                            "line": 64,
                            "code": "predicted_ranks = year_df[\"PredictedRank\"].tolist()"
                        },
                        {
                            "line": 65,
                            "code": "true_ranks = year_df[\"Rank\"].tolist()"
                        }
                    ],
                    "summaryComponent": "visualizes the predicted and actual ranks for a specific year"
                },
                {
                    "codeSegments": [
                        {
                            "line": 70,
                            "code": "plt.bar(x - bar_width/2, predicted_ranks, width=bar_width, color=\"#f9d3c2\", label=\"Predicted Rank\")"
                        },
                        {
                            "line": 71,
                            "code": "plt.bar(x + bar_width/2, true_ranks, width=bar_width, color=\"#a9c7fc\", label=\"True Rank\")"
                        }
                    ],
                    "summaryComponent": "using a grouped bar plot"
                },
                {
                    "codeSegments": [],
                    "summaryComponent": "rather than highlighting prediction errors"
                },
                {
                    "codeSegments": [
                        {
                            "line": 70,
                            "code": "plt.bar(x - bar_width/2, predicted_ranks, width=bar_width, color=\"#f9d3c2\", label=\"Predicted Rank\")"
                        },
                        {
                            "line": 71,
                            "code": "plt.bar(x + bar_width/2, true_ranks, width=bar_width, color=\"#a9c7fc\", label=\"True Rank\")"
                        },
                        {
                            "line": 73,
                            "code": "plt.xticks(x, names, rotation=45, ha=\"right\")"
                        }
                    ],
                    "summaryComponent": "It displays both predicted and true ranks for each individual"
                },
                {
                    "codeSegments": [
                        {
                            "line": 78,
                            "code": "plt.savefig(f\"data/ranking_predictions_{year}.png\")"
                        }
                    ],
                    "summaryComponent": "and saves the plot as a PNG file"
                },
                {
                    "codeSegments": [
                        {
                            "line": 75,
                            "code": "plt.title(f\"MVP Ranking Predictions ({year})\")"
                        }
                    ],
                    "summaryComponent": "The chart helps assess model performance for that year"
                }
            ]
        },
        "event": "map_summary_code",
        "id": "D32cVprAy9bLYGBIFfDf"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:29:00.000",
        "data": {
            "after_section_id": "27acfc6c-29e2-42f5-b9de-8dc06a0d3748",
            "before_section_id": "ce822799-0629-496a-a72f-202b19b8e04d"
        },
        "event": "autotransit_section",
        "id": "RQemy3ilYYdKBVLiZazf"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:29:00.000",
        "data": {
            "section_data": {
                "editPromptValue": "",
                "summaryData": {
                    "high_unstructured": "The plot_ranking_predictions function generates a grouped bar plot that visualizes both the predicted and true ranks for each individual in a specified year, instead of plotting the prediction error. It filters and sorts the data for the given year, then uses matplotlib to create a side-by-side bar plot with names on the x-axis and both predicted and true ranks on the y-axis, each with distinct colors and a legend. The plot includes rotated x-axis labels for readability, descriptive axis labels and title, and is saved as a PNG file named according to the year, allowing for easy review of model performance for that specific year.",
                    "low_structured": "• Plots both predicted and true ranks for a given year using side-by-side bars.\n• Saves the resulting bar chart as an image.",
                    "high_structured": "• Retrieves predicted and true ranks for each entry.\n• Filters the DataFrame to include only rows from the specified year.\n• Sorts the filtered data by true rank for ordered visualization.\n• Creates a grouped bar plot using matplotlib:\n  ◦ X-axis: Player or entry names\n  ◦ Y-axis: Predicted and true ranks (side-by-side bars)\n  ◦ Bars are colored differently for predicted and true ranks, with a legend\n• Rotates x-axis labels for better readability and sets axis labels and plot title.\n• Adjusts layout for appearance and saves the plot as a PNG file named for the year.",
                    "title": "plot_ranking_predictions Function Summary",
                    "medium_unstructured": "The plot_ranking_predictions function visualizes the predicted and actual ranks for a specific year using a grouped bar plot, rather than highlighting prediction errors. It displays both predicted and true ranks for each individual and saves the plot as a PNG file. The chart helps assess model performance for that year.",
                    "medium_structured": "• Retrieves predicted and true ranks for each entry.\n• Filters data for the specified year and sorts by true rank.\n• Creates a grouped bar plot showing both predicted and true ranks by name, with color differentiation.\n• Saves the plot as a PNG file for later review.",
                    "low_unstructured": "This function creates and saves a bar plot showing both predicted and true ranks for a specified year, instead of plotting prediction errors."
                },
                "selectedDetailLevel": "medium",
                "title": "plot_ranking_predictions Function Summary",
                "summaryMappings": {
                    "low_structured": [
                        {
                            "codeSegments": [
                                {
                                    "line": 70,
                                    "code": "plt.bar(x - bar_width/2, predicted_ranks, width=bar_width, color=\"#f9d3c2\", label=\"Predicted Rank\")"
                                },
                                {
                                    "line": 71,
                                    "code": "plt.bar(x + bar_width/2, true_ranks, width=bar_width, color=\"#a9c7fc\", label=\"True Rank\")"
                                }
                            ],
                            "summaryComponent": "Plots both predicted and true ranks for a given year using side-by-side bars."
                        },
                        {
                            "codeSegments": [
                                {
                                    "line": 78,
                                    "code": "plt.savefig(f\"data/ranking_predictions_{year}.png\")"
                                }
                            ],
                            "summaryComponent": "Saves the resulting bar chart as an image."
                        }
                    ],
                    "high_structured": [
                        {
                            "codeSegments": [
                                {
                                    "line": 64,
                                    "code": "predicted_ranks = year_df[\"PredictedRank\"].tolist()"
                                },
                                {
                                    "line": 65,
                                    "code": "true_ranks = year_df[\"Rank\"].tolist()"
                                }
                            ],
                            "summaryComponent": "Retrieves predicted and true ranks for each entry."
                        },
                        {
                            "codeSegments": [
                                {
                                    "line": 60,
                                    "code": "year_df = df[df[\"Year\"] == year].copy()"
                                }
                            ],
                            "summaryComponent": "Filters the DataFrame to include only rows from the specified year."
                        },
                        {
                            "codeSegments": [
                                {
                                    "line": 61,
                                    "code": "year_df.sort_values(\"Rank\", inplace=True)"
                                }
                            ],
                            "summaryComponent": "Sorts the filtered data by true rank for ordered visualization."
                        },
                        {
                            "codeSegments": [
                                {
                                    "line": 70,
                                    "code": "plt.bar(x - bar_width/2, predicted_ranks, width=bar_width, color=\"#f9d3c2\", label=\"Predicted Rank\")"
                                },
                                {
                                    "line": 71,
                                    "code": "plt.bar(x + bar_width/2, true_ranks, width=bar_width, color=\"#a9c7fc\", label=\"True Rank\")"
                                }
                            ],
                            "summaryComponent": "Creates a grouped bar plot using matplotlib:"
                        },
                        {
                            "codeSegments": [
                                {
                                    "line": 73,
                                    "code": "plt.xticks(x, names, rotation=45, ha=\"right\")"
                                }
                            ],
                            "summaryComponent": "X-axis: Player or entry names"
                        },
                        {
                            "codeSegments": [
                                {
                                    "line": 70,
                                    "code": "plt.bar(x - bar_width/2, predicted_ranks, width=bar_width, color=\"#f9d3c2\", label=\"Predicted Rank\")"
                                },
                                {
                                    "line": 71,
                                    "code": "plt.bar(x + bar_width/2, true_ranks, width=bar_width, color=\"#a9c7fc\", label=\"True Rank\")"
                                }
                            ],
                            "summaryComponent": "Y-axis: Predicted and true ranks (side-by-side bars)"
                        },
                        {
                            "codeSegments": [
                                {
                                    "line": 70,
                                    "code": "plt.bar(x - bar_width/2, predicted_ranks, width=bar_width, color=\"#f9d3c2\", label=\"Predicted Rank\")"
                                },
                                {
                                    "line": 71,
                                    "code": "plt.bar(x + bar_width/2, true_ranks, width=bar_width, color=\"#a9c7fc\", label=\"True Rank\")"
                                },
                                {
                                    "line": 76,
                                    "code": "plt.legend(loc=\"upper center\", bbox_to_anchor=(0.5, 1.08), ncol=2)"
                                }
                            ],
                            "summaryComponent": "Bars are colored differently for predicted and true ranks, with a legend"
                        },
                        {
                            "codeSegments": [
                                {
                                    "line": 73,
                                    "code": "plt.xticks(x, names, rotation=45, ha=\"right\")"
                                },
                                {
                                    "line": 74,
                                    "code": "plt.ylabel(\"Rank\")"
                                },
                                {
                                    "line": 75,
                                    "code": "plt.title(f\"MVP Ranking Predictions ({year})\")"
                                }
                            ],
                            "summaryComponent": "Rotates x-axis labels for better readability and sets axis labels and plot title."
                        },
                        {
                            "codeSegments": [
                                {
                                    "line": 77,
                                    "code": "plt.tight_layout()"
                                },
                                {
                                    "line": 78,
                                    "code": "plt.savefig(f\"data/ranking_predictions_{year}.png\")"
                                }
                            ],
                            "summaryComponent": "Adjusts layout for appearance and saves the plot as a PNG file named for the year."
                        }
                    ],
                    "medium_structured": [
                        {
                            "codeSegments": [
                                {
                                    "line": 64,
                                    "code": "predicted_ranks = year_df[\"PredictedRank\"].tolist()"
                                },
                                {
                                    "line": 65,
                                    "code": "true_ranks = year_df[\"Rank\"].tolist()"
                                }
                            ],
                            "summaryComponent": "Retrieves predicted and true ranks for each entry."
                        },
                        {
                            "codeSegments": [
                                {
                                    "line": 60,
                                    "code": "year_df = df[df[\"Year\"] == year].copy()"
                                },
                                {
                                    "line": 61,
                                    "code": "year_df.sort_values(\"Rank\", inplace=True)"
                                }
                            ],
                            "summaryComponent": "Filters data for the specified year and sorts by true rank."
                        },
                        {
                            "codeSegments": [
                                {
                                    "line": 70,
                                    "code": "plt.bar(x - bar_width/2, predicted_ranks, width=bar_width, color=\"#f9d3c2\", label=\"Predicted Rank\")"
                                },
                                {
                                    "line": 71,
                                    "code": "plt.bar(x + bar_width/2, true_ranks, width=bar_width, color=\"#a9c7fc\", label=\"True Rank\")"
                                },
                                {
                                    "line": 73,
                                    "code": "plt.xticks(x, names, rotation=45, ha=\"right\")"
                                }
                            ],
                            "summaryComponent": "Creates a grouped bar plot showing both predicted and true ranks by name, with color differentiation."
                        },
                        {
                            "codeSegments": [
                                {
                                    "line": 78,
                                    "code": "plt.savefig(f\"data/ranking_predictions_{year}.png\")"
                                }
                            ],
                            "summaryComponent": "Saves the plot as a PNG file for later review."
                        }
                    ],
                    "medium_unstructured": [
                        {
                            "codeSegments": [
                                {
                                    "line": 52,
                                    "code": "def plot_ranking_predictions(df, year):"
                                }
                            ],
                            "summaryComponent": "The plot_ranking_predictions function"
                        },
                        {
                            "codeSegments": [
                                {
                                    "line": 60,
                                    "code": "year_df = df[df[\"Year\"] == year].copy()"
                                },
                                {
                                    "line": 64,
                                    "code": "predicted_ranks = year_df[\"PredictedRank\"].tolist()"
                                },
                                {
                                    "line": 65,
                                    "code": "true_ranks = year_df[\"Rank\"].tolist()"
                                }
                            ],
                            "summaryComponent": "visualizes the predicted and actual ranks for a specific year"
                        },
                        {
                            "codeSegments": [
                                {
                                    "line": 70,
                                    "code": "plt.bar(x - bar_width/2, predicted_ranks, width=bar_width, color=\"#f9d3c2\", label=\"Predicted Rank\")"
                                },
                                {
                                    "line": 71,
                                    "code": "plt.bar(x + bar_width/2, true_ranks, width=bar_width, color=\"#a9c7fc\", label=\"True Rank\")"
                                }
                            ],
                            "summaryComponent": "using a grouped bar plot"
                        },
                        {
                            "codeSegments": [],
                            "summaryComponent": "rather than highlighting prediction errors"
                        },
                        {
                            "codeSegments": [
                                {
                                    "line": 70,
                                    "code": "plt.bar(x - bar_width/2, predicted_ranks, width=bar_width, color=\"#f9d3c2\", label=\"Predicted Rank\")"
                                },
                                {
                                    "line": 71,
                                    "code": "plt.bar(x + bar_width/2, true_ranks, width=bar_width, color=\"#a9c7fc\", label=\"True Rank\")"
                                },
                                {
                                    "line": 73,
                                    "code": "plt.xticks(x, names, rotation=45, ha=\"right\")"
                                }
                            ],
                            "summaryComponent": "It displays both predicted and true ranks for each individual"
                        },
                        {
                            "codeSegments": [
                                {
                                    "line": 78,
                                    "code": "plt.savefig(f\"data/ranking_predictions_{year}.png\")"
                                }
                            ],
                            "summaryComponent": "and saves the plot as a PNG file"
                        },
                        {
                            "codeSegments": [
                                {
                                    "line": 75,
                                    "code": "plt.title(f\"MVP Ranking Predictions ({year})\")"
                                }
                            ],
                            "summaryComponent": "The chart helps assess model performance for that year"
                        }
                    ],
                    "high_unstructured": [
                        {
                            "codeSegments": [
                                {
                                    "line": 52,
                                    "code": "def plot_ranking_predictions(df, year):"
                                }
                            ],
                            "summaryComponent": "The plot_ranking_predictions function"
                        },
                        {
                            "codeSegments": [
                                {
                                    "line": 70,
                                    "code": "plt.bar(x - bar_width/2, predicted_ranks, width=bar_width, color=\"#f9d3c2\", label=\"Predicted Rank\")"
                                },
                                {
                                    "line": 71,
                                    "code": "plt.bar(x + bar_width/2, true_ranks, width=bar_width, color=\"#a9c7fc\", label=\"True Rank\")"
                                }
                            ],
                            "summaryComponent": "generates a grouped bar plot"
                        },
                        {
                            "codeSegments": [
                                {
                                    "line": 60,
                                    "code": "year_df = df[df[\"Year\"] == year].copy()"
                                },
                                {
                                    "line": 64,
                                    "code": "predicted_ranks = year_df[\"PredictedRank\"].tolist()"
                                },
                                {
                                    "line": 65,
                                    "code": "true_ranks = year_df[\"Rank\"].tolist()"
                                }
                            ],
                            "summaryComponent": "visualizes both the predicted and true ranks for each individual in a specified year"
                        },
                        {
                            "codeSegments": [
                                {
                                    "line": 70,
                                    "code": "plt.bar(x - bar_width/2, predicted_ranks, width=bar_width, color=\"#f9d3c2\", label=\"Predicted Rank\")"
                                },
                                {
                                    "line": 71,
                                    "code": "plt.bar(x + bar_width/2, true_ranks, width=bar_width, color=\"#a9c7fc\", label=\"True Rank\")"
                                }
                            ],
                            "summaryComponent": "instead of plotting the prediction error"
                        },
                        {
                            "codeSegments": [
                                {
                                    "line": 60,
                                    "code": "year_df = df[df[\"Year\"] == year].copy()"
                                },
                                {
                                    "line": 61,
                                    "code": "year_df.sort_values(\"Rank\", inplace=True)"
                                }
                            ],
                            "summaryComponent": "It filters and sorts the data for the given year"
                        },
                        {
                            "codeSegments": [
                                {
                                    "line": 70,
                                    "code": "plt.bar(x - bar_width/2, predicted_ranks, width=bar_width, color=\"#f9d3c2\", label=\"Predicted Rank\")"
                                },
                                {
                                    "line": 71,
                                    "code": "plt.bar(x + bar_width/2, true_ranks, width=bar_width, color=\"#a9c7fc\", label=\"True Rank\")"
                                }
                            ],
                            "summaryComponent": "then uses matplotlib to create a side-by-side bar plot"
                        },
                        {
                            "codeSegments": [
                                {
                                    "line": 63,
                                    "code": "names = year_df[\"Name\"].tolist()"
                                },
                                {
                                    "line": 73,
                                    "code": "plt.xticks(x, names, rotation=45, ha=\"right\")"
                                }
                            ],
                            "summaryComponent": "with names on the x-axis"
                        },
                        {
                            "codeSegments": [
                                {
                                    "line": 70,
                                    "code": "plt.bar(x - bar_width/2, predicted_ranks, width=bar_width, color=\"#f9d3c2\", label=\"Predicted Rank\")"
                                },
                                {
                                    "line": 71,
                                    "code": "plt.bar(x + bar_width/2, true_ranks, width=bar_width, color=\"#a9c7fc\", label=\"True Rank\")"
                                }
                            ],
                            "summaryComponent": "and both predicted and true ranks on the y-axis"
                        },
                        {
                            "codeSegments": [
                                {
                                    "line": 70,
                                    "code": "plt.bar(x - bar_width/2, predicted_ranks, width=bar_width, color=\"#f9d3c2\", label=\"Predicted Rank\")"
                                },
                                {
                                    "line": 71,
                                    "code": "plt.bar(x + bar_width/2, true_ranks, width=bar_width, color=\"#a9c7fc\", label=\"True Rank\")"
                                },
                                {
                                    "line": 76,
                                    "code": "plt.legend(loc=\"upper center\", bbox_to_anchor=(0.5, 1.08), ncol=2)"
                                }
                            ],
                            "summaryComponent": "each with distinct colors and a legend"
                        },
                        {
                            "codeSegments": [
                                {
                                    "line": 73,
                                    "code": "plt.xticks(x, names, rotation=45, ha=\"right\")"
                                },
                                {
                                    "line": 74,
                                    "code": "plt.ylabel(\"Rank\")"
                                },
                                {
                                    "line": 75,
                                    "code": "plt.title(f\"MVP Ranking Predictions ({year})\")"
                                },
                                {
                                    "line": 78,
                                    "code": "plt.savefig(f\"data/ranking_predictions_{year}.png\")"
                                }
                            ],
                            "summaryComponent": "The plot includes rotated x-axis labels for readability, descriptive axis labels and title, and is saved as a PNG file named according to the year, allowing for easy review of model performance for that specific year."
                        }
                    ],
                    "low_unstructured": [
                        {
                            "codeSegments": [
                                {
                                    "line": 52,
                                    "code": "def plot_ranking_predictions(df, year):"
                                },
                                {
                                    "line": 69,
                                    "code": "plt.figure(figsize=(12, 6))"
                                },
                                {
                                    "line": 78,
                                    "code": "plt.savefig(f\"data/ranking_predictions_{year}.png\")"
                                }
                            ],
                            "summaryComponent": "This function creates and saves a bar plot"
                        },
                        {
                            "codeSegments": [
                                {
                                    "line": 70,
                                    "code": "plt.bar(x - bar_width/2, predicted_ranks, width=bar_width, color=\"#f9d3c2\", label=\"Predicted Rank\")"
                                },
                                {
                                    "line": 71,
                                    "code": "plt.bar(x + bar_width/2, true_ranks, width=bar_width, color=\"#a9c7fc\", label=\"True Rank\")"
                                }
                            ],
                            "summaryComponent": "showing both predicted and true ranks"
                        },
                        {
                            "codeSegments": [
                                {
                                    "line": 60,
                                    "code": "year_df = df[df[\"Year\"] == year].copy()"
                                },
                                {
                                    "line": 75,
                                    "code": "plt.title(f\"MVP Ranking Predictions ({year})\")"
                                },
                                {
                                    "line": 78,
                                    "code": "plt.savefig(f\"data/ranking_predictions_{year}.png\")"
                                }
                            ],
                            "summaryComponent": "for a specified year"
                        },
                        {
                            "codeSegments": [
                                {
                                    "line": 70,
                                    "code": "plt.bar(x - bar_width/2, predicted_ranks, width=bar_width, color=\"#f9d3c2\", label=\"Predicted Rank\")"
                                },
                                {
                                    "line": 71,
                                    "code": "plt.bar(x + bar_width/2, true_ranks, width=bar_width, color=\"#a9c7fc\", label=\"True Rank\")"
                                }
                            ],
                            "summaryComponent": "instead of plotting prediction errors"
                        }
                    ]
                },
                "oldSummaryData": {
                    "high_unstructured": "The plot_ranking_predictions function generates a bar plot that visualizes the prediction error (difference between predicted and true ranks) for each individual in a specified year. It first computes the error, filters and sorts the data for the given year, and then uses seaborn to create a color-coded bar plot with names on the x-axis and prediction errors on the y-axis. The plot includes a horizontal reference line at zero, rotated x-axis labels for readability, and descriptive axis labels and title. Finally, the plot is saved as a PNG file named according to the year, allowing for easy review of model performance for that specific year.",
                    "low_structured": "• Plots prediction errors for a given year.\n• Saves the resulting bar chart as an image.",
                    "high_structured": "• Computes the prediction error for each entry as PredictedRank minus Rank.\n• Filters the DataFrame to include only rows from the specified year.\n• Sorts the filtered data by true rank for ordered visualization.\n• Creates a bar plot using seaborn:\n  ◦ X-axis: Player or entry names\n  ◦ Y-axis: Prediction error (PredictedRank - Rank)\n  ◦ Bars are colored by name using a 'coolwarm' palette\n• Adds a horizontal dashed line at y=0 to indicate no prediction error.\n• Rotates x-axis labels for better readability and sets axis labels and plot title.\n• Adjusts layout for appearance and saves the plot as a PNG file named for the year.",
                    "title": "plot_ranking_predictions Function Summary",
                    "medium_unstructured": "The plot_ranking_predictions function visualizes the difference between predicted and actual ranks for a specific year using a bar plot. It highlights each individual's prediction error and saves the plot as a PNG file. The chart helps assess model performance for that year.",
                    "medium_structured": "• Calculates prediction error (PredictedRank - Rank) for each entry.\n• Filters data for the specified year and sorts by true rank.\n• Creates a bar plot of prediction errors by name, with color differentiation.\n• Saves the plot as a PNG file for later review.",
                    "low_unstructured": "This function creates and saves a bar plot showing prediction errors for a specified year."
                },
                "metadata": {
                    "id": "27acfc6c-29e2-42f5-b9de-8dc06a0d3748",
                    "filename": "rank_model.py",
                    "offset": 1205,
                    "fullPath": "/project/workspace/rank_model.py",
                    "originalCode": "def plot_ranking_predictions(df, year):\n    \"\"\"\n    Plot predicted and true ranks for a specific year.\n\n    Args:\n        df: DataFrame containing prediction results\n        year: Year to plot prediction results for\n    \"\"\"\n    year_df = df[df[\"Year\"] == year].copy()\n    year_df.sort_values(\"Rank\", inplace=True)\n\n    names = year_df[\"Name\"].tolist()\n    predicted_ranks = year_df[\"PredictedRank\"].tolist()\n    true_ranks = year_df[\"Rank\"].tolist()\n    x = np.arange(len(names))\n    bar_width = 0.35\n\n    plt.figure(figsize=(12, 6))\n    plt.bar(x - bar_width/2, predicted_ranks, width=bar_width, color=\"#f9d3c2\", label=\"Predicted Rank\")\n    plt.bar(x + bar_width/2, true_ranks, width=bar_width, color=\"#a9c7fc\", label=\"True Rank\")\n\n    plt.xticks(x, names, rotation=45, ha=\"right\")\n    plt.ylabel(\"Rank\")\n    plt.title(f\"MVP Ranking Predictions ({year})\")\n    plt.legend(loc=\"upper center\", bbox_to_anchor=(0.5, 1.08), ncol=2)\n    plt.tight_layout()\n    plt.savefig(f\"data/ranking_predictions_{year}.png\")"
                },
                "createdAt": 1755988141000,
                "lines": [
                    52,
                    78
                ],
                "editPromptStructured": null,
                "selectedStructured": "unstructured",
                "editPromptDetailLevel": null
            },
            "section_id": "27acfc6c-29e2-42f5-b9de-8dc06a0d3748"
        },
        "event": "create_new_section",
        "id": "YkQo6iV51Nq5tnF0dGkI"
    },
    {
        "source": "backend",
        "timestamp": "2025-08-23 14:29:01.000",
        "data": {
            "summary": "• Retrieves predicted and true ranks for each entry.\n• Filters the DataFrame to include only rows from the specified year.\n• Sorts the filtered data by true rank for ordered visualization.\n• Creates a grouped bar plot using matplotlib:\n  ◦ X-axis: Player or entry names\n  ◦ Y-axis: Predicted and true ranks (side-by-side bars)\n  ◦ Bars are colored differently for predicted and true ranks, with a legend\n• Rotates x-axis labels for better readability and sets axis labels and plot title.\n• Adjusts layout for appearance and saves the plot as a PNG file named for the year.",
            "code": "52: def plot_ranking_predictions(df, year):\n53:     \"\"\"\n54:     Plot predicted and true ranks for a specific year.\n55: \n56:     Args:\n57:         df: DataFrame containing prediction results\n58:         year: Year to plot prediction results for\n59:     \"\"\"\n60:     year_df = df[df[\"Year\"] == year].copy()\n61:     year_df.sort_values(\"Rank\", inplace=True)\n62: \n63:     names = year_df[\"Name\"].tolist()\n64:     predicted_ranks = year_df[\"PredictedRank\"].tolist()\n65:     true_ranks = year_df[\"Rank\"].tolist()\n66:     x = np.arange(len(names))\n67:     bar_width = 0.35\n68: \n69:     plt.figure(figsize=(12, 6))\n70:     plt.bar(x - bar_width/2, predicted_ranks, width=bar_width, color=\"#f9d3c2\", label=\"Predicted Rank\")\n71:     plt.bar(x + bar_width/2, true_ranks, width=bar_width, color=\"#a9c7fc\", label=\"True Rank\")\n72: \n73:     plt.xticks(x, names, rotation=45, ha=\"right\")\n74:     plt.ylabel(\"Rank\")\n75:     plt.title(f\"MVP Ranking Predictions ({year})\")\n76:     plt.legend(loc=\"upper center\", bbox_to_anchor=(0.5, 1.08), ncol=2)\n77:     plt.tight_layout()\n78:     plt.savefig(f\"data/ranking_predictions_{year}.png\")",
            "mapping": [
                {
                    "codeSegments": [
                        {
                            "line": 64,
                            "code": "predicted_ranks = year_df[\"PredictedRank\"].tolist()"
                        },
                        {
                            "line": 65,
                            "code": "true_ranks = year_df[\"Rank\"].tolist()"
                        }
                    ],
                    "summaryComponent": "Retrieves predicted and true ranks for each entry."
                },
                {
                    "codeSegments": [
                        {
                            "line": 60,
                            "code": "year_df = df[df[\"Year\"] == year].copy()"
                        }
                    ],
                    "summaryComponent": "Filters the DataFrame to include only rows from the specified year."
                },
                {
                    "codeSegments": [
                        {
                            "line": 61,
                            "code": "year_df.sort_values(\"Rank\", inplace=True)"
                        }
                    ],
                    "summaryComponent": "Sorts the filtered data by true rank for ordered visualization."
                },
                {
                    "codeSegments": [
                        {
                            "line": 70,
                            "code": "plt.bar(x - bar_width/2, predicted_ranks, width=bar_width, color=\"#f9d3c2\", label=\"Predicted Rank\")"
                        },
                        {
                            "line": 71,
                            "code": "plt.bar(x + bar_width/2, true_ranks, width=bar_width, color=\"#a9c7fc\", label=\"True Rank\")"
                        }
                    ],
                    "summaryComponent": "Creates a grouped bar plot using matplotlib:"
                },
                {
                    "codeSegments": [
                        {
                            "line": 73,
                            "code": "plt.xticks(x, names, rotation=45, ha=\"right\")"
                        }
                    ],
                    "summaryComponent": "X-axis: Player or entry names"
                },
                {
                    "codeSegments": [
                        {
                            "line": 70,
                            "code": "plt.bar(x - bar_width/2, predicted_ranks, width=bar_width, color=\"#f9d3c2\", label=\"Predicted Rank\")"
                        },
                        {
                            "line": 71,
                            "code": "plt.bar(x + bar_width/2, true_ranks, width=bar_width, color=\"#a9c7fc\", label=\"True Rank\")"
                        }
                    ],
                    "summaryComponent": "Y-axis: Predicted and true ranks (side-by-side bars)"
                },
                {
                    "codeSegments": [
                        {
                            "line": 70,
                            "code": "plt.bar(x - bar_width/2, predicted_ranks, width=bar_width, color=\"#f9d3c2\", label=\"Predicted Rank\")"
                        },
                        {
                            "line": 71,
                            "code": "plt.bar(x + bar_width/2, true_ranks, width=bar_width, color=\"#a9c7fc\", label=\"True Rank\")"
                        },
                        {
                            "line": 76,
                            "code": "plt.legend(loc=\"upper center\", bbox_to_anchor=(0.5, 1.08), ncol=2)"
                        }
                    ],
                    "summaryComponent": "Bars are colored differently for predicted and true ranks, with a legend"
                },
                {
                    "codeSegments": [
                        {
                            "line": 73,
                            "code": "plt.xticks(x, names, rotation=45, ha=\"right\")"
                        },
                        {
                            "line": 74,
                            "code": "plt.ylabel(\"Rank\")"
                        },
                        {
                            "line": 75,
                            "code": "plt.title(f\"MVP Ranking Predictions ({year})\")"
                        }
                    ],
                    "summaryComponent": "Rotates x-axis labels for better readability and sets axis labels and plot title."
                },
                {
                    "codeSegments": [
                        {
                            "line": 77,
                            "code": "plt.tight_layout()"
                        },
                        {
                            "line": 78,
                            "code": "plt.savefig(f\"data/ranking_predictions_{year}.png\")"
                        }
                    ],
                    "summaryComponent": "Adjusts layout for appearance and saves the plot as a PNG file named for the year."
                }
            ]
        },
        "event": "map_summary_code",
        "id": "kZVKQ7wOlwusAaQPQtDI"
    },
    {
        "source": "backend",
        "timestamp": "2025-08-23 14:29:01.000",
        "data": {
            "summary": "The plot_ranking_predictions function generates a grouped bar plot that visualizes both the predicted and true ranks for each individual in a specified year, instead of plotting the prediction error. It filters and sorts the data for the given year, then uses matplotlib to create a side-by-side bar plot with names on the x-axis and both predicted and true ranks on the y-axis, each with distinct colors and a legend. The plot includes rotated x-axis labels for readability, descriptive axis labels and title, and is saved as a PNG file named according to the year, allowing for easy review of model performance for that specific year.",
            "code": "52: def plot_ranking_predictions(df, year):\n53:     \"\"\"\n54:     Plot predicted and true ranks for a specific year.\n55: \n56:     Args:\n57:         df: DataFrame containing prediction results\n58:         year: Year to plot prediction results for\n59:     \"\"\"\n60:     year_df = df[df[\"Year\"] == year].copy()\n61:     year_df.sort_values(\"Rank\", inplace=True)\n62: \n63:     names = year_df[\"Name\"].tolist()\n64:     predicted_ranks = year_df[\"PredictedRank\"].tolist()\n65:     true_ranks = year_df[\"Rank\"].tolist()\n66:     x = np.arange(len(names))\n67:     bar_width = 0.35\n68: \n69:     plt.figure(figsize=(12, 6))\n70:     plt.bar(x - bar_width/2, predicted_ranks, width=bar_width, color=\"#f9d3c2\", label=\"Predicted Rank\")\n71:     plt.bar(x + bar_width/2, true_ranks, width=bar_width, color=\"#a9c7fc\", label=\"True Rank\")\n72: \n73:     plt.xticks(x, names, rotation=45, ha=\"right\")\n74:     plt.ylabel(\"Rank\")\n75:     plt.title(f\"MVP Ranking Predictions ({year})\")\n76:     plt.legend(loc=\"upper center\", bbox_to_anchor=(0.5, 1.08), ncol=2)\n77:     plt.tight_layout()\n78:     plt.savefig(f\"data/ranking_predictions_{year}.png\")",
            "mapping": [
                {
                    "codeSegments": [
                        {
                            "line": 52,
                            "code": "def plot_ranking_predictions(df, year):"
                        }
                    ],
                    "summaryComponent": "The plot_ranking_predictions function"
                },
                {
                    "codeSegments": [
                        {
                            "line": 70,
                            "code": "plt.bar(x - bar_width/2, predicted_ranks, width=bar_width, color=\"#f9d3c2\", label=\"Predicted Rank\")"
                        },
                        {
                            "line": 71,
                            "code": "plt.bar(x + bar_width/2, true_ranks, width=bar_width, color=\"#a9c7fc\", label=\"True Rank\")"
                        }
                    ],
                    "summaryComponent": "generates a grouped bar plot"
                },
                {
                    "codeSegments": [
                        {
                            "line": 60,
                            "code": "year_df = df[df[\"Year\"] == year].copy()"
                        },
                        {
                            "line": 64,
                            "code": "predicted_ranks = year_df[\"PredictedRank\"].tolist()"
                        },
                        {
                            "line": 65,
                            "code": "true_ranks = year_df[\"Rank\"].tolist()"
                        }
                    ],
                    "summaryComponent": "visualizes both the predicted and true ranks for each individual in a specified year"
                },
                {
                    "codeSegments": [
                        {
                            "line": 70,
                            "code": "plt.bar(x - bar_width/2, predicted_ranks, width=bar_width, color=\"#f9d3c2\", label=\"Predicted Rank\")"
                        },
                        {
                            "line": 71,
                            "code": "plt.bar(x + bar_width/2, true_ranks, width=bar_width, color=\"#a9c7fc\", label=\"True Rank\")"
                        }
                    ],
                    "summaryComponent": "instead of plotting the prediction error"
                },
                {
                    "codeSegments": [
                        {
                            "line": 60,
                            "code": "year_df = df[df[\"Year\"] == year].copy()"
                        },
                        {
                            "line": 61,
                            "code": "year_df.sort_values(\"Rank\", inplace=True)"
                        }
                    ],
                    "summaryComponent": "It filters and sorts the data for the given year"
                },
                {
                    "codeSegments": [
                        {
                            "line": 70,
                            "code": "plt.bar(x - bar_width/2, predicted_ranks, width=bar_width, color=\"#f9d3c2\", label=\"Predicted Rank\")"
                        },
                        {
                            "line": 71,
                            "code": "plt.bar(x + bar_width/2, true_ranks, width=bar_width, color=\"#a9c7fc\", label=\"True Rank\")"
                        }
                    ],
                    "summaryComponent": "then uses matplotlib to create a side-by-side bar plot"
                },
                {
                    "codeSegments": [
                        {
                            "line": 63,
                            "code": "names = year_df[\"Name\"].tolist()"
                        },
                        {
                            "line": 73,
                            "code": "plt.xticks(x, names, rotation=45, ha=\"right\")"
                        }
                    ],
                    "summaryComponent": "with names on the x-axis"
                },
                {
                    "codeSegments": [
                        {
                            "line": 70,
                            "code": "plt.bar(x - bar_width/2, predicted_ranks, width=bar_width, color=\"#f9d3c2\", label=\"Predicted Rank\")"
                        },
                        {
                            "line": 71,
                            "code": "plt.bar(x + bar_width/2, true_ranks, width=bar_width, color=\"#a9c7fc\", label=\"True Rank\")"
                        }
                    ],
                    "summaryComponent": "and both predicted and true ranks on the y-axis"
                },
                {
                    "codeSegments": [
                        {
                            "line": 70,
                            "code": "plt.bar(x - bar_width/2, predicted_ranks, width=bar_width, color=\"#f9d3c2\", label=\"Predicted Rank\")"
                        },
                        {
                            "line": 71,
                            "code": "plt.bar(x + bar_width/2, true_ranks, width=bar_width, color=\"#a9c7fc\", label=\"True Rank\")"
                        },
                        {
                            "line": 76,
                            "code": "plt.legend(loc=\"upper center\", bbox_to_anchor=(0.5, 1.08), ncol=2)"
                        }
                    ],
                    "summaryComponent": "each with distinct colors and a legend"
                },
                {
                    "codeSegments": [
                        {
                            "line": 73,
                            "code": "plt.xticks(x, names, rotation=45, ha=\"right\")"
                        },
                        {
                            "line": 74,
                            "code": "plt.ylabel(\"Rank\")"
                        },
                        {
                            "line": 75,
                            "code": "plt.title(f\"MVP Ranking Predictions ({year})\")"
                        },
                        {
                            "line": 78,
                            "code": "plt.savefig(f\"data/ranking_predictions_{year}.png\")"
                        }
                    ],
                    "summaryComponent": "The plot includes rotated x-axis labels for readability, descriptive axis labels and title, and is saved as a PNG file named according to the year, allowing for easy review of model performance for that specific year."
                }
            ]
        },
        "event": "map_summary_code",
        "id": "ubyk4X6DyCVh8PVhPh1g"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:29:06.000",
        "data": {
            "detail_level": "medium",
            "section_id": "27acfc6c-29e2-42f5-b9de-8dc06a0d3748",
            "structured_type": "unstructured"
        },
        "event": "mapping_unhover",
        "id": "9UZys44Ee5sDDCxvbKdG"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:29:06.000",
        "data": {
            "detail_level": "medium",
            "section_id": "27acfc6c-29e2-42f5-b9de-8dc06a0d3748",
            "structured_type": "unstructured",
            "mapping_index": 6
        },
        "event": "mapping_hover",
        "id": "J8gWhqIhwYz3iUjH1HjR"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:29:06.000",
        "data": {
            "detail_level": "medium",
            "section_id": "27acfc6c-29e2-42f5-b9de-8dc06a0d3748",
            "structured_type": "unstructured"
        },
        "event": "mapping_unhover",
        "id": "LAo9RxFLSDhJvKEYeE6m"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:29:06.000",
        "data": {
            "detail_level": "medium",
            "section_id": "27acfc6c-29e2-42f5-b9de-8dc06a0d3748",
            "structured_type": "unstructured",
            "mapping_index": 4
        },
        "event": "mapping_hover",
        "id": "gndXNCTB1bcuHkMQ9v4U"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:29:06.000",
        "data": {
            "detail_level": "medium",
            "section_id": "27acfc6c-29e2-42f5-b9de-8dc06a0d3748",
            "structured_type": "unstructured",
            "mapping_index": 0
        },
        "event": "mapping_hover",
        "id": "nGac73LxqydnxfL3fXmL"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:29:06.000",
        "data": {
            "detail_level": "medium",
            "section_id": "27acfc6c-29e2-42f5-b9de-8dc06a0d3748",
            "structured_type": "unstructured",
            "mapping_index": 2
        },
        "event": "mapping_hover",
        "id": "p95PT0lVDg2swcnL5yuM"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:29:06.000",
        "data": {
            "detail_level": "medium",
            "section_id": "27acfc6c-29e2-42f5-b9de-8dc06a0d3748",
            "structured_type": "unstructured"
        },
        "event": "mapping_unhover",
        "id": "qOmuMtnUQaOaBBekeD8k"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:29:06.000",
        "data": {
            "detail_level": "medium",
            "section_id": "27acfc6c-29e2-42f5-b9de-8dc06a0d3748",
            "structured_type": "unstructured"
        },
        "event": "mapping_unhover",
        "id": "uYZaiDI4xdsZe7mFfUQ0"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:29:07.000",
        "data": {
            "detail_level": "medium",
            "section_id": "27acfc6c-29e2-42f5-b9de-8dc06a0d3748",
            "structured_type": "unstructured"
        },
        "event": "mapping_unhover",
        "id": "1YKztDORsid6oQk8AQlu"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:29:07.000",
        "data": {
            "detail_level": "medium",
            "section_id": "27acfc6c-29e2-42f5-b9de-8dc06a0d3748",
            "structured_type": "unstructured",
            "mapping_index": 2
        },
        "event": "mapping_hover",
        "id": "5kvbiuAOMNtKxgAeBill"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:29:07.000",
        "data": {
            "detail_level": "medium",
            "section_id": "27acfc6c-29e2-42f5-b9de-8dc06a0d3748",
            "structured_type": "unstructured",
            "mapping_index": 0
        },
        "event": "mapping_hover",
        "id": "BE2UFryCumDwgTn4alpH"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:29:07.000",
        "data": {
            "detail_level": "medium",
            "section_id": "27acfc6c-29e2-42f5-b9de-8dc06a0d3748",
            "structured_type": "unstructured"
        },
        "event": "mapping_unhover",
        "id": "kMzitn7zauCxqMpDg6jD"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:29:07.000",
        "data": {
            "detail_level": "medium",
            "section_id": "27acfc6c-29e2-42f5-b9de-8dc06a0d3748",
            "structured_type": "unstructured"
        },
        "event": "mapping_unhover",
        "id": "qLVOuNK5yEKswh3FS3P6"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:29:07.000",
        "data": {
            "detail_level": "medium",
            "section_id": "27acfc6c-29e2-42f5-b9de-8dc06a0d3748",
            "structured_type": "unstructured",
            "mapping_index": 4
        },
        "event": "mapping_hover",
        "id": "sBnbHQYX6eYDTzXIP7fm"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:33:24.000",
        "data": {
            "detail_level": "medium",
            "section_id": "27acfc6c-29e2-42f5-b9de-8dc06a0d3748",
            "structured_type": "unstructured",
            "mapping_index": 3
        },
        "event": "mapping_hover",
        "id": "Cx6AQn6FV8D1ohNAyTDi"
    },
    {
        "source": "frontend",
        "timestamp": "2025-08-23 14:33:24.000",
        "data": {
            "detail_level": "medium",
            "section_id": "27acfc6c-29e2-42f5-b9de-8dc06a0d3748",
            "structured_type": "unstructured"
        },
        "event": "mapping_unhover",
        "id": "XJ9TCiQKLSDf7idClB0i"
    }
]