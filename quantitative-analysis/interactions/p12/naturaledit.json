[
    {
        "source": "frontend",
        "event": "click_summarize_code",
        "timestamp": "2025-08-24 11:43:49.000",
        "data": {},
        "id": "Ct5CecmXGnNrFDyyyOGY"
    },
    {
        "source": "frontend",
        "event": "click_summarize_code",
        "timestamp": "2025-08-24 11:43:59.000",
        "data": {},
        "id": "rniHYgCyPQHOAfGmdTFK"
    },
    {
        "source": "backend",
        "event": "summarize_selected_code",
        "timestamp": "2025-08-24 11:44:05.000",
        "data": {
            "summary": {
                "medium_structured": "• Scrapes MVP voting data and player statistics from Basketball Reference\n• Processes data for multiple NBA seasons (2018-2025 by default)\n• Saves MVP votes and season stats into separate CSV files\n• Handles data extraction, cleaning, and output",
                "low_unstructured": "This code scrapes NBA MVP votes and player statistics from Basketball Reference and saves them as CSV files.",
                "high_structured": "• Defines functions to scrape and process NBA data from Basketball Reference\n  ◦ scrape_mvp_votes: Collects MVP voting tables for each year, renames columns, and combines results\n  ◦ scrape_season_stats: Downloads per-game player stats, removes duplicate headers, selects key columns (Player, Year, PTS, AST, TRB, FG%), and drops rows with missing data\n  ◦ scrape_multiple_seasons: Aggregates player stats across multiple seasons\n• Handles data extraction for a configurable year range (default 2018-2025)\n• Ensures a 'data' directory exists before saving files\n• Exports MVP votes and player stats as separate CSV files\n• Prints progress messages during scraping",
                "low_structured": "• Scrapes MVP votes and player stats from Basketball Reference\n• Saves the results as CSV files",
                "high_unstructured": "The provided code defines functions to scrape NBA MVP voting results and player per-game statistics from Basketball Reference for a range of seasons (defaulting to 2018-2025). The scrape_mvp_votes function retrieves MVP tables, renames columns, and consolidates data, while scrape_season_stats fetches player stats, cleans repeated headers, selects relevant columns, and drops rows with missing key stats. scrape_multiple_seasons aggregates stats across years. When run as a script, it ensures a data directory exists, scrapes both datasets, and exports them as CSV files for further use.",
                "medium_unstructured": "This script collects NBA MVP voting results and player per-game statistics for multiple seasons from Basketball Reference. It processes the data and saves it into CSV files for further analysis. The code handles data extraction, cleaning, and file output automatically.",
                "title": "Basketball MVP Votes and Player Stats Scraper"
            },
            "selected_code": "import pandas as pd\nimport os\n\n\ndef scrape_mvp_votes(start_year=2018, end_year=2025):\n    all_votes = []\n    for year in range(start_year, end_year + 1):\n        url = f\"https://www.basketball-reference.com/awards/awards_{year}.html\"\n        tables = pd.read_html(url, header=1)\n        try:\n            mvp_table = tables[0]  # MVP table is the first table\n            mvp_table[\"Year\"] = year\n            all_votes.append(mvp_table)\n        except:\n            print(f\"Could not parse year {year}\")\n\n    df = pd.concat(all_votes)\n    df = df.rename(columns={\"Player\": \"Name\", \"Pts Won\": \"MVP_Points\"})\n    return df[[\"Year\", \"Name\", \"MVP_Points\"]]\n\n\ndef scrape_season_stats(year):\n    base_url_reg = (\n        f\"https://www.basketball-reference.com/leagues/NBA_{year}_per_game.html\"\n    )\n    df_reg = pd.read_html(base_url_reg, header=0)[0]\n    df_reg = df_reg[df_reg[\"Player\"] != \"Player\"]  # remove repeated header rows\n    df_reg[\"Year\"] = year\n\n    df_reg = df_reg[\n        [\"Player\", \"Year\", \"PTS\", \"AST\", \"TRB\", \"FG%\"]\n    ]  # Keep only specified columns\n    df_reg = df_reg.dropna(\n        subset=[\"PTS\", \"AST\", \"TRB\", \"FG%\"]\n    )  # Ensure key stats aren't invalid\n    return df_reg\n\n\ndef scrape_multiple_seasons(start_year=2018, end_year=2025):\n    all_stats = []\n    for year in range(start_year, end_year + 1):\n        df = scrape_season_stats(year)\n        all_stats.append(df)\n    return pd.concat(all_stats)\n\n\nif __name__ == \"__main__\":\n    if not os.path.exists(\"data\"):\n        os.makedirs(\"data\")\n\n    print(\"Scraping MVP votes...\")\n    mvp_df = scrape_mvp_votes()\n    mvp_df.to_csv(\"data/mvp_votes.csv\", index=False)\n\n    print(\"Scraping player stats...\")\n    stats_df = scrape_multiple_seasons()\n    stats_df.to_csv(\"data/season_stats.csv\", index=False)\n"
        },
        "id": "x6ZVYa2bowhPmnn8Ebee"
    },
    {
        "source": "backend",
        "event": "map_summary_code",
        "timestamp": "2025-08-24 11:44:08.000",
        "data": {
            "summary": "This code scrapes NBA MVP votes and player statistics from Basketball Reference and saves them as CSV files.",
            "code": "1: import pandas as pd\n2: import os\n3: \n4: \n5: def scrape_mvp_votes(start_year=2018, end_year=2025):\n6:     all_votes = []\n7:     for year in range(start_year, end_year + 1):\n8:         url = f\"https://www.basketball-reference.com/awards/awards_{year}.html\"\n9:         tables = pd.read_html(url, header=1)\n10:         try:\n11:             mvp_table = tables[0]  # MVP table is the first table\n12:             mvp_table[\"Year\"] = year\n13:             all_votes.append(mvp_table)\n14:         except:\n15:             print(f\"Could not parse year {year}\")\n16: \n17:     df = pd.concat(all_votes)\n18:     df = df.rename(columns={\"Player\": \"Name\", \"Pts Won\": \"MVP_Points\"})\n19:     return df[[\"Year\", \"Name\", \"MVP_Points\"]]\n20: \n21: \n22: def scrape_season_stats(year):\n23:     base_url_reg = (\n24:         f\"https://www.basketball-reference.com/leagues/NBA_{year}_per_game.html\"\n25:     )\n26:     df_reg = pd.read_html(base_url_reg, header=0)[0]\n27:     df_reg = df_reg[df_reg[\"Player\"] != \"Player\"]  # remove repeated header rows\n28:     df_reg[\"Year\"] = year\n29: \n30:     df_reg = df_reg[\n31:         [\"Player\", \"Year\", \"PTS\", \"AST\", \"TRB\", \"FG%\"]\n32:     ]  # Keep only specified columns\n33:     df_reg = df_reg.dropna(\n34:         subset=[\"PTS\", \"AST\", \"TRB\", \"FG%\"]\n35:     )  # Ensure key stats aren't invalid\n36:     return df_reg\n37: \n38: \n39: def scrape_multiple_seasons(start_year=2018, end_year=2025):\n40:     all_stats = []\n41:     for year in range(start_year, end_year + 1):\n42:         df = scrape_season_stats(year)\n43:         all_stats.append(df)\n44:     return pd.concat(all_stats)\n45: \n46: \n47: if __name__ == \"__main__\":\n48:     if not os.path.exists(\"data\"):\n49:         os.makedirs(\"data\")\n50: \n51:     print(\"Scraping MVP votes...\")\n52:     mvp_df = scrape_mvp_votes()\n53:     mvp_df.to_csv(\"data/mvp_votes.csv\", index=False)\n54: \n55:     print(\"Scraping player stats...\")\n56:     stats_df = scrape_multiple_seasons()\n57:     stats_df.to_csv(\"data/season_stats.csv\", index=False)\n58: ",
            "mapping": [
                {
                    "summaryComponent": "scrapes NBA MVP votes",
                    "codeSegments": [
                        {
                            "code": "def scrape_mvp_votes(start_year=2018, end_year=2025):",
                            "line": 5
                        },
                        {
                            "code": "mvp_df = scrape_mvp_votes()",
                            "line": 52
                        }
                    ]
                },
                {
                    "summaryComponent": "and player statistics",
                    "codeSegments": [
                        {
                            "code": "def scrape_season_stats(year):",
                            "line": 22
                        },
                        {
                            "code": "def scrape_multiple_seasons(start_year=2018, end_year=2025):",
                            "line": 39
                        },
                        {
                            "code": "stats_df = scrape_multiple_seasons()",
                            "line": 56
                        }
                    ]
                },
                {
                    "summaryComponent": "from Basketball Reference",
                    "codeSegments": [
                        {
                            "code": "url = f\"https://www.basketball-reference.com/awards/awards_{year}.html\"",
                            "line": 8
                        },
                        {
                            "code": "base_url_reg = (",
                            "line": 23
                        },
                        {
                            "code": "f\"https://www.basketball-reference.com/leagues/NBA_{year}_per_game.html\"",
                            "line": 24
                        }
                    ]
                },
                {
                    "summaryComponent": "and saves them as CSV files",
                    "codeSegments": [
                        {
                            "code": "mvp_df.to_csv(\"data/mvp_votes.csv\", index=False)",
                            "line": 53
                        },
                        {
                            "code": "stats_df.to_csv(\"data/season_stats.csv\", index=False)",
                            "line": 57
                        }
                    ]
                }
            ]
        },
        "id": "RrYE68ASk2mpwGj1Jxzg"
    },
    {
        "source": "backend",
        "event": "map_summary_code",
        "timestamp": "2025-08-24 11:44:08.000",
        "data": {
            "summary": "• Scrapes MVP votes and player stats from Basketball Reference\n• Saves the results as CSV files",
            "code": "1: import pandas as pd\n2: import os\n3: \n4: \n5: def scrape_mvp_votes(start_year=2018, end_year=2025):\n6:     all_votes = []\n7:     for year in range(start_year, end_year + 1):\n8:         url = f\"https://www.basketball-reference.com/awards/awards_{year}.html\"\n9:         tables = pd.read_html(url, header=1)\n10:         try:\n11:             mvp_table = tables[0]  # MVP table is the first table\n12:             mvp_table[\"Year\"] = year\n13:             all_votes.append(mvp_table)\n14:         except:\n15:             print(f\"Could not parse year {year}\")\n16: \n17:     df = pd.concat(all_votes)\n18:     df = df.rename(columns={\"Player\": \"Name\", \"Pts Won\": \"MVP_Points\"})\n19:     return df[[\"Year\", \"Name\", \"MVP_Points\"]]\n20: \n21: \n22: def scrape_season_stats(year):\n23:     base_url_reg = (\n24:         f\"https://www.basketball-reference.com/leagues/NBA_{year}_per_game.html\"\n25:     )\n26:     df_reg = pd.read_html(base_url_reg, header=0)[0]\n27:     df_reg = df_reg[df_reg[\"Player\"] != \"Player\"]  # remove repeated header rows\n28:     df_reg[\"Year\"] = year\n29: \n30:     df_reg = df_reg[\n31:         [\"Player\", \"Year\", \"PTS\", \"AST\", \"TRB\", \"FG%\"]\n32:     ]  # Keep only specified columns\n33:     df_reg = df_reg.dropna(\n34:         subset=[\"PTS\", \"AST\", \"TRB\", \"FG%\"]\n35:     )  # Ensure key stats aren't invalid\n36:     return df_reg\n37: \n38: \n39: def scrape_multiple_seasons(start_year=2018, end_year=2025):\n40:     all_stats = []\n41:     for year in range(start_year, end_year + 1):\n42:         df = scrape_season_stats(year)\n43:         all_stats.append(df)\n44:     return pd.concat(all_stats)\n45: \n46: \n47: if __name__ == \"__main__\":\n48:     if not os.path.exists(\"data\"):\n49:         os.makedirs(\"data\")\n50: \n51:     print(\"Scraping MVP votes...\")\n52:     mvp_df = scrape_mvp_votes()\n53:     mvp_df.to_csv(\"data/mvp_votes.csv\", index=False)\n54: \n55:     print(\"Scraping player stats...\")\n56:     stats_df = scrape_multiple_seasons()\n57:     stats_df.to_csv(\"data/season_stats.csv\", index=False)\n58: ",
            "mapping": [
                {
                    "summaryComponent": "Scrapes MVP votes",
                    "codeSegments": [
                        {
                            "code": "def scrape_mvp_votes(start_year=2018, end_year=2025):",
                            "line": 5
                        },
                        {
                            "code": "mvp_df = scrape_mvp_votes()",
                            "line": 52
                        }
                    ]
                },
                {
                    "summaryComponent": "and player stats",
                    "codeSegments": [
                        {
                            "code": "def scrape_season_stats(year):",
                            "line": 22
                        },
                        {
                            "code": "def scrape_multiple_seasons(start_year=2018, end_year=2025):",
                            "line": 39
                        },
                        {
                            "code": "stats_df = scrape_multiple_seasons()",
                            "line": 56
                        }
                    ]
                },
                {
                    "summaryComponent": "from Basketball Reference",
                    "codeSegments": [
                        {
                            "code": "url = f\"https://www.basketball-reference.com/awards/awards_{year}.html\"",
                            "line": 8
                        },
                        {
                            "code": "base_url_reg = (",
                            "line": 23
                        },
                        {
                            "code": "f\"https://www.basketball-reference.com/leagues/NBA_{year}_per_game.html\"",
                            "line": 24
                        }
                    ]
                },
                {
                    "summaryComponent": "Saves the results as CSV files",
                    "codeSegments": [
                        {
                            "code": "mvp_df.to_csv(\"data/mvp_votes.csv\", index=False)",
                            "line": 53
                        },
                        {
                            "code": "stats_df.to_csv(\"data/season_stats.csv\", index=False)",
                            "line": 57
                        }
                    ]
                }
            ]
        },
        "id": "zrM2FNe7MfG3lTZx3TSZ"
    },
    {
        "source": "backend",
        "event": "map_summary_code",
        "timestamp": "2025-08-24 11:44:10.000",
        "data": {
            "summary": "• Scrapes MVP voting data and player statistics from Basketball Reference\n• Processes data for multiple NBA seasons (2018-2025 by default)\n• Saves MVP votes and season stats into separate CSV files\n• Handles data extraction, cleaning, and output",
            "code": "1: import pandas as pd\n2: import os\n3: \n4: \n5: def scrape_mvp_votes(start_year=2018, end_year=2025):\n6:     all_votes = []\n7:     for year in range(start_year, end_year + 1):\n8:         url = f\"https://www.basketball-reference.com/awards/awards_{year}.html\"\n9:         tables = pd.read_html(url, header=1)\n10:         try:\n11:             mvp_table = tables[0]  # MVP table is the first table\n12:             mvp_table[\"Year\"] = year\n13:             all_votes.append(mvp_table)\n14:         except:\n15:             print(f\"Could not parse year {year}\")\n16: \n17:     df = pd.concat(all_votes)\n18:     df = df.rename(columns={\"Player\": \"Name\", \"Pts Won\": \"MVP_Points\"})\n19:     return df[[\"Year\", \"Name\", \"MVP_Points\"]]\n20: \n21: \n22: def scrape_season_stats(year):\n23:     base_url_reg = (\n24:         f\"https://www.basketball-reference.com/leagues/NBA_{year}_per_game.html\"\n25:     )\n26:     df_reg = pd.read_html(base_url_reg, header=0)[0]\n27:     df_reg = df_reg[df_reg[\"Player\"] != \"Player\"]  # remove repeated header rows\n28:     df_reg[\"Year\"] = year\n29: \n30:     df_reg = df_reg[\n31:         [\"Player\", \"Year\", \"PTS\", \"AST\", \"TRB\", \"FG%\"]\n32:     ]  # Keep only specified columns\n33:     df_reg = df_reg.dropna(\n34:         subset=[\"PTS\", \"AST\", \"TRB\", \"FG%\"]\n35:     )  # Ensure key stats aren't invalid\n36:     return df_reg\n37: \n38: \n39: def scrape_multiple_seasons(start_year=2018, end_year=2025):\n40:     all_stats = []\n41:     for year in range(start_year, end_year + 1):\n42:         df = scrape_season_stats(year)\n43:         all_stats.append(df)\n44:     return pd.concat(all_stats)\n45: \n46: \n47: if __name__ == \"__main__\":\n48:     if not os.path.exists(\"data\"):\n49:         os.makedirs(\"data\")\n50: \n51:     print(\"Scraping MVP votes...\")\n52:     mvp_df = scrape_mvp_votes()\n53:     mvp_df.to_csv(\"data/mvp_votes.csv\", index=False)\n54: \n55:     print(\"Scraping player stats...\")\n56:     stats_df = scrape_multiple_seasons()\n57:     stats_df.to_csv(\"data/season_stats.csv\", index=False)\n58: ",
            "mapping": [
                {
                    "summaryComponent": "Scrapes MVP voting data and player statistics from Basketball Reference",
                    "codeSegments": [
                        {
                            "code": "def scrape_mvp_votes(start_year=2018, end_year=2025):",
                            "line": 5
                        },
                        {
                            "code": "def scrape_season_stats(year):",
                            "line": 22
                        },
                        {
                            "code": "def scrape_multiple_seasons(start_year=2018, end_year=2025):",
                            "line": 39
                        },
                        {
                            "code": "url = f\"https://www.basketball-reference.com/awards/awards_{year}.html\"",
                            "line": 8
                        },
                        {
                            "code": "base_url_reg = (\n    f\"https://www.basketball-reference.com/leagues/NBA_{year}_per_game.html\"\n)",
                            "line": 23
                        }
                    ]
                },
                {
                    "summaryComponent": "Processes data for multiple NBA seasons (2018-2025 by default)",
                    "codeSegments": [
                        {
                            "code": "for year in range(start_year, end_year + 1):",
                            "line": 7
                        },
                        {
                            "code": "for year in range(start_year, end_year + 1):",
                            "line": 41
                        },
                        {
                            "code": "def scrape_mvp_votes(start_year=2018, end_year=2025):",
                            "line": 5
                        },
                        {
                            "code": "def scrape_multiple_seasons(start_year=2018, end_year=2025):",
                            "line": 39
                        }
                    ]
                },
                {
                    "summaryComponent": "Saves MVP votes and season stats into separate CSV files",
                    "codeSegments": [
                        {
                            "code": "mvp_df.to_csv(\"data/mvp_votes.csv\", index=False)",
                            "line": 53
                        },
                        {
                            "code": "stats_df.to_csv(\"data/season_stats.csv\", index=False)",
                            "line": 57
                        }
                    ]
                },
                {
                    "summaryComponent": "Handles data extraction, cleaning, and output",
                    "codeSegments": [
                        {
                            "code": "tables = pd.read_html(url, header=1)",
                            "line": 9
                        },
                        {
                            "code": "df_reg = pd.read_html(base_url_reg, header=0)[0]",
                            "line": 26
                        },
                        {
                            "code": "df_reg = df_reg[df_reg[\"Player\"] != \"Player\"]  # remove repeated header rows",
                            "line": 27
                        },
                        {
                            "code": "df_reg = df_reg[\n    [\"Player\", \"Year\", \"PTS\", \"AST\", \"TRB\", \"FG%\"]\n]  # Keep only specified columns",
                            "line": 30
                        },
                        {
                            "code": "df_reg = df_reg.dropna(\n    subset=[\"PTS\", \"AST\", \"TRB\", \"FG%\"]\n)  # Ensure key stats aren't invalid",
                            "line": 33
                        },
                        {
                            "code": "return df[ [\"Year\", \"Name\", \"MVP_Points\"] ]",
                            "line": 19
                        },
                        {
                            "code": "return df_reg",
                            "line": 36
                        }
                    ]
                }
            ]
        },
        "id": "KgrPBNAfPobcMbGF07rt"
    },
    {
        "source": "backend",
        "event": "map_summary_code",
        "timestamp": "2025-08-24 11:44:12.000",
        "data": {
            "summary": "The provided code defines functions to scrape NBA MVP voting results and player per-game statistics from Basketball Reference for a range of seasons (defaulting to 2018-2025). The scrape_mvp_votes function retrieves MVP tables, renames columns, and consolidates data, while scrape_season_stats fetches player stats, cleans repeated headers, selects relevant columns, and drops rows with missing key stats. scrape_multiple_seasons aggregates stats across years. When run as a script, it ensures a data directory exists, scrapes both datasets, and exports them as CSV files for further use.",
            "code": "1: import pandas as pd\n2: import os\n3: \n4: \n5: def scrape_mvp_votes(start_year=2018, end_year=2025):\n6:     all_votes = []\n7:     for year in range(start_year, end_year + 1):\n8:         url = f\"https://www.basketball-reference.com/awards/awards_{year}.html\"\n9:         tables = pd.read_html(url, header=1)\n10:         try:\n11:             mvp_table = tables[0]  # MVP table is the first table\n12:             mvp_table[\"Year\"] = year\n13:             all_votes.append(mvp_table)\n14:         except:\n15:             print(f\"Could not parse year {year}\")\n16: \n17:     df = pd.concat(all_votes)\n18:     df = df.rename(columns={\"Player\": \"Name\", \"Pts Won\": \"MVP_Points\"})\n19:     return df[[\"Year\", \"Name\", \"MVP_Points\"]]\n20: \n21: \n22: def scrape_season_stats(year):\n23:     base_url_reg = (\n24:         f\"https://www.basketball-reference.com/leagues/NBA_{year}_per_game.html\"\n25:     )\n26:     df_reg = pd.read_html(base_url_reg, header=0)[0]\n27:     df_reg = df_reg[df_reg[\"Player\"] != \"Player\"]  # remove repeated header rows\n28:     df_reg[\"Year\"] = year\n29: \n30:     df_reg = df_reg[\n31:         [\"Player\", \"Year\", \"PTS\", \"AST\", \"TRB\", \"FG%\"]\n32:     ]  # Keep only specified columns\n33:     df_reg = df_reg.dropna(\n34:         subset=[\"PTS\", \"AST\", \"TRB\", \"FG%\"]\n35:     )  # Ensure key stats aren't invalid\n36:     return df_reg\n37: \n38: \n39: def scrape_multiple_seasons(start_year=2018, end_year=2025):\n40:     all_stats = []\n41:     for year in range(start_year, end_year + 1):\n42:         df = scrape_season_stats(year)\n43:         all_stats.append(df)\n44:     return pd.concat(all_stats)\n45: \n46: \n47: if __name__ == \"__main__\":\n48:     if not os.path.exists(\"data\"):\n49:         os.makedirs(\"data\")\n50: \n51:     print(\"Scraping MVP votes...\")\n52:     mvp_df = scrape_mvp_votes()\n53:     mvp_df.to_csv(\"data/mvp_votes.csv\", index=False)\n54: \n55:     print(\"Scraping player stats...\")\n56:     stats_df = scrape_multiple_seasons()\n57:     stats_df.to_csv(\"data/season_stats.csv\", index=False)\n58: ",
            "mapping": [
                {
                    "summaryComponent": "defines functions to scrape NBA MVP voting results and player per-game statistics from Basketball Reference for a range of seasons (defaulting to 2018-2025)",
                    "codeSegments": [
                        {
                            "code": "def scrape_mvp_votes(start_year=2018, end_year=2025):",
                            "line": 5
                        },
                        {
                            "code": "def scrape_season_stats(year):",
                            "line": 22
                        },
                        {
                            "code": "def scrape_multiple_seasons(start_year=2018, end_year=2025):",
                            "line": 39
                        }
                    ]
                },
                {
                    "summaryComponent": "The scrape_mvp_votes function retrieves MVP tables",
                    "codeSegments": [
                        {
                            "code": "mvp_table = tables[0]  # MVP table is the first table",
                            "line": 11
                        }
                    ]
                },
                {
                    "summaryComponent": "renames columns",
                    "codeSegments": [
                        {
                            "code": "df = df.rename(columns={\"Player\": \"Name\", \"Pts Won\": \"MVP_Points\"})",
                            "line": 18
                        }
                    ]
                },
                {
                    "summaryComponent": "and consolidates data",
                    "codeSegments": [
                        {
                            "code": "all_votes.append(mvp_table)",
                            "line": 13
                        },
                        {
                            "code": "df = pd.concat(all_votes)",
                            "line": 17
                        }
                    ]
                },
                {
                    "summaryComponent": "while scrape_season_stats fetches player stats",
                    "codeSegments": [
                        {
                            "code": "df_reg = pd.read_html(base_url_reg, header=0)[0]",
                            "line": 26
                        }
                    ]
                },
                {
                    "summaryComponent": "cleans repeated headers",
                    "codeSegments": [
                        {
                            "code": "df_reg = df_reg[df_reg[\"Player\"] != \"Player\"]  # remove repeated header rows",
                            "line": 27
                        }
                    ]
                },
                {
                    "summaryComponent": "selects relevant columns",
                    "codeSegments": [
                        {
                            "code": "df_reg = df_reg[",
                            "line": 30
                        },
                        {
                            "code": "    [\"Player\", \"Year\", \"PTS\", \"AST\", \"TRB\", \"FG%\"]",
                            "line": 31
                        },
                        {
                            "code": "]  # Keep only specified columns",
                            "line": 32
                        }
                    ]
                },
                {
                    "summaryComponent": "and drops rows with missing key stats",
                    "codeSegments": [
                        {
                            "code": "df_reg = df_reg.dropna(",
                            "line": 33
                        },
                        {
                            "code": "    subset=[\"PTS\", \"AST\", \"TRB\", \"FG%\"]",
                            "line": 34
                        },
                        {
                            "code": ")  # Ensure key stats aren't invalid",
                            "line": 35
                        }
                    ]
                },
                {
                    "summaryComponent": "scrape_multiple_seasons aggregates stats across years",
                    "codeSegments": [
                        {
                            "code": "for year in range(start_year, end_year + 1):",
                            "line": 41
                        },
                        {
                            "code": "df = scrape_season_stats(year)",
                            "line": 42
                        },
                        {
                            "code": "all_stats.append(df)",
                            "line": 43
                        },
                        {
                            "code": "return pd.concat(all_stats)",
                            "line": 44
                        }
                    ]
                },
                {
                    "summaryComponent": "When run as a script, it ensures a data directory exists, scrapes both datasets, and exports them as CSV files for further use.",
                    "codeSegments": [
                        {
                            "code": "if __name__ == \"__main__\":",
                            "line": 47
                        },
                        {
                            "code": "if not os.path.exists(\"data\"):",
                            "line": 48
                        },
                        {
                            "code": "os.makedirs(\"data\")",
                            "line": 49
                        },
                        {
                            "code": "mvp_df = scrape_mvp_votes()",
                            "line": 52
                        },
                        {
                            "code": "mvp_df.to_csv(\"data/mvp_votes.csv\", index=False)",
                            "line": 53
                        },
                        {
                            "code": "stats_df = scrape_multiple_seasons()",
                            "line": 56
                        },
                        {
                            "code": "stats_df.to_csv(\"data/season_stats.csv\", index=False)",
                            "line": 57
                        }
                    ]
                }
            ]
        },
        "id": "6GzJOJiF30B6Biv7XUsJ"
    },
    {
        "source": "backend",
        "event": "map_summary_code",
        "timestamp": "2025-08-24 11:44:12.000",
        "data": {
            "summary": "This script collects NBA MVP voting results and player per-game statistics for multiple seasons from Basketball Reference. It processes the data and saves it into CSV files for further analysis. The code handles data extraction, cleaning, and file output automatically.",
            "code": "1: import pandas as pd\n2: import os\n3: \n4: \n5: def scrape_mvp_votes(start_year=2018, end_year=2025):\n6:     all_votes = []\n7:     for year in range(start_year, end_year + 1):\n8:         url = f\"https://www.basketball-reference.com/awards/awards_{year}.html\"\n9:         tables = pd.read_html(url, header=1)\n10:         try:\n11:             mvp_table = tables[0]  # MVP table is the first table\n12:             mvp_table[\"Year\"] = year\n13:             all_votes.append(mvp_table)\n14:         except:\n15:             print(f\"Could not parse year {year}\")\n16: \n17:     df = pd.concat(all_votes)\n18:     df = df.rename(columns={\"Player\": \"Name\", \"Pts Won\": \"MVP_Points\"})\n19:     return df[[\"Year\", \"Name\", \"MVP_Points\"]]\n20: \n21: \n22: def scrape_season_stats(year):\n23:     base_url_reg = (\n24:         f\"https://www.basketball-reference.com/leagues/NBA_{year}_per_game.html\"\n25:     )\n26:     df_reg = pd.read_html(base_url_reg, header=0)[0]\n27:     df_reg = df_reg[df_reg[\"Player\"] != \"Player\"]  # remove repeated header rows\n28:     df_reg[\"Year\"] = year\n29: \n30:     df_reg = df_reg[\n31:         [\"Player\", \"Year\", \"PTS\", \"AST\", \"TRB\", \"FG%\"]\n32:     ]  # Keep only specified columns\n33:     df_reg = df_reg.dropna(\n34:         subset=[\"PTS\", \"AST\", \"TRB\", \"FG%\"]\n35:     )  # Ensure key stats aren't invalid\n36:     return df_reg\n37: \n38: \n39: def scrape_multiple_seasons(start_year=2018, end_year=2025):\n40:     all_stats = []\n41:     for year in range(start_year, end_year + 1):\n42:         df = scrape_season_stats(year)\n43:         all_stats.append(df)\n44:     return pd.concat(all_stats)\n45: \n46: \n47: if __name__ == \"__main__\":\n48:     if not os.path.exists(\"data\"):\n49:         os.makedirs(\"data\")\n50: \n51:     print(\"Scraping MVP votes...\")\n52:     mvp_df = scrape_mvp_votes()\n53:     mvp_df.to_csv(\"data/mvp_votes.csv\", index=False)\n54: \n55:     print(\"Scraping player stats...\")\n56:     stats_df = scrape_multiple_seasons()\n57:     stats_df.to_csv(\"data/season_stats.csv\", index=False)\n58: ",
            "mapping": [
                {
                    "summaryComponent": "collects NBA MVP voting results",
                    "codeSegments": [
                        {
                            "code": "def scrape_mvp_votes(start_year=2018, end_year=2025):",
                            "line": 5
                        },
                        {
                            "code": "mvp_df = scrape_mvp_votes()",
                            "line": 52
                        }
                    ]
                },
                {
                    "summaryComponent": "player per-game statistics for multiple seasons",
                    "codeSegments": [
                        {
                            "code": "def scrape_season_stats(year):",
                            "line": 22
                        },
                        {
                            "code": "def scrape_multiple_seasons(start_year=2018, end_year=2025):",
                            "line": 39
                        },
                        {
                            "code": "stats_df = scrape_multiple_seasons()",
                            "line": 56
                        }
                    ]
                },
                {
                    "summaryComponent": "from Basketball Reference",
                    "codeSegments": [
                        {
                            "code": "url = f\"https://www.basketball-reference.com/awards/awards_{year}.html\"",
                            "line": 8
                        },
                        {
                            "code": "base_url_reg = (\n    f\"https://www.basketball-reference.com/leagues/NBA_{year}_per_game.html\"\n)",
                            "line": 23
                        }
                    ]
                },
                {
                    "summaryComponent": "processes the data",
                    "codeSegments": [
                        {
                            "code": "df = pd.concat(all_votes)",
                            "line": 17
                        },
                        {
                            "code": "df = df.rename(columns={\"Player\": \"Name\", \"Pts Won\": \"MVP_Points\"})",
                            "line": 18
                        },
                        {
                            "code": "df_reg = df_reg[df_reg[\"Player\"] != \"Player\"]  # remove repeated header rows",
                            "line": 27
                        },
                        {
                            "code": "df_reg = df_reg[\n    [\"Player\", \"Year\", \"PTS\", \"AST\", \"TRB\", \"FG%\"]\n]  # Keep only specified columns",
                            "line": 30
                        },
                        {
                            "code": "df_reg = df_reg.dropna(\n    subset=[\"PTS\", \"AST\", \"TRB\", \"FG%\"]\n)  # Ensure key stats aren't invalid",
                            "line": 33
                        }
                    ]
                },
                {
                    "summaryComponent": "saves it into CSV files",
                    "codeSegments": [
                        {
                            "code": "mvp_df.to_csv(\"data/mvp_votes.csv\", index=False)",
                            "line": 53
                        },
                        {
                            "code": "stats_df.to_csv(\"data/season_stats.csv\", index=False)",
                            "line": 57
                        }
                    ]
                },
                {
                    "summaryComponent": "for further analysis",
                    "codeSegments": [
                        {
                            "code": "mvp_df.to_csv(\"data/mvp_votes.csv\", index=False)",
                            "line": 53
                        },
                        {
                            "code": "stats_df.to_csv(\"data/season_stats.csv\", index=False)",
                            "line": 57
                        }
                    ]
                },
                {
                    "summaryComponent": "handles data extraction",
                    "codeSegments": [
                        {
                            "code": "tables = pd.read_html(url, header=1)",
                            "line": 9
                        },
                        {
                            "code": "df_reg = pd.read_html(base_url_reg, header=0)[0]",
                            "line": 26
                        }
                    ]
                },
                {
                    "summaryComponent": "cleaning",
                    "codeSegments": [
                        {
                            "code": "df = df.rename(columns={\"Player\": \"Name\", \"Pts Won\": \"MVP_Points\"})",
                            "line": 18
                        },
                        {
                            "code": "df_reg = df_reg[df_reg[\"Player\"] != \"Player\"]  # remove repeated header rows",
                            "line": 27
                        },
                        {
                            "code": "df_reg = df_reg.dropna(\n    subset=[\"PTS\", \"AST\", \"TRB\", \"FG%\"]\n)  # Ensure key stats aren't invalid",
                            "line": 33
                        }
                    ]
                },
                {
                    "summaryComponent": "file output automatically",
                    "codeSegments": [
                        {
                            "code": "mvp_df.to_csv(\"data/mvp_votes.csv\", index=False)",
                            "line": 53
                        },
                        {
                            "code": "stats_df.to_csv(\"data/season_stats.csv\", index=False)",
                            "line": 57
                        }
                    ]
                }
            ]
        },
        "id": "BrhGvcV5mhd3OeSCdJFK"
    },
    {
        "source": "frontend",
        "event": "create_new_section",
        "timestamp": "2025-08-24 11:44:12.000",
        "data": {
            "section_data": {
                "selectedDetailLevel": "medium",
                "createdAt": 1756064652000,
                "metadata": {
                    "originalCode": "import pandas as pd\nimport os\n\n\ndef scrape_mvp_votes(start_year=2018, end_year=2025):\n    all_votes = []\n    for year in range(start_year, end_year + 1):\n        url = f\"https://www.basketball-reference.com/awards/awards_{year}.html\"\n        tables = pd.read_html(url, header=1)\n        try:\n            mvp_table = tables[0]  # MVP table is the first table\n            mvp_table[\"Year\"] = year\n            all_votes.append(mvp_table)\n        except:\n            print(f\"Could not parse year {year}\")\n\n    df = pd.concat(all_votes)\n    df = df.rename(columns={\"Player\": \"Name\", \"Pts Won\": \"MVP_Points\"})\n    return df[[\"Year\", \"Name\", \"MVP_Points\"]]\n\n\ndef scrape_season_stats(year):\n    base_url_reg = (\n        f\"https://www.basketball-reference.com/leagues/NBA_{year}_per_game.html\"\n    )\n    df_reg = pd.read_html(base_url_reg, header=0)[0]\n    df_reg = df_reg[df_reg[\"Player\"] != \"Player\"]  # remove repeated header rows\n    df_reg[\"Year\"] = year\n\n    df_reg = df_reg[\n        [\"Player\", \"Year\", \"PTS\", \"AST\", \"TRB\", \"FG%\"]\n    ]  # Keep only specified columns\n    df_reg = df_reg.dropna(\n        subset=[\"PTS\", \"AST\", \"TRB\", \"FG%\"]\n    )  # Ensure key stats aren't invalid\n    return df_reg\n\n\ndef scrape_multiple_seasons(start_year=2018, end_year=2025):\n    all_stats = []\n    for year in range(start_year, end_year + 1):\n        df = scrape_season_stats(year)\n        all_stats.append(df)\n    return pd.concat(all_stats)\n\n\nif __name__ == \"__main__\":\n    if not os.path.exists(\"data\"):\n        os.makedirs(\"data\")\n\n    print(\"Scraping MVP votes...\")\n    mvp_df = scrape_mvp_votes()\n    mvp_df.to_csv(\"data/mvp_votes.csv\", index=False)\n\n    print(\"Scraping player stats...\")\n    stats_df = scrape_multiple_seasons()\n    stats_df.to_csv(\"data/season_stats.csv\", index=False)\n",
                    "id": "04ba9f41-f7cf-417a-ab4a-747376f4a2f9",
                    "filename": "scraper.py",
                    "fullPath": "/project/workspace/scraper.py",
                    "offset": 0
                },
                "summaryData": {
                    "medium_structured": "• Scrapes MVP voting data and player statistics from Basketball Reference\n• Processes data for multiple NBA seasons (2018-2025 by default)\n• Saves MVP votes and season stats into separate CSV files\n• Handles data extraction, cleaning, and output",
                    "low_unstructured": "This code scrapes NBA MVP votes and player statistics from Basketball Reference and saves them as CSV files.",
                    "high_structured": "• Defines functions to scrape and process NBA data from Basketball Reference\n  ◦ scrape_mvp_votes: Collects MVP voting tables for each year, renames columns, and combines results\n  ◦ scrape_season_stats: Downloads per-game player stats, removes duplicate headers, selects key columns (Player, Year, PTS, AST, TRB, FG%), and drops rows with missing data\n  ◦ scrape_multiple_seasons: Aggregates player stats across multiple seasons\n• Handles data extraction for a configurable year range (default 2018-2025)\n• Ensures a 'data' directory exists before saving files\n• Exports MVP votes and player stats as separate CSV files\n• Prints progress messages during scraping",
                    "low_structured": "• Scrapes MVP votes and player stats from Basketball Reference\n• Saves the results as CSV files",
                    "high_unstructured": "The provided code defines functions to scrape NBA MVP voting results and player per-game statistics from Basketball Reference for a range of seasons (defaulting to 2018-2025). The scrape_mvp_votes function retrieves MVP tables, renames columns, and consolidates data, while scrape_season_stats fetches player stats, cleans repeated headers, selects relevant columns, and drops rows with missing key stats. scrape_multiple_seasons aggregates stats across years. When run as a script, it ensures a data directory exists, scrapes both datasets, and exports them as CSV files for further use.",
                    "medium_unstructured": "This script collects NBA MVP voting results and player per-game statistics for multiple seasons from Basketball Reference. It processes the data and saves it into CSV files for further analysis. The code handles data extraction, cleaning, and file output automatically.",
                    "title": "Basketball MVP Votes and Player Stats Scraper"
                },
                "selectedStructured": "unstructured",
                "summaryMappings": {
                    "medium_structured": [
                        {
                            "summaryComponent": "Scrapes MVP voting data and player statistics from Basketball Reference",
                            "codeSegments": [
                                {
                                    "code": "def scrape_mvp_votes(start_year=2018, end_year=2025):",
                                    "line": 5
                                },
                                {
                                    "code": "def scrape_season_stats(year):",
                                    "line": 22
                                },
                                {
                                    "code": "def scrape_multiple_seasons(start_year=2018, end_year=2025):",
                                    "line": 39
                                },
                                {
                                    "code": "url = f\"https://www.basketball-reference.com/awards/awards_{year}.html\"",
                                    "line": 8
                                },
                                {
                                    "code": "base_url_reg = (\n    f\"https://www.basketball-reference.com/leagues/NBA_{year}_per_game.html\"\n)",
                                    "line": 23
                                }
                            ]
                        },
                        {
                            "summaryComponent": "Processes data for multiple NBA seasons (2018-2025 by default)",
                            "codeSegments": [
                                {
                                    "code": "for year in range(start_year, end_year + 1):",
                                    "line": 7
                                },
                                {
                                    "code": "for year in range(start_year, end_year + 1):",
                                    "line": 41
                                },
                                {
                                    "code": "def scrape_mvp_votes(start_year=2018, end_year=2025):",
                                    "line": 5
                                },
                                {
                                    "code": "def scrape_multiple_seasons(start_year=2018, end_year=2025):",
                                    "line": 39
                                }
                            ]
                        },
                        {
                            "summaryComponent": "Saves MVP votes and season stats into separate CSV files",
                            "codeSegments": [
                                {
                                    "code": "mvp_df.to_csv(\"data/mvp_votes.csv\", index=False)",
                                    "line": 53
                                },
                                {
                                    "code": "stats_df.to_csv(\"data/season_stats.csv\", index=False)",
                                    "line": 57
                                }
                            ]
                        },
                        {
                            "summaryComponent": "Handles data extraction, cleaning, and output",
                            "codeSegments": [
                                {
                                    "code": "tables = pd.read_html(url, header=1)",
                                    "line": 9
                                },
                                {
                                    "code": "df_reg = pd.read_html(base_url_reg, header=0)[0]",
                                    "line": 26
                                },
                                {
                                    "code": "df_reg = df_reg[df_reg[\"Player\"] != \"Player\"]  # remove repeated header rows",
                                    "line": 27
                                },
                                {
                                    "code": "df_reg = df_reg[\n    [\"Player\", \"Year\", \"PTS\", \"AST\", \"TRB\", \"FG%\"]\n]  # Keep only specified columns",
                                    "line": 30
                                },
                                {
                                    "code": "df_reg = df_reg.dropna(\n    subset=[\"PTS\", \"AST\", \"TRB\", \"FG%\"]\n)  # Ensure key stats aren't invalid",
                                    "line": 33
                                },
                                {
                                    "code": "return df[ [\"Year\", \"Name\", \"MVP_Points\"] ]",
                                    "line": 19
                                },
                                {
                                    "code": "return df_reg",
                                    "line": 36
                                }
                            ]
                        }
                    ],
                    "high_structured": [
                        {
                            "summaryComponent": "Defines functions to scrape and process NBA data from Basketball Reference",
                            "codeSegments": [
                                {
                                    "code": "def scrape_mvp_votes(start_year=2018, end_year=2025):",
                                    "line": 5
                                },
                                {
                                    "code": "def scrape_season_stats(year):",
                                    "line": 22
                                },
                                {
                                    "code": "def scrape_multiple_seasons(start_year=2018, end_year=2025):",
                                    "line": 39
                                }
                            ]
                        },
                        {
                            "summaryComponent": "scrape_mvp_votes: Collects MVP voting tables for each year, renames columns, and combines results",
                            "codeSegments": [
                                {
                                    "code": "def scrape_mvp_votes(start_year=2018, end_year=2025):",
                                    "line": 5
                                },
                                {
                                    "code": "for year in range(start_year, end_year + 1):",
                                    "line": 7
                                },
                                {
                                    "code": "url = f\"https://www.basketball-reference.com/awards/awards_{year}.html\"",
                                    "line": 8
                                },
                                {
                                    "code": "tables = pd.read_html(url, header=1)",
                                    "line": 9
                                },
                                {
                                    "code": "mvp_table = tables[0]  # MVP table is the first table",
                                    "line": 11
                                },
                                {
                                    "code": "mvp_table[\"Year\"] = year",
                                    "line": 12
                                },
                                {
                                    "code": "all_votes.append(mvp_table)",
                                    "line": 13
                                },
                                {
                                    "code": "df = pd.concat(all_votes)",
                                    "line": 17
                                },
                                {
                                    "code": "df = df.rename(columns={\"Player\": \"Name\", \"Pts Won\": \"MVP_Points\"})",
                                    "line": 18
                                }
                            ]
                        },
                        {
                            "summaryComponent": "scrape_season_stats: Downloads per-game player stats, removes duplicate headers, selects key columns (Player, Year, PTS, AST, TRB, FG%), and drops rows with missing data",
                            "codeSegments": [
                                {
                                    "code": "def scrape_season_stats(year):",
                                    "line": 22
                                },
                                {
                                    "code": "df_reg = pd.read_html(base_url_reg, header=0)[0]",
                                    "line": 26
                                },
                                {
                                    "code": "df_reg = df_reg[df_reg[\"Player\"] != \"Player\"]  # remove repeated header rows",
                                    "line": 27
                                },
                                {
                                    "code": "df_reg = df_reg[\n    [\"Player\", \"Year\", \"PTS\", \"AST\", \"TRB\", \"FG%\"]\n]",
                                    "line": 30
                                },
                                {
                                    "code": "df_reg = df_reg.dropna(\n    subset=[\"PTS\", \"AST\", \"TRB\", \"FG%\"]\n)",
                                    "line": 33
                                }
                            ]
                        },
                        {
                            "summaryComponent": "scrape_multiple_seasons: Aggregates player stats across multiple seasons",
                            "codeSegments": [
                                {
                                    "code": "def scrape_multiple_seasons(start_year=2018, end_year=2025):",
                                    "line": 39
                                },
                                {
                                    "code": "for year in range(start_year, end_year + 1):",
                                    "line": 41
                                },
                                {
                                    "code": "df = scrape_season_stats(year)",
                                    "line": 42
                                },
                                {
                                    "code": "all_stats.append(df)",
                                    "line": 43
                                },
                                {
                                    "code": "return pd.concat(all_stats)",
                                    "line": 44
                                }
                            ]
                        },
                        {
                            "summaryComponent": "Handles data extraction for a configurable year range (default 2018-2025)",
                            "codeSegments": [
                                {
                                    "code": "def scrape_mvp_votes(start_year=2018, end_year=2025):",
                                    "line": 5
                                },
                                {
                                    "code": "def scrape_multiple_seasons(start_year=2018, end_year=2025):",
                                    "line": 39
                                }
                            ]
                        },
                        {
                            "summaryComponent": "Ensures a 'data' directory exists before saving files",
                            "codeSegments": [
                                {
                                    "code": "if not os.path.exists(\"data\"):",
                                    "line": 48
                                },
                                {
                                    "code": "os.makedirs(\"data\")",
                                    "line": 49
                                }
                            ]
                        },
                        {
                            "summaryComponent": "Exports MVP votes and player stats as separate CSV files",
                            "codeSegments": [
                                {
                                    "code": "mvp_df.to_csv(\"data/mvp_votes.csv\", index=False)",
                                    "line": 53
                                },
                                {
                                    "code": "stats_df.to_csv(\"data/season_stats.csv\", index=False)",
                                    "line": 57
                                }
                            ]
                        },
                        {
                            "summaryComponent": "Prints progress messages during scraping",
                            "codeSegments": [
                                {
                                    "code": "print(\"Scraping MVP votes...\")",
                                    "line": 51
                                },
                                {
                                    "code": "print(\"Scraping player stats...\")",
                                    "line": 55
                                }
                            ]
                        }
                    ],
                    "low_structured": [
                        {
                            "summaryComponent": "Scrapes MVP votes",
                            "codeSegments": [
                                {
                                    "code": "def scrape_mvp_votes(start_year=2018, end_year=2025):",
                                    "line": 5
                                },
                                {
                                    "code": "mvp_df = scrape_mvp_votes()",
                                    "line": 52
                                }
                            ]
                        },
                        {
                            "summaryComponent": "and player stats",
                            "codeSegments": [
                                {
                                    "code": "def scrape_season_stats(year):",
                                    "line": 22
                                },
                                {
                                    "code": "def scrape_multiple_seasons(start_year=2018, end_year=2025):",
                                    "line": 39
                                },
                                {
                                    "code": "stats_df = scrape_multiple_seasons()",
                                    "line": 56
                                }
                            ]
                        },
                        {
                            "summaryComponent": "from Basketball Reference",
                            "codeSegments": [
                                {
                                    "code": "url = f\"https://www.basketball-reference.com/awards/awards_{year}.html\"",
                                    "line": 8
                                },
                                {
                                    "code": "base_url_reg = (",
                                    "line": 23
                                },
                                {
                                    "code": "f\"https://www.basketball-reference.com/leagues/NBA_{year}_per_game.html\"",
                                    "line": 24
                                }
                            ]
                        },
                        {
                            "summaryComponent": "Saves the results as CSV files",
                            "codeSegments": [
                                {
                                    "code": "mvp_df.to_csv(\"data/mvp_votes.csv\", index=False)",
                                    "line": 53
                                },
                                {
                                    "code": "stats_df.to_csv(\"data/season_stats.csv\", index=False)",
                                    "line": 57
                                }
                            ]
                        }
                    ],
                    "high_unstructured": [
                        {
                            "summaryComponent": "defines functions to scrape NBA MVP voting results and player per-game statistics from Basketball Reference for a range of seasons (defaulting to 2018-2025)",
                            "codeSegments": [
                                {
                                    "code": "def scrape_mvp_votes(start_year=2018, end_year=2025):",
                                    "line": 5
                                },
                                {
                                    "code": "def scrape_season_stats(year):",
                                    "line": 22
                                },
                                {
                                    "code": "def scrape_multiple_seasons(start_year=2018, end_year=2025):",
                                    "line": 39
                                }
                            ]
                        },
                        {
                            "summaryComponent": "The scrape_mvp_votes function retrieves MVP tables",
                            "codeSegments": [
                                {
                                    "code": "mvp_table = tables[0]  # MVP table is the first table",
                                    "line": 11
                                }
                            ]
                        },
                        {
                            "summaryComponent": "renames columns",
                            "codeSegments": [
                                {
                                    "code": "df = df.rename(columns={\"Player\": \"Name\", \"Pts Won\": \"MVP_Points\"})",
                                    "line": 18
                                }
                            ]
                        },
                        {
                            "summaryComponent": "and consolidates data",
                            "codeSegments": [
                                {
                                    "code": "all_votes.append(mvp_table)",
                                    "line": 13
                                },
                                {
                                    "code": "df = pd.concat(all_votes)",
                                    "line": 17
                                }
                            ]
                        },
                        {
                            "summaryComponent": "while scrape_season_stats fetches player stats",
                            "codeSegments": [
                                {
                                    "code": "df_reg = pd.read_html(base_url_reg, header=0)[0]",
                                    "line": 26
                                }
                            ]
                        },
                        {
                            "summaryComponent": "cleans repeated headers",
                            "codeSegments": [
                                {
                                    "code": "df_reg = df_reg[df_reg[\"Player\"] != \"Player\"]  # remove repeated header rows",
                                    "line": 27
                                }
                            ]
                        },
                        {
                            "summaryComponent": "selects relevant columns",
                            "codeSegments": [
                                {
                                    "code": "df_reg = df_reg[",
                                    "line": 30
                                },
                                {
                                    "code": "    [\"Player\", \"Year\", \"PTS\", \"AST\", \"TRB\", \"FG%\"]",
                                    "line": 31
                                },
                                {
                                    "code": "]  # Keep only specified columns",
                                    "line": 32
                                }
                            ]
                        },
                        {
                            "summaryComponent": "and drops rows with missing key stats",
                            "codeSegments": [
                                {
                                    "code": "df_reg = df_reg.dropna(",
                                    "line": 33
                                },
                                {
                                    "code": "    subset=[\"PTS\", \"AST\", \"TRB\", \"FG%\"]",
                                    "line": 34
                                },
                                {
                                    "code": ")  # Ensure key stats aren't invalid",
                                    "line": 35
                                }
                            ]
                        },
                        {
                            "summaryComponent": "scrape_multiple_seasons aggregates stats across years",
                            "codeSegments": [
                                {
                                    "code": "for year in range(start_year, end_year + 1):",
                                    "line": 41
                                },
                                {
                                    "code": "df = scrape_season_stats(year)",
                                    "line": 42
                                },
                                {
                                    "code": "all_stats.append(df)",
                                    "line": 43
                                },
                                {
                                    "code": "return pd.concat(all_stats)",
                                    "line": 44
                                }
                            ]
                        },
                        {
                            "summaryComponent": "When run as a script, it ensures a data directory exists, scrapes both datasets, and exports them as CSV files for further use.",
                            "codeSegments": [
                                {
                                    "code": "if __name__ == \"__main__\":",
                                    "line": 47
                                },
                                {
                                    "code": "if not os.path.exists(\"data\"):",
                                    "line": 48
                                },
                                {
                                    "code": "os.makedirs(\"data\")",
                                    "line": 49
                                },
                                {
                                    "code": "mvp_df = scrape_mvp_votes()",
                                    "line": 52
                                },
                                {
                                    "code": "mvp_df.to_csv(\"data/mvp_votes.csv\", index=False)",
                                    "line": 53
                                },
                                {
                                    "code": "stats_df = scrape_multiple_seasons()",
                                    "line": 56
                                },
                                {
                                    "code": "stats_df.to_csv(\"data/season_stats.csv\", index=False)",
                                    "line": 57
                                }
                            ]
                        }
                    ],
                    "medium_unstructured": [
                        {
                            "summaryComponent": "collects NBA MVP voting results",
                            "codeSegments": [
                                {
                                    "code": "def scrape_mvp_votes(start_year=2018, end_year=2025):",
                                    "line": 5
                                },
                                {
                                    "code": "mvp_df = scrape_mvp_votes()",
                                    "line": 52
                                }
                            ]
                        },
                        {
                            "summaryComponent": "player per-game statistics for multiple seasons",
                            "codeSegments": [
                                {
                                    "code": "def scrape_season_stats(year):",
                                    "line": 22
                                },
                                {
                                    "code": "def scrape_multiple_seasons(start_year=2018, end_year=2025):",
                                    "line": 39
                                },
                                {
                                    "code": "stats_df = scrape_multiple_seasons()",
                                    "line": 56
                                }
                            ]
                        },
                        {
                            "summaryComponent": "from Basketball Reference",
                            "codeSegments": [
                                {
                                    "code": "url = f\"https://www.basketball-reference.com/awards/awards_{year}.html\"",
                                    "line": 8
                                },
                                {
                                    "code": "base_url_reg = (\n    f\"https://www.basketball-reference.com/leagues/NBA_{year}_per_game.html\"\n)",
                                    "line": 23
                                }
                            ]
                        },
                        {
                            "summaryComponent": "processes the data",
                            "codeSegments": [
                                {
                                    "code": "df = pd.concat(all_votes)",
                                    "line": 17
                                },
                                {
                                    "code": "df = df.rename(columns={\"Player\": \"Name\", \"Pts Won\": \"MVP_Points\"})",
                                    "line": 18
                                },
                                {
                                    "code": "df_reg = df_reg[df_reg[\"Player\"] != \"Player\"]  # remove repeated header rows",
                                    "line": 27
                                },
                                {
                                    "code": "df_reg = df_reg[\n    [\"Player\", \"Year\", \"PTS\", \"AST\", \"TRB\", \"FG%\"]\n]  # Keep only specified columns",
                                    "line": 30
                                },
                                {
                                    "code": "df_reg = df_reg.dropna(\n    subset=[\"PTS\", \"AST\", \"TRB\", \"FG%\"]\n)  # Ensure key stats aren't invalid",
                                    "line": 33
                                }
                            ]
                        },
                        {
                            "summaryComponent": "saves it into CSV files",
                            "codeSegments": [
                                {
                                    "code": "mvp_df.to_csv(\"data/mvp_votes.csv\", index=False)",
                                    "line": 53
                                },
                                {
                                    "code": "stats_df.to_csv(\"data/season_stats.csv\", index=False)",
                                    "line": 57
                                }
                            ]
                        },
                        {
                            "summaryComponent": "for further analysis",
                            "codeSegments": [
                                {
                                    "code": "mvp_df.to_csv(\"data/mvp_votes.csv\", index=False)",
                                    "line": 53
                                },
                                {
                                    "code": "stats_df.to_csv(\"data/season_stats.csv\", index=False)",
                                    "line": 57
                                }
                            ]
                        },
                        {
                            "summaryComponent": "handles data extraction",
                            "codeSegments": [
                                {
                                    "code": "tables = pd.read_html(url, header=1)",
                                    "line": 9
                                },
                                {
                                    "code": "df_reg = pd.read_html(base_url_reg, header=0)[0]",
                                    "line": 26
                                }
                            ]
                        },
                        {
                            "summaryComponent": "cleaning",
                            "codeSegments": [
                                {
                                    "code": "df = df.rename(columns={\"Player\": \"Name\", \"Pts Won\": \"MVP_Points\"})",
                                    "line": 18
                                },
                                {
                                    "code": "df_reg = df_reg[df_reg[\"Player\"] != \"Player\"]  # remove repeated header rows",
                                    "line": 27
                                },
                                {
                                    "code": "df_reg = df_reg.dropna(\n    subset=[\"PTS\", \"AST\", \"TRB\", \"FG%\"]\n)  # Ensure key stats aren't invalid",
                                    "line": 33
                                }
                            ]
                        },
                        {
                            "summaryComponent": "file output automatically",
                            "codeSegments": [
                                {
                                    "code": "mvp_df.to_csv(\"data/mvp_votes.csv\", index=False)",
                                    "line": 53
                                },
                                {
                                    "code": "stats_df.to_csv(\"data/season_stats.csv\", index=False)",
                                    "line": 57
                                }
                            ]
                        }
                    ],
                    "low_unstructured": [
                        {
                            "summaryComponent": "scrapes NBA MVP votes",
                            "codeSegments": [
                                {
                                    "code": "def scrape_mvp_votes(start_year=2018, end_year=2025):",
                                    "line": 5
                                },
                                {
                                    "code": "mvp_df = scrape_mvp_votes()",
                                    "line": 52
                                }
                            ]
                        },
                        {
                            "summaryComponent": "and player statistics",
                            "codeSegments": [
                                {
                                    "code": "def scrape_season_stats(year):",
                                    "line": 22
                                },
                                {
                                    "code": "def scrape_multiple_seasons(start_year=2018, end_year=2025):",
                                    "line": 39
                                },
                                {
                                    "code": "stats_df = scrape_multiple_seasons()",
                                    "line": 56
                                }
                            ]
                        },
                        {
                            "summaryComponent": "from Basketball Reference",
                            "codeSegments": [
                                {
                                    "code": "url = f\"https://www.basketball-reference.com/awards/awards_{year}.html\"",
                                    "line": 8
                                },
                                {
                                    "code": "base_url_reg = (",
                                    "line": 23
                                },
                                {
                                    "code": "f\"https://www.basketball-reference.com/leagues/NBA_{year}_per_game.html\"",
                                    "line": 24
                                }
                            ]
                        },
                        {
                            "summaryComponent": "and saves them as CSV files",
                            "codeSegments": [
                                {
                                    "code": "mvp_df.to_csv(\"data/mvp_votes.csv\", index=False)",
                                    "line": 53
                                },
                                {
                                    "code": "stats_df.to_csv(\"data/season_stats.csv\", index=False)",
                                    "line": 57
                                }
                            ]
                        }
                    ]
                },
                "editPromptValue": "",
                "editPromptDetailLevel": null,
                "editPromptStructured": null,
                "lines": [
                    1,
                    58
                ],
                "title": "Basketball MVP Votes and Player Stats Scraper"
            },
            "section_id": "04ba9f41-f7cf-417a-ab4a-747376f4a2f9"
        },
        "id": "L13QbHOE2rfoqYzmZsF5"
    },
    {
        "source": "frontend",
        "event": "autotransit_section",
        "timestamp": "2025-08-24 11:44:12.000",
        "data": {
            "before_section_id": null,
            "after_section_id": "04ba9f41-f7cf-417a-ab4a-747376f4a2f9"
        },
        "id": "Q9fvg4SOmzbTaeE5ZKfr"
    },
    {
        "source": "backend",
        "event": "map_summary_code",
        "timestamp": "2025-08-24 11:44:12.000",
        "data": {
            "summary": "• Defines functions to scrape and process NBA data from Basketball Reference\n  ◦ scrape_mvp_votes: Collects MVP voting tables for each year, renames columns, and combines results\n  ◦ scrape_season_stats: Downloads per-game player stats, removes duplicate headers, selects key columns (Player, Year, PTS, AST, TRB, FG%), and drops rows with missing data\n  ◦ scrape_multiple_seasons: Aggregates player stats across multiple seasons\n• Handles data extraction for a configurable year range (default 2018-2025)\n• Ensures a 'data' directory exists before saving files\n• Exports MVP votes and player stats as separate CSV files\n• Prints progress messages during scraping",
            "code": "1: import pandas as pd\n2: import os\n3: \n4: \n5: def scrape_mvp_votes(start_year=2018, end_year=2025):\n6:     all_votes = []\n7:     for year in range(start_year, end_year + 1):\n8:         url = f\"https://www.basketball-reference.com/awards/awards_{year}.html\"\n9:         tables = pd.read_html(url, header=1)\n10:         try:\n11:             mvp_table = tables[0]  # MVP table is the first table\n12:             mvp_table[\"Year\"] = year\n13:             all_votes.append(mvp_table)\n14:         except:\n15:             print(f\"Could not parse year {year}\")\n16: \n17:     df = pd.concat(all_votes)\n18:     df = df.rename(columns={\"Player\": \"Name\", \"Pts Won\": \"MVP_Points\"})\n19:     return df[[\"Year\", \"Name\", \"MVP_Points\"]]\n20: \n21: \n22: def scrape_season_stats(year):\n23:     base_url_reg = (\n24:         f\"https://www.basketball-reference.com/leagues/NBA_{year}_per_game.html\"\n25:     )\n26:     df_reg = pd.read_html(base_url_reg, header=0)[0]\n27:     df_reg = df_reg[df_reg[\"Player\"] != \"Player\"]  # remove repeated header rows\n28:     df_reg[\"Year\"] = year\n29: \n30:     df_reg = df_reg[\n31:         [\"Player\", \"Year\", \"PTS\", \"AST\", \"TRB\", \"FG%\"]\n32:     ]  # Keep only specified columns\n33:     df_reg = df_reg.dropna(\n34:         subset=[\"PTS\", \"AST\", \"TRB\", \"FG%\"]\n35:     )  # Ensure key stats aren't invalid\n36:     return df_reg\n37: \n38: \n39: def scrape_multiple_seasons(start_year=2018, end_year=2025):\n40:     all_stats = []\n41:     for year in range(start_year, end_year + 1):\n42:         df = scrape_season_stats(year)\n43:         all_stats.append(df)\n44:     return pd.concat(all_stats)\n45: \n46: \n47: if __name__ == \"__main__\":\n48:     if not os.path.exists(\"data\"):\n49:         os.makedirs(\"data\")\n50: \n51:     print(\"Scraping MVP votes...\")\n52:     mvp_df = scrape_mvp_votes()\n53:     mvp_df.to_csv(\"data/mvp_votes.csv\", index=False)\n54: \n55:     print(\"Scraping player stats...\")\n56:     stats_df = scrape_multiple_seasons()\n57:     stats_df.to_csv(\"data/season_stats.csv\", index=False)\n58: ",
            "mapping": [
                {
                    "summaryComponent": "Defines functions to scrape and process NBA data from Basketball Reference",
                    "codeSegments": [
                        {
                            "code": "def scrape_mvp_votes(start_year=2018, end_year=2025):",
                            "line": 5
                        },
                        {
                            "code": "def scrape_season_stats(year):",
                            "line": 22
                        },
                        {
                            "code": "def scrape_multiple_seasons(start_year=2018, end_year=2025):",
                            "line": 39
                        }
                    ]
                },
                {
                    "summaryComponent": "scrape_mvp_votes: Collects MVP voting tables for each year, renames columns, and combines results",
                    "codeSegments": [
                        {
                            "code": "def scrape_mvp_votes(start_year=2018, end_year=2025):",
                            "line": 5
                        },
                        {
                            "code": "for year in range(start_year, end_year + 1):",
                            "line": 7
                        },
                        {
                            "code": "url = f\"https://www.basketball-reference.com/awards/awards_{year}.html\"",
                            "line": 8
                        },
                        {
                            "code": "tables = pd.read_html(url, header=1)",
                            "line": 9
                        },
                        {
                            "code": "mvp_table = tables[0]  # MVP table is the first table",
                            "line": 11
                        },
                        {
                            "code": "mvp_table[\"Year\"] = year",
                            "line": 12
                        },
                        {
                            "code": "all_votes.append(mvp_table)",
                            "line": 13
                        },
                        {
                            "code": "df = pd.concat(all_votes)",
                            "line": 17
                        },
                        {
                            "code": "df = df.rename(columns={\"Player\": \"Name\", \"Pts Won\": \"MVP_Points\"})",
                            "line": 18
                        }
                    ]
                },
                {
                    "summaryComponent": "scrape_season_stats: Downloads per-game player stats, removes duplicate headers, selects key columns (Player, Year, PTS, AST, TRB, FG%), and drops rows with missing data",
                    "codeSegments": [
                        {
                            "code": "def scrape_season_stats(year):",
                            "line": 22
                        },
                        {
                            "code": "df_reg = pd.read_html(base_url_reg, header=0)[0]",
                            "line": 26
                        },
                        {
                            "code": "df_reg = df_reg[df_reg[\"Player\"] != \"Player\"]  # remove repeated header rows",
                            "line": 27
                        },
                        {
                            "code": "df_reg = df_reg[\n    [\"Player\", \"Year\", \"PTS\", \"AST\", \"TRB\", \"FG%\"]\n]",
                            "line": 30
                        },
                        {
                            "code": "df_reg = df_reg.dropna(\n    subset=[\"PTS\", \"AST\", \"TRB\", \"FG%\"]\n)",
                            "line": 33
                        }
                    ]
                },
                {
                    "summaryComponent": "scrape_multiple_seasons: Aggregates player stats across multiple seasons",
                    "codeSegments": [
                        {
                            "code": "def scrape_multiple_seasons(start_year=2018, end_year=2025):",
                            "line": 39
                        },
                        {
                            "code": "for year in range(start_year, end_year + 1):",
                            "line": 41
                        },
                        {
                            "code": "df = scrape_season_stats(year)",
                            "line": 42
                        },
                        {
                            "code": "all_stats.append(df)",
                            "line": 43
                        },
                        {
                            "code": "return pd.concat(all_stats)",
                            "line": 44
                        }
                    ]
                },
                {
                    "summaryComponent": "Handles data extraction for a configurable year range (default 2018-2025)",
                    "codeSegments": [
                        {
                            "code": "def scrape_mvp_votes(start_year=2018, end_year=2025):",
                            "line": 5
                        },
                        {
                            "code": "def scrape_multiple_seasons(start_year=2018, end_year=2025):",
                            "line": 39
                        }
                    ]
                },
                {
                    "summaryComponent": "Ensures a 'data' directory exists before saving files",
                    "codeSegments": [
                        {
                            "code": "if not os.path.exists(\"data\"):",
                            "line": 48
                        },
                        {
                            "code": "os.makedirs(\"data\")",
                            "line": 49
                        }
                    ]
                },
                {
                    "summaryComponent": "Exports MVP votes and player stats as separate CSV files",
                    "codeSegments": [
                        {
                            "code": "mvp_df.to_csv(\"data/mvp_votes.csv\", index=False)",
                            "line": 53
                        },
                        {
                            "code": "stats_df.to_csv(\"data/season_stats.csv\", index=False)",
                            "line": 57
                        }
                    ]
                },
                {
                    "summaryComponent": "Prints progress messages during scraping",
                    "codeSegments": [
                        {
                            "code": "print(\"Scraping MVP votes...\")",
                            "line": 51
                        },
                        {
                            "code": "print(\"Scraping player stats...\")",
                            "line": 55
                        }
                    ]
                }
            ]
        },
        "id": "g5092AIAloA2kcWifWiQ"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "timestamp": "2025-08-24 11:44:13.000",
        "data": {
            "structured_type": "unstructured",
            "detail_level": "medium",
            "section_id": "04ba9f41-f7cf-417a-ab4a-747376f4a2f9"
        },
        "id": "MZcxDW4YPz8qV4L8GizB"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "timestamp": "2025-08-24 11:44:13.000",
        "data": {
            "structured_type": "unstructured",
            "detail_level": "medium",
            "mapping_index": 1,
            "section_id": "04ba9f41-f7cf-417a-ab4a-747376f4a2f9"
        },
        "id": "YYmpVj8AgoVQjNStqFqC"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "timestamp": "2025-08-24 11:44:13.000",
        "data": {
            "structured_type": "unstructured",
            "detail_level": "medium",
            "mapping_index": 2,
            "section_id": "04ba9f41-f7cf-417a-ab4a-747376f4a2f9"
        },
        "id": "s9rwScXXsKHA4p6tDkgO"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "timestamp": "2025-08-24 11:44:14.000",
        "data": {
            "structured_type": "unstructured",
            "detail_level": "medium",
            "mapping_index": 0,
            "section_id": "04ba9f41-f7cf-417a-ab4a-747376f4a2f9"
        },
        "id": "TBgRV5I8tAyPZzNrh9AD"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "timestamp": "2025-08-24 11:44:14.000",
        "data": {
            "structured_type": "unstructured",
            "detail_level": "medium",
            "section_id": "04ba9f41-f7cf-417a-ab4a-747376f4a2f9"
        },
        "id": "UcIo64VWcmoqtsmJ5deY"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "timestamp": "2025-08-24 11:44:14.000",
        "data": {
            "structured_type": "unstructured",
            "detail_level": "medium",
            "section_id": "04ba9f41-f7cf-417a-ab4a-747376f4a2f9"
        },
        "id": "h9Mpmse8f6aqbywxzc6Q"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "timestamp": "2025-08-24 11:44:14.000",
        "data": {
            "structured_type": "unstructured",
            "detail_level": "medium",
            "mapping_index": 2,
            "section_id": "04ba9f41-f7cf-417a-ab4a-747376f4a2f9"
        },
        "id": "rj3osu5cFvw2QBFI3ipL"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "timestamp": "2025-08-24 11:44:16.000",
        "data": {
            "structured_type": "unstructured",
            "detail_level": "medium",
            "mapping_index": 3,
            "section_id": "04ba9f41-f7cf-417a-ab4a-747376f4a2f9"
        },
        "id": "JoRMze1chtxXIGjBzjET"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "timestamp": "2025-08-24 11:44:16.000",
        "data": {
            "structured_type": "unstructured",
            "detail_level": "medium",
            "mapping_index": 1,
            "section_id": "04ba9f41-f7cf-417a-ab4a-747376f4a2f9"
        },
        "id": "K1qiBBs66a2LhuEL7p15"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "timestamp": "2025-08-24 11:44:16.000",
        "data": {
            "structured_type": "unstructured",
            "detail_level": "medium",
            "section_id": "04ba9f41-f7cf-417a-ab4a-747376f4a2f9"
        },
        "id": "Y3aX9jOzRSp0xzkp1pQk"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "timestamp": "2025-08-24 11:44:16.000",
        "data": {
            "structured_type": "unstructured",
            "detail_level": "medium",
            "section_id": "04ba9f41-f7cf-417a-ab4a-747376f4a2f9"
        },
        "id": "eKcA8YupdsNzHMABz5QS"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "timestamp": "2025-08-24 11:44:17.000",
        "data": {
            "structured_type": "unstructured",
            "detail_level": "medium",
            "section_id": "04ba9f41-f7cf-417a-ab4a-747376f4a2f9"
        },
        "id": "29V7R91O4DUYKPYxJNqp"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "timestamp": "2025-08-24 11:44:17.000",
        "data": {
            "structured_type": "unstructured",
            "detail_level": "medium",
            "mapping_index": 7,
            "section_id": "04ba9f41-f7cf-417a-ab4a-747376f4a2f9"
        },
        "id": "XjIPdLeL4MI5rcIltJka"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "timestamp": "2025-08-24 11:44:18.000",
        "data": {
            "structured_type": "unstructured",
            "detail_level": "medium",
            "section_id": "04ba9f41-f7cf-417a-ab4a-747376f4a2f9"
        },
        "id": "ak3ZA6yI5FxfoGGGQES5"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "timestamp": "2025-08-24 11:44:24.000",
        "data": {
            "structured_type": "unstructured",
            "detail_level": "medium",
            "section_id": "04ba9f41-f7cf-417a-ab4a-747376f4a2f9"
        },
        "id": "4OSdflma5qixWXnReXLv"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "timestamp": "2025-08-24 11:44:24.000",
        "data": {
            "structured_type": "unstructured",
            "detail_level": "medium",
            "mapping_index": 2,
            "section_id": "04ba9f41-f7cf-417a-ab4a-747376f4a2f9"
        },
        "id": "BhFuJuwj7jlRwOr05MkK"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "timestamp": "2025-08-24 11:44:24.000",
        "data": {
            "structured_type": "unstructured",
            "detail_level": "medium",
            "mapping_index": 0,
            "section_id": "04ba9f41-f7cf-417a-ab4a-747376f4a2f9"
        },
        "id": "I3M978im5A09lVkgyWRC"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "timestamp": "2025-08-24 11:44:24.000",
        "data": {
            "structured_type": "unstructured",
            "detail_level": "medium",
            "section_id": "04ba9f41-f7cf-417a-ab4a-747376f4a2f9"
        },
        "id": "cieI1W6m7601a9Airdhr"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "timestamp": "2025-08-24 11:44:24.000",
        "data": {
            "structured_type": "unstructured",
            "detail_level": "medium",
            "mapping_index": 5,
            "section_id": "04ba9f41-f7cf-417a-ab4a-747376f4a2f9"
        },
        "id": "oOuS4wISS9ElnJV7gGbr"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "timestamp": "2025-08-24 11:44:24.000",
        "data": {
            "structured_type": "unstructured",
            "detail_level": "medium",
            "mapping_index": 2,
            "section_id": "04ba9f41-f7cf-417a-ab4a-747376f4a2f9"
        },
        "id": "vNsgxMhAwUehFx1EACoI"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "timestamp": "2025-08-24 11:44:24.000",
        "data": {
            "structured_type": "unstructured",
            "detail_level": "medium",
            "section_id": "04ba9f41-f7cf-417a-ab4a-747376f4a2f9"
        },
        "id": "wKDY8Fi7EO5Y5YmVGcLe"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "timestamp": "2025-08-24 11:44:26.000",
        "data": {
            "structured_type": "unstructured",
            "detail_level": "medium",
            "section_id": "04ba9f41-f7cf-417a-ab4a-747376f4a2f9"
        },
        "id": "a8FEhEB5c3ZhNJQ9RBhd"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "timestamp": "2025-08-24 11:44:26.000",
        "data": {
            "structured_type": "unstructured",
            "detail_level": "medium",
            "mapping_index": 0,
            "section_id": "04ba9f41-f7cf-417a-ab4a-747376f4a2f9"
        },
        "id": "dJ5aPXsp26v6er3NqT1A"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "timestamp": "2025-08-24 11:44:26.000",
        "data": {
            "structured_type": "unstructured",
            "detail_level": "medium",
            "section_id": "04ba9f41-f7cf-417a-ab4a-747376f4a2f9"
        },
        "id": "fpdaoCTRpXECIAUjbnyV"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "timestamp": "2025-08-24 11:44:43.000",
        "data": {
            "structured_type": "unstructured",
            "detail_level": "medium",
            "section_id": "04ba9f41-f7cf-417a-ab4a-747376f4a2f9"
        },
        "id": "5qzrnd0raMh9sMN7YvAk"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "timestamp": "2025-08-24 11:44:43.000",
        "data": {
            "structured_type": "unstructured",
            "detail_level": "medium",
            "mapping_index": 1,
            "section_id": "04ba9f41-f7cf-417a-ab4a-747376f4a2f9"
        },
        "id": "9njOo72HpPnmnMiH2Ptn"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "timestamp": "2025-08-24 11:44:43.000",
        "data": {
            "structured_type": "unstructured",
            "detail_level": "medium",
            "mapping_index": 0,
            "section_id": "04ba9f41-f7cf-417a-ab4a-747376f4a2f9"
        },
        "id": "B2x00eKRVbE0ovDnQRSA"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "timestamp": "2025-08-24 11:44:43.000",
        "data": {
            "structured_type": "unstructured",
            "detail_level": "medium",
            "section_id": "04ba9f41-f7cf-417a-ab4a-747376f4a2f9"
        },
        "id": "Efoz3BTUbjsdqR4wnefh"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "timestamp": "2025-08-24 11:44:43.000",
        "data": {
            "structured_type": "unstructured",
            "detail_level": "medium",
            "mapping_index": 3,
            "section_id": "04ba9f41-f7cf-417a-ab4a-747376f4a2f9"
        },
        "id": "kBs5qmLjjxReWX7BlD9Y"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "timestamp": "2025-08-24 11:44:43.000",
        "data": {
            "structured_type": "unstructured",
            "detail_level": "medium",
            "section_id": "04ba9f41-f7cf-417a-ab4a-747376f4a2f9"
        },
        "id": "kRTLRQZFEPHm4bp2Fy06"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "timestamp": "2025-08-24 11:44:43.000",
        "data": {
            "structured_type": "unstructured",
            "detail_level": "medium",
            "mapping_index": 2,
            "section_id": "04ba9f41-f7cf-417a-ab4a-747376f4a2f9"
        },
        "id": "neG9ByHQmGAd2NJ72wlY"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "timestamp": "2025-08-24 11:44:45.000",
        "data": {
            "structured_type": "unstructured",
            "detail_level": "medium",
            "section_id": "04ba9f41-f7cf-417a-ab4a-747376f4a2f9"
        },
        "id": "3iW6fYq4il61w0ZhuTUw"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "timestamp": "2025-08-24 11:44:45.000",
        "data": {
            "structured_type": "unstructured",
            "detail_level": "medium",
            "mapping_index": 3,
            "section_id": "04ba9f41-f7cf-417a-ab4a-747376f4a2f9"
        },
        "id": "Bh8I88K0VJ8gR5yQSkL5"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "timestamp": "2025-08-24 11:44:46.000",
        "data": {
            "structured_type": "unstructured",
            "detail_level": "medium",
            "mapping_index": 6,
            "section_id": "04ba9f41-f7cf-417a-ab4a-747376f4a2f9"
        },
        "id": "0597To52n88oIwQBfT0O"
    },
    {
        "source": "frontend",
        "event": "change_summary_level",
        "timestamp": "2025-08-24 11:44:46.000",
        "data": {
            "before_structured": "unstructured",
            "before_detail_level": "medium",
            "after_structured": "structured",
            "after_detail_level": "medium",
            "section_id": "04ba9f41-f7cf-417a-ab4a-747376f4a2f9"
        },
        "id": "0ryUWJ9wgsnSBaBIIFKJ"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "timestamp": "2025-08-24 11:44:46.000",
        "data": {
            "structured_type": "unstructured",
            "detail_level": "medium",
            "section_id": "04ba9f41-f7cf-417a-ab4a-747376f4a2f9"
        },
        "id": "3fOv2lywAs5K9S0Yvjdf"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "timestamp": "2025-08-24 11:44:46.000",
        "data": {
            "structured_type": "unstructured",
            "detail_level": "medium",
            "mapping_index": 2,
            "section_id": "04ba9f41-f7cf-417a-ab4a-747376f4a2f9"
        },
        "id": "42XQRfAnDvUTMLrC7CL3"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "timestamp": "2025-08-24 11:44:46.000",
        "data": {
            "structured_type": "unstructured",
            "detail_level": "medium",
            "section_id": "04ba9f41-f7cf-417a-ab4a-747376f4a2f9"
        },
        "id": "9dgyuiHY8uZxTipAtzWt"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "timestamp": "2025-08-24 11:44:46.000",
        "data": {
            "structured_type": "unstructured",
            "detail_level": "medium",
            "mapping_index": 0,
            "section_id": "04ba9f41-f7cf-417a-ab4a-747376f4a2f9"
        },
        "id": "LO67QwO19PvAhgwi2vAL"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "timestamp": "2025-08-24 11:44:46.000",
        "data": {
            "structured_type": "unstructured",
            "detail_level": "medium",
            "section_id": "04ba9f41-f7cf-417a-ab4a-747376f4a2f9"
        },
        "id": "nde9KesTwlZP66tjcnSo"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "timestamp": "2025-08-24 11:44:46.000",
        "data": {
            "structured_type": "unstructured",
            "detail_level": "medium",
            "section_id": "04ba9f41-f7cf-417a-ab4a-747376f4a2f9"
        },
        "id": "wJWaSeBu0u5kBDfHvmii"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "timestamp": "2025-08-24 11:44:47.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "medium",
            "section_id": "04ba9f41-f7cf-417a-ab4a-747376f4a2f9"
        },
        "id": "7J400UJMydGvAds5oYan"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "timestamp": "2025-08-24 11:44:47.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "medium",
            "mapping_index": 0,
            "section_id": "04ba9f41-f7cf-417a-ab4a-747376f4a2f9"
        },
        "id": "8iEgmebopgDbOFHuNjad"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "timestamp": "2025-08-24 11:44:47.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "medium",
            "section_id": "04ba9f41-f7cf-417a-ab4a-747376f4a2f9"
        },
        "id": "9VJds2L3xm0dHvmrUFyV"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "timestamp": "2025-08-24 11:44:47.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "medium",
            "mapping_index": 1,
            "section_id": "04ba9f41-f7cf-417a-ab4a-747376f4a2f9"
        },
        "id": "HGSabitO0HD2oJK1Qg6y"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "timestamp": "2025-08-24 11:44:47.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "medium",
            "section_id": "04ba9f41-f7cf-417a-ab4a-747376f4a2f9"
        },
        "id": "MWqf2lvctpN7WtXd0XiK"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "timestamp": "2025-08-24 11:44:47.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "medium",
            "mapping_index": 3,
            "section_id": "04ba9f41-f7cf-417a-ab4a-747376f4a2f9"
        },
        "id": "b1PEsvbNhpfDBljCOjDs"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "timestamp": "2025-08-24 11:44:47.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "medium",
            "mapping_index": 2,
            "section_id": "04ba9f41-f7cf-417a-ab4a-747376f4a2f9"
        },
        "id": "bwDqXcd6nzMhDetKjvdP"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "timestamp": "2025-08-24 11:44:47.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "medium",
            "mapping_index": 3,
            "section_id": "04ba9f41-f7cf-417a-ab4a-747376f4a2f9"
        },
        "id": "kveGE8dOW4ydaGSxf0Lf"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "timestamp": "2025-08-24 11:44:47.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "medium",
            "section_id": "04ba9f41-f7cf-417a-ab4a-747376f4a2f9"
        },
        "id": "q0BmfTWJqBpAq3mlb6zU"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "timestamp": "2025-08-24 11:44:49.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "medium",
            "section_id": "04ba9f41-f7cf-417a-ab4a-747376f4a2f9"
        },
        "id": "0bhz03HB0QEH9flYOTzp"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "timestamp": "2025-08-24 11:44:49.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "medium",
            "mapping_index": 2,
            "section_id": "04ba9f41-f7cf-417a-ab4a-747376f4a2f9"
        },
        "id": "JYNakJ54Izl6CpSah7Sm"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "timestamp": "2025-08-24 11:44:50.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "medium",
            "section_id": "04ba9f41-f7cf-417a-ab4a-747376f4a2f9"
        },
        "id": "EWUla3iTLjXzNhHjSIQd"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "timestamp": "2025-08-24 11:44:50.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "medium",
            "mapping_index": 1,
            "section_id": "04ba9f41-f7cf-417a-ab4a-747376f4a2f9"
        },
        "id": "Lwwm4JkuTLXhXInWKNwR"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "timestamp": "2025-08-24 11:44:50.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "medium",
            "mapping_index": 0,
            "section_id": "04ba9f41-f7cf-417a-ab4a-747376f4a2f9"
        },
        "id": "hKuq3Eual9mcyylhCHz9"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "timestamp": "2025-08-24 11:44:50.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "medium",
            "section_id": "04ba9f41-f7cf-417a-ab4a-747376f4a2f9"
        },
        "id": "ol613jrhZ6hSxY5vQ2pB"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "timestamp": "2025-08-24 11:44:51.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "medium",
            "section_id": "04ba9f41-f7cf-417a-ab4a-747376f4a2f9"
        },
        "id": "VSsTBufJ4fu0DSC7as5S"
    },
    {
        "source": "frontend",
        "event": "change_summary_level",
        "timestamp": "2025-08-24 11:45:05.000",
        "data": {
            "before_structured": "structured",
            "before_detail_level": "medium",
            "after_structured": "structured",
            "after_detail_level": "low",
            "section_id": "04ba9f41-f7cf-417a-ab4a-747376f4a2f9"
        },
        "id": "XwzhKACAw8T8FdjTrR3l"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "timestamp": "2025-08-24 11:45:07.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "low",
            "mapping_index": 1,
            "section_id": "04ba9f41-f7cf-417a-ab4a-747376f4a2f9"
        },
        "id": "JNOAo8pt7yc1uFFhxKLB"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "timestamp": "2025-08-24 11:45:07.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "low",
            "section_id": "04ba9f41-f7cf-417a-ab4a-747376f4a2f9"
        },
        "id": "d3NqMXLBPLz6Am7cI6sF"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "timestamp": "2025-08-24 11:45:07.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "low",
            "mapping_index": 1,
            "section_id": "04ba9f41-f7cf-417a-ab4a-747376f4a2f9"
        },
        "id": "dYgKw6iT58ctgndML6eA"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "timestamp": "2025-08-24 11:45:08.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "low",
            "mapping_index": 0,
            "section_id": "04ba9f41-f7cf-417a-ab4a-747376f4a2f9"
        },
        "id": "aZfEsTWnv8CQJSPjn8Va"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "timestamp": "2025-08-24 11:45:08.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "low",
            "section_id": "04ba9f41-f7cf-417a-ab4a-747376f4a2f9"
        },
        "id": "v5XSZ0VgTIbJhTIw1KSZ"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "timestamp": "2025-08-24 11:45:09.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "low",
            "mapping_index": 1,
            "section_id": "04ba9f41-f7cf-417a-ab4a-747376f4a2f9"
        },
        "id": "ZwpksMbccMWNH9OR3Ysj"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "timestamp": "2025-08-24 11:45:09.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "low",
            "section_id": "04ba9f41-f7cf-417a-ab4a-747376f4a2f9"
        },
        "id": "prlsufJ1rIbsphnw7rmC"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "timestamp": "2025-08-24 11:45:16.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "low",
            "mapping_index": 3,
            "section_id": "04ba9f41-f7cf-417a-ab4a-747376f4a2f9"
        },
        "id": "R2HOEfoDElNA8bG7v5Ho"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "timestamp": "2025-08-24 11:45:16.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "low",
            "section_id": "04ba9f41-f7cf-417a-ab4a-747376f4a2f9"
        },
        "id": "akOKxmFdliZUaJnnq1wj"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "timestamp": "2025-08-24 11:45:20.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "low",
            "section_id": "04ba9f41-f7cf-417a-ab4a-747376f4a2f9"
        },
        "id": "CufgXXyVR3blcEOzWYNR"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "timestamp": "2025-08-24 11:45:20.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "low",
            "section_id": "04ba9f41-f7cf-417a-ab4a-747376f4a2f9"
        },
        "id": "HcSytqrM4l18wCRCHr72"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "timestamp": "2025-08-24 11:45:20.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "low",
            "mapping_index": 1,
            "section_id": "04ba9f41-f7cf-417a-ab4a-747376f4a2f9"
        },
        "id": "LoXqBKcmniARCa5d199M"
    },
    {
        "source": "frontend",
        "event": "change_summary_level",
        "timestamp": "2025-08-24 11:45:21.000",
        "data": {
            "before_structured": "structured",
            "before_detail_level": "low",
            "after_structured": "structured",
            "after_detail_level": "medium",
            "section_id": "04ba9f41-f7cf-417a-ab4a-747376f4a2f9"
        },
        "id": "ieuqd54tk6u89K7J90ZB"
    },
    {
        "source": "frontend",
        "event": "change_summary_level",
        "timestamp": "2025-08-24 11:45:24.000",
        "data": {
            "before_structured": "structured",
            "before_detail_level": "medium",
            "after_structured": "structured",
            "after_detail_level": "high",
            "section_id": "04ba9f41-f7cf-417a-ab4a-747376f4a2f9"
        },
        "id": "q9xm6ZpX6fPbs3w7msOg"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "timestamp": "2025-08-24 11:45:26.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "high",
            "mapping_index": 1,
            "section_id": "04ba9f41-f7cf-417a-ab4a-747376f4a2f9"
        },
        "id": "N2rxGC7181gysiQq3awY"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "timestamp": "2025-08-24 11:45:26.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "high",
            "mapping_index": 0,
            "section_id": "04ba9f41-f7cf-417a-ab4a-747376f4a2f9"
        },
        "id": "UWhHXpHfA42K0gm2UajL"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "timestamp": "2025-08-24 11:45:26.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "high",
            "section_id": "04ba9f41-f7cf-417a-ab4a-747376f4a2f9"
        },
        "id": "W5aUu6vsl4NjpGCDiPrA"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "timestamp": "2025-08-24 11:45:26.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "high",
            "section_id": "04ba9f41-f7cf-417a-ab4a-747376f4a2f9"
        },
        "id": "YwJGdZ3d5TSlFsjDFnjs"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "timestamp": "2025-08-24 11:45:26.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "high",
            "mapping_index": 2,
            "section_id": "04ba9f41-f7cf-417a-ab4a-747376f4a2f9"
        },
        "id": "umEdOR4rLUKAu0So3Cfk"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "timestamp": "2025-08-24 11:45:30.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "high",
            "section_id": "04ba9f41-f7cf-417a-ab4a-747376f4a2f9"
        },
        "id": "2THbbb0j8CWbrLdyiz9g"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "timestamp": "2025-08-24 11:45:30.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "high",
            "mapping_index": 1,
            "section_id": "04ba9f41-f7cf-417a-ab4a-747376f4a2f9"
        },
        "id": "NMIOMzXTPCF2mkQ2cDLV"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "timestamp": "2025-08-24 11:45:32.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "high",
            "mapping_index": 1,
            "section_id": "04ba9f41-f7cf-417a-ab4a-747376f4a2f9"
        },
        "id": "7VDe9CVuGucAskYL2ZqU"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "timestamp": "2025-08-24 11:45:32.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "high",
            "section_id": "04ba9f41-f7cf-417a-ab4a-747376f4a2f9"
        },
        "id": "r7vsYTKPYfNSzK3Zn6Pt"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "timestamp": "2025-08-24 11:45:32.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "high",
            "section_id": "04ba9f41-f7cf-417a-ab4a-747376f4a2f9"
        },
        "id": "txzrxEgsYcp7RYORkgKp"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "timestamp": "2025-08-24 11:46:08.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "high",
            "mapping_index": 2,
            "section_id": "04ba9f41-f7cf-417a-ab4a-747376f4a2f9"
        },
        "id": "3JT9ISbaOK5FwxZIpyy0"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "timestamp": "2025-08-24 11:46:08.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "high",
            "mapping_index": 4,
            "section_id": "04ba9f41-f7cf-417a-ab4a-747376f4a2f9"
        },
        "id": "4WMq3eHsxKd6XWPldcOI"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "timestamp": "2025-08-24 11:46:08.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "high",
            "section_id": "04ba9f41-f7cf-417a-ab4a-747376f4a2f9"
        },
        "id": "CBZTEboMBWk652pGauq2"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "timestamp": "2025-08-24 11:46:08.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "high",
            "section_id": "04ba9f41-f7cf-417a-ab4a-747376f4a2f9"
        },
        "id": "PhVQWmlRKk0MUraEBtIW"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "timestamp": "2025-08-24 11:46:08.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "high",
            "section_id": "04ba9f41-f7cf-417a-ab4a-747376f4a2f9"
        },
        "id": "RKamtBLmYLbvTUttSlTP"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "timestamp": "2025-08-24 11:46:08.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "high",
            "section_id": "04ba9f41-f7cf-417a-ab4a-747376f4a2f9"
        },
        "id": "WXtLyOumpnrsx9i0gG8r"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "timestamp": "2025-08-24 11:46:08.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "high",
            "mapping_index": 4,
            "section_id": "04ba9f41-f7cf-417a-ab4a-747376f4a2f9"
        },
        "id": "iQMGIy7ehdC0w8bQoqLu"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "timestamp": "2025-08-24 11:46:08.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "high",
            "section_id": "04ba9f41-f7cf-417a-ab4a-747376f4a2f9"
        },
        "id": "jpSyFxNjqQHMy6QhaQ61"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "timestamp": "2025-08-24 11:46:08.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "high",
            "mapping_index": 5,
            "section_id": "04ba9f41-f7cf-417a-ab4a-747376f4a2f9"
        },
        "id": "m4AuuUTU7lfMBDjGwLIq"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "timestamp": "2025-08-24 11:46:08.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "high",
            "mapping_index": 3,
            "section_id": "04ba9f41-f7cf-417a-ab4a-747376f4a2f9"
        },
        "id": "mvXJKBlXgHASIUYa9i3K"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "timestamp": "2025-08-24 11:46:08.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "high",
            "mapping_index": 3,
            "section_id": "04ba9f41-f7cf-417a-ab4a-747376f4a2f9"
        },
        "id": "sJogtqZKAseizLsHGiqF"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "timestamp": "2025-08-24 11:46:09.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "high",
            "section_id": "04ba9f41-f7cf-417a-ab4a-747376f4a2f9"
        },
        "id": "Iu47ZdH6vfxO3hmxc6Xl"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "timestamp": "2025-08-24 11:46:09.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "high",
            "mapping_index": 4,
            "section_id": "04ba9f41-f7cf-417a-ab4a-747376f4a2f9"
        },
        "id": "MzSsd1f03u96jItTd0Kn"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "timestamp": "2025-08-24 11:46:09.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "high",
            "mapping_index": 2,
            "section_id": "04ba9f41-f7cf-417a-ab4a-747376f4a2f9"
        },
        "id": "WRE3NQ0AvMxONiVsOKmQ"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "timestamp": "2025-08-24 11:46:09.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "high",
            "section_id": "04ba9f41-f7cf-417a-ab4a-747376f4a2f9"
        },
        "id": "a8yFAI2395pVkhSd5yeV"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "timestamp": "2025-08-24 11:46:09.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "high",
            "section_id": "04ba9f41-f7cf-417a-ab4a-747376f4a2f9"
        },
        "id": "l5pdXYTmUgxGKvkdPYWx"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "timestamp": "2025-08-24 11:46:09.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "high",
            "mapping_index": 3,
            "section_id": "04ba9f41-f7cf-417a-ab4a-747376f4a2f9"
        },
        "id": "woDK4qmwlqJLuTRrZWAa"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "timestamp": "2025-08-24 11:46:10.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "high",
            "section_id": "04ba9f41-f7cf-417a-ab4a-747376f4a2f9"
        },
        "id": "aGK2dh4ZlX5GBM5ccrhf"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "timestamp": "2025-08-24 11:46:10.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "high",
            "mapping_index": 1,
            "section_id": "04ba9f41-f7cf-417a-ab4a-747376f4a2f9"
        },
        "id": "e6EOnlTsn9h0QzrmMHNj"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "timestamp": "2025-08-24 11:46:13.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "high",
            "mapping_index": 1,
            "section_id": "04ba9f41-f7cf-417a-ab4a-747376f4a2f9"
        },
        "id": "2SQLwcjsmSK9BXqH6c3V"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "timestamp": "2025-08-24 11:46:13.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "high",
            "section_id": "04ba9f41-f7cf-417a-ab4a-747376f4a2f9"
        },
        "id": "8N6HTaIjNK3IwvChDlsN"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "timestamp": "2025-08-24 11:46:13.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "high",
            "section_id": "04ba9f41-f7cf-417a-ab4a-747376f4a2f9"
        },
        "id": "Y9DbyRHt4QycdnIpEu1m"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "timestamp": "2025-08-24 11:46:13.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "high",
            "mapping_index": 2,
            "section_id": "04ba9f41-f7cf-417a-ab4a-747376f4a2f9"
        },
        "id": "um8GsbeIllRtN2kx5WTD"
    },
    {
        "source": "frontend",
        "event": "click_edit_in_prompt",
        "timestamp": "2025-08-24 11:46:14.000",
        "data": {
            "detail_level": "high",
            "structured": "structured",
            "summary": "• Defines functions to scrape and process NBA data from Basketball Reference\n  ◦ scrape_mvp_votes: Collects MVP voting tables for each year, renames columns, and combines results\n  ◦ scrape_season_stats: Downloads per-game player stats, removes duplicate headers, selects key columns (Player, Year, PTS, AST, TRB, FG%), and drops rows with missing data\n  ◦ scrape_multiple_seasons: Aggregates player stats across multiple seasons\n• Handles data extraction for a configurable year range (default 2018-2025)\n• Ensures a 'data' directory exists before saving files\n• Exports MVP votes and player stats as separate CSV files\n• Prints progress messages during scraping",
            "section_id": "04ba9f41-f7cf-417a-ab4a-747376f4a2f9"
        },
        "id": "U5htwpyEpUABIvu22jlE"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "timestamp": "2025-08-24 11:46:14.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "high",
            "section_id": "04ba9f41-f7cf-417a-ab4a-747376f4a2f9"
        },
        "id": "swpenR3E8FWfQot8P7zV"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "timestamp": "2025-08-24 11:46:15.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "high",
            "section_id": "04ba9f41-f7cf-417a-ab4a-747376f4a2f9"
        },
        "id": "HUI947JKCjXXMqM5sy4Y"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "timestamp": "2025-08-24 11:46:15.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "high",
            "section_id": "04ba9f41-f7cf-417a-ab4a-747376f4a2f9"
        },
        "id": "NmIza6CANTrDscQDXf7C"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "timestamp": "2025-08-24 11:46:15.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "high",
            "mapping_index": 1,
            "section_id": "04ba9f41-f7cf-417a-ab4a-747376f4a2f9"
        },
        "id": "TlsSh56eVSB0ze4p5I0V"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "timestamp": "2025-08-24 11:46:15.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "high",
            "mapping_index": 2,
            "section_id": "04ba9f41-f7cf-417a-ab4a-747376f4a2f9"
        },
        "id": "Yf0pK55H2vCBf3prIHVc"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "timestamp": "2025-08-24 11:46:47.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "high",
            "mapping_index": 3,
            "section_id": "04ba9f41-f7cf-417a-ab4a-747376f4a2f9"
        },
        "id": "SZtxwpp8jJjiWz7BinBy"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "timestamp": "2025-08-24 11:46:47.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "high",
            "mapping_index": 2,
            "section_id": "04ba9f41-f7cf-417a-ab4a-747376f4a2f9"
        },
        "id": "UcZsSZF3jHiBZhsX9mRP"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "timestamp": "2025-08-24 11:46:47.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "high",
            "section_id": "04ba9f41-f7cf-417a-ab4a-747376f4a2f9"
        },
        "id": "y4UIxQCExklLYYUcr6dM"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "timestamp": "2025-08-24 11:46:48.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "high",
            "section_id": "04ba9f41-f7cf-417a-ab4a-747376f4a2f9"
        },
        "id": "PMISyBdDwRuatGHj5nVu"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "timestamp": "2025-08-24 11:46:48.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "high",
            "mapping_index": 2,
            "section_id": "04ba9f41-f7cf-417a-ab4a-747376f4a2f9"
        },
        "id": "SoG8RrU1WlDw3gth1h49"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "timestamp": "2025-08-24 11:46:48.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "high",
            "section_id": "04ba9f41-f7cf-417a-ab4a-747376f4a2f9"
        },
        "id": "idOePlBz75fjFlRw1XbL"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "timestamp": "2025-08-24 11:46:58.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "high",
            "section_id": "04ba9f41-f7cf-417a-ab4a-747376f4a2f9"
        },
        "id": "0sMcc9gyNNNmw7p1NqEF"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "timestamp": "2025-08-24 11:46:58.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "high",
            "mapping_index": 7,
            "section_id": "04ba9f41-f7cf-417a-ab4a-747376f4a2f9"
        },
        "id": "H57Aq2y1N2q6MWgXXCFU"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "timestamp": "2025-08-24 11:46:58.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "high",
            "mapping_index": 3,
            "section_id": "04ba9f41-f7cf-417a-ab4a-747376f4a2f9"
        },
        "id": "MdTXSCbi6Vc3RuhouULH"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "timestamp": "2025-08-24 11:46:58.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "high",
            "section_id": "04ba9f41-f7cf-417a-ab4a-747376f4a2f9"
        },
        "id": "N6YFl8M1uCPyXhzwR3IS"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "timestamp": "2025-08-24 11:46:58.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "high",
            "section_id": "04ba9f41-f7cf-417a-ab4a-747376f4a2f9"
        },
        "id": "fMd16tYfq03r1ToVHInn"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "timestamp": "2025-08-24 11:46:58.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "high",
            "mapping_index": 1,
            "section_id": "04ba9f41-f7cf-417a-ab4a-747376f4a2f9"
        },
        "id": "fj984qhnUTyarKLiWuuI"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "timestamp": "2025-08-24 11:46:58.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "high",
            "section_id": "04ba9f41-f7cf-417a-ab4a-747376f4a2f9"
        },
        "id": "vhJks92ydDe0WEHMlA3W"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "timestamp": "2025-08-24 11:46:58.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "high",
            "mapping_index": 2,
            "section_id": "04ba9f41-f7cf-417a-ab4a-747376f4a2f9"
        },
        "id": "zSQBeTUGTdYw8myEIWLL"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "timestamp": "2025-08-24 11:46:59.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "high",
            "mapping_index": 3,
            "section_id": "04ba9f41-f7cf-417a-ab4a-747376f4a2f9"
        },
        "id": "4srK0hx9YnAh0JSGFSjN"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "timestamp": "2025-08-24 11:46:59.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "high",
            "mapping_index": 0,
            "section_id": "04ba9f41-f7cf-417a-ab4a-747376f4a2f9"
        },
        "id": "OFCi51tg7VD5pvSZzwfQ"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "timestamp": "2025-08-24 11:46:59.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "high",
            "section_id": "04ba9f41-f7cf-417a-ab4a-747376f4a2f9"
        },
        "id": "U9YF0abCima0F0G0rWes"
    },
    {
        "source": "frontend",
        "event": "click_summarize_code",
        "timestamp": "2025-08-24 11:46:59.000",
        "data": {},
        "id": "dsVpLh5cXGpHoMo6LUYX"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "timestamp": "2025-08-24 11:46:59.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "high",
            "section_id": "04ba9f41-f7cf-417a-ab4a-747376f4a2f9"
        },
        "id": "gfApu2LauJXWKTfyJKMj"
    },
    {
        "source": "backend",
        "event": "summarize_selected_code",
        "timestamp": "2025-08-24 11:47:05.000",
        "data": {
            "summary": {
                "medium_structured": "• Downloads per-game NBA stats for a specified year from Basketball Reference\n• Cleans the data:\n  ◦ Removes repeated header rows\n  ◦ Adds the year as a column\n• Filters to keep only Player, Year, PTS, AST, TRB, and FG% columns\n• Drops rows with missing values in key stats\n• Returns the cleaned DataFrame",
                "low_unstructured": "This function retrieves and processes NBA player per-game statistics for a given year from Basketball Reference.",
                "high_structured": "• Constructs the URL for the NBA per-game stats page for the specified year\n• Reads the first HTML table from the page into a DataFrame\n• Cleans the DataFrame:\n  ◦ Removes rows where the 'Player' column equals 'Player' (eliminating repeated headers)\n  ◦ Adds a 'Year' column to indicate the season\n• Filters the DataFrame to keep only the following columns:\n  ◦ Player, Year, PTS, AST, TRB, FG%\n• Drops rows with missing values in any of the key stat columns (PTS, AST, TRB, FG%)\n• Returns the processed DataFrame containing clean, relevant player statistics for the given year",
                "low_structured": "• Fetches NBA per-game stats for a given year\n• Cleans and filters the data\n• Returns selected player statistics",
                "high_unstructured": "The scrape_season_stats function takes a year as input and constructs the URL for that season's NBA per-game statistics page on Basketball Reference. It reads the HTML table into a DataFrame, removes any rows where the 'Player' column contains the header string (to eliminate repeated headers), and adds a 'Year' column. The function then filters the DataFrame to retain only the columns for player name, year, points, assists, rebounds, and field goal percentage. Finally, it drops any rows with missing values in these key statistics and returns the cleaned DataFrame for further analysis.",
                "medium_unstructured": "The function scrape_season_stats downloads NBA per-game statistics for a specified year from Basketball Reference. It cleans the data by removing repeated header rows and keeps only relevant columns such as player name, year, points, assists, rebounds, and field goal percentage. The function also ensures that rows with missing key stats are excluded before returning the processed DataFrame.",
                "title": "Summary of scrape_season_stats(year) Function"
            },
            "selected_code": "def scrape_season_stats(year):\n    base_url_reg = (\n        f\"https://www.basketball-reference.com/leagues/NBA_{year}_per_game.html\"\n    )\n    df_reg = pd.read_html(base_url_reg, header=0)[0]\n    df_reg = df_reg[df_reg[\"Player\"] != \"Player\"]  # remove repeated header rows\n    df_reg[\"Year\"] = year\n\n    df_reg = df_reg[\n        [\"Player\", \"Year\", \"PTS\", \"AST\", \"TRB\", \"FG%\"]\n    ]  # Keep only specified columns\n    df_reg = df_reg.dropna(\n        subset=[\"PTS\", \"AST\", \"TRB\", \"FG%\"]\n    )  # Ensure key stats aren't invalid\n    return df_reg"
        },
        "id": "ux3wdoxHyUoSa0JWKzcA"
    },
    {
        "source": "backend",
        "event": "map_summary_code",
        "timestamp": "2025-08-24 11:47:08.000",
        "data": {
            "summary": "• Downloads per-game NBA stats for a specified year from Basketball Reference\n• Cleans the data:\n  ◦ Removes repeated header rows\n  ◦ Adds the year as a column\n• Filters to keep only Player, Year, PTS, AST, TRB, and FG% columns\n• Drops rows with missing values in key stats\n• Returns the cleaned DataFrame",
            "code": "22: def scrape_season_stats(year):\n23:     base_url_reg = (\n24:         f\"https://www.basketball-reference.com/leagues/NBA_{year}_per_game.html\"\n25:     )\n26:     df_reg = pd.read_html(base_url_reg, header=0)[0]\n27:     df_reg = df_reg[df_reg[\"Player\"] != \"Player\"]  # remove repeated header rows\n28:     df_reg[\"Year\"] = year\n29: \n30:     df_reg = df_reg[\n31:         [\"Player\", \"Year\", \"PTS\", \"AST\", \"TRB\", \"FG%\"]\n32:     ]  # Keep only specified columns\n33:     df_reg = df_reg.dropna(\n34:         subset=[\"PTS\", \"AST\", \"TRB\", \"FG%\"]\n35:     )  # Ensure key stats aren't invalid\n36:     return df_reg",
            "mapping": [
                {
                    "summaryComponent": "Downloads per-game NBA stats for a specified year from Basketball Reference",
                    "codeSegments": [
                        {
                            "code": "base_url_reg = (\n    f\"https://www.basketball-reference.com/leagues/NBA_{year}_per_game.html\"\n)",
                            "line": 23
                        },
                        {
                            "code": "df_reg = pd.read_html(base_url_reg, header=0)[0]",
                            "line": 26
                        }
                    ]
                },
                {
                    "summaryComponent": "Cleans the data:",
                    "codeSegments": []
                },
                {
                    "summaryComponent": "Removes repeated header rows",
                    "codeSegments": [
                        {
                            "code": "df_reg = df_reg[df_reg[\"Player\"] != \"Player\"]  # remove repeated header rows",
                            "line": 27
                        }
                    ]
                },
                {
                    "summaryComponent": "Adds the year as a column",
                    "codeSegments": [
                        {
                            "code": "df_reg[\"Year\"] = year",
                            "line": 28
                        }
                    ]
                },
                {
                    "summaryComponent": "Filters to keep only Player, Year, PTS, AST, TRB, and FG% columns",
                    "codeSegments": [
                        {
                            "code": "df_reg = df_reg[\n    [\"Player\", \"Year\", \"PTS\", \"AST\", \"TRB\", \"FG%\"]\n]",
                            "line": 30
                        }
                    ]
                },
                {
                    "summaryComponent": "Drops rows with missing values in key stats",
                    "codeSegments": [
                        {
                            "code": "df_reg = df_reg.dropna(\n    subset=[\"PTS\", \"AST\", \"TRB\", \"FG%\"]\n)",
                            "line": 33
                        }
                    ]
                },
                {
                    "summaryComponent": "Returns the cleaned DataFrame",
                    "codeSegments": [
                        {
                            "code": "return df_reg",
                            "line": 36
                        }
                    ]
                }
            ]
        },
        "id": "SeyzppT06iAW645IamXA"
    },
    {
        "source": "backend",
        "event": "map_summary_code",
        "timestamp": "2025-08-24 11:47:08.000",
        "data": {
            "summary": "• Fetches NBA per-game stats for a given year\n• Cleans and filters the data\n• Returns selected player statistics",
            "code": "22: def scrape_season_stats(year):\n23:     base_url_reg = (\n24:         f\"https://www.basketball-reference.com/leagues/NBA_{year}_per_game.html\"\n25:     )\n26:     df_reg = pd.read_html(base_url_reg, header=0)[0]\n27:     df_reg = df_reg[df_reg[\"Player\"] != \"Player\"]  # remove repeated header rows\n28:     df_reg[\"Year\"] = year\n29: \n30:     df_reg = df_reg[\n31:         [\"Player\", \"Year\", \"PTS\", \"AST\", \"TRB\", \"FG%\"]\n32:     ]  # Keep only specified columns\n33:     df_reg = df_reg.dropna(\n34:         subset=[\"PTS\", \"AST\", \"TRB\", \"FG%\"]\n35:     )  # Ensure key stats aren't invalid\n36:     return df_reg",
            "mapping": [
                {
                    "summaryComponent": "Fetches NBA per-game stats for a given year",
                    "codeSegments": [
                        {
                            "code": "def scrape_season_stats(year):",
                            "line": 22
                        },
                        {
                            "code": "base_url_reg = (",
                            "line": 23
                        },
                        {
                            "code": "f\"https://www.basketball-reference.com/leagues/NBA_{year}_per_game.html\"",
                            "line": 24
                        },
                        {
                            "code": "df_reg = pd.read_html(base_url_reg, header=0)[0]",
                            "line": 26
                        }
                    ]
                },
                {
                    "summaryComponent": "Cleans and filters the data",
                    "codeSegments": [
                        {
                            "code": "df_reg = df_reg[df_reg[\"Player\"] != \"Player\"]  # remove repeated header rows",
                            "line": 27
                        },
                        {
                            "code": "df_reg = df_reg[",
                            "line": 30
                        },
                        {
                            "code": "[\"Player\", \"Year\", \"PTS\", \"AST\", \"TRB\", \"FG%\"]",
                            "line": 31
                        },
                        {
                            "code": "df_reg = df_reg.dropna(",
                            "line": 33
                        },
                        {
                            "code": "subset=[\"PTS\", \"AST\", \"TRB\", \"FG%\"]",
                            "line": 34
                        }
                    ]
                },
                {
                    "summaryComponent": "Returns selected player statistics",
                    "codeSegments": [
                        {
                            "code": "return df_reg",
                            "line": 36
                        }
                    ]
                }
            ]
        },
        "id": "SsQEGbn0oU6keUa9mXNF"
    },
    {
        "source": "backend",
        "event": "map_summary_code",
        "timestamp": "2025-08-24 11:47:08.000",
        "data": {
            "summary": "The function scrape_season_stats downloads NBA per-game statistics for a specified year from Basketball Reference. It cleans the data by removing repeated header rows and keeps only relevant columns such as player name, year, points, assists, rebounds, and field goal percentage. The function also ensures that rows with missing key stats are excluded before returning the processed DataFrame.",
            "code": "22: def scrape_season_stats(year):\n23:     base_url_reg = (\n24:         f\"https://www.basketball-reference.com/leagues/NBA_{year}_per_game.html\"\n25:     )\n26:     df_reg = pd.read_html(base_url_reg, header=0)[0]\n27:     df_reg = df_reg[df_reg[\"Player\"] != \"Player\"]  # remove repeated header rows\n28:     df_reg[\"Year\"] = year\n29: \n30:     df_reg = df_reg[\n31:         [\"Player\", \"Year\", \"PTS\", \"AST\", \"TRB\", \"FG%\"]\n32:     ]  # Keep only specified columns\n33:     df_reg = df_reg.dropna(\n34:         subset=[\"PTS\", \"AST\", \"TRB\", \"FG%\"]\n35:     )  # Ensure key stats aren't invalid\n36:     return df_reg",
            "mapping": [
                {
                    "summaryComponent": "The function scrape_season_stats",
                    "codeSegments": [
                        {
                            "code": "def scrape_season_stats(year):",
                            "line": 22
                        }
                    ]
                },
                {
                    "summaryComponent": "downloads NBA per-game statistics for a specified year from Basketball Reference",
                    "codeSegments": [
                        {
                            "code": "base_url_reg = (",
                            "line": 23
                        },
                        {
                            "code": "f\"https://www.basketball-reference.com/leagues/NBA_{year}_per_game.html\"",
                            "line": 24
                        },
                        {
                            "code": "df_reg = pd.read_html(base_url_reg, header=0)[0]",
                            "line": 26
                        }
                    ]
                },
                {
                    "summaryComponent": "It cleans the data by removing repeated header rows",
                    "codeSegments": [
                        {
                            "code": "df_reg = df_reg[df_reg[\"Player\"] != \"Player\"]  # remove repeated header rows",
                            "line": 27
                        }
                    ]
                },
                {
                    "summaryComponent": "keeps only relevant columns such as player name, year, points, assists, rebounds, and field goal percentage",
                    "codeSegments": [
                        {
                            "code": "df_reg = df_reg[",
                            "line": 30
                        },
                        {
                            "code": "[\"Player\", \"Year\", \"PTS\", \"AST\", \"TRB\", \"FG%\"]",
                            "line": 31
                        }
                    ]
                },
                {
                    "summaryComponent": "The function also ensures that rows with missing key stats are excluded",
                    "codeSegments": [
                        {
                            "code": "df_reg = df_reg.dropna(",
                            "line": 33
                        },
                        {
                            "code": "subset=[\"PTS\", \"AST\", \"TRB\", \"FG%\"]",
                            "line": 34
                        }
                    ]
                },
                {
                    "summaryComponent": "before returning the processed DataFrame",
                    "codeSegments": [
                        {
                            "code": "return df_reg",
                            "line": 36
                        }
                    ]
                }
            ]
        },
        "id": "tMrDWMihIaJnBC98ehqQ"
    },
    {
        "source": "backend",
        "event": "map_summary_code",
        "timestamp": "2025-08-24 11:47:09.000",
        "data": {
            "summary": "The scrape_season_stats function takes a year as input and constructs the URL for that season's NBA per-game statistics page on Basketball Reference. It reads the HTML table into a DataFrame, removes any rows where the 'Player' column contains the header string (to eliminate repeated headers), and adds a 'Year' column. The function then filters the DataFrame to retain only the columns for player name, year, points, assists, rebounds, and field goal percentage. Finally, it drops any rows with missing values in these key statistics and returns the cleaned DataFrame for further analysis.",
            "code": "22: def scrape_season_stats(year):\n23:     base_url_reg = (\n24:         f\"https://www.basketball-reference.com/leagues/NBA_{year}_per_game.html\"\n25:     )\n26:     df_reg = pd.read_html(base_url_reg, header=0)[0]\n27:     df_reg = df_reg[df_reg[\"Player\"] != \"Player\"]  # remove repeated header rows\n28:     df_reg[\"Year\"] = year\n29: \n30:     df_reg = df_reg[\n31:         [\"Player\", \"Year\", \"PTS\", \"AST\", \"TRB\", \"FG%\"]\n32:     ]  # Keep only specified columns\n33:     df_reg = df_reg.dropna(\n34:         subset=[\"PTS\", \"AST\", \"TRB\", \"FG%\"]\n35:     )  # Ensure key stats aren't invalid\n36:     return df_reg",
            "mapping": [
                {
                    "summaryComponent": "scrape_season_stats function takes a year as input",
                    "codeSegments": [
                        {
                            "code": "def scrape_season_stats(year):",
                            "line": 22
                        }
                    ]
                },
                {
                    "summaryComponent": "constructs the URL for that season's NBA per-game statistics page on Basketball Reference",
                    "codeSegments": [
                        {
                            "code": "base_url_reg = (",
                            "line": 23
                        },
                        {
                            "code": "    f\"https://www.basketball-reference.com/leagues/NBA_{year}_per_game.html\"",
                            "line": 24
                        },
                        {
                            "code": ")",
                            "line": 25
                        }
                    ]
                },
                {
                    "summaryComponent": "reads the HTML table into a DataFrame",
                    "codeSegments": [
                        {
                            "code": "df_reg = pd.read_html(base_url_reg, header=0)[0]",
                            "line": 26
                        }
                    ]
                },
                {
                    "summaryComponent": "removes any rows where the 'Player' column contains the header string (to eliminate repeated headers)",
                    "codeSegments": [
                        {
                            "code": "df_reg = df_reg[df_reg[\"Player\"] != \"Player\"]  # remove repeated header rows",
                            "line": 27
                        }
                    ]
                },
                {
                    "summaryComponent": "adds a 'Year' column",
                    "codeSegments": [
                        {
                            "code": "df_reg[\"Year\"] = year",
                            "line": 28
                        }
                    ]
                },
                {
                    "summaryComponent": "filters the DataFrame to retain only the columns for player name, year, points, assists, rebounds, and field goal percentage",
                    "codeSegments": [
                        {
                            "code": "df_reg = df_reg[",
                            "line": 30
                        },
                        {
                            "code": "    [\"Player\", \"Year\", \"PTS\", \"AST\", \"TRB\", \"FG%\"]",
                            "line": 31
                        },
                        {
                            "code": "]  # Keep only specified columns",
                            "line": 32
                        }
                    ]
                },
                {
                    "summaryComponent": "drops any rows with missing values in these key statistics",
                    "codeSegments": [
                        {
                            "code": "df_reg = df_reg.dropna(",
                            "line": 33
                        },
                        {
                            "code": "    subset=[\"PTS\", \"AST\", \"TRB\", \"FG%\"]",
                            "line": 34
                        },
                        {
                            "code": ")  # Ensure key stats aren't invalid",
                            "line": 35
                        }
                    ]
                },
                {
                    "summaryComponent": "returns the cleaned DataFrame for further analysis",
                    "codeSegments": [
                        {
                            "code": "return df_reg",
                            "line": 36
                        }
                    ]
                }
            ]
        },
        "id": "2cazdEIQ37m3aC5sUCWC"
    },
    {
        "source": "backend",
        "event": "map_summary_code",
        "timestamp": "2025-08-24 11:47:09.000",
        "data": {
            "summary": "This function retrieves and processes NBA player per-game statistics for a given year from Basketball Reference.",
            "code": "22: def scrape_season_stats(year):\n23:     base_url_reg = (\n24:         f\"https://www.basketball-reference.com/leagues/NBA_{year}_per_game.html\"\n25:     )\n26:     df_reg = pd.read_html(base_url_reg, header=0)[0]\n27:     df_reg = df_reg[df_reg[\"Player\"] != \"Player\"]  # remove repeated header rows\n28:     df_reg[\"Year\"] = year\n29: \n30:     df_reg = df_reg[\n31:         [\"Player\", \"Year\", \"PTS\", \"AST\", \"TRB\", \"FG%\"]\n32:     ]  # Keep only specified columns\n33:     df_reg = df_reg.dropna(\n34:         subset=[\"PTS\", \"AST\", \"TRB\", \"FG%\"]\n35:     )  # Ensure key stats aren't invalid\n36:     return df_reg",
            "mapping": [
                {
                    "summaryComponent": "retrieves",
                    "codeSegments": [
                        {
                            "code": "df_reg = pd.read_html(base_url_reg, header=0)[0]",
                            "line": 26
                        }
                    ]
                },
                {
                    "summaryComponent": "processes",
                    "codeSegments": [
                        {
                            "code": "df_reg = df_reg[df_reg[\"Player\"] != \"Player\"]  # remove repeated header rows",
                            "line": 27
                        },
                        {
                            "code": "df_reg[\"Year\"] = year",
                            "line": 28
                        },
                        {
                            "code": "df_reg = df_reg[\n    [\"Player\", \"Year\", \"PTS\", \"AST\", \"TRB\", \"FG%\"]\n]",
                            "line": 30
                        },
                        {
                            "code": "df_reg = df_reg.dropna(\n    subset=[\"PTS\", \"AST\", \"TRB\", \"FG%\"]\n)",
                            "line": 33
                        }
                    ]
                },
                {
                    "summaryComponent": "NBA player per-game statistics",
                    "codeSegments": [
                        {
                            "code": "f\"https://www.basketball-reference.com/leagues/NBA_{year}_per_game.html\"",
                            "line": 24
                        },
                        {
                            "code": "df_reg = pd.read_html(base_url_reg, header=0)[0]",
                            "line": 26
                        },
                        {
                            "code": "df_reg = df_reg[\n    [\"Player\", \"Year\", \"PTS\", \"AST\", \"TRB\", \"FG%\"]\n]",
                            "line": 30
                        }
                    ]
                },
                {
                    "summaryComponent": "for a given year",
                    "codeSegments": [
                        {
                            "code": "def scrape_season_stats(year):",
                            "line": 22
                        },
                        {
                            "code": "f\"https://www.basketball-reference.com/leagues/NBA_{year}_per_game.html\"",
                            "line": 24
                        },
                        {
                            "code": "df_reg[\"Year\"] = year",
                            "line": 28
                        }
                    ]
                },
                {
                    "summaryComponent": "from Basketball Reference",
                    "codeSegments": [
                        {
                            "code": "f\"https://www.basketball-reference.com/leagues/NBA_{year}_per_game.html\"",
                            "line": 24
                        }
                    ]
                }
            ]
        },
        "id": "ZZh3QUrucTbIWflTQ24D"
    },
    {
        "source": "frontend",
        "event": "create_new_section",
        "timestamp": "2025-08-24 11:47:10.000",
        "data": {
            "section_data": {
                "selectedDetailLevel": "medium",
                "createdAt": 1756064830000,
                "metadata": {
                    "originalCode": "def scrape_season_stats(year):\n    base_url_reg = (\n        f\"https://www.basketball-reference.com/leagues/NBA_{year}_per_game.html\"\n    )\n    df_reg = pd.read_html(base_url_reg, header=0)[0]\n    df_reg = df_reg[df_reg[\"Player\"] != \"Player\"]  # remove repeated header rows\n    df_reg[\"Year\"] = year\n\n    df_reg = df_reg[\n        [\"Player\", \"Year\", \"PTS\", \"AST\", \"TRB\", \"FG%\"]\n    ]  # Keep only specified columns\n    df_reg = df_reg.dropna(\n        subset=[\"PTS\", \"AST\", \"TRB\", \"FG%\"]\n    )  # Ensure key stats aren't invalid\n    return df_reg",
                    "id": "f9c48e11-77ac-4181-9eab-5bf14b4f8670",
                    "filename": "scraper.py",
                    "fullPath": "/project/workspace/scraper.py",
                    "offset": 652
                },
                "summaryData": {
                    "medium_structured": "• Downloads per-game NBA stats for a specified year from Basketball Reference\n• Cleans the data:\n  ◦ Removes repeated header rows\n  ◦ Adds the year as a column\n• Filters to keep only Player, Year, PTS, AST, TRB, and FG% columns\n• Drops rows with missing values in key stats\n• Returns the cleaned DataFrame",
                    "low_unstructured": "This function retrieves and processes NBA player per-game statistics for a given year from Basketball Reference.",
                    "high_structured": "• Constructs the URL for the NBA per-game stats page for the specified year\n• Reads the first HTML table from the page into a DataFrame\n• Cleans the DataFrame:\n  ◦ Removes rows where the 'Player' column equals 'Player' (eliminating repeated headers)\n  ◦ Adds a 'Year' column to indicate the season\n• Filters the DataFrame to keep only the following columns:\n  ◦ Player, Year, PTS, AST, TRB, FG%\n• Drops rows with missing values in any of the key stat columns (PTS, AST, TRB, FG%)\n• Returns the processed DataFrame containing clean, relevant player statistics for the given year",
                    "low_structured": "• Fetches NBA per-game stats for a given year\n• Cleans and filters the data\n• Returns selected player statistics",
                    "high_unstructured": "The scrape_season_stats function takes a year as input and constructs the URL for that season's NBA per-game statistics page on Basketball Reference. It reads the HTML table into a DataFrame, removes any rows where the 'Player' column contains the header string (to eliminate repeated headers), and adds a 'Year' column. The function then filters the DataFrame to retain only the columns for player name, year, points, assists, rebounds, and field goal percentage. Finally, it drops any rows with missing values in these key statistics and returns the cleaned DataFrame for further analysis.",
                    "medium_unstructured": "The function scrape_season_stats downloads NBA per-game statistics for a specified year from Basketball Reference. It cleans the data by removing repeated header rows and keeps only relevant columns such as player name, year, points, assists, rebounds, and field goal percentage. The function also ensures that rows with missing key stats are excluded before returning the processed DataFrame.",
                    "title": "Summary of scrape_season_stats(year) Function"
                },
                "selectedStructured": "unstructured",
                "summaryMappings": {
                    "medium_structured": [
                        {
                            "summaryComponent": "Downloads per-game NBA stats for a specified year from Basketball Reference",
                            "codeSegments": [
                                {
                                    "code": "base_url_reg = (\n    f\"https://www.basketball-reference.com/leagues/NBA_{year}_per_game.html\"\n)",
                                    "line": 23
                                },
                                {
                                    "code": "df_reg = pd.read_html(base_url_reg, header=0)[0]",
                                    "line": 26
                                }
                            ]
                        },
                        {
                            "summaryComponent": "Cleans the data:",
                            "codeSegments": []
                        },
                        {
                            "summaryComponent": "Removes repeated header rows",
                            "codeSegments": [
                                {
                                    "code": "df_reg = df_reg[df_reg[\"Player\"] != \"Player\"]  # remove repeated header rows",
                                    "line": 27
                                }
                            ]
                        },
                        {
                            "summaryComponent": "Adds the year as a column",
                            "codeSegments": [
                                {
                                    "code": "df_reg[\"Year\"] = year",
                                    "line": 28
                                }
                            ]
                        },
                        {
                            "summaryComponent": "Filters to keep only Player, Year, PTS, AST, TRB, and FG% columns",
                            "codeSegments": [
                                {
                                    "code": "df_reg = df_reg[\n    [\"Player\", \"Year\", \"PTS\", \"AST\", \"TRB\", \"FG%\"]\n]",
                                    "line": 30
                                }
                            ]
                        },
                        {
                            "summaryComponent": "Drops rows with missing values in key stats",
                            "codeSegments": [
                                {
                                    "code": "df_reg = df_reg.dropna(\n    subset=[\"PTS\", \"AST\", \"TRB\", \"FG%\"]\n)",
                                    "line": 33
                                }
                            ]
                        },
                        {
                            "summaryComponent": "Returns the cleaned DataFrame",
                            "codeSegments": [
                                {
                                    "code": "return df_reg",
                                    "line": 36
                                }
                            ]
                        }
                    ],
                    "high_structured": [
                        {
                            "summaryComponent": "Constructs the URL for the NBA per-game stats page for the specified year",
                            "codeSegments": [
                                {
                                    "code": "base_url_reg = (\n    f\"https://www.basketball-reference.com/leagues/NBA_{year}_per_game.html\"\n)",
                                    "line": 23
                                },
                                {
                                    "code": "f\"https://www.basketball-reference.com/leagues/NBA_{year}_per_game.html\"",
                                    "line": 24
                                }
                            ]
                        },
                        {
                            "summaryComponent": "Reads the first HTML table from the page into a DataFrame",
                            "codeSegments": [
                                {
                                    "code": "df_reg = pd.read_html(base_url_reg, header=0)[0]",
                                    "line": 26
                                }
                            ]
                        },
                        {
                            "summaryComponent": "Cleans the DataFrame:",
                            "codeSegments": []
                        },
                        {
                            "summaryComponent": "Removes rows where the 'Player' column equals 'Player' (eliminating repeated headers)",
                            "codeSegments": [
                                {
                                    "code": "df_reg = df_reg[df_reg[\"Player\"] != \"Player\"]  # remove repeated header rows",
                                    "line": 27
                                }
                            ]
                        },
                        {
                            "summaryComponent": "Adds a 'Year' column to indicate the season",
                            "codeSegments": [
                                {
                                    "code": "df_reg[\"Year\"] = year",
                                    "line": 28
                                }
                            ]
                        },
                        {
                            "summaryComponent": "Filters the DataFrame to keep only the following columns:",
                            "codeSegments": [
                                {
                                    "code": "df_reg = df_reg[\n    [\"Player\", \"Year\", \"PTS\", \"AST\", \"TRB\", \"FG%\"]\n]",
                                    "line": 30
                                }
                            ]
                        },
                        {
                            "summaryComponent": "Player, Year, PTS, AST, TRB, FG%",
                            "codeSegments": [
                                {
                                    "code": "[\"Player\", \"Year\", \"PTS\", \"AST\", \"TRB\", \"FG%\"]",
                                    "line": 31
                                }
                            ]
                        },
                        {
                            "summaryComponent": "Drops rows with missing values in any of the key stat columns (PTS, AST, TRB, FG%)",
                            "codeSegments": [
                                {
                                    "code": "df_reg = df_reg.dropna(\n    subset=[\"PTS\", \"AST\", \"TRB\", \"FG%\"]\n)",
                                    "line": 33
                                }
                            ]
                        },
                        {
                            "summaryComponent": "Returns the processed DataFrame containing clean, relevant player statistics for the given year",
                            "codeSegments": [
                                {
                                    "code": "return df_reg",
                                    "line": 36
                                }
                            ]
                        }
                    ],
                    "low_structured": [
                        {
                            "summaryComponent": "Fetches NBA per-game stats for a given year",
                            "codeSegments": [
                                {
                                    "code": "def scrape_season_stats(year):",
                                    "line": 22
                                },
                                {
                                    "code": "base_url_reg = (",
                                    "line": 23
                                },
                                {
                                    "code": "f\"https://www.basketball-reference.com/leagues/NBA_{year}_per_game.html\"",
                                    "line": 24
                                },
                                {
                                    "code": "df_reg = pd.read_html(base_url_reg, header=0)[0]",
                                    "line": 26
                                }
                            ]
                        },
                        {
                            "summaryComponent": "Cleans and filters the data",
                            "codeSegments": [
                                {
                                    "code": "df_reg = df_reg[df_reg[\"Player\"] != \"Player\"]  # remove repeated header rows",
                                    "line": 27
                                },
                                {
                                    "code": "df_reg = df_reg[",
                                    "line": 30
                                },
                                {
                                    "code": "[\"Player\", \"Year\", \"PTS\", \"AST\", \"TRB\", \"FG%\"]",
                                    "line": 31
                                },
                                {
                                    "code": "df_reg = df_reg.dropna(",
                                    "line": 33
                                },
                                {
                                    "code": "subset=[\"PTS\", \"AST\", \"TRB\", \"FG%\"]",
                                    "line": 34
                                }
                            ]
                        },
                        {
                            "summaryComponent": "Returns selected player statistics",
                            "codeSegments": [
                                {
                                    "code": "return df_reg",
                                    "line": 36
                                }
                            ]
                        }
                    ],
                    "high_unstructured": [
                        {
                            "summaryComponent": "scrape_season_stats function takes a year as input",
                            "codeSegments": [
                                {
                                    "code": "def scrape_season_stats(year):",
                                    "line": 22
                                }
                            ]
                        },
                        {
                            "summaryComponent": "constructs the URL for that season's NBA per-game statistics page on Basketball Reference",
                            "codeSegments": [
                                {
                                    "code": "base_url_reg = (",
                                    "line": 23
                                },
                                {
                                    "code": "    f\"https://www.basketball-reference.com/leagues/NBA_{year}_per_game.html\"",
                                    "line": 24
                                },
                                {
                                    "code": ")",
                                    "line": 25
                                }
                            ]
                        },
                        {
                            "summaryComponent": "reads the HTML table into a DataFrame",
                            "codeSegments": [
                                {
                                    "code": "df_reg = pd.read_html(base_url_reg, header=0)[0]",
                                    "line": 26
                                }
                            ]
                        },
                        {
                            "summaryComponent": "removes any rows where the 'Player' column contains the header string (to eliminate repeated headers)",
                            "codeSegments": [
                                {
                                    "code": "df_reg = df_reg[df_reg[\"Player\"] != \"Player\"]  # remove repeated header rows",
                                    "line": 27
                                }
                            ]
                        },
                        {
                            "summaryComponent": "adds a 'Year' column",
                            "codeSegments": [
                                {
                                    "code": "df_reg[\"Year\"] = year",
                                    "line": 28
                                }
                            ]
                        },
                        {
                            "summaryComponent": "filters the DataFrame to retain only the columns for player name, year, points, assists, rebounds, and field goal percentage",
                            "codeSegments": [
                                {
                                    "code": "df_reg = df_reg[",
                                    "line": 30
                                },
                                {
                                    "code": "    [\"Player\", \"Year\", \"PTS\", \"AST\", \"TRB\", \"FG%\"]",
                                    "line": 31
                                },
                                {
                                    "code": "]  # Keep only specified columns",
                                    "line": 32
                                }
                            ]
                        },
                        {
                            "summaryComponent": "drops any rows with missing values in these key statistics",
                            "codeSegments": [
                                {
                                    "code": "df_reg = df_reg.dropna(",
                                    "line": 33
                                },
                                {
                                    "code": "    subset=[\"PTS\", \"AST\", \"TRB\", \"FG%\"]",
                                    "line": 34
                                },
                                {
                                    "code": ")  # Ensure key stats aren't invalid",
                                    "line": 35
                                }
                            ]
                        },
                        {
                            "summaryComponent": "returns the cleaned DataFrame for further analysis",
                            "codeSegments": [
                                {
                                    "code": "return df_reg",
                                    "line": 36
                                }
                            ]
                        }
                    ],
                    "medium_unstructured": [
                        {
                            "summaryComponent": "The function scrape_season_stats",
                            "codeSegments": [
                                {
                                    "code": "def scrape_season_stats(year):",
                                    "line": 22
                                }
                            ]
                        },
                        {
                            "summaryComponent": "downloads NBA per-game statistics for a specified year from Basketball Reference",
                            "codeSegments": [
                                {
                                    "code": "base_url_reg = (",
                                    "line": 23
                                },
                                {
                                    "code": "f\"https://www.basketball-reference.com/leagues/NBA_{year}_per_game.html\"",
                                    "line": 24
                                },
                                {
                                    "code": "df_reg = pd.read_html(base_url_reg, header=0)[0]",
                                    "line": 26
                                }
                            ]
                        },
                        {
                            "summaryComponent": "It cleans the data by removing repeated header rows",
                            "codeSegments": [
                                {
                                    "code": "df_reg = df_reg[df_reg[\"Player\"] != \"Player\"]  # remove repeated header rows",
                                    "line": 27
                                }
                            ]
                        },
                        {
                            "summaryComponent": "keeps only relevant columns such as player name, year, points, assists, rebounds, and field goal percentage",
                            "codeSegments": [
                                {
                                    "code": "df_reg = df_reg[",
                                    "line": 30
                                },
                                {
                                    "code": "[\"Player\", \"Year\", \"PTS\", \"AST\", \"TRB\", \"FG%\"]",
                                    "line": 31
                                }
                            ]
                        },
                        {
                            "summaryComponent": "The function also ensures that rows with missing key stats are excluded",
                            "codeSegments": [
                                {
                                    "code": "df_reg = df_reg.dropna(",
                                    "line": 33
                                },
                                {
                                    "code": "subset=[\"PTS\", \"AST\", \"TRB\", \"FG%\"]",
                                    "line": 34
                                }
                            ]
                        },
                        {
                            "summaryComponent": "before returning the processed DataFrame",
                            "codeSegments": [
                                {
                                    "code": "return df_reg",
                                    "line": 36
                                }
                            ]
                        }
                    ],
                    "low_unstructured": [
                        {
                            "summaryComponent": "retrieves",
                            "codeSegments": [
                                {
                                    "code": "df_reg = pd.read_html(base_url_reg, header=0)[0]",
                                    "line": 26
                                }
                            ]
                        },
                        {
                            "summaryComponent": "processes",
                            "codeSegments": [
                                {
                                    "code": "df_reg = df_reg[df_reg[\"Player\"] != \"Player\"]  # remove repeated header rows",
                                    "line": 27
                                },
                                {
                                    "code": "df_reg[\"Year\"] = year",
                                    "line": 28
                                },
                                {
                                    "code": "df_reg = df_reg[\n    [\"Player\", \"Year\", \"PTS\", \"AST\", \"TRB\", \"FG%\"]\n]",
                                    "line": 30
                                },
                                {
                                    "code": "df_reg = df_reg.dropna(\n    subset=[\"PTS\", \"AST\", \"TRB\", \"FG%\"]\n)",
                                    "line": 33
                                }
                            ]
                        },
                        {
                            "summaryComponent": "NBA player per-game statistics",
                            "codeSegments": [
                                {
                                    "code": "f\"https://www.basketball-reference.com/leagues/NBA_{year}_per_game.html\"",
                                    "line": 24
                                },
                                {
                                    "code": "df_reg = pd.read_html(base_url_reg, header=0)[0]",
                                    "line": 26
                                },
                                {
                                    "code": "df_reg = df_reg[\n    [\"Player\", \"Year\", \"PTS\", \"AST\", \"TRB\", \"FG%\"]\n]",
                                    "line": 30
                                }
                            ]
                        },
                        {
                            "summaryComponent": "for a given year",
                            "codeSegments": [
                                {
                                    "code": "def scrape_season_stats(year):",
                                    "line": 22
                                },
                                {
                                    "code": "f\"https://www.basketball-reference.com/leagues/NBA_{year}_per_game.html\"",
                                    "line": 24
                                },
                                {
                                    "code": "df_reg[\"Year\"] = year",
                                    "line": 28
                                }
                            ]
                        },
                        {
                            "summaryComponent": "from Basketball Reference",
                            "codeSegments": [
                                {
                                    "code": "f\"https://www.basketball-reference.com/leagues/NBA_{year}_per_game.html\"",
                                    "line": 24
                                }
                            ]
                        }
                    ]
                },
                "editPromptValue": "",
                "editPromptDetailLevel": null,
                "editPromptStructured": null,
                "lines": [
                    22,
                    36
                ],
                "title": "Summary of scrape_season_stats(year) Function"
            },
            "section_id": "f9c48e11-77ac-4181-9eab-5bf14b4f8670"
        },
        "id": "FyibDx58OS3BpcCQIgEX"
    },
    {
        "source": "backend",
        "event": "map_summary_code",
        "timestamp": "2025-08-24 11:47:10.000",
        "data": {
            "summary": "• Constructs the URL for the NBA per-game stats page for the specified year\n• Reads the first HTML table from the page into a DataFrame\n• Cleans the DataFrame:\n  ◦ Removes rows where the 'Player' column equals 'Player' (eliminating repeated headers)\n  ◦ Adds a 'Year' column to indicate the season\n• Filters the DataFrame to keep only the following columns:\n  ◦ Player, Year, PTS, AST, TRB, FG%\n• Drops rows with missing values in any of the key stat columns (PTS, AST, TRB, FG%)\n• Returns the processed DataFrame containing clean, relevant player statistics for the given year",
            "code": "22: def scrape_season_stats(year):\n23:     base_url_reg = (\n24:         f\"https://www.basketball-reference.com/leagues/NBA_{year}_per_game.html\"\n25:     )\n26:     df_reg = pd.read_html(base_url_reg, header=0)[0]\n27:     df_reg = df_reg[df_reg[\"Player\"] != \"Player\"]  # remove repeated header rows\n28:     df_reg[\"Year\"] = year\n29: \n30:     df_reg = df_reg[\n31:         [\"Player\", \"Year\", \"PTS\", \"AST\", \"TRB\", \"FG%\"]\n32:     ]  # Keep only specified columns\n33:     df_reg = df_reg.dropna(\n34:         subset=[\"PTS\", \"AST\", \"TRB\", \"FG%\"]\n35:     )  # Ensure key stats aren't invalid\n36:     return df_reg",
            "mapping": [
                {
                    "summaryComponent": "Constructs the URL for the NBA per-game stats page for the specified year",
                    "codeSegments": [
                        {
                            "code": "base_url_reg = (\n    f\"https://www.basketball-reference.com/leagues/NBA_{year}_per_game.html\"\n)",
                            "line": 23
                        },
                        {
                            "code": "f\"https://www.basketball-reference.com/leagues/NBA_{year}_per_game.html\"",
                            "line": 24
                        }
                    ]
                },
                {
                    "summaryComponent": "Reads the first HTML table from the page into a DataFrame",
                    "codeSegments": [
                        {
                            "code": "df_reg = pd.read_html(base_url_reg, header=0)[0]",
                            "line": 26
                        }
                    ]
                },
                {
                    "summaryComponent": "Cleans the DataFrame:",
                    "codeSegments": []
                },
                {
                    "summaryComponent": "Removes rows where the 'Player' column equals 'Player' (eliminating repeated headers)",
                    "codeSegments": [
                        {
                            "code": "df_reg = df_reg[df_reg[\"Player\"] != \"Player\"]  # remove repeated header rows",
                            "line": 27
                        }
                    ]
                },
                {
                    "summaryComponent": "Adds a 'Year' column to indicate the season",
                    "codeSegments": [
                        {
                            "code": "df_reg[\"Year\"] = year",
                            "line": 28
                        }
                    ]
                },
                {
                    "summaryComponent": "Filters the DataFrame to keep only the following columns:",
                    "codeSegments": [
                        {
                            "code": "df_reg = df_reg[\n    [\"Player\", \"Year\", \"PTS\", \"AST\", \"TRB\", \"FG%\"]\n]",
                            "line": 30
                        }
                    ]
                },
                {
                    "summaryComponent": "Player, Year, PTS, AST, TRB, FG%",
                    "codeSegments": [
                        {
                            "code": "[\"Player\", \"Year\", \"PTS\", \"AST\", \"TRB\", \"FG%\"]",
                            "line": 31
                        }
                    ]
                },
                {
                    "summaryComponent": "Drops rows with missing values in any of the key stat columns (PTS, AST, TRB, FG%)",
                    "codeSegments": [
                        {
                            "code": "df_reg = df_reg.dropna(\n    subset=[\"PTS\", \"AST\", \"TRB\", \"FG%\"]\n)",
                            "line": 33
                        }
                    ]
                },
                {
                    "summaryComponent": "Returns the processed DataFrame containing clean, relevant player statistics for the given year",
                    "codeSegments": [
                        {
                            "code": "return df_reg",
                            "line": 36
                        }
                    ]
                }
            ]
        },
        "id": "J1at43wNivGl8Pur8fcU"
    },
    {
        "source": "frontend",
        "event": "autotransit_section",
        "timestamp": "2025-08-24 11:47:10.000",
        "data": {
            "before_section_id": "04ba9f41-f7cf-417a-ab4a-747376f4a2f9",
            "after_section_id": "f9c48e11-77ac-4181-9eab-5bf14b4f8670"
        },
        "id": "pKb2dAe0y4wOSrox6JDk"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "timestamp": "2025-08-24 11:47:11.000",
        "data": {
            "structured_type": "unstructured",
            "detail_level": "medium",
            "mapping_index": 2,
            "section_id": "f9c48e11-77ac-4181-9eab-5bf14b4f8670"
        },
        "id": "Bu27gYopWd8t3s2mlqGp"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "timestamp": "2025-08-24 11:47:11.000",
        "data": {
            "structured_type": "unstructured",
            "detail_level": "medium",
            "section_id": "f9c48e11-77ac-4181-9eab-5bf14b4f8670"
        },
        "id": "C23aNijjT82oU3IQ0W8d"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "timestamp": "2025-08-24 11:47:11.000",
        "data": {
            "structured_type": "unstructured",
            "detail_level": "medium",
            "section_id": "f9c48e11-77ac-4181-9eab-5bf14b4f8670"
        },
        "id": "H9E2RPvHjZcldYGym71g"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "timestamp": "2025-08-24 11:47:11.000",
        "data": {
            "structured_type": "unstructured",
            "detail_level": "medium",
            "mapping_index": 1,
            "section_id": "f9c48e11-77ac-4181-9eab-5bf14b4f8670"
        },
        "id": "Ivtf76UpQm0nlq1pe1yF"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "timestamp": "2025-08-24 11:47:11.000",
        "data": {
            "structured_type": "unstructured",
            "detail_level": "medium",
            "mapping_index": 3,
            "section_id": "f9c48e11-77ac-4181-9eab-5bf14b4f8670"
        },
        "id": "WAEBzzpzWPltYCC9OWhK"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "timestamp": "2025-08-24 11:47:11.000",
        "data": {
            "structured_type": "unstructured",
            "detail_level": "medium",
            "section_id": "f9c48e11-77ac-4181-9eab-5bf14b4f8670"
        },
        "id": "gdO8Kmp56lCg5tzOOhOW"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "timestamp": "2025-08-24 11:47:12.000",
        "data": {
            "structured_type": "unstructured",
            "detail_level": "medium",
            "section_id": "f9c48e11-77ac-4181-9eab-5bf14b4f8670"
        },
        "id": "7N5uEoVCCFykBE8OPXKD"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "timestamp": "2025-08-24 11:47:12.000",
        "data": {
            "structured_type": "unstructured",
            "detail_level": "medium",
            "mapping_index": 1,
            "section_id": "f9c48e11-77ac-4181-9eab-5bf14b4f8670"
        },
        "id": "gZHPxRP6u2cS6R0NwsCx"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "timestamp": "2025-08-24 11:47:12.000",
        "data": {
            "structured_type": "unstructured",
            "detail_level": "medium",
            "mapping_index": 2,
            "section_id": "f9c48e11-77ac-4181-9eab-5bf14b4f8670"
        },
        "id": "v7OBkCWmCLR0xDfib87f"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "timestamp": "2025-08-24 11:47:13.000",
        "data": {
            "structured_type": "unstructured",
            "detail_level": "medium",
            "mapping_index": 0,
            "section_id": "f9c48e11-77ac-4181-9eab-5bf14b4f8670"
        },
        "id": "9bzREFCEduDcl6DnTGWL"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "timestamp": "2025-08-24 11:47:13.000",
        "data": {
            "structured_type": "unstructured",
            "detail_level": "medium",
            "section_id": "f9c48e11-77ac-4181-9eab-5bf14b4f8670"
        },
        "id": "9ymVnVlkoRScMeRDkY3f"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "timestamp": "2025-08-24 11:47:13.000",
        "data": {
            "structured_type": "unstructured",
            "detail_level": "medium",
            "section_id": "f9c48e11-77ac-4181-9eab-5bf14b4f8670"
        },
        "id": "XBM86SIcNGKr53RKpGxl"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "timestamp": "2025-08-24 11:47:14.000",
        "data": {
            "structured_type": "unstructured",
            "detail_level": "medium",
            "section_id": "f9c48e11-77ac-4181-9eab-5bf14b4f8670"
        },
        "id": "D6784zVeRUvlthErJohG"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "timestamp": "2025-08-24 11:47:14.000",
        "data": {
            "structured_type": "unstructured",
            "detail_level": "medium",
            "mapping_index": 0,
            "section_id": "f9c48e11-77ac-4181-9eab-5bf14b4f8670"
        },
        "id": "NxrGvV74IQpiaBT29uXp"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "timestamp": "2025-08-24 11:47:14.000",
        "data": {
            "structured_type": "unstructured",
            "detail_level": "medium",
            "mapping_index": 1,
            "section_id": "f9c48e11-77ac-4181-9eab-5bf14b4f8670"
        },
        "id": "kHTJojkxYHKYOyQx0E8l"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "timestamp": "2025-08-24 11:47:14.000",
        "data": {
            "structured_type": "unstructured",
            "detail_level": "medium",
            "section_id": "f9c48e11-77ac-4181-9eab-5bf14b4f8670"
        },
        "id": "uY5Dk7dvjNdhiHTyfXXW"
    },
    {
        "source": "frontend",
        "event": "change_summary_level",
        "timestamp": "2025-08-24 11:47:15.000",
        "data": {
            "before_structured": "unstructured",
            "before_detail_level": "medium",
            "after_structured": "unstructured",
            "after_detail_level": "high",
            "section_id": "f9c48e11-77ac-4181-9eab-5bf14b4f8670"
        },
        "id": "DABUZJhCM2tx3vIqcRbV"
    },
    {
        "source": "frontend",
        "event": "change_summary_level",
        "timestamp": "2025-08-24 11:47:16.000",
        "data": {
            "before_structured": "unstructured",
            "before_detail_level": "high",
            "after_structured": "structured",
            "after_detail_level": "high",
            "section_id": "f9c48e11-77ac-4181-9eab-5bf14b4f8670"
        },
        "id": "wkDIIKC5xIgtTu429K3v"
    },
    {
        "source": "frontend",
        "event": "change_summary_level",
        "timestamp": "2025-08-24 11:47:19.000",
        "data": {
            "before_structured": "structured",
            "before_detail_level": "high",
            "after_structured": "structured",
            "after_detail_level": "medium",
            "section_id": "f9c48e11-77ac-4181-9eab-5bf14b4f8670"
        },
        "id": "LZGx3nkyDswtfSmqjUuk"
    },
    {
        "source": "frontend",
        "event": "change_summary_level",
        "timestamp": "2025-08-24 11:47:20.000",
        "data": {
            "before_structured": "structured",
            "before_detail_level": "medium",
            "after_structured": "structured",
            "after_detail_level": "low",
            "section_id": "f9c48e11-77ac-4181-9eab-5bf14b4f8670"
        },
        "id": "sgRSyFgnWxdaZROTKMX2"
    },
    {
        "source": "frontend",
        "event": "change_summary_level",
        "timestamp": "2025-08-24 11:47:21.000",
        "data": {
            "before_structured": "structured",
            "before_detail_level": "low",
            "after_structured": "structured",
            "after_detail_level": "medium",
            "section_id": "f9c48e11-77ac-4181-9eab-5bf14b4f8670"
        },
        "id": "PICilkxEQ83enLEhAiap"
    },
    {
        "source": "frontend",
        "event": "change_summary_level",
        "timestamp": "2025-08-24 11:47:26.000",
        "data": {
            "before_structured": "structured",
            "before_detail_level": "medium",
            "after_structured": "structured",
            "after_detail_level": "high",
            "section_id": "f9c48e11-77ac-4181-9eab-5bf14b4f8670"
        },
        "id": "dwlDLMELWTDVf4PYeE6m"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "timestamp": "2025-08-24 11:47:27.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "high",
            "mapping_index": 0,
            "section_id": "f9c48e11-77ac-4181-9eab-5bf14b4f8670"
        },
        "id": "TTm5X4Ozj1xl3yltva0d"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "timestamp": "2025-08-24 11:47:27.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "high",
            "mapping_index": 1,
            "section_id": "f9c48e11-77ac-4181-9eab-5bf14b4f8670"
        },
        "id": "c83NpA8d6L5Dac4p2bo9"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "timestamp": "2025-08-24 11:47:27.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "high",
            "section_id": "f9c48e11-77ac-4181-9eab-5bf14b4f8670"
        },
        "id": "rqcJb5mlTWDT6wtIseaA"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "timestamp": "2025-08-24 11:47:28.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "high",
            "mapping_index": 0,
            "section_id": "f9c48e11-77ac-4181-9eab-5bf14b4f8670"
        },
        "id": "Dq1pKAlWrr3nbVwAAvWn"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "timestamp": "2025-08-24 11:47:28.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "high",
            "section_id": "f9c48e11-77ac-4181-9eab-5bf14b4f8670"
        },
        "id": "ZrDFxTaO8ZAni3edT20J"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "timestamp": "2025-08-24 11:47:29.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "high",
            "mapping_index": 1,
            "section_id": "f9c48e11-77ac-4181-9eab-5bf14b4f8670"
        },
        "id": "TTvbEpxAnSnK8paa9HyR"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "timestamp": "2025-08-24 11:47:29.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "high",
            "section_id": "f9c48e11-77ac-4181-9eab-5bf14b4f8670"
        },
        "id": "rIe9LAzytn5zcPsFfHiq"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "timestamp": "2025-08-24 11:47:30.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "high",
            "mapping_index": 0,
            "section_id": "f9c48e11-77ac-4181-9eab-5bf14b4f8670"
        },
        "id": "FJJSufaASyAvmMY4HDj3"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "timestamp": "2025-08-24 11:47:30.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "high",
            "section_id": "f9c48e11-77ac-4181-9eab-5bf14b4f8670"
        },
        "id": "OwkJz9w7I9XnSkeA3vyH"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "timestamp": "2025-08-24 11:47:30.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "high",
            "section_id": "f9c48e11-77ac-4181-9eab-5bf14b4f8670"
        },
        "id": "bcDH02ZAKOJpFRbzU9sL"
    },
    {
        "source": "frontend",
        "event": "change_summary_level",
        "timestamp": "2025-08-24 11:47:31.000",
        "data": {
            "before_structured": "structured",
            "before_detail_level": "high",
            "after_structured": "unstructured",
            "after_detail_level": "high",
            "section_id": "f9c48e11-77ac-4181-9eab-5bf14b4f8670"
        },
        "id": "0qpPq56aPoKswInYLxPp"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "timestamp": "2025-08-24 11:47:31.000",
        "data": {
            "structured_type": "unstructured",
            "detail_level": "high",
            "mapping_index": 0,
            "section_id": "f9c48e11-77ac-4181-9eab-5bf14b4f8670"
        },
        "id": "JkBfXJBu4hfEnBJfSBIn"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "timestamp": "2025-08-24 11:47:32.000",
        "data": {
            "structured_type": "unstructured",
            "detail_level": "high",
            "mapping_index": 1,
            "section_id": "f9c48e11-77ac-4181-9eab-5bf14b4f8670"
        },
        "id": "ikKPViffqLxg0CUCzrVK"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "timestamp": "2025-08-24 11:47:32.000",
        "data": {
            "structured_type": "unstructured",
            "detail_level": "high",
            "section_id": "f9c48e11-77ac-4181-9eab-5bf14b4f8670"
        },
        "id": "kMxk0B3uuHx2RZHJgFVc"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "timestamp": "2025-08-24 11:47:35.000",
        "data": {
            "structured_type": "unstructured",
            "detail_level": "high",
            "mapping_index": 1,
            "section_id": "f9c48e11-77ac-4181-9eab-5bf14b4f8670"
        },
        "id": "j4FqwYBj9swFapWUaRgx"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "timestamp": "2025-08-24 11:47:35.000",
        "data": {
            "structured_type": "unstructured",
            "detail_level": "high",
            "section_id": "f9c48e11-77ac-4181-9eab-5bf14b4f8670"
        },
        "id": "tfG1SC9PKwbedbU55CcG"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "timestamp": "2025-08-24 11:47:43.000",
        "data": {
            "structured_type": "unstructured",
            "detail_level": "high",
            "mapping_index": 6,
            "section_id": "f9c48e11-77ac-4181-9eab-5bf14b4f8670"
        },
        "id": "75FavmXzTHMdG8oYu7ws"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "timestamp": "2025-08-24 11:47:43.000",
        "data": {
            "structured_type": "unstructured",
            "detail_level": "high",
            "section_id": "f9c48e11-77ac-4181-9eab-5bf14b4f8670"
        },
        "id": "BZpIGKL4tc6AXxS57IVa"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "timestamp": "2025-08-24 11:47:43.000",
        "data": {
            "structured_type": "unstructured",
            "detail_level": "high",
            "section_id": "f9c48e11-77ac-4181-9eab-5bf14b4f8670"
        },
        "id": "DjRi3WyMRj2nl9S44d79"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "timestamp": "2025-08-24 11:47:43.000",
        "data": {
            "structured_type": "unstructured",
            "detail_level": "high",
            "mapping_index": 5,
            "section_id": "f9c48e11-77ac-4181-9eab-5bf14b4f8670"
        },
        "id": "IBszO6ss5WKN0O5EbavW"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "timestamp": "2025-08-24 11:47:43.000",
        "data": {
            "structured_type": "unstructured",
            "detail_level": "high",
            "mapping_index": 3,
            "section_id": "f9c48e11-77ac-4181-9eab-5bf14b4f8670"
        },
        "id": "ZL3oA4I5WDc8l0Il6ZbX"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "timestamp": "2025-08-24 11:47:43.000",
        "data": {
            "structured_type": "unstructured",
            "detail_level": "high",
            "section_id": "f9c48e11-77ac-4181-9eab-5bf14b4f8670"
        },
        "id": "bQc5rQjw6epokZ8vSh9L"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "timestamp": "2025-08-24 11:47:43.000",
        "data": {
            "structured_type": "unstructured",
            "detail_level": "high",
            "section_id": "f9c48e11-77ac-4181-9eab-5bf14b4f8670"
        },
        "id": "lSYGtXbj2dQSZLiGyrjK"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "timestamp": "2025-08-24 11:47:45.000",
        "data": {
            "structured_type": "unstructured",
            "detail_level": "high",
            "mapping_index": 0,
            "section_id": "f9c48e11-77ac-4181-9eab-5bf14b4f8670"
        },
        "id": "1jb9uN1mwJVLVz02KbRQ"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "timestamp": "2025-08-24 11:47:45.000",
        "data": {
            "structured_type": "unstructured",
            "detail_level": "high",
            "section_id": "f9c48e11-77ac-4181-9eab-5bf14b4f8670"
        },
        "id": "7DYzLIZH5bnxk0RLjmVi"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "timestamp": "2025-08-24 11:47:45.000",
        "data": {
            "structured_type": "unstructured",
            "detail_level": "high",
            "mapping_index": 5,
            "section_id": "f9c48e11-77ac-4181-9eab-5bf14b4f8670"
        },
        "id": "ErnVf2QUC2chrjGyN2s7"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "timestamp": "2025-08-24 11:47:45.000",
        "data": {
            "structured_type": "unstructured",
            "detail_level": "high",
            "mapping_index": 4,
            "section_id": "f9c48e11-77ac-4181-9eab-5bf14b4f8670"
        },
        "id": "F1jphWdrCm1vE1VOGGvP"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "timestamp": "2025-08-24 11:47:45.000",
        "data": {
            "structured_type": "unstructured",
            "detail_level": "high",
            "mapping_index": 3,
            "section_id": "f9c48e11-77ac-4181-9eab-5bf14b4f8670"
        },
        "id": "MLEJaAGmlGAQgjDLcuGo"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "timestamp": "2025-08-24 11:47:45.000",
        "data": {
            "structured_type": "unstructured",
            "detail_level": "high",
            "mapping_index": 5,
            "section_id": "f9c48e11-77ac-4181-9eab-5bf14b4f8670"
        },
        "id": "OtAgVaFcjRQg6sH5nMu3"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "timestamp": "2025-08-24 11:47:45.000",
        "data": {
            "structured_type": "unstructured",
            "detail_level": "high",
            "section_id": "f9c48e11-77ac-4181-9eab-5bf14b4f8670"
        },
        "id": "P34zkz1IVGdkPjRjR8Hq"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "timestamp": "2025-08-24 11:47:45.000",
        "data": {
            "structured_type": "unstructured",
            "detail_level": "high",
            "mapping_index": 3,
            "section_id": "f9c48e11-77ac-4181-9eab-5bf14b4f8670"
        },
        "id": "Qi6ar8W7otJuyQlElSIi"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "timestamp": "2025-08-24 11:47:45.000",
        "data": {
            "structured_type": "unstructured",
            "detail_level": "high",
            "section_id": "f9c48e11-77ac-4181-9eab-5bf14b4f8670"
        },
        "id": "VTncsnwV3EKmnPB7i4rl"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "timestamp": "2025-08-24 11:47:45.000",
        "data": {
            "structured_type": "unstructured",
            "detail_level": "high",
            "section_id": "f9c48e11-77ac-4181-9eab-5bf14b4f8670"
        },
        "id": "bQSRMcamsGlao1omo3oK"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "timestamp": "2025-08-24 11:47:45.000",
        "data": {
            "structured_type": "unstructured",
            "detail_level": "high",
            "section_id": "f9c48e11-77ac-4181-9eab-5bf14b4f8670"
        },
        "id": "gAt1Q8J8hRyOzjBKm7nG"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "timestamp": "2025-08-24 11:47:45.000",
        "data": {
            "structured_type": "unstructured",
            "detail_level": "high",
            "section_id": "f9c48e11-77ac-4181-9eab-5bf14b4f8670"
        },
        "id": "iuYQ9zL2c4vTQmWGfjCi"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "timestamp": "2025-08-24 11:47:45.000",
        "data": {
            "structured_type": "unstructured",
            "detail_level": "high",
            "section_id": "f9c48e11-77ac-4181-9eab-5bf14b4f8670"
        },
        "id": "kF9PCjDwUgXftiFFeAwW"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "timestamp": "2025-08-24 11:47:45.000",
        "data": {
            "structured_type": "unstructured",
            "detail_level": "high",
            "mapping_index": 1,
            "section_id": "f9c48e11-77ac-4181-9eab-5bf14b4f8670"
        },
        "id": "tGMZJXU1A1jWa6jIkPxc"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "timestamp": "2025-08-24 11:47:45.000",
        "data": {
            "structured_type": "unstructured",
            "detail_level": "high",
            "mapping_index": 6,
            "section_id": "f9c48e11-77ac-4181-9eab-5bf14b4f8670"
        },
        "id": "tPBWxHHx1yDW1WYbfSH2"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "timestamp": "2025-08-24 11:47:46.000",
        "data": {
            "structured_type": "unstructured",
            "detail_level": "high",
            "section_id": "f9c48e11-77ac-4181-9eab-5bf14b4f8670"
        },
        "id": "6LBs5QyF4hwpwxCDUTBS"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "timestamp": "2025-08-24 11:47:46.000",
        "data": {
            "structured_type": "unstructured",
            "detail_level": "high",
            "mapping_index": 4,
            "section_id": "f9c48e11-77ac-4181-9eab-5bf14b4f8670"
        },
        "id": "97Ozb3bxXo9lsTqrC7FR"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "timestamp": "2025-08-24 11:47:46.000",
        "data": {
            "structured_type": "unstructured",
            "detail_level": "high",
            "mapping_index": 0,
            "section_id": "f9c48e11-77ac-4181-9eab-5bf14b4f8670"
        },
        "id": "EJ2p6SSi53xxW4shDnu9"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "timestamp": "2025-08-24 11:47:46.000",
        "data": {
            "structured_type": "unstructured",
            "detail_level": "high",
            "section_id": "f9c48e11-77ac-4181-9eab-5bf14b4f8670"
        },
        "id": "HyeZzJqyBm45wM93NSU8"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "timestamp": "2025-08-24 11:47:46.000",
        "data": {
            "structured_type": "unstructured",
            "detail_level": "high",
            "mapping_index": 3,
            "section_id": "f9c48e11-77ac-4181-9eab-5bf14b4f8670"
        },
        "id": "RG9ci09iuEQvCRrQ9d3o"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "timestamp": "2025-08-24 11:47:46.000",
        "data": {
            "structured_type": "unstructured",
            "detail_level": "high",
            "section_id": "f9c48e11-77ac-4181-9eab-5bf14b4f8670"
        },
        "id": "eQ7QMMYoQFcJILnWq7zB"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "timestamp": "2025-08-24 11:47:46.000",
        "data": {
            "structured_type": "unstructured",
            "detail_level": "high",
            "section_id": "f9c48e11-77ac-4181-9eab-5bf14b4f8670"
        },
        "id": "n87UtF36Fcfty5ZGDxyG"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "timestamp": "2025-08-24 11:47:46.000",
        "data": {
            "structured_type": "unstructured",
            "detail_level": "high",
            "mapping_index": 1,
            "section_id": "f9c48e11-77ac-4181-9eab-5bf14b4f8670"
        },
        "id": "onTbhVe1F8958rNhXCB8"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "timestamp": "2025-08-24 11:47:46.000",
        "data": {
            "structured_type": "unstructured",
            "detail_level": "high",
            "section_id": "f9c48e11-77ac-4181-9eab-5bf14b4f8670"
        },
        "id": "qw9fQyytFTVz7D1geAkF"
    },
    {
        "source": "frontend",
        "event": "change_summary_level",
        "timestamp": "2025-08-24 11:47:47.000",
        "data": {
            "before_structured": "unstructured",
            "before_detail_level": "high",
            "after_structured": "unstructured",
            "after_detail_level": "medium",
            "section_id": "f9c48e11-77ac-4181-9eab-5bf14b4f8670"
        },
        "id": "KD6DCMh5o6jfBu8YuKCs"
    },
    {
        "source": "frontend",
        "event": "change_summary_level",
        "timestamp": "2025-08-24 11:47:47.000",
        "data": {
            "before_structured": "unstructured",
            "before_detail_level": "medium",
            "after_structured": "unstructured",
            "after_detail_level": "low",
            "section_id": "f9c48e11-77ac-4181-9eab-5bf14b4f8670"
        },
        "id": "dtOs8HksSHpyzq8SQzp7"
    },
    {
        "source": "frontend",
        "event": "change_summary_level",
        "timestamp": "2025-08-24 11:47:48.000",
        "data": {
            "before_structured": "unstructured",
            "before_detail_level": "low",
            "after_structured": "unstructured",
            "after_detail_level": "medium",
            "section_id": "f9c48e11-77ac-4181-9eab-5bf14b4f8670"
        },
        "id": "9AU1lBRHAy4dYdKhZXJh"
    },
    {
        "source": "frontend",
        "event": "change_summary_level",
        "timestamp": "2025-08-24 11:47:48.000",
        "data": {
            "before_structured": "unstructured",
            "before_detail_level": "medium",
            "after_structured": "unstructured",
            "after_detail_level": "high",
            "section_id": "f9c48e11-77ac-4181-9eab-5bf14b4f8670"
        },
        "id": "Cnsjr3vmLllLqJQSbdfa"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "timestamp": "2025-08-24 11:47:49.000",
        "data": {
            "structured_type": "unstructured",
            "detail_level": "high",
            "mapping_index": 0,
            "section_id": "f9c48e11-77ac-4181-9eab-5bf14b4f8670"
        },
        "id": "0CBIWgfW1j4JI5pIYwNO"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "timestamp": "2025-08-24 11:47:49.000",
        "data": {
            "structured_type": "unstructured",
            "detail_level": "high",
            "section_id": "f9c48e11-77ac-4181-9eab-5bf14b4f8670"
        },
        "id": "0vVMS9xVE2FizslrxdUY"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "timestamp": "2025-08-24 11:47:49.000",
        "data": {
            "structured_type": "unstructured",
            "detail_level": "high",
            "mapping_index": 6,
            "section_id": "f9c48e11-77ac-4181-9eab-5bf14b4f8670"
        },
        "id": "4OiG5CaC9P7vILZZesnk"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "timestamp": "2025-08-24 11:47:49.000",
        "data": {
            "structured_type": "unstructured",
            "detail_level": "high",
            "section_id": "f9c48e11-77ac-4181-9eab-5bf14b4f8670"
        },
        "id": "94THUvohDZOBCNxqOKX6"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "timestamp": "2025-08-24 11:47:49.000",
        "data": {
            "structured_type": "unstructured",
            "detail_level": "high",
            "section_id": "f9c48e11-77ac-4181-9eab-5bf14b4f8670"
        },
        "id": "9xaNOI1b4q2963ZIAGBV"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "timestamp": "2025-08-24 11:47:49.000",
        "data": {
            "structured_type": "unstructured",
            "detail_level": "high",
            "mapping_index": 3,
            "section_id": "f9c48e11-77ac-4181-9eab-5bf14b4f8670"
        },
        "id": "BILqbpgSXCx7yY8kwdjV"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "timestamp": "2025-08-24 11:47:49.000",
        "data": {
            "structured_type": "unstructured",
            "detail_level": "high",
            "section_id": "f9c48e11-77ac-4181-9eab-5bf14b4f8670"
        },
        "id": "FSlBSSo9AfsxqqaQp9qc"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "timestamp": "2025-08-24 11:47:49.000",
        "data": {
            "structured_type": "unstructured",
            "detail_level": "high",
            "mapping_index": 5,
            "section_id": "f9c48e11-77ac-4181-9eab-5bf14b4f8670"
        },
        "id": "Gny5CD0x9evxz8tX0q2o"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "timestamp": "2025-08-24 11:47:49.000",
        "data": {
            "structured_type": "unstructured",
            "detail_level": "high",
            "section_id": "f9c48e11-77ac-4181-9eab-5bf14b4f8670"
        },
        "id": "HUpuwjdOlbgdk0B0N05t"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "timestamp": "2025-08-24 11:47:49.000",
        "data": {
            "structured_type": "unstructured",
            "detail_level": "high",
            "mapping_index": 7,
            "section_id": "f9c48e11-77ac-4181-9eab-5bf14b4f8670"
        },
        "id": "QwT3DTkyc6D73o7CGfPT"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "timestamp": "2025-08-24 11:47:49.000",
        "data": {
            "structured_type": "unstructured",
            "detail_level": "high",
            "mapping_index": 6,
            "section_id": "f9c48e11-77ac-4181-9eab-5bf14b4f8670"
        },
        "id": "REq9KNI4NF1u3kX0yDM7"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "timestamp": "2025-08-24 11:47:49.000",
        "data": {
            "structured_type": "unstructured",
            "detail_level": "high",
            "mapping_index": 2,
            "section_id": "f9c48e11-77ac-4181-9eab-5bf14b4f8670"
        },
        "id": "Tu4x0UGin25RfBDyT9GN"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "timestamp": "2025-08-24 11:47:49.000",
        "data": {
            "structured_type": "unstructured",
            "detail_level": "high",
            "mapping_index": 3,
            "section_id": "f9c48e11-77ac-4181-9eab-5bf14b4f8670"
        },
        "id": "cAszG4uZ1UDIM6NxoEUZ"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "timestamp": "2025-08-24 11:47:49.000",
        "data": {
            "structured_type": "unstructured",
            "detail_level": "high",
            "section_id": "f9c48e11-77ac-4181-9eab-5bf14b4f8670"
        },
        "id": "eU5OeLDP27Cv3yUzr34D"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "timestamp": "2025-08-24 11:47:49.000",
        "data": {
            "structured_type": "unstructured",
            "detail_level": "high",
            "section_id": "f9c48e11-77ac-4181-9eab-5bf14b4f8670"
        },
        "id": "fV4yMfpmvi3qyeFgbOxJ"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "timestamp": "2025-08-24 11:47:49.000",
        "data": {
            "structured_type": "unstructured",
            "detail_level": "high",
            "section_id": "f9c48e11-77ac-4181-9eab-5bf14b4f8670"
        },
        "id": "gcxJCjePLPlVQCOhFbxe"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "timestamp": "2025-08-24 11:47:49.000",
        "data": {
            "structured_type": "unstructured",
            "detail_level": "high",
            "mapping_index": 5,
            "section_id": "f9c48e11-77ac-4181-9eab-5bf14b4f8670"
        },
        "id": "ms1e2qOmUmAadoEkfrzY"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "timestamp": "2025-08-24 11:47:49.000",
        "data": {
            "structured_type": "unstructured",
            "detail_level": "high",
            "section_id": "f9c48e11-77ac-4181-9eab-5bf14b4f8670"
        },
        "id": "sUkfDIshsOTY02eF3HpX"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "timestamp": "2025-08-24 11:47:49.000",
        "data": {
            "structured_type": "unstructured",
            "detail_level": "high",
            "mapping_index": 4,
            "section_id": "f9c48e11-77ac-4181-9eab-5bf14b4f8670"
        },
        "id": "wl7x3YOV5tOiYTF5rqsu"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "timestamp": "2025-08-24 11:47:49.000",
        "data": {
            "structured_type": "unstructured",
            "detail_level": "high",
            "section_id": "f9c48e11-77ac-4181-9eab-5bf14b4f8670"
        },
        "id": "xJQKnDj898gos05J5zPR"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "timestamp": "2025-08-24 11:47:49.000",
        "data": {
            "structured_type": "unstructured",
            "detail_level": "high",
            "mapping_index": 1,
            "section_id": "f9c48e11-77ac-4181-9eab-5bf14b4f8670"
        },
        "id": "yBpkPBm4cpUn9Dtcurg5"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "timestamp": "2025-08-24 11:47:50.000",
        "data": {
            "structured_type": "unstructured",
            "detail_level": "high",
            "mapping_index": 1,
            "section_id": "f9c48e11-77ac-4181-9eab-5bf14b4f8670"
        },
        "id": "36AAPHKYI36aLI5xbtPg"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "timestamp": "2025-08-24 11:47:50.000",
        "data": {
            "structured_type": "unstructured",
            "detail_level": "high",
            "section_id": "f9c48e11-77ac-4181-9eab-5bf14b4f8670"
        },
        "id": "C5c6PCJufqxeykzzdby1"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "timestamp": "2025-08-24 11:47:53.000",
        "data": {
            "structured_type": "unstructured",
            "detail_level": "high",
            "section_id": "f9c48e11-77ac-4181-9eab-5bf14b4f8670"
        },
        "id": "Mff4VfUDmXtG1IxCHW4D"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "timestamp": "2025-08-24 11:47:54.000",
        "data": {
            "structured_type": "unstructured",
            "detail_level": "high",
            "section_id": "f9c48e11-77ac-4181-9eab-5bf14b4f8670"
        },
        "id": "fjLCcLxk9Jur7VxY45Ra"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "timestamp": "2025-08-24 11:47:54.000",
        "data": {
            "structured_type": "unstructured",
            "detail_level": "high",
            "mapping_index": 1,
            "section_id": "f9c48e11-77ac-4181-9eab-5bf14b4f8670"
        },
        "id": "xV1QnFY6v4Jz9bFK1bSQ"
    },
    {
        "source": "frontend",
        "event": "change_summary_level",
        "timestamp": "2025-08-24 11:47:55.000",
        "data": {
            "before_structured": "unstructured",
            "before_detail_level": "high",
            "after_structured": "structured",
            "after_detail_level": "high",
            "section_id": "f9c48e11-77ac-4181-9eab-5bf14b4f8670"
        },
        "id": "PMWePuONTLVINQpc55aN"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "timestamp": "2025-08-24 11:47:56.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "high",
            "mapping_index": 0,
            "section_id": "f9c48e11-77ac-4181-9eab-5bf14b4f8670"
        },
        "id": "0sLhF37IRHZzNJ8Gw2QR"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "timestamp": "2025-08-24 11:47:56.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "high",
            "section_id": "f9c48e11-77ac-4181-9eab-5bf14b4f8670"
        },
        "id": "XtEhDKtvGZDzNZGs36p5"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "timestamp": "2025-08-24 11:47:56.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "high",
            "section_id": "f9c48e11-77ac-4181-9eab-5bf14b4f8670"
        },
        "id": "ka28rbqsm3Ofr49iFmPW"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "timestamp": "2025-08-24 11:47:56.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "high",
            "mapping_index": 1,
            "section_id": "f9c48e11-77ac-4181-9eab-5bf14b4f8670"
        },
        "id": "qGzpzmjlICjqo1h4e2rz"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "timestamp": "2025-08-24 11:47:57.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "high",
            "section_id": "f9c48e11-77ac-4181-9eab-5bf14b4f8670"
        },
        "id": "4OFJhOxOE1CW4gjHyfYH"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "timestamp": "2025-08-24 11:47:57.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "high",
            "mapping_index": 1,
            "section_id": "f9c48e11-77ac-4181-9eab-5bf14b4f8670"
        },
        "id": "S5i6lPN3ogrGDafn67PI"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "timestamp": "2025-08-24 11:47:57.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "high",
            "mapping_index": 0,
            "section_id": "f9c48e11-77ac-4181-9eab-5bf14b4f8670"
        },
        "id": "Xq2hzTKNx9dUkrGz5wbJ"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "timestamp": "2025-08-24 11:47:57.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "high",
            "section_id": "f9c48e11-77ac-4181-9eab-5bf14b4f8670"
        },
        "id": "ZGKL3JA7ALn0jhtNaZi6"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "timestamp": "2025-08-24 11:47:58.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "high",
            "mapping_index": 0,
            "section_id": "f9c48e11-77ac-4181-9eab-5bf14b4f8670"
        },
        "id": "tNbeylDuGwQVrw8KaVwO"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "timestamp": "2025-08-24 11:47:59.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "high",
            "section_id": "f9c48e11-77ac-4181-9eab-5bf14b4f8670"
        },
        "id": "8JAx2TkgErNE8tkFqyjc"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "timestamp": "2025-08-24 11:47:59.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "high",
            "section_id": "f9c48e11-77ac-4181-9eab-5bf14b4f8670"
        },
        "id": "I4VXUiu0eTH57xd9CgSC"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "timestamp": "2025-08-24 11:47:59.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "high",
            "mapping_index": 1,
            "section_id": "f9c48e11-77ac-4181-9eab-5bf14b4f8670"
        },
        "id": "P2zOZz45Zd9AOVNLeLSW"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "timestamp": "2025-08-24 11:47:59.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "high",
            "section_id": "f9c48e11-77ac-4181-9eab-5bf14b4f8670"
        },
        "id": "eik3WNixD1WUPHl8eF3m"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "timestamp": "2025-08-24 11:47:59.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "high",
            "mapping_index": 3,
            "section_id": "f9c48e11-77ac-4181-9eab-5bf14b4f8670"
        },
        "id": "mslP9SjFq4HPqpMSogba"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "timestamp": "2025-08-24 11:48:00.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "high",
            "mapping_index": 1,
            "section_id": "f9c48e11-77ac-4181-9eab-5bf14b4f8670"
        },
        "id": "uRd8EUfjGmyfXaxlpGAM"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "timestamp": "2025-08-24 11:48:01.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "high",
            "mapping_index": 1,
            "section_id": "f9c48e11-77ac-4181-9eab-5bf14b4f8670"
        },
        "id": "5u3wSwwjO2itXRTwzdIm"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "timestamp": "2025-08-24 11:48:01.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "high",
            "section_id": "f9c48e11-77ac-4181-9eab-5bf14b4f8670"
        },
        "id": "DDdH0K1ro9KzWTaV3nUZ"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "timestamp": "2025-08-24 11:48:01.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "high",
            "mapping_index": 2,
            "section_id": "f9c48e11-77ac-4181-9eab-5bf14b4f8670"
        },
        "id": "Hthp81tIFuvI6rOomTam"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "timestamp": "2025-08-24 11:48:01.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "high",
            "section_id": "f9c48e11-77ac-4181-9eab-5bf14b4f8670"
        },
        "id": "KTr4xihaEwPoH0czQB91"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "timestamp": "2025-08-24 11:48:01.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "high",
            "section_id": "f9c48e11-77ac-4181-9eab-5bf14b4f8670"
        },
        "id": "TLuXT4SqoACl1U6OBUUd"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "timestamp": "2025-08-24 11:48:01.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "high",
            "mapping_index": 3,
            "section_id": "f9c48e11-77ac-4181-9eab-5bf14b4f8670"
        },
        "id": "X0a8jAPvWbZVQnhr751u"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "timestamp": "2025-08-24 11:48:02.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "high",
            "section_id": "f9c48e11-77ac-4181-9eab-5bf14b4f8670"
        },
        "id": "ZFPEdNZjrgLjRZYgFwTS"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "timestamp": "2025-08-24 11:48:02.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "high",
            "section_id": "f9c48e11-77ac-4181-9eab-5bf14b4f8670"
        },
        "id": "gWOqMgUJFDT35PQIn3L6"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "timestamp": "2025-08-24 11:48:02.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "high",
            "mapping_index": 0,
            "section_id": "f9c48e11-77ac-4181-9eab-5bf14b4f8670"
        },
        "id": "jObH0V1l7XFnRKngAJpk"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "timestamp": "2025-08-24 11:48:03.000",
        "data": {
            "structured_type": "unstructured",
            "detail_level": "high",
            "section_id": "f9c48e11-77ac-4181-9eab-5bf14b4f8670"
        },
        "id": "5bSllXSzhjc2JCeywJRU"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "timestamp": "2025-08-24 11:48:03.000",
        "data": {
            "structured_type": "unstructured",
            "detail_level": "high",
            "mapping_index": 3,
            "section_id": "f9c48e11-77ac-4181-9eab-5bf14b4f8670"
        },
        "id": "pT3wVQWx2ivSm4Dn1PgF"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "timestamp": "2025-08-24 11:48:03.000",
        "data": {
            "structured_type": "unstructured",
            "detail_level": "high",
            "section_id": "f9c48e11-77ac-4181-9eab-5bf14b4f8670"
        },
        "id": "u9xfZLF3STHsMCyo46eR"
    },
    {
        "source": "frontend",
        "event": "change_summary_level",
        "timestamp": "2025-08-24 11:48:03.000",
        "data": {
            "before_structured": "structured",
            "before_detail_level": "high",
            "after_structured": "unstructured",
            "after_detail_level": "high",
            "section_id": "f9c48e11-77ac-4181-9eab-5bf14b4f8670"
        },
        "id": "uD3Exbz3zPhNoEUtZ23z"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "timestamp": "2025-08-24 11:48:03.000",
        "data": {
            "structured_type": "unstructured",
            "detail_level": "high",
            "mapping_index": 0,
            "section_id": "f9c48e11-77ac-4181-9eab-5bf14b4f8670"
        },
        "id": "ybCYbuy1fsU6fds1R1LX"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "timestamp": "2025-08-24 11:48:03.000",
        "data": {
            "structured_type": "unstructured",
            "detail_level": "high",
            "mapping_index": 1,
            "section_id": "f9c48e11-77ac-4181-9eab-5bf14b4f8670"
        },
        "id": "zrPDwkOTj7h5x5aVwpzR"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "timestamp": "2025-08-24 11:48:04.000",
        "data": {
            "structured_type": "unstructured",
            "detail_level": "high",
            "section_id": "f9c48e11-77ac-4181-9eab-5bf14b4f8670"
        },
        "id": "HJc9KWCT2rtcPrE15JFM"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "timestamp": "2025-08-24 11:48:04.000",
        "data": {
            "structured_type": "unstructured",
            "detail_level": "high",
            "mapping_index": 2,
            "section_id": "f9c48e11-77ac-4181-9eab-5bf14b4f8670"
        },
        "id": "dbFV59qvzBGL1gmSPpsw"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "timestamp": "2025-08-24 11:48:04.000",
        "data": {
            "structured_type": "unstructured",
            "detail_level": "high",
            "section_id": "f9c48e11-77ac-4181-9eab-5bf14b4f8670"
        },
        "id": "ps8ljoumHfindFXE7J8P"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "timestamp": "2025-08-24 11:48:10.000",
        "data": {
            "structured_type": "unstructured",
            "detail_level": "high",
            "section_id": "f9c48e11-77ac-4181-9eab-5bf14b4f8670"
        },
        "id": "0WR3sX5sRbduJ6ePSqm7"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "timestamp": "2025-08-24 11:48:10.000",
        "data": {
            "structured_type": "unstructured",
            "detail_level": "high",
            "mapping_index": 5,
            "section_id": "f9c48e11-77ac-4181-9eab-5bf14b4f8670"
        },
        "id": "0qMRngLsEBuYTJEgo874"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "timestamp": "2025-08-24 11:48:10.000",
        "data": {
            "structured_type": "unstructured",
            "detail_level": "high",
            "section_id": "f9c48e11-77ac-4181-9eab-5bf14b4f8670"
        },
        "id": "GWNKQK9wOd4lwqzJyCf3"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "timestamp": "2025-08-24 11:48:10.000",
        "data": {
            "structured_type": "unstructured",
            "detail_level": "high",
            "mapping_index": 1,
            "section_id": "f9c48e11-77ac-4181-9eab-5bf14b4f8670"
        },
        "id": "IatO4saUyGXLwnVwjUKd"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "timestamp": "2025-08-24 11:48:10.000",
        "data": {
            "structured_type": "unstructured",
            "detail_level": "high",
            "mapping_index": 2,
            "section_id": "f9c48e11-77ac-4181-9eab-5bf14b4f8670"
        },
        "id": "aoaHno5En7R4AtRB5Kla"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "timestamp": "2025-08-24 11:48:10.000",
        "data": {
            "structured_type": "unstructured",
            "detail_level": "high",
            "mapping_index": 6,
            "section_id": "f9c48e11-77ac-4181-9eab-5bf14b4f8670"
        },
        "id": "b0UOqFsrGV2p0Co2jVIM"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "timestamp": "2025-08-24 11:48:10.000",
        "data": {
            "structured_type": "unstructured",
            "detail_level": "high",
            "mapping_index": 3,
            "section_id": "f9c48e11-77ac-4181-9eab-5bf14b4f8670"
        },
        "id": "gSvXbVeh3OISrvrahDda"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "timestamp": "2025-08-24 11:48:10.000",
        "data": {
            "structured_type": "unstructured",
            "detail_level": "high",
            "section_id": "f9c48e11-77ac-4181-9eab-5bf14b4f8670"
        },
        "id": "m2Z4HK8jtQeqHPOM2t4G"
    },
    {
        "source": "frontend",
        "event": "click_edit_in_prompt",
        "timestamp": "2025-08-24 11:48:10.000",
        "data": {
            "detail_level": "high",
            "structured": "unstructured",
            "summary": "The scrape_season_stats function takes a year as input and constructs the URL for that season's NBA per-game statistics page on Basketball Reference. It reads the HTML table into a DataFrame, removes any rows where the 'Player' column contains the header string (to eliminate repeated headers), and adds a 'Year' column. The function then filters the DataFrame to retain only the columns for player name, year, points, assists, rebounds, and field goal percentage. Finally, it drops any rows with missing values in these key statistics and returns the cleaned DataFrame for further analysis.",
            "section_id": "f9c48e11-77ac-4181-9eab-5bf14b4f8670"
        },
        "id": "mUQ9aM3zPm1XzfwWK8tX"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "timestamp": "2025-08-24 11:48:10.000",
        "data": {
            "structured_type": "unstructured",
            "detail_level": "high",
            "section_id": "f9c48e11-77ac-4181-9eab-5bf14b4f8670"
        },
        "id": "mgl1lHr2Z2nrzMXDOkvu"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "timestamp": "2025-08-24 11:48:10.000",
        "data": {
            "structured_type": "unstructured",
            "detail_level": "high",
            "section_id": "f9c48e11-77ac-4181-9eab-5bf14b4f8670"
        },
        "id": "nEGJZ7nAK3Y4pFGq7rYz"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "timestamp": "2025-08-24 11:48:14.000",
        "data": {
            "structured_type": "unstructured",
            "detail_level": "high",
            "mapping_index": 5,
            "section_id": "f9c48e11-77ac-4181-9eab-5bf14b4f8670"
        },
        "id": "7mJmqkrvsT2YLlhKtdPp"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "timestamp": "2025-08-24 11:48:14.000",
        "data": {
            "structured_type": "unstructured",
            "detail_level": "high",
            "section_id": "f9c48e11-77ac-4181-9eab-5bf14b4f8670"
        },
        "id": "85QN0MPGrDsFPBYvcdN9"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "timestamp": "2025-08-24 11:48:14.000",
        "data": {
            "structured_type": "unstructured",
            "detail_level": "high",
            "section_id": "f9c48e11-77ac-4181-9eab-5bf14b4f8670"
        },
        "id": "D6uWUsF1WRtInq5C4XNV"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "timestamp": "2025-08-24 11:48:14.000",
        "data": {
            "structured_type": "unstructured",
            "detail_level": "high",
            "mapping_index": 4,
            "section_id": "f9c48e11-77ac-4181-9eab-5bf14b4f8670"
        },
        "id": "QL3wAMViciF9f3H7wJHf"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "timestamp": "2025-08-24 11:48:14.000",
        "data": {
            "structured_type": "unstructured",
            "detail_level": "high",
            "mapping_index": 0,
            "section_id": "f9c48e11-77ac-4181-9eab-5bf14b4f8670"
        },
        "id": "R9dwxmk2vM2zjgNlm8ox"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "timestamp": "2025-08-24 11:48:14.000",
        "data": {
            "structured_type": "unstructured",
            "detail_level": "high",
            "section_id": "f9c48e11-77ac-4181-9eab-5bf14b4f8670"
        },
        "id": "Zr2nmKmnsbkz8oearrmD"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "timestamp": "2025-08-24 11:48:14.000",
        "data": {
            "structured_type": "unstructured",
            "detail_level": "high",
            "mapping_index": 1,
            "section_id": "f9c48e11-77ac-4181-9eab-5bf14b4f8670"
        },
        "id": "aBwVn90QsuTqo8PzNmCD"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "timestamp": "2025-08-24 11:48:14.000",
        "data": {
            "structured_type": "unstructured",
            "detail_level": "high",
            "section_id": "f9c48e11-77ac-4181-9eab-5bf14b4f8670"
        },
        "id": "hY4xNHJFKojVisUKSrej"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "timestamp": "2025-08-24 11:48:16.000",
        "data": {
            "structured_type": "unstructured",
            "detail_level": "high",
            "section_id": "f9c48e11-77ac-4181-9eab-5bf14b4f8670"
        },
        "id": "2dy6NL8GoVFBk6ngoM4D"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "timestamp": "2025-08-24 11:48:16.000",
        "data": {
            "structured_type": "unstructured",
            "detail_level": "high",
            "mapping_index": 1,
            "section_id": "f9c48e11-77ac-4181-9eab-5bf14b4f8670"
        },
        "id": "AEwerJ3lZ4cEJna9WoWU"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "timestamp": "2025-08-24 11:48:16.000",
        "data": {
            "structured_type": "unstructured",
            "detail_level": "high",
            "section_id": "f9c48e11-77ac-4181-9eab-5bf14b4f8670"
        },
        "id": "LjBIFRKeipwTNeg4tA2d"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "timestamp": "2025-08-24 11:48:16.000",
        "data": {
            "structured_type": "unstructured",
            "detail_level": "high",
            "mapping_index": 6,
            "section_id": "f9c48e11-77ac-4181-9eab-5bf14b4f8670"
        },
        "id": "MklGTg2g9w1X3zla1Ixg"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "timestamp": "2025-08-24 11:48:16.000",
        "data": {
            "structured_type": "unstructured",
            "detail_level": "high",
            "section_id": "f9c48e11-77ac-4181-9eab-5bf14b4f8670"
        },
        "id": "Q3QxCNWzzuPVNqwH5hkl"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "timestamp": "2025-08-24 11:48:16.000",
        "data": {
            "structured_type": "unstructured",
            "detail_level": "high",
            "mapping_index": 0,
            "section_id": "f9c48e11-77ac-4181-9eab-5bf14b4f8670"
        },
        "id": "UKYDrKccC3cwUsvK1vU6"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "timestamp": "2025-08-24 11:48:16.000",
        "data": {
            "structured_type": "unstructured",
            "detail_level": "high",
            "section_id": "f9c48e11-77ac-4181-9eab-5bf14b4f8670"
        },
        "id": "Zlo4q10J2oso4aJQLwTV"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "timestamp": "2025-08-24 11:48:16.000",
        "data": {
            "structured_type": "unstructured",
            "detail_level": "high",
            "section_id": "f9c48e11-77ac-4181-9eab-5bf14b4f8670"
        },
        "id": "gYyoUz0xg7tS1o0Usup1"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "timestamp": "2025-08-24 11:48:16.000",
        "data": {
            "structured_type": "unstructured",
            "detail_level": "high",
            "mapping_index": 5,
            "section_id": "f9c48e11-77ac-4181-9eab-5bf14b4f8670"
        },
        "id": "l13gkUZiXvAeKKlQiZLf"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "timestamp": "2025-08-24 11:48:16.000",
        "data": {
            "structured_type": "unstructured",
            "detail_level": "high",
            "mapping_index": 7,
            "section_id": "f9c48e11-77ac-4181-9eab-5bf14b4f8670"
        },
        "id": "oHXTcCsylaKK407WPgas"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "timestamp": "2025-08-24 11:48:17.000",
        "data": {
            "structured_type": "unstructured",
            "detail_level": "high",
            "mapping_index": 7,
            "section_id": "f9c48e11-77ac-4181-9eab-5bf14b4f8670"
        },
        "id": "NiM1mxxI6x2ifF4VYv7F"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "timestamp": "2025-08-24 11:48:17.000",
        "data": {
            "structured_type": "unstructured",
            "detail_level": "high",
            "mapping_index": 1,
            "section_id": "f9c48e11-77ac-4181-9eab-5bf14b4f8670"
        },
        "id": "SkJlFkB6FLFeFxULFPlH"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "timestamp": "2025-08-24 11:48:17.000",
        "data": {
            "structured_type": "unstructured",
            "detail_level": "high",
            "section_id": "f9c48e11-77ac-4181-9eab-5bf14b4f8670"
        },
        "id": "SwN8BztlIJf2ganP3tZu"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "timestamp": "2025-08-24 11:48:17.000",
        "data": {
            "structured_type": "unstructured",
            "detail_level": "high",
            "section_id": "f9c48e11-77ac-4181-9eab-5bf14b4f8670"
        },
        "id": "uPFhqcMe90Ac7Yp2IoNZ"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "timestamp": "2025-08-24 11:48:17.000",
        "data": {
            "structured_type": "unstructured",
            "detail_level": "high",
            "mapping_index": 5,
            "section_id": "f9c48e11-77ac-4181-9eab-5bf14b4f8670"
        },
        "id": "wExGp6Ppj8F1ZHbCxAz3"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "timestamp": "2025-08-24 11:48:17.000",
        "data": {
            "structured_type": "unstructured",
            "detail_level": "high",
            "section_id": "f9c48e11-77ac-4181-9eab-5bf14b4f8670"
        },
        "id": "zcFf8djBE2WrFlB0s9Rd"
    },
    {
        "source": "frontend",
        "event": "apply_instruction_summary",
        "timestamp": "2025-08-24 11:49:23.000",
        "data": {
            "detail_level": "high",
            "structured": "unstructured",
            "instruction": "Also scrap from advanced stats (https://www.basketball-reference.com/leagues/NBA_2025_advanced.html) and merge the advanced stats with existing basic stats",
            "original_summary": "The scrape_season_stats function takes a year as input and constructs the URL for that season's NBA per-game statistics page on Basketball Reference. It reads the HTML table into a DataFrame, removes any rows where the 'Player' column contains the header string (to eliminate repeated headers), and adds a 'Year' column. The function then filters the DataFrame to retain only the columns for player name, year, points, assists, rebounds, and field goal percentage. Finally, it drops any rows with missing values in these key statistics and returns the cleaned DataFrame for further analysis.",
            "section_id": "f9c48e11-77ac-4181-9eab-5bf14b4f8670"
        },
        "id": "VqiIEseZ5jkpjVfjf8PU"
    },
    {
        "source": "backend",
        "event": "apply_instruction_summary",
        "timestamp": "2025-08-24 11:49:25.000",
        "data": {
            "original_code": "def scrape_season_stats(year):\n    base_url_reg = (\n        f\"https://www.basketball-reference.com/leagues/NBA_{year}_per_game.html\"\n    )\n    df_reg = pd.read_html(base_url_reg, header=0)[0]\n    df_reg = df_reg[df_reg[\"Player\"] != \"Player\"]  # remove repeated header rows\n    df_reg[\"Year\"] = year\n\n    df_reg = df_reg[\n        [\"Player\", \"Year\", \"PTS\", \"AST\", \"TRB\", \"FG%\"]\n    ]  # Keep only specified columns\n    df_reg = df_reg.dropna(\n        subset=[\"PTS\", \"AST\", \"TRB\", \"FG%\"]\n    )  # Ensure key stats aren't invalid\n    return df_reg",
            "updated_summary": "The scrape_season_stats function takes a year as input and constructs the URL for that season's NBA per-game statistics page on Basketball Reference. It also constructs the URL for the advanced statistics page for the same season and scrapes the advanced stats table. It reads the HTML table into a DataFrame, removes any rows where the 'Player' column contains the header string (to eliminate repeated headers), and adds a 'Year' column. The function then filters the DataFrame to retain only the columns for player name, year, points, assists, rebounds, and field goal percentage. The advanced stats DataFrame is merged with the basic stats DataFrame to combine both sets of statistics for each player. Finally, it drops any rows with missing values in these key statistics and returns the cleaned, merged DataFrame for further analysis.",
            "instruction": "Also scrap from advanced stats (https://www.basketball-reference.com/leagues/NBA_2025_advanced.html) and merge the advanced stats with existing basic stats",
            "original_summary": "The scrape_season_stats function takes a year as input and constructs the URL for that season's NBA per-game statistics page on Basketball Reference. It reads the HTML table into a DataFrame, removes any rows where the 'Player' column contains the header string (to eliminate repeated headers), and adds a 'Year' column. The function then filters the DataFrame to retain only the columns for player name, year, points, assists, rebounds, and field goal percentage. Finally, it drops any rows with missing values in these key statistics and returns the cleaned DataFrame for further analysis."
        },
        "id": "la7sQCQNYRx529ojh8Dv"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "timestamp": "2025-08-24 11:49:36.000",
        "data": {
            "structured_type": "unstructured",
            "detail_level": "high",
            "section_id": "f9c48e11-77ac-4181-9eab-5bf14b4f8670"
        },
        "id": "BRhAMNb7GpCddda9WVs6"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "timestamp": "2025-08-24 11:49:36.000",
        "data": {
            "structured_type": "unstructured",
            "detail_level": "high",
            "mapping_index": 1,
            "section_id": "f9c48e11-77ac-4181-9eab-5bf14b4f8670"
        },
        "id": "KGC4YtEGUHVZ2rm9TXMg"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "timestamp": "2025-08-24 11:49:36.000",
        "data": {
            "structured_type": "unstructured",
            "detail_level": "high",
            "mapping_index": 7,
            "section_id": "f9c48e11-77ac-4181-9eab-5bf14b4f8670"
        },
        "id": "Q5bxw3QvQObQN9TBqcbP"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "timestamp": "2025-08-24 11:49:36.000",
        "data": {
            "structured_type": "unstructured",
            "detail_level": "high",
            "mapping_index": 3,
            "section_id": "f9c48e11-77ac-4181-9eab-5bf14b4f8670"
        },
        "id": "QgXAiHBH3aIukeNB2N01"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "timestamp": "2025-08-24 11:49:36.000",
        "data": {
            "structured_type": "unstructured",
            "detail_level": "high",
            "mapping_index": 0,
            "section_id": "f9c48e11-77ac-4181-9eab-5bf14b4f8670"
        },
        "id": "QuXlrSKIdI4QiynIyDIt"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "timestamp": "2025-08-24 11:49:36.000",
        "data": {
            "structured_type": "unstructured",
            "detail_level": "high",
            "section_id": "f9c48e11-77ac-4181-9eab-5bf14b4f8670"
        },
        "id": "aM5cIvTBuw6Sklo7RA5m"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "timestamp": "2025-08-24 11:49:36.000",
        "data": {
            "structured_type": "unstructured",
            "detail_level": "high",
            "mapping_index": 1,
            "section_id": "f9c48e11-77ac-4181-9eab-5bf14b4f8670"
        },
        "id": "cOOWFL6JDHvEXX8nmPft"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "timestamp": "2025-08-24 11:49:36.000",
        "data": {
            "structured_type": "unstructured",
            "detail_level": "high",
            "section_id": "f9c48e11-77ac-4181-9eab-5bf14b4f8670"
        },
        "id": "gu4RgQgzx9YvhuzPQUsR"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "timestamp": "2025-08-24 11:49:36.000",
        "data": {
            "structured_type": "unstructured",
            "detail_level": "high",
            "section_id": "f9c48e11-77ac-4181-9eab-5bf14b4f8670"
        },
        "id": "zZBB5QB5TLdVUVQYe91k"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "timestamp": "2025-08-24 11:49:36.000",
        "data": {
            "structured_type": "unstructured",
            "detail_level": "high",
            "section_id": "f9c48e11-77ac-4181-9eab-5bf14b4f8670"
        },
        "id": "za8M00q0oNnc5v95U6BS"
    },
    {
        "source": "frontend",
        "event": "commit_modified_summary",
        "timestamp": "2025-08-24 11:49:53.000",
        "data": {
            "detail_level": "high",
            "structured": "unstructured",
            "edited_summary": "The scrape_season_stats function takes a year as input and constructs the URL for that season's NBA per-game statistics page on Basketball Reference. It also constructs the URL for the advanced statistics page (https://www.basketball-reference.com/leagues/NBA_2025_advanced.html) for the same season and scrapes the advanced stats table. It reads the HTML table into a DataFrame, removes any rows where the 'Player' column contains the header string (to eliminate repeated headers), and adds a 'Year' column. The function then filters the DataFrame to retain only the columns for player name, year, points, assists, rebounds, and field goal percentage. The advanced stats DataFrame is merged with the basic stats DataFrame to combine both sets of statistics for each player. Finally, it drops any rows with missing values in these key statistics and returns the cleaned, merged DataFrame for further analysis.",
            "original_summary": "The scrape_season_stats function takes a year as input and constructs the URL for that season's NBA per-game statistics page on Basketball Reference. It reads the HTML table into a DataFrame, removes any rows where the 'Player' column contains the header string (to eliminate repeated headers), and adds a 'Year' column. The function then filters the DataFrame to retain only the columns for player name, year, points, assists, rebounds, and field goal percentage. Finally, it drops any rows with missing values in these key statistics and returns the cleaned DataFrame for further analysis.",
            "section_id": "f9c48e11-77ac-4181-9eab-5bf14b4f8670"
        },
        "id": "V3mQnIlbcbz0NkILGW9P"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "timestamp": "2025-08-24 11:49:56.000",
        "data": {
            "structured_type": "unstructured",
            "detail_level": "high",
            "section_id": "f9c48e11-77ac-4181-9eab-5bf14b4f8670"
        },
        "id": "DkjwxP7BduWux4vu6cXL"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "timestamp": "2025-08-24 11:49:56.000",
        "data": {
            "structured_type": "unstructured",
            "detail_level": "high",
            "mapping_index": 7,
            "section_id": "f9c48e11-77ac-4181-9eab-5bf14b4f8670"
        },
        "id": "H0Ua1OfPpdGXgCN9KdRS"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "timestamp": "2025-08-24 11:49:56.000",
        "data": {
            "structured_type": "unstructured",
            "detail_level": "high",
            "section_id": "f9c48e11-77ac-4181-9eab-5bf14b4f8670"
        },
        "id": "UqRT7gK3em7d5KT2N4KA"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "timestamp": "2025-08-24 11:49:56.000",
        "data": {
            "structured_type": "unstructured",
            "detail_level": "high",
            "mapping_index": 1,
            "section_id": "f9c48e11-77ac-4181-9eab-5bf14b4f8670"
        },
        "id": "Wt8NLoF74xlrXdd7xM9Q"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "timestamp": "2025-08-24 11:49:56.000",
        "data": {
            "structured_type": "unstructured",
            "detail_level": "high",
            "mapping_index": 1,
            "section_id": "f9c48e11-77ac-4181-9eab-5bf14b4f8670"
        },
        "id": "YWDPD1dFGfM3kjpXmN0r"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "timestamp": "2025-08-24 11:49:56.000",
        "data": {
            "structured_type": "unstructured",
            "detail_level": "high",
            "mapping_index": 3,
            "section_id": "f9c48e11-77ac-4181-9eab-5bf14b4f8670"
        },
        "id": "Zg1J2texIF0EECWEGqJv"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "timestamp": "2025-08-24 11:49:56.000",
        "data": {
            "structured_type": "unstructured",
            "detail_level": "high",
            "mapping_index": 3,
            "section_id": "f9c48e11-77ac-4181-9eab-5bf14b4f8670"
        },
        "id": "aKBC4f2969WNbv5Lw1d4"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "timestamp": "2025-08-24 11:49:56.000",
        "data": {
            "structured_type": "unstructured",
            "detail_level": "high",
            "mapping_index": 5,
            "section_id": "f9c48e11-77ac-4181-9eab-5bf14b4f8670"
        },
        "id": "c1VfgimSvIyF1mUSYFuE"
    },
    {
        "source": "backend",
        "event": "modify_summary_mediation",
        "timestamp": "2025-08-24 11:49:56.000",
        "data": {
            "original_code": "def scrape_season_stats(year):\n    base_url_reg = (\n        f\"https://www.basketball-reference.com/leagues/NBA_{year}_per_game.html\"\n    )\n    df_reg = pd.read_html(base_url_reg, header=0)[0]\n    df_reg = df_reg[df_reg[\"Player\"] != \"Player\"]  # remove repeated header rows\n    df_reg[\"Year\"] = year\n\n    df_reg = df_reg[\n        [\"Player\", \"Year\", \"PTS\", \"AST\", \"TRB\", \"FG%\"]\n    ]  # Keep only specified columns\n    df_reg = df_reg.dropna(\n        subset=[\"PTS\", \"AST\", \"TRB\", \"FG%\"]\n    )  # Ensure key stats aren't invalid\n    return df_reg",
            "detail_level": "high",
            "edited_summary": "The scrape_season_stats function takes a year as input and constructs the URL for that season's NBA per-game statistics page on Basketball Reference. It also constructs the URL for the advanced statistics page (https://www.basketball-reference.com/leagues/NBA_2025_advanced.html) for the same season and scrapes the advanced stats table. It reads the HTML table into a DataFrame, removes any rows where the 'Player' column contains the header string (to eliminate repeated headers), and adds a 'Year' column. The function then filters the DataFrame to retain only the columns for player name, year, points, assists, rebounds, and field goal percentage. The advanced stats DataFrame is merged with the basic stats DataFrame to combine both sets of statistics for each player. Finally, it drops any rows with missing values in these key statistics and returns the cleaned, merged DataFrame for further analysis.",
            "original_summary": "The scrape_season_stats function takes a year as input and constructs the URL for that season's NBA per-game statistics page on Basketball Reference. It reads the HTML table into a DataFrame, removes any rows where the 'Player' column contains the header string (to eliminate repeated headers), and adds a 'Year' column. The function then filters the DataFrame to retain only the columns for player name, year, points, assists, rebounds, and field goal percentage. Finally, it drops any rows with missing values in these key statistics and returns the cleaned DataFrame for further analysis.",
            "updated_code": "def scrape_season_stats(year):\n    base_url_reg = (\n        f\"https://www.basketball-reference.com/leagues/NBA_{year}_per_game.html\"\n    )\n    base_url_adv = (\n        f\"https://www.basketball-reference.com/leagues/NBA_{year}_advanced.html\"\n    )\n    # Scrape per-game stats\n    df_reg = pd.read_html(base_url_reg, header=0)[0]\n    df_reg = df_reg[df_reg[\"Player\"] != \"Player\"]  # remove repeated header rows\n    df_reg[\"Year\"] = year\n\n    df_reg = df_reg[\n        [\"Player\", \"Year\", \"PTS\", \"AST\", \"TRB\", \"FG%\"]\n    ]  # Keep only specified columns\n\n    # Scrape advanced stats\n    df_adv = pd.read_html(base_url_adv, header=0)[0]\n    df_adv = df_adv[df_adv[\"Player\"] != \"Player\"]  # remove repeated header rows\n    df_adv[\"Year\"] = year\n    # Keep only Player, Year, and all advanced stats columns except team totals\n    # Remove duplicate columns before merging\n    adv_cols = [col for col in df_adv.columns if col not in [\"Player\", \"Year\", \"Tm\"]]\n    df_adv = df_adv[[\"Player\", \"Year\"] + adv_cols]\n\n    # Merge per-game and advanced stats on Player and Year\n    df_merged = pd.merge(df_reg, df_adv, on=[\"Player\", \"Year\"], how=\"inner\")\n\n    # Ensure key stats aren't invalid\n    df_merged = df_merged.dropna(\n        subset=[\"PTS\", \"AST\", \"TRB\", \"FG%\"]\n    )\n    return df_merged",
            "structured_type": "unstructured"
        },
        "id": "ccPKS5MspU9cuRu4zChY"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "timestamp": "2025-08-24 11:49:56.000",
        "data": {
            "structured_type": "unstructured",
            "detail_level": "high",
            "section_id": "f9c48e11-77ac-4181-9eab-5bf14b4f8670"
        },
        "id": "cq3XgBuqFACuLrVDvSvF"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "timestamp": "2025-08-24 11:49:56.000",
        "data": {
            "structured_type": "unstructured",
            "detail_level": "high",
            "section_id": "f9c48e11-77ac-4181-9eab-5bf14b4f8670"
        },
        "id": "eFdPHHeWGOs8hYpfml7p"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "timestamp": "2025-08-24 11:49:56.000",
        "data": {
            "structured_type": "unstructured",
            "detail_level": "high",
            "mapping_index": 6,
            "section_id": "f9c48e11-77ac-4181-9eab-5bf14b4f8670"
        },
        "id": "fWneCvhkz40aS93nOLZf"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "timestamp": "2025-08-24 11:49:56.000",
        "data": {
            "structured_type": "unstructured",
            "detail_level": "high",
            "mapping_index": 0,
            "section_id": "f9c48e11-77ac-4181-9eab-5bf14b4f8670"
        },
        "id": "g8TOw6npJCbdKBPJz0Ct"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "timestamp": "2025-08-24 11:49:56.000",
        "data": {
            "structured_type": "unstructured",
            "detail_level": "high",
            "section_id": "f9c48e11-77ac-4181-9eab-5bf14b4f8670"
        },
        "id": "jUgtK2jcJo2lPZsDP6rl"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "timestamp": "2025-08-24 11:49:56.000",
        "data": {
            "structured_type": "unstructured",
            "detail_level": "high",
            "section_id": "f9c48e11-77ac-4181-9eab-5bf14b4f8670"
        },
        "id": "lVCxnfnugBey9k48hRgT"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "timestamp": "2025-08-24 11:49:56.000",
        "data": {
            "structured_type": "unstructured",
            "detail_level": "high",
            "section_id": "f9c48e11-77ac-4181-9eab-5bf14b4f8670"
        },
        "id": "luY1dwOfqfBYyi22WgBi"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "timestamp": "2025-08-24 11:49:56.000",
        "data": {
            "structured_type": "unstructured",
            "detail_level": "high",
            "section_id": "f9c48e11-77ac-4181-9eab-5bf14b4f8670"
        },
        "id": "okN06da1rL8mdPeK6Yhp"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "timestamp": "2025-08-24 11:49:56.000",
        "data": {
            "structured_type": "unstructured",
            "detail_level": "high",
            "section_id": "f9c48e11-77ac-4181-9eab-5bf14b4f8670"
        },
        "id": "rsc1p31m96NWU8FEQQxa"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "timestamp": "2025-08-24 11:49:56.000",
        "data": {
            "structured_type": "unstructured",
            "detail_level": "high",
            "section_id": "f9c48e11-77ac-4181-9eab-5bf14b4f8670"
        },
        "id": "sRZMF8BF3sEsmfg0Ycj4"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "timestamp": "2025-08-24 11:49:56.000",
        "data": {
            "structured_type": "unstructured",
            "detail_level": "high",
            "mapping_index": 7,
            "section_id": "f9c48e11-77ac-4181-9eab-5bf14b4f8670"
        },
        "id": "xwPbXzimQcIYjUV4wRq3"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "timestamp": "2025-08-24 11:49:56.000",
        "data": {
            "structured_type": "unstructured",
            "detail_level": "high",
            "mapping_index": 5,
            "section_id": "f9c48e11-77ac-4181-9eab-5bf14b4f8670"
        },
        "id": "zuK8R00VMBrFLmr213NF"
    },
    {
        "source": "backend",
        "event": "summarize_modified_code",
        "timestamp": "2025-08-24 11:50:09.000",
        "data": {
            "original_code": "def scrape_season_stats(year):\n    base_url_reg = (\n        f\"https://www.basketball-reference.com/leagues/NBA_{year}_per_game.html\"\n    )\n    base_url_adv = (\n        f\"https://www.basketball-reference.com/leagues/NBA_{year}_advanced.html\"\n    )\n    # Scrape per-game stats\n    df_reg = pd.read_html(base_url_reg, header=0)[0]\n    df_reg = df_reg[df_reg[\"Player\"] != \"Player\"]  # remove repeated header rows\n    df_reg[\"Year\"] = year\n\n    df_reg = df_reg[\n        [\"Player\", \"Year\", \"PTS\", \"AST\", \"TRB\", \"FG%\"]\n    ]  # Keep only specified columns\n\n    # Scrape advanced stats\n    df_adv = pd.read_html(base_url_adv, header=0)[0]\n    df_adv = df_adv[df_adv[\"Player\"] != \"Player\"]  # remove repeated header rows\n    df_adv[\"Year\"] = year\n    # Keep only Player, Year, and all advanced stats columns except team totals\n    # Remove duplicate columns before merging\n    adv_cols = [col for col in df_adv.columns if col not in [\"Player\", \"Year\", \"Tm\"]]\n    df_adv = df_adv[[\"Player\", \"Year\"] + adv_cols]\n\n    # Merge per-game and advanced stats on Player and Year\n    df_merged = pd.merge(df_reg, df_adv, on=[\"Player\", \"Year\"], how=\"inner\")\n\n    # Ensure key stats aren't invalid\n    df_merged = df_merged.dropna(\n        subset=[\"PTS\", \"AST\", \"TRB\", \"FG%\"]\n    )\n    return df_merged",
            "new_summary": {
                "medium_structured": "• Downloads per-game and advanced NBA stats for a specified year from Basketball Reference\n• Cleans the data:\n  ◦ Removes repeated header rows\n  ◦ Adds the year as a column\n• Filters per-game stats to keep only Player, Year, PTS, AST, TRB, and FG% columns\n• Filters advanced stats to keep Player, Year, and all advanced stats columns except team totals\n• Merges per-game and advanced stats on Player and Year\n• Drops rows with missing values in key stats\n• Returns the cleaned and merged DataFrame",
                "low_unstructured": "This function retrieves and processes NBA player per-game and advanced statistics for a given year from Basketball Reference, merging both datasets.",
                "high_structured": "• Constructs the URLs for the NBA per-game and advanced stats pages for the specified year\n• Reads the first HTML tables from both pages into DataFrames\n• Cleans both DataFrames:\n  ◦ Removes rows where the 'Player' column equals 'Player' (eliminating repeated headers)\n  ◦ Adds a 'Year' column to indicate the season\n• Filters the per-game DataFrame to keep only the following columns:\n  ◦ Player, Year, PTS, AST, TRB, FG%\n• Filters the advanced stats DataFrame to keep Player, Year, and all advanced stats columns except team totals\n• Merges the per-game and advanced stats DataFrames on Player and Year\n• Drops rows with missing values in any of the key stat columns (PTS, AST, TRB, FG%)\n• Returns the processed DataFrame containing clean, relevant, and merged player statistics for the given year",
                "low_structured": "• Fetches NBA per-game and advanced stats for a given year\n• Cleans and filters the data\n• Merges per-game and advanced stats on Player and Year\n• Returns selected player statistics",
                "high_unstructured": "The scrape_season_stats function takes a year as input and constructs URLs for that season's NBA per-game and advanced statistics pages on Basketball Reference. It reads the HTML tables into DataFrames, removes any rows where the 'Player' column contains the header string (to eliminate repeated headers), and adds a 'Year' column. The function then filters the per-game DataFrame to retain only the columns for player name, year, points, assists, rebounds, and field goal percentage, and filters the advanced stats DataFrame to keep player name, year, and all advanced stats except team totals. It merges the per-game and advanced stats DataFrames on player and year, drops any rows with missing values in the key statistics, and returns the cleaned, merged DataFrame for further analysis.",
                "medium_unstructured": "The function scrape_season_stats downloads both NBA per-game and advanced statistics for a specified year from Basketball Reference. It cleans the data by removing repeated header rows and keeps only relevant columns such as player name, year, points, assists, rebounds, and field goal percentage from the per-game stats, and all advanced stats except team totals from the advanced stats. The function merges these datasets on player and year, ensures that rows with missing key stats are excluded, and returns the processed DataFrame.",
                "title": "Summary of scrape_season_stats(year) Function (with Advanced Stats Merging)"
            },
            "old_summary": {
                "medium_structured": "• Downloads per-game NBA stats for a specified year from Basketball Reference\n• Cleans the data:\n  ◦ Removes repeated header rows\n  ◦ Adds the year as a column\n• Filters to keep only Player, Year, PTS, AST, TRB, and FG% columns\n• Drops rows with missing values in key stats\n• Returns the cleaned DataFrame",
                "low_unstructured": "This function retrieves and processes NBA player per-game statistics for a given year from Basketball Reference.",
                "high_structured": "• Constructs the URL for the NBA per-game stats page for the specified year\n• Reads the first HTML table from the page into a DataFrame\n• Cleans the DataFrame:\n  ◦ Removes rows where the 'Player' column equals 'Player' (eliminating repeated headers)\n  ◦ Adds a 'Year' column to indicate the season\n• Filters the DataFrame to keep only the following columns:\n  ◦ Player, Year, PTS, AST, TRB, FG%\n• Drops rows with missing values in any of the key stat columns (PTS, AST, TRB, FG%)\n• Returns the processed DataFrame containing clean, relevant player statistics for the given year",
                "low_structured": "• Fetches NBA per-game stats for a given year\n• Cleans and filters the data\n• Returns selected player statistics",
                "high_unstructured": "The scrape_season_stats function takes a year as input and constructs the URL for that season's NBA per-game statistics page on Basketball Reference. It reads the HTML table into a DataFrame, removes any rows where the 'Player' column contains the header string (to eliminate repeated headers), and adds a 'Year' column. The function then filters the DataFrame to retain only the columns for player name, year, points, assists, rebounds, and field goal percentage. Finally, it drops any rows with missing values in these key statistics and returns the cleaned DataFrame for further analysis.",
                "medium_unstructured": "The function scrape_season_stats downloads NBA per-game statistics for a specified year from Basketball Reference. It cleans the data by removing repeated header rows and keeps only relevant columns such as player name, year, points, assists, rebounds, and field goal percentage. The function also ensures that rows with missing key stats are excluded before returning the processed DataFrame.",
                "title": "Summary of scrape_season_stats(year) Function"
            },
            "new_code": "def scrape_season_stats(year):\n    base_url_reg = (\n        f\"https://www.basketball-reference.com/leagues/NBA_{year}_per_game.html\"\n    )\n    base_url_adv = (\n        f\"https://www.basketball-reference.com/leagues/NBA_{year}_advanced.html\"\n    )\n    # Scrape per-game stats\n    df_reg = pd.read_html(base_url_reg, header=0)[0]\n    df_reg = df_reg[df_reg[\"Player\"] != \"Player\"]  # remove repeated header rows\n    df_reg[\"Year\"] = year\n\n    df_reg = df_reg[\n        [\"Player\", \"Year\", \"PTS\", \"AST\", \"TRB\", \"FG%\"]\n    ]  # Keep only specified columns\n\n    # Scrape advanced stats\n    df_adv = pd.read_html(base_url_adv, header=0)[0]\n    df_adv = df_adv[df_adv[\"Player\"] != \"Player\"]  # remove repeated header rows\n    df_adv[\"Year\"] = year\n    # Keep only Player, Year, and all advanced stats columns except team totals\n    # Remove duplicate columns before merging\n    adv_cols = [col for col in df_adv.columns if col not in [\"Player\", \"Year\", \"Tm\"]]\n    df_adv = df_adv[[\"Player\", \"Year\"] + adv_cols]\n\n    # Merge per-game and advanced stats on Player and Year\n    df_merged = pd.merge(df_reg, df_adv, on=[\"Player\", \"Year\"], how=\"inner\")\n\n    # Ensure key stats aren't invalid\n    df_merged = df_merged.dropna(\n        subset=[\"PTS\", \"AST\", \"TRB\", \"FG%\"]\n    )\n    return df_merged"
        },
        "id": "e1fK149BAUCRXcXb0d1M"
    },
    {
        "source": "backend",
        "event": "map_summary_code",
        "timestamp": "2025-08-24 11:50:13.000",
        "data": {
            "summary": "This function retrieves and processes NBA player per-game and advanced statistics for a given year from Basketball Reference, merging both datasets.",
            "code": "22: def scrape_season_stats(year):\n23:     base_url_reg = (\n24:         f\"https://www.basketball-reference.com/leagues/NBA_{year}_per_game.html\"\n25:     )\n26:     base_url_adv = (\n27:         f\"https://www.basketball-reference.com/leagues/NBA_{year}_advanced.html\"\n28:     )\n29:     # Scrape per-game stats\n30:     df_reg = pd.read_html(base_url_reg, header=0)[0]\n31:     df_reg = df_reg[df_reg[\"Player\"] != \"Player\"]  # remove repeated header rows\n32:     df_reg[\"Year\"] = year\n33: \n34:     df_reg = df_reg[\n35:         [\"Player\", \"Year\", \"PTS\", \"AST\", \"TRB\", \"FG%\"]\n36:     ]  # Keep only specified columns\n37: \n38:     # Scrape advanced stats\n39:     df_adv = pd.read_html(base_url_adv, header=0)[0]\n40:     df_adv = df_adv[df_adv[\"Player\"] != \"Player\"]  # remove repeated header rows\n41:     df_adv[\"Year\"] = year\n42:     # Keep only Player, Year, and all advanced stats columns except team totals\n43:     # Remove duplicate columns before merging\n44:     adv_cols = [col for col in df_adv.columns if col not in [\"Player\", \"Year\", \"Tm\"]]\n45:     df_adv = df_adv[[\"Player\", \"Year\"] + adv_cols]\n46: \n47:     # Merge per-game and advanced stats on Player and Year\n48:     df_merged = pd.merge(df_reg, df_adv, on=[\"Player\", \"Year\"], how=\"inner\")\n49: \n50:     # Ensure key stats aren't invalid\n51:     df_merged = df_merged.dropna(\n52:         subset=[\"PTS\", \"AST\", \"TRB\", \"FG%\"]\n53:     )\n54:     return df_merged",
            "mapping": [
                {
                    "summaryComponent": "retrieves and processes NBA player per-game",
                    "codeSegments": [
                        {
                            "code": "df_reg = pd.read_html(base_url_reg, header=0)[0]",
                            "line": 30
                        },
                        {
                            "code": "df_reg = df_reg[df_reg[\"Player\"] != \"Player\"]  # remove repeated header rows",
                            "line": 31
                        },
                        {
                            "code": "df_reg[\"Year\"] = year",
                            "line": 32
                        },
                        {
                            "code": "df_reg = df_reg[\n    [\"Player\", \"Year\", \"PTS\", \"AST\", \"TRB\", \"FG%\"]\n]  # Keep only specified columns",
                            "line": 34
                        }
                    ]
                },
                {
                    "summaryComponent": "and advanced statistics",
                    "codeSegments": [
                        {
                            "code": "df_adv = pd.read_html(base_url_adv, header=0)[0]",
                            "line": 39
                        },
                        {
                            "code": "df_adv = df_adv[df_adv[\"Player\"] != \"Player\"]  # remove repeated header rows",
                            "line": 40
                        },
                        {
                            "code": "df_adv[\"Year\"] = year",
                            "line": 41
                        },
                        {
                            "code": "adv_cols = [col for col in df_adv.columns if col not in [\"Player\", \"Year\", \"Tm\"]]",
                            "line": 44
                        },
                        {
                            "code": "df_adv = df_adv[[\"Player\", \"Year\"] + adv_cols]",
                            "line": 45
                        }
                    ]
                },
                {
                    "summaryComponent": "for a given year",
                    "codeSegments": [
                        {
                            "code": "def scrape_season_stats(year):",
                            "line": 22
                        },
                        {
                            "code": "f\"https://www.basketball-reference.com/leagues/NBA_{year}_per_game.html\"",
                            "line": 24
                        },
                        {
                            "code": "f\"https://www.basketball-reference.com/leagues/NBA_{year}_advanced.html\"",
                            "line": 27
                        }
                    ]
                },
                {
                    "summaryComponent": "from Basketball Reference",
                    "codeSegments": [
                        {
                            "code": "f\"https://www.basketball-reference.com/leagues/NBA_{year}_per_game.html\"",
                            "line": 24
                        },
                        {
                            "code": "f\"https://www.basketball-reference.com/leagues/NBA_{year}_advanced.html\"",
                            "line": 27
                        }
                    ]
                },
                {
                    "summaryComponent": "merging both datasets",
                    "codeSegments": [
                        {
                            "code": "df_merged = pd.merge(df_reg, df_adv, on=[\"Player\", \"Year\"], how=\"inner\")",
                            "line": 48
                        }
                    ]
                }
            ]
        },
        "id": "F8sRUMfjjQmsQM0cHUK7"
    },
    {
        "source": "backend",
        "event": "map_summary_code",
        "timestamp": "2025-08-24 11:50:13.000",
        "data": {
            "summary": "• Fetches NBA per-game and advanced stats for a given year\n• Cleans and filters the data\n• Merges per-game and advanced stats on Player and Year\n• Returns selected player statistics",
            "code": "22: def scrape_season_stats(year):\n23:     base_url_reg = (\n24:         f\"https://www.basketball-reference.com/leagues/NBA_{year}_per_game.html\"\n25:     )\n26:     base_url_adv = (\n27:         f\"https://www.basketball-reference.com/leagues/NBA_{year}_advanced.html\"\n28:     )\n29:     # Scrape per-game stats\n30:     df_reg = pd.read_html(base_url_reg, header=0)[0]\n31:     df_reg = df_reg[df_reg[\"Player\"] != \"Player\"]  # remove repeated header rows\n32:     df_reg[\"Year\"] = year\n33: \n34:     df_reg = df_reg[\n35:         [\"Player\", \"Year\", \"PTS\", \"AST\", \"TRB\", \"FG%\"]\n36:     ]  # Keep only specified columns\n37: \n38:     # Scrape advanced stats\n39:     df_adv = pd.read_html(base_url_adv, header=0)[0]\n40:     df_adv = df_adv[df_adv[\"Player\"] != \"Player\"]  # remove repeated header rows\n41:     df_adv[\"Year\"] = year\n42:     # Keep only Player, Year, and all advanced stats columns except team totals\n43:     # Remove duplicate columns before merging\n44:     adv_cols = [col for col in df_adv.columns if col not in [\"Player\", \"Year\", \"Tm\"]]\n45:     df_adv = df_adv[[\"Player\", \"Year\"] + adv_cols]\n46: \n47:     # Merge per-game and advanced stats on Player and Year\n48:     df_merged = pd.merge(df_reg, df_adv, on=[\"Player\", \"Year\"], how=\"inner\")\n49: \n50:     # Ensure key stats aren't invalid\n51:     df_merged = df_merged.dropna(\n52:         subset=[\"PTS\", \"AST\", \"TRB\", \"FG%\"]\n53:     )\n54:     return df_merged",
            "mapping": [
                {
                    "summaryComponent": "Fetches NBA per-game and advanced stats for a given year",
                    "codeSegments": [
                        {
                            "code": "df_reg = pd.read_html(base_url_reg, header=0)[0]",
                            "line": 30
                        },
                        {
                            "code": "df_adv = pd.read_html(base_url_adv, header=0)[0]",
                            "line": 39
                        }
                    ]
                },
                {
                    "summaryComponent": "Cleans and filters the data",
                    "codeSegments": [
                        {
                            "code": "df_reg = df_reg[df_reg[\"Player\"] != \"Player\"]  # remove repeated header rows",
                            "line": 31
                        },
                        {
                            "code": "df_reg = df_reg[\n    [\"Player\", \"Year\", \"PTS\", \"AST\", \"TRB\", \"FG%\"]\n]",
                            "line": 34
                        },
                        {
                            "code": "df_adv = df_adv[df_adv[\"Player\"] != \"Player\"]  # remove repeated header rows",
                            "line": 40
                        },
                        {
                            "code": "adv_cols = [col for col in df_adv.columns if col not in [\"Player\", \"Year\", \"Tm\"]]",
                            "line": 44
                        },
                        {
                            "code": "df_adv = df_adv[[\"Player\", \"Year\"] + adv_cols]",
                            "line": 45
                        },
                        {
                            "code": "df_merged = df_merged.dropna(\n    subset=[\"PTS\", \"AST\", \"TRB\", \"FG%\"]\n)",
                            "line": 51
                        }
                    ]
                },
                {
                    "summaryComponent": "Merges per-game and advanced stats on Player and Year",
                    "codeSegments": [
                        {
                            "code": "df_merged = pd.merge(df_reg, df_adv, on=[\"Player\", \"Year\"], how=\"inner\")",
                            "line": 48
                        }
                    ]
                },
                {
                    "summaryComponent": "Returns selected player statistics",
                    "codeSegments": [
                        {
                            "code": "return df_merged",
                            "line": 54
                        }
                    ]
                }
            ]
        },
        "id": "kJ09vH6xuStvDjFzPmFy"
    },
    {
        "source": "backend",
        "event": "map_summary_code",
        "timestamp": "2025-08-24 11:50:14.000",
        "data": {
            "summary": "The function scrape_season_stats downloads both NBA per-game and advanced statistics for a specified year from Basketball Reference. It cleans the data by removing repeated header rows and keeps only relevant columns such as player name, year, points, assists, rebounds, and field goal percentage from the per-game stats, and all advanced stats except team totals from the advanced stats. The function merges these datasets on player and year, ensures that rows with missing key stats are excluded, and returns the processed DataFrame.",
            "code": "22: def scrape_season_stats(year):\n23:     base_url_reg = (\n24:         f\"https://www.basketball-reference.com/leagues/NBA_{year}_per_game.html\"\n25:     )\n26:     base_url_adv = (\n27:         f\"https://www.basketball-reference.com/leagues/NBA_{year}_advanced.html\"\n28:     )\n29:     # Scrape per-game stats\n30:     df_reg = pd.read_html(base_url_reg, header=0)[0]\n31:     df_reg = df_reg[df_reg[\"Player\"] != \"Player\"]  # remove repeated header rows\n32:     df_reg[\"Year\"] = year\n33: \n34:     df_reg = df_reg[\n35:         [\"Player\", \"Year\", \"PTS\", \"AST\", \"TRB\", \"FG%\"]\n36:     ]  # Keep only specified columns\n37: \n38:     # Scrape advanced stats\n39:     df_adv = pd.read_html(base_url_adv, header=0)[0]\n40:     df_adv = df_adv[df_adv[\"Player\"] != \"Player\"]  # remove repeated header rows\n41:     df_adv[\"Year\"] = year\n42:     # Keep only Player, Year, and all advanced stats columns except team totals\n43:     # Remove duplicate columns before merging\n44:     adv_cols = [col for col in df_adv.columns if col not in [\"Player\", \"Year\", \"Tm\"]]\n45:     df_adv = df_adv[[\"Player\", \"Year\"] + adv_cols]\n46: \n47:     # Merge per-game and advanced stats on Player and Year\n48:     df_merged = pd.merge(df_reg, df_adv, on=[\"Player\", \"Year\"], how=\"inner\")\n49: \n50:     # Ensure key stats aren't invalid\n51:     df_merged = df_merged.dropna(\n52:         subset=[\"PTS\", \"AST\", \"TRB\", \"FG%\"]\n53:     )\n54:     return df_merged",
            "mapping": [
                {
                    "summaryComponent": "The function scrape_season_stats",
                    "codeSegments": [
                        {
                            "code": "def scrape_season_stats(year):",
                            "line": 22
                        }
                    ]
                },
                {
                    "summaryComponent": "downloads both NBA per-game and advanced statistics for a specified year from Basketball Reference",
                    "codeSegments": [
                        {
                            "code": "base_url_reg = (",
                            "line": 23
                        },
                        {
                            "code": "f\"https://www.basketball-reference.com/leagues/NBA_{year}_per_game.html\"",
                            "line": 24
                        },
                        {
                            "code": "base_url_adv = (",
                            "line": 26
                        },
                        {
                            "code": "f\"https://www.basketball-reference.com/leagues/NBA_{year}_advanced.html\"",
                            "line": 27
                        },
                        {
                            "code": "df_reg = pd.read_html(base_url_reg, header=0)[0]",
                            "line": 30
                        },
                        {
                            "code": "df_adv = pd.read_html(base_url_adv, header=0)[0]",
                            "line": 39
                        }
                    ]
                },
                {
                    "summaryComponent": "cleans the data by removing repeated header rows",
                    "codeSegments": [
                        {
                            "code": "df_reg = df_reg[df_reg[\"Player\"] != \"Player\"]  # remove repeated header rows",
                            "line": 31
                        },
                        {
                            "code": "df_adv = df_adv[df_adv[\"Player\"] != \"Player\"]  # remove repeated header rows",
                            "line": 40
                        }
                    ]
                },
                {
                    "summaryComponent": "keeps only relevant columns such as player name, year, points, assists, rebounds, and field goal percentage from the per-game stats",
                    "codeSegments": [
                        {
                            "code": "df_reg = df_reg[",
                            "line": 34
                        },
                        {
                            "code": "[\"Player\", \"Year\", \"PTS\", \"AST\", \"TRB\", \"FG%\"]",
                            "line": 35
                        }
                    ]
                },
                {
                    "summaryComponent": "and all advanced stats except team totals from the advanced stats",
                    "codeSegments": [
                        {
                            "code": "adv_cols = [col for col in df_adv.columns if col not in [\"Player\", \"Year\", \"Tm\"]]",
                            "line": 44
                        },
                        {
                            "code": "df_adv = df_adv[[\"Player\", \"Year\"] + adv_cols]",
                            "line": 45
                        }
                    ]
                },
                {
                    "summaryComponent": "The function merges these datasets on player and year",
                    "codeSegments": [
                        {
                            "code": "df_merged = pd.merge(df_reg, df_adv, on=[\"Player\", \"Year\"], how=\"inner\")",
                            "line": 48
                        }
                    ]
                },
                {
                    "summaryComponent": "ensures that rows with missing key stats are excluded",
                    "codeSegments": [
                        {
                            "code": "df_merged = df_merged.dropna(",
                            "line": 51
                        },
                        {
                            "code": "subset=[\"PTS\", \"AST\", \"TRB\", \"FG%\"]",
                            "line": 52
                        }
                    ]
                },
                {
                    "summaryComponent": "and returns the processed DataFrame",
                    "codeSegments": [
                        {
                            "code": "return df_merged",
                            "line": 54
                        }
                    ]
                }
            ]
        },
        "id": "02oawhwonQ8E9inAR7N7"
    },
    {
        "source": "backend",
        "event": "map_summary_code",
        "timestamp": "2025-08-24 11:50:14.000",
        "data": {
            "summary": "• Constructs the URLs for the NBA per-game and advanced stats pages for the specified year\n• Reads the first HTML tables from both pages into DataFrames\n• Cleans both DataFrames:\n  ◦ Removes rows where the 'Player' column equals 'Player' (eliminating repeated headers)\n  ◦ Adds a 'Year' column to indicate the season\n• Filters the per-game DataFrame to keep only the following columns:\n  ◦ Player, Year, PTS, AST, TRB, FG%\n• Filters the advanced stats DataFrame to keep Player, Year, and all advanced stats columns except team totals\n• Merges the per-game and advanced stats DataFrames on Player and Year\n• Drops rows with missing values in any of the key stat columns (PTS, AST, TRB, FG%)\n• Returns the processed DataFrame containing clean, relevant, and merged player statistics for the given year",
            "code": "22: def scrape_season_stats(year):\n23:     base_url_reg = (\n24:         f\"https://www.basketball-reference.com/leagues/NBA_{year}_per_game.html\"\n25:     )\n26:     base_url_adv = (\n27:         f\"https://www.basketball-reference.com/leagues/NBA_{year}_advanced.html\"\n28:     )\n29:     # Scrape per-game stats\n30:     df_reg = pd.read_html(base_url_reg, header=0)[0]\n31:     df_reg = df_reg[df_reg[\"Player\"] != \"Player\"]  # remove repeated header rows\n32:     df_reg[\"Year\"] = year\n33: \n34:     df_reg = df_reg[\n35:         [\"Player\", \"Year\", \"PTS\", \"AST\", \"TRB\", \"FG%\"]\n36:     ]  # Keep only specified columns\n37: \n38:     # Scrape advanced stats\n39:     df_adv = pd.read_html(base_url_adv, header=0)[0]\n40:     df_adv = df_adv[df_adv[\"Player\"] != \"Player\"]  # remove repeated header rows\n41:     df_adv[\"Year\"] = year\n42:     # Keep only Player, Year, and all advanced stats columns except team totals\n43:     # Remove duplicate columns before merging\n44:     adv_cols = [col for col in df_adv.columns if col not in [\"Player\", \"Year\", \"Tm\"]]\n45:     df_adv = df_adv[[\"Player\", \"Year\"] + adv_cols]\n46: \n47:     # Merge per-game and advanced stats on Player and Year\n48:     df_merged = pd.merge(df_reg, df_adv, on=[\"Player\", \"Year\"], how=\"inner\")\n49: \n50:     # Ensure key stats aren't invalid\n51:     df_merged = df_merged.dropna(\n52:         subset=[\"PTS\", \"AST\", \"TRB\", \"FG%\"]\n53:     )\n54:     return df_merged",
            "mapping": [
                {
                    "summaryComponent": "Constructs the URLs for the NBA per-game and advanced stats pages for the specified year",
                    "codeSegments": [
                        {
                            "code": "base_url_reg = (\n    f\"https://www.basketball-reference.com/leagues/NBA_{year}_per_game.html\"\n)",
                            "line": 23
                        },
                        {
                            "code": "base_url_adv = (\n    f\"https://www.basketball-reference.com/leagues/NBA_{year}_advanced.html\"\n)",
                            "line": 26
                        }
                    ]
                },
                {
                    "summaryComponent": "Reads the first HTML tables from both pages into DataFrames",
                    "codeSegments": [
                        {
                            "code": "df_reg = pd.read_html(base_url_reg, header=0)[0]",
                            "line": 30
                        },
                        {
                            "code": "df_adv = pd.read_html(base_url_adv, header=0)[0]",
                            "line": 39
                        }
                    ]
                },
                {
                    "summaryComponent": "Removes rows where the 'Player' column equals 'Player' (eliminating repeated headers)",
                    "codeSegments": [
                        {
                            "code": "df_reg = df_reg[df_reg[\"Player\"] != \"Player\"]  # remove repeated header rows",
                            "line": 31
                        },
                        {
                            "code": "df_adv = df_adv[df_adv[\"Player\"] != \"Player\"]  # remove repeated header rows",
                            "line": 40
                        }
                    ]
                },
                {
                    "summaryComponent": "Adds a 'Year' column to indicate the season",
                    "codeSegments": [
                        {
                            "code": "df_reg[\"Year\"] = year",
                            "line": 32
                        },
                        {
                            "code": "df_adv[\"Year\"] = year",
                            "line": 41
                        }
                    ]
                },
                {
                    "summaryComponent": "Filters the per-game DataFrame to keep only the following columns:",
                    "codeSegments": [
                        {
                            "code": "df_reg = df_reg[\n    [\"Player\", \"Year\", \"PTS\", \"AST\", \"TRB\", \"FG%\"]\n]",
                            "line": 34
                        }
                    ]
                },
                {
                    "summaryComponent": "Player, Year, PTS, AST, TRB, FG%",
                    "codeSegments": [
                        {
                            "code": "[\"Player\", \"Year\", \"PTS\", \"AST\", \"TRB\", \"FG%\"]",
                            "line": 35
                        }
                    ]
                },
                {
                    "summaryComponent": "Filters the advanced stats DataFrame to keep Player, Year, and all advanced stats columns except team totals",
                    "codeSegments": [
                        {
                            "code": "adv_cols = [col for col in df_adv.columns if col not in [\"Player\", \"Year\", \"Tm\"]]",
                            "line": 44
                        },
                        {
                            "code": "df_adv = df_adv[[\"Player\", \"Year\"] + adv_cols]",
                            "line": 45
                        }
                    ]
                },
                {
                    "summaryComponent": "Merges the per-game and advanced stats DataFrames on Player and Year",
                    "codeSegments": [
                        {
                            "code": "df_merged = pd.merge(df_reg, df_adv, on=[\"Player\", \"Year\"], how=\"inner\")",
                            "line": 48
                        }
                    ]
                },
                {
                    "summaryComponent": "Drops rows with missing values in any of the key stat columns (PTS, AST, TRB, FG%)",
                    "codeSegments": [
                        {
                            "code": "df_merged = df_merged.dropna(\n    subset=[\"PTS\", \"AST\", \"TRB\", \"FG%\"]\n)",
                            "line": 51
                        }
                    ]
                },
                {
                    "summaryComponent": "Returns the processed DataFrame containing clean, relevant, and merged player statistics for the given year",
                    "codeSegments": [
                        {
                            "code": "return df_merged",
                            "line": 54
                        }
                    ]
                }
            ]
        },
        "id": "ILb2SOKqeJa28cyK2eiK"
    },
    {
        "source": "backend",
        "event": "map_summary_code",
        "timestamp": "2025-08-24 11:50:14.000",
        "data": {
            "summary": "• Downloads per-game and advanced NBA stats for a specified year from Basketball Reference\n• Cleans the data:\n  ◦ Removes repeated header rows\n  ◦ Adds the year as a column\n• Filters per-game stats to keep only Player, Year, PTS, AST, TRB, and FG% columns\n• Filters advanced stats to keep Player, Year, and all advanced stats columns except team totals\n• Merges per-game and advanced stats on Player and Year\n• Drops rows with missing values in key stats\n• Returns the cleaned and merged DataFrame",
            "code": "22: def scrape_season_stats(year):\n23:     base_url_reg = (\n24:         f\"https://www.basketball-reference.com/leagues/NBA_{year}_per_game.html\"\n25:     )\n26:     base_url_adv = (\n27:         f\"https://www.basketball-reference.com/leagues/NBA_{year}_advanced.html\"\n28:     )\n29:     # Scrape per-game stats\n30:     df_reg = pd.read_html(base_url_reg, header=0)[0]\n31:     df_reg = df_reg[df_reg[\"Player\"] != \"Player\"]  # remove repeated header rows\n32:     df_reg[\"Year\"] = year\n33: \n34:     df_reg = df_reg[\n35:         [\"Player\", \"Year\", \"PTS\", \"AST\", \"TRB\", \"FG%\"]\n36:     ]  # Keep only specified columns\n37: \n38:     # Scrape advanced stats\n39:     df_adv = pd.read_html(base_url_adv, header=0)[0]\n40:     df_adv = df_adv[df_adv[\"Player\"] != \"Player\"]  # remove repeated header rows\n41:     df_adv[\"Year\"] = year\n42:     # Keep only Player, Year, and all advanced stats columns except team totals\n43:     # Remove duplicate columns before merging\n44:     adv_cols = [col for col in df_adv.columns if col not in [\"Player\", \"Year\", \"Tm\"]]\n45:     df_adv = df_adv[[\"Player\", \"Year\"] + adv_cols]\n46: \n47:     # Merge per-game and advanced stats on Player and Year\n48:     df_merged = pd.merge(df_reg, df_adv, on=[\"Player\", \"Year\"], how=\"inner\")\n49: \n50:     # Ensure key stats aren't invalid\n51:     df_merged = df_merged.dropna(\n52:         subset=[\"PTS\", \"AST\", \"TRB\", \"FG%\"]\n53:     )\n54:     return df_merged",
            "mapping": [
                {
                    "summaryComponent": "Downloads per-game and advanced NBA stats for a specified year from Basketball Reference",
                    "codeSegments": [
                        {
                            "code": "base_url_reg = (\n    f\"https://www.basketball-reference.com/leagues/NBA_{year}_per_game.html\"\n)",
                            "line": 23
                        },
                        {
                            "code": "base_url_adv = (\n    f\"https://www.basketball-reference.com/leagues/NBA_{year}_advanced.html\"\n)",
                            "line": 26
                        },
                        {
                            "code": "df_reg = pd.read_html(base_url_reg, header=0)[0]",
                            "line": 30
                        },
                        {
                            "code": "df_adv = pd.read_html(base_url_adv, header=0)[0]",
                            "line": 39
                        }
                    ]
                },
                {
                    "summaryComponent": "Cleans the data:",
                    "codeSegments": []
                },
                {
                    "summaryComponent": "Removes repeated header rows",
                    "codeSegments": [
                        {
                            "code": "df_reg = df_reg[df_reg[\"Player\"] != \"Player\"]  # remove repeated header rows",
                            "line": 31
                        },
                        {
                            "code": "df_adv = df_adv[df_adv[\"Player\"] != \"Player\"]  # remove repeated header rows",
                            "line": 40
                        }
                    ]
                },
                {
                    "summaryComponent": "Adds the year as a column",
                    "codeSegments": [
                        {
                            "code": "df_reg[\"Year\"] = year",
                            "line": 32
                        },
                        {
                            "code": "df_adv[\"Year\"] = year",
                            "line": 41
                        }
                    ]
                },
                {
                    "summaryComponent": "Filters per-game stats to keep only Player, Year, PTS, AST, TRB, and FG% columns",
                    "codeSegments": [
                        {
                            "code": "df_reg = df_reg[\n    [\"Player\", \"Year\", \"PTS\", \"AST\", \"TRB\", \"FG%\"]\n]",
                            "line": 34
                        }
                    ]
                },
                {
                    "summaryComponent": "Filters advanced stats to keep Player, Year, and all advanced stats columns except team totals",
                    "codeSegments": [
                        {
                            "code": "adv_cols = [col for col in df_adv.columns if col not in [\"Player\", \"Year\", \"Tm\"]]",
                            "line": 44
                        },
                        {
                            "code": "df_adv = df_adv[[\"Player\", \"Year\"] + adv_cols]",
                            "line": 45
                        }
                    ]
                },
                {
                    "summaryComponent": "Merges per-game and advanced stats on Player and Year",
                    "codeSegments": [
                        {
                            "code": "df_merged = pd.merge(df_reg, df_adv, on=[\"Player\", \"Year\"], how=\"inner\")",
                            "line": 48
                        }
                    ]
                },
                {
                    "summaryComponent": "Drops rows with missing values in key stats",
                    "codeSegments": [
                        {
                            "code": "df_merged = df_merged.dropna(\n    subset=[\"PTS\", \"AST\", \"TRB\", \"FG%\"]\n)",
                            "line": 51
                        }
                    ]
                },
                {
                    "summaryComponent": "Returns the cleaned and merged DataFrame",
                    "codeSegments": [
                        {
                            "code": "return df_merged",
                            "line": 54
                        }
                    ]
                }
            ]
        },
        "id": "RRj8FdO8lpcWLeYDvZzx"
    },
    {
        "source": "frontend",
        "event": "autotransit_section",
        "timestamp": "2025-08-24 11:50:14.000",
        "data": {
            "before_section_id": "f9c48e11-77ac-4181-9eab-5bf14b4f8670",
            "after_section_id": "227aed7c-31ad-4ebc-8402-b2a1bdeaddf0"
        },
        "id": "RnoWLNqu3GB50Vs9Je7s"
    },
    {
        "source": "backend",
        "event": "map_summary_code",
        "timestamp": "2025-08-24 11:50:14.000",
        "data": {
            "summary": "The scrape_season_stats function takes a year as input and constructs URLs for that season's NBA per-game and advanced statistics pages on Basketball Reference. It reads the HTML tables into DataFrames, removes any rows where the 'Player' column contains the header string (to eliminate repeated headers), and adds a 'Year' column. The function then filters the per-game DataFrame to retain only the columns for player name, year, points, assists, rebounds, and field goal percentage, and filters the advanced stats DataFrame to keep player name, year, and all advanced stats except team totals. It merges the per-game and advanced stats DataFrames on player and year, drops any rows with missing values in the key statistics, and returns the cleaned, merged DataFrame for further analysis.",
            "code": "22: def scrape_season_stats(year):\n23:     base_url_reg = (\n24:         f\"https://www.basketball-reference.com/leagues/NBA_{year}_per_game.html\"\n25:     )\n26:     base_url_adv = (\n27:         f\"https://www.basketball-reference.com/leagues/NBA_{year}_advanced.html\"\n28:     )\n29:     # Scrape per-game stats\n30:     df_reg = pd.read_html(base_url_reg, header=0)[0]\n31:     df_reg = df_reg[df_reg[\"Player\"] != \"Player\"]  # remove repeated header rows\n32:     df_reg[\"Year\"] = year\n33: \n34:     df_reg = df_reg[\n35:         [\"Player\", \"Year\", \"PTS\", \"AST\", \"TRB\", \"FG%\"]\n36:     ]  # Keep only specified columns\n37: \n38:     # Scrape advanced stats\n39:     df_adv = pd.read_html(base_url_adv, header=0)[0]\n40:     df_adv = df_adv[df_adv[\"Player\"] != \"Player\"]  # remove repeated header rows\n41:     df_adv[\"Year\"] = year\n42:     # Keep only Player, Year, and all advanced stats columns except team totals\n43:     # Remove duplicate columns before merging\n44:     adv_cols = [col for col in df_adv.columns if col not in [\"Player\", \"Year\", \"Tm\"]]\n45:     df_adv = df_adv[[\"Player\", \"Year\"] + adv_cols]\n46: \n47:     # Merge per-game and advanced stats on Player and Year\n48:     df_merged = pd.merge(df_reg, df_adv, on=[\"Player\", \"Year\"], how=\"inner\")\n49: \n50:     # Ensure key stats aren't invalid\n51:     df_merged = df_merged.dropna(\n52:         subset=[\"PTS\", \"AST\", \"TRB\", \"FG%\"]\n53:     )\n54:     return df_merged",
            "mapping": [
                {
                    "summaryComponent": "The scrape_season_stats function takes a year as input",
                    "codeSegments": [
                        {
                            "code": "def scrape_season_stats(year):",
                            "line": 22
                        }
                    ]
                },
                {
                    "summaryComponent": "constructs URLs for that season's NBA per-game and advanced statistics pages on Basketball Reference",
                    "codeSegments": [
                        {
                            "code": "base_url_reg = (",
                            "line": 23
                        },
                        {
                            "code": "f\"https://www.basketball-reference.com/leagues/NBA_{year}_per_game.html\"",
                            "line": 24
                        },
                        {
                            "code": "base_url_adv = (",
                            "line": 26
                        },
                        {
                            "code": "f\"https://www.basketball-reference.com/leagues/NBA_{year}_advanced.html\"",
                            "line": 27
                        }
                    ]
                },
                {
                    "summaryComponent": "It reads the HTML tables into DataFrames",
                    "codeSegments": [
                        {
                            "code": "df_reg = pd.read_html(base_url_reg, header=0)[0]",
                            "line": 30
                        },
                        {
                            "code": "df_adv = pd.read_html(base_url_adv, header=0)[0]",
                            "line": 39
                        }
                    ]
                },
                {
                    "summaryComponent": "removes any rows where the 'Player' column contains the header string (to eliminate repeated headers)",
                    "codeSegments": [
                        {
                            "code": "df_reg = df_reg[df_reg[\"Player\"] != \"Player\"]  # remove repeated header rows",
                            "line": 31
                        },
                        {
                            "code": "df_adv = df_adv[df_adv[\"Player\"] != \"Player\"]  # remove repeated header rows",
                            "line": 40
                        }
                    ]
                },
                {
                    "summaryComponent": "adds a 'Year' column",
                    "codeSegments": [
                        {
                            "code": "df_reg[\"Year\"] = year",
                            "line": 32
                        },
                        {
                            "code": "df_adv[\"Year\"] = year",
                            "line": 41
                        }
                    ]
                },
                {
                    "summaryComponent": "filters the per-game DataFrame to retain only the columns for player name, year, points, assists, rebounds, and field goal percentage",
                    "codeSegments": [
                        {
                            "code": "df_reg = df_reg[",
                            "line": 34
                        },
                        {
                            "code": "[\"Player\", \"Year\", \"PTS\", \"AST\", \"TRB\", \"FG%\"]",
                            "line": 35
                        }
                    ]
                },
                {
                    "summaryComponent": "filters the advanced stats DataFrame to keep player name, year, and all advanced stats except team totals",
                    "codeSegments": [
                        {
                            "code": "adv_cols = [col for col in df_adv.columns if col not in [\"Player\", \"Year\", \"Tm\"]]",
                            "line": 44
                        },
                        {
                            "code": "df_adv = df_adv[[\"Player\", \"Year\"] + adv_cols]",
                            "line": 45
                        }
                    ]
                },
                {
                    "summaryComponent": "It merges the per-game and advanced stats DataFrames on player and year",
                    "codeSegments": [
                        {
                            "code": "df_merged = pd.merge(df_reg, df_adv, on=[\"Player\", \"Year\"], how=\"inner\")",
                            "line": 48
                        }
                    ]
                },
                {
                    "summaryComponent": "drops any rows with missing values in the key statistics",
                    "codeSegments": [
                        {
                            "code": "df_merged = df_merged.dropna(",
                            "line": 51
                        },
                        {
                            "code": "subset=[\"PTS\", \"AST\", \"TRB\", \"FG%\"]",
                            "line": 52
                        }
                    ]
                },
                {
                    "summaryComponent": "returns the cleaned, merged DataFrame for further analysis",
                    "codeSegments": [
                        {
                            "code": "return df_merged",
                            "line": 54
                        }
                    ]
                }
            ]
        },
        "id": "jJlewAr2FWybpcbvM1oA"
    },
    {
        "source": "frontend",
        "event": "create_new_section",
        "timestamp": "2025-08-24 11:50:14.000",
        "data": {
            "section_data": {
                "selectedDetailLevel": "medium",
                "editPromptStructured": null,
                "createdAt": 1756065014000,
                "metadata": {
                    "originalCode": "def scrape_season_stats(year):\n    base_url_reg = (\n        f\"https://www.basketball-reference.com/leagues/NBA_{year}_per_game.html\"\n    )\n    base_url_adv = (\n        f\"https://www.basketball-reference.com/leagues/NBA_{year}_advanced.html\"\n    )\n    # Scrape per-game stats\n    df_reg = pd.read_html(base_url_reg, header=0)[0]\n    df_reg = df_reg[df_reg[\"Player\"] != \"Player\"]  # remove repeated header rows\n    df_reg[\"Year\"] = year\n\n    df_reg = df_reg[\n        [\"Player\", \"Year\", \"PTS\", \"AST\", \"TRB\", \"FG%\"]\n    ]  # Keep only specified columns\n\n    # Scrape advanced stats\n    df_adv = pd.read_html(base_url_adv, header=0)[0]\n    df_adv = df_adv[df_adv[\"Player\"] != \"Player\"]  # remove repeated header rows\n    df_adv[\"Year\"] = year\n    # Keep only Player, Year, and all advanced stats columns except team totals\n    # Remove duplicate columns before merging\n    adv_cols = [col for col in df_adv.columns if col not in [\"Player\", \"Year\", \"Tm\"]]\n    df_adv = df_adv[[\"Player\", \"Year\"] + adv_cols]\n\n    # Merge per-game and advanced stats on Player and Year\n    df_merged = pd.merge(df_reg, df_adv, on=[\"Player\", \"Year\"], how=\"inner\")\n\n    # Ensure key stats aren't invalid\n    df_merged = df_merged.dropna(\n        subset=[\"PTS\", \"AST\", \"TRB\", \"FG%\"]\n    )\n    return df_merged",
                    "id": "227aed7c-31ad-4ebc-8402-b2a1bdeaddf0",
                    "filename": "scraper.py",
                    "fullPath": "/project/workspace/scraper.py",
                    "offset": 652
                },
                "summaryData": {
                    "medium_structured": "• Downloads per-game and advanced NBA stats for a specified year from Basketball Reference\n• Cleans the data:\n  ◦ Removes repeated header rows\n  ◦ Adds the year as a column\n• Filters per-game stats to keep only Player, Year, PTS, AST, TRB, and FG% columns\n• Filters advanced stats to keep Player, Year, and all advanced stats columns except team totals\n• Merges per-game and advanced stats on Player and Year\n• Drops rows with missing values in key stats\n• Returns the cleaned and merged DataFrame",
                    "low_unstructured": "This function retrieves and processes NBA player per-game and advanced statistics for a given year from Basketball Reference, merging both datasets.",
                    "high_structured": "• Constructs the URLs for the NBA per-game and advanced stats pages for the specified year\n• Reads the first HTML tables from both pages into DataFrames\n• Cleans both DataFrames:\n  ◦ Removes rows where the 'Player' column equals 'Player' (eliminating repeated headers)\n  ◦ Adds a 'Year' column to indicate the season\n• Filters the per-game DataFrame to keep only the following columns:\n  ◦ Player, Year, PTS, AST, TRB, FG%\n• Filters the advanced stats DataFrame to keep Player, Year, and all advanced stats columns except team totals\n• Merges the per-game and advanced stats DataFrames on Player and Year\n• Drops rows with missing values in any of the key stat columns (PTS, AST, TRB, FG%)\n• Returns the processed DataFrame containing clean, relevant, and merged player statistics for the given year",
                    "low_structured": "• Fetches NBA per-game and advanced stats for a given year\n• Cleans and filters the data\n• Merges per-game and advanced stats on Player and Year\n• Returns selected player statistics",
                    "high_unstructured": "The scrape_season_stats function takes a year as input and constructs URLs for that season's NBA per-game and advanced statistics pages on Basketball Reference. It reads the HTML tables into DataFrames, removes any rows where the 'Player' column contains the header string (to eliminate repeated headers), and adds a 'Year' column. The function then filters the per-game DataFrame to retain only the columns for player name, year, points, assists, rebounds, and field goal percentage, and filters the advanced stats DataFrame to keep player name, year, and all advanced stats except team totals. It merges the per-game and advanced stats DataFrames on player and year, drops any rows with missing values in the key statistics, and returns the cleaned, merged DataFrame for further analysis.",
                    "medium_unstructured": "The function scrape_season_stats downloads both NBA per-game and advanced statistics for a specified year from Basketball Reference. It cleans the data by removing repeated header rows and keeps only relevant columns such as player name, year, points, assists, rebounds, and field goal percentage from the per-game stats, and all advanced stats except team totals from the advanced stats. The function merges these datasets on player and year, ensures that rows with missing key stats are excluded, and returns the processed DataFrame.",
                    "title": "Summary of scrape_season_stats(year) Function (with Advanced Stats Merging)"
                },
                "selectedStructured": "unstructured",
                "summaryMappings": {
                    "medium_structured": [
                        {
                            "summaryComponent": "Downloads per-game and advanced NBA stats for a specified year from Basketball Reference",
                            "codeSegments": [
                                {
                                    "code": "base_url_reg = (\n    f\"https://www.basketball-reference.com/leagues/NBA_{year}_per_game.html\"\n)",
                                    "line": 23
                                },
                                {
                                    "code": "base_url_adv = (\n    f\"https://www.basketball-reference.com/leagues/NBA_{year}_advanced.html\"\n)",
                                    "line": 26
                                },
                                {
                                    "code": "df_reg = pd.read_html(base_url_reg, header=0)[0]",
                                    "line": 30
                                },
                                {
                                    "code": "df_adv = pd.read_html(base_url_adv, header=0)[0]",
                                    "line": 39
                                }
                            ]
                        },
                        {
                            "summaryComponent": "Cleans the data:",
                            "codeSegments": []
                        },
                        {
                            "summaryComponent": "Removes repeated header rows",
                            "codeSegments": [
                                {
                                    "code": "df_reg = df_reg[df_reg[\"Player\"] != \"Player\"]  # remove repeated header rows",
                                    "line": 31
                                },
                                {
                                    "code": "df_adv = df_adv[df_adv[\"Player\"] != \"Player\"]  # remove repeated header rows",
                                    "line": 40
                                }
                            ]
                        },
                        {
                            "summaryComponent": "Adds the year as a column",
                            "codeSegments": [
                                {
                                    "code": "df_reg[\"Year\"] = year",
                                    "line": 32
                                },
                                {
                                    "code": "df_adv[\"Year\"] = year",
                                    "line": 41
                                }
                            ]
                        },
                        {
                            "summaryComponent": "Filters per-game stats to keep only Player, Year, PTS, AST, TRB, and FG% columns",
                            "codeSegments": [
                                {
                                    "code": "df_reg = df_reg[\n    [\"Player\", \"Year\", \"PTS\", \"AST\", \"TRB\", \"FG%\"]\n]",
                                    "line": 34
                                }
                            ]
                        },
                        {
                            "summaryComponent": "Filters advanced stats to keep Player, Year, and all advanced stats columns except team totals",
                            "codeSegments": [
                                {
                                    "code": "adv_cols = [col for col in df_adv.columns if col not in [\"Player\", \"Year\", \"Tm\"]]",
                                    "line": 44
                                },
                                {
                                    "code": "df_adv = df_adv[[\"Player\", \"Year\"] + adv_cols]",
                                    "line": 45
                                }
                            ]
                        },
                        {
                            "summaryComponent": "Merges per-game and advanced stats on Player and Year",
                            "codeSegments": [
                                {
                                    "code": "df_merged = pd.merge(df_reg, df_adv, on=[\"Player\", \"Year\"], how=\"inner\")",
                                    "line": 48
                                }
                            ]
                        },
                        {
                            "summaryComponent": "Drops rows with missing values in key stats",
                            "codeSegments": [
                                {
                                    "code": "df_merged = df_merged.dropna(\n    subset=[\"PTS\", \"AST\", \"TRB\", \"FG%\"]\n)",
                                    "line": 51
                                }
                            ]
                        },
                        {
                            "summaryComponent": "Returns the cleaned and merged DataFrame",
                            "codeSegments": [
                                {
                                    "code": "return df_merged",
                                    "line": 54
                                }
                            ]
                        }
                    ],
                    "high_structured": [
                        {
                            "summaryComponent": "Constructs the URLs for the NBA per-game and advanced stats pages for the specified year",
                            "codeSegments": [
                                {
                                    "code": "base_url_reg = (\n    f\"https://www.basketball-reference.com/leagues/NBA_{year}_per_game.html\"\n)",
                                    "line": 23
                                },
                                {
                                    "code": "base_url_adv = (\n    f\"https://www.basketball-reference.com/leagues/NBA_{year}_advanced.html\"\n)",
                                    "line": 26
                                }
                            ]
                        },
                        {
                            "summaryComponent": "Reads the first HTML tables from both pages into DataFrames",
                            "codeSegments": [
                                {
                                    "code": "df_reg = pd.read_html(base_url_reg, header=0)[0]",
                                    "line": 30
                                },
                                {
                                    "code": "df_adv = pd.read_html(base_url_adv, header=0)[0]",
                                    "line": 39
                                }
                            ]
                        },
                        {
                            "summaryComponent": "Removes rows where the 'Player' column equals 'Player' (eliminating repeated headers)",
                            "codeSegments": [
                                {
                                    "code": "df_reg = df_reg[df_reg[\"Player\"] != \"Player\"]  # remove repeated header rows",
                                    "line": 31
                                },
                                {
                                    "code": "df_adv = df_adv[df_adv[\"Player\"] != \"Player\"]  # remove repeated header rows",
                                    "line": 40
                                }
                            ]
                        },
                        {
                            "summaryComponent": "Adds a 'Year' column to indicate the season",
                            "codeSegments": [
                                {
                                    "code": "df_reg[\"Year\"] = year",
                                    "line": 32
                                },
                                {
                                    "code": "df_adv[\"Year\"] = year",
                                    "line": 41
                                }
                            ]
                        },
                        {
                            "summaryComponent": "Filters the per-game DataFrame to keep only the following columns:",
                            "codeSegments": [
                                {
                                    "code": "df_reg = df_reg[\n    [\"Player\", \"Year\", \"PTS\", \"AST\", \"TRB\", \"FG%\"]\n]",
                                    "line": 34
                                }
                            ]
                        },
                        {
                            "summaryComponent": "Player, Year, PTS, AST, TRB, FG%",
                            "codeSegments": [
                                {
                                    "code": "[\"Player\", \"Year\", \"PTS\", \"AST\", \"TRB\", \"FG%\"]",
                                    "line": 35
                                }
                            ]
                        },
                        {
                            "summaryComponent": "Filters the advanced stats DataFrame to keep Player, Year, and all advanced stats columns except team totals",
                            "codeSegments": [
                                {
                                    "code": "adv_cols = [col for col in df_adv.columns if col not in [\"Player\", \"Year\", \"Tm\"]]",
                                    "line": 44
                                },
                                {
                                    "code": "df_adv = df_adv[[\"Player\", \"Year\"] + adv_cols]",
                                    "line": 45
                                }
                            ]
                        },
                        {
                            "summaryComponent": "Merges the per-game and advanced stats DataFrames on Player and Year",
                            "codeSegments": [
                                {
                                    "code": "df_merged = pd.merge(df_reg, df_adv, on=[\"Player\", \"Year\"], how=\"inner\")",
                                    "line": 48
                                }
                            ]
                        },
                        {
                            "summaryComponent": "Drops rows with missing values in any of the key stat columns (PTS, AST, TRB, FG%)",
                            "codeSegments": [
                                {
                                    "code": "df_merged = df_merged.dropna(\n    subset=[\"PTS\", \"AST\", \"TRB\", \"FG%\"]\n)",
                                    "line": 51
                                }
                            ]
                        },
                        {
                            "summaryComponent": "Returns the processed DataFrame containing clean, relevant, and merged player statistics for the given year",
                            "codeSegments": [
                                {
                                    "code": "return df_merged",
                                    "line": 54
                                }
                            ]
                        }
                    ],
                    "low_structured": [
                        {
                            "summaryComponent": "Fetches NBA per-game and advanced stats for a given year",
                            "codeSegments": [
                                {
                                    "code": "df_reg = pd.read_html(base_url_reg, header=0)[0]",
                                    "line": 30
                                },
                                {
                                    "code": "df_adv = pd.read_html(base_url_adv, header=0)[0]",
                                    "line": 39
                                }
                            ]
                        },
                        {
                            "summaryComponent": "Cleans and filters the data",
                            "codeSegments": [
                                {
                                    "code": "df_reg = df_reg[df_reg[\"Player\"] != \"Player\"]  # remove repeated header rows",
                                    "line": 31
                                },
                                {
                                    "code": "df_reg = df_reg[\n    [\"Player\", \"Year\", \"PTS\", \"AST\", \"TRB\", \"FG%\"]\n]",
                                    "line": 34
                                },
                                {
                                    "code": "df_adv = df_adv[df_adv[\"Player\"] != \"Player\"]  # remove repeated header rows",
                                    "line": 40
                                },
                                {
                                    "code": "adv_cols = [col for col in df_adv.columns if col not in [\"Player\", \"Year\", \"Tm\"]]",
                                    "line": 44
                                },
                                {
                                    "code": "df_adv = df_adv[[\"Player\", \"Year\"] + adv_cols]",
                                    "line": 45
                                },
                                {
                                    "code": "df_merged = df_merged.dropna(\n    subset=[\"PTS\", \"AST\", \"TRB\", \"FG%\"]\n)",
                                    "line": 51
                                }
                            ]
                        },
                        {
                            "summaryComponent": "Merges per-game and advanced stats on Player and Year",
                            "codeSegments": [
                                {
                                    "code": "df_merged = pd.merge(df_reg, df_adv, on=[\"Player\", \"Year\"], how=\"inner\")",
                                    "line": 48
                                }
                            ]
                        },
                        {
                            "summaryComponent": "Returns selected player statistics",
                            "codeSegments": [
                                {
                                    "code": "return df_merged",
                                    "line": 54
                                }
                            ]
                        }
                    ],
                    "high_unstructured": [
                        {
                            "summaryComponent": "The scrape_season_stats function takes a year as input",
                            "codeSegments": [
                                {
                                    "code": "def scrape_season_stats(year):",
                                    "line": 22
                                }
                            ]
                        },
                        {
                            "summaryComponent": "constructs URLs for that season's NBA per-game and advanced statistics pages on Basketball Reference",
                            "codeSegments": [
                                {
                                    "code": "base_url_reg = (",
                                    "line": 23
                                },
                                {
                                    "code": "f\"https://www.basketball-reference.com/leagues/NBA_{year}_per_game.html\"",
                                    "line": 24
                                },
                                {
                                    "code": "base_url_adv = (",
                                    "line": 26
                                },
                                {
                                    "code": "f\"https://www.basketball-reference.com/leagues/NBA_{year}_advanced.html\"",
                                    "line": 27
                                }
                            ]
                        },
                        {
                            "summaryComponent": "It reads the HTML tables into DataFrames",
                            "codeSegments": [
                                {
                                    "code": "df_reg = pd.read_html(base_url_reg, header=0)[0]",
                                    "line": 30
                                },
                                {
                                    "code": "df_adv = pd.read_html(base_url_adv, header=0)[0]",
                                    "line": 39
                                }
                            ]
                        },
                        {
                            "summaryComponent": "removes any rows where the 'Player' column contains the header string (to eliminate repeated headers)",
                            "codeSegments": [
                                {
                                    "code": "df_reg = df_reg[df_reg[\"Player\"] != \"Player\"]  # remove repeated header rows",
                                    "line": 31
                                },
                                {
                                    "code": "df_adv = df_adv[df_adv[\"Player\"] != \"Player\"]  # remove repeated header rows",
                                    "line": 40
                                }
                            ]
                        },
                        {
                            "summaryComponent": "adds a 'Year' column",
                            "codeSegments": [
                                {
                                    "code": "df_reg[\"Year\"] = year",
                                    "line": 32
                                },
                                {
                                    "code": "df_adv[\"Year\"] = year",
                                    "line": 41
                                }
                            ]
                        },
                        {
                            "summaryComponent": "filters the per-game DataFrame to retain only the columns for player name, year, points, assists, rebounds, and field goal percentage",
                            "codeSegments": [
                                {
                                    "code": "df_reg = df_reg[",
                                    "line": 34
                                },
                                {
                                    "code": "[\"Player\", \"Year\", \"PTS\", \"AST\", \"TRB\", \"FG%\"]",
                                    "line": 35
                                }
                            ]
                        },
                        {
                            "summaryComponent": "filters the advanced stats DataFrame to keep player name, year, and all advanced stats except team totals",
                            "codeSegments": [
                                {
                                    "code": "adv_cols = [col for col in df_adv.columns if col not in [\"Player\", \"Year\", \"Tm\"]]",
                                    "line": 44
                                },
                                {
                                    "code": "df_adv = df_adv[[\"Player\", \"Year\"] + adv_cols]",
                                    "line": 45
                                }
                            ]
                        },
                        {
                            "summaryComponent": "It merges the per-game and advanced stats DataFrames on player and year",
                            "codeSegments": [
                                {
                                    "code": "df_merged = pd.merge(df_reg, df_adv, on=[\"Player\", \"Year\"], how=\"inner\")",
                                    "line": 48
                                }
                            ]
                        },
                        {
                            "summaryComponent": "drops any rows with missing values in the key statistics",
                            "codeSegments": [
                                {
                                    "code": "df_merged = df_merged.dropna(",
                                    "line": 51
                                },
                                {
                                    "code": "subset=[\"PTS\", \"AST\", \"TRB\", \"FG%\"]",
                                    "line": 52
                                }
                            ]
                        },
                        {
                            "summaryComponent": "returns the cleaned, merged DataFrame for further analysis",
                            "codeSegments": [
                                {
                                    "code": "return df_merged",
                                    "line": 54
                                }
                            ]
                        }
                    ],
                    "medium_unstructured": [
                        {
                            "summaryComponent": "The function scrape_season_stats",
                            "codeSegments": [
                                {
                                    "code": "def scrape_season_stats(year):",
                                    "line": 22
                                }
                            ]
                        },
                        {
                            "summaryComponent": "downloads both NBA per-game and advanced statistics for a specified year from Basketball Reference",
                            "codeSegments": [
                                {
                                    "code": "base_url_reg = (",
                                    "line": 23
                                },
                                {
                                    "code": "f\"https://www.basketball-reference.com/leagues/NBA_{year}_per_game.html\"",
                                    "line": 24
                                },
                                {
                                    "code": "base_url_adv = (",
                                    "line": 26
                                },
                                {
                                    "code": "f\"https://www.basketball-reference.com/leagues/NBA_{year}_advanced.html\"",
                                    "line": 27
                                },
                                {
                                    "code": "df_reg = pd.read_html(base_url_reg, header=0)[0]",
                                    "line": 30
                                },
                                {
                                    "code": "df_adv = pd.read_html(base_url_adv, header=0)[0]",
                                    "line": 39
                                }
                            ]
                        },
                        {
                            "summaryComponent": "cleans the data by removing repeated header rows",
                            "codeSegments": [
                                {
                                    "code": "df_reg = df_reg[df_reg[\"Player\"] != \"Player\"]  # remove repeated header rows",
                                    "line": 31
                                },
                                {
                                    "code": "df_adv = df_adv[df_adv[\"Player\"] != \"Player\"]  # remove repeated header rows",
                                    "line": 40
                                }
                            ]
                        },
                        {
                            "summaryComponent": "keeps only relevant columns such as player name, year, points, assists, rebounds, and field goal percentage from the per-game stats",
                            "codeSegments": [
                                {
                                    "code": "df_reg = df_reg[",
                                    "line": 34
                                },
                                {
                                    "code": "[\"Player\", \"Year\", \"PTS\", \"AST\", \"TRB\", \"FG%\"]",
                                    "line": 35
                                }
                            ]
                        },
                        {
                            "summaryComponent": "and all advanced stats except team totals from the advanced stats",
                            "codeSegments": [
                                {
                                    "code": "adv_cols = [col for col in df_adv.columns if col not in [\"Player\", \"Year\", \"Tm\"]]",
                                    "line": 44
                                },
                                {
                                    "code": "df_adv = df_adv[[\"Player\", \"Year\"] + adv_cols]",
                                    "line": 45
                                }
                            ]
                        },
                        {
                            "summaryComponent": "The function merges these datasets on player and year",
                            "codeSegments": [
                                {
                                    "code": "df_merged = pd.merge(df_reg, df_adv, on=[\"Player\", \"Year\"], how=\"inner\")",
                                    "line": 48
                                }
                            ]
                        },
                        {
                            "summaryComponent": "ensures that rows with missing key stats are excluded",
                            "codeSegments": [
                                {
                                    "code": "df_merged = df_merged.dropna(",
                                    "line": 51
                                },
                                {
                                    "code": "subset=[\"PTS\", \"AST\", \"TRB\", \"FG%\"]",
                                    "line": 52
                                }
                            ]
                        },
                        {
                            "summaryComponent": "and returns the processed DataFrame",
                            "codeSegments": [
                                {
                                    "code": "return df_merged",
                                    "line": 54
                                }
                            ]
                        }
                    ],
                    "low_unstructured": [
                        {
                            "summaryComponent": "retrieves and processes NBA player per-game",
                            "codeSegments": [
                                {
                                    "code": "df_reg = pd.read_html(base_url_reg, header=0)[0]",
                                    "line": 30
                                },
                                {
                                    "code": "df_reg = df_reg[df_reg[\"Player\"] != \"Player\"]  # remove repeated header rows",
                                    "line": 31
                                },
                                {
                                    "code": "df_reg[\"Year\"] = year",
                                    "line": 32
                                },
                                {
                                    "code": "df_reg = df_reg[\n    [\"Player\", \"Year\", \"PTS\", \"AST\", \"TRB\", \"FG%\"]\n]  # Keep only specified columns",
                                    "line": 34
                                }
                            ]
                        },
                        {
                            "summaryComponent": "and advanced statistics",
                            "codeSegments": [
                                {
                                    "code": "df_adv = pd.read_html(base_url_adv, header=0)[0]",
                                    "line": 39
                                },
                                {
                                    "code": "df_adv = df_adv[df_adv[\"Player\"] != \"Player\"]  # remove repeated header rows",
                                    "line": 40
                                },
                                {
                                    "code": "df_adv[\"Year\"] = year",
                                    "line": 41
                                },
                                {
                                    "code": "adv_cols = [col for col in df_adv.columns if col not in [\"Player\", \"Year\", \"Tm\"]]",
                                    "line": 44
                                },
                                {
                                    "code": "df_adv = df_adv[[\"Player\", \"Year\"] + adv_cols]",
                                    "line": 45
                                }
                            ]
                        },
                        {
                            "summaryComponent": "for a given year",
                            "codeSegments": [
                                {
                                    "code": "def scrape_season_stats(year):",
                                    "line": 22
                                },
                                {
                                    "code": "f\"https://www.basketball-reference.com/leagues/NBA_{year}_per_game.html\"",
                                    "line": 24
                                },
                                {
                                    "code": "f\"https://www.basketball-reference.com/leagues/NBA_{year}_advanced.html\"",
                                    "line": 27
                                }
                            ]
                        },
                        {
                            "summaryComponent": "from Basketball Reference",
                            "codeSegments": [
                                {
                                    "code": "f\"https://www.basketball-reference.com/leagues/NBA_{year}_per_game.html\"",
                                    "line": 24
                                },
                                {
                                    "code": "f\"https://www.basketball-reference.com/leagues/NBA_{year}_advanced.html\"",
                                    "line": 27
                                }
                            ]
                        },
                        {
                            "summaryComponent": "merging both datasets",
                            "codeSegments": [
                                {
                                    "code": "df_merged = pd.merge(df_reg, df_adv, on=[\"Player\", \"Year\"], how=\"inner\")",
                                    "line": 48
                                }
                            ]
                        }
                    ]
                },
                "editPromptValue": "",
                "editPromptDetailLevel": null,
                "oldSummaryData": {
                    "medium_structured": "• Downloads per-game NBA stats for a specified year from Basketball Reference\n• Cleans the data:\n  ◦ Removes repeated header rows\n  ◦ Adds the year as a column\n• Filters to keep only Player, Year, PTS, AST, TRB, and FG% columns\n• Drops rows with missing values in key stats\n• Returns the cleaned DataFrame",
                    "low_unstructured": "This function retrieves and processes NBA player per-game statistics for a given year from Basketball Reference.",
                    "high_structured": "• Constructs the URL for the NBA per-game stats page for the specified year\n• Reads the first HTML table from the page into a DataFrame\n• Cleans the DataFrame:\n  ◦ Removes rows where the 'Player' column equals 'Player' (eliminating repeated headers)\n  ◦ Adds a 'Year' column to indicate the season\n• Filters the DataFrame to keep only the following columns:\n  ◦ Player, Year, PTS, AST, TRB, FG%\n• Drops rows with missing values in any of the key stat columns (PTS, AST, TRB, FG%)\n• Returns the processed DataFrame containing clean, relevant player statistics for the given year",
                    "low_structured": "• Fetches NBA per-game stats for a given year\n• Cleans and filters the data\n• Returns selected player statistics",
                    "high_unstructured": "The scrape_season_stats function takes a year as input and constructs the URL for that season's NBA per-game statistics page on Basketball Reference. It reads the HTML table into a DataFrame, removes any rows where the 'Player' column contains the header string (to eliminate repeated headers), and adds a 'Year' column. The function then filters the DataFrame to retain only the columns for player name, year, points, assists, rebounds, and field goal percentage. Finally, it drops any rows with missing values in these key statistics and returns the cleaned DataFrame for further analysis.",
                    "medium_unstructured": "The function scrape_season_stats downloads NBA per-game statistics for a specified year from Basketball Reference. It cleans the data by removing repeated header rows and keeps only relevant columns such as player name, year, points, assists, rebounds, and field goal percentage. The function also ensures that rows with missing key stats are excluded before returning the processed DataFrame.",
                    "title": "Summary of scrape_season_stats(year) Function"
                },
                "lines": [
                    22,
                    54
                ],
                "title": "Summary of scrape_season_stats(year) Function (with Advanced Stats Merging)"
            },
            "section_id": "227aed7c-31ad-4ebc-8402-b2a1bdeaddf0"
        },
        "id": "pWX41PogHSOtAH6jaImS"
    },
    {
        "source": "frontend",
        "event": "click_summarize_code",
        "timestamp": "2025-08-24 11:52:26.000",
        "data": {},
        "id": "KVzxPEXEp0VUiHI1dx7Q"
    },
    {
        "source": "backend",
        "event": "summarize_selected_code",
        "timestamp": "2025-08-24 11:52:33.000",
        "data": {
            "summary": {
                "medium_structured": "• Loads data and splits it into training (earlier years) and test (most recent years) sets\n• Trains an XGBoost ranking model on the training data\n• Predicts and ranks players for the test years\n• Evaluates model performance using the NDCG metric\n• Generates and saves plots of prediction errors for the test years",
                "low_unstructured": "This function trains and evaluates an XGBoost ranking model on basketball player data split by year.",
                "high_structured": "• Loads player data and splits it by year into training (all but last two years) and test (last two years) sets\n• Prepares training and test feature matrices, target ranks, and group sizes for ranking\n• Initializes and trains an XGBRanker model with specific hyperparameters\n  ◦ Uses 'rank:pairwise' objective and groups data by year for proper ranking\n• Predicts ranking scores for test data\n  ◦ Assigns predicted ranks within each year based on predicted scores\n  ◦ Stores predicted scores and ranks in the DataFrame\n• Evaluates model performance using the NDCG metric on test years\n• Prints detailed prediction results for each player in the test years\n• Generates and saves bar plots visualizing prediction errors for 2024 and 2025",
                "low_structured": "• Loads data and splits it into training and test sets by year\n• Trains an XGBoost ranking model\n• Evaluates and prints results for recent years",
                "high_unstructured": "The main() function orchestrates the process of training and evaluating an XGBoost ranking model on basketball player statistics. It first loads the data and splits it into training and test sets based on year, with the last two years reserved for testing. The function trains an XGBRanker using group information for proper ranking, predicts scores for the test set, and assigns predicted ranks within each year. It then computes the NDCG score to assess ranking quality, prints detailed prediction results for the test years, and generates bar plots visualizing prediction errors for each player in the test years.",
                "medium_unstructured": "The main() function loads basketball player data, splits it into training and test sets based on years, and trains an XGBoost ranking model. It predicts rankings for the test years, evaluates performance using the NDCG metric, and prints the results. Additionally, it generates plots to visualize prediction errors for the test years.",
                "title": "Summary of the main() Function in rank_model.py"
            },
            "selected_code": "def main():\n    X, y, group, df = load_data()\n\n    # Train-test split on years\n    unique_years = df[\"Year\"].unique()\n    train_years, test_years = (\n        unique_years[:-2],  # train: 2015-2023\n        unique_years[-2:],  # test: 2024-2025\n    )\n\n    train_idx = df[\"Year\"].isin(train_years)\n    test_idx = df[\"Year\"].isin(test_years)\n\n    X_train, X_test = X[train_idx], X[test_idx]\n    y_train, y_test = y[train_idx], y[test_idx]\n\n    # Group sizes\n    train_groups = df[train_idx].groupby(\"Year\").size().to_numpy()\n    test_groups = df[test_idx].groupby(\"Year\").size().to_numpy()\n\n    # Model\n    model = XGBRanker(\n        objective=\"rank:pairwise\",\n        learning_rate=0.1,\n        n_estimators=100,\n        max_depth=4,\n        random_state=42,\n    )\n\n    print(\"Training XGBoostRanker...\")\n    model.fit(X_train, y_train, group=train_groups)\n\n    # Predict, sort, and evaluate\n    y_pred = model.predict(X_test)\n    df.loc[test_idx, \"PredictedScore\"] = y_pred\n    df.loc[test_idx, \"PredictedRank\"] = (\n        df.loc[test_idx]\n        .groupby(\"Year\")[\"PredictedScore\"]\n        .rank(ascending=False, method=\"first\")\n    )\n\n    ndcg = evaluate_ndcg(y_test.to_numpy(), y_pred, test_groups)\n    print(f\"NDCG Score on test years {test_years.tolist()}: {ndcg:.4f}\")\n\n    # Show results\n    print(df[test_idx][[\"Year\", \"Name\", \"Rank\", \"PredictedScore\", \"PredictedRank\"]])\n    plot_ranking_predictions(df, 2024)\n    plot_ranking_predictions(df, 2025)\n\n\nif __name__ == \"__main__\":\n    main()\n"
        },
        "id": "Jj43nNhmcXZOIVegTlGb"
    },
    {
        "source": "backend",
        "event": "map_summary_code",
        "timestamp": "2025-08-24 11:52:35.000",
        "data": {
            "summary": "This function trains and evaluates an XGBoost ranking model on basketball player data split by year.",
            "code": "74: def main():\n75:     X, y, group, df = load_data()\n76: \n77:     # Train-test split on years\n78:     unique_years = df[\"Year\"].unique()\n79:     train_years, test_years = (\n80:         unique_years[:-2],  # train: 2015-2023\n81:         unique_years[-2:],  # test: 2024-2025\n82:     )\n83: \n84:     train_idx = df[\"Year\"].isin(train_years)\n85:     test_idx = df[\"Year\"].isin(test_years)\n86: \n87:     X_train, X_test = X[train_idx], X[test_idx]\n88:     y_train, y_test = y[train_idx], y[test_idx]\n89: \n90:     # Group sizes\n91:     train_groups = df[train_idx].groupby(\"Year\").size().to_numpy()\n92:     test_groups = df[test_idx].groupby(\"Year\").size().to_numpy()\n93: \n94:     # Model\n95:     model = XGBRanker(\n96:         objective=\"rank:pairwise\",\n97:         learning_rate=0.1,\n98:         n_estimators=100,\n99:         max_depth=4,\n100:         random_state=42,\n101:     )\n102: \n103:     print(\"Training XGBoostRanker...\")\n104:     model.fit(X_train, y_train, group=train_groups)\n105: \n106:     # Predict, sort, and evaluate\n107:     y_pred = model.predict(X_test)\n108:     df.loc[test_idx, \"PredictedScore\"] = y_pred\n109:     df.loc[test_idx, \"PredictedRank\"] = (\n110:         df.loc[test_idx]\n111:         .groupby(\"Year\")[\"PredictedScore\"]\n112:         .rank(ascending=False, method=\"first\")\n113:     )\n114: \n115:     ndcg = evaluate_ndcg(y_test.to_numpy(), y_pred, test_groups)\n116:     print(f\"NDCG Score on test years {test_years.tolist()}: {ndcg:.4f}\")\n117: \n118:     # Show results\n119:     print(df[test_idx][[\"Year\", \"Name\", \"Rank\", \"PredictedScore\", \"PredictedRank\"]])\n120:     plot_ranking_predictions(df, 2024)\n121:     plot_ranking_predictions(df, 2025)\n122: \n123: \n124: if __name__ == \"__main__\":\n125:     main()\n126: ",
            "mapping": [
                {
                    "summaryComponent": "trains and evaluates",
                    "codeSegments": [
                        {
                            "code": "model.fit(X_train, y_train, group=train_groups)",
                            "line": 104
                        },
                        {
                            "code": "ndcg = evaluate_ndcg(y_test.to_numpy(), y_pred, test_groups)",
                            "line": 115
                        }
                    ]
                },
                {
                    "summaryComponent": "an XGBoost ranking model",
                    "codeSegments": [
                        {
                            "code": "model = XGBRanker(",
                            "line": 95
                        }
                    ]
                },
                {
                    "summaryComponent": "on basketball player data",
                    "codeSegments": [
                        {
                            "code": "X, y, group, df = load_data()",
                            "line": 75
                        }
                    ]
                },
                {
                    "summaryComponent": "split by year",
                    "codeSegments": [
                        {
                            "code": "unique_years = df[\"Year\"].unique()",
                            "line": 78
                        },
                        {
                            "code": "train_years, test_years = (",
                            "line": 79
                        },
                        {
                            "code": "train_idx = df[\"Year\"].isin(train_years)",
                            "line": 84
                        },
                        {
                            "code": "test_idx = df[\"Year\"].isin(test_years)",
                            "line": 85
                        }
                    ]
                }
            ]
        },
        "id": "xMXg222CVPMDInr2PSuT"
    },
    {
        "source": "backend",
        "event": "map_summary_code",
        "timestamp": "2025-08-24 11:52:36.000",
        "data": {
            "summary": "• Loads data and splits it into training and test sets by year\n• Trains an XGBoost ranking model\n• Evaluates and prints results for recent years",
            "code": "74: def main():\n75:     X, y, group, df = load_data()\n76: \n77:     # Train-test split on years\n78:     unique_years = df[\"Year\"].unique()\n79:     train_years, test_years = (\n80:         unique_years[:-2],  # train: 2015-2023\n81:         unique_years[-2:],  # test: 2024-2025\n82:     )\n83: \n84:     train_idx = df[\"Year\"].isin(train_years)\n85:     test_idx = df[\"Year\"].isin(test_years)\n86: \n87:     X_train, X_test = X[train_idx], X[test_idx]\n88:     y_train, y_test = y[train_idx], y[test_idx]\n89: \n90:     # Group sizes\n91:     train_groups = df[train_idx].groupby(\"Year\").size().to_numpy()\n92:     test_groups = df[test_idx].groupby(\"Year\").size().to_numpy()\n93: \n94:     # Model\n95:     model = XGBRanker(\n96:         objective=\"rank:pairwise\",\n97:         learning_rate=0.1,\n98:         n_estimators=100,\n99:         max_depth=4,\n100:         random_state=42,\n101:     )\n102: \n103:     print(\"Training XGBoostRanker...\")\n104:     model.fit(X_train, y_train, group=train_groups)\n105: \n106:     # Predict, sort, and evaluate\n107:     y_pred = model.predict(X_test)\n108:     df.loc[test_idx, \"PredictedScore\"] = y_pred\n109:     df.loc[test_idx, \"PredictedRank\"] = (\n110:         df.loc[test_idx]\n111:         .groupby(\"Year\")[\"PredictedScore\"]\n112:         .rank(ascending=False, method=\"first\")\n113:     )\n114: \n115:     ndcg = evaluate_ndcg(y_test.to_numpy(), y_pred, test_groups)\n116:     print(f\"NDCG Score on test years {test_years.tolist()}: {ndcg:.4f}\")\n117: \n118:     # Show results\n119:     print(df[test_idx][[\"Year\", \"Name\", \"Rank\", \"PredictedScore\", \"PredictedRank\"]])\n120:     plot_ranking_predictions(df, 2024)\n121:     plot_ranking_predictions(df, 2025)\n122: \n123: \n124: if __name__ == \"__main__\":\n125:     main()\n126: ",
            "mapping": [
                {
                    "summaryComponent": "Loads data",
                    "codeSegments": [
                        {
                            "code": "X, y, group, df = load_data()",
                            "line": 75
                        }
                    ]
                },
                {
                    "summaryComponent": "and splits it into training and test sets by year",
                    "codeSegments": [
                        {
                            "code": "unique_years = df[\"Year\"].unique()",
                            "line": 78
                        },
                        {
                            "code": "train_years, test_years = (",
                            "line": 79
                        },
                        {
                            "code": "train_idx = df[\"Year\"].isin(train_years)",
                            "line": 84
                        },
                        {
                            "code": "test_idx = df[\"Year\"].isin(test_years)",
                            "line": 85
                        },
                        {
                            "code": "X_train, X_test = X[train_idx], X[test_idx]",
                            "line": 87
                        },
                        {
                            "code": "y_train, y_test = y[train_idx], y[test_idx]",
                            "line": 88
                        }
                    ]
                },
                {
                    "summaryComponent": "Trains an XGBoost ranking model",
                    "codeSegments": [
                        {
                            "code": "model = XGBRanker(",
                            "line": 95
                        },
                        {
                            "code": "model.fit(X_train, y_train, group=train_groups)",
                            "line": 104
                        }
                    ]
                },
                {
                    "summaryComponent": "Evaluates and prints results for recent years",
                    "codeSegments": [
                        {
                            "code": "ndcg = evaluate_ndcg(y_test.to_numpy(), y_pred, test_groups)",
                            "line": 115
                        },
                        {
                            "code": "print(f\"NDCG Score on test years {test_years.tolist()}: {ndcg:.4f}\")",
                            "line": 116
                        },
                        {
                            "code": "print(df[test_idx][[\"Year\", \"Name\", \"Rank\", \"PredictedScore\", \"PredictedRank\"]])",
                            "line": 119
                        },
                        {
                            "code": "plot_ranking_predictions(df, 2024)",
                            "line": 120
                        },
                        {
                            "code": "plot_ranking_predictions(df, 2025)",
                            "line": 121
                        }
                    ]
                }
            ]
        },
        "id": "J40VjqNJwNWwd6L1aRA6"
    },
    {
        "source": "backend",
        "event": "map_summary_code",
        "timestamp": "2025-08-24 11:52:37.000",
        "data": {
            "summary": "• Loads data and splits it into training (earlier years) and test (most recent years) sets\n• Trains an XGBoost ranking model on the training data\n• Predicts and ranks players for the test years\n• Evaluates model performance using the NDCG metric\n• Generates and saves plots of prediction errors for the test years",
            "code": "74: def main():\n75:     X, y, group, df = load_data()\n76: \n77:     # Train-test split on years\n78:     unique_years = df[\"Year\"].unique()\n79:     train_years, test_years = (\n80:         unique_years[:-2],  # train: 2015-2023\n81:         unique_years[-2:],  # test: 2024-2025\n82:     )\n83: \n84:     train_idx = df[\"Year\"].isin(train_years)\n85:     test_idx = df[\"Year\"].isin(test_years)\n86: \n87:     X_train, X_test = X[train_idx], X[test_idx]\n88:     y_train, y_test = y[train_idx], y[test_idx]\n89: \n90:     # Group sizes\n91:     train_groups = df[train_idx].groupby(\"Year\").size().to_numpy()\n92:     test_groups = df[test_idx].groupby(\"Year\").size().to_numpy()\n93: \n94:     # Model\n95:     model = XGBRanker(\n96:         objective=\"rank:pairwise\",\n97:         learning_rate=0.1,\n98:         n_estimators=100,\n99:         max_depth=4,\n100:         random_state=42,\n101:     )\n102: \n103:     print(\"Training XGBoostRanker...\")\n104:     model.fit(X_train, y_train, group=train_groups)\n105: \n106:     # Predict, sort, and evaluate\n107:     y_pred = model.predict(X_test)\n108:     df.loc[test_idx, \"PredictedScore\"] = y_pred\n109:     df.loc[test_idx, \"PredictedRank\"] = (\n110:         df.loc[test_idx]\n111:         .groupby(\"Year\")[\"PredictedScore\"]\n112:         .rank(ascending=False, method=\"first\")\n113:     )\n114: \n115:     ndcg = evaluate_ndcg(y_test.to_numpy(), y_pred, test_groups)\n116:     print(f\"NDCG Score on test years {test_years.tolist()}: {ndcg:.4f}\")\n117: \n118:     # Show results\n119:     print(df[test_idx][[\"Year\", \"Name\", \"Rank\", \"PredictedScore\", \"PredictedRank\"]])\n120:     plot_ranking_predictions(df, 2024)\n121:     plot_ranking_predictions(df, 2025)\n122: \n123: \n124: if __name__ == \"__main__\":\n125:     main()\n126: ",
            "mapping": [
                {
                    "summaryComponent": "Loads data and splits it into training (earlier years) and test (most recent years) sets",
                    "codeSegments": [
                        {
                            "code": "X, y, group, df = load_data()",
                            "line": 75
                        },
                        {
                            "code": "unique_years = df[\"Year\"].unique()",
                            "line": 78
                        },
                        {
                            "code": "train_years, test_years = (\n    unique_years[:-2],  # train: 2015-2023\n    unique_years[-2:],  # test: 2024-2025\n)",
                            "line": 79
                        },
                        {
                            "code": "train_idx = df[\"Year\"].isin(train_years)",
                            "line": 84
                        },
                        {
                            "code": "test_idx = df[\"Year\"].isin(test_years)",
                            "line": 85
                        },
                        {
                            "code": "X_train, X_test = X[train_idx], X[test_idx]",
                            "line": 87
                        },
                        {
                            "code": "y_train, y_test = y[train_idx], y[test_idx]",
                            "line": 88
                        }
                    ]
                },
                {
                    "summaryComponent": "Trains an XGBoost ranking model on the training data",
                    "codeSegments": [
                        {
                            "code": "model = XGBRanker(",
                            "line": 95
                        },
                        {
                            "code": "model.fit(X_train, y_train, group=train_groups)",
                            "line": 104
                        }
                    ]
                },
                {
                    "summaryComponent": "Predicts and ranks players for the test years",
                    "codeSegments": [
                        {
                            "code": "y_pred = model.predict(X_test)",
                            "line": 107
                        },
                        {
                            "code": "df.loc[test_idx, \"PredictedScore\"] = y_pred",
                            "line": 108
                        },
                        {
                            "code": "df.loc[test_idx, \"PredictedRank\"] = (\n    df.loc[test_idx]\n    .groupby(\"Year\")[\"PredictedScore\"]\n    .rank(ascending=False, method=\"first\")\n)",
                            "line": 109
                        }
                    ]
                },
                {
                    "summaryComponent": "Evaluates model performance using the NDCG metric",
                    "codeSegments": [
                        {
                            "code": "ndcg = evaluate_ndcg(y_test.to_numpy(), y_pred, test_groups)",
                            "line": 115
                        },
                        {
                            "code": "print(f\"NDCG Score on test years {test_years.tolist()}: {ndcg:.4f}\")",
                            "line": 116
                        }
                    ]
                },
                {
                    "summaryComponent": "Generates and saves plots of prediction errors for the test years",
                    "codeSegments": [
                        {
                            "code": "plot_ranking_predictions(df, 2024)",
                            "line": 120
                        },
                        {
                            "code": "plot_ranking_predictions(df, 2025)",
                            "line": 121
                        }
                    ]
                }
            ]
        },
        "id": "17GfazA3EhOFq9AUL6QZ"
    },
    {
        "source": "backend",
        "event": "map_summary_code",
        "timestamp": "2025-08-24 11:52:37.000",
        "data": {
            "summary": "The main() function orchestrates the process of training and evaluating an XGBoost ranking model on basketball player statistics. It first loads the data and splits it into training and test sets based on year, with the last two years reserved for testing. The function trains an XGBRanker using group information for proper ranking, predicts scores for the test set, and assigns predicted ranks within each year. It then computes the NDCG score to assess ranking quality, prints detailed prediction results for the test years, and generates bar plots visualizing prediction errors for each player in the test years.",
            "code": "74: def main():\n75:     X, y, group, df = load_data()\n76: \n77:     # Train-test split on years\n78:     unique_years = df[\"Year\"].unique()\n79:     train_years, test_years = (\n80:         unique_years[:-2],  # train: 2015-2023\n81:         unique_years[-2:],  # test: 2024-2025\n82:     )\n83: \n84:     train_idx = df[\"Year\"].isin(train_years)\n85:     test_idx = df[\"Year\"].isin(test_years)\n86: \n87:     X_train, X_test = X[train_idx], X[test_idx]\n88:     y_train, y_test = y[train_idx], y[test_idx]\n89: \n90:     # Group sizes\n91:     train_groups = df[train_idx].groupby(\"Year\").size().to_numpy()\n92:     test_groups = df[test_idx].groupby(\"Year\").size().to_numpy()\n93: \n94:     # Model\n95:     model = XGBRanker(\n96:         objective=\"rank:pairwise\",\n97:         learning_rate=0.1,\n98:         n_estimators=100,\n99:         max_depth=4,\n100:         random_state=42,\n101:     )\n102: \n103:     print(\"Training XGBoostRanker...\")\n104:     model.fit(X_train, y_train, group=train_groups)\n105: \n106:     # Predict, sort, and evaluate\n107:     y_pred = model.predict(X_test)\n108:     df.loc[test_idx, \"PredictedScore\"] = y_pred\n109:     df.loc[test_idx, \"PredictedRank\"] = (\n110:         df.loc[test_idx]\n111:         .groupby(\"Year\")[\"PredictedScore\"]\n112:         .rank(ascending=False, method=\"first\")\n113:     )\n114: \n115:     ndcg = evaluate_ndcg(y_test.to_numpy(), y_pred, test_groups)\n116:     print(f\"NDCG Score on test years {test_years.tolist()}: {ndcg:.4f}\")\n117: \n118:     # Show results\n119:     print(df[test_idx][[\"Year\", \"Name\", \"Rank\", \"PredictedScore\", \"PredictedRank\"]])\n120:     plot_ranking_predictions(df, 2024)\n121:     plot_ranking_predictions(df, 2025)\n122: \n123: \n124: if __name__ == \"__main__\":\n125:     main()\n126: ",
            "mapping": [
                {
                    "summaryComponent": "The main() function orchestrates the process of training and evaluating an XGBoost ranking model on basketball player statistics.",
                    "codeSegments": [
                        {
                            "code": "def main():",
                            "line": 74
                        },
                        {
                            "code": "model = XGBRanker(",
                            "line": 95
                        }
                    ]
                },
                {
                    "summaryComponent": "It first loads the data",
                    "codeSegments": [
                        {
                            "code": "X, y, group, df = load_data()",
                            "line": 75
                        }
                    ]
                },
                {
                    "summaryComponent": "and splits it into training and test sets based on year, with the last two years reserved for testing.",
                    "codeSegments": [
                        {
                            "code": "unique_years = df[\"Year\"].unique()",
                            "line": 78
                        },
                        {
                            "code": "train_years, test_years = (",
                            "line": 79
                        },
                        {
                            "code": "unique_years[:-2],  # train: 2015-2023",
                            "line": 80
                        },
                        {
                            "code": "unique_years[-2:],  # test: 2024-2025",
                            "line": 81
                        }
                    ]
                },
                {
                    "summaryComponent": "The function trains an XGBRanker using group information for proper ranking,",
                    "codeSegments": [
                        {
                            "code": "model = XGBRanker(",
                            "line": 95
                        },
                        {
                            "code": "model.fit(X_train, y_train, group=train_groups)",
                            "line": 104
                        }
                    ]
                },
                {
                    "summaryComponent": "predicts scores for the test set,",
                    "codeSegments": [
                        {
                            "code": "y_pred = model.predict(X_test)",
                            "line": 107
                        }
                    ]
                },
                {
                    "summaryComponent": "and assigns predicted ranks within each year.",
                    "codeSegments": [
                        {
                            "code": "df.loc[test_idx, \"PredictedRank\"] = (",
                            "line": 109
                        },
                        {
                            "code": ".groupby(\"Year\")[\"PredictedScore\"]",
                            "line": 111
                        },
                        {
                            "code": ".rank(ascending=False, method=\"first\")",
                            "line": 112
                        }
                    ]
                },
                {
                    "summaryComponent": "It then computes the NDCG score to assess ranking quality,",
                    "codeSegments": [
                        {
                            "code": "ndcg = evaluate_ndcg(y_test.to_numpy(), y_pred, test_groups)",
                            "line": 115
                        }
                    ]
                },
                {
                    "summaryComponent": "prints detailed prediction results for the test years,",
                    "codeSegments": [
                        {
                            "code": "print(df[test_idx][[\"Year\", \"Name\", \"Rank\", \"PredictedScore\", \"PredictedRank\"]])",
                            "line": 119
                        }
                    ]
                },
                {
                    "summaryComponent": "and generates bar plots visualizing prediction errors for each player in the test years.",
                    "codeSegments": [
                        {
                            "code": "plot_ranking_predictions(df, 2024)",
                            "line": 120
                        },
                        {
                            "code": "plot_ranking_predictions(df, 2025)",
                            "line": 121
                        }
                    ]
                }
            ]
        },
        "id": "3Q3CsJgQr5ZmZFm8uh1r"
    },
    {
        "source": "backend",
        "event": "map_summary_code",
        "timestamp": "2025-08-24 11:52:37.000",
        "data": {
            "summary": "The main() function loads basketball player data, splits it into training and test sets based on years, and trains an XGBoost ranking model. It predicts rankings for the test years, evaluates performance using the NDCG metric, and prints the results. Additionally, it generates plots to visualize prediction errors for the test years.",
            "code": "74: def main():\n75:     X, y, group, df = load_data()\n76: \n77:     # Train-test split on years\n78:     unique_years = df[\"Year\"].unique()\n79:     train_years, test_years = (\n80:         unique_years[:-2],  # train: 2015-2023\n81:         unique_years[-2:],  # test: 2024-2025\n82:     )\n83: \n84:     train_idx = df[\"Year\"].isin(train_years)\n85:     test_idx = df[\"Year\"].isin(test_years)\n86: \n87:     X_train, X_test = X[train_idx], X[test_idx]\n88:     y_train, y_test = y[train_idx], y[test_idx]\n89: \n90:     # Group sizes\n91:     train_groups = df[train_idx].groupby(\"Year\").size().to_numpy()\n92:     test_groups = df[test_idx].groupby(\"Year\").size().to_numpy()\n93: \n94:     # Model\n95:     model = XGBRanker(\n96:         objective=\"rank:pairwise\",\n97:         learning_rate=0.1,\n98:         n_estimators=100,\n99:         max_depth=4,\n100:         random_state=42,\n101:     )\n102: \n103:     print(\"Training XGBoostRanker...\")\n104:     model.fit(X_train, y_train, group=train_groups)\n105: \n106:     # Predict, sort, and evaluate\n107:     y_pred = model.predict(X_test)\n108:     df.loc[test_idx, \"PredictedScore\"] = y_pred\n109:     df.loc[test_idx, \"PredictedRank\"] = (\n110:         df.loc[test_idx]\n111:         .groupby(\"Year\")[\"PredictedScore\"]\n112:         .rank(ascending=False, method=\"first\")\n113:     )\n114: \n115:     ndcg = evaluate_ndcg(y_test.to_numpy(), y_pred, test_groups)\n116:     print(f\"NDCG Score on test years {test_years.tolist()}: {ndcg:.4f}\")\n117: \n118:     # Show results\n119:     print(df[test_idx][[\"Year\", \"Name\", \"Rank\", \"PredictedScore\", \"PredictedRank\"]])\n120:     plot_ranking_predictions(df, 2024)\n121:     plot_ranking_predictions(df, 2025)\n122: \n123: \n124: if __name__ == \"__main__\":\n125:     main()\n126: ",
            "mapping": [
                {
                    "summaryComponent": "The main() function",
                    "codeSegments": [
                        {
                            "code": "def main():",
                            "line": 74
                        }
                    ]
                },
                {
                    "summaryComponent": "loads basketball player data",
                    "codeSegments": [
                        {
                            "code": "X, y, group, df = load_data()",
                            "line": 75
                        }
                    ]
                },
                {
                    "summaryComponent": "splits it into training and test sets based on years",
                    "codeSegments": [
                        {
                            "code": "unique_years = df[\"Year\"].unique()",
                            "line": 78
                        },
                        {
                            "code": "train_years, test_years = (",
                            "line": 79
                        },
                        {
                            "code": "    unique_years[:-2],  # train: 2015-2023",
                            "line": 80
                        },
                        {
                            "code": "    unique_years[-2:],  # test: 2024-2025",
                            "line": 81
                        },
                        {
                            "code": "train_idx = df[\"Year\"].isin(train_years)",
                            "line": 84
                        },
                        {
                            "code": "test_idx = df[\"Year\"].isin(test_years)",
                            "line": 85
                        },
                        {
                            "code": "X_train, X_test = X[train_idx], X[test_idx]",
                            "line": 87
                        },
                        {
                            "code": "y_train, y_test = y[train_idx], y[test_idx]",
                            "line": 88
                        }
                    ]
                },
                {
                    "summaryComponent": "trains an XGBoost ranking model",
                    "codeSegments": [
                        {
                            "code": "model = XGBRanker(",
                            "line": 95
                        },
                        {
                            "code": "model.fit(X_train, y_train, group=train_groups)",
                            "line": 104
                        }
                    ]
                },
                {
                    "summaryComponent": "It predicts rankings for the test years",
                    "codeSegments": [
                        {
                            "code": "y_pred = model.predict(X_test)",
                            "line": 107
                        },
                        {
                            "code": "df.loc[test_idx, \"PredictedScore\"] = y_pred",
                            "line": 108
                        },
                        {
                            "code": "df.loc[test_idx, \"PredictedRank\"] = (",
                            "line": 109
                        }
                    ]
                },
                {
                    "summaryComponent": "evaluates performance using the NDCG metric",
                    "codeSegments": [
                        {
                            "code": "ndcg = evaluate_ndcg(y_test.to_numpy(), y_pred, test_groups)",
                            "line": 115
                        },
                        {
                            "code": "print(f\"NDCG Score on test years {test_years.tolist()}: {ndcg:.4f}\")",
                            "line": 116
                        }
                    ]
                },
                {
                    "summaryComponent": "prints the results",
                    "codeSegments": [
                        {
                            "code": "print(df[test_idx][[\"Year\", \"Name\", \"Rank\", \"PredictedScore\", \"PredictedRank\"]])",
                            "line": 119
                        }
                    ]
                },
                {
                    "summaryComponent": "generates plots to visualize prediction errors for the test years",
                    "codeSegments": [
                        {
                            "code": "plot_ranking_predictions(df, 2024)",
                            "line": 120
                        },
                        {
                            "code": "plot_ranking_predictions(df, 2025)",
                            "line": 121
                        }
                    ]
                }
            ]
        },
        "id": "HpJx4V3khTUxgAhG2LKy"
    },
    {
        "source": "frontend",
        "event": "create_new_section",
        "timestamp": "2025-08-24 11:52:40.000",
        "data": {
            "section_data": {
                "selectedDetailLevel": "medium",
                "createdAt": 1756065160000,
                "metadata": {
                    "originalCode": "def main():\n    X, y, group, df = load_data()\n\n    # Train-test split on years\n    unique_years = df[\"Year\"].unique()\n    train_years, test_years = (\n        unique_years[:-2],  # train: 2015-2023\n        unique_years[-2:],  # test: 2024-2025\n    )\n\n    train_idx = df[\"Year\"].isin(train_years)\n    test_idx = df[\"Year\"].isin(test_years)\n\n    X_train, X_test = X[train_idx], X[test_idx]\n    y_train, y_test = y[train_idx], y[test_idx]\n\n    # Group sizes\n    train_groups = df[train_idx].groupby(\"Year\").size().to_numpy()\n    test_groups = df[test_idx].groupby(\"Year\").size().to_numpy()\n\n    # Model\n    model = XGBRanker(\n        objective=\"rank:pairwise\",\n        learning_rate=0.1,\n        n_estimators=100,\n        max_depth=4,\n        random_state=42,\n    )\n\n    print(\"Training XGBoostRanker...\")\n    model.fit(X_train, y_train, group=train_groups)\n\n    # Predict, sort, and evaluate\n    y_pred = model.predict(X_test)\n    df.loc[test_idx, \"PredictedScore\"] = y_pred\n    df.loc[test_idx, \"PredictedRank\"] = (\n        df.loc[test_idx]\n        .groupby(\"Year\")[\"PredictedScore\"]\n        .rank(ascending=False, method=\"first\")\n    )\n\n    ndcg = evaluate_ndcg(y_test.to_numpy(), y_pred, test_groups)\n    print(f\"NDCG Score on test years {test_years.tolist()}: {ndcg:.4f}\")\n\n    # Show results\n    print(df[test_idx][[\"Year\", \"Name\", \"Rank\", \"PredictedScore\", \"PredictedRank\"]])\n    plot_ranking_predictions(df, 2024)\n    plot_ranking_predictions(df, 2025)\n\n\nif __name__ == \"__main__\":\n    main()\n",
                    "id": "976fd15f-9dc3-4531-8eae-a29169ab7e11",
                    "filename": "rank_model.py",
                    "fullPath": "/project/workspace/rank_model.py",
                    "offset": 1952
                },
                "summaryData": {
                    "medium_structured": "• Loads data and splits it into training (earlier years) and test (most recent years) sets\n• Trains an XGBoost ranking model on the training data\n• Predicts and ranks players for the test years\n• Evaluates model performance using the NDCG metric\n• Generates and saves plots of prediction errors for the test years",
                    "low_unstructured": "This function trains and evaluates an XGBoost ranking model on basketball player data split by year.",
                    "high_structured": "• Loads player data and splits it by year into training (all but last two years) and test (last two years) sets\n• Prepares training and test feature matrices, target ranks, and group sizes for ranking\n• Initializes and trains an XGBRanker model with specific hyperparameters\n  ◦ Uses 'rank:pairwise' objective and groups data by year for proper ranking\n• Predicts ranking scores for test data\n  ◦ Assigns predicted ranks within each year based on predicted scores\n  ◦ Stores predicted scores and ranks in the DataFrame\n• Evaluates model performance using the NDCG metric on test years\n• Prints detailed prediction results for each player in the test years\n• Generates and saves bar plots visualizing prediction errors for 2024 and 2025",
                    "low_structured": "• Loads data and splits it into training and test sets by year\n• Trains an XGBoost ranking model\n• Evaluates and prints results for recent years",
                    "high_unstructured": "The main() function orchestrates the process of training and evaluating an XGBoost ranking model on basketball player statistics. It first loads the data and splits it into training and test sets based on year, with the last two years reserved for testing. The function trains an XGBRanker using group information for proper ranking, predicts scores for the test set, and assigns predicted ranks within each year. It then computes the NDCG score to assess ranking quality, prints detailed prediction results for the test years, and generates bar plots visualizing prediction errors for each player in the test years.",
                    "medium_unstructured": "The main() function loads basketball player data, splits it into training and test sets based on years, and trains an XGBoost ranking model. It predicts rankings for the test years, evaluates performance using the NDCG metric, and prints the results. Additionally, it generates plots to visualize prediction errors for the test years.",
                    "title": "Summary of the main() Function in rank_model.py"
                },
                "selectedStructured": "unstructured",
                "summaryMappings": {
                    "medium_structured": [
                        {
                            "summaryComponent": "Loads data and splits it into training (earlier years) and test (most recent years) sets",
                            "codeSegments": [
                                {
                                    "code": "X, y, group, df = load_data()",
                                    "line": 75
                                },
                                {
                                    "code": "unique_years = df[\"Year\"].unique()",
                                    "line": 78
                                },
                                {
                                    "code": "train_years, test_years = (\n    unique_years[:-2],  # train: 2015-2023\n    unique_years[-2:],  # test: 2024-2025\n)",
                                    "line": 79
                                },
                                {
                                    "code": "train_idx = df[\"Year\"].isin(train_years)",
                                    "line": 84
                                },
                                {
                                    "code": "test_idx = df[\"Year\"].isin(test_years)",
                                    "line": 85
                                },
                                {
                                    "code": "X_train, X_test = X[train_idx], X[test_idx]",
                                    "line": 87
                                },
                                {
                                    "code": "y_train, y_test = y[train_idx], y[test_idx]",
                                    "line": 88
                                }
                            ]
                        },
                        {
                            "summaryComponent": "Trains an XGBoost ranking model on the training data",
                            "codeSegments": [
                                {
                                    "code": "model = XGBRanker(",
                                    "line": 95
                                },
                                {
                                    "code": "model.fit(X_train, y_train, group=train_groups)",
                                    "line": 104
                                }
                            ]
                        },
                        {
                            "summaryComponent": "Predicts and ranks players for the test years",
                            "codeSegments": [
                                {
                                    "code": "y_pred = model.predict(X_test)",
                                    "line": 107
                                },
                                {
                                    "code": "df.loc[test_idx, \"PredictedScore\"] = y_pred",
                                    "line": 108
                                },
                                {
                                    "code": "df.loc[test_idx, \"PredictedRank\"] = (\n    df.loc[test_idx]\n    .groupby(\"Year\")[\"PredictedScore\"]\n    .rank(ascending=False, method=\"first\")\n)",
                                    "line": 109
                                }
                            ]
                        },
                        {
                            "summaryComponent": "Evaluates model performance using the NDCG metric",
                            "codeSegments": [
                                {
                                    "code": "ndcg = evaluate_ndcg(y_test.to_numpy(), y_pred, test_groups)",
                                    "line": 115
                                },
                                {
                                    "code": "print(f\"NDCG Score on test years {test_years.tolist()}: {ndcg:.4f}\")",
                                    "line": 116
                                }
                            ]
                        },
                        {
                            "summaryComponent": "Generates and saves plots of prediction errors for the test years",
                            "codeSegments": [
                                {
                                    "code": "plot_ranking_predictions(df, 2024)",
                                    "line": 120
                                },
                                {
                                    "code": "plot_ranking_predictions(df, 2025)",
                                    "line": 121
                                }
                            ]
                        }
                    ],
                    "high_structured": [
                        {
                            "summaryComponent": "Loads player data and splits it by year into training (all but last two years) and test (last two years) sets",
                            "codeSegments": [
                                {
                                    "code": "X, y, group, df = load_data()",
                                    "line": 75
                                },
                                {
                                    "code": "unique_years = df[\"Year\"].unique()",
                                    "line": 78
                                },
                                {
                                    "code": "train_years, test_years = (",
                                    "line": 79
                                },
                                {
                                    "code": "unique_years[:-2],  # train: 2015-2023",
                                    "line": 80
                                },
                                {
                                    "code": "unique_years[-2:],  # test: 2024-2025",
                                    "line": 81
                                }
                            ]
                        },
                        {
                            "summaryComponent": "Prepares training and test feature matrices, target ranks, and group sizes for ranking",
                            "codeSegments": [
                                {
                                    "code": "train_idx = df[\"Year\"].isin(train_years)",
                                    "line": 84
                                },
                                {
                                    "code": "test_idx = df[\"Year\"].isin(test_years)",
                                    "line": 85
                                },
                                {
                                    "code": "X_train, X_test = X[train_idx], X[test_idx]",
                                    "line": 87
                                },
                                {
                                    "code": "y_train, y_test = y[train_idx], y[test_idx]",
                                    "line": 88
                                },
                                {
                                    "code": "train_groups = df[train_idx].groupby(\"Year\").size().to_numpy()",
                                    "line": 91
                                },
                                {
                                    "code": "test_groups = df[test_idx].groupby(\"Year\").size().to_numpy()",
                                    "line": 92
                                }
                            ]
                        },
                        {
                            "summaryComponent": "Initializes and trains an XGBRanker model with specific hyperparameters",
                            "codeSegments": [
                                {
                                    "code": "model = XGBRanker(",
                                    "line": 95
                                },
                                {
                                    "code": "objective=\"rank:pairwise\",",
                                    "line": 96
                                },
                                {
                                    "code": "learning_rate=0.1,",
                                    "line": 97
                                },
                                {
                                    "code": "n_estimators=100,",
                                    "line": 98
                                },
                                {
                                    "code": "max_depth=4,",
                                    "line": 99
                                },
                                {
                                    "code": "random_state=42,",
                                    "line": 100
                                },
                                {
                                    "code": ")",
                                    "line": 101
                                },
                                {
                                    "code": "model.fit(X_train, y_train, group=train_groups)",
                                    "line": 104
                                }
                            ]
                        },
                        {
                            "summaryComponent": "Uses 'rank:pairwise' objective and groups data by year for proper ranking",
                            "codeSegments": [
                                {
                                    "code": "objective=\"rank:pairwise\",",
                                    "line": 96
                                },
                                {
                                    "code": "group=train_groups",
                                    "line": 104
                                }
                            ]
                        },
                        {
                            "summaryComponent": "Predicts ranking scores for test data",
                            "codeSegments": [
                                {
                                    "code": "y_pred = model.predict(X_test)",
                                    "line": 107
                                }
                            ]
                        },
                        {
                            "summaryComponent": "Assigns predicted ranks within each year based on predicted scores",
                            "codeSegments": [
                                {
                                    "code": "df.loc[test_idx, \"PredictedRank\"] = (",
                                    "line": 109
                                },
                                {
                                    "code": "df.loc[test_idx]\n        .groupby(\"Year\")[\"PredictedScore\"]\n        .rank(ascending=False, method=\"first\")",
                                    "line": 110
                                }
                            ]
                        },
                        {
                            "summaryComponent": "Stores predicted scores and ranks in the DataFrame",
                            "codeSegments": [
                                {
                                    "code": "df.loc[test_idx, \"PredictedScore\"] = y_pred",
                                    "line": 108
                                },
                                {
                                    "code": "df.loc[test_idx, \"PredictedRank\"] = (",
                                    "line": 109
                                }
                            ]
                        },
                        {
                            "summaryComponent": "Evaluates model performance using the NDCG metric on test years",
                            "codeSegments": [
                                {
                                    "code": "ndcg = evaluate_ndcg(y_test.to_numpy(), y_pred, test_groups)",
                                    "line": 115
                                },
                                {
                                    "code": "print(f\"NDCG Score on test years {test_years.tolist()}: {ndcg:.4f}\")",
                                    "line": 116
                                }
                            ]
                        },
                        {
                            "summaryComponent": "Prints detailed prediction results for each player in the test years",
                            "codeSegments": [
                                {
                                    "code": "print(df[test_idx][[\"Year\", \"Name\", \"Rank\", \"PredictedScore\", \"PredictedRank\"]])",
                                    "line": 119
                                }
                            ]
                        },
                        {
                            "summaryComponent": "Generates and saves bar plots visualizing prediction errors for 2024 and 2025",
                            "codeSegments": [
                                {
                                    "code": "plot_ranking_predictions(df, 2024)",
                                    "line": 120
                                },
                                {
                                    "code": "plot_ranking_predictions(df, 2025)",
                                    "line": 121
                                }
                            ]
                        }
                    ],
                    "low_structured": [
                        {
                            "summaryComponent": "Loads data",
                            "codeSegments": [
                                {
                                    "code": "X, y, group, df = load_data()",
                                    "line": 75
                                }
                            ]
                        },
                        {
                            "summaryComponent": "and splits it into training and test sets by year",
                            "codeSegments": [
                                {
                                    "code": "unique_years = df[\"Year\"].unique()",
                                    "line": 78
                                },
                                {
                                    "code": "train_years, test_years = (",
                                    "line": 79
                                },
                                {
                                    "code": "train_idx = df[\"Year\"].isin(train_years)",
                                    "line": 84
                                },
                                {
                                    "code": "test_idx = df[\"Year\"].isin(test_years)",
                                    "line": 85
                                },
                                {
                                    "code": "X_train, X_test = X[train_idx], X[test_idx]",
                                    "line": 87
                                },
                                {
                                    "code": "y_train, y_test = y[train_idx], y[test_idx]",
                                    "line": 88
                                }
                            ]
                        },
                        {
                            "summaryComponent": "Trains an XGBoost ranking model",
                            "codeSegments": [
                                {
                                    "code": "model = XGBRanker(",
                                    "line": 95
                                },
                                {
                                    "code": "model.fit(X_train, y_train, group=train_groups)",
                                    "line": 104
                                }
                            ]
                        },
                        {
                            "summaryComponent": "Evaluates and prints results for recent years",
                            "codeSegments": [
                                {
                                    "code": "ndcg = evaluate_ndcg(y_test.to_numpy(), y_pred, test_groups)",
                                    "line": 115
                                },
                                {
                                    "code": "print(f\"NDCG Score on test years {test_years.tolist()}: {ndcg:.4f}\")",
                                    "line": 116
                                },
                                {
                                    "code": "print(df[test_idx][[\"Year\", \"Name\", \"Rank\", \"PredictedScore\", \"PredictedRank\"]])",
                                    "line": 119
                                },
                                {
                                    "code": "plot_ranking_predictions(df, 2024)",
                                    "line": 120
                                },
                                {
                                    "code": "plot_ranking_predictions(df, 2025)",
                                    "line": 121
                                }
                            ]
                        }
                    ],
                    "high_unstructured": [
                        {
                            "summaryComponent": "The main() function orchestrates the process of training and evaluating an XGBoost ranking model on basketball player statistics.",
                            "codeSegments": [
                                {
                                    "code": "def main():",
                                    "line": 74
                                },
                                {
                                    "code": "model = XGBRanker(",
                                    "line": 95
                                }
                            ]
                        },
                        {
                            "summaryComponent": "It first loads the data",
                            "codeSegments": [
                                {
                                    "code": "X, y, group, df = load_data()",
                                    "line": 75
                                }
                            ]
                        },
                        {
                            "summaryComponent": "and splits it into training and test sets based on year, with the last two years reserved for testing.",
                            "codeSegments": [
                                {
                                    "code": "unique_years = df[\"Year\"].unique()",
                                    "line": 78
                                },
                                {
                                    "code": "train_years, test_years = (",
                                    "line": 79
                                },
                                {
                                    "code": "unique_years[:-2],  # train: 2015-2023",
                                    "line": 80
                                },
                                {
                                    "code": "unique_years[-2:],  # test: 2024-2025",
                                    "line": 81
                                }
                            ]
                        },
                        {
                            "summaryComponent": "The function trains an XGBRanker using group information for proper ranking,",
                            "codeSegments": [
                                {
                                    "code": "model = XGBRanker(",
                                    "line": 95
                                },
                                {
                                    "code": "model.fit(X_train, y_train, group=train_groups)",
                                    "line": 104
                                }
                            ]
                        },
                        {
                            "summaryComponent": "predicts scores for the test set,",
                            "codeSegments": [
                                {
                                    "code": "y_pred = model.predict(X_test)",
                                    "line": 107
                                }
                            ]
                        },
                        {
                            "summaryComponent": "and assigns predicted ranks within each year.",
                            "codeSegments": [
                                {
                                    "code": "df.loc[test_idx, \"PredictedRank\"] = (",
                                    "line": 109
                                },
                                {
                                    "code": ".groupby(\"Year\")[\"PredictedScore\"]",
                                    "line": 111
                                },
                                {
                                    "code": ".rank(ascending=False, method=\"first\")",
                                    "line": 112
                                }
                            ]
                        },
                        {
                            "summaryComponent": "It then computes the NDCG score to assess ranking quality,",
                            "codeSegments": [
                                {
                                    "code": "ndcg = evaluate_ndcg(y_test.to_numpy(), y_pred, test_groups)",
                                    "line": 115
                                }
                            ]
                        },
                        {
                            "summaryComponent": "prints detailed prediction results for the test years,",
                            "codeSegments": [
                                {
                                    "code": "print(df[test_idx][[\"Year\", \"Name\", \"Rank\", \"PredictedScore\", \"PredictedRank\"]])",
                                    "line": 119
                                }
                            ]
                        },
                        {
                            "summaryComponent": "and generates bar plots visualizing prediction errors for each player in the test years.",
                            "codeSegments": [
                                {
                                    "code": "plot_ranking_predictions(df, 2024)",
                                    "line": 120
                                },
                                {
                                    "code": "plot_ranking_predictions(df, 2025)",
                                    "line": 121
                                }
                            ]
                        }
                    ],
                    "medium_unstructured": [
                        {
                            "summaryComponent": "The main() function",
                            "codeSegments": [
                                {
                                    "code": "def main():",
                                    "line": 74
                                }
                            ]
                        },
                        {
                            "summaryComponent": "loads basketball player data",
                            "codeSegments": [
                                {
                                    "code": "X, y, group, df = load_data()",
                                    "line": 75
                                }
                            ]
                        },
                        {
                            "summaryComponent": "splits it into training and test sets based on years",
                            "codeSegments": [
                                {
                                    "code": "unique_years = df[\"Year\"].unique()",
                                    "line": 78
                                },
                                {
                                    "code": "train_years, test_years = (",
                                    "line": 79
                                },
                                {
                                    "code": "    unique_years[:-2],  # train: 2015-2023",
                                    "line": 80
                                },
                                {
                                    "code": "    unique_years[-2:],  # test: 2024-2025",
                                    "line": 81
                                },
                                {
                                    "code": "train_idx = df[\"Year\"].isin(train_years)",
                                    "line": 84
                                },
                                {
                                    "code": "test_idx = df[\"Year\"].isin(test_years)",
                                    "line": 85
                                },
                                {
                                    "code": "X_train, X_test = X[train_idx], X[test_idx]",
                                    "line": 87
                                },
                                {
                                    "code": "y_train, y_test = y[train_idx], y[test_idx]",
                                    "line": 88
                                }
                            ]
                        },
                        {
                            "summaryComponent": "trains an XGBoost ranking model",
                            "codeSegments": [
                                {
                                    "code": "model = XGBRanker(",
                                    "line": 95
                                },
                                {
                                    "code": "model.fit(X_train, y_train, group=train_groups)",
                                    "line": 104
                                }
                            ]
                        },
                        {
                            "summaryComponent": "It predicts rankings for the test years",
                            "codeSegments": [
                                {
                                    "code": "y_pred = model.predict(X_test)",
                                    "line": 107
                                },
                                {
                                    "code": "df.loc[test_idx, \"PredictedScore\"] = y_pred",
                                    "line": 108
                                },
                                {
                                    "code": "df.loc[test_idx, \"PredictedRank\"] = (",
                                    "line": 109
                                }
                            ]
                        },
                        {
                            "summaryComponent": "evaluates performance using the NDCG metric",
                            "codeSegments": [
                                {
                                    "code": "ndcg = evaluate_ndcg(y_test.to_numpy(), y_pred, test_groups)",
                                    "line": 115
                                },
                                {
                                    "code": "print(f\"NDCG Score on test years {test_years.tolist()}: {ndcg:.4f}\")",
                                    "line": 116
                                }
                            ]
                        },
                        {
                            "summaryComponent": "prints the results",
                            "codeSegments": [
                                {
                                    "code": "print(df[test_idx][[\"Year\", \"Name\", \"Rank\", \"PredictedScore\", \"PredictedRank\"]])",
                                    "line": 119
                                }
                            ]
                        },
                        {
                            "summaryComponent": "generates plots to visualize prediction errors for the test years",
                            "codeSegments": [
                                {
                                    "code": "plot_ranking_predictions(df, 2024)",
                                    "line": 120
                                },
                                {
                                    "code": "plot_ranking_predictions(df, 2025)",
                                    "line": 121
                                }
                            ]
                        }
                    ],
                    "low_unstructured": [
                        {
                            "summaryComponent": "trains and evaluates",
                            "codeSegments": [
                                {
                                    "code": "model.fit(X_train, y_train, group=train_groups)",
                                    "line": 104
                                },
                                {
                                    "code": "ndcg = evaluate_ndcg(y_test.to_numpy(), y_pred, test_groups)",
                                    "line": 115
                                }
                            ]
                        },
                        {
                            "summaryComponent": "an XGBoost ranking model",
                            "codeSegments": [
                                {
                                    "code": "model = XGBRanker(",
                                    "line": 95
                                }
                            ]
                        },
                        {
                            "summaryComponent": "on basketball player data",
                            "codeSegments": [
                                {
                                    "code": "X, y, group, df = load_data()",
                                    "line": 75
                                }
                            ]
                        },
                        {
                            "summaryComponent": "split by year",
                            "codeSegments": [
                                {
                                    "code": "unique_years = df[\"Year\"].unique()",
                                    "line": 78
                                },
                                {
                                    "code": "train_years, test_years = (",
                                    "line": 79
                                },
                                {
                                    "code": "train_idx = df[\"Year\"].isin(train_years)",
                                    "line": 84
                                },
                                {
                                    "code": "test_idx = df[\"Year\"].isin(test_years)",
                                    "line": 85
                                }
                            ]
                        }
                    ]
                },
                "editPromptValue": "",
                "editPromptDetailLevel": null,
                "editPromptStructured": null,
                "lines": [
                    74,
                    126
                ],
                "title": "Summary of the main() Function in rank_model.py"
            },
            "section_id": "976fd15f-9dc3-4531-8eae-a29169ab7e11"
        },
        "id": "BmkyOaCohkeGRzmutq3t"
    },
    {
        "source": "backend",
        "event": "map_summary_code",
        "timestamp": "2025-08-24 11:52:40.000",
        "data": {
            "summary": "• Loads player data and splits it by year into training (all but last two years) and test (last two years) sets\n• Prepares training and test feature matrices, target ranks, and group sizes for ranking\n• Initializes and trains an XGBRanker model with specific hyperparameters\n  ◦ Uses 'rank:pairwise' objective and groups data by year for proper ranking\n• Predicts ranking scores for test data\n  ◦ Assigns predicted ranks within each year based on predicted scores\n  ◦ Stores predicted scores and ranks in the DataFrame\n• Evaluates model performance using the NDCG metric on test years\n• Prints detailed prediction results for each player in the test years\n• Generates and saves bar plots visualizing prediction errors for 2024 and 2025",
            "code": "74: def main():\n75:     X, y, group, df = load_data()\n76: \n77:     # Train-test split on years\n78:     unique_years = df[\"Year\"].unique()\n79:     train_years, test_years = (\n80:         unique_years[:-2],  # train: 2015-2023\n81:         unique_years[-2:],  # test: 2024-2025\n82:     )\n83: \n84:     train_idx = df[\"Year\"].isin(train_years)\n85:     test_idx = df[\"Year\"].isin(test_years)\n86: \n87:     X_train, X_test = X[train_idx], X[test_idx]\n88:     y_train, y_test = y[train_idx], y[test_idx]\n89: \n90:     # Group sizes\n91:     train_groups = df[train_idx].groupby(\"Year\").size().to_numpy()\n92:     test_groups = df[test_idx].groupby(\"Year\").size().to_numpy()\n93: \n94:     # Model\n95:     model = XGBRanker(\n96:         objective=\"rank:pairwise\",\n97:         learning_rate=0.1,\n98:         n_estimators=100,\n99:         max_depth=4,\n100:         random_state=42,\n101:     )\n102: \n103:     print(\"Training XGBoostRanker...\")\n104:     model.fit(X_train, y_train, group=train_groups)\n105: \n106:     # Predict, sort, and evaluate\n107:     y_pred = model.predict(X_test)\n108:     df.loc[test_idx, \"PredictedScore\"] = y_pred\n109:     df.loc[test_idx, \"PredictedRank\"] = (\n110:         df.loc[test_idx]\n111:         .groupby(\"Year\")[\"PredictedScore\"]\n112:         .rank(ascending=False, method=\"first\")\n113:     )\n114: \n115:     ndcg = evaluate_ndcg(y_test.to_numpy(), y_pred, test_groups)\n116:     print(f\"NDCG Score on test years {test_years.tolist()}: {ndcg:.4f}\")\n117: \n118:     # Show results\n119:     print(df[test_idx][[\"Year\", \"Name\", \"Rank\", \"PredictedScore\", \"PredictedRank\"]])\n120:     plot_ranking_predictions(df, 2024)\n121:     plot_ranking_predictions(df, 2025)\n122: \n123: \n124: if __name__ == \"__main__\":\n125:     main()\n126: ",
            "mapping": [
                {
                    "summaryComponent": "Loads player data and splits it by year into training (all but last two years) and test (last two years) sets",
                    "codeSegments": [
                        {
                            "code": "X, y, group, df = load_data()",
                            "line": 75
                        },
                        {
                            "code": "unique_years = df[\"Year\"].unique()",
                            "line": 78
                        },
                        {
                            "code": "train_years, test_years = (",
                            "line": 79
                        },
                        {
                            "code": "unique_years[:-2],  # train: 2015-2023",
                            "line": 80
                        },
                        {
                            "code": "unique_years[-2:],  # test: 2024-2025",
                            "line": 81
                        }
                    ]
                },
                {
                    "summaryComponent": "Prepares training and test feature matrices, target ranks, and group sizes for ranking",
                    "codeSegments": [
                        {
                            "code": "train_idx = df[\"Year\"].isin(train_years)",
                            "line": 84
                        },
                        {
                            "code": "test_idx = df[\"Year\"].isin(test_years)",
                            "line": 85
                        },
                        {
                            "code": "X_train, X_test = X[train_idx], X[test_idx]",
                            "line": 87
                        },
                        {
                            "code": "y_train, y_test = y[train_idx], y[test_idx]",
                            "line": 88
                        },
                        {
                            "code": "train_groups = df[train_idx].groupby(\"Year\").size().to_numpy()",
                            "line": 91
                        },
                        {
                            "code": "test_groups = df[test_idx].groupby(\"Year\").size().to_numpy()",
                            "line": 92
                        }
                    ]
                },
                {
                    "summaryComponent": "Initializes and trains an XGBRanker model with specific hyperparameters",
                    "codeSegments": [
                        {
                            "code": "model = XGBRanker(",
                            "line": 95
                        },
                        {
                            "code": "objective=\"rank:pairwise\",",
                            "line": 96
                        },
                        {
                            "code": "learning_rate=0.1,",
                            "line": 97
                        },
                        {
                            "code": "n_estimators=100,",
                            "line": 98
                        },
                        {
                            "code": "max_depth=4,",
                            "line": 99
                        },
                        {
                            "code": "random_state=42,",
                            "line": 100
                        },
                        {
                            "code": ")",
                            "line": 101
                        },
                        {
                            "code": "model.fit(X_train, y_train, group=train_groups)",
                            "line": 104
                        }
                    ]
                },
                {
                    "summaryComponent": "Uses 'rank:pairwise' objective and groups data by year for proper ranking",
                    "codeSegments": [
                        {
                            "code": "objective=\"rank:pairwise\",",
                            "line": 96
                        },
                        {
                            "code": "group=train_groups",
                            "line": 104
                        }
                    ]
                },
                {
                    "summaryComponent": "Predicts ranking scores for test data",
                    "codeSegments": [
                        {
                            "code": "y_pred = model.predict(X_test)",
                            "line": 107
                        }
                    ]
                },
                {
                    "summaryComponent": "Assigns predicted ranks within each year based on predicted scores",
                    "codeSegments": [
                        {
                            "code": "df.loc[test_idx, \"PredictedRank\"] = (",
                            "line": 109
                        },
                        {
                            "code": "df.loc[test_idx]\n        .groupby(\"Year\")[\"PredictedScore\"]\n        .rank(ascending=False, method=\"first\")",
                            "line": 110
                        }
                    ]
                },
                {
                    "summaryComponent": "Stores predicted scores and ranks in the DataFrame",
                    "codeSegments": [
                        {
                            "code": "df.loc[test_idx, \"PredictedScore\"] = y_pred",
                            "line": 108
                        },
                        {
                            "code": "df.loc[test_idx, \"PredictedRank\"] = (",
                            "line": 109
                        }
                    ]
                },
                {
                    "summaryComponent": "Evaluates model performance using the NDCG metric on test years",
                    "codeSegments": [
                        {
                            "code": "ndcg = evaluate_ndcg(y_test.to_numpy(), y_pred, test_groups)",
                            "line": 115
                        },
                        {
                            "code": "print(f\"NDCG Score on test years {test_years.tolist()}: {ndcg:.4f}\")",
                            "line": 116
                        }
                    ]
                },
                {
                    "summaryComponent": "Prints detailed prediction results for each player in the test years",
                    "codeSegments": [
                        {
                            "code": "print(df[test_idx][[\"Year\", \"Name\", \"Rank\", \"PredictedScore\", \"PredictedRank\"]])",
                            "line": 119
                        }
                    ]
                },
                {
                    "summaryComponent": "Generates and saves bar plots visualizing prediction errors for 2024 and 2025",
                    "codeSegments": [
                        {
                            "code": "plot_ranking_predictions(df, 2024)",
                            "line": 120
                        },
                        {
                            "code": "plot_ranking_predictions(df, 2025)",
                            "line": 121
                        }
                    ]
                }
            ]
        },
        "id": "XyXuE5kxyRwx8rmrnnCj"
    },
    {
        "source": "frontend",
        "event": "autotransit_section",
        "timestamp": "2025-08-24 11:52:40.000",
        "data": {
            "before_section_id": "227aed7c-31ad-4ebc-8402-b2a1bdeaddf0",
            "after_section_id": "976fd15f-9dc3-4531-8eae-a29169ab7e11"
        },
        "id": "YMLLG16amEC13RBofhVn"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "timestamp": "2025-08-24 11:52:50.000",
        "data": {
            "structured_type": "unstructured",
            "detail_level": "medium",
            "mapping_index": 1,
            "section_id": "976fd15f-9dc3-4531-8eae-a29169ab7e11"
        },
        "id": "BhUMah5ByYl8Od0xheyN"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "timestamp": "2025-08-24 11:52:50.000",
        "data": {
            "structured_type": "unstructured",
            "detail_level": "medium",
            "section_id": "976fd15f-9dc3-4531-8eae-a29169ab7e11"
        },
        "id": "H7ei8Fp4HOYRoLLxD2Iy"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "timestamp": "2025-08-24 11:52:50.000",
        "data": {
            "structured_type": "unstructured",
            "detail_level": "medium",
            "section_id": "976fd15f-9dc3-4531-8eae-a29169ab7e11"
        },
        "id": "OplZquVpyju6ZeTavYHY"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "timestamp": "2025-08-24 11:52:50.000",
        "data": {
            "structured_type": "unstructured",
            "detail_level": "medium",
            "mapping_index": 7,
            "section_id": "976fd15f-9dc3-4531-8eae-a29169ab7e11"
        },
        "id": "XNNHLvaxQQLiV6A2Fg06"
    },
    {
        "source": "frontend",
        "event": "change_summary_level",
        "timestamp": "2025-08-24 11:52:51.000",
        "data": {
            "before_structured": "unstructured",
            "before_detail_level": "medium",
            "after_structured": "unstructured",
            "after_detail_level": "low",
            "section_id": "976fd15f-9dc3-4531-8eae-a29169ab7e11"
        },
        "id": "3y3VnqGJ9mPofwHqESSY"
    },
    {
        "source": "frontend",
        "event": "change_summary_level",
        "timestamp": "2025-08-24 11:52:52.000",
        "data": {
            "before_structured": "unstructured",
            "before_detail_level": "low",
            "after_structured": "unstructured",
            "after_detail_level": "medium",
            "section_id": "976fd15f-9dc3-4531-8eae-a29169ab7e11"
        },
        "id": "lbBl6tM5UrqT2v6bkwFs"
    },
    {
        "source": "frontend",
        "event": "change_summary_level",
        "timestamp": "2025-08-24 11:52:53.000",
        "data": {
            "before_structured": "unstructured",
            "before_detail_level": "medium",
            "after_structured": "unstructured",
            "after_detail_level": "high",
            "section_id": "976fd15f-9dc3-4531-8eae-a29169ab7e11"
        },
        "id": "bFniXUItusafIq9nSCbj"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "timestamp": "2025-08-24 11:52:54.000",
        "data": {
            "structured_type": "unstructured",
            "detail_level": "high",
            "mapping_index": 1,
            "section_id": "976fd15f-9dc3-4531-8eae-a29169ab7e11"
        },
        "id": "CS6ZbC4NGh78ejgpBm2C"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "timestamp": "2025-08-24 11:52:54.000",
        "data": {
            "structured_type": "unstructured",
            "detail_level": "high",
            "section_id": "976fd15f-9dc3-4531-8eae-a29169ab7e11"
        },
        "id": "GNL0Fwt6xDXCdcLhh5Fv"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "timestamp": "2025-08-24 11:52:54.000",
        "data": {
            "structured_type": "unstructured",
            "detail_level": "high",
            "mapping_index": 2,
            "section_id": "976fd15f-9dc3-4531-8eae-a29169ab7e11"
        },
        "id": "IpqwmytsMXenT9N8UBtF"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "timestamp": "2025-08-24 11:52:54.000",
        "data": {
            "structured_type": "unstructured",
            "detail_level": "high",
            "mapping_index": 0,
            "section_id": "976fd15f-9dc3-4531-8eae-a29169ab7e11"
        },
        "id": "JhTVcBevnvJAGkM6GrCl"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "timestamp": "2025-08-24 11:52:54.000",
        "data": {
            "structured_type": "unstructured",
            "detail_level": "high",
            "section_id": "976fd15f-9dc3-4531-8eae-a29169ab7e11"
        },
        "id": "mnCDlxJQ3zH4I6vpPd62"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "timestamp": "2025-08-24 11:52:55.000",
        "data": {
            "structured_type": "unstructured",
            "detail_level": "high",
            "mapping_index": 3,
            "section_id": "976fd15f-9dc3-4531-8eae-a29169ab7e11"
        },
        "id": "8nfxvWMkayaBz2uCcvuV"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "timestamp": "2025-08-24 11:52:55.000",
        "data": {
            "structured_type": "unstructured",
            "detail_level": "high",
            "section_id": "976fd15f-9dc3-4531-8eae-a29169ab7e11"
        },
        "id": "960lLJyzdtGAVZ8QJHiw"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "timestamp": "2025-08-24 11:52:55.000",
        "data": {
            "structured_type": "unstructured",
            "detail_level": "high",
            "mapping_index": 7,
            "section_id": "976fd15f-9dc3-4531-8eae-a29169ab7e11"
        },
        "id": "9HieX0Nibb53jHDJWDwV"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "timestamp": "2025-08-24 11:52:55.000",
        "data": {
            "structured_type": "unstructured",
            "detail_level": "high",
            "section_id": "976fd15f-9dc3-4531-8eae-a29169ab7e11"
        },
        "id": "H6hiZRgw43QdHJMlAa3L"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "timestamp": "2025-08-24 11:52:55.000",
        "data": {
            "structured_type": "unstructured",
            "detail_level": "high",
            "mapping_index": 5,
            "section_id": "976fd15f-9dc3-4531-8eae-a29169ab7e11"
        },
        "id": "VtWG4CsWRLoxG2O2Jp43"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "timestamp": "2025-08-24 11:52:55.000",
        "data": {
            "structured_type": "unstructured",
            "detail_level": "high",
            "section_id": "976fd15f-9dc3-4531-8eae-a29169ab7e11"
        },
        "id": "xTpWnfpKzYBvhO33iwCh"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "timestamp": "2025-08-24 11:52:56.000",
        "data": {
            "structured_type": "unstructured",
            "detail_level": "high",
            "section_id": "976fd15f-9dc3-4531-8eae-a29169ab7e11"
        },
        "id": "4PvD35YkJR8ZIIlMcNpz"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "timestamp": "2025-08-24 11:52:56.000",
        "data": {
            "structured_type": "unstructured",
            "detail_level": "high",
            "mapping_index": 8,
            "section_id": "976fd15f-9dc3-4531-8eae-a29169ab7e11"
        },
        "id": "Heed07Rm1BGHxHBBeJSj"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "timestamp": "2025-08-24 11:52:56.000",
        "data": {
            "structured_type": "unstructured",
            "detail_level": "high",
            "mapping_index": 7,
            "section_id": "976fd15f-9dc3-4531-8eae-a29169ab7e11"
        },
        "id": "pnIQKsgIDCkAmFZuccBD"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "timestamp": "2025-08-24 11:52:56.000",
        "data": {
            "structured_type": "unstructured",
            "detail_level": "high",
            "section_id": "976fd15f-9dc3-4531-8eae-a29169ab7e11"
        },
        "id": "uASJphCcjqgk4jVYHdWy"
    },
    {
        "source": "frontend",
        "event": "change_summary_level",
        "timestamp": "2025-08-24 11:52:57.000",
        "data": {
            "before_structured": "unstructured",
            "before_detail_level": "high",
            "after_structured": "structured",
            "after_detail_level": "high",
            "section_id": "976fd15f-9dc3-4531-8eae-a29169ab7e11"
        },
        "id": "DT3E6LtFnMZcoEFjYSC3"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "timestamp": "2025-08-24 11:52:57.000",
        "data": {
            "structured_type": "unstructured",
            "detail_level": "high",
            "section_id": "976fd15f-9dc3-4531-8eae-a29169ab7e11"
        },
        "id": "RAvTdA8kIJQaki0sEXlR"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "timestamp": "2025-08-24 11:52:57.000",
        "data": {
            "structured_type": "unstructured",
            "detail_level": "high",
            "mapping_index": 2,
            "section_id": "976fd15f-9dc3-4531-8eae-a29169ab7e11"
        },
        "id": "RwBOna2AAehdODC9YzDr"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "timestamp": "2025-08-24 11:52:57.000",
        "data": {
            "structured_type": "unstructured",
            "detail_level": "high",
            "section_id": "976fd15f-9dc3-4531-8eae-a29169ab7e11"
        },
        "id": "TT6nBWTcnM2u8yblssw3"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "timestamp": "2025-08-24 11:52:57.000",
        "data": {
            "structured_type": "unstructured",
            "detail_level": "high",
            "mapping_index": 5,
            "section_id": "976fd15f-9dc3-4531-8eae-a29169ab7e11"
        },
        "id": "TpipkBU52nz9D7VNXg80"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "timestamp": "2025-08-24 11:52:57.000",
        "data": {
            "structured_type": "unstructured",
            "detail_level": "high",
            "section_id": "976fd15f-9dc3-4531-8eae-a29169ab7e11"
        },
        "id": "VmLTkOIrXme6RzkR45lQ"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "timestamp": "2025-08-24 11:52:57.000",
        "data": {
            "structured_type": "unstructured",
            "detail_level": "high",
            "section_id": "976fd15f-9dc3-4531-8eae-a29169ab7e11"
        },
        "id": "beT4qxKKomxO2KSSutA5"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "timestamp": "2025-08-24 11:52:57.000",
        "data": {
            "structured_type": "unstructured",
            "detail_level": "high",
            "mapping_index": 0,
            "section_id": "976fd15f-9dc3-4531-8eae-a29169ab7e11"
        },
        "id": "bvoTfe5FTzm3Ix63jSfI"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "timestamp": "2025-08-24 11:52:57.000",
        "data": {
            "structured_type": "unstructured",
            "detail_level": "high",
            "mapping_index": 5,
            "section_id": "976fd15f-9dc3-4531-8eae-a29169ab7e11"
        },
        "id": "mY8GVOweEcSDkpIawZ0O"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "timestamp": "2025-08-24 11:52:57.000",
        "data": {
            "structured_type": "unstructured",
            "detail_level": "high",
            "section_id": "976fd15f-9dc3-4531-8eae-a29169ab7e11"
        },
        "id": "ojALFeTVziyAiY8bIT10"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "timestamp": "2025-08-24 11:52:57.000",
        "data": {
            "structured_type": "unstructured",
            "detail_level": "high",
            "mapping_index": 3,
            "section_id": "976fd15f-9dc3-4531-8eae-a29169ab7e11"
        },
        "id": "pzS3vPjppZEqeRMnFPFi"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "timestamp": "2025-08-24 11:52:57.000",
        "data": {
            "structured_type": "unstructured",
            "detail_level": "high",
            "section_id": "976fd15f-9dc3-4531-8eae-a29169ab7e11"
        },
        "id": "uNEsTfoB9PQeEQ4neqkM"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "timestamp": "2025-08-24 11:52:58.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "high",
            "section_id": "976fd15f-9dc3-4531-8eae-a29169ab7e11"
        },
        "id": "9TzfFILU2A2rFzC5CxWz"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "timestamp": "2025-08-24 11:52:58.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "high",
            "mapping_index": 1,
            "section_id": "976fd15f-9dc3-4531-8eae-a29169ab7e11"
        },
        "id": "PelY7CXDNCkXM6z8f7BM"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "timestamp": "2025-08-24 11:52:58.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "high",
            "mapping_index": 0,
            "section_id": "976fd15f-9dc3-4531-8eae-a29169ab7e11"
        },
        "id": "Spjap7SStPr8ih1lLSZL"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "timestamp": "2025-08-24 11:52:58.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "high",
            "mapping_index": 2,
            "section_id": "976fd15f-9dc3-4531-8eae-a29169ab7e11"
        },
        "id": "ez14aZb79xs9ONxuwXXx"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "timestamp": "2025-08-24 11:52:58.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "high",
            "section_id": "976fd15f-9dc3-4531-8eae-a29169ab7e11"
        },
        "id": "gaK5Kslgic7JFWZCB6As"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "timestamp": "2025-08-24 11:52:59.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "high",
            "mapping_index": 7,
            "section_id": "976fd15f-9dc3-4531-8eae-a29169ab7e11"
        },
        "id": "5QhSRJAwQ3U1d3GbVMxv"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "timestamp": "2025-08-24 11:52:59.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "high",
            "mapping_index": 4,
            "section_id": "976fd15f-9dc3-4531-8eae-a29169ab7e11"
        },
        "id": "BBBsOGDP1jugsktTRaA6"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "timestamp": "2025-08-24 11:52:59.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "high",
            "mapping_index": 3,
            "section_id": "976fd15f-9dc3-4531-8eae-a29169ab7e11"
        },
        "id": "IdjbpqIQUvl5ZqxbZAH4"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "timestamp": "2025-08-24 11:52:59.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "high",
            "section_id": "976fd15f-9dc3-4531-8eae-a29169ab7e11"
        },
        "id": "O5CwzlMBPfqVFspoyPhb"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "timestamp": "2025-08-24 11:52:59.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "high",
            "mapping_index": 5,
            "section_id": "976fd15f-9dc3-4531-8eae-a29169ab7e11"
        },
        "id": "ToPxufeVbSxo8Ll7kbJB"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "timestamp": "2025-08-24 11:52:59.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "high",
            "section_id": "976fd15f-9dc3-4531-8eae-a29169ab7e11"
        },
        "id": "UmepVx3R6pl51TtThwZL"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "timestamp": "2025-08-24 11:52:59.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "high",
            "mapping_index": 6,
            "section_id": "976fd15f-9dc3-4531-8eae-a29169ab7e11"
        },
        "id": "W1roDfwMZWq0HhNBgn4M"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "timestamp": "2025-08-24 11:52:59.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "high",
            "section_id": "976fd15f-9dc3-4531-8eae-a29169ab7e11"
        },
        "id": "WRzGmPLp5Y9f1XJJ83CV"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "timestamp": "2025-08-24 11:52:59.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "high",
            "section_id": "976fd15f-9dc3-4531-8eae-a29169ab7e11"
        },
        "id": "lF7eqXYFsL3c7JMT0SL6"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "timestamp": "2025-08-24 11:52:59.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "high",
            "section_id": "976fd15f-9dc3-4531-8eae-a29169ab7e11"
        },
        "id": "ztrMSrx7gL66QrkghoCm"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "timestamp": "2025-08-24 11:53:00.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "high",
            "section_id": "976fd15f-9dc3-4531-8eae-a29169ab7e11"
        },
        "id": "05al8T0nKLxTsn6r28GG"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "timestamp": "2025-08-24 11:53:00.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "high",
            "section_id": "976fd15f-9dc3-4531-8eae-a29169ab7e11"
        },
        "id": "CZjZCnBxcCrv0SuwEgbP"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "timestamp": "2025-08-24 11:53:00.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "high",
            "mapping_index": 6,
            "section_id": "976fd15f-9dc3-4531-8eae-a29169ab7e11"
        },
        "id": "PoKo6BsrX2zIEts3SfgN"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "timestamp": "2025-08-24 11:53:07.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "high",
            "section_id": "976fd15f-9dc3-4531-8eae-a29169ab7e11"
        },
        "id": "4N91i4HesYanaNdCdjOE"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "timestamp": "2025-08-24 11:53:07.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "high",
            "mapping_index": 7,
            "section_id": "976fd15f-9dc3-4531-8eae-a29169ab7e11"
        },
        "id": "FO2OSSA1zpM7gPU9VYGh"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "timestamp": "2025-08-24 11:53:07.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "high",
            "mapping_index": 6,
            "section_id": "976fd15f-9dc3-4531-8eae-a29169ab7e11"
        },
        "id": "Np3N0rmAz2zZHbaqA7Pz"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "timestamp": "2025-08-24 11:53:07.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "high",
            "mapping_index": 8,
            "section_id": "976fd15f-9dc3-4531-8eae-a29169ab7e11"
        },
        "id": "YJBupfHKqwmQjLLlkcq5"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "timestamp": "2025-08-24 11:53:07.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "high",
            "section_id": "976fd15f-9dc3-4531-8eae-a29169ab7e11"
        },
        "id": "nhPM32wqgC8MdIyFsprF"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "timestamp": "2025-08-24 11:53:08.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "high",
            "section_id": "976fd15f-9dc3-4531-8eae-a29169ab7e11"
        },
        "id": "IIVxza7E6XX1YQlQoDBw"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "timestamp": "2025-08-24 11:53:08.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "high",
            "section_id": "976fd15f-9dc3-4531-8eae-a29169ab7e11"
        },
        "id": "In14u6TW8syUCTvE7IgW"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "timestamp": "2025-08-24 11:53:08.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "high",
            "section_id": "976fd15f-9dc3-4531-8eae-a29169ab7e11"
        },
        "id": "aft5b73I5ihvE5CAairO"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "timestamp": "2025-08-24 11:53:08.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "high",
            "mapping_index": 9,
            "section_id": "976fd15f-9dc3-4531-8eae-a29169ab7e11"
        },
        "id": "ajnr2UV4pnx8RyruZ3oR"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "timestamp": "2025-08-24 11:53:08.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "high",
            "mapping_index": 8,
            "section_id": "976fd15f-9dc3-4531-8eae-a29169ab7e11"
        },
        "id": "eZjaSVk91RDO2PWrpt4E"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "timestamp": "2025-08-24 11:53:08.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "high",
            "mapping_index": 7,
            "section_id": "976fd15f-9dc3-4531-8eae-a29169ab7e11"
        },
        "id": "vHFGZBHlYNN3QhLeLhib"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "timestamp": "2025-08-24 11:53:09.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "high",
            "mapping_index": 7,
            "section_id": "976fd15f-9dc3-4531-8eae-a29169ab7e11"
        },
        "id": "AowVisYwfGMBBAgHi1xl"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "timestamp": "2025-08-24 11:53:09.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "high",
            "section_id": "976fd15f-9dc3-4531-8eae-a29169ab7e11"
        },
        "id": "D1ltqdydTyaKeFmhx5po"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "timestamp": "2025-08-24 11:53:09.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "high",
            "section_id": "976fd15f-9dc3-4531-8eae-a29169ab7e11"
        },
        "id": "VwTW8Js2IefPyGtBTjCp"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "timestamp": "2025-08-24 11:53:09.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "high",
            "mapping_index": 8,
            "section_id": "976fd15f-9dc3-4531-8eae-a29169ab7e11"
        },
        "id": "oxYjWpsszVDmqwRAdNtA"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "timestamp": "2025-08-24 11:53:10.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "high",
            "section_id": "976fd15f-9dc3-4531-8eae-a29169ab7e11"
        },
        "id": "9pctsvFphNJQa3wlpOhU"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "timestamp": "2025-08-24 11:53:10.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "high",
            "mapping_index": 6,
            "section_id": "976fd15f-9dc3-4531-8eae-a29169ab7e11"
        },
        "id": "GHyEP13p1XpjqVU1tGYE"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "timestamp": "2025-08-24 11:53:10.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "high",
            "mapping_index": 5,
            "section_id": "976fd15f-9dc3-4531-8eae-a29169ab7e11"
        },
        "id": "IrTSUMwjkkAF3ArrCT9r"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "timestamp": "2025-08-24 11:53:10.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "high",
            "section_id": "976fd15f-9dc3-4531-8eae-a29169ab7e11"
        },
        "id": "WyZsDr5iPcYGyilW3LLY"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "timestamp": "2025-08-24 11:53:11.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "high",
            "mapping_index": 4,
            "section_id": "976fd15f-9dc3-4531-8eae-a29169ab7e11"
        },
        "id": "9DaZSm1D8f2ZUChmqhO6"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "timestamp": "2025-08-24 11:53:11.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "high",
            "section_id": "976fd15f-9dc3-4531-8eae-a29169ab7e11"
        },
        "id": "LOBzbKgldTfbfcuyZxcc"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "timestamp": "2025-08-24 11:53:12.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "high",
            "section_id": "976fd15f-9dc3-4531-8eae-a29169ab7e11"
        },
        "id": "8OQFFzB1s4DtDHpnaDdP"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "timestamp": "2025-08-24 11:53:12.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "high",
            "section_id": "976fd15f-9dc3-4531-8eae-a29169ab7e11"
        },
        "id": "L80Cxu0IRcbzNCfyc3y3"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "timestamp": "2025-08-24 11:53:12.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "high",
            "mapping_index": 3,
            "section_id": "976fd15f-9dc3-4531-8eae-a29169ab7e11"
        },
        "id": "WBMDp5NZdTw4ry8kjBDo"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "timestamp": "2025-08-24 11:53:51.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "high",
            "mapping_index": 0,
            "section_id": "976fd15f-9dc3-4531-8eae-a29169ab7e11"
        },
        "id": "s5uYC7kte30w5oWP2MAJ"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "timestamp": "2025-08-24 11:53:52.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "high",
            "section_id": "976fd15f-9dc3-4531-8eae-a29169ab7e11"
        },
        "id": "OyZl23W1JdCessddMZTR"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "timestamp": "2025-08-24 11:53:54.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "high",
            "mapping_index": 0,
            "section_id": "976fd15f-9dc3-4531-8eae-a29169ab7e11"
        },
        "id": "cLUiJLAoIongvSNpOKiR"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "timestamp": "2025-08-24 11:53:54.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "high",
            "section_id": "976fd15f-9dc3-4531-8eae-a29169ab7e11"
        },
        "id": "heTkXNeRNHbA85kiwTn9"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "timestamp": "2025-08-24 11:53:54.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "high",
            "section_id": "976fd15f-9dc3-4531-8eae-a29169ab7e11"
        },
        "id": "p1IFthwynukfBX3V5knU"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "timestamp": "2025-08-24 11:53:54.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "high",
            "mapping_index": 0,
            "section_id": "976fd15f-9dc3-4531-8eae-a29169ab7e11"
        },
        "id": "uPVBxF6atXKd1r2Hrolm"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "timestamp": "2025-08-24 11:53:59.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "high",
            "mapping_index": 2,
            "section_id": "976fd15f-9dc3-4531-8eae-a29169ab7e11"
        },
        "id": "7OUDCFZk2mZo2bSrpULQ"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "timestamp": "2025-08-24 11:53:59.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "high",
            "section_id": "976fd15f-9dc3-4531-8eae-a29169ab7e11"
        },
        "id": "Bnb9BsTDcXIMx6CvyAQN"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "timestamp": "2025-08-24 11:53:59.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "high",
            "mapping_index": 1,
            "section_id": "976fd15f-9dc3-4531-8eae-a29169ab7e11"
        },
        "id": "Hq8RJQ4t1nkkdxcdQUrv"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "timestamp": "2025-08-24 11:53:59.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "high",
            "section_id": "976fd15f-9dc3-4531-8eae-a29169ab7e11"
        },
        "id": "Ras3nqfx5mbsa4uQaXmd"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "timestamp": "2025-08-24 11:53:59.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "high",
            "mapping_index": 3,
            "section_id": "976fd15f-9dc3-4531-8eae-a29169ab7e11"
        },
        "id": "VeSOKd0zXcNTTsHaSV9Y"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "timestamp": "2025-08-24 11:53:59.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "high",
            "section_id": "976fd15f-9dc3-4531-8eae-a29169ab7e11"
        },
        "id": "seYGBbLIEluHNdN5Y4R8"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "timestamp": "2025-08-24 11:53:59.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "high",
            "mapping_index": 4,
            "section_id": "976fd15f-9dc3-4531-8eae-a29169ab7e11"
        },
        "id": "thIDw97C4GuDuZJgC8me"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "timestamp": "2025-08-24 11:54:00.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "high",
            "section_id": "976fd15f-9dc3-4531-8eae-a29169ab7e11"
        },
        "id": "14drwJ8fS6WsI0weN901"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "timestamp": "2025-08-24 11:54:00.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "high",
            "mapping_index": 5,
            "section_id": "976fd15f-9dc3-4531-8eae-a29169ab7e11"
        },
        "id": "2VtwYgCyDVieDAOBo8up"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "timestamp": "2025-08-24 11:54:00.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "high",
            "section_id": "976fd15f-9dc3-4531-8eae-a29169ab7e11"
        },
        "id": "4vyUjuzLkGvM2kUA9VWI"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "timestamp": "2025-08-24 11:54:00.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "high",
            "mapping_index": 8,
            "section_id": "976fd15f-9dc3-4531-8eae-a29169ab7e11"
        },
        "id": "A42dOtV2kIB152JNjk08"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "timestamp": "2025-08-24 11:54:00.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "high",
            "section_id": "976fd15f-9dc3-4531-8eae-a29169ab7e11"
        },
        "id": "GfcpPnu9ZtJJBJtdtsyF"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "timestamp": "2025-08-24 11:54:00.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "high",
            "section_id": "976fd15f-9dc3-4531-8eae-a29169ab7e11"
        },
        "id": "Jl8tfG4B6qfla9c3AGHS"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "timestamp": "2025-08-24 11:54:00.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "high",
            "mapping_index": 9,
            "section_id": "976fd15f-9dc3-4531-8eae-a29169ab7e11"
        },
        "id": "WPQRZc8foI24Vc5grNVY"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "timestamp": "2025-08-24 11:54:00.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "high",
            "section_id": "976fd15f-9dc3-4531-8eae-a29169ab7e11"
        },
        "id": "XzQfZWPzGc6pv3vYmO5S"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "timestamp": "2025-08-24 11:54:00.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "high",
            "mapping_index": 6,
            "section_id": "976fd15f-9dc3-4531-8eae-a29169ab7e11"
        },
        "id": "fNevziCMclKy9NY3BnOz"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "timestamp": "2025-08-24 11:54:00.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "high",
            "mapping_index": 7,
            "section_id": "976fd15f-9dc3-4531-8eae-a29169ab7e11"
        },
        "id": "fP7m1ZkgnBg3cAOPa7Kg"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "timestamp": "2025-08-24 11:54:00.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "high",
            "section_id": "976fd15f-9dc3-4531-8eae-a29169ab7e11"
        },
        "id": "xb2BIrJB35GUxydUNo74"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "timestamp": "2025-08-24 11:54:01.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "high",
            "mapping_index": 0,
            "section_id": "976fd15f-9dc3-4531-8eae-a29169ab7e11"
        },
        "id": "8oueEPLLjsEtuMPZg4t4"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "timestamp": "2025-08-24 11:54:01.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "high",
            "section_id": "976fd15f-9dc3-4531-8eae-a29169ab7e11"
        },
        "id": "tBjmKQYB7nBW5guFbdvw"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "timestamp": "2025-08-24 11:54:02.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "high",
            "mapping_index": 0,
            "section_id": "976fd15f-9dc3-4531-8eae-a29169ab7e11"
        },
        "id": "0tgcyOmidAjpQKLQIO8r"
    },
    {
        "source": "frontend",
        "event": "click_edit_in_prompt",
        "timestamp": "2025-08-24 11:54:02.000",
        "data": {
            "detail_level": "high",
            "structured": "structured",
            "summary": "• Loads player data and splits it by year into training (all but last two years) and test (last two years) sets\n• Prepares training and test feature matrices, target ranks, and group sizes for ranking\n• Initializes and trains an XGBRanker model with specific hyperparameters\n  ◦ Uses 'rank:pairwise' objective and groups data by year for proper ranking\n• Predicts ranking scores for test data\n  ◦ Assigns predicted ranks within each year based on predicted scores\n  ◦ Stores predicted scores and ranks in the DataFrame\n• Evaluates model performance using the NDCG metric on test years\n• Prints detailed prediction results for each player in the test years\n• Generates and saves bar plots visualizing prediction errors for 2024 and 2025",
            "section_id": "976fd15f-9dc3-4531-8eae-a29169ab7e11"
        },
        "id": "Qzv9RokmGce1ytdH9Hpd"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "timestamp": "2025-08-24 11:54:02.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "high",
            "section_id": "976fd15f-9dc3-4531-8eae-a29169ab7e11"
        },
        "id": "SBELOBRjEP3WlVpYujWb"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "timestamp": "2025-08-24 11:54:03.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "high",
            "mapping_index": 9,
            "section_id": "976fd15f-9dc3-4531-8eae-a29169ab7e11"
        },
        "id": "QcKy5GpTrlF2MEyeshSg"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "timestamp": "2025-08-24 11:54:03.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "high",
            "section_id": "976fd15f-9dc3-4531-8eae-a29169ab7e11"
        },
        "id": "gz7ciLTF5MApk7pyG0rh"
    },
    {
        "source": "frontend",
        "event": "apply_instruction_summary",
        "timestamp": "2025-08-24 11:55:13.000",
        "data": {
            "detail_level": "high",
            "structured": "structured",
            "instruction": "Try n_estimator = (100,1000, 2000) and evaluate the result to pick the best parameter",
            "original_summary": "• Loads player data and splits it by year into training (all but last two years) and test (last two years) sets\n• Prepares training and test feature matrices, target ranks, and group sizes for ranking\n• Initializes and trains an XGBRanker model with specific hyperparameters\n  ◦ Uses 'rank:pairwise' objective and groups data by year for proper ranking\n• Predicts ranking scores for test data\n  ◦ Assigns predicted ranks within each year based on predicted scores\n  ◦ Stores predicted scores and ranks in the DataFrame\n• Evaluates model performance using the NDCG metric on test years\n• Prints detailed prediction results for each player in the test years\n• Generates and saves bar plots visualizing prediction errors for 2024 and 2025",
            "section_id": "976fd15f-9dc3-4531-8eae-a29169ab7e11"
        },
        "id": "1VyKDn6PfqQYNwdX0t7q"
    },
    {
        "source": "backend",
        "event": "apply_instruction_summary",
        "timestamp": "2025-08-24 11:55:15.000",
        "data": {
            "original_code": "def main():\n    X, y, group, df = load_data()\n\n    # Train-test split on years\n    unique_years = df[\"Year\"].unique()\n    train_years, test_years = (\n        unique_years[:-2],  # train: 2015-2023\n        unique_years[-2:],  # test: 2024-2025\n    )\n\n    train_idx = df[\"Year\"].isin(train_years)\n    test_idx = df[\"Year\"].isin(test_years)\n\n    X_train, X_test = X[train_idx], X[test_idx]\n    y_train, y_test = y[train_idx], y[test_idx]\n\n    # Group sizes\n    train_groups = df[train_idx].groupby(\"Year\").size().to_numpy()\n    test_groups = df[test_idx].groupby(\"Year\").size().to_numpy()\n\n    # Model\n    model = XGBRanker(\n        objective=\"rank:pairwise\",\n        learning_rate=0.1,\n        n_estimators=100,\n        max_depth=4,\n        random_state=42,\n    )\n\n    print(\"Training XGBoostRanker...\")\n    model.fit(X_train, y_train, group=train_groups)\n\n    # Predict, sort, and evaluate\n    y_pred = model.predict(X_test)\n    df.loc[test_idx, \"PredictedScore\"] = y_pred\n    df.loc[test_idx, \"PredictedRank\"] = (\n        df.loc[test_idx]\n        .groupby(\"Year\")[\"PredictedScore\"]\n        .rank(ascending=False, method=\"first\")\n    )\n\n    ndcg = evaluate_ndcg(y_test.to_numpy(), y_pred, test_groups)\n    print(f\"NDCG Score on test years {test_years.tolist()}: {ndcg:.4f}\")\n\n    # Show results\n    print(df[test_idx][[\"Year\", \"Name\", \"Rank\", \"PredictedScore\", \"PredictedRank\"]])\n    plot_ranking_predictions(df, 2024)\n    plot_ranking_predictions(df, 2025)\n\n\nif __name__ == \"__main__\":\n    main()\n",
            "updated_summary": "• Loads player data and splits it by year into training (all but last two years) and test (last two years) sets  \n• Prepares training and test feature matrices, target ranks, and group sizes for ranking  \n• Initializes and trains an XGBRanker model with specific hyperparameters  \n  ◦ Uses 'rank:pairwise' objective and groups data by year for proper ranking  \n  ◦ Tries multiple values for n_estimators (100, 1000, 2000), evaluates the results for each, and selects the best parameter based on evaluation metrics  \n• Predicts ranking scores for test data  \n  ◦ Assigns predicted ranks within each year based on predicted scores  \n  ◦ Stores predicted scores and ranks in the DataFrame  \n• Evaluates model performance using the NDCG metric on test years  \n• Prints detailed prediction results for each player in the test years  \n• Generates and saves bar plots visualizing prediction errors for 2024 and 2025",
            "instruction": "Try n_estimator = (100,1000, 2000) and evaluate the result to pick the best parameter",
            "original_summary": "• Loads player data and splits it by year into training (all but last two years) and test (last two years) sets\n• Prepares training and test feature matrices, target ranks, and group sizes for ranking\n• Initializes and trains an XGBRanker model with specific hyperparameters\n  ◦ Uses 'rank:pairwise' objective and groups data by year for proper ranking\n• Predicts ranking scores for test data\n  ◦ Assigns predicted ranks within each year based on predicted scores\n  ◦ Stores predicted scores and ranks in the DataFrame\n• Evaluates model performance using the NDCG metric on test years\n• Prints detailed prediction results for each player in the test years\n• Generates and saves bar plots visualizing prediction errors for 2024 and 2025"
        },
        "id": "I9qSFBtGiDYknjpXKnw2"
    },
    {
        "source": "frontend",
        "event": "commit_modified_summary",
        "timestamp": "2025-08-24 11:55:50.000",
        "data": {
            "detail_level": "high",
            "structured": "structured",
            "edited_summary": "• Loads player data and splits it by year into training (all but last two years) and test (last two years) sets  \n• Prepares training and test feature matrices, target ranks, and group sizes for ranking  \n• Initializes and trains an XGBRanker model with specific hyperparameters  \n  ◦ Uses 'rank:pairwise' objective and groups data by year for proper ranking  \n  ◦ Tries multiple values for n_estimators (100, 1000, 2000), evaluates the results for each, and selects the best parameter based on evaluation metrics  \n• Predicts ranking scores for test data  \n  ◦ Assigns predicted ranks within each year based on predicted scores  \n  ◦ Stores predicted scores and ranks in the DataFrame  \n• Evaluates model performance using the NDCG metric on test years  \n• Prints detailed prediction results for each player in the test years  \n• Generates and saves bar plots visualizing prediction errors for 2024 and 2025",
            "original_summary": "• Loads player data and splits it by year into training (all but last two years) and test (last two years) sets\n• Prepares training and test feature matrices, target ranks, and group sizes for ranking\n• Initializes and trains an XGBRanker model with specific hyperparameters\n  ◦ Uses 'rank:pairwise' objective and groups data by year for proper ranking\n• Predicts ranking scores for test data\n  ◦ Assigns predicted ranks within each year based on predicted scores\n  ◦ Stores predicted scores and ranks in the DataFrame\n• Evaluates model performance using the NDCG metric on test years\n• Prints detailed prediction results for each player in the test years\n• Generates and saves bar plots visualizing prediction errors for 2024 and 2025",
            "section_id": "976fd15f-9dc3-4531-8eae-a29169ab7e11"
        },
        "id": "MW4lZTqzViQppq05lhdS"
    },
    {
        "source": "backend",
        "event": "modify_summary_mediation",
        "timestamp": "2025-08-24 11:55:55.000",
        "data": {
            "original_code": "def main():\n    X, y, group, df = load_data()\n\n    # Train-test split on years\n    unique_years = df[\"Year\"].unique()\n    train_years, test_years = (\n        unique_years[:-2],  # train: 2015-2023\n        unique_years[-2:],  # test: 2024-2025\n    )\n\n    train_idx = df[\"Year\"].isin(train_years)\n    test_idx = df[\"Year\"].isin(test_years)\n\n    X_train, X_test = X[train_idx], X[test_idx]\n    y_train, y_test = y[train_idx], y[test_idx]\n\n    # Group sizes\n    train_groups = df[train_idx].groupby(\"Year\").size().to_numpy()\n    test_groups = df[test_idx].groupby(\"Year\").size().to_numpy()\n\n    # Model\n    model = XGBRanker(\n        objective=\"rank:pairwise\",\n        learning_rate=0.1,\n        n_estimators=100,\n        max_depth=4,\n        random_state=42,\n    )\n\n    print(\"Training XGBoostRanker...\")\n    model.fit(X_train, y_train, group=train_groups)\n\n    # Predict, sort, and evaluate\n    y_pred = model.predict(X_test)\n    df.loc[test_idx, \"PredictedScore\"] = y_pred\n    df.loc[test_idx, \"PredictedRank\"] = (\n        df.loc[test_idx]\n        .groupby(\"Year\")[\"PredictedScore\"]\n        .rank(ascending=False, method=\"first\")\n    )\n\n    ndcg = evaluate_ndcg(y_test.to_numpy(), y_pred, test_groups)\n    print(f\"NDCG Score on test years {test_years.tolist()}: {ndcg:.4f}\")\n\n    # Show results\n    print(df[test_idx][[\"Year\", \"Name\", \"Rank\", \"PredictedScore\", \"PredictedRank\"]])\n    plot_ranking_predictions(df, 2024)\n    plot_ranking_predictions(df, 2025)\n\n\nif __name__ == \"__main__\":\n    main()\n",
            "detail_level": "high",
            "edited_summary": "• Loads player data and splits it by year into training (all but last two years) and test (last two years) sets  \n• Prepares training and test feature matrices, target ranks, and group sizes for ranking  \n• Initializes and trains an XGBRanker model with specific hyperparameters  \n  ◦ Uses 'rank:pairwise' objective and groups data by year for proper ranking  \n  ◦ Tries multiple values for n_estimators (100, 1000, 2000), evaluates the results for each, and selects the best parameter based on evaluation metrics  \n• Predicts ranking scores for test data  \n  ◦ Assigns predicted ranks within each year based on predicted scores  \n  ◦ Stores predicted scores and ranks in the DataFrame  \n• Evaluates model performance using the NDCG metric on test years  \n• Prints detailed prediction results for each player in the test years  \n• Generates and saves bar plots visualizing prediction errors for 2024 and 2025",
            "original_summary": "• Loads player data and splits it by year into training (all but last two years) and test (last two years) sets\n• Prepares training and test feature matrices, target ranks, and group sizes for ranking\n• Initializes and trains an XGBRanker model with specific hyperparameters\n  ◦ Uses 'rank:pairwise' objective and groups data by year for proper ranking\n• Predicts ranking scores for test data\n  ◦ Assigns predicted ranks within each year based on predicted scores\n  ◦ Stores predicted scores and ranks in the DataFrame\n• Evaluates model performance using the NDCG metric on test years\n• Prints detailed prediction results for each player in the test years\n• Generates and saves bar plots visualizing prediction errors for 2024 and 2025",
            "updated_code": "def main():\n    X, y, group, df = load_data()\n\n    # Train-test split on years\n    unique_years = df[\"Year\"].unique()\n    train_years, test_years = (\n        unique_years[:-2],  # train: 2015-2023\n        unique_years[-2:],  # test: 2024-2025\n    )\n\n    train_idx = df[\"Year\"].isin(train_years)\n    test_idx = df[\"Year\"].isin(test_years)\n\n    X_train, X_test = X[train_idx], X[test_idx]\n    y_train, y_test = y[train_idx], y[test_idx]\n\n    # Group sizes\n    train_groups = df[train_idx].groupby(\"Year\").size().to_numpy()\n    test_groups = df[test_idx].groupby(\"Year\").size().to_numpy()\n\n    # Try multiple n_estimators and select the best based on NDCG\n    n_estimators_list = [100, 1000, 2000]\n    best_ndcg = -np.inf\n    best_model = None\n    best_n_estimators = None\n    best_y_pred = None\n\n    for n_estimators in n_estimators_list:\n        model = XGBRanker(\n            objective=\"rank:pairwise\",\n            learning_rate=0.1,\n            n_estimators=n_estimators,\n            max_depth=4,\n            random_state=42,\n        )\n\n        print(f\"Training XGBoostRanker with n_estimators={n_estimators}...\")\n        model.fit(X_train, y_train, group=train_groups)\n\n        y_pred = model.predict(X_test)\n        ndcg = evaluate_ndcg(y_test.to_numpy(), y_pred, test_groups)\n        print(f\"NDCG Score with n_estimators={n_estimators}: {ndcg:.4f}\")\n\n        if ndcg > best_ndcg:\n            best_ndcg = ndcg\n            best_model = model\n            best_n_estimators = n_estimators\n            best_y_pred = y_pred\n\n    print(f\"\\nBest n_estimators: {best_n_estimators} with NDCG: {best_ndcg:.4f}\")\n\n    # Predict, sort, and evaluate with the best model\n    y_pred = best_y_pred\n    df.loc[test_idx, \"PredictedScore\"] = y_pred\n    df.loc[test_idx, \"PredictedRank\"] = (\n        df.loc[test_idx]\n        .groupby(\"Year\")[\"PredictedScore\"]\n        .rank(ascending=False, method=\"first\")\n    )\n\n    print(f\"NDCG Score on test years {test_years.tolist()}: {best_ndcg:.4f}\")\n\n    # Show results\n    print(df[test_idx][[\"Year\", \"Name\", \"Rank\", \"PredictedScore\", \"PredictedRank\"]])\n    plot_ranking_predictions(df, 2024)\n    plot_ranking_predictions(df, 2025)\n\n\nif __name__ == \"__main__\":\n    main()",
            "structured_type": "structured"
        },
        "id": "YUQyOXxFvqkSkduDFPKq"
    },
    {
        "source": "backend",
        "event": "summarize_modified_code",
        "timestamp": "2025-08-24 11:56:09.000",
        "data": {
            "original_code": "def main():\n    X, y, group, df = load_data()\n\n    # Train-test split on years\n    unique_years = df[\"Year\"].unique()\n    train_years, test_years = (\n        unique_years[:-2],  # train: 2015-2023\n        unique_years[-2:],  # test: 2024-2025\n    )\n\n    train_idx = df[\"Year\"].isin(train_years)\n    test_idx = df[\"Year\"].isin(test_years)\n\n    X_train, X_test = X[train_idx], X[test_idx]\n    y_train, y_test = y[train_idx], y[test_idx]\n\n    # Group sizes\n    train_groups = df[train_idx].groupby(\"Year\").size().to_numpy()\n    test_groups = df[test_idx].groupby(\"Year\").size().to_numpy()\n\n    # Try multiple n_estimators and select the best based on NDCG\n    n_estimators_list = [100, 1000, 2000]\n    best_ndcg = -np.inf\n    best_model = None\n    best_n_estimators = None\n    best_y_pred = None\n\n    for n_estimators in n_estimators_list:\n        model = XGBRanker(\n            objective=\"rank:pairwise\",\n            learning_rate=0.1,\n            n_estimators=n_estimators,\n            max_depth=4,\n            random_state=42,\n        )\n\n        print(f\"Training XGBoostRanker with n_estimators={n_estimators}...\")\n        model.fit(X_train, y_train, group=train_groups)\n\n        y_pred = model.predict(X_test)\n        ndcg = evaluate_ndcg(y_test.to_numpy(), y_pred, test_groups)\n        print(f\"NDCG Score with n_estimators={n_estimators}: {ndcg:.4f}\")\n\n        if ndcg > best_ndcg:\n            best_ndcg = ndcg\n            best_model = model\n            best_n_estimators = n_estimators\n            best_y_pred = y_pred\n\n    print(f\"\\nBest n_estimators: {best_n_estimators} with NDCG: {best_ndcg:.4f}\")\n\n    # Predict, sort, and evaluate with the best model\n    y_pred = best_y_pred\n    df.loc[test_idx, \"PredictedScore\"] = y_pred\n    df.loc[test_idx, \"PredictedRank\"] = (\n        df.loc[test_idx]\n        .groupby(\"Year\")[\"PredictedScore\"]\n        .rank(ascending=False, method=\"first\")\n    )\n\n    print(f\"NDCG Score on test years {test_years.tolist()}: {best_ndcg:.4f}\")\n\n    # Show results\n    print(df[test_idx][[\"Year\", \"Name\", \"Rank\", \"PredictedScore\", \"PredictedRank\"]])\n    plot_ranking_predictions(df, 2024)\n    plot_ranking_predictions(df, 2025)\n\n\nif __name__ == \"__main__\":\n    main()",
            "new_summary": {
                "medium_structured": "• Loads data and splits it into training (earlier years) and test (most recent years) sets\n• Trains an XGBoost ranking model on the training data, trying multiple n_estimators values and selecting the best based on NDCG\n• Predicts and ranks players for the test years\n• Evaluates model performance using the NDCG metric\n• Generates and saves plots of prediction errors for the test years",
                "low_unstructured": "This function now trains and evaluates an XGBoost ranking model on basketball player data split by year, trying multiple n_estimators values and selecting the best model based on NDCG.",
                "high_structured": "• Loads player data and splits it by year into training (all but last two years) and test (last two years) sets\n• Prepares training and test feature matrices, target ranks, and group sizes for ranking\n• Initializes and trains an XGBRanker model with specific hyperparameters, now trying multiple n_estimators values and selecting the best based on NDCG\n  ◦ Uses 'rank:pairwise' objective and groups data by year for proper ranking\n• Predicts ranking scores for test data using the best model\n  ◦ Assigns predicted ranks within each year based on predicted scores\n  ◦ Stores predicted scores and ranks in the DataFrame\n• Evaluates model performance using the NDCG metric on test years\n• Prints detailed prediction results for each player in the test years\n• Generates and saves bar plots visualizing prediction errors for 2024 and 2025",
                "low_structured": "• Loads data and splits it into training and test sets by year\n• Trains an XGBoost ranking model using multiple n_estimators values and selects the best based on NDCG\n• Evaluates and prints results for recent years",
                "high_unstructured": "The main() function orchestrates the process of training and evaluating an XGBoost ranking model on basketball player statistics. It first loads the data and splits it into training and test sets based on year, with the last two years reserved for testing. The function now iterates over several n_estimators values, trains an XGBRanker for each, and selects the model with the highest NDCG score using group information for proper ranking. It predicts scores for the test set, assigns predicted ranks within each year, computes the NDCG score to assess ranking quality, prints detailed prediction results for the test years, and generates bar plots visualizing prediction errors for each player in the test years.",
                "medium_unstructured": "The main() function loads basketball player data, splits it into training and test sets based on years, and trains an XGBoost ranking model. It now tries several n_estimators values, selects the one yielding the highest NDCG score, predicts rankings for the test years, evaluates performance using the NDCG metric, and prints the results. Additionally, it generates plots to visualize prediction errors for the test years.",
                "title": "Summary of the main() Function in rank_model.py (with n_estimators Grid Search)"
            },
            "old_summary": {
                "medium_structured": "• Loads data and splits it into training (earlier years) and test (most recent years) sets\n• Trains an XGBoost ranking model on the training data\n• Predicts and ranks players for the test years\n• Evaluates model performance using the NDCG metric\n• Generates and saves plots of prediction errors for the test years",
                "low_unstructured": "This function trains and evaluates an XGBoost ranking model on basketball player data split by year.",
                "high_structured": "• Loads player data and splits it by year into training (all but last two years) and test (last two years) sets\n• Prepares training and test feature matrices, target ranks, and group sizes for ranking\n• Initializes and trains an XGBRanker model with specific hyperparameters\n  ◦ Uses 'rank:pairwise' objective and groups data by year for proper ranking\n• Predicts ranking scores for test data\n  ◦ Assigns predicted ranks within each year based on predicted scores\n  ◦ Stores predicted scores and ranks in the DataFrame\n• Evaluates model performance using the NDCG metric on test years\n• Prints detailed prediction results for each player in the test years\n• Generates and saves bar plots visualizing prediction errors for 2024 and 2025",
                "low_structured": "• Loads data and splits it into training and test sets by year\n• Trains an XGBoost ranking model\n• Evaluates and prints results for recent years",
                "high_unstructured": "The main() function orchestrates the process of training and evaluating an XGBoost ranking model on basketball player statistics. It first loads the data and splits it into training and test sets based on year, with the last two years reserved for testing. The function trains an XGBRanker using group information for proper ranking, predicts scores for the test set, and assigns predicted ranks within each year. It then computes the NDCG score to assess ranking quality, prints detailed prediction results for the test years, and generates bar plots visualizing prediction errors for each player in the test years.",
                "medium_unstructured": "The main() function loads basketball player data, splits it into training and test sets based on years, and trains an XGBoost ranking model. It predicts rankings for the test years, evaluates performance using the NDCG metric, and prints the results. Additionally, it generates plots to visualize prediction errors for the test years.",
                "title": "Summary of the main() Function in rank_model.py"
            },
            "new_code": "def main():\n    X, y, group, df = load_data()\n\n    # Train-test split on years\n    unique_years = df[\"Year\"].unique()\n    train_years, test_years = (\n        unique_years[:-2],  # train: 2015-2023\n        unique_years[-2:],  # test: 2024-2025\n    )\n\n    train_idx = df[\"Year\"].isin(train_years)\n    test_idx = df[\"Year\"].isin(test_years)\n\n    X_train, X_test = X[train_idx], X[test_idx]\n    y_train, y_test = y[train_idx], y[test_idx]\n\n    # Group sizes\n    train_groups = df[train_idx].groupby(\"Year\").size().to_numpy()\n    test_groups = df[test_idx].groupby(\"Year\").size().to_numpy()\n\n    # Try multiple n_estimators and select the best based on NDCG\n    n_estimators_list = [100, 1000, 2000]\n    best_ndcg = -np.inf\n    best_model = None\n    best_n_estimators = None\n    best_y_pred = None\n\n    for n_estimators in n_estimators_list:\n        model = XGBRanker(\n            objective=\"rank:pairwise\",\n            learning_rate=0.1,\n            n_estimators=n_estimators,\n            max_depth=4,\n            random_state=42,\n        )\n\n        print(f\"Training XGBoostRanker with n_estimators={n_estimators}...\")\n        model.fit(X_train, y_train, group=train_groups)\n\n        y_pred = model.predict(X_test)\n        ndcg = evaluate_ndcg(y_test.to_numpy(), y_pred, test_groups)\n        print(f\"NDCG Score with n_estimators={n_estimators}: {ndcg:.4f}\")\n\n        if ndcg > best_ndcg:\n            best_ndcg = ndcg\n            best_model = model\n            best_n_estimators = n_estimators\n            best_y_pred = y_pred\n\n    print(f\"\\nBest n_estimators: {best_n_estimators} with NDCG: {best_ndcg:.4f}\")\n\n    # Predict, sort, and evaluate with the best model\n    y_pred = best_y_pred\n    df.loc[test_idx, \"PredictedScore\"] = y_pred\n    df.loc[test_idx, \"PredictedRank\"] = (\n        df.loc[test_idx]\n        .groupby(\"Year\")[\"PredictedScore\"]\n        .rank(ascending=False, method=\"first\")\n    )\n\n    print(f\"NDCG Score on test years {test_years.tolist()}: {best_ndcg:.4f}\")\n\n    # Show results\n    print(df[test_idx][[\"Year\", \"Name\", \"Rank\", \"PredictedScore\", \"PredictedRank\"]])\n    plot_ranking_predictions(df, 2024)\n    plot_ranking_predictions(df, 2025)\n\n\nif __name__ == \"__main__\":\n    main()"
        },
        "id": "9MSTLnMAWWxn3EEka00E"
    },
    {
        "source": "backend",
        "event": "map_summary_code",
        "timestamp": "2025-08-24 11:56:12.000",
        "data": {
            "summary": "• Loads data and splits it into training and test sets by year\n• Trains an XGBoost ranking model using multiple n_estimators values and selects the best based on NDCG\n• Evaluates and prints results for recent years",
            "code": "74: def main():\n75:     X, y, group, df = load_data()\n76: \n77:     # Train-test split on years\n78:     unique_years = df[\"Year\"].unique()\n79:     train_years, test_years = (\n80:         unique_years[:-2],  # train: 2015-2023\n81:         unique_years[-2:],  # test: 2024-2025\n82:     )\n83: \n84:     train_idx = df[\"Year\"].isin(train_years)\n85:     test_idx = df[\"Year\"].isin(test_years)\n86: \n87:     X_train, X_test = X[train_idx], X[test_idx]\n88:     y_train, y_test = y[train_idx], y[test_idx]\n89: \n90:     # Group sizes\n91:     train_groups = df[train_idx].groupby(\"Year\").size().to_numpy()\n92:     test_groups = df[test_idx].groupby(\"Year\").size().to_numpy()\n93: \n94:     # Try multiple n_estimators and select the best based on NDCG\n95:     n_estimators_list = [100, 1000, 2000]\n96:     best_ndcg = -np.inf\n97:     best_model = None\n98:     best_n_estimators = None\n99:     best_y_pred = None\n100: \n101:     for n_estimators in n_estimators_list:\n102:         model = XGBRanker(\n103:             objective=\"rank:pairwise\",\n104:             learning_rate=0.1,\n105:             n_estimators=n_estimators,\n106:             max_depth=4,\n107:             random_state=42,\n108:         )\n109: \n110:         print(f\"Training XGBoostRanker with n_estimators={n_estimators}...\")\n111:         model.fit(X_train, y_train, group=train_groups)\n112: \n113:         y_pred = model.predict(X_test)\n114:         ndcg = evaluate_ndcg(y_test.to_numpy(), y_pred, test_groups)\n115:         print(f\"NDCG Score with n_estimators={n_estimators}: {ndcg:.4f}\")\n116: \n117:         if ndcg > best_ndcg:\n118:             best_ndcg = ndcg\n119:             best_model = model\n120:             best_n_estimators = n_estimators\n121:             best_y_pred = y_pred\n122: \n123:     print(f\"\\nBest n_estimators: {best_n_estimators} with NDCG: {best_ndcg:.4f}\")\n124: \n125:     # Predict, sort, and evaluate with the best model\n126:     y_pred = best_y_pred\n127:     df.loc[test_idx, \"PredictedScore\"] = y_pred\n128:     df.loc[test_idx, \"PredictedRank\"] = (\n129:         df.loc[test_idx]\n130:         .groupby(\"Year\")[\"PredictedScore\"]\n131:         .rank(ascending=False, method=\"first\")\n132:     )\n133: \n134:     print(f\"NDCG Score on test years {test_years.tolist()}: {best_ndcg:.4f}\")\n135: \n136:     # Show results\n137:     print(df[test_idx][[\"Year\", \"Name\", \"Rank\", \"PredictedScore\", \"PredictedRank\"]])\n138:     plot_ranking_predictions(df, 2024)\n139:     plot_ranking_predictions(df, 2025)\n140: \n141: \n142: if __name__ == \"__main__\":\n143:     main()",
            "mapping": [
                {
                    "summaryComponent": "Loads data",
                    "codeSegments": [
                        {
                            "code": "X, y, group, df = load_data()",
                            "line": 75
                        }
                    ]
                },
                {
                    "summaryComponent": "splits it into training and test sets by year",
                    "codeSegments": [
                        {
                            "code": "unique_years = df[\"Year\"].unique()",
                            "line": 78
                        },
                        {
                            "code": "train_years, test_years = (",
                            "line": 79
                        },
                        {
                            "code": "train_idx = df[\"Year\"].isin(train_years)",
                            "line": 84
                        },
                        {
                            "code": "test_idx = df[\"Year\"].isin(test_years)",
                            "line": 85
                        },
                        {
                            "code": "X_train, X_test = X[train_idx], X[test_idx]",
                            "line": 87
                        },
                        {
                            "code": "y_train, y_test = y[train_idx], y[test_idx]",
                            "line": 88
                        }
                    ]
                },
                {
                    "summaryComponent": "Trains an XGBoost ranking model using multiple n_estimators values",
                    "codeSegments": [
                        {
                            "code": "n_estimators_list = [100, 1000, 2000]",
                            "line": 95
                        },
                        {
                            "code": "for n_estimators in n_estimators_list:",
                            "line": 101
                        },
                        {
                            "code": "model = XGBRanker(",
                            "line": 102
                        },
                        {
                            "code": "model.fit(X_train, y_train, group=train_groups)",
                            "line": 111
                        }
                    ]
                },
                {
                    "summaryComponent": "selects the best based on NDCG",
                    "codeSegments": [
                        {
                            "code": "ndcg = evaluate_ndcg(y_test.to_numpy(), y_pred, test_groups)",
                            "line": 114
                        },
                        {
                            "code": "if ndcg > best_ndcg:",
                            "line": 117
                        },
                        {
                            "code": "best_ndcg = ndcg",
                            "line": 118
                        },
                        {
                            "code": "best_model = model",
                            "line": 119
                        },
                        {
                            "code": "best_n_estimators = n_estimators",
                            "line": 120
                        }
                    ]
                },
                {
                    "summaryComponent": "Evaluates and prints results for recent years",
                    "codeSegments": [
                        {
                            "code": "print(f\"NDCG Score on test years {test_years.tolist()}: {best_ndcg:.4f}\")",
                            "line": 134
                        },
                        {
                            "code": "print(df[test_idx][[\"Year\", \"Name\", \"Rank\", \"PredictedScore\", \"PredictedRank\"]])",
                            "line": 137
                        },
                        {
                            "code": "plot_ranking_predictions(df, 2024)",
                            "line": 138
                        },
                        {
                            "code": "plot_ranking_predictions(df, 2025)",
                            "line": 139
                        }
                    ]
                }
            ]
        },
        "id": "TFINVNjHBHLpCqyXwLey"
    },
    {
        "source": "backend",
        "event": "map_summary_code",
        "timestamp": "2025-08-24 11:56:12.000",
        "data": {
            "summary": "This function now trains and evaluates an XGBoost ranking model on basketball player data split by year, trying multiple n_estimators values and selecting the best model based on NDCG.",
            "code": "74: def main():\n75:     X, y, group, df = load_data()\n76: \n77:     # Train-test split on years\n78:     unique_years = df[\"Year\"].unique()\n79:     train_years, test_years = (\n80:         unique_years[:-2],  # train: 2015-2023\n81:         unique_years[-2:],  # test: 2024-2025\n82:     )\n83: \n84:     train_idx = df[\"Year\"].isin(train_years)\n85:     test_idx = df[\"Year\"].isin(test_years)\n86: \n87:     X_train, X_test = X[train_idx], X[test_idx]\n88:     y_train, y_test = y[train_idx], y[test_idx]\n89: \n90:     # Group sizes\n91:     train_groups = df[train_idx].groupby(\"Year\").size().to_numpy()\n92:     test_groups = df[test_idx].groupby(\"Year\").size().to_numpy()\n93: \n94:     # Try multiple n_estimators and select the best based on NDCG\n95:     n_estimators_list = [100, 1000, 2000]\n96:     best_ndcg = -np.inf\n97:     best_model = None\n98:     best_n_estimators = None\n99:     best_y_pred = None\n100: \n101:     for n_estimators in n_estimators_list:\n102:         model = XGBRanker(\n103:             objective=\"rank:pairwise\",\n104:             learning_rate=0.1,\n105:             n_estimators=n_estimators,\n106:             max_depth=4,\n107:             random_state=42,\n108:         )\n109: \n110:         print(f\"Training XGBoostRanker with n_estimators={n_estimators}...\")\n111:         model.fit(X_train, y_train, group=train_groups)\n112: \n113:         y_pred = model.predict(X_test)\n114:         ndcg = evaluate_ndcg(y_test.to_numpy(), y_pred, test_groups)\n115:         print(f\"NDCG Score with n_estimators={n_estimators}: {ndcg:.4f}\")\n116: \n117:         if ndcg > best_ndcg:\n118:             best_ndcg = ndcg\n119:             best_model = model\n120:             best_n_estimators = n_estimators\n121:             best_y_pred = y_pred\n122: \n123:     print(f\"\\nBest n_estimators: {best_n_estimators} with NDCG: {best_ndcg:.4f}\")\n124: \n125:     # Predict, sort, and evaluate with the best model\n126:     y_pred = best_y_pred\n127:     df.loc[test_idx, \"PredictedScore\"] = y_pred\n128:     df.loc[test_idx, \"PredictedRank\"] = (\n129:         df.loc[test_idx]\n130:         .groupby(\"Year\")[\"PredictedScore\"]\n131:         .rank(ascending=False, method=\"first\")\n132:     )\n133: \n134:     print(f\"NDCG Score on test years {test_years.tolist()}: {best_ndcg:.4f}\")\n135: \n136:     # Show results\n137:     print(df[test_idx][[\"Year\", \"Name\", \"Rank\", \"PredictedScore\", \"PredictedRank\"]])\n138:     plot_ranking_predictions(df, 2024)\n139:     plot_ranking_predictions(df, 2025)\n140: \n141: \n142: if __name__ == \"__main__\":\n143:     main()",
            "mapping": [
                {
                    "summaryComponent": "trains and evaluates an XGBoost ranking model",
                    "codeSegments": [
                        {
                            "code": "model = XGBRanker(",
                            "line": 102
                        },
                        {
                            "code": "model.fit(X_train, y_train, group=train_groups)",
                            "line": 111
                        },
                        {
                            "code": "y_pred = model.predict(X_test)",
                            "line": 113
                        },
                        {
                            "code": "ndcg = evaluate_ndcg(y_test.to_numpy(), y_pred, test_groups)",
                            "line": 114
                        }
                    ]
                },
                {
                    "summaryComponent": "on basketball player data",
                    "codeSegments": [
                        {
                            "code": "X, y, group, df = load_data()",
                            "line": 75
                        }
                    ]
                },
                {
                    "summaryComponent": "split by year",
                    "codeSegments": [
                        {
                            "code": "unique_years = df[\"Year\"].unique()",
                            "line": 78
                        },
                        {
                            "code": "train_years, test_years = (",
                            "line": 79
                        },
                        {
                            "code": "train_idx = df[\"Year\"].isin(train_years)",
                            "line": 84
                        },
                        {
                            "code": "test_idx = df[\"Year\"].isin(test_years)",
                            "line": 85
                        }
                    ]
                },
                {
                    "summaryComponent": "trying multiple n_estimators values",
                    "codeSegments": [
                        {
                            "code": "n_estimators_list = [100, 1000, 2000]",
                            "line": 95
                        },
                        {
                            "code": "for n_estimators in n_estimators_list:",
                            "line": 101
                        }
                    ]
                },
                {
                    "summaryComponent": "selecting the best model based on NDCG",
                    "codeSegments": [
                        {
                            "code": "best_ndcg = -np.inf",
                            "line": 96
                        },
                        {
                            "code": "best_model = None",
                            "line": 97
                        },
                        {
                            "code": "if ndcg > best_ndcg:",
                            "line": 117
                        },
                        {
                            "code": "best_ndcg = ndcg",
                            "line": 118
                        },
                        {
                            "code": "best_model = model",
                            "line": 119
                        }
                    ]
                }
            ]
        },
        "id": "jS3DwiShRjgKRuo9FAGz"
    },
    {
        "source": "backend",
        "event": "map_summary_code",
        "timestamp": "2025-08-24 11:56:14.000",
        "data": {
            "summary": "• Loads data and splits it into training (earlier years) and test (most recent years) sets\n• Trains an XGBoost ranking model on the training data, trying multiple n_estimators values and selecting the best based on NDCG\n• Predicts and ranks players for the test years\n• Evaluates model performance using the NDCG metric\n• Generates and saves plots of prediction errors for the test years",
            "code": "74: def main():\n75:     X, y, group, df = load_data()\n76: \n77:     # Train-test split on years\n78:     unique_years = df[\"Year\"].unique()\n79:     train_years, test_years = (\n80:         unique_years[:-2],  # train: 2015-2023\n81:         unique_years[-2:],  # test: 2024-2025\n82:     )\n83: \n84:     train_idx = df[\"Year\"].isin(train_years)\n85:     test_idx = df[\"Year\"].isin(test_years)\n86: \n87:     X_train, X_test = X[train_idx], X[test_idx]\n88:     y_train, y_test = y[train_idx], y[test_idx]\n89: \n90:     # Group sizes\n91:     train_groups = df[train_idx].groupby(\"Year\").size().to_numpy()\n92:     test_groups = df[test_idx].groupby(\"Year\").size().to_numpy()\n93: \n94:     # Try multiple n_estimators and select the best based on NDCG\n95:     n_estimators_list = [100, 1000, 2000]\n96:     best_ndcg = -np.inf\n97:     best_model = None\n98:     best_n_estimators = None\n99:     best_y_pred = None\n100: \n101:     for n_estimators in n_estimators_list:\n102:         model = XGBRanker(\n103:             objective=\"rank:pairwise\",\n104:             learning_rate=0.1,\n105:             n_estimators=n_estimators,\n106:             max_depth=4,\n107:             random_state=42,\n108:         )\n109: \n110:         print(f\"Training XGBoostRanker with n_estimators={n_estimators}...\")\n111:         model.fit(X_train, y_train, group=train_groups)\n112: \n113:         y_pred = model.predict(X_test)\n114:         ndcg = evaluate_ndcg(y_test.to_numpy(), y_pred, test_groups)\n115:         print(f\"NDCG Score with n_estimators={n_estimators}: {ndcg:.4f}\")\n116: \n117:         if ndcg > best_ndcg:\n118:             best_ndcg = ndcg\n119:             best_model = model\n120:             best_n_estimators = n_estimators\n121:             best_y_pred = y_pred\n122: \n123:     print(f\"\\nBest n_estimators: {best_n_estimators} with NDCG: {best_ndcg:.4f}\")\n124: \n125:     # Predict, sort, and evaluate with the best model\n126:     y_pred = best_y_pred\n127:     df.loc[test_idx, \"PredictedScore\"] = y_pred\n128:     df.loc[test_idx, \"PredictedRank\"] = (\n129:         df.loc[test_idx]\n130:         .groupby(\"Year\")[\"PredictedScore\"]\n131:         .rank(ascending=False, method=\"first\")\n132:     )\n133: \n134:     print(f\"NDCG Score on test years {test_years.tolist()}: {best_ndcg:.4f}\")\n135: \n136:     # Show results\n137:     print(df[test_idx][[\"Year\", \"Name\", \"Rank\", \"PredictedScore\", \"PredictedRank\"]])\n138:     plot_ranking_predictions(df, 2024)\n139:     plot_ranking_predictions(df, 2025)\n140: \n141: \n142: if __name__ == \"__main__\":\n143:     main()",
            "mapping": [
                {
                    "summaryComponent": "Loads data and splits it into training (earlier years) and test (most recent years) sets",
                    "codeSegments": [
                        {
                            "code": "X, y, group, df = load_data()",
                            "line": 75
                        },
                        {
                            "code": "unique_years = df[\"Year\"].unique()",
                            "line": 78
                        },
                        {
                            "code": "train_years, test_years = (",
                            "line": 79
                        },
                        {
                            "code": "unique_years[:-2],  # train: 2015-2023",
                            "line": 80
                        },
                        {
                            "code": "unique_years[-2:],  # test: 2024-2025",
                            "line": 81
                        },
                        {
                            "code": "train_idx = df[\"Year\"].isin(train_years)",
                            "line": 84
                        },
                        {
                            "code": "test_idx = df[\"Year\"].isin(test_years)",
                            "line": 85
                        },
                        {
                            "code": "X_train, X_test = X[train_idx], X[test_idx]",
                            "line": 87
                        },
                        {
                            "code": "y_train, y_test = y[train_idx], y[test_idx]",
                            "line": 88
                        }
                    ]
                },
                {
                    "summaryComponent": "Trains an XGBoost ranking model on the training data, trying multiple n_estimators values and selecting the best based on NDCG",
                    "codeSegments": [
                        {
                            "code": "n_estimators_list = [100, 1000, 2000]",
                            "line": 95
                        },
                        {
                            "code": "for n_estimators in n_estimators_list:",
                            "line": 101
                        },
                        {
                            "code": "model = XGBRanker(",
                            "line": 102
                        },
                        {
                            "code": "model.fit(X_train, y_train, group=train_groups)",
                            "line": 111
                        },
                        {
                            "code": "ndcg = evaluate_ndcg(y_test.to_numpy(), y_pred, test_groups)",
                            "line": 114
                        },
                        {
                            "code": "if ndcg > best_ndcg:",
                            "line": 117
                        },
                        {
                            "code": "best_ndcg = ndcg",
                            "line": 118
                        },
                        {
                            "code": "best_model = model",
                            "line": 119
                        },
                        {
                            "code": "best_n_estimators = n_estimators",
                            "line": 120
                        }
                    ]
                },
                {
                    "summaryComponent": "Predicts and ranks players for the test years",
                    "codeSegments": [
                        {
                            "code": "y_pred = best_y_pred",
                            "line": 126
                        },
                        {
                            "code": "df.loc[test_idx, \"PredictedScore\"] = y_pred",
                            "line": 127
                        },
                        {
                            "code": "df.loc[test_idx, \"PredictedRank\"] = (",
                            "line": 128
                        },
                        {
                            "code": "df.loc[test_idx]",
                            "line": 129
                        },
                        {
                            "code": ".groupby(\"Year\")[\"PredictedScore\"]",
                            "line": 130
                        },
                        {
                            "code": ".rank(ascending=False, method=\"first\")",
                            "line": 131
                        }
                    ]
                },
                {
                    "summaryComponent": "Evaluates model performance using the NDCG metric",
                    "codeSegments": [
                        {
                            "code": "ndcg = evaluate_ndcg(y_test.to_numpy(), y_pred, test_groups)",
                            "line": 114
                        },
                        {
                            "code": "print(f\"NDCG Score with n_estimators={n_estimators}: {ndcg:.4f}\")",
                            "line": 115
                        },
                        {
                            "code": "print(f\"\\nBest n_estimators: {best_n_estimators} with NDCG: {best_ndcg:.4f}\")",
                            "line": 123
                        },
                        {
                            "code": "print(f\"NDCG Score on test years {test_years.tolist()}: {best_ndcg:.4f}\")",
                            "line": 134
                        }
                    ]
                },
                {
                    "summaryComponent": "Generates and saves plots of prediction errors for the test years",
                    "codeSegments": [
                        {
                            "code": "plot_ranking_predictions(df, 2024)",
                            "line": 138
                        },
                        {
                            "code": "plot_ranking_predictions(df, 2025)",
                            "line": 139
                        }
                    ]
                }
            ]
        },
        "id": "0dUeG8w9H6MEaoHDIEOf"
    },
    {
        "source": "backend",
        "event": "map_summary_code",
        "timestamp": "2025-08-24 11:56:14.000",
        "data": {
            "summary": "The main() function loads basketball player data, splits it into training and test sets based on years, and trains an XGBoost ranking model. It now tries several n_estimators values, selects the one yielding the highest NDCG score, predicts rankings for the test years, evaluates performance using the NDCG metric, and prints the results. Additionally, it generates plots to visualize prediction errors for the test years.",
            "code": "74: def main():\n75:     X, y, group, df = load_data()\n76: \n77:     # Train-test split on years\n78:     unique_years = df[\"Year\"].unique()\n79:     train_years, test_years = (\n80:         unique_years[:-2],  # train: 2015-2023\n81:         unique_years[-2:],  # test: 2024-2025\n82:     )\n83: \n84:     train_idx = df[\"Year\"].isin(train_years)\n85:     test_idx = df[\"Year\"].isin(test_years)\n86: \n87:     X_train, X_test = X[train_idx], X[test_idx]\n88:     y_train, y_test = y[train_idx], y[test_idx]\n89: \n90:     # Group sizes\n91:     train_groups = df[train_idx].groupby(\"Year\").size().to_numpy()\n92:     test_groups = df[test_idx].groupby(\"Year\").size().to_numpy()\n93: \n94:     # Try multiple n_estimators and select the best based on NDCG\n95:     n_estimators_list = [100, 1000, 2000]\n96:     best_ndcg = -np.inf\n97:     best_model = None\n98:     best_n_estimators = None\n99:     best_y_pred = None\n100: \n101:     for n_estimators in n_estimators_list:\n102:         model = XGBRanker(\n103:             objective=\"rank:pairwise\",\n104:             learning_rate=0.1,\n105:             n_estimators=n_estimators,\n106:             max_depth=4,\n107:             random_state=42,\n108:         )\n109: \n110:         print(f\"Training XGBoostRanker with n_estimators={n_estimators}...\")\n111:         model.fit(X_train, y_train, group=train_groups)\n112: \n113:         y_pred = model.predict(X_test)\n114:         ndcg = evaluate_ndcg(y_test.to_numpy(), y_pred, test_groups)\n115:         print(f\"NDCG Score with n_estimators={n_estimators}: {ndcg:.4f}\")\n116: \n117:         if ndcg > best_ndcg:\n118:             best_ndcg = ndcg\n119:             best_model = model\n120:             best_n_estimators = n_estimators\n121:             best_y_pred = y_pred\n122: \n123:     print(f\"\\nBest n_estimators: {best_n_estimators} with NDCG: {best_ndcg:.4f}\")\n124: \n125:     # Predict, sort, and evaluate with the best model\n126:     y_pred = best_y_pred\n127:     df.loc[test_idx, \"PredictedScore\"] = y_pred\n128:     df.loc[test_idx, \"PredictedRank\"] = (\n129:         df.loc[test_idx]\n130:         .groupby(\"Year\")[\"PredictedScore\"]\n131:         .rank(ascending=False, method=\"first\")\n132:     )\n133: \n134:     print(f\"NDCG Score on test years {test_years.tolist()}: {best_ndcg:.4f}\")\n135: \n136:     # Show results\n137:     print(df[test_idx][[\"Year\", \"Name\", \"Rank\", \"PredictedScore\", \"PredictedRank\"]])\n138:     plot_ranking_predictions(df, 2024)\n139:     plot_ranking_predictions(df, 2025)\n140: \n141: \n142: if __name__ == \"__main__\":\n143:     main()",
            "mapping": [
                {
                    "summaryComponent": "The main() function",
                    "codeSegments": [
                        {
                            "code": "def main():",
                            "line": 74
                        }
                    ]
                },
                {
                    "summaryComponent": "loads basketball player data",
                    "codeSegments": [
                        {
                            "code": "X, y, group, df = load_data()",
                            "line": 75
                        }
                    ]
                },
                {
                    "summaryComponent": "splits it into training and test sets based on years",
                    "codeSegments": [
                        {
                            "code": "unique_years = df[\"Year\"].unique()",
                            "line": 78
                        },
                        {
                            "code": "train_years, test_years = (",
                            "line": 79
                        },
                        {
                            "code": "train_idx = df[\"Year\"].isin(train_years)",
                            "line": 84
                        },
                        {
                            "code": "test_idx = df[\"Year\"].isin(test_years)",
                            "line": 85
                        },
                        {
                            "code": "X_train, X_test = X[train_idx], X[test_idx]",
                            "line": 87
                        },
                        {
                            "code": "y_train, y_test = y[train_idx], y[test_idx]",
                            "line": 88
                        }
                    ]
                },
                {
                    "summaryComponent": "trains an XGBoost ranking model",
                    "codeSegments": [
                        {
                            "code": "model = XGBRanker(",
                            "line": 102
                        },
                        {
                            "code": "model.fit(X_train, y_train, group=train_groups)",
                            "line": 111
                        }
                    ]
                },
                {
                    "summaryComponent": "tries several n_estimators values",
                    "codeSegments": [
                        {
                            "code": "n_estimators_list = [100, 1000, 2000]",
                            "line": 95
                        },
                        {
                            "code": "for n_estimators in n_estimators_list:",
                            "line": 101
                        }
                    ]
                },
                {
                    "summaryComponent": "selects the one yielding the highest NDCG score",
                    "codeSegments": [
                        {
                            "code": "if ndcg > best_ndcg:",
                            "line": 117
                        },
                        {
                            "code": "best_ndcg = ndcg",
                            "line": 118
                        },
                        {
                            "code": "best_model = model",
                            "line": 119
                        },
                        {
                            "code": "best_n_estimators = n_estimators",
                            "line": 120
                        }
                    ]
                },
                {
                    "summaryComponent": "predicts rankings for the test years",
                    "codeSegments": [
                        {
                            "code": "y_pred = best_y_pred",
                            "line": 126
                        },
                        {
                            "code": "df.loc[test_idx, \"PredictedScore\"] = y_pred",
                            "line": 127
                        },
                        {
                            "code": "df.loc[test_idx, \"PredictedRank\"] = (",
                            "line": 128
                        }
                    ]
                },
                {
                    "summaryComponent": "evaluates performance using the NDCG metric",
                    "codeSegments": [
                        {
                            "code": "ndcg = evaluate_ndcg(y_test.to_numpy(), y_pred, test_groups)",
                            "line": 114
                        },
                        {
                            "code": "print(f\"NDCG Score on test years {test_years.tolist()}: {best_ndcg:.4f}\")",
                            "line": 134
                        }
                    ]
                },
                {
                    "summaryComponent": "prints the results",
                    "codeSegments": [
                        {
                            "code": "print(df[test_idx][[\"Year\", \"Name\", \"Rank\", \"PredictedScore\", \"PredictedRank\"]])",
                            "line": 137
                        }
                    ]
                },
                {
                    "summaryComponent": "generates plots to visualize prediction errors for the test years",
                    "codeSegments": [
                        {
                            "code": "plot_ranking_predictions(df, 2024)",
                            "line": 138
                        },
                        {
                            "code": "plot_ranking_predictions(df, 2025)",
                            "line": 139
                        }
                    ]
                }
            ]
        },
        "id": "h4u90CJJzVTQtXdkN8el"
    },
    {
        "source": "backend",
        "event": "map_summary_code",
        "timestamp": "2025-08-24 11:56:15.000",
        "data": {
            "summary": "The main() function orchestrates the process of training and evaluating an XGBoost ranking model on basketball player statistics. It first loads the data and splits it into training and test sets based on year, with the last two years reserved for testing. The function now iterates over several n_estimators values, trains an XGBRanker for each, and selects the model with the highest NDCG score using group information for proper ranking. It predicts scores for the test set, assigns predicted ranks within each year, computes the NDCG score to assess ranking quality, prints detailed prediction results for the test years, and generates bar plots visualizing prediction errors for each player in the test years.",
            "code": "74: def main():\n75:     X, y, group, df = load_data()\n76: \n77:     # Train-test split on years\n78:     unique_years = df[\"Year\"].unique()\n79:     train_years, test_years = (\n80:         unique_years[:-2],  # train: 2015-2023\n81:         unique_years[-2:],  # test: 2024-2025\n82:     )\n83: \n84:     train_idx = df[\"Year\"].isin(train_years)\n85:     test_idx = df[\"Year\"].isin(test_years)\n86: \n87:     X_train, X_test = X[train_idx], X[test_idx]\n88:     y_train, y_test = y[train_idx], y[test_idx]\n89: \n90:     # Group sizes\n91:     train_groups = df[train_idx].groupby(\"Year\").size().to_numpy()\n92:     test_groups = df[test_idx].groupby(\"Year\").size().to_numpy()\n93: \n94:     # Try multiple n_estimators and select the best based on NDCG\n95:     n_estimators_list = [100, 1000, 2000]\n96:     best_ndcg = -np.inf\n97:     best_model = None\n98:     best_n_estimators = None\n99:     best_y_pred = None\n100: \n101:     for n_estimators in n_estimators_list:\n102:         model = XGBRanker(\n103:             objective=\"rank:pairwise\",\n104:             learning_rate=0.1,\n105:             n_estimators=n_estimators,\n106:             max_depth=4,\n107:             random_state=42,\n108:         )\n109: \n110:         print(f\"Training XGBoostRanker with n_estimators={n_estimators}...\")\n111:         model.fit(X_train, y_train, group=train_groups)\n112: \n113:         y_pred = model.predict(X_test)\n114:         ndcg = evaluate_ndcg(y_test.to_numpy(), y_pred, test_groups)\n115:         print(f\"NDCG Score with n_estimators={n_estimators}: {ndcg:.4f}\")\n116: \n117:         if ndcg > best_ndcg:\n118:             best_ndcg = ndcg\n119:             best_model = model\n120:             best_n_estimators = n_estimators\n121:             best_y_pred = y_pred\n122: \n123:     print(f\"\\nBest n_estimators: {best_n_estimators} with NDCG: {best_ndcg:.4f}\")\n124: \n125:     # Predict, sort, and evaluate with the best model\n126:     y_pred = best_y_pred\n127:     df.loc[test_idx, \"PredictedScore\"] = y_pred\n128:     df.loc[test_idx, \"PredictedRank\"] = (\n129:         df.loc[test_idx]\n130:         .groupby(\"Year\")[\"PredictedScore\"]\n131:         .rank(ascending=False, method=\"first\")\n132:     )\n133: \n134:     print(f\"NDCG Score on test years {test_years.tolist()}: {best_ndcg:.4f}\")\n135: \n136:     # Show results\n137:     print(df[test_idx][[\"Year\", \"Name\", \"Rank\", \"PredictedScore\", \"PredictedRank\"]])\n138:     plot_ranking_predictions(df, 2024)\n139:     plot_ranking_predictions(df, 2025)\n140: \n141: \n142: if __name__ == \"__main__\":\n143:     main()",
            "mapping": [
                {
                    "summaryComponent": "The main() function orchestrates the process of training and evaluating an XGBoost ranking model on basketball player statistics.",
                    "codeSegments": [
                        {
                            "code": "def main():",
                            "line": 74
                        },
                        {
                            "code": "model = XGBRanker(",
                            "line": 102
                        }
                    ]
                },
                {
                    "summaryComponent": "It first loads the data",
                    "codeSegments": [
                        {
                            "code": "X, y, group, df = load_data()",
                            "line": 75
                        }
                    ]
                },
                {
                    "summaryComponent": "and splits it into training and test sets based on year, with the last two years reserved for testing.",
                    "codeSegments": [
                        {
                            "code": "unique_years = df[\"Year\"].unique()",
                            "line": 78
                        },
                        {
                            "code": "train_years, test_years = (",
                            "line": 79
                        },
                        {
                            "code": "unique_years[:-2],  # train: 2015-2023",
                            "line": 80
                        },
                        {
                            "code": "unique_years[-2:],  # test: 2024-2025",
                            "line": 81
                        },
                        {
                            "code": "train_idx = df[\"Year\"].isin(train_years)",
                            "line": 84
                        },
                        {
                            "code": "test_idx = df[\"Year\"].isin(test_years)",
                            "line": 85
                        },
                        {
                            "code": "X_train, X_test = X[train_idx], X[test_idx]",
                            "line": 87
                        },
                        {
                            "code": "y_train, y_test = y[train_idx], y[test_idx]",
                            "line": 88
                        }
                    ]
                },
                {
                    "summaryComponent": "The function now iterates over several n_estimators values,",
                    "codeSegments": [
                        {
                            "code": "n_estimators_list = [100, 1000, 2000]",
                            "line": 95
                        },
                        {
                            "code": "for n_estimators in n_estimators_list:",
                            "line": 101
                        }
                    ]
                },
                {
                    "summaryComponent": "trains an XGBRanker for each,",
                    "codeSegments": [
                        {
                            "code": "model = XGBRanker(",
                            "line": 102
                        },
                        {
                            "code": "model.fit(X_train, y_train, group=train_groups)",
                            "line": 111
                        }
                    ]
                },
                {
                    "summaryComponent": "and selects the model with the highest NDCG score",
                    "codeSegments": [
                        {
                            "code": "if ndcg > best_ndcg:",
                            "line": 117
                        },
                        {
                            "code": "best_ndcg = ndcg",
                            "line": 118
                        },
                        {
                            "code": "best_model = model",
                            "line": 119
                        },
                        {
                            "code": "best_n_estimators = n_estimators",
                            "line": 120
                        },
                        {
                            "code": "best_y_pred = y_pred",
                            "line": 121
                        }
                    ]
                },
                {
                    "summaryComponent": "using group information for proper ranking.",
                    "codeSegments": [
                        {
                            "code": "train_groups = df[train_idx].groupby(\"Year\").size().to_numpy()",
                            "line": 91
                        },
                        {
                            "code": "test_groups = df[test_idx].groupby(\"Year\").size().to_numpy()",
                            "line": 92
                        },
                        {
                            "code": "model.fit(X_train, y_train, group=train_groups)",
                            "line": 111
                        },
                        {
                            "code": "ndcg = evaluate_ndcg(y_test.to_numpy(), y_pred, test_groups)",
                            "line": 114
                        }
                    ]
                },
                {
                    "summaryComponent": "It predicts scores for the test set,",
                    "codeSegments": [
                        {
                            "code": "y_pred = model.predict(X_test)",
                            "line": 113
                        },
                        {
                            "code": "y_pred = best_y_pred",
                            "line": 126
                        }
                    ]
                },
                {
                    "summaryComponent": "assigns predicted ranks within each year,",
                    "codeSegments": [
                        {
                            "code": "df.loc[test_idx, \"PredictedScore\"] = y_pred",
                            "line": 127
                        },
                        {
                            "code": "df.loc[test_idx, \"PredictedRank\"] = (",
                            "line": 128
                        },
                        {
                            "code": ".groupby(\"Year\")[\"PredictedScore\"]",
                            "line": 130
                        },
                        {
                            "code": ".rank(ascending=False, method=\"first\")",
                            "line": 131
                        }
                    ]
                },
                {
                    "summaryComponent": "computes the NDCG score to assess ranking quality, prints detailed prediction results for the test years, and generates bar plots visualizing prediction errors for each player in the test years.",
                    "codeSegments": [
                        {
                            "code": "print(f\"NDCG Score on test years {test_years.tolist()}: {best_ndcg:.4f}\")",
                            "line": 134
                        },
                        {
                            "code": "print(df[test_idx][[\"Year\", \"Name\", \"Rank\", \"PredictedScore\", \"PredictedRank\"]])",
                            "line": 137
                        },
                        {
                            "code": "plot_ranking_predictions(df, 2024)",
                            "line": 138
                        },
                        {
                            "code": "plot_ranking_predictions(df, 2025)",
                            "line": 139
                        }
                    ]
                }
            ]
        },
        "id": "odIUkQyAvEXFLarFACdn"
    },
    {
        "source": "frontend",
        "event": "create_new_section",
        "timestamp": "2025-08-24 11:56:16.000",
        "data": {
            "section_data": {
                "selectedDetailLevel": "medium",
                "editPromptStructured": null,
                "createdAt": 1756065376000,
                "metadata": {
                    "originalCode": "def main():\n    X, y, group, df = load_data()\n\n    # Train-test split on years\n    unique_years = df[\"Year\"].unique()\n    train_years, test_years = (\n        unique_years[:-2],  # train: 2015-2023\n        unique_years[-2:],  # test: 2024-2025\n    )\n\n    train_idx = df[\"Year\"].isin(train_years)\n    test_idx = df[\"Year\"].isin(test_years)\n\n    X_train, X_test = X[train_idx], X[test_idx]\n    y_train, y_test = y[train_idx], y[test_idx]\n\n    # Group sizes\n    train_groups = df[train_idx].groupby(\"Year\").size().to_numpy()\n    test_groups = df[test_idx].groupby(\"Year\").size().to_numpy()\n\n    # Try multiple n_estimators and select the best based on NDCG\n    n_estimators_list = [100, 1000, 2000]\n    best_ndcg = -np.inf\n    best_model = None\n    best_n_estimators = None\n    best_y_pred = None\n\n    for n_estimators in n_estimators_list:\n        model = XGBRanker(\n            objective=\"rank:pairwise\",\n            learning_rate=0.1,\n            n_estimators=n_estimators,\n            max_depth=4,\n            random_state=42,\n        )\n\n        print(f\"Training XGBoostRanker with n_estimators={n_estimators}...\")\n        model.fit(X_train, y_train, group=train_groups)\n\n        y_pred = model.predict(X_test)\n        ndcg = evaluate_ndcg(y_test.to_numpy(), y_pred, test_groups)\n        print(f\"NDCG Score with n_estimators={n_estimators}: {ndcg:.4f}\")\n\n        if ndcg > best_ndcg:\n            best_ndcg = ndcg\n            best_model = model\n            best_n_estimators = n_estimators\n            best_y_pred = y_pred\n\n    print(f\"\\nBest n_estimators: {best_n_estimators} with NDCG: {best_ndcg:.4f}\")\n\n    # Predict, sort, and evaluate with the best model\n    y_pred = best_y_pred\n    df.loc[test_idx, \"PredictedScore\"] = y_pred\n    df.loc[test_idx, \"PredictedRank\"] = (\n        df.loc[test_idx]\n        .groupby(\"Year\")[\"PredictedScore\"]\n        .rank(ascending=False, method=\"first\")\n    )\n\n    print(f\"NDCG Score on test years {test_years.tolist()}: {best_ndcg:.4f}\")\n\n    # Show results\n    print(df[test_idx][[\"Year\", \"Name\", \"Rank\", \"PredictedScore\", \"PredictedRank\"]])\n    plot_ranking_predictions(df, 2024)\n    plot_ranking_predictions(df, 2025)\n\n\nif __name__ == \"__main__\":\n    main()",
                    "id": "0f8d4e67-12a3-412f-aaf9-c6388e7e8282",
                    "filename": "rank_model.py",
                    "fullPath": "/project/workspace/rank_model.py",
                    "offset": 1952
                },
                "summaryData": {
                    "medium_structured": "• Loads data and splits it into training (earlier years) and test (most recent years) sets\n• Trains an XGBoost ranking model on the training data, trying multiple n_estimators values and selecting the best based on NDCG\n• Predicts and ranks players for the test years\n• Evaluates model performance using the NDCG metric\n• Generates and saves plots of prediction errors for the test years",
                    "low_unstructured": "This function now trains and evaluates an XGBoost ranking model on basketball player data split by year, trying multiple n_estimators values and selecting the best model based on NDCG.",
                    "high_structured": "• Loads player data and splits it by year into training (all but last two years) and test (last two years) sets\n• Prepares training and test feature matrices, target ranks, and group sizes for ranking\n• Initializes and trains an XGBRanker model with specific hyperparameters, now trying multiple n_estimators values and selecting the best based on NDCG\n  ◦ Uses 'rank:pairwise' objective and groups data by year for proper ranking\n• Predicts ranking scores for test data using the best model\n  ◦ Assigns predicted ranks within each year based on predicted scores\n  ◦ Stores predicted scores and ranks in the DataFrame\n• Evaluates model performance using the NDCG metric on test years\n• Prints detailed prediction results for each player in the test years\n• Generates and saves bar plots visualizing prediction errors for 2024 and 2025",
                    "low_structured": "• Loads data and splits it into training and test sets by year\n• Trains an XGBoost ranking model using multiple n_estimators values and selects the best based on NDCG\n• Evaluates and prints results for recent years",
                    "high_unstructured": "The main() function orchestrates the process of training and evaluating an XGBoost ranking model on basketball player statistics. It first loads the data and splits it into training and test sets based on year, with the last two years reserved for testing. The function now iterates over several n_estimators values, trains an XGBRanker for each, and selects the model with the highest NDCG score using group information for proper ranking. It predicts scores for the test set, assigns predicted ranks within each year, computes the NDCG score to assess ranking quality, prints detailed prediction results for the test years, and generates bar plots visualizing prediction errors for each player in the test years.",
                    "medium_unstructured": "The main() function loads basketball player data, splits it into training and test sets based on years, and trains an XGBoost ranking model. It now tries several n_estimators values, selects the one yielding the highest NDCG score, predicts rankings for the test years, evaluates performance using the NDCG metric, and prints the results. Additionally, it generates plots to visualize prediction errors for the test years.",
                    "title": "Summary of the main() Function in rank_model.py (with n_estimators Grid Search)"
                },
                "selectedStructured": "unstructured",
                "summaryMappings": {
                    "medium_structured": [
                        {
                            "summaryComponent": "Loads data and splits it into training (earlier years) and test (most recent years) sets",
                            "codeSegments": [
                                {
                                    "code": "X, y, group, df = load_data()",
                                    "line": 75
                                },
                                {
                                    "code": "unique_years = df[\"Year\"].unique()",
                                    "line": 78
                                },
                                {
                                    "code": "train_years, test_years = (",
                                    "line": 79
                                },
                                {
                                    "code": "unique_years[:-2],  # train: 2015-2023",
                                    "line": 80
                                },
                                {
                                    "code": "unique_years[-2:],  # test: 2024-2025",
                                    "line": 81
                                },
                                {
                                    "code": "train_idx = df[\"Year\"].isin(train_years)",
                                    "line": 84
                                },
                                {
                                    "code": "test_idx = df[\"Year\"].isin(test_years)",
                                    "line": 85
                                },
                                {
                                    "code": "X_train, X_test = X[train_idx], X[test_idx]",
                                    "line": 87
                                },
                                {
                                    "code": "y_train, y_test = y[train_idx], y[test_idx]",
                                    "line": 88
                                }
                            ]
                        },
                        {
                            "summaryComponent": "Trains an XGBoost ranking model on the training data, trying multiple n_estimators values and selecting the best based on NDCG",
                            "codeSegments": [
                                {
                                    "code": "n_estimators_list = [100, 1000, 2000]",
                                    "line": 95
                                },
                                {
                                    "code": "for n_estimators in n_estimators_list:",
                                    "line": 101
                                },
                                {
                                    "code": "model = XGBRanker(",
                                    "line": 102
                                },
                                {
                                    "code": "model.fit(X_train, y_train, group=train_groups)",
                                    "line": 111
                                },
                                {
                                    "code": "ndcg = evaluate_ndcg(y_test.to_numpy(), y_pred, test_groups)",
                                    "line": 114
                                },
                                {
                                    "code": "if ndcg > best_ndcg:",
                                    "line": 117
                                },
                                {
                                    "code": "best_ndcg = ndcg",
                                    "line": 118
                                },
                                {
                                    "code": "best_model = model",
                                    "line": 119
                                },
                                {
                                    "code": "best_n_estimators = n_estimators",
                                    "line": 120
                                }
                            ]
                        },
                        {
                            "summaryComponent": "Predicts and ranks players for the test years",
                            "codeSegments": [
                                {
                                    "code": "y_pred = best_y_pred",
                                    "line": 126
                                },
                                {
                                    "code": "df.loc[test_idx, \"PredictedScore\"] = y_pred",
                                    "line": 127
                                },
                                {
                                    "code": "df.loc[test_idx, \"PredictedRank\"] = (",
                                    "line": 128
                                },
                                {
                                    "code": "df.loc[test_idx]",
                                    "line": 129
                                },
                                {
                                    "code": ".groupby(\"Year\")[\"PredictedScore\"]",
                                    "line": 130
                                },
                                {
                                    "code": ".rank(ascending=False, method=\"first\")",
                                    "line": 131
                                }
                            ]
                        },
                        {
                            "summaryComponent": "Evaluates model performance using the NDCG metric",
                            "codeSegments": [
                                {
                                    "code": "ndcg = evaluate_ndcg(y_test.to_numpy(), y_pred, test_groups)",
                                    "line": 114
                                },
                                {
                                    "code": "print(f\"NDCG Score with n_estimators={n_estimators}: {ndcg:.4f}\")",
                                    "line": 115
                                },
                                {
                                    "code": "print(f\"\\nBest n_estimators: {best_n_estimators} with NDCG: {best_ndcg:.4f}\")",
                                    "line": 123
                                },
                                {
                                    "code": "print(f\"NDCG Score on test years {test_years.tolist()}: {best_ndcg:.4f}\")",
                                    "line": 134
                                }
                            ]
                        },
                        {
                            "summaryComponent": "Generates and saves plots of prediction errors for the test years",
                            "codeSegments": [
                                {
                                    "code": "plot_ranking_predictions(df, 2024)",
                                    "line": 138
                                },
                                {
                                    "code": "plot_ranking_predictions(df, 2025)",
                                    "line": 139
                                }
                            ]
                        }
                    ],
                    "high_structured": [
                        {
                            "summaryComponent": "Loads player data and splits it by year into training (all but last two years) and test (last two years) sets",
                            "codeSegments": [
                                {
                                    "code": "X, y, group, df = load_data()",
                                    "line": 75
                                },
                                {
                                    "code": "unique_years = df[\"Year\"].unique()",
                                    "line": 78
                                },
                                {
                                    "code": "train_years, test_years = (\n    unique_years[:-2],  # train: 2015-2023\n    unique_years[-2:],  # test: 2024-2025\n)",
                                    "line": 79
                                },
                                {
                                    "code": "train_idx = df[\"Year\"].isin(train_years)",
                                    "line": 84
                                },
                                {
                                    "code": "test_idx = df[\"Year\"].isin(test_years)",
                                    "line": 85
                                }
                            ]
                        },
                        {
                            "summaryComponent": "Prepares training and test feature matrices, target ranks, and group sizes for ranking",
                            "codeSegments": [
                                {
                                    "code": "X_train, X_test = X[train_idx], X[test_idx]",
                                    "line": 87
                                },
                                {
                                    "code": "y_train, y_test = y[train_idx], y[test_idx]",
                                    "line": 88
                                },
                                {
                                    "code": "train_groups = df[train_idx].groupby(\"Year\").size().to_numpy()",
                                    "line": 91
                                },
                                {
                                    "code": "test_groups = df[test_idx].groupby(\"Year\").size().to_numpy()",
                                    "line": 92
                                }
                            ]
                        },
                        {
                            "summaryComponent": "Initializes and trains an XGBRanker model with specific hyperparameters, now trying multiple n_estimators values and selecting the best based on NDCG",
                            "codeSegments": [
                                {
                                    "code": "n_estimators_list = [100, 1000, 2000]",
                                    "line": 95
                                },
                                {
                                    "code": "for n_estimators in n_estimators_list:",
                                    "line": 101
                                },
                                {
                                    "code": "model = XGBRanker(\n    objective=\"rank:pairwise\",\n    learning_rate=0.1,\n    n_estimators=n_estimators,\n    max_depth=4,\n    random_state=42,\n)",
                                    "line": 102
                                },
                                {
                                    "code": "model.fit(X_train, y_train, group=train_groups)",
                                    "line": 111
                                },
                                {
                                    "code": "ndcg = evaluate_ndcg(y_test.to_numpy(), y_pred, test_groups)",
                                    "line": 114
                                },
                                {
                                    "code": "if ndcg > best_ndcg:\n    best_ndcg = ndcg\n    best_model = model\n    best_n_estimators = n_estimators\n    best_y_pred = y_pred",
                                    "line": 117
                                }
                            ]
                        },
                        {
                            "summaryComponent": "Uses 'rank:pairwise' objective and groups data by year for proper ranking",
                            "codeSegments": [
                                {
                                    "code": "objective=\"rank:pairwise\"",
                                    "line": 103
                                },
                                {
                                    "code": "group=train_groups",
                                    "line": 111
                                }
                            ]
                        },
                        {
                            "summaryComponent": "Predicts ranking scores for test data using the best model",
                            "codeSegments": [
                                {
                                    "code": "y_pred = best_y_pred",
                                    "line": 126
                                }
                            ]
                        },
                        {
                            "summaryComponent": "Assigns predicted ranks within each year based on predicted scores",
                            "codeSegments": [
                                {
                                    "code": "df.loc[test_idx, \"PredictedRank\"] = (\n    df.loc[test_idx]\n    .groupby(\"Year\")[\"PredictedScore\"]\n    .rank(ascending=False, method=\"first\")\n)",
                                    "line": 128
                                }
                            ]
                        },
                        {
                            "summaryComponent": "Stores predicted scores and ranks in the DataFrame",
                            "codeSegments": [
                                {
                                    "code": "df.loc[test_idx, \"PredictedScore\"] = y_pred",
                                    "line": 127
                                },
                                {
                                    "code": "df.loc[test_idx, \"PredictedRank\"] = (\n    df.loc[test_idx]\n    .groupby(\"Year\")[\"PredictedScore\"]\n    .rank(ascending=False, method=\"first\")\n)",
                                    "line": 128
                                }
                            ]
                        },
                        {
                            "summaryComponent": "Evaluates model performance using the NDCG metric on test years",
                            "codeSegments": [
                                {
                                    "code": "print(f\"NDCG Score on test years {test_years.tolist()}: {best_ndcg:.4f}\")",
                                    "line": 134
                                }
                            ]
                        },
                        {
                            "summaryComponent": "Prints detailed prediction results for each player in the test years",
                            "codeSegments": [
                                {
                                    "code": "print(df[test_idx][[\"Year\", \"Name\", \"Rank\", \"PredictedScore\", \"PredictedRank\"]])",
                                    "line": 137
                                }
                            ]
                        },
                        {
                            "summaryComponent": "Generates and saves bar plots visualizing prediction errors for 2024 and 2025",
                            "codeSegments": [
                                {
                                    "code": "plot_ranking_predictions(df, 2024)",
                                    "line": 138
                                },
                                {
                                    "code": "plot_ranking_predictions(df, 2025)",
                                    "line": 139
                                }
                            ]
                        }
                    ],
                    "low_structured": [
                        {
                            "summaryComponent": "Loads data",
                            "codeSegments": [
                                {
                                    "code": "X, y, group, df = load_data()",
                                    "line": 75
                                }
                            ]
                        },
                        {
                            "summaryComponent": "splits it into training and test sets by year",
                            "codeSegments": [
                                {
                                    "code": "unique_years = df[\"Year\"].unique()",
                                    "line": 78
                                },
                                {
                                    "code": "train_years, test_years = (",
                                    "line": 79
                                },
                                {
                                    "code": "train_idx = df[\"Year\"].isin(train_years)",
                                    "line": 84
                                },
                                {
                                    "code": "test_idx = df[\"Year\"].isin(test_years)",
                                    "line": 85
                                },
                                {
                                    "code": "X_train, X_test = X[train_idx], X[test_idx]",
                                    "line": 87
                                },
                                {
                                    "code": "y_train, y_test = y[train_idx], y[test_idx]",
                                    "line": 88
                                }
                            ]
                        },
                        {
                            "summaryComponent": "Trains an XGBoost ranking model using multiple n_estimators values",
                            "codeSegments": [
                                {
                                    "code": "n_estimators_list = [100, 1000, 2000]",
                                    "line": 95
                                },
                                {
                                    "code": "for n_estimators in n_estimators_list:",
                                    "line": 101
                                },
                                {
                                    "code": "model = XGBRanker(",
                                    "line": 102
                                },
                                {
                                    "code": "model.fit(X_train, y_train, group=train_groups)",
                                    "line": 111
                                }
                            ]
                        },
                        {
                            "summaryComponent": "selects the best based on NDCG",
                            "codeSegments": [
                                {
                                    "code": "ndcg = evaluate_ndcg(y_test.to_numpy(), y_pred, test_groups)",
                                    "line": 114
                                },
                                {
                                    "code": "if ndcg > best_ndcg:",
                                    "line": 117
                                },
                                {
                                    "code": "best_ndcg = ndcg",
                                    "line": 118
                                },
                                {
                                    "code": "best_model = model",
                                    "line": 119
                                },
                                {
                                    "code": "best_n_estimators = n_estimators",
                                    "line": 120
                                }
                            ]
                        },
                        {
                            "summaryComponent": "Evaluates and prints results for recent years",
                            "codeSegments": [
                                {
                                    "code": "print(f\"NDCG Score on test years {test_years.tolist()}: {best_ndcg:.4f}\")",
                                    "line": 134
                                },
                                {
                                    "code": "print(df[test_idx][[\"Year\", \"Name\", \"Rank\", \"PredictedScore\", \"PredictedRank\"]])",
                                    "line": 137
                                },
                                {
                                    "code": "plot_ranking_predictions(df, 2024)",
                                    "line": 138
                                },
                                {
                                    "code": "plot_ranking_predictions(df, 2025)",
                                    "line": 139
                                }
                            ]
                        }
                    ],
                    "high_unstructured": [
                        {
                            "summaryComponent": "The main() function orchestrates the process of training and evaluating an XGBoost ranking model on basketball player statistics.",
                            "codeSegments": [
                                {
                                    "code": "def main():",
                                    "line": 74
                                },
                                {
                                    "code": "model = XGBRanker(",
                                    "line": 102
                                }
                            ]
                        },
                        {
                            "summaryComponent": "It first loads the data",
                            "codeSegments": [
                                {
                                    "code": "X, y, group, df = load_data()",
                                    "line": 75
                                }
                            ]
                        },
                        {
                            "summaryComponent": "and splits it into training and test sets based on year, with the last two years reserved for testing.",
                            "codeSegments": [
                                {
                                    "code": "unique_years = df[\"Year\"].unique()",
                                    "line": 78
                                },
                                {
                                    "code": "train_years, test_years = (",
                                    "line": 79
                                },
                                {
                                    "code": "unique_years[:-2],  # train: 2015-2023",
                                    "line": 80
                                },
                                {
                                    "code": "unique_years[-2:],  # test: 2024-2025",
                                    "line": 81
                                },
                                {
                                    "code": "train_idx = df[\"Year\"].isin(train_years)",
                                    "line": 84
                                },
                                {
                                    "code": "test_idx = df[\"Year\"].isin(test_years)",
                                    "line": 85
                                },
                                {
                                    "code": "X_train, X_test = X[train_idx], X[test_idx]",
                                    "line": 87
                                },
                                {
                                    "code": "y_train, y_test = y[train_idx], y[test_idx]",
                                    "line": 88
                                }
                            ]
                        },
                        {
                            "summaryComponent": "The function now iterates over several n_estimators values,",
                            "codeSegments": [
                                {
                                    "code": "n_estimators_list = [100, 1000, 2000]",
                                    "line": 95
                                },
                                {
                                    "code": "for n_estimators in n_estimators_list:",
                                    "line": 101
                                }
                            ]
                        },
                        {
                            "summaryComponent": "trains an XGBRanker for each,",
                            "codeSegments": [
                                {
                                    "code": "model = XGBRanker(",
                                    "line": 102
                                },
                                {
                                    "code": "model.fit(X_train, y_train, group=train_groups)",
                                    "line": 111
                                }
                            ]
                        },
                        {
                            "summaryComponent": "and selects the model with the highest NDCG score",
                            "codeSegments": [
                                {
                                    "code": "if ndcg > best_ndcg:",
                                    "line": 117
                                },
                                {
                                    "code": "best_ndcg = ndcg",
                                    "line": 118
                                },
                                {
                                    "code": "best_model = model",
                                    "line": 119
                                },
                                {
                                    "code": "best_n_estimators = n_estimators",
                                    "line": 120
                                },
                                {
                                    "code": "best_y_pred = y_pred",
                                    "line": 121
                                }
                            ]
                        },
                        {
                            "summaryComponent": "using group information for proper ranking.",
                            "codeSegments": [
                                {
                                    "code": "train_groups = df[train_idx].groupby(\"Year\").size().to_numpy()",
                                    "line": 91
                                },
                                {
                                    "code": "test_groups = df[test_idx].groupby(\"Year\").size().to_numpy()",
                                    "line": 92
                                },
                                {
                                    "code": "model.fit(X_train, y_train, group=train_groups)",
                                    "line": 111
                                },
                                {
                                    "code": "ndcg = evaluate_ndcg(y_test.to_numpy(), y_pred, test_groups)",
                                    "line": 114
                                }
                            ]
                        },
                        {
                            "summaryComponent": "It predicts scores for the test set,",
                            "codeSegments": [
                                {
                                    "code": "y_pred = model.predict(X_test)",
                                    "line": 113
                                },
                                {
                                    "code": "y_pred = best_y_pred",
                                    "line": 126
                                }
                            ]
                        },
                        {
                            "summaryComponent": "assigns predicted ranks within each year,",
                            "codeSegments": [
                                {
                                    "code": "df.loc[test_idx, \"PredictedScore\"] = y_pred",
                                    "line": 127
                                },
                                {
                                    "code": "df.loc[test_idx, \"PredictedRank\"] = (",
                                    "line": 128
                                },
                                {
                                    "code": ".groupby(\"Year\")[\"PredictedScore\"]",
                                    "line": 130
                                },
                                {
                                    "code": ".rank(ascending=False, method=\"first\")",
                                    "line": 131
                                }
                            ]
                        },
                        {
                            "summaryComponent": "computes the NDCG score to assess ranking quality, prints detailed prediction results for the test years, and generates bar plots visualizing prediction errors for each player in the test years.",
                            "codeSegments": [
                                {
                                    "code": "print(f\"NDCG Score on test years {test_years.tolist()}: {best_ndcg:.4f}\")",
                                    "line": 134
                                },
                                {
                                    "code": "print(df[test_idx][[\"Year\", \"Name\", \"Rank\", \"PredictedScore\", \"PredictedRank\"]])",
                                    "line": 137
                                },
                                {
                                    "code": "plot_ranking_predictions(df, 2024)",
                                    "line": 138
                                },
                                {
                                    "code": "plot_ranking_predictions(df, 2025)",
                                    "line": 139
                                }
                            ]
                        }
                    ],
                    "medium_unstructured": [
                        {
                            "summaryComponent": "The main() function",
                            "codeSegments": [
                                {
                                    "code": "def main():",
                                    "line": 74
                                }
                            ]
                        },
                        {
                            "summaryComponent": "loads basketball player data",
                            "codeSegments": [
                                {
                                    "code": "X, y, group, df = load_data()",
                                    "line": 75
                                }
                            ]
                        },
                        {
                            "summaryComponent": "splits it into training and test sets based on years",
                            "codeSegments": [
                                {
                                    "code": "unique_years = df[\"Year\"].unique()",
                                    "line": 78
                                },
                                {
                                    "code": "train_years, test_years = (",
                                    "line": 79
                                },
                                {
                                    "code": "train_idx = df[\"Year\"].isin(train_years)",
                                    "line": 84
                                },
                                {
                                    "code": "test_idx = df[\"Year\"].isin(test_years)",
                                    "line": 85
                                },
                                {
                                    "code": "X_train, X_test = X[train_idx], X[test_idx]",
                                    "line": 87
                                },
                                {
                                    "code": "y_train, y_test = y[train_idx], y[test_idx]",
                                    "line": 88
                                }
                            ]
                        },
                        {
                            "summaryComponent": "trains an XGBoost ranking model",
                            "codeSegments": [
                                {
                                    "code": "model = XGBRanker(",
                                    "line": 102
                                },
                                {
                                    "code": "model.fit(X_train, y_train, group=train_groups)",
                                    "line": 111
                                }
                            ]
                        },
                        {
                            "summaryComponent": "tries several n_estimators values",
                            "codeSegments": [
                                {
                                    "code": "n_estimators_list = [100, 1000, 2000]",
                                    "line": 95
                                },
                                {
                                    "code": "for n_estimators in n_estimators_list:",
                                    "line": 101
                                }
                            ]
                        },
                        {
                            "summaryComponent": "selects the one yielding the highest NDCG score",
                            "codeSegments": [
                                {
                                    "code": "if ndcg > best_ndcg:",
                                    "line": 117
                                },
                                {
                                    "code": "best_ndcg = ndcg",
                                    "line": 118
                                },
                                {
                                    "code": "best_model = model",
                                    "line": 119
                                },
                                {
                                    "code": "best_n_estimators = n_estimators",
                                    "line": 120
                                }
                            ]
                        },
                        {
                            "summaryComponent": "predicts rankings for the test years",
                            "codeSegments": [
                                {
                                    "code": "y_pred = best_y_pred",
                                    "line": 126
                                },
                                {
                                    "code": "df.loc[test_idx, \"PredictedScore\"] = y_pred",
                                    "line": 127
                                },
                                {
                                    "code": "df.loc[test_idx, \"PredictedRank\"] = (",
                                    "line": 128
                                }
                            ]
                        },
                        {
                            "summaryComponent": "evaluates performance using the NDCG metric",
                            "codeSegments": [
                                {
                                    "code": "ndcg = evaluate_ndcg(y_test.to_numpy(), y_pred, test_groups)",
                                    "line": 114
                                },
                                {
                                    "code": "print(f\"NDCG Score on test years {test_years.tolist()}: {best_ndcg:.4f}\")",
                                    "line": 134
                                }
                            ]
                        },
                        {
                            "summaryComponent": "prints the results",
                            "codeSegments": [
                                {
                                    "code": "print(df[test_idx][[\"Year\", \"Name\", \"Rank\", \"PredictedScore\", \"PredictedRank\"]])",
                                    "line": 137
                                }
                            ]
                        },
                        {
                            "summaryComponent": "generates plots to visualize prediction errors for the test years",
                            "codeSegments": [
                                {
                                    "code": "plot_ranking_predictions(df, 2024)",
                                    "line": 138
                                },
                                {
                                    "code": "plot_ranking_predictions(df, 2025)",
                                    "line": 139
                                }
                            ]
                        }
                    ],
                    "low_unstructured": [
                        {
                            "summaryComponent": "trains and evaluates an XGBoost ranking model",
                            "codeSegments": [
                                {
                                    "code": "model = XGBRanker(",
                                    "line": 102
                                },
                                {
                                    "code": "model.fit(X_train, y_train, group=train_groups)",
                                    "line": 111
                                },
                                {
                                    "code": "y_pred = model.predict(X_test)",
                                    "line": 113
                                },
                                {
                                    "code": "ndcg = evaluate_ndcg(y_test.to_numpy(), y_pred, test_groups)",
                                    "line": 114
                                }
                            ]
                        },
                        {
                            "summaryComponent": "on basketball player data",
                            "codeSegments": [
                                {
                                    "code": "X, y, group, df = load_data()",
                                    "line": 75
                                }
                            ]
                        },
                        {
                            "summaryComponent": "split by year",
                            "codeSegments": [
                                {
                                    "code": "unique_years = df[\"Year\"].unique()",
                                    "line": 78
                                },
                                {
                                    "code": "train_years, test_years = (",
                                    "line": 79
                                },
                                {
                                    "code": "train_idx = df[\"Year\"].isin(train_years)",
                                    "line": 84
                                },
                                {
                                    "code": "test_idx = df[\"Year\"].isin(test_years)",
                                    "line": 85
                                }
                            ]
                        },
                        {
                            "summaryComponent": "trying multiple n_estimators values",
                            "codeSegments": [
                                {
                                    "code": "n_estimators_list = [100, 1000, 2000]",
                                    "line": 95
                                },
                                {
                                    "code": "for n_estimators in n_estimators_list:",
                                    "line": 101
                                }
                            ]
                        },
                        {
                            "summaryComponent": "selecting the best model based on NDCG",
                            "codeSegments": [
                                {
                                    "code": "best_ndcg = -np.inf",
                                    "line": 96
                                },
                                {
                                    "code": "best_model = None",
                                    "line": 97
                                },
                                {
                                    "code": "if ndcg > best_ndcg:",
                                    "line": 117
                                },
                                {
                                    "code": "best_ndcg = ndcg",
                                    "line": 118
                                },
                                {
                                    "code": "best_model = model",
                                    "line": 119
                                }
                            ]
                        }
                    ]
                },
                "editPromptValue": "",
                "editPromptDetailLevel": null,
                "oldSummaryData": {
                    "medium_structured": "• Loads data and splits it into training (earlier years) and test (most recent years) sets\n• Trains an XGBoost ranking model on the training data\n• Predicts and ranks players for the test years\n• Evaluates model performance using the NDCG metric\n• Generates and saves plots of prediction errors for the test years",
                    "low_unstructured": "This function trains and evaluates an XGBoost ranking model on basketball player data split by year.",
                    "high_structured": "• Loads player data and splits it by year into training (all but last two years) and test (last two years) sets\n• Prepares training and test feature matrices, target ranks, and group sizes for ranking\n• Initializes and trains an XGBRanker model with specific hyperparameters\n  ◦ Uses 'rank:pairwise' objective and groups data by year for proper ranking\n• Predicts ranking scores for test data\n  ◦ Assigns predicted ranks within each year based on predicted scores\n  ◦ Stores predicted scores and ranks in the DataFrame\n• Evaluates model performance using the NDCG metric on test years\n• Prints detailed prediction results for each player in the test years\n• Generates and saves bar plots visualizing prediction errors for 2024 and 2025",
                    "low_structured": "• Loads data and splits it into training and test sets by year\n• Trains an XGBoost ranking model\n• Evaluates and prints results for recent years",
                    "high_unstructured": "The main() function orchestrates the process of training and evaluating an XGBoost ranking model on basketball player statistics. It first loads the data and splits it into training and test sets based on year, with the last two years reserved for testing. The function trains an XGBRanker using group information for proper ranking, predicts scores for the test set, and assigns predicted ranks within each year. It then computes the NDCG score to assess ranking quality, prints detailed prediction results for the test years, and generates bar plots visualizing prediction errors for each player in the test years.",
                    "medium_unstructured": "The main() function loads basketball player data, splits it into training and test sets based on years, and trains an XGBoost ranking model. It predicts rankings for the test years, evaluates performance using the NDCG metric, and prints the results. Additionally, it generates plots to visualize prediction errors for the test years.",
                    "title": "Summary of the main() Function in rank_model.py"
                },
                "lines": [
                    74,
                    143
                ],
                "title": "Summary of the main() Function in rank_model.py (with n_estimators Grid Search)"
            },
            "section_id": "0f8d4e67-12a3-412f-aaf9-c6388e7e8282"
        },
        "id": "eq388DC8Lz8cWXoNrd9R"
    },
    {
        "source": "backend",
        "event": "map_summary_code",
        "timestamp": "2025-08-24 11:56:16.000",
        "data": {
            "summary": "• Loads player data and splits it by year into training (all but last two years) and test (last two years) sets\n• Prepares training and test feature matrices, target ranks, and group sizes for ranking\n• Initializes and trains an XGBRanker model with specific hyperparameters, now trying multiple n_estimators values and selecting the best based on NDCG\n  ◦ Uses 'rank:pairwise' objective and groups data by year for proper ranking\n• Predicts ranking scores for test data using the best model\n  ◦ Assigns predicted ranks within each year based on predicted scores\n  ◦ Stores predicted scores and ranks in the DataFrame\n• Evaluates model performance using the NDCG metric on test years\n• Prints detailed prediction results for each player in the test years\n• Generates and saves bar plots visualizing prediction errors for 2024 and 2025",
            "code": "74: def main():\n75:     X, y, group, df = load_data()\n76: \n77:     # Train-test split on years\n78:     unique_years = df[\"Year\"].unique()\n79:     train_years, test_years = (\n80:         unique_years[:-2],  # train: 2015-2023\n81:         unique_years[-2:],  # test: 2024-2025\n82:     )\n83: \n84:     train_idx = df[\"Year\"].isin(train_years)\n85:     test_idx = df[\"Year\"].isin(test_years)\n86: \n87:     X_train, X_test = X[train_idx], X[test_idx]\n88:     y_train, y_test = y[train_idx], y[test_idx]\n89: \n90:     # Group sizes\n91:     train_groups = df[train_idx].groupby(\"Year\").size().to_numpy()\n92:     test_groups = df[test_idx].groupby(\"Year\").size().to_numpy()\n93: \n94:     # Try multiple n_estimators and select the best based on NDCG\n95:     n_estimators_list = [100, 1000, 2000]\n96:     best_ndcg = -np.inf\n97:     best_model = None\n98:     best_n_estimators = None\n99:     best_y_pred = None\n100: \n101:     for n_estimators in n_estimators_list:\n102:         model = XGBRanker(\n103:             objective=\"rank:pairwise\",\n104:             learning_rate=0.1,\n105:             n_estimators=n_estimators,\n106:             max_depth=4,\n107:             random_state=42,\n108:         )\n109: \n110:         print(f\"Training XGBoostRanker with n_estimators={n_estimators}...\")\n111:         model.fit(X_train, y_train, group=train_groups)\n112: \n113:         y_pred = model.predict(X_test)\n114:         ndcg = evaluate_ndcg(y_test.to_numpy(), y_pred, test_groups)\n115:         print(f\"NDCG Score with n_estimators={n_estimators}: {ndcg:.4f}\")\n116: \n117:         if ndcg > best_ndcg:\n118:             best_ndcg = ndcg\n119:             best_model = model\n120:             best_n_estimators = n_estimators\n121:             best_y_pred = y_pred\n122: \n123:     print(f\"\\nBest n_estimators: {best_n_estimators} with NDCG: {best_ndcg:.4f}\")\n124: \n125:     # Predict, sort, and evaluate with the best model\n126:     y_pred = best_y_pred\n127:     df.loc[test_idx, \"PredictedScore\"] = y_pred\n128:     df.loc[test_idx, \"PredictedRank\"] = (\n129:         df.loc[test_idx]\n130:         .groupby(\"Year\")[\"PredictedScore\"]\n131:         .rank(ascending=False, method=\"first\")\n132:     )\n133: \n134:     print(f\"NDCG Score on test years {test_years.tolist()}: {best_ndcg:.4f}\")\n135: \n136:     # Show results\n137:     print(df[test_idx][[\"Year\", \"Name\", \"Rank\", \"PredictedScore\", \"PredictedRank\"]])\n138:     plot_ranking_predictions(df, 2024)\n139:     plot_ranking_predictions(df, 2025)\n140: \n141: \n142: if __name__ == \"__main__\":\n143:     main()",
            "mapping": [
                {
                    "summaryComponent": "Loads player data and splits it by year into training (all but last two years) and test (last two years) sets",
                    "codeSegments": [
                        {
                            "code": "X, y, group, df = load_data()",
                            "line": 75
                        },
                        {
                            "code": "unique_years = df[\"Year\"].unique()",
                            "line": 78
                        },
                        {
                            "code": "train_years, test_years = (\n    unique_years[:-2],  # train: 2015-2023\n    unique_years[-2:],  # test: 2024-2025\n)",
                            "line": 79
                        },
                        {
                            "code": "train_idx = df[\"Year\"].isin(train_years)",
                            "line": 84
                        },
                        {
                            "code": "test_idx = df[\"Year\"].isin(test_years)",
                            "line": 85
                        }
                    ]
                },
                {
                    "summaryComponent": "Prepares training and test feature matrices, target ranks, and group sizes for ranking",
                    "codeSegments": [
                        {
                            "code": "X_train, X_test = X[train_idx], X[test_idx]",
                            "line": 87
                        },
                        {
                            "code": "y_train, y_test = y[train_idx], y[test_idx]",
                            "line": 88
                        },
                        {
                            "code": "train_groups = df[train_idx].groupby(\"Year\").size().to_numpy()",
                            "line": 91
                        },
                        {
                            "code": "test_groups = df[test_idx].groupby(\"Year\").size().to_numpy()",
                            "line": 92
                        }
                    ]
                },
                {
                    "summaryComponent": "Initializes and trains an XGBRanker model with specific hyperparameters, now trying multiple n_estimators values and selecting the best based on NDCG",
                    "codeSegments": [
                        {
                            "code": "n_estimators_list = [100, 1000, 2000]",
                            "line": 95
                        },
                        {
                            "code": "for n_estimators in n_estimators_list:",
                            "line": 101
                        },
                        {
                            "code": "model = XGBRanker(\n    objective=\"rank:pairwise\",\n    learning_rate=0.1,\n    n_estimators=n_estimators,\n    max_depth=4,\n    random_state=42,\n)",
                            "line": 102
                        },
                        {
                            "code": "model.fit(X_train, y_train, group=train_groups)",
                            "line": 111
                        },
                        {
                            "code": "ndcg = evaluate_ndcg(y_test.to_numpy(), y_pred, test_groups)",
                            "line": 114
                        },
                        {
                            "code": "if ndcg > best_ndcg:\n    best_ndcg = ndcg\n    best_model = model\n    best_n_estimators = n_estimators\n    best_y_pred = y_pred",
                            "line": 117
                        }
                    ]
                },
                {
                    "summaryComponent": "Uses 'rank:pairwise' objective and groups data by year for proper ranking",
                    "codeSegments": [
                        {
                            "code": "objective=\"rank:pairwise\"",
                            "line": 103
                        },
                        {
                            "code": "group=train_groups",
                            "line": 111
                        }
                    ]
                },
                {
                    "summaryComponent": "Predicts ranking scores for test data using the best model",
                    "codeSegments": [
                        {
                            "code": "y_pred = best_y_pred",
                            "line": 126
                        }
                    ]
                },
                {
                    "summaryComponent": "Assigns predicted ranks within each year based on predicted scores",
                    "codeSegments": [
                        {
                            "code": "df.loc[test_idx, \"PredictedRank\"] = (\n    df.loc[test_idx]\n    .groupby(\"Year\")[\"PredictedScore\"]\n    .rank(ascending=False, method=\"first\")\n)",
                            "line": 128
                        }
                    ]
                },
                {
                    "summaryComponent": "Stores predicted scores and ranks in the DataFrame",
                    "codeSegments": [
                        {
                            "code": "df.loc[test_idx, \"PredictedScore\"] = y_pred",
                            "line": 127
                        },
                        {
                            "code": "df.loc[test_idx, \"PredictedRank\"] = (\n    df.loc[test_idx]\n    .groupby(\"Year\")[\"PredictedScore\"]\n    .rank(ascending=False, method=\"first\")\n)",
                            "line": 128
                        }
                    ]
                },
                {
                    "summaryComponent": "Evaluates model performance using the NDCG metric on test years",
                    "codeSegments": [
                        {
                            "code": "print(f\"NDCG Score on test years {test_years.tolist()}: {best_ndcg:.4f}\")",
                            "line": 134
                        }
                    ]
                },
                {
                    "summaryComponent": "Prints detailed prediction results for each player in the test years",
                    "codeSegments": [
                        {
                            "code": "print(df[test_idx][[\"Year\", \"Name\", \"Rank\", \"PredictedScore\", \"PredictedRank\"]])",
                            "line": 137
                        }
                    ]
                },
                {
                    "summaryComponent": "Generates and saves bar plots visualizing prediction errors for 2024 and 2025",
                    "codeSegments": [
                        {
                            "code": "plot_ranking_predictions(df, 2024)",
                            "line": 138
                        },
                        {
                            "code": "plot_ranking_predictions(df, 2025)",
                            "line": 139
                        }
                    ]
                }
            ]
        },
        "id": "wV5fIWvGg9aaVmPgHVoB"
    },
    {
        "source": "frontend",
        "event": "autotransit_section",
        "timestamp": "2025-08-24 11:56:16.000",
        "data": {
            "before_section_id": "976fd15f-9dc3-4531-8eae-a29169ab7e11",
            "after_section_id": "0f8d4e67-12a3-412f-aaf9-c6388e7e8282"
        },
        "id": "zZ6KR87pgij6ESRRoK1J"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "timestamp": "2025-08-24 11:56:19.000",
        "data": {
            "structured_type": "unstructured",
            "detail_level": "medium",
            "mapping_index": 9,
            "section_id": "0f8d4e67-12a3-412f-aaf9-c6388e7e8282"
        },
        "id": "7pj5wGh6DOJXdRXThbDF"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "timestamp": "2025-08-24 11:56:19.000",
        "data": {
            "structured_type": "unstructured",
            "detail_level": "medium",
            "section_id": "0f8d4e67-12a3-412f-aaf9-c6388e7e8282"
        },
        "id": "98c9ufX7ZiLjij8UXtzG"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "timestamp": "2025-08-24 11:56:19.000",
        "data": {
            "structured_type": "unstructured",
            "detail_level": "medium",
            "section_id": "0f8d4e67-12a3-412f-aaf9-c6388e7e8282"
        },
        "id": "Qo6jtY6a991aQwLZwkyB"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "timestamp": "2025-08-24 11:56:19.000",
        "data": {
            "structured_type": "unstructured",
            "detail_level": "medium",
            "section_id": "0f8d4e67-12a3-412f-aaf9-c6388e7e8282"
        },
        "id": "bcu82gfE9XCvJMrWwAnv"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "timestamp": "2025-08-24 11:56:19.000",
        "data": {
            "structured_type": "unstructured",
            "detail_level": "medium",
            "mapping_index": 5,
            "section_id": "0f8d4e67-12a3-412f-aaf9-c6388e7e8282"
        },
        "id": "h0PPf1U7tfUgxTZHcShn"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "timestamp": "2025-08-24 11:56:19.000",
        "data": {
            "structured_type": "unstructured",
            "detail_level": "medium",
            "mapping_index": 7,
            "section_id": "0f8d4e67-12a3-412f-aaf9-c6388e7e8282"
        },
        "id": "pk3qSlW1Kb5dnFVhVw5K"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "timestamp": "2025-08-24 11:56:20.000",
        "data": {
            "structured_type": "unstructured",
            "detail_level": "medium",
            "mapping_index": 9,
            "section_id": "0f8d4e67-12a3-412f-aaf9-c6388e7e8282"
        },
        "id": "KKkQN2kCNmLL3keVjANE"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "timestamp": "2025-08-24 11:56:20.000",
        "data": {
            "structured_type": "unstructured",
            "detail_level": "medium",
            "section_id": "0f8d4e67-12a3-412f-aaf9-c6388e7e8282"
        },
        "id": "MAiRYfgGYrxn94ji2ItG"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "timestamp": "2025-08-24 11:56:24.000",
        "data": {
            "structured_type": "unstructured",
            "detail_level": "medium",
            "mapping_index": 1,
            "section_id": "0f8d4e67-12a3-412f-aaf9-c6388e7e8282"
        },
        "id": "6CWkJYTAA6qq6sRjWLdf"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "timestamp": "2025-08-24 11:56:24.000",
        "data": {
            "structured_type": "unstructured",
            "detail_level": "medium",
            "section_id": "0f8d4e67-12a3-412f-aaf9-c6388e7e8282"
        },
        "id": "Ha7xQdOrqD8wDpKkQpn8"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "timestamp": "2025-08-24 11:56:24.000",
        "data": {
            "structured_type": "unstructured",
            "detail_level": "medium",
            "mapping_index": 3,
            "section_id": "0f8d4e67-12a3-412f-aaf9-c6388e7e8282"
        },
        "id": "PIDh68Z7ft7HnDGbHyvl"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "timestamp": "2025-08-24 11:56:24.000",
        "data": {
            "structured_type": "unstructured",
            "detail_level": "medium",
            "section_id": "0f8d4e67-12a3-412f-aaf9-c6388e7e8282"
        },
        "id": "aYaL1ibW7xlFgM7l43qM"
    },
    {
        "source": "frontend",
        "event": "change_summary_level",
        "timestamp": "2025-08-24 11:56:25.000",
        "data": {
            "before_structured": "unstructured",
            "before_detail_level": "medium",
            "after_structured": "structured",
            "after_detail_level": "medium",
            "section_id": "0f8d4e67-12a3-412f-aaf9-c6388e7e8282"
        },
        "id": "T1OyUGohvgj86TLRXUKO"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "timestamp": "2025-08-24 11:56:26.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "medium",
            "mapping_index": 2,
            "section_id": "0f8d4e67-12a3-412f-aaf9-c6388e7e8282"
        },
        "id": "FvF2RHcTOOrXyef2QBoG"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "timestamp": "2025-08-24 11:56:26.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "medium",
            "mapping_index": 0,
            "section_id": "0f8d4e67-12a3-412f-aaf9-c6388e7e8282"
        },
        "id": "FvyJOjzlx59heSmUKlwZ"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "timestamp": "2025-08-24 11:56:26.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "medium",
            "section_id": "0f8d4e67-12a3-412f-aaf9-c6388e7e8282"
        },
        "id": "Hm9PmhMYxHOQtFuKZ9Ee"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "timestamp": "2025-08-24 11:56:26.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "medium",
            "mapping_index": 1,
            "section_id": "0f8d4e67-12a3-412f-aaf9-c6388e7e8282"
        },
        "id": "HxxEfTrUoLCQ2GusnNie"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "timestamp": "2025-08-24 11:56:26.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "medium",
            "section_id": "0f8d4e67-12a3-412f-aaf9-c6388e7e8282"
        },
        "id": "JPl0Y0fjB8AtJTENj7oi"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "timestamp": "2025-08-24 11:56:26.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "medium",
            "section_id": "0f8d4e67-12a3-412f-aaf9-c6388e7e8282"
        },
        "id": "ThPo3XLzxZ2ut2nymDf9"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "timestamp": "2025-08-24 11:56:26.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "medium",
            "mapping_index": 3,
            "section_id": "0f8d4e67-12a3-412f-aaf9-c6388e7e8282"
        },
        "id": "VO3S6S3zOkXU5HajuMSp"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "timestamp": "2025-08-24 11:56:27.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "medium",
            "mapping_index": 2,
            "section_id": "0f8d4e67-12a3-412f-aaf9-c6388e7e8282"
        },
        "id": "EgKqaOLxzU2CVZfExvsr"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "timestamp": "2025-08-24 11:56:27.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "medium",
            "section_id": "0f8d4e67-12a3-412f-aaf9-c6388e7e8282"
        },
        "id": "KkfETMumfkCkSDxDWcXI"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "timestamp": "2025-08-24 11:56:28.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "medium",
            "section_id": "0f8d4e67-12a3-412f-aaf9-c6388e7e8282"
        },
        "id": "FL6jcvlNnWE8pLhIhlV0"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "timestamp": "2025-08-24 11:56:28.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "medium",
            "section_id": "0f8d4e67-12a3-412f-aaf9-c6388e7e8282"
        },
        "id": "LDGJEkGOsAxg2ZxqyyQR"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "timestamp": "2025-08-24 11:56:28.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "medium",
            "mapping_index": 1,
            "section_id": "0f8d4e67-12a3-412f-aaf9-c6388e7e8282"
        },
        "id": "aST1oBmV1oSaQz733z6x"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "timestamp": "2025-08-24 11:56:29.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "medium",
            "section_id": "0f8d4e67-12a3-412f-aaf9-c6388e7e8282"
        },
        "id": "4dFvR5zUQFrveYqAIE7R"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "timestamp": "2025-08-24 11:56:29.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "medium",
            "mapping_index": 1,
            "section_id": "0f8d4e67-12a3-412f-aaf9-c6388e7e8282"
        },
        "id": "cMURae5CSTOT3yzTalYh"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "timestamp": "2025-08-24 11:56:29.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "medium",
            "mapping_index": 1,
            "section_id": "0f8d4e67-12a3-412f-aaf9-c6388e7e8282"
        },
        "id": "zI3iuMX63sfHkQ31IqAb"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "timestamp": "2025-08-24 11:56:31.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "medium",
            "section_id": "0f8d4e67-12a3-412f-aaf9-c6388e7e8282"
        },
        "id": "EP9WahbFfFF4HJ1yhzDF"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "timestamp": "2025-08-24 11:56:31.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "medium",
            "mapping_index": 1,
            "section_id": "0f8d4e67-12a3-412f-aaf9-c6388e7e8282"
        },
        "id": "Gdgifi4TL6owwCnk7QgG"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "timestamp": "2025-08-24 11:56:31.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "medium",
            "section_id": "0f8d4e67-12a3-412f-aaf9-c6388e7e8282"
        },
        "id": "L7rGuviRKPiHGokyFQeO"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "timestamp": "2025-08-24 11:56:31.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "medium",
            "mapping_index": 3,
            "section_id": "0f8d4e67-12a3-412f-aaf9-c6388e7e8282"
        },
        "id": "Vz7ypQaBsj6HxSdnUnaq"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "timestamp": "2025-08-24 11:56:31.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "medium",
            "mapping_index": 2,
            "section_id": "0f8d4e67-12a3-412f-aaf9-c6388e7e8282"
        },
        "id": "dT2dMITBhQl0RuCGHYX1"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "timestamp": "2025-08-24 11:56:31.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "medium",
            "section_id": "0f8d4e67-12a3-412f-aaf9-c6388e7e8282"
        },
        "id": "tEXFZqhLee96TAdjyu3q"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "timestamp": "2025-08-24 11:56:31.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "medium",
            "section_id": "0f8d4e67-12a3-412f-aaf9-c6388e7e8282"
        },
        "id": "uwGXI2kHe1MDc39a275Q"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "timestamp": "2025-08-24 11:56:33.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "medium",
            "section_id": "0f8d4e67-12a3-412f-aaf9-c6388e7e8282"
        },
        "id": "6pXy7uH9PqUfjM7gOE5s"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "timestamp": "2025-08-24 11:56:33.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "medium",
            "mapping_index": 3,
            "section_id": "0f8d4e67-12a3-412f-aaf9-c6388e7e8282"
        },
        "id": "8hW2pDT4DYG6eGZZso0f"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "timestamp": "2025-08-24 11:56:33.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "medium",
            "section_id": "0f8d4e67-12a3-412f-aaf9-c6388e7e8282"
        },
        "id": "DVatOCuh5RAGovG0oG9Z"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "timestamp": "2025-08-24 11:56:33.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "medium",
            "mapping_index": 0,
            "section_id": "0f8d4e67-12a3-412f-aaf9-c6388e7e8282"
        },
        "id": "FF0H9ml2VKHrYw331czC"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "timestamp": "2025-08-24 11:56:33.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "medium",
            "mapping_index": 4,
            "section_id": "0f8d4e67-12a3-412f-aaf9-c6388e7e8282"
        },
        "id": "NPSEGBt1WjJS4HEv8aho"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "timestamp": "2025-08-24 11:56:33.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "medium",
            "section_id": "0f8d4e67-12a3-412f-aaf9-c6388e7e8282"
        },
        "id": "WfmItipSzeYQIZXWePxL"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "timestamp": "2025-08-24 11:56:33.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "medium",
            "mapping_index": 1,
            "section_id": "0f8d4e67-12a3-412f-aaf9-c6388e7e8282"
        },
        "id": "YlEqvaEqKk62Z1cjFGdI"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "timestamp": "2025-08-24 11:56:34.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "medium",
            "section_id": "0f8d4e67-12a3-412f-aaf9-c6388e7e8282"
        },
        "id": "jg4XBfDFRXuNHYNkfnRT"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "timestamp": "2025-08-24 11:56:34.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "medium",
            "mapping_index": 1,
            "section_id": "0f8d4e67-12a3-412f-aaf9-c6388e7e8282"
        },
        "id": "pmw7xr7JB5VcN219tSit"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "timestamp": "2025-08-24 11:56:47.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "medium",
            "section_id": "0f8d4e67-12a3-412f-aaf9-c6388e7e8282"
        },
        "id": "GG1cJjwekqFeZETzrLo1"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "timestamp": "2025-08-24 11:56:47.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "medium",
            "mapping_index": 2,
            "section_id": "0f8d4e67-12a3-412f-aaf9-c6388e7e8282"
        },
        "id": "c1klu3itLJbiVDbmtG2g"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "timestamp": "2025-08-24 11:56:47.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "medium",
            "mapping_index": 3,
            "section_id": "0f8d4e67-12a3-412f-aaf9-c6388e7e8282"
        },
        "id": "conaaqGUKl2z1gyCaPh7"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "timestamp": "2025-08-24 11:56:47.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "medium",
            "mapping_index": 4,
            "section_id": "0f8d4e67-12a3-412f-aaf9-c6388e7e8282"
        },
        "id": "gJwbZ0N448UjWM7Mj6XM"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "timestamp": "2025-08-24 11:56:47.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "medium",
            "section_id": "0f8d4e67-12a3-412f-aaf9-c6388e7e8282"
        },
        "id": "onBYRTwUCTMxi7Gs4ORQ"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "timestamp": "2025-08-24 11:56:47.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "medium",
            "section_id": "0f8d4e67-12a3-412f-aaf9-c6388e7e8282"
        },
        "id": "yEDOsNS6OkA17MJ6Fogp"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "timestamp": "2025-08-24 11:56:47.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "medium",
            "section_id": "0f8d4e67-12a3-412f-aaf9-c6388e7e8282"
        },
        "id": "zrZACdd4t9odKviNeA5J"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "timestamp": "2025-08-24 11:56:55.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "medium",
            "section_id": "0f8d4e67-12a3-412f-aaf9-c6388e7e8282"
        },
        "id": "0iuEicF0lbeMf9eqrKmp"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "timestamp": "2025-08-24 11:56:55.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "medium",
            "mapping_index": 0,
            "section_id": "0f8d4e67-12a3-412f-aaf9-c6388e7e8282"
        },
        "id": "96KsUsdyFTvTJLUbjYBT"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "timestamp": "2025-08-24 11:56:55.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "medium",
            "mapping_index": 2,
            "section_id": "0f8d4e67-12a3-412f-aaf9-c6388e7e8282"
        },
        "id": "A8S32AjdLT7cZezM1WJu"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "timestamp": "2025-08-24 11:56:55.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "medium",
            "section_id": "0f8d4e67-12a3-412f-aaf9-c6388e7e8282"
        },
        "id": "HlmLmaIPgVycQ9GMO5i4"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "timestamp": "2025-08-24 11:56:55.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "medium",
            "mapping_index": 4,
            "section_id": "0f8d4e67-12a3-412f-aaf9-c6388e7e8282"
        },
        "id": "LCACeReknufAK3Fz4AYP"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "timestamp": "2025-08-24 11:56:55.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "medium",
            "section_id": "0f8d4e67-12a3-412f-aaf9-c6388e7e8282"
        },
        "id": "VUneccMSeO2XPs7oiWGO"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "timestamp": "2025-08-24 11:56:55.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "medium",
            "section_id": "0f8d4e67-12a3-412f-aaf9-c6388e7e8282"
        },
        "id": "fHff3aPLVM9tjl0qBJSb"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "timestamp": "2025-08-24 11:56:55.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "medium",
            "mapping_index": 1,
            "section_id": "0f8d4e67-12a3-412f-aaf9-c6388e7e8282"
        },
        "id": "o378w1aIqiCo8xbP0qvG"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "timestamp": "2025-08-24 11:56:56.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "medium",
            "section_id": "0f8d4e67-12a3-412f-aaf9-c6388e7e8282"
        },
        "id": "Eo9ucnVi5zrO0ly66ayk"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "timestamp": "2025-08-24 11:56:56.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "medium",
            "mapping_index": 0,
            "section_id": "0f8d4e67-12a3-412f-aaf9-c6388e7e8282"
        },
        "id": "VRHlUhxXRQeCaoSWJlBe"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "timestamp": "2025-08-24 11:56:56.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "medium",
            "mapping_index": 1,
            "section_id": "0f8d4e67-12a3-412f-aaf9-c6388e7e8282"
        },
        "id": "izlnhN23abjKqQ7yAxhG"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "timestamp": "2025-08-24 11:56:57.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "medium",
            "section_id": "0f8d4e67-12a3-412f-aaf9-c6388e7e8282"
        },
        "id": "H6TRTPLiAhvVATNXCvxg"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "timestamp": "2025-08-24 11:56:57.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "medium",
            "mapping_index": 4,
            "section_id": "0f8d4e67-12a3-412f-aaf9-c6388e7e8282"
        },
        "id": "Mf5Aec1Wes6PZe1eqYih"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "timestamp": "2025-08-24 11:56:57.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "medium",
            "mapping_index": 2,
            "section_id": "0f8d4e67-12a3-412f-aaf9-c6388e7e8282"
        },
        "id": "RIqZUKtmgbmuJbAZ4Z1Z"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "timestamp": "2025-08-24 11:56:57.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "medium",
            "mapping_index": 1,
            "section_id": "0f8d4e67-12a3-412f-aaf9-c6388e7e8282"
        },
        "id": "RXY8T4Phn7hHkgHeYyUZ"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "timestamp": "2025-08-24 11:56:57.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "medium",
            "section_id": "0f8d4e67-12a3-412f-aaf9-c6388e7e8282"
        },
        "id": "UWPaeT7v7Zn6UYzCKScs"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "timestamp": "2025-08-24 11:56:57.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "medium",
            "section_id": "0f8d4e67-12a3-412f-aaf9-c6388e7e8282"
        },
        "id": "i44EzMbthFYNU7Qh4IAC"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "timestamp": "2025-08-24 11:56:57.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "medium",
            "section_id": "0f8d4e67-12a3-412f-aaf9-c6388e7e8282"
        },
        "id": "ngfJBOFT27GHxTUXQA5v"
    },
    {
        "source": "frontend",
        "event": "click_summarize_code",
        "timestamp": "2025-08-24 11:58:12.000",
        "data": {},
        "id": "V3ZubiB5dCd8NQTYYGkN"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "timestamp": "2025-08-24 11:58:19.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "medium",
            "mapping_index": 1,
            "section_id": "0f8d4e67-12a3-412f-aaf9-c6388e7e8282"
        },
        "id": "3wGJ7DklFu9dMhGokzoa"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "timestamp": "2025-08-24 11:58:19.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "medium",
            "mapping_index": 2,
            "section_id": "0f8d4e67-12a3-412f-aaf9-c6388e7e8282"
        },
        "id": "LYClLt3ehPsAYDfB9g7q"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "timestamp": "2025-08-24 11:58:19.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "medium",
            "section_id": "0f8d4e67-12a3-412f-aaf9-c6388e7e8282"
        },
        "id": "SObGpxZZPgWftKel70o4"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "timestamp": "2025-08-24 11:58:19.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "medium",
            "section_id": "0f8d4e67-12a3-412f-aaf9-c6388e7e8282"
        },
        "id": "mCcmS9Ie0WUjD44DaZBa"
    },
    {
        "source": "backend",
        "event": "summarize_selected_code",
        "timestamp": "2025-08-24 11:58:19.000",
        "data": {
            "summary": {
                "medium_structured": "• Calculates prediction error as the difference between predicted and true ranks\n• Filters data for the specified year and sorts players by true rank\n• Plots a bar chart of prediction errors for each player\n  ◦ Uses player names on the x-axis and error on the y-axis\n• Saves the plot as a PNG file named for the year",
                "low_unstructured": "This function plots the prediction error for player rankings in a specified year.",
                "high_structured": "• Computes the prediction error by subtracting the true rank from the predicted rank for each player\n• Filters the DataFrame to include only records from the specified year\n  ◦ Makes a copy and sorts players by their true rank for clear visualization\n• Creates a bar plot using Seaborn:\n  ◦ Player names are shown on the x-axis, prediction errors on the y-axis\n  ◦ Each player's bar is colored distinctly using the 'coolwarm' palette\n• Adds a horizontal dashed line at y=0 to indicate perfect prediction\n• Rotates x-axis labels for readability and sets axis labels and plot title\n• Adjusts the layout to prevent overlap and saves the plot as a PNG file named with the target year",
                "low_structured": "• Plots prediction error for a given year\n• Uses player ranking data\n• Saves the plot as an image",
                "high_unstructured": "The plot_ranking_predictions function generates a bar plot to visualize the prediction error (PredictedRank minus actual Rank) for each player in a specified year. It first computes the rank error, filters the DataFrame for the given year, and sorts players by their true rank. The function then creates a bar plot with player names on the x-axis and prediction error on the y-axis, adds a horizontal reference line at zero, and customizes the plot's appearance (such as rotating x-axis labels and setting the title). Finally, it saves the plot as a PNG file in the data directory, named according to the year.",
                "medium_unstructured": "The plot_ranking_predictions function visualizes the difference between predicted and actual player ranks for a specified year. It creates a bar plot showing these errors for each player and saves the resulting figure as a PNG file. The plot helps assess ranking prediction performance for that year.",
                "title": "plot_ranking_predictions Function Summary"
            },
            "selected_code": "def plot_ranking_predictions(df, year):\n    \"\"\"\n    Plot prediction error for a specific year.\n\n    Args:\n        df: DataFrame containing prediction results\n        year: Year to plot prediction errors for\n    \"\"\"\n    df[\"RankError\"] = df[\"PredictedRank\"] - df[\"Rank\"]\n    year_df = df[df[\"Year\"] == year].copy()\n    year_df.sort_values(\"Rank\", inplace=True)\n\n    plt.figure(figsize=(12, 6))\n    sns.barplot(x=\"Name\", y=\"RankError\", data=year_df, hue=\"Name\", palette=\"coolwarm\")\n    plt.axhline(0, color=\"black\", linestyle=\"--\")\n    plt.xticks(rotation=45, ha=\"right\")\n    plt.ylabel(\"Predicted Rank - True Rank\")\n    plt.title(f\"MVP Ranking Predictions ({year})\")\n    plt.tight_layout()\n    plt.savefig(f\"data/ranking_predictions_{year}.png\")"
        },
        "id": "sCPRMKK5Xi3lR7BcbyL5"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "timestamp": "2025-08-24 11:58:19.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "medium",
            "mapping_index": 0,
            "section_id": "0f8d4e67-12a3-412f-aaf9-c6388e7e8282"
        },
        "id": "zcJh7oY1N4xQIQbpQyU3"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "timestamp": "2025-08-24 11:58:20.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "medium",
            "section_id": "0f8d4e67-12a3-412f-aaf9-c6388e7e8282"
        },
        "id": "KoCclGzxsfV1epSpwfq3"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "timestamp": "2025-08-24 11:58:20.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "medium",
            "section_id": "0f8d4e67-12a3-412f-aaf9-c6388e7e8282"
        },
        "id": "T6U4FWxmLDhb7xtOwPbg"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "timestamp": "2025-08-24 11:58:20.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "medium",
            "mapping_index": 4,
            "section_id": "0f8d4e67-12a3-412f-aaf9-c6388e7e8282"
        },
        "id": "YhGBLg4C5Llj1vZsSjB0"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "timestamp": "2025-08-24 11:58:20.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "medium",
            "section_id": "0f8d4e67-12a3-412f-aaf9-c6388e7e8282"
        },
        "id": "oQcE8yf8e6hTiVvWUxcM"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "timestamp": "2025-08-24 11:58:20.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "medium",
            "mapping_index": 3,
            "section_id": "0f8d4e67-12a3-412f-aaf9-c6388e7e8282"
        },
        "id": "pMAI4g2N1QLqrRJdc5d5"
    },
    {
        "source": "backend",
        "event": "map_summary_code",
        "timestamp": "2025-08-24 11:58:21.000",
        "data": {
            "summary": "• Plots prediction error for a given year\n• Uses player ranking data\n• Saves the plot as an image",
            "code": "52: def plot_ranking_predictions(df, year):\n53:     \"\"\"\n54:     Plot prediction error for a specific year.\n55: \n56:     Args:\n57:         df: DataFrame containing prediction results\n58:         year: Year to plot prediction errors for\n59:     \"\"\"\n60:     df[\"RankError\"] = df[\"PredictedRank\"] - df[\"Rank\"]\n61:     year_df = df[df[\"Year\"] == year].copy()\n62:     year_df.sort_values(\"Rank\", inplace=True)\n63: \n64:     plt.figure(figsize=(12, 6))\n65:     sns.barplot(x=\"Name\", y=\"RankError\", data=year_df, hue=\"Name\", palette=\"coolwarm\")\n66:     plt.axhline(0, color=\"black\", linestyle=\"--\")\n67:     plt.xticks(rotation=45, ha=\"right\")\n68:     plt.ylabel(\"Predicted Rank - True Rank\")\n69:     plt.title(f\"MVP Ranking Predictions ({year})\")\n70:     plt.tight_layout()\n71:     plt.savefig(f\"data/ranking_predictions_{year}.png\")",
            "mapping": [
                {
                    "summaryComponent": "Plots prediction error for a given year",
                    "codeSegments": [
                        {
                            "code": "def plot_ranking_predictions(df, year):",
                            "line": 52
                        },
                        {
                            "code": "df[\"RankError\"] = df[\"PredictedRank\"] - df[\"Rank\"]",
                            "line": 60
                        },
                        {
                            "code": "year_df = df[df[\"Year\"] == year].copy()",
                            "line": 61
                        },
                        {
                            "code": "sns.barplot(x=\"Name\", y=\"RankError\", data=year_df, hue=\"Name\", palette=\"coolwarm\")",
                            "line": 65
                        }
                    ]
                },
                {
                    "summaryComponent": "Uses player ranking data",
                    "codeSegments": [
                        {
                            "code": "df[\"RankError\"] = df[\"PredictedRank\"] - df[\"Rank\"]",
                            "line": 60
                        },
                        {
                            "code": "year_df = df[df[\"Year\"] == year].copy()",
                            "line": 61
                        },
                        {
                            "code": "year_df.sort_values(\"Rank\", inplace=True)",
                            "line": 62
                        }
                    ]
                },
                {
                    "summaryComponent": "Saves the plot as an image",
                    "codeSegments": [
                        {
                            "code": "plt.savefig(f\"data/ranking_predictions_{year}.png\")",
                            "line": 71
                        }
                    ]
                }
            ]
        },
        "id": "8B0hfKpymcA6Te2LVrCm"
    },
    {
        "source": "backend",
        "event": "map_summary_code",
        "timestamp": "2025-08-24 11:58:21.000",
        "data": {
            "summary": "• Calculates prediction error as the difference between predicted and true ranks\n• Filters data for the specified year and sorts players by true rank\n• Plots a bar chart of prediction errors for each player\n  ◦ Uses player names on the x-axis and error on the y-axis\n• Saves the plot as a PNG file named for the year",
            "code": "52: def plot_ranking_predictions(df, year):\n53:     \"\"\"\n54:     Plot prediction error for a specific year.\n55: \n56:     Args:\n57:         df: DataFrame containing prediction results\n58:         year: Year to plot prediction errors for\n59:     \"\"\"\n60:     df[\"RankError\"] = df[\"PredictedRank\"] - df[\"Rank\"]\n61:     year_df = df[df[\"Year\"] == year].copy()\n62:     year_df.sort_values(\"Rank\", inplace=True)\n63: \n64:     plt.figure(figsize=(12, 6))\n65:     sns.barplot(x=\"Name\", y=\"RankError\", data=year_df, hue=\"Name\", palette=\"coolwarm\")\n66:     plt.axhline(0, color=\"black\", linestyle=\"--\")\n67:     plt.xticks(rotation=45, ha=\"right\")\n68:     plt.ylabel(\"Predicted Rank - True Rank\")\n69:     plt.title(f\"MVP Ranking Predictions ({year})\")\n70:     plt.tight_layout()\n71:     plt.savefig(f\"data/ranking_predictions_{year}.png\")",
            "mapping": [
                {
                    "summaryComponent": "Calculates prediction error as the difference between predicted and true ranks",
                    "codeSegments": [
                        {
                            "code": "df[\"RankError\"] = df[\"PredictedRank\"] - df[\"Rank\"]",
                            "line": 60
                        }
                    ]
                },
                {
                    "summaryComponent": "Filters data for the specified year and sorts players by true rank",
                    "codeSegments": [
                        {
                            "code": "year_df = df[df[\"Year\"] == year].copy()",
                            "line": 61
                        },
                        {
                            "code": "year_df.sort_values(\"Rank\", inplace=True)",
                            "line": 62
                        }
                    ]
                },
                {
                    "summaryComponent": "Plots a bar chart of prediction errors for each player",
                    "codeSegments": [
                        {
                            "code": "sns.barplot(x=\"Name\", y=\"RankError\", data=year_df, hue=\"Name\", palette=\"coolwarm\")",
                            "line": 65
                        }
                    ]
                },
                {
                    "summaryComponent": "Uses player names on the x-axis and error on the y-axis",
                    "codeSegments": [
                        {
                            "code": "sns.barplot(x=\"Name\", y=\"RankError\", data=year_df, hue=\"Name\", palette=\"coolwarm\")",
                            "line": 65
                        }
                    ]
                },
                {
                    "summaryComponent": "Saves the plot as a PNG file named for the year",
                    "codeSegments": [
                        {
                            "code": "plt.savefig(f\"data/ranking_predictions_{year}.png\")",
                            "line": 71
                        }
                    ]
                }
            ]
        },
        "id": "FTYEZi9AkF4R95nYEVx5"
    },
    {
        "source": "backend",
        "event": "map_summary_code",
        "timestamp": "2025-08-24 11:58:22.000",
        "data": {
            "summary": "The plot_ranking_predictions function visualizes the difference between predicted and actual player ranks for a specified year. It creates a bar plot showing these errors for each player and saves the resulting figure as a PNG file. The plot helps assess ranking prediction performance for that year.",
            "code": "52: def plot_ranking_predictions(df, year):\n53:     \"\"\"\n54:     Plot prediction error for a specific year.\n55: \n56:     Args:\n57:         df: DataFrame containing prediction results\n58:         year: Year to plot prediction errors for\n59:     \"\"\"\n60:     df[\"RankError\"] = df[\"PredictedRank\"] - df[\"Rank\"]\n61:     year_df = df[df[\"Year\"] == year].copy()\n62:     year_df.sort_values(\"Rank\", inplace=True)\n63: \n64:     plt.figure(figsize=(12, 6))\n65:     sns.barplot(x=\"Name\", y=\"RankError\", data=year_df, hue=\"Name\", palette=\"coolwarm\")\n66:     plt.axhline(0, color=\"black\", linestyle=\"--\")\n67:     plt.xticks(rotation=45, ha=\"right\")\n68:     plt.ylabel(\"Predicted Rank - True Rank\")\n69:     plt.title(f\"MVP Ranking Predictions ({year})\")\n70:     plt.tight_layout()\n71:     plt.savefig(f\"data/ranking_predictions_{year}.png\")",
            "mapping": [
                {
                    "summaryComponent": "The plot_ranking_predictions function",
                    "codeSegments": [
                        {
                            "code": "def plot_ranking_predictions(df, year):",
                            "line": 52
                        }
                    ]
                },
                {
                    "summaryComponent": "visualizes the difference between predicted and actual player ranks",
                    "codeSegments": [
                        {
                            "code": "df[\"RankError\"] = df[\"PredictedRank\"] - df[\"Rank\"]",
                            "line": 60
                        }
                    ]
                },
                {
                    "summaryComponent": "for a specified year",
                    "codeSegments": [
                        {
                            "code": "year_df = df[df[\"Year\"] == year].copy()",
                            "line": 61
                        }
                    ]
                },
                {
                    "summaryComponent": "It creates a bar plot",
                    "codeSegments": [
                        {
                            "code": "sns.barplot(x=\"Name\", y=\"RankError\", data=year_df, hue=\"Name\", palette=\"coolwarm\")",
                            "line": 65
                        }
                    ]
                },
                {
                    "summaryComponent": "showing these errors for each player",
                    "codeSegments": [
                        {
                            "code": "x=\"Name\", y=\"RankError\", data=year_df",
                            "line": 65
                        }
                    ]
                },
                {
                    "summaryComponent": "and saves the resulting figure as a PNG file",
                    "codeSegments": [
                        {
                            "code": "plt.savefig(f\"data/ranking_predictions_{year}.png\")",
                            "line": 71
                        }
                    ]
                },
                {
                    "summaryComponent": "The plot helps assess ranking prediction performance for that year",
                    "codeSegments": [
                        {
                            "code": "plt.title(f\"MVP Ranking Predictions ({year})\")",
                            "line": 69
                        }
                    ]
                }
            ]
        },
        "id": "islpADpQz6q4TfB6AXda"
    },
    {
        "source": "backend",
        "event": "map_summary_code",
        "timestamp": "2025-08-24 11:58:23.000",
        "data": {
            "summary": "• Computes the prediction error by subtracting the true rank from the predicted rank for each player\n• Filters the DataFrame to include only records from the specified year\n  ◦ Makes a copy and sorts players by their true rank for clear visualization\n• Creates a bar plot using Seaborn:\n  ◦ Player names are shown on the x-axis, prediction errors on the y-axis\n  ◦ Each player's bar is colored distinctly using the 'coolwarm' palette\n• Adds a horizontal dashed line at y=0 to indicate perfect prediction\n• Rotates x-axis labels for readability and sets axis labels and plot title\n• Adjusts the layout to prevent overlap and saves the plot as a PNG file named with the target year",
            "code": "52: def plot_ranking_predictions(df, year):\n53:     \"\"\"\n54:     Plot prediction error for a specific year.\n55: \n56:     Args:\n57:         df: DataFrame containing prediction results\n58:         year: Year to plot prediction errors for\n59:     \"\"\"\n60:     df[\"RankError\"] = df[\"PredictedRank\"] - df[\"Rank\"]\n61:     year_df = df[df[\"Year\"] == year].copy()\n62:     year_df.sort_values(\"Rank\", inplace=True)\n63: \n64:     plt.figure(figsize=(12, 6))\n65:     sns.barplot(x=\"Name\", y=\"RankError\", data=year_df, hue=\"Name\", palette=\"coolwarm\")\n66:     plt.axhline(0, color=\"black\", linestyle=\"--\")\n67:     plt.xticks(rotation=45, ha=\"right\")\n68:     plt.ylabel(\"Predicted Rank - True Rank\")\n69:     plt.title(f\"MVP Ranking Predictions ({year})\")\n70:     plt.tight_layout()\n71:     plt.savefig(f\"data/ranking_predictions_{year}.png\")",
            "mapping": [
                {
                    "summaryComponent": "Computes the prediction error by subtracting the true rank from the predicted rank for each player",
                    "codeSegments": [
                        {
                            "code": "df[\"RankError\"] = df[\"PredictedRank\"] - df[\"Rank\"]",
                            "line": 60
                        }
                    ]
                },
                {
                    "summaryComponent": "Filters the DataFrame to include only records from the specified year",
                    "codeSegments": [
                        {
                            "code": "year_df = df[df[\"Year\"] == year].copy()",
                            "line": 61
                        }
                    ]
                },
                {
                    "summaryComponent": "Makes a copy and sorts players by their true rank for clear visualization",
                    "codeSegments": [
                        {
                            "code": "year_df = df[df[\"Year\"] == year].copy()",
                            "line": 61
                        },
                        {
                            "code": "year_df.sort_values(\"Rank\", inplace=True)",
                            "line": 62
                        }
                    ]
                },
                {
                    "summaryComponent": "Creates a bar plot using Seaborn:",
                    "codeSegments": [
                        {
                            "code": "sns.barplot(x=\"Name\", y=\"RankError\", data=year_df, hue=\"Name\", palette=\"coolwarm\")",
                            "line": 65
                        }
                    ]
                },
                {
                    "summaryComponent": "Player names are shown on the x-axis, prediction errors on the y-axis",
                    "codeSegments": [
                        {
                            "code": "sns.barplot(x=\"Name\", y=\"RankError\", data=year_df, hue=\"Name\", palette=\"coolwarm\")",
                            "line": 65
                        }
                    ]
                },
                {
                    "summaryComponent": "Each player's bar is colored distinctly using the 'coolwarm' palette",
                    "codeSegments": [
                        {
                            "code": "sns.barplot(x=\"Name\", y=\"RankError\", data=year_df, hue=\"Name\", palette=\"coolwarm\")",
                            "line": 65
                        }
                    ]
                },
                {
                    "summaryComponent": "Adds a horizontal dashed line at y=0 to indicate perfect prediction",
                    "codeSegments": [
                        {
                            "code": "plt.axhline(0, color=\"black\", linestyle=\"--\")",
                            "line": 66
                        }
                    ]
                },
                {
                    "summaryComponent": "Rotates x-axis labels for readability and sets axis labels and plot title",
                    "codeSegments": [
                        {
                            "code": "plt.xticks(rotation=45, ha=\"right\")",
                            "line": 67
                        },
                        {
                            "code": "plt.ylabel(\"Predicted Rank - True Rank\")",
                            "line": 68
                        },
                        {
                            "code": "plt.title(f\"MVP Ranking Predictions ({year})\")",
                            "line": 69
                        }
                    ]
                },
                {
                    "summaryComponent": "Adjusts the layout to prevent overlap and saves the plot as a PNG file named with the target year",
                    "codeSegments": [
                        {
                            "code": "plt.tight_layout()",
                            "line": 70
                        },
                        {
                            "code": "plt.savefig(f\"data/ranking_predictions_{year}.png\")",
                            "line": 71
                        }
                    ]
                }
            ]
        },
        "id": "2sLaOBGexVzhf4NyDlTo"
    },
    {
        "source": "backend",
        "event": "map_summary_code",
        "timestamp": "2025-08-24 11:58:23.000",
        "data": {
            "summary": "The plot_ranking_predictions function generates a bar plot to visualize the prediction error (PredictedRank minus actual Rank) for each player in a specified year. It first computes the rank error, filters the DataFrame for the given year, and sorts players by their true rank. The function then creates a bar plot with player names on the x-axis and prediction error on the y-axis, adds a horizontal reference line at zero, and customizes the plot's appearance (such as rotating x-axis labels and setting the title). Finally, it saves the plot as a PNG file in the data directory, named according to the year.",
            "code": "52: def plot_ranking_predictions(df, year):\n53:     \"\"\"\n54:     Plot prediction error for a specific year.\n55: \n56:     Args:\n57:         df: DataFrame containing prediction results\n58:         year: Year to plot prediction errors for\n59:     \"\"\"\n60:     df[\"RankError\"] = df[\"PredictedRank\"] - df[\"Rank\"]\n61:     year_df = df[df[\"Year\"] == year].copy()\n62:     year_df.sort_values(\"Rank\", inplace=True)\n63: \n64:     plt.figure(figsize=(12, 6))\n65:     sns.barplot(x=\"Name\", y=\"RankError\", data=year_df, hue=\"Name\", palette=\"coolwarm\")\n66:     plt.axhline(0, color=\"black\", linestyle=\"--\")\n67:     plt.xticks(rotation=45, ha=\"right\")\n68:     plt.ylabel(\"Predicted Rank - True Rank\")\n69:     plt.title(f\"MVP Ranking Predictions ({year})\")\n70:     plt.tight_layout()\n71:     plt.savefig(f\"data/ranking_predictions_{year}.png\")",
            "mapping": [
                {
                    "summaryComponent": "The plot_ranking_predictions function generates a bar plot to visualize the prediction error (PredictedRank minus actual Rank) for each player in a specified year.",
                    "codeSegments": [
                        {
                            "code": "def plot_ranking_predictions(df, year):",
                            "line": 52
                        },
                        {
                            "code": "sns.barplot(x=\"Name\", y=\"RankError\", data=year_df, hue=\"Name\", palette=\"coolwarm\")",
                            "line": 65
                        }
                    ]
                },
                {
                    "summaryComponent": "It first computes the rank error",
                    "codeSegments": [
                        {
                            "code": "df[\"RankError\"] = df[\"PredictedRank\"] - df[\"Rank\"]",
                            "line": 60
                        }
                    ]
                },
                {
                    "summaryComponent": "filters the DataFrame for the given year",
                    "codeSegments": [
                        {
                            "code": "year_df = df[df[\"Year\"] == year].copy()",
                            "line": 61
                        }
                    ]
                },
                {
                    "summaryComponent": "and sorts players by their true rank.",
                    "codeSegments": [
                        {
                            "code": "year_df.sort_values(\"Rank\", inplace=True)",
                            "line": 62
                        }
                    ]
                },
                {
                    "summaryComponent": "The function then creates a bar plot with player names on the x-axis and prediction error on the y-axis",
                    "codeSegments": [
                        {
                            "code": "sns.barplot(x=\"Name\", y=\"RankError\", data=year_df, hue=\"Name\", palette=\"coolwarm\")",
                            "line": 65
                        }
                    ]
                },
                {
                    "summaryComponent": "adds a horizontal reference line at zero",
                    "codeSegments": [
                        {
                            "code": "plt.axhline(0, color=\"black\", linestyle=\"--\")",
                            "line": 66
                        }
                    ]
                },
                {
                    "summaryComponent": "and customizes the plot's appearance (such as rotating x-axis labels and setting the title).",
                    "codeSegments": [
                        {
                            "code": "plt.xticks(rotation=45, ha=\"right\")",
                            "line": 67
                        },
                        {
                            "code": "plt.title(f\"MVP Ranking Predictions ({year})\")",
                            "line": 69
                        }
                    ]
                },
                {
                    "summaryComponent": "Finally, it saves the plot as a PNG file in the data directory, named according to the year.",
                    "codeSegments": [
                        {
                            "code": "plt.savefig(f\"data/ranking_predictions_{year}.png\")",
                            "line": 71
                        }
                    ]
                }
            ]
        },
        "id": "ynPviJ3yYUA6A1LObFit"
    },
    {
        "source": "frontend",
        "event": "autotransit_section",
        "timestamp": "2025-08-24 11:58:25.000",
        "data": {
            "before_section_id": "0f8d4e67-12a3-412f-aaf9-c6388e7e8282",
            "after_section_id": "2200d6eb-db5a-48d9-bcfe-8e6213e48872"
        },
        "id": "ctHrTfBdj4OPjv8f0OUy"
    },
    {
        "source": "backend",
        "event": "map_summary_code",
        "timestamp": "2025-08-24 11:58:25.000",
        "data": {
            "summary": "This function plots the prediction error for player rankings in a specified year.",
            "code": "52: def plot_ranking_predictions(df, year):\n53:     \"\"\"\n54:     Plot prediction error for a specific year.\n55: \n56:     Args:\n57:         df: DataFrame containing prediction results\n58:         year: Year to plot prediction errors for\n59:     \"\"\"\n60:     df[\"RankError\"] = df[\"PredictedRank\"] - df[\"Rank\"]\n61:     year_df = df[df[\"Year\"] == year].copy()\n62:     year_df.sort_values(\"Rank\", inplace=True)\n63: \n64:     plt.figure(figsize=(12, 6))\n65:     sns.barplot(x=\"Name\", y=\"RankError\", data=year_df, hue=\"Name\", palette=\"coolwarm\")\n66:     plt.axhline(0, color=\"black\", linestyle=\"--\")\n67:     plt.xticks(rotation=45, ha=\"right\")\n68:     plt.ylabel(\"Predicted Rank - True Rank\")\n69:     plt.title(f\"MVP Ranking Predictions ({year})\")\n70:     plt.tight_layout()\n71:     plt.savefig(f\"data/ranking_predictions_{year}.png\")",
            "mapping": [
                {
                    "summaryComponent": "This function",
                    "codeSegments": [
                        {
                            "code": "def plot_ranking_predictions(df, year):",
                            "line": 52
                        }
                    ]
                },
                {
                    "summaryComponent": "plots the prediction error",
                    "codeSegments": [
                        {
                            "code": "df[\"RankError\"] = df[\"PredictedRank\"] - df[\"Rank\"]",
                            "line": 60
                        },
                        {
                            "code": "sns.barplot(x=\"Name\", y=\"RankError\", data=year_df, hue=\"Name\", palette=\"coolwarm\")",
                            "line": 65
                        }
                    ]
                },
                {
                    "summaryComponent": "for player rankings",
                    "codeSegments": [
                        {
                            "code": "df[\"RankError\"] = df[\"PredictedRank\"] - df[\"Rank\"]",
                            "line": 60
                        },
                        {
                            "code": "year_df.sort_values(\"Rank\", inplace=True)",
                            "line": 62
                        }
                    ]
                },
                {
                    "summaryComponent": "in a specified year",
                    "codeSegments": [
                        {
                            "code": "year_df = df[df[\"Year\"] == year].copy()",
                            "line": 61
                        },
                        {
                            "code": "plt.title(f\"MVP Ranking Predictions ({year})\")",
                            "line": 69
                        },
                        {
                            "code": "plt.savefig(f\"data/ranking_predictions_{year}.png\")",
                            "line": 71
                        }
                    ]
                }
            ]
        },
        "id": "k2pBrB6z4plJG1lz0qdG"
    },
    {
        "source": "frontend",
        "event": "create_new_section",
        "timestamp": "2025-08-24 11:58:25.000",
        "data": {
            "section_data": {
                "selectedDetailLevel": "medium",
                "createdAt": 1756065505000,
                "metadata": {
                    "originalCode": "def plot_ranking_predictions(df, year):\n    \"\"\"\n    Plot prediction error for a specific year.\n\n    Args:\n        df: DataFrame containing prediction results\n        year: Year to plot prediction errors for\n    \"\"\"\n    df[\"RankError\"] = df[\"PredictedRank\"] - df[\"Rank\"]\n    year_df = df[df[\"Year\"] == year].copy()\n    year_df.sort_values(\"Rank\", inplace=True)\n\n    plt.figure(figsize=(12, 6))\n    sns.barplot(x=\"Name\", y=\"RankError\", data=year_df, hue=\"Name\", palette=\"coolwarm\")\n    plt.axhline(0, color=\"black\", linestyle=\"--\")\n    plt.xticks(rotation=45, ha=\"right\")\n    plt.ylabel(\"Predicted Rank - True Rank\")\n    plt.title(f\"MVP Ranking Predictions ({year})\")\n    plt.tight_layout()\n    plt.savefig(f\"data/ranking_predictions_{year}.png\")",
                    "id": "2200d6eb-db5a-48d9-bcfe-8e6213e48872",
                    "filename": "rank_model.py",
                    "fullPath": "/project/workspace/rank_model.py",
                    "offset": 1205
                },
                "summaryData": {
                    "medium_structured": "• Calculates prediction error as the difference between predicted and true ranks\n• Filters data for the specified year and sorts players by true rank\n• Plots a bar chart of prediction errors for each player\n  ◦ Uses player names on the x-axis and error on the y-axis\n• Saves the plot as a PNG file named for the year",
                    "low_unstructured": "This function plots the prediction error for player rankings in a specified year.",
                    "high_structured": "• Computes the prediction error by subtracting the true rank from the predicted rank for each player\n• Filters the DataFrame to include only records from the specified year\n  ◦ Makes a copy and sorts players by their true rank for clear visualization\n• Creates a bar plot using Seaborn:\n  ◦ Player names are shown on the x-axis, prediction errors on the y-axis\n  ◦ Each player's bar is colored distinctly using the 'coolwarm' palette\n• Adds a horizontal dashed line at y=0 to indicate perfect prediction\n• Rotates x-axis labels for readability and sets axis labels and plot title\n• Adjusts the layout to prevent overlap and saves the plot as a PNG file named with the target year",
                    "low_structured": "• Plots prediction error for a given year\n• Uses player ranking data\n• Saves the plot as an image",
                    "high_unstructured": "The plot_ranking_predictions function generates a bar plot to visualize the prediction error (PredictedRank minus actual Rank) for each player in a specified year. It first computes the rank error, filters the DataFrame for the given year, and sorts players by their true rank. The function then creates a bar plot with player names on the x-axis and prediction error on the y-axis, adds a horizontal reference line at zero, and customizes the plot's appearance (such as rotating x-axis labels and setting the title). Finally, it saves the plot as a PNG file in the data directory, named according to the year.",
                    "medium_unstructured": "The plot_ranking_predictions function visualizes the difference between predicted and actual player ranks for a specified year. It creates a bar plot showing these errors for each player and saves the resulting figure as a PNG file. The plot helps assess ranking prediction performance for that year.",
                    "title": "plot_ranking_predictions Function Summary"
                },
                "selectedStructured": "unstructured",
                "summaryMappings": {
                    "medium_structured": [
                        {
                            "summaryComponent": "Calculates prediction error as the difference between predicted and true ranks",
                            "codeSegments": [
                                {
                                    "code": "df[\"RankError\"] = df[\"PredictedRank\"] - df[\"Rank\"]",
                                    "line": 60
                                }
                            ]
                        },
                        {
                            "summaryComponent": "Filters data for the specified year and sorts players by true rank",
                            "codeSegments": [
                                {
                                    "code": "year_df = df[df[\"Year\"] == year].copy()",
                                    "line": 61
                                },
                                {
                                    "code": "year_df.sort_values(\"Rank\", inplace=True)",
                                    "line": 62
                                }
                            ]
                        },
                        {
                            "summaryComponent": "Plots a bar chart of prediction errors for each player",
                            "codeSegments": [
                                {
                                    "code": "sns.barplot(x=\"Name\", y=\"RankError\", data=year_df, hue=\"Name\", palette=\"coolwarm\")",
                                    "line": 65
                                }
                            ]
                        },
                        {
                            "summaryComponent": "Uses player names on the x-axis and error on the y-axis",
                            "codeSegments": [
                                {
                                    "code": "sns.barplot(x=\"Name\", y=\"RankError\", data=year_df, hue=\"Name\", palette=\"coolwarm\")",
                                    "line": 65
                                }
                            ]
                        },
                        {
                            "summaryComponent": "Saves the plot as a PNG file named for the year",
                            "codeSegments": [
                                {
                                    "code": "plt.savefig(f\"data/ranking_predictions_{year}.png\")",
                                    "line": 71
                                }
                            ]
                        }
                    ],
                    "high_structured": [
                        {
                            "summaryComponent": "Computes the prediction error by subtracting the true rank from the predicted rank for each player",
                            "codeSegments": [
                                {
                                    "code": "df[\"RankError\"] = df[\"PredictedRank\"] - df[\"Rank\"]",
                                    "line": 60
                                }
                            ]
                        },
                        {
                            "summaryComponent": "Filters the DataFrame to include only records from the specified year",
                            "codeSegments": [
                                {
                                    "code": "year_df = df[df[\"Year\"] == year].copy()",
                                    "line": 61
                                }
                            ]
                        },
                        {
                            "summaryComponent": "Makes a copy and sorts players by their true rank for clear visualization",
                            "codeSegments": [
                                {
                                    "code": "year_df = df[df[\"Year\"] == year].copy()",
                                    "line": 61
                                },
                                {
                                    "code": "year_df.sort_values(\"Rank\", inplace=True)",
                                    "line": 62
                                }
                            ]
                        },
                        {
                            "summaryComponent": "Creates a bar plot using Seaborn:",
                            "codeSegments": [
                                {
                                    "code": "sns.barplot(x=\"Name\", y=\"RankError\", data=year_df, hue=\"Name\", palette=\"coolwarm\")",
                                    "line": 65
                                }
                            ]
                        },
                        {
                            "summaryComponent": "Player names are shown on the x-axis, prediction errors on the y-axis",
                            "codeSegments": [
                                {
                                    "code": "sns.barplot(x=\"Name\", y=\"RankError\", data=year_df, hue=\"Name\", palette=\"coolwarm\")",
                                    "line": 65
                                }
                            ]
                        },
                        {
                            "summaryComponent": "Each player's bar is colored distinctly using the 'coolwarm' palette",
                            "codeSegments": [
                                {
                                    "code": "sns.barplot(x=\"Name\", y=\"RankError\", data=year_df, hue=\"Name\", palette=\"coolwarm\")",
                                    "line": 65
                                }
                            ]
                        },
                        {
                            "summaryComponent": "Adds a horizontal dashed line at y=0 to indicate perfect prediction",
                            "codeSegments": [
                                {
                                    "code": "plt.axhline(0, color=\"black\", linestyle=\"--\")",
                                    "line": 66
                                }
                            ]
                        },
                        {
                            "summaryComponent": "Rotates x-axis labels for readability and sets axis labels and plot title",
                            "codeSegments": [
                                {
                                    "code": "plt.xticks(rotation=45, ha=\"right\")",
                                    "line": 67
                                },
                                {
                                    "code": "plt.ylabel(\"Predicted Rank - True Rank\")",
                                    "line": 68
                                },
                                {
                                    "code": "plt.title(f\"MVP Ranking Predictions ({year})\")",
                                    "line": 69
                                }
                            ]
                        },
                        {
                            "summaryComponent": "Adjusts the layout to prevent overlap and saves the plot as a PNG file named with the target year",
                            "codeSegments": [
                                {
                                    "code": "plt.tight_layout()",
                                    "line": 70
                                },
                                {
                                    "code": "plt.savefig(f\"data/ranking_predictions_{year}.png\")",
                                    "line": 71
                                }
                            ]
                        }
                    ],
                    "low_structured": [
                        {
                            "summaryComponent": "Plots prediction error for a given year",
                            "codeSegments": [
                                {
                                    "code": "def plot_ranking_predictions(df, year):",
                                    "line": 52
                                },
                                {
                                    "code": "df[\"RankError\"] = df[\"PredictedRank\"] - df[\"Rank\"]",
                                    "line": 60
                                },
                                {
                                    "code": "year_df = df[df[\"Year\"] == year].copy()",
                                    "line": 61
                                },
                                {
                                    "code": "sns.barplot(x=\"Name\", y=\"RankError\", data=year_df, hue=\"Name\", palette=\"coolwarm\")",
                                    "line": 65
                                }
                            ]
                        },
                        {
                            "summaryComponent": "Uses player ranking data",
                            "codeSegments": [
                                {
                                    "code": "df[\"RankError\"] = df[\"PredictedRank\"] - df[\"Rank\"]",
                                    "line": 60
                                },
                                {
                                    "code": "year_df = df[df[\"Year\"] == year].copy()",
                                    "line": 61
                                },
                                {
                                    "code": "year_df.sort_values(\"Rank\", inplace=True)",
                                    "line": 62
                                }
                            ]
                        },
                        {
                            "summaryComponent": "Saves the plot as an image",
                            "codeSegments": [
                                {
                                    "code": "plt.savefig(f\"data/ranking_predictions_{year}.png\")",
                                    "line": 71
                                }
                            ]
                        }
                    ],
                    "high_unstructured": [
                        {
                            "summaryComponent": "The plot_ranking_predictions function generates a bar plot to visualize the prediction error (PredictedRank minus actual Rank) for each player in a specified year.",
                            "codeSegments": [
                                {
                                    "code": "def plot_ranking_predictions(df, year):",
                                    "line": 52
                                },
                                {
                                    "code": "sns.barplot(x=\"Name\", y=\"RankError\", data=year_df, hue=\"Name\", palette=\"coolwarm\")",
                                    "line": 65
                                }
                            ]
                        },
                        {
                            "summaryComponent": "It first computes the rank error",
                            "codeSegments": [
                                {
                                    "code": "df[\"RankError\"] = df[\"PredictedRank\"] - df[\"Rank\"]",
                                    "line": 60
                                }
                            ]
                        },
                        {
                            "summaryComponent": "filters the DataFrame for the given year",
                            "codeSegments": [
                                {
                                    "code": "year_df = df[df[\"Year\"] == year].copy()",
                                    "line": 61
                                }
                            ]
                        },
                        {
                            "summaryComponent": "and sorts players by their true rank.",
                            "codeSegments": [
                                {
                                    "code": "year_df.sort_values(\"Rank\", inplace=True)",
                                    "line": 62
                                }
                            ]
                        },
                        {
                            "summaryComponent": "The function then creates a bar plot with player names on the x-axis and prediction error on the y-axis",
                            "codeSegments": [
                                {
                                    "code": "sns.barplot(x=\"Name\", y=\"RankError\", data=year_df, hue=\"Name\", palette=\"coolwarm\")",
                                    "line": 65
                                }
                            ]
                        },
                        {
                            "summaryComponent": "adds a horizontal reference line at zero",
                            "codeSegments": [
                                {
                                    "code": "plt.axhline(0, color=\"black\", linestyle=\"--\")",
                                    "line": 66
                                }
                            ]
                        },
                        {
                            "summaryComponent": "and customizes the plot's appearance (such as rotating x-axis labels and setting the title).",
                            "codeSegments": [
                                {
                                    "code": "plt.xticks(rotation=45, ha=\"right\")",
                                    "line": 67
                                },
                                {
                                    "code": "plt.title(f\"MVP Ranking Predictions ({year})\")",
                                    "line": 69
                                }
                            ]
                        },
                        {
                            "summaryComponent": "Finally, it saves the plot as a PNG file in the data directory, named according to the year.",
                            "codeSegments": [
                                {
                                    "code": "plt.savefig(f\"data/ranking_predictions_{year}.png\")",
                                    "line": 71
                                }
                            ]
                        }
                    ],
                    "medium_unstructured": [
                        {
                            "summaryComponent": "The plot_ranking_predictions function",
                            "codeSegments": [
                                {
                                    "code": "def plot_ranking_predictions(df, year):",
                                    "line": 52
                                }
                            ]
                        },
                        {
                            "summaryComponent": "visualizes the difference between predicted and actual player ranks",
                            "codeSegments": [
                                {
                                    "code": "df[\"RankError\"] = df[\"PredictedRank\"] - df[\"Rank\"]",
                                    "line": 60
                                }
                            ]
                        },
                        {
                            "summaryComponent": "for a specified year",
                            "codeSegments": [
                                {
                                    "code": "year_df = df[df[\"Year\"] == year].copy()",
                                    "line": 61
                                }
                            ]
                        },
                        {
                            "summaryComponent": "It creates a bar plot",
                            "codeSegments": [
                                {
                                    "code": "sns.barplot(x=\"Name\", y=\"RankError\", data=year_df, hue=\"Name\", palette=\"coolwarm\")",
                                    "line": 65
                                }
                            ]
                        },
                        {
                            "summaryComponent": "showing these errors for each player",
                            "codeSegments": [
                                {
                                    "code": "x=\"Name\", y=\"RankError\", data=year_df",
                                    "line": 65
                                }
                            ]
                        },
                        {
                            "summaryComponent": "and saves the resulting figure as a PNG file",
                            "codeSegments": [
                                {
                                    "code": "plt.savefig(f\"data/ranking_predictions_{year}.png\")",
                                    "line": 71
                                }
                            ]
                        },
                        {
                            "summaryComponent": "The plot helps assess ranking prediction performance for that year",
                            "codeSegments": [
                                {
                                    "code": "plt.title(f\"MVP Ranking Predictions ({year})\")",
                                    "line": 69
                                }
                            ]
                        }
                    ],
                    "low_unstructured": [
                        {
                            "summaryComponent": "This function",
                            "codeSegments": [
                                {
                                    "code": "def plot_ranking_predictions(df, year):",
                                    "line": 52
                                }
                            ]
                        },
                        {
                            "summaryComponent": "plots the prediction error",
                            "codeSegments": [
                                {
                                    "code": "df[\"RankError\"] = df[\"PredictedRank\"] - df[\"Rank\"]",
                                    "line": 60
                                },
                                {
                                    "code": "sns.barplot(x=\"Name\", y=\"RankError\", data=year_df, hue=\"Name\", palette=\"coolwarm\")",
                                    "line": 65
                                }
                            ]
                        },
                        {
                            "summaryComponent": "for player rankings",
                            "codeSegments": [
                                {
                                    "code": "df[\"RankError\"] = df[\"PredictedRank\"] - df[\"Rank\"]",
                                    "line": 60
                                },
                                {
                                    "code": "year_df.sort_values(\"Rank\", inplace=True)",
                                    "line": 62
                                }
                            ]
                        },
                        {
                            "summaryComponent": "in a specified year",
                            "codeSegments": [
                                {
                                    "code": "year_df = df[df[\"Year\"] == year].copy()",
                                    "line": 61
                                },
                                {
                                    "code": "plt.title(f\"MVP Ranking Predictions ({year})\")",
                                    "line": 69
                                },
                                {
                                    "code": "plt.savefig(f\"data/ranking_predictions_{year}.png\")",
                                    "line": 71
                                }
                            ]
                        }
                    ]
                },
                "editPromptValue": "",
                "editPromptDetailLevel": null,
                "editPromptStructured": null,
                "lines": [
                    52,
                    71
                ],
                "title": "plot_ranking_predictions Function Summary"
            },
            "section_id": "2200d6eb-db5a-48d9-bcfe-8e6213e48872"
        },
        "id": "ur1MOVhiOJOoIXfQMC8U"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "timestamp": "2025-08-24 11:58:26.000",
        "data": {
            "structured_type": "unstructured",
            "detail_level": "medium",
            "mapping_index": 5,
            "section_id": "2200d6eb-db5a-48d9-bcfe-8e6213e48872"
        },
        "id": "cetZE35SAzNnyp9RVdHJ"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "timestamp": "2025-08-24 11:58:26.000",
        "data": {
            "structured_type": "unstructured",
            "detail_level": "medium",
            "section_id": "2200d6eb-db5a-48d9-bcfe-8e6213e48872"
        },
        "id": "fXiWp2NCEPzNpWuybaek"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "timestamp": "2025-08-24 11:58:26.000",
        "data": {
            "structured_type": "unstructured",
            "detail_level": "medium",
            "mapping_index": 6,
            "section_id": "2200d6eb-db5a-48d9-bcfe-8e6213e48872"
        },
        "id": "qc38lePEH8sobkg6HsX7"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "timestamp": "2025-08-24 11:58:27.000",
        "data": {
            "structured_type": "unstructured",
            "detail_level": "medium",
            "section_id": "2200d6eb-db5a-48d9-bcfe-8e6213e48872"
        },
        "id": "ZytJPjIVK43Wbz6626QV"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "timestamp": "2025-08-24 11:58:27.000",
        "data": {
            "structured_type": "unstructured",
            "detail_level": "medium",
            "mapping_index": 2,
            "section_id": "2200d6eb-db5a-48d9-bcfe-8e6213e48872"
        },
        "id": "lSnAMb5dnhEaB4wz44WT"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "timestamp": "2025-08-24 11:58:28.000",
        "data": {
            "structured_type": "unstructured",
            "detail_level": "medium",
            "mapping_index": 5,
            "section_id": "2200d6eb-db5a-48d9-bcfe-8e6213e48872"
        },
        "id": "BdLpc6WU7bjHq3DhtfJo"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "timestamp": "2025-08-24 11:58:28.000",
        "data": {
            "structured_type": "unstructured",
            "detail_level": "medium",
            "mapping_index": 0,
            "section_id": "2200d6eb-db5a-48d9-bcfe-8e6213e48872"
        },
        "id": "SzvnQQK1MdpyIKm9dkeW"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "timestamp": "2025-08-24 11:58:28.000",
        "data": {
            "structured_type": "unstructured",
            "detail_level": "medium",
            "section_id": "2200d6eb-db5a-48d9-bcfe-8e6213e48872"
        },
        "id": "VuHctu6YuOsXxrdqAecy"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "timestamp": "2025-08-24 11:58:28.000",
        "data": {
            "structured_type": "unstructured",
            "detail_level": "medium",
            "section_id": "2200d6eb-db5a-48d9-bcfe-8e6213e48872"
        },
        "id": "YbF6gA2o5yrC4KgXPEOf"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "timestamp": "2025-08-24 11:58:28.000",
        "data": {
            "structured_type": "unstructured",
            "detail_level": "medium",
            "mapping_index": 2,
            "section_id": "2200d6eb-db5a-48d9-bcfe-8e6213e48872"
        },
        "id": "bGwGFljNx5wjjbYovJX4"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "timestamp": "2025-08-24 11:58:28.000",
        "data": {
            "structured_type": "unstructured",
            "detail_level": "medium",
            "section_id": "2200d6eb-db5a-48d9-bcfe-8e6213e48872"
        },
        "id": "k9Nj4SABG4ssEojWmnHX"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "timestamp": "2025-08-24 11:58:28.000",
        "data": {
            "structured_type": "unstructured",
            "detail_level": "medium",
            "section_id": "2200d6eb-db5a-48d9-bcfe-8e6213e48872"
        },
        "id": "lrpEudfRZYv5zj5TWy67"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "timestamp": "2025-08-24 11:58:29.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "medium",
            "mapping_index": 0,
            "section_id": "2200d6eb-db5a-48d9-bcfe-8e6213e48872"
        },
        "id": "3UBf6pxfqKumOlIAFTLr"
    },
    {
        "source": "frontend",
        "event": "change_summary_level",
        "timestamp": "2025-08-24 11:58:29.000",
        "data": {
            "before_structured": "unstructured",
            "before_detail_level": "medium",
            "after_structured": "structured",
            "after_detail_level": "medium",
            "section_id": "2200d6eb-db5a-48d9-bcfe-8e6213e48872"
        },
        "id": "iOQlDEMhzpAVtdZJjCZm"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "timestamp": "2025-08-24 11:58:30.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "medium",
            "section_id": "2200d6eb-db5a-48d9-bcfe-8e6213e48872"
        },
        "id": "9RzJgQREEGX8v8AjAcz2"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "timestamp": "2025-08-24 11:58:30.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "medium",
            "mapping_index": 0,
            "section_id": "2200d6eb-db5a-48d9-bcfe-8e6213e48872"
        },
        "id": "FrWX7spaHY4NER2fMXfb"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "timestamp": "2025-08-24 11:58:30.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "medium",
            "section_id": "2200d6eb-db5a-48d9-bcfe-8e6213e48872"
        },
        "id": "WsH7ojw421Z8cyzVyUs6"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "timestamp": "2025-08-24 11:58:30.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "medium",
            "mapping_index": 1,
            "section_id": "2200d6eb-db5a-48d9-bcfe-8e6213e48872"
        },
        "id": "czuxqPC66j2f9BOXGBLy"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "timestamp": "2025-08-24 11:58:30.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "medium",
            "section_id": "2200d6eb-db5a-48d9-bcfe-8e6213e48872"
        },
        "id": "lNGpm20ooU9gGzifvoT5"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "timestamp": "2025-08-24 11:58:31.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "medium",
            "mapping_index": 0,
            "section_id": "2200d6eb-db5a-48d9-bcfe-8e6213e48872"
        },
        "id": "3yBUtaqVAoYhmZupiMQK"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "timestamp": "2025-08-24 11:58:31.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "medium",
            "section_id": "2200d6eb-db5a-48d9-bcfe-8e6213e48872"
        },
        "id": "8XiWsDMYuNyPdIEi6fPD"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "timestamp": "2025-08-24 11:58:31.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "medium",
            "mapping_index": 2,
            "section_id": "2200d6eb-db5a-48d9-bcfe-8e6213e48872"
        },
        "id": "936zruBXkeH8Ipzs2xRD"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "timestamp": "2025-08-24 11:58:31.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "medium",
            "section_id": "2200d6eb-db5a-48d9-bcfe-8e6213e48872"
        },
        "id": "P596YmibmzVqGlnKK7T3"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "timestamp": "2025-08-24 11:58:31.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "medium",
            "mapping_index": 1,
            "section_id": "2200d6eb-db5a-48d9-bcfe-8e6213e48872"
        },
        "id": "XBNnIuj6cFuHMCygpIil"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "timestamp": "2025-08-24 11:58:32.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "medium",
            "section_id": "2200d6eb-db5a-48d9-bcfe-8e6213e48872"
        },
        "id": "CzCpSA3bJDTBsn2pnhQi"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "timestamp": "2025-08-24 11:58:32.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "medium",
            "section_id": "2200d6eb-db5a-48d9-bcfe-8e6213e48872"
        },
        "id": "E94ueZo9W9HAKvzMrzyo"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "timestamp": "2025-08-24 11:58:32.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "medium",
            "mapping_index": 3,
            "section_id": "2200d6eb-db5a-48d9-bcfe-8e6213e48872"
        },
        "id": "I9mm3Mmj97fyNRCv07Tz"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "timestamp": "2025-08-24 11:58:32.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "medium",
            "section_id": "2200d6eb-db5a-48d9-bcfe-8e6213e48872"
        },
        "id": "hZHpgZNbkWsbzDbM73m7"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "timestamp": "2025-08-24 11:58:32.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "medium",
            "mapping_index": 4,
            "section_id": "2200d6eb-db5a-48d9-bcfe-8e6213e48872"
        },
        "id": "mRNLRjZoVvqO5PJBPRxH"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "timestamp": "2025-08-24 11:58:33.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "medium",
            "mapping_index": 0,
            "section_id": "2200d6eb-db5a-48d9-bcfe-8e6213e48872"
        },
        "id": "37odTcIcw9avOiaT87M7"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "timestamp": "2025-08-24 11:58:33.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "medium",
            "section_id": "2200d6eb-db5a-48d9-bcfe-8e6213e48872"
        },
        "id": "4CCr8SWjbEeXcUK4OGGm"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "timestamp": "2025-08-24 11:58:33.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "medium",
            "mapping_index": 2,
            "section_id": "2200d6eb-db5a-48d9-bcfe-8e6213e48872"
        },
        "id": "8cyaWln5SvCnMgaSBkB7"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "timestamp": "2025-08-24 11:58:33.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "medium",
            "mapping_index": 3,
            "section_id": "2200d6eb-db5a-48d9-bcfe-8e6213e48872"
        },
        "id": "8uC0SQUba6zxlLvH2Hme"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "timestamp": "2025-08-24 11:58:33.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "medium",
            "section_id": "2200d6eb-db5a-48d9-bcfe-8e6213e48872"
        },
        "id": "Bo8cIDGkE4c585MpVIHj"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "timestamp": "2025-08-24 11:58:33.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "medium",
            "section_id": "2200d6eb-db5a-48d9-bcfe-8e6213e48872"
        },
        "id": "Jbob1zPHf6FtjrAq63Ij"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "timestamp": "2025-08-24 11:58:33.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "medium",
            "mapping_index": 1,
            "section_id": "2200d6eb-db5a-48d9-bcfe-8e6213e48872"
        },
        "id": "cqpi7m54tgFxDjzDMvbs"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "timestamp": "2025-08-24 11:58:34.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "medium",
            "section_id": "2200d6eb-db5a-48d9-bcfe-8e6213e48872"
        },
        "id": "Bc6OlOA0Y8fe3jGe2x4y"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "timestamp": "2025-08-24 11:58:34.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "medium",
            "mapping_index": 2,
            "section_id": "2200d6eb-db5a-48d9-bcfe-8e6213e48872"
        },
        "id": "IIpRr2wbRWdt3t14L1yW"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "timestamp": "2025-08-24 11:58:34.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "medium",
            "section_id": "2200d6eb-db5a-48d9-bcfe-8e6213e48872"
        },
        "id": "Lj3av6AkzFVatB24s1br"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "timestamp": "2025-08-24 11:58:34.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "medium",
            "section_id": "2200d6eb-db5a-48d9-bcfe-8e6213e48872"
        },
        "id": "WAqp61gVjOVfsUY6fszS"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "timestamp": "2025-08-24 11:58:34.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "medium",
            "mapping_index": 1,
            "section_id": "2200d6eb-db5a-48d9-bcfe-8e6213e48872"
        },
        "id": "axAyov44mfFRgVknkXtK"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "timestamp": "2025-08-24 11:58:34.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "medium",
            "mapping_index": 1,
            "section_id": "2200d6eb-db5a-48d9-bcfe-8e6213e48872"
        },
        "id": "lpbYUhBoE7vEvd3RGbXn"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "timestamp": "2025-08-24 11:58:35.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "medium",
            "section_id": "2200d6eb-db5a-48d9-bcfe-8e6213e48872"
        },
        "id": "1QvnvHAB1B8n50tya9Nv"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "timestamp": "2025-08-24 11:58:35.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "medium",
            "section_id": "2200d6eb-db5a-48d9-bcfe-8e6213e48872"
        },
        "id": "BinEISsPTfAYfTv5BUGm"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "timestamp": "2025-08-24 11:58:35.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "medium",
            "mapping_index": 3,
            "section_id": "2200d6eb-db5a-48d9-bcfe-8e6213e48872"
        },
        "id": "ffxDGyTgzHAAwQ70UnI0"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "timestamp": "2025-08-24 11:58:35.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "medium",
            "mapping_index": 2,
            "section_id": "2200d6eb-db5a-48d9-bcfe-8e6213e48872"
        },
        "id": "qalPNMWAJ3zldpM8GLEr"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "timestamp": "2025-08-24 11:58:36.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "medium",
            "mapping_index": 4,
            "section_id": "2200d6eb-db5a-48d9-bcfe-8e6213e48872"
        },
        "id": "ImFKqnsUQUMNpR7RyP7U"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "timestamp": "2025-08-24 11:58:36.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "medium",
            "section_id": "2200d6eb-db5a-48d9-bcfe-8e6213e48872"
        },
        "id": "l1DSK8M0jlcb7SMYT3lr"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "timestamp": "2025-08-24 11:58:38.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "medium",
            "section_id": "2200d6eb-db5a-48d9-bcfe-8e6213e48872"
        },
        "id": "0XaRKonJodDyNQPjtYtg"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "timestamp": "2025-08-24 11:58:38.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "medium",
            "mapping_index": 1,
            "section_id": "2200d6eb-db5a-48d9-bcfe-8e6213e48872"
        },
        "id": "2YbrICeYqz6g1j1fCCsT"
    },
    {
        "source": "frontend",
        "event": "change_summary_level",
        "timestamp": "2025-08-24 11:58:38.000",
        "data": {
            "before_structured": "structured",
            "before_detail_level": "medium",
            "after_structured": "structured",
            "after_detail_level": "high",
            "section_id": "2200d6eb-db5a-48d9-bcfe-8e6213e48872"
        },
        "id": "DISAOENs8B4B6cqNmJYE"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "timestamp": "2025-08-24 11:58:38.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "medium",
            "section_id": "2200d6eb-db5a-48d9-bcfe-8e6213e48872"
        },
        "id": "LCJWSxIYTZDSSGaZrpPk"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "timestamp": "2025-08-24 11:58:38.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "medium",
            "mapping_index": 3,
            "section_id": "2200d6eb-db5a-48d9-bcfe-8e6213e48872"
        },
        "id": "LSGnHNa01lE4XfUEPHXL"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "timestamp": "2025-08-24 11:58:38.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "medium",
            "mapping_index": 0,
            "section_id": "2200d6eb-db5a-48d9-bcfe-8e6213e48872"
        },
        "id": "MfY6Uekrayd5xsB1zHwx"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "timestamp": "2025-08-24 11:58:38.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "medium",
            "section_id": "2200d6eb-db5a-48d9-bcfe-8e6213e48872"
        },
        "id": "R8B1jrWZSQg9OK17B8GS"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "timestamp": "2025-08-24 11:58:38.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "medium",
            "mapping_index": 2,
            "section_id": "2200d6eb-db5a-48d9-bcfe-8e6213e48872"
        },
        "id": "Wcl7TkM4D6ftdlkNgEeP"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "timestamp": "2025-08-24 11:58:38.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "medium",
            "section_id": "2200d6eb-db5a-48d9-bcfe-8e6213e48872"
        },
        "id": "ddBHeAmYplrKAa2GzGXF"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "timestamp": "2025-08-24 11:58:38.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "medium",
            "section_id": "2200d6eb-db5a-48d9-bcfe-8e6213e48872"
        },
        "id": "vBCFjDRfA17OFz6vXIxy"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "timestamp": "2025-08-24 11:58:39.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "high",
            "mapping_index": 0,
            "section_id": "2200d6eb-db5a-48d9-bcfe-8e6213e48872"
        },
        "id": "B6ti7MBJ41EM6NhH86Rs"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "timestamp": "2025-08-24 11:58:40.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "high",
            "mapping_index": 2,
            "section_id": "2200d6eb-db5a-48d9-bcfe-8e6213e48872"
        },
        "id": "4E4nM7LRXbeeWmnmCd63"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "timestamp": "2025-08-24 11:58:40.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "high",
            "section_id": "2200d6eb-db5a-48d9-bcfe-8e6213e48872"
        },
        "id": "IwYC4JpnrR9w6YoCo74D"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "timestamp": "2025-08-24 11:58:40.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "high",
            "section_id": "2200d6eb-db5a-48d9-bcfe-8e6213e48872"
        },
        "id": "RbjITJVM63P6Q89zvyGp"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "timestamp": "2025-08-24 11:58:40.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "high",
            "mapping_index": 1,
            "section_id": "2200d6eb-db5a-48d9-bcfe-8e6213e48872"
        },
        "id": "icoLz2A0wbFe9bAKGmKY"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "timestamp": "2025-08-24 11:58:41.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "high",
            "section_id": "2200d6eb-db5a-48d9-bcfe-8e6213e48872"
        },
        "id": "BfudACZN2ShgdG06WFVz"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "timestamp": "2025-08-24 11:58:41.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "high",
            "mapping_index": 2,
            "section_id": "2200d6eb-db5a-48d9-bcfe-8e6213e48872"
        },
        "id": "RJXcmvCwo6lL9snWAPf0"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "timestamp": "2025-08-24 11:58:41.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "high",
            "mapping_index": 1,
            "section_id": "2200d6eb-db5a-48d9-bcfe-8e6213e48872"
        },
        "id": "uZmwyy1mbVZeqRoZ82mV"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "timestamp": "2025-08-24 11:58:41.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "high",
            "section_id": "2200d6eb-db5a-48d9-bcfe-8e6213e48872"
        },
        "id": "zDnsHPTfnBqb9XSguKyu"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "timestamp": "2025-08-24 11:58:42.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "high",
            "section_id": "2200d6eb-db5a-48d9-bcfe-8e6213e48872"
        },
        "id": "1usTemuAcwCID6VH3c24"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "timestamp": "2025-08-24 11:58:42.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "high",
            "mapping_index": 3,
            "section_id": "2200d6eb-db5a-48d9-bcfe-8e6213e48872"
        },
        "id": "HTE7em93zcnMZfVFBzCm"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "timestamp": "2025-08-24 11:58:42.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "high",
            "section_id": "2200d6eb-db5a-48d9-bcfe-8e6213e48872"
        },
        "id": "PNt5ADeZU8g9LuaTVTfV"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "timestamp": "2025-08-24 11:58:42.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "high",
            "mapping_index": 4,
            "section_id": "2200d6eb-db5a-48d9-bcfe-8e6213e48872"
        },
        "id": "WSe9XFbblbspI3yoAhl5"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "timestamp": "2025-08-24 11:58:43.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "high",
            "section_id": "2200d6eb-db5a-48d9-bcfe-8e6213e48872"
        },
        "id": "LDwGxMUaVpxRlXzhpAM6"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "timestamp": "2025-08-24 11:58:43.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "high",
            "section_id": "2200d6eb-db5a-48d9-bcfe-8e6213e48872"
        },
        "id": "R6DpUWflErB7E7nUSTZk"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "timestamp": "2025-08-24 11:58:43.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "high",
            "section_id": "2200d6eb-db5a-48d9-bcfe-8e6213e48872"
        },
        "id": "UYFNGaNn4FKTaiyVwuLh"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "timestamp": "2025-08-24 11:58:43.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "high",
            "mapping_index": 7,
            "section_id": "2200d6eb-db5a-48d9-bcfe-8e6213e48872"
        },
        "id": "fjCfzxtmXa3hmal8EIeE"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "timestamp": "2025-08-24 11:58:43.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "high",
            "mapping_index": 8,
            "section_id": "2200d6eb-db5a-48d9-bcfe-8e6213e48872"
        },
        "id": "hu1glWy3lSdSZxAO6uyd"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "timestamp": "2025-08-24 11:58:43.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "high",
            "mapping_index": 6,
            "section_id": "2200d6eb-db5a-48d9-bcfe-8e6213e48872"
        },
        "id": "nrEZ7UzdsDQKY4JFbZIc"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "timestamp": "2025-08-24 11:58:43.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "high",
            "mapping_index": 5,
            "section_id": "2200d6eb-db5a-48d9-bcfe-8e6213e48872"
        },
        "id": "oO5xXt437cRwiK5gMLT6"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "timestamp": "2025-08-24 11:58:43.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "high",
            "section_id": "2200d6eb-db5a-48d9-bcfe-8e6213e48872"
        },
        "id": "ssZabMpihzT6Ac8TmbXk"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "timestamp": "2025-08-24 11:58:44.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "high",
            "section_id": "2200d6eb-db5a-48d9-bcfe-8e6213e48872"
        },
        "id": "3vH5ruYjk5I9wIMNC6OL"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "timestamp": "2025-08-24 11:58:44.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "high",
            "mapping_index": 6,
            "section_id": "2200d6eb-db5a-48d9-bcfe-8e6213e48872"
        },
        "id": "EGqgm4MU3U26IK6Vd1rm"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "timestamp": "2025-08-24 11:58:44.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "high",
            "mapping_index": 4,
            "section_id": "2200d6eb-db5a-48d9-bcfe-8e6213e48872"
        },
        "id": "IsiBkIeywRAmKmKvh1O3"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "timestamp": "2025-08-24 11:58:44.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "high",
            "section_id": "2200d6eb-db5a-48d9-bcfe-8e6213e48872"
        },
        "id": "KfqAXtoSxJ6Fav4wIupj"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "timestamp": "2025-08-24 11:58:44.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "high",
            "section_id": "2200d6eb-db5a-48d9-bcfe-8e6213e48872"
        },
        "id": "RHsrnO81zBYEMdw1nvb7"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "timestamp": "2025-08-24 11:58:44.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "high",
            "mapping_index": 2,
            "section_id": "2200d6eb-db5a-48d9-bcfe-8e6213e48872"
        },
        "id": "TlXSN69G22Ni2XCWyxkg"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "timestamp": "2025-08-24 11:58:44.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "high",
            "mapping_index": 0,
            "section_id": "2200d6eb-db5a-48d9-bcfe-8e6213e48872"
        },
        "id": "UWswJlKh1CrlrJaYek1J"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "timestamp": "2025-08-24 11:58:44.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "high",
            "section_id": "2200d6eb-db5a-48d9-bcfe-8e6213e48872"
        },
        "id": "Ut6r66di6nyuzDH85CFD"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "timestamp": "2025-08-24 11:58:44.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "high",
            "section_id": "2200d6eb-db5a-48d9-bcfe-8e6213e48872"
        },
        "id": "ggYyfTmPj7mv619JX3ie"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "timestamp": "2025-08-24 11:58:44.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "high",
            "section_id": "2200d6eb-db5a-48d9-bcfe-8e6213e48872"
        },
        "id": "i573Vcv6fWFMGbmixe98"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "timestamp": "2025-08-24 11:58:44.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "high",
            "mapping_index": 5,
            "section_id": "2200d6eb-db5a-48d9-bcfe-8e6213e48872"
        },
        "id": "lOR2P7LrWHbmN0WPPPFK"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "timestamp": "2025-08-24 11:58:44.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "high",
            "mapping_index": 7,
            "section_id": "2200d6eb-db5a-48d9-bcfe-8e6213e48872"
        },
        "id": "loHvOKShXurA6BlMJCOn"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "timestamp": "2025-08-24 11:58:44.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "high",
            "section_id": "2200d6eb-db5a-48d9-bcfe-8e6213e48872"
        },
        "id": "ok8w5R2Y6Vzcj6P30M6H"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "timestamp": "2025-08-24 11:58:44.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "high",
            "mapping_index": 1,
            "section_id": "2200d6eb-db5a-48d9-bcfe-8e6213e48872"
        },
        "id": "p0C0NTpL1f8SAb9aUqmy"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "timestamp": "2025-08-24 11:58:44.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "high",
            "section_id": "2200d6eb-db5a-48d9-bcfe-8e6213e48872"
        },
        "id": "swjYSqvPNixyHJZryOPv"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "timestamp": "2025-08-24 11:58:44.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "high",
            "mapping_index": 3,
            "section_id": "2200d6eb-db5a-48d9-bcfe-8e6213e48872"
        },
        "id": "tDp4J0jTQizCLPXUSH5Y"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "timestamp": "2025-08-24 11:58:44.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "high",
            "section_id": "2200d6eb-db5a-48d9-bcfe-8e6213e48872"
        },
        "id": "wfrljA7GPpp678T2ApLd"
    },
    {
        "source": "frontend",
        "event": "change_summary_level",
        "timestamp": "2025-08-24 11:58:45.000",
        "data": {
            "before_structured": "structured",
            "before_detail_level": "high",
            "after_structured": "structured",
            "after_detail_level": "medium",
            "section_id": "2200d6eb-db5a-48d9-bcfe-8e6213e48872"
        },
        "id": "4Pr6Nehdd5pzV5QDi8fX"
    },
    {
        "source": "frontend",
        "event": "change_summary_level",
        "timestamp": "2025-08-24 11:58:45.000",
        "data": {
            "before_structured": "structured",
            "before_detail_level": "medium",
            "after_structured": "structured",
            "after_detail_level": "low",
            "section_id": "2200d6eb-db5a-48d9-bcfe-8e6213e48872"
        },
        "id": "R63sgwpZ7KiyQnfzMFKd"
    },
    {
        "source": "frontend",
        "event": "change_summary_level",
        "timestamp": "2025-08-24 11:58:47.000",
        "data": {
            "before_structured": "structured",
            "before_detail_level": "low",
            "after_structured": "structured",
            "after_detail_level": "medium",
            "section_id": "2200d6eb-db5a-48d9-bcfe-8e6213e48872"
        },
        "id": "nY2kjei8RoZ9TNoGW7SX"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "timestamp": "2025-08-24 11:58:48.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "medium",
            "mapping_index": 0,
            "section_id": "2200d6eb-db5a-48d9-bcfe-8e6213e48872"
        },
        "id": "cQ4EFaLrvhWwY5QTouek"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "timestamp": "2025-08-24 11:58:49.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "medium",
            "mapping_index": 1,
            "section_id": "2200d6eb-db5a-48d9-bcfe-8e6213e48872"
        },
        "id": "4W1nCnW16PUFUMr0Ec4I"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "timestamp": "2025-08-24 11:58:49.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "medium",
            "mapping_index": 3,
            "section_id": "2200d6eb-db5a-48d9-bcfe-8e6213e48872"
        },
        "id": "6sPSGJAWswRNkuigaCKp"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "timestamp": "2025-08-24 11:58:49.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "medium",
            "mapping_index": 2,
            "section_id": "2200d6eb-db5a-48d9-bcfe-8e6213e48872"
        },
        "id": "7fNifHl49kfFEN8dthtI"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "timestamp": "2025-08-24 11:58:49.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "medium",
            "mapping_index": 2,
            "section_id": "2200d6eb-db5a-48d9-bcfe-8e6213e48872"
        },
        "id": "C7U19bPSDR9zLzucA4X7"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "timestamp": "2025-08-24 11:58:49.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "medium",
            "section_id": "2200d6eb-db5a-48d9-bcfe-8e6213e48872"
        },
        "id": "FSxGHqh3pkz1dNrHRnre"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "timestamp": "2025-08-24 11:58:49.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "medium",
            "section_id": "2200d6eb-db5a-48d9-bcfe-8e6213e48872"
        },
        "id": "KnWYNfkmdlxob0X2LrcV"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "timestamp": "2025-08-24 11:58:49.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "medium",
            "section_id": "2200d6eb-db5a-48d9-bcfe-8e6213e48872"
        },
        "id": "m1KKaEOR7xRsKtkL2aP8"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "timestamp": "2025-08-24 11:58:49.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "medium",
            "section_id": "2200d6eb-db5a-48d9-bcfe-8e6213e48872"
        },
        "id": "wlalifGGRsCQO3KtcA6N"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "timestamp": "2025-08-24 11:58:50.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "medium",
            "section_id": "2200d6eb-db5a-48d9-bcfe-8e6213e48872"
        },
        "id": "00LoXsnRP7P9ecpWBBP7"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "timestamp": "2025-08-24 11:58:50.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "medium",
            "mapping_index": 3,
            "section_id": "2200d6eb-db5a-48d9-bcfe-8e6213e48872"
        },
        "id": "T7nrbRevrguMKVeWY69k"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "timestamp": "2025-08-24 11:58:50.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "medium",
            "section_id": "2200d6eb-db5a-48d9-bcfe-8e6213e48872"
        },
        "id": "iYPCNzqW2TnpQBbkXA28"
    },
    {
        "source": "frontend",
        "event": "click_edit_in_prompt",
        "timestamp": "2025-08-24 11:58:51.000",
        "data": {
            "detail_level": "medium",
            "structured": "structured",
            "summary": "• Calculates prediction error as the difference between predicted and true ranks\n• Filters data for the specified year and sorts players by true rank\n• Plots a bar chart of prediction errors for each player\n  ◦ Uses player names on the x-axis and error on the y-axis\n• Saves the plot as a PNG file named for the year",
            "section_id": "2200d6eb-db5a-48d9-bcfe-8e6213e48872"
        },
        "id": "NRsKpBXYNe8q68JVhDUW"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "timestamp": "2025-08-24 11:59:14.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "medium",
            "section_id": "2200d6eb-db5a-48d9-bcfe-8e6213e48872"
        },
        "id": "Mt9EphrMFJ437wbcYUsW"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "timestamp": "2025-08-24 11:59:14.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "medium",
            "mapping_index": 1,
            "section_id": "2200d6eb-db5a-48d9-bcfe-8e6213e48872"
        },
        "id": "eJHapq9Nt9ntF23w331H"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "timestamp": "2025-08-24 11:59:14.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "medium",
            "section_id": "2200d6eb-db5a-48d9-bcfe-8e6213e48872"
        },
        "id": "i6ANoKTYxEMvoYaqDn8l"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "timestamp": "2025-08-24 11:59:14.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "medium",
            "mapping_index": 4,
            "section_id": "2200d6eb-db5a-48d9-bcfe-8e6213e48872"
        },
        "id": "vR8t6kNBgsoIEZQKiwvu"
    },
    {
        "source": "frontend",
        "event": "apply_instruction_summary",
        "timestamp": "2025-08-24 11:59:21.000",
        "data": {
            "detail_level": "medium",
            "structured": "structured",
            "instruction": "Plot a grouped bar chart using (color palette coolwarm)",
            "original_summary": "• Calculates prediction error as the difference between predicted and true ranks\n• Filters data for the specified year and sorts players by true rank\n• Plots a bar chart of prediction errors for each player\n  ◦ Uses player names on the x-axis and error on the y-axis\n• Saves the plot as a PNG file named for the year",
            "section_id": "2200d6eb-db5a-48d9-bcfe-8e6213e48872"
        },
        "id": "lEhRAaoq8V93TArwVD0I"
    },
    {
        "source": "backend",
        "event": "apply_instruction_summary",
        "timestamp": "2025-08-24 11:59:22.000",
        "data": {
            "original_code": "def plot_ranking_predictions(df, year):\n    \"\"\"\n    Plot prediction error for a specific year.\n\n    Args:\n        df: DataFrame containing prediction results\n        year: Year to plot prediction errors for\n    \"\"\"\n    df[\"RankError\"] = df[\"PredictedRank\"] - df[\"Rank\"]\n    year_df = df[df[\"Year\"] == year].copy()\n    year_df.sort_values(\"Rank\", inplace=True)\n\n    plt.figure(figsize=(12, 6))\n    sns.barplot(x=\"Name\", y=\"RankError\", data=year_df, hue=\"Name\", palette=\"coolwarm\")\n    plt.axhline(0, color=\"black\", linestyle=\"--\")\n    plt.xticks(rotation=45, ha=\"right\")\n    plt.ylabel(\"Predicted Rank - True Rank\")\n    plt.title(f\"MVP Ranking Predictions ({year})\")\n    plt.tight_layout()\n    plt.savefig(f\"data/ranking_predictions_{year}.png\")",
            "updated_summary": "• Calculates prediction error as the difference between predicted and true ranks  \n• Filters data for the specified year and sorts players by true rank  \n• Plots a grouped bar chart of prediction errors for each player using the \"coolwarm\" color palette  \n  ◦ Uses player names on the x-axis and error on the y-axis  \n• Saves the plot as a PNG file named for the year",
            "instruction": "Plot a grouped bar chart using (color palette coolwarm)",
            "original_summary": "• Calculates prediction error as the difference between predicted and true ranks\n• Filters data for the specified year and sorts players by true rank\n• Plots a bar chart of prediction errors for each player\n  ◦ Uses player names on the x-axis and error on the y-axis\n• Saves the plot as a PNG file named for the year"
        },
        "id": "TUM0LrREEj8CUJeMud17"
    },
    {
        "source": "frontend",
        "event": "commit_modified_summary",
        "timestamp": "2025-08-24 11:59:29.000",
        "data": {
            "detail_level": "medium",
            "structured": "structured",
            "edited_summary": "• Calculates prediction error as the difference between predicted and true ranks  \n• Filters data for the specified year and sorts players by true rank  \n• Plots a grouped bar chart of prediction errors for each player using the \"coolwarm\" color palette  \n  ◦ Uses player names on the x-axis and error on the y-axis  \n• Saves the plot as a PNG file named for the year",
            "original_summary": "• Calculates prediction error as the difference between predicted and true ranks\n• Filters data for the specified year and sorts players by true rank\n• Plots a bar chart of prediction errors for each player\n  ◦ Uses player names on the x-axis and error on the y-axis\n• Saves the plot as a PNG file named for the year",
            "section_id": "2200d6eb-db5a-48d9-bcfe-8e6213e48872"
        },
        "id": "kRAfaWphlHxXFTSF46cj"
    },
    {
        "source": "backend",
        "event": "modify_summary_mediation",
        "timestamp": "2025-08-24 11:59:31.000",
        "data": {
            "original_code": "def plot_ranking_predictions(df, year):\n    \"\"\"\n    Plot prediction error for a specific year.\n\n    Args:\n        df: DataFrame containing prediction results\n        year: Year to plot prediction errors for\n    \"\"\"\n    df[\"RankError\"] = df[\"PredictedRank\"] - df[\"Rank\"]\n    year_df = df[df[\"Year\"] == year].copy()\n    year_df.sort_values(\"Rank\", inplace=True)\n\n    plt.figure(figsize=(12, 6))\n    sns.barplot(x=\"Name\", y=\"RankError\", data=year_df, hue=\"Name\", palette=\"coolwarm\")\n    plt.axhline(0, color=\"black\", linestyle=\"--\")\n    plt.xticks(rotation=45, ha=\"right\")\n    plt.ylabel(\"Predicted Rank - True Rank\")\n    plt.title(f\"MVP Ranking Predictions ({year})\")\n    plt.tight_layout()\n    plt.savefig(f\"data/ranking_predictions_{year}.png\")",
            "detail_level": "medium",
            "edited_summary": "• Calculates prediction error as the difference between predicted and true ranks  \n• Filters data for the specified year and sorts players by true rank  \n• Plots a grouped bar chart of prediction errors for each player using the \"coolwarm\" color palette  \n  ◦ Uses player names on the x-axis and error on the y-axis  \n• Saves the plot as a PNG file named for the year",
            "original_summary": "• Calculates prediction error as the difference between predicted and true ranks\n• Filters data for the specified year and sorts players by true rank\n• Plots a bar chart of prediction errors for each player\n  ◦ Uses player names on the x-axis and error on the y-axis\n• Saves the plot as a PNG file named for the year",
            "updated_code": "def plot_ranking_predictions(df, year):\n    \"\"\"\n    Plot prediction error for a specific year.\n\n    Args:\n        df: DataFrame containing prediction results\n        year: Year to plot prediction errors for\n    \"\"\"\n    df[\"RankError\"] = df[\"PredictedRank\"] - df[\"Rank\"]\n    year_df = df[df[\"Year\"] == year].copy()\n    year_df.sort_values(\"Rank\", inplace=True)\n\n    plt.figure(figsize=(12, 6))\n    sns.barplot(x=\"Name\", y=\"RankError\", data=year_df, hue=\"Name\", palette=\"coolwarm\", dodge=True)\n    plt.axhline(0, color=\"black\", linestyle=\"--\")\n    plt.xticks(rotation=45, ha=\"right\")\n    plt.ylabel(\"Predicted Rank - True Rank\")\n    plt.title(f\"MVP Ranking Predictions ({year})\")\n    plt.tight_layout()\n    plt.savefig(f\"data/ranking_predictions_{year}.png\")",
            "structured_type": "structured"
        },
        "id": "SiOxOwtYcBBpMgrgxM0f"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "timestamp": "2025-08-24 11:59:36.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "medium",
            "mapping_index": 4,
            "section_id": "2200d6eb-db5a-48d9-bcfe-8e6213e48872"
        },
        "id": "t2K1nvo1MKiwBYs8IApq"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "timestamp": "2025-08-24 11:59:37.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "medium",
            "section_id": "2200d6eb-db5a-48d9-bcfe-8e6213e48872"
        },
        "id": "qzYQcszRXV7BgWtJNeKK"
    },
    {
        "source": "backend",
        "event": "summarize_modified_code",
        "timestamp": "2025-08-24 11:59:41.000",
        "data": {
            "original_code": "def plot_ranking_predictions(df, year):\n    \"\"\"\n    Plot prediction error for a specific year.\n\n    Args:\n        df: DataFrame containing prediction results\n        year: Year to plot prediction errors for\n    \"\"\"\n    df[\"RankError\"] = df[\"PredictedRank\"] - df[\"Rank\"]\n    year_df = df[df[\"Year\"] == year].copy()\n    year_df.sort_values(\"Rank\", inplace=True)\n\n    plt.figure(figsize=(12, 6))\n    sns.barplot(x=\"Name\", y=\"RankError\", data=year_df, hue=\"Name\", palette=\"coolwarm\", dodge=True)\n    plt.axhline(0, color=\"black\", linestyle=\"--\")\n    plt.xticks(rotation=45, ha=\"right\")\n    plt.ylabel(\"Predicted Rank - True Rank\")\n    plt.title(f\"MVP Ranking Predictions ({year})\")\n    plt.tight_layout()\n    plt.savefig(f\"data/ranking_predictions_{year}.png\")",
            "new_summary": {
                "medium_structured": "• Calculates prediction error as the difference between predicted and true ranks\n• Filters data for the specified year and sorts players by true rank\n• Plots a bar chart of prediction errors for each player\n  ◦ Uses player names on the x-axis and error on the y-axis\n• Saves the plot as a PNG file named for the year (No changes from the previous version)",
                "low_unstructured": "This function plots the prediction error for player rankings in a specified year. (No changes were made to the function.)",
                "high_structured": "• Computes the prediction error by subtracting the true rank from the predicted rank for each player\n• Filters the DataFrame to include only records from the specified year\n  ◦ Makes a copy and sorts players by their true rank for clear visualization\n• Creates a bar plot using Seaborn:\n  ◦ Player names are shown on the x-axis, prediction errors on the y-axis\n  ◦ Each player's bar is colored distinctly using the 'coolwarm' palette\n• Adds a horizontal dashed line at y=0 to indicate perfect prediction\n• Rotates x-axis labels for readability and sets axis labels and plot title\n• Adjusts the layout to prevent overlap and saves the plot as a PNG file named with the target year (No changes from the previous version)",
                "low_structured": "• Plots prediction error for a given year\n• Uses player ranking data\n• Saves the plot as an image (No changes from the previous version)",
                "high_unstructured": "The plot_ranking_predictions function generates a bar plot to visualize the prediction error (PredictedRank minus actual Rank) for each player in a specified year. It first computes the rank error, filters the DataFrame for the given year, and sorts players by their true rank. The function then creates a bar plot with player names on the x-axis and prediction error on the y-axis, adds a horizontal reference line at zero, and customizes the plot's appearance (such as rotating x-axis labels and setting the title). Finally, it saves the plot as a PNG file in the data directory, named according to the year. (No changes from the previous version.)",
                "medium_unstructured": "The plot_ranking_predictions function visualizes the difference between predicted and actual player ranks for a specified year. It creates a bar plot showing these errors for each player and saves the resulting figure as a PNG file. The plot helps assess ranking prediction performance for that year. (No changes from the previous version.)",
                "title": "plot_ranking_predictions Function Summary"
            },
            "old_summary": {
                "medium_structured": "• Calculates prediction error as the difference between predicted and true ranks\n• Filters data for the specified year and sorts players by true rank\n• Plots a bar chart of prediction errors for each player\n  ◦ Uses player names on the x-axis and error on the y-axis\n• Saves the plot as a PNG file named for the year",
                "low_unstructured": "This function plots the prediction error for player rankings in a specified year.",
                "high_structured": "• Computes the prediction error by subtracting the true rank from the predicted rank for each player\n• Filters the DataFrame to include only records from the specified year\n  ◦ Makes a copy and sorts players by their true rank for clear visualization\n• Creates a bar plot using Seaborn:\n  ◦ Player names are shown on the x-axis, prediction errors on the y-axis\n  ◦ Each player's bar is colored distinctly using the 'coolwarm' palette\n• Adds a horizontal dashed line at y=0 to indicate perfect prediction\n• Rotates x-axis labels for readability and sets axis labels and plot title\n• Adjusts the layout to prevent overlap and saves the plot as a PNG file named with the target year",
                "low_structured": "• Plots prediction error for a given year\n• Uses player ranking data\n• Saves the plot as an image",
                "high_unstructured": "The plot_ranking_predictions function generates a bar plot to visualize the prediction error (PredictedRank minus actual Rank) for each player in a specified year. It first computes the rank error, filters the DataFrame for the given year, and sorts players by their true rank. The function then creates a bar plot with player names on the x-axis and prediction error on the y-axis, adds a horizontal reference line at zero, and customizes the plot's appearance (such as rotating x-axis labels and setting the title). Finally, it saves the plot as a PNG file in the data directory, named according to the year.",
                "medium_unstructured": "The plot_ranking_predictions function visualizes the difference between predicted and actual player ranks for a specified year. It creates a bar plot showing these errors for each player and saves the resulting figure as a PNG file. The plot helps assess ranking prediction performance for that year.",
                "title": "plot_ranking_predictions Function Summary"
            },
            "new_code": "def plot_ranking_predictions(df, year):\n    \"\"\"\n    Plot prediction error for a specific year.\n\n    Args:\n        df: DataFrame containing prediction results\n        year: Year to plot prediction errors for\n    \"\"\"\n    df[\"RankError\"] = df[\"PredictedRank\"] - df[\"Rank\"]\n    year_df = df[df[\"Year\"] == year].copy()\n    year_df.sort_values(\"Rank\", inplace=True)\n\n    plt.figure(figsize=(12, 6))\n    sns.barplot(x=\"Name\", y=\"RankError\", data=year_df, hue=\"Name\", palette=\"coolwarm\", dodge=True)\n    plt.axhline(0, color=\"black\", linestyle=\"--\")\n    plt.xticks(rotation=45, ha=\"right\")\n    plt.ylabel(\"Predicted Rank - True Rank\")\n    plt.title(f\"MVP Ranking Predictions ({year})\")\n    plt.tight_layout()\n    plt.savefig(f\"data/ranking_predictions_{year}.png\")"
        },
        "id": "jPbx3y5bkXhEbXBLqCwF"
    },
    {
        "source": "backend",
        "event": "map_summary_code",
        "timestamp": "2025-08-24 11:59:43.000",
        "data": {
            "summary": "This function plots the prediction error for player rankings in a specified year. (No changes were made to the function.)",
            "code": "52: def plot_ranking_predictions(df, year):\n53:     \"\"\"\n54:     Plot prediction error for a specific year.\n55: \n56:     Args:\n57:         df: DataFrame containing prediction results\n58:         year: Year to plot prediction errors for\n59:     \"\"\"\n60:     df[\"RankError\"] = df[\"PredictedRank\"] - df[\"Rank\"]\n61:     year_df = df[df[\"Year\"] == year].copy()\n62:     year_df.sort_values(\"Rank\", inplace=True)\n63: \n64:     plt.figure(figsize=(12, 6))\n65:     sns.barplot(x=\"Name\", y=\"RankError\", data=year_df, hue=\"Name\", palette=\"coolwarm\", dodge=True)\n66:     plt.axhline(0, color=\"black\", linestyle=\"--\")\n67:     plt.xticks(rotation=45, ha=\"right\")\n68:     plt.ylabel(\"Predicted Rank - True Rank\")\n69:     plt.title(f\"MVP Ranking Predictions ({year})\")\n70:     plt.tight_layout()\n71:     plt.savefig(f\"data/ranking_predictions_{year}.png\")",
            "mapping": [
                {
                    "summaryComponent": "This function",
                    "codeSegments": [
                        {
                            "code": "def plot_ranking_predictions(df, year):",
                            "line": 52
                        }
                    ]
                },
                {
                    "summaryComponent": "plots the prediction error",
                    "codeSegments": [
                        {
                            "code": "plt.figure(figsize=(12, 6))",
                            "line": 64
                        },
                        {
                            "code": "sns.barplot(x=\"Name\", y=\"RankError\", data=year_df, hue=\"Name\", palette=\"coolwarm\", dodge=True)",
                            "line": 65
                        }
                    ]
                },
                {
                    "summaryComponent": "for player rankings",
                    "codeSegments": [
                        {
                            "code": "df[\"RankError\"] = df[\"PredictedRank\"] - df[\"Rank\"]",
                            "line": 60
                        },
                        {
                            "code": "year_df.sort_values(\"Rank\", inplace=True)",
                            "line": 62
                        }
                    ]
                },
                {
                    "summaryComponent": "in a specified year",
                    "codeSegments": [
                        {
                            "code": "year_df = df[df[\"Year\"] == year].copy()",
                            "line": 61
                        }
                    ]
                }
            ]
        },
        "id": "59Uh6T76LgsSIhRYoVpR"
    },
    {
        "source": "backend",
        "event": "map_summary_code",
        "timestamp": "2025-08-24 11:59:43.000",
        "data": {
            "summary": "The plot_ranking_predictions function visualizes the difference between predicted and actual player ranks for a specified year. It creates a bar plot showing these errors for each player and saves the resulting figure as a PNG file. The plot helps assess ranking prediction performance for that year. (No changes from the previous version.)",
            "code": "52: def plot_ranking_predictions(df, year):\n53:     \"\"\"\n54:     Plot prediction error for a specific year.\n55: \n56:     Args:\n57:         df: DataFrame containing prediction results\n58:         year: Year to plot prediction errors for\n59:     \"\"\"\n60:     df[\"RankError\"] = df[\"PredictedRank\"] - df[\"Rank\"]\n61:     year_df = df[df[\"Year\"] == year].copy()\n62:     year_df.sort_values(\"Rank\", inplace=True)\n63: \n64:     plt.figure(figsize=(12, 6))\n65:     sns.barplot(x=\"Name\", y=\"RankError\", data=year_df, hue=\"Name\", palette=\"coolwarm\", dodge=True)\n66:     plt.axhline(0, color=\"black\", linestyle=\"--\")\n67:     plt.xticks(rotation=45, ha=\"right\")\n68:     plt.ylabel(\"Predicted Rank - True Rank\")\n69:     plt.title(f\"MVP Ranking Predictions ({year})\")\n70:     plt.tight_layout()\n71:     plt.savefig(f\"data/ranking_predictions_{year}.png\")",
            "mapping": [
                {
                    "summaryComponent": "The plot_ranking_predictions function",
                    "codeSegments": [
                        {
                            "code": "def plot_ranking_predictions(df, year):",
                            "line": 52
                        }
                    ]
                },
                {
                    "summaryComponent": "visualizes the difference between predicted and actual player ranks",
                    "codeSegments": [
                        {
                            "code": "df[\"RankError\"] = df[\"PredictedRank\"] - df[\"Rank\"]",
                            "line": 60
                        }
                    ]
                },
                {
                    "summaryComponent": "for a specified year",
                    "codeSegments": [
                        {
                            "code": "year_df = df[df[\"Year\"] == year].copy()",
                            "line": 61
                        }
                    ]
                },
                {
                    "summaryComponent": "It creates a bar plot showing these errors for each player",
                    "codeSegments": [
                        {
                            "code": "sns.barplot(x=\"Name\", y=\"RankError\", data=year_df, hue=\"Name\", palette=\"coolwarm\", dodge=True)",
                            "line": 65
                        }
                    ]
                },
                {
                    "summaryComponent": "and saves the resulting figure as a PNG file",
                    "codeSegments": [
                        {
                            "code": "plt.savefig(f\"data/ranking_predictions_{year}.png\")",
                            "line": 71
                        }
                    ]
                },
                {
                    "summaryComponent": "The plot helps assess ranking prediction performance for that year",
                    "codeSegments": [
                        {
                            "code": "plt.title(f\"MVP Ranking Predictions ({year})\")",
                            "line": 69
                        }
                    ]
                }
            ]
        },
        "id": "DlimZ3a0PFk9LgLj7IZ6"
    },
    {
        "source": "backend",
        "event": "map_summary_code",
        "timestamp": "2025-08-24 11:59:43.000",
        "data": {
            "summary": "• Plots prediction error for a given year\n• Uses player ranking data\n• Saves the plot as an image (No changes from the previous version)",
            "code": "52: def plot_ranking_predictions(df, year):\n53:     \"\"\"\n54:     Plot prediction error for a specific year.\n55: \n56:     Args:\n57:         df: DataFrame containing prediction results\n58:         year: Year to plot prediction errors for\n59:     \"\"\"\n60:     df[\"RankError\"] = df[\"PredictedRank\"] - df[\"Rank\"]\n61:     year_df = df[df[\"Year\"] == year].copy()\n62:     year_df.sort_values(\"Rank\", inplace=True)\n63: \n64:     plt.figure(figsize=(12, 6))\n65:     sns.barplot(x=\"Name\", y=\"RankError\", data=year_df, hue=\"Name\", palette=\"coolwarm\", dodge=True)\n66:     plt.axhline(0, color=\"black\", linestyle=\"--\")\n67:     plt.xticks(rotation=45, ha=\"right\")\n68:     plt.ylabel(\"Predicted Rank - True Rank\")\n69:     plt.title(f\"MVP Ranking Predictions ({year})\")\n70:     plt.tight_layout()\n71:     plt.savefig(f\"data/ranking_predictions_{year}.png\")",
            "mapping": [
                {
                    "summaryComponent": "Plots prediction error for a given year",
                    "codeSegments": [
                        {
                            "code": "def plot_ranking_predictions(df, year):",
                            "line": 52
                        },
                        {
                            "code": "plt.figure(figsize=(12, 6))",
                            "line": 64
                        },
                        {
                            "code": "sns.barplot(x=\"Name\", y=\"RankError\", data=year_df, hue=\"Name\", palette=\"coolwarm\", dodge=True)",
                            "line": 65
                        },
                        {
                            "code": "plt.axhline(0, color=\"black\", linestyle=\"--\")",
                            "line": 66
                        },
                        {
                            "code": "plt.title(f\"MVP Ranking Predictions ({year})\")",
                            "line": 69
                        }
                    ]
                },
                {
                    "summaryComponent": "Uses player ranking data",
                    "codeSegments": [
                        {
                            "code": "df[\"RankError\"] = df[\"PredictedRank\"] - df[\"Rank\"]",
                            "line": 60
                        },
                        {
                            "code": "year_df = df[df[\"Year\"] == year].copy()",
                            "line": 61
                        },
                        {
                            "code": "year_df.sort_values(\"Rank\", inplace=True)",
                            "line": 62
                        }
                    ]
                },
                {
                    "summaryComponent": "Saves the plot as an image",
                    "codeSegments": [
                        {
                            "code": "plt.savefig(f\"data/ranking_predictions_{year}.png\")",
                            "line": 71
                        }
                    ]
                }
            ]
        },
        "id": "mzXbeajwd3lSc7xYSULd"
    },
    {
        "source": "backend",
        "event": "map_summary_code",
        "timestamp": "2025-08-24 11:59:43.000",
        "data": {
            "summary": "• Calculates prediction error as the difference between predicted and true ranks\n• Filters data for the specified year and sorts players by true rank\n• Plots a bar chart of prediction errors for each player\n  ◦ Uses player names on the x-axis and error on the y-axis\n• Saves the plot as a PNG file named for the year (No changes from the previous version)",
            "code": "52: def plot_ranking_predictions(df, year):\n53:     \"\"\"\n54:     Plot prediction error for a specific year.\n55: \n56:     Args:\n57:         df: DataFrame containing prediction results\n58:         year: Year to plot prediction errors for\n59:     \"\"\"\n60:     df[\"RankError\"] = df[\"PredictedRank\"] - df[\"Rank\"]\n61:     year_df = df[df[\"Year\"] == year].copy()\n62:     year_df.sort_values(\"Rank\", inplace=True)\n63: \n64:     plt.figure(figsize=(12, 6))\n65:     sns.barplot(x=\"Name\", y=\"RankError\", data=year_df, hue=\"Name\", palette=\"coolwarm\", dodge=True)\n66:     plt.axhline(0, color=\"black\", linestyle=\"--\")\n67:     plt.xticks(rotation=45, ha=\"right\")\n68:     plt.ylabel(\"Predicted Rank - True Rank\")\n69:     plt.title(f\"MVP Ranking Predictions ({year})\")\n70:     plt.tight_layout()\n71:     plt.savefig(f\"data/ranking_predictions_{year}.png\")",
            "mapping": [
                {
                    "summaryComponent": "Calculates prediction error as the difference between predicted and true ranks",
                    "codeSegments": [
                        {
                            "code": "df[\"RankError\"] = df[\"PredictedRank\"] - df[\"Rank\"]",
                            "line": 60
                        }
                    ]
                },
                {
                    "summaryComponent": "Filters data for the specified year and sorts players by true rank",
                    "codeSegments": [
                        {
                            "code": "year_df = df[df[\"Year\"] == year].copy()",
                            "line": 61
                        },
                        {
                            "code": "year_df.sort_values(\"Rank\", inplace=True)",
                            "line": 62
                        }
                    ]
                },
                {
                    "summaryComponent": "Plots a bar chart of prediction errors for each player",
                    "codeSegments": [
                        {
                            "code": "sns.barplot(x=\"Name\", y=\"RankError\", data=year_df, hue=\"Name\", palette=\"coolwarm\", dodge=True)",
                            "line": 65
                        }
                    ]
                },
                {
                    "summaryComponent": "Uses player names on the x-axis and error on the y-axis",
                    "codeSegments": [
                        {
                            "code": "x=\"Name\"",
                            "line": 65
                        },
                        {
                            "code": "y=\"RankError\"",
                            "line": 65
                        }
                    ]
                },
                {
                    "summaryComponent": "Saves the plot as a PNG file named for the year",
                    "codeSegments": [
                        {
                            "code": "plt.savefig(f\"data/ranking_predictions_{year}.png\")",
                            "line": 71
                        }
                    ]
                }
            ]
        },
        "id": "w8guljG89fdGLmuR2wfh"
    },
    {
        "source": "backend",
        "event": "map_summary_code",
        "timestamp": "2025-08-24 11:59:45.000",
        "data": {
            "summary": "• Computes the prediction error by subtracting the true rank from the predicted rank for each player\n• Filters the DataFrame to include only records from the specified year\n  ◦ Makes a copy and sorts players by their true rank for clear visualization\n• Creates a bar plot using Seaborn:\n  ◦ Player names are shown on the x-axis, prediction errors on the y-axis\n  ◦ Each player's bar is colored distinctly using the 'coolwarm' palette\n• Adds a horizontal dashed line at y=0 to indicate perfect prediction\n• Rotates x-axis labels for readability and sets axis labels and plot title\n• Adjusts the layout to prevent overlap and saves the plot as a PNG file named with the target year (No changes from the previous version)",
            "code": "52: def plot_ranking_predictions(df, year):\n53:     \"\"\"\n54:     Plot prediction error for a specific year.\n55: \n56:     Args:\n57:         df: DataFrame containing prediction results\n58:         year: Year to plot prediction errors for\n59:     \"\"\"\n60:     df[\"RankError\"] = df[\"PredictedRank\"] - df[\"Rank\"]\n61:     year_df = df[df[\"Year\"] == year].copy()\n62:     year_df.sort_values(\"Rank\", inplace=True)\n63: \n64:     plt.figure(figsize=(12, 6))\n65:     sns.barplot(x=\"Name\", y=\"RankError\", data=year_df, hue=\"Name\", palette=\"coolwarm\", dodge=True)\n66:     plt.axhline(0, color=\"black\", linestyle=\"--\")\n67:     plt.xticks(rotation=45, ha=\"right\")\n68:     plt.ylabel(\"Predicted Rank - True Rank\")\n69:     plt.title(f\"MVP Ranking Predictions ({year})\")\n70:     plt.tight_layout()\n71:     plt.savefig(f\"data/ranking_predictions_{year}.png\")",
            "mapping": [
                {
                    "summaryComponent": "Computes the prediction error by subtracting the true rank from the predicted rank for each player",
                    "codeSegments": [
                        {
                            "code": "df[\"RankError\"] = df[\"PredictedRank\"] - df[\"Rank\"]",
                            "line": 60
                        }
                    ]
                },
                {
                    "summaryComponent": "Filters the DataFrame to include only records from the specified year",
                    "codeSegments": [
                        {
                            "code": "year_df = df[df[\"Year\"] == year].copy()",
                            "line": 61
                        }
                    ]
                },
                {
                    "summaryComponent": "Makes a copy and sorts players by their true rank for clear visualization",
                    "codeSegments": [
                        {
                            "code": "year_df = df[df[\"Year\"] == year].copy()",
                            "line": 61
                        },
                        {
                            "code": "year_df.sort_values(\"Rank\", inplace=True)",
                            "line": 62
                        }
                    ]
                },
                {
                    "summaryComponent": "Creates a bar plot using Seaborn:",
                    "codeSegments": [
                        {
                            "code": "sns.barplot(x=\"Name\", y=\"RankError\", data=year_df, hue=\"Name\", palette=\"coolwarm\", dodge=True)",
                            "line": 65
                        }
                    ]
                },
                {
                    "summaryComponent": "Player names are shown on the x-axis, prediction errors on the y-axis",
                    "codeSegments": [
                        {
                            "code": "sns.barplot(x=\"Name\", y=\"RankError\", data=year_df, hue=\"Name\", palette=\"coolwarm\", dodge=True)",
                            "line": 65
                        }
                    ]
                },
                {
                    "summaryComponent": "Each player's bar is colored distinctly using the 'coolwarm' palette",
                    "codeSegments": [
                        {
                            "code": "sns.barplot(x=\"Name\", y=\"RankError\", data=year_df, hue=\"Name\", palette=\"coolwarm\", dodge=True)",
                            "line": 65
                        }
                    ]
                },
                {
                    "summaryComponent": "Adds a horizontal dashed line at y=0 to indicate perfect prediction",
                    "codeSegments": [
                        {
                            "code": "plt.axhline(0, color=\"black\", linestyle=\"--\")",
                            "line": 66
                        }
                    ]
                },
                {
                    "summaryComponent": "Rotates x-axis labels for readability and sets axis labels and plot title",
                    "codeSegments": [
                        {
                            "code": "plt.xticks(rotation=45, ha=\"right\")",
                            "line": 67
                        },
                        {
                            "code": "plt.ylabel(\"Predicted Rank - True Rank\")",
                            "line": 68
                        },
                        {
                            "code": "plt.title(f\"MVP Ranking Predictions ({year})\")",
                            "line": 69
                        }
                    ]
                },
                {
                    "summaryComponent": "Adjusts the layout to prevent overlap and saves the plot as a PNG file named with the target year",
                    "codeSegments": [
                        {
                            "code": "plt.tight_layout()",
                            "line": 70
                        },
                        {
                            "code": "plt.savefig(f\"data/ranking_predictions_{year}.png\")",
                            "line": 71
                        }
                    ]
                }
            ]
        },
        "id": "8702nBUCO83MtQZSyAVL"
    },
    {
        "source": "frontend",
        "event": "autotransit_section",
        "timestamp": "2025-08-24 11:59:45.000",
        "data": {
            "before_section_id": "2200d6eb-db5a-48d9-bcfe-8e6213e48872",
            "after_section_id": "21428fb2-d6b0-4575-8f96-b84e832bdb50"
        },
        "id": "CRtxoqI20ssNiIkfkpRZ"
    },
    {
        "source": "backend",
        "event": "map_summary_code",
        "timestamp": "2025-08-24 11:59:45.000",
        "data": {
            "summary": "The plot_ranking_predictions function generates a bar plot to visualize the prediction error (PredictedRank minus actual Rank) for each player in a specified year. It first computes the rank error, filters the DataFrame for the given year, and sorts players by their true rank. The function then creates a bar plot with player names on the x-axis and prediction error on the y-axis, adds a horizontal reference line at zero, and customizes the plot's appearance (such as rotating x-axis labels and setting the title). Finally, it saves the plot as a PNG file in the data directory, named according to the year. (No changes from the previous version.)",
            "code": "52: def plot_ranking_predictions(df, year):\n53:     \"\"\"\n54:     Plot prediction error for a specific year.\n55: \n56:     Args:\n57:         df: DataFrame containing prediction results\n58:         year: Year to plot prediction errors for\n59:     \"\"\"\n60:     df[\"RankError\"] = df[\"PredictedRank\"] - df[\"Rank\"]\n61:     year_df = df[df[\"Year\"] == year].copy()\n62:     year_df.sort_values(\"Rank\", inplace=True)\n63: \n64:     plt.figure(figsize=(12, 6))\n65:     sns.barplot(x=\"Name\", y=\"RankError\", data=year_df, hue=\"Name\", palette=\"coolwarm\", dodge=True)\n66:     plt.axhline(0, color=\"black\", linestyle=\"--\")\n67:     plt.xticks(rotation=45, ha=\"right\")\n68:     plt.ylabel(\"Predicted Rank - True Rank\")\n69:     plt.title(f\"MVP Ranking Predictions ({year})\")\n70:     plt.tight_layout()\n71:     plt.savefig(f\"data/ranking_predictions_{year}.png\")",
            "mapping": [
                {
                    "summaryComponent": "The plot_ranking_predictions function generates a bar plot to visualize the prediction error (PredictedRank minus actual Rank) for each player in a specified year.",
                    "codeSegments": [
                        {
                            "code": "def plot_ranking_predictions(df, year):",
                            "line": 52
                        },
                        {
                            "code": "plt.figure(figsize=(12, 6))",
                            "line": 64
                        },
                        {
                            "code": "sns.barplot(x=\"Name\", y=\"RankError\", data=year_df, hue=\"Name\", palette=\"coolwarm\", dodge=True)",
                            "line": 65
                        }
                    ]
                },
                {
                    "summaryComponent": "It first computes the rank error",
                    "codeSegments": [
                        {
                            "code": "df[\"RankError\"] = df[\"PredictedRank\"] - df[\"Rank\"]",
                            "line": 60
                        }
                    ]
                },
                {
                    "summaryComponent": "filters the DataFrame for the given year",
                    "codeSegments": [
                        {
                            "code": "year_df = df[df[\"Year\"] == year].copy()",
                            "line": 61
                        }
                    ]
                },
                {
                    "summaryComponent": "and sorts players by their true rank.",
                    "codeSegments": [
                        {
                            "code": "year_df.sort_values(\"Rank\", inplace=True)",
                            "line": 62
                        }
                    ]
                },
                {
                    "summaryComponent": "The function then creates a bar plot with player names on the x-axis and prediction error on the y-axis",
                    "codeSegments": [
                        {
                            "code": "sns.barplot(x=\"Name\", y=\"RankError\", data=year_df, hue=\"Name\", palette=\"coolwarm\", dodge=True)",
                            "line": 65
                        }
                    ]
                },
                {
                    "summaryComponent": "adds a horizontal reference line at zero",
                    "codeSegments": [
                        {
                            "code": "plt.axhline(0, color=\"black\", linestyle=\"--\")",
                            "line": 66
                        }
                    ]
                },
                {
                    "summaryComponent": "and customizes the plot's appearance (such as rotating x-axis labels and setting the title).",
                    "codeSegments": [
                        {
                            "code": "plt.xticks(rotation=45, ha=\"right\")",
                            "line": 67
                        },
                        {
                            "code": "plt.title(f\"MVP Ranking Predictions ({year})\")",
                            "line": 69
                        }
                    ]
                },
                {
                    "summaryComponent": "Finally, it saves the plot as a PNG file in the data directory, named according to the year.",
                    "codeSegments": [
                        {
                            "code": "plt.savefig(f\"data/ranking_predictions_{year}.png\")",
                            "line": 71
                        }
                    ]
                }
            ]
        },
        "id": "ixnVLtgbOxsq6KSySAkc"
    },
    {
        "source": "frontend",
        "event": "create_new_section",
        "timestamp": "2025-08-24 11:59:45.000",
        "data": {
            "section_data": {
                "selectedDetailLevel": "medium",
                "editPromptStructured": null,
                "createdAt": 1756065585000,
                "metadata": {
                    "originalCode": "def plot_ranking_predictions(df, year):\n    \"\"\"\n    Plot prediction error for a specific year.\n\n    Args:\n        df: DataFrame containing prediction results\n        year: Year to plot prediction errors for\n    \"\"\"\n    df[\"RankError\"] = df[\"PredictedRank\"] - df[\"Rank\"]\n    year_df = df[df[\"Year\"] == year].copy()\n    year_df.sort_values(\"Rank\", inplace=True)\n\n    plt.figure(figsize=(12, 6))\n    sns.barplot(x=\"Name\", y=\"RankError\", data=year_df, hue=\"Name\", palette=\"coolwarm\", dodge=True)\n    plt.axhline(0, color=\"black\", linestyle=\"--\")\n    plt.xticks(rotation=45, ha=\"right\")\n    plt.ylabel(\"Predicted Rank - True Rank\")\n    plt.title(f\"MVP Ranking Predictions ({year})\")\n    plt.tight_layout()\n    plt.savefig(f\"data/ranking_predictions_{year}.png\")",
                    "id": "21428fb2-d6b0-4575-8f96-b84e832bdb50",
                    "filename": "rank_model.py",
                    "fullPath": "/project/workspace/rank_model.py",
                    "offset": 1205
                },
                "summaryData": {
                    "medium_structured": "• Calculates prediction error as the difference between predicted and true ranks\n• Filters data for the specified year and sorts players by true rank\n• Plots a bar chart of prediction errors for each player\n  ◦ Uses player names on the x-axis and error on the y-axis\n• Saves the plot as a PNG file named for the year (No changes from the previous version)",
                    "low_unstructured": "This function plots the prediction error for player rankings in a specified year. (No changes were made to the function.)",
                    "high_structured": "• Computes the prediction error by subtracting the true rank from the predicted rank for each player\n• Filters the DataFrame to include only records from the specified year\n  ◦ Makes a copy and sorts players by their true rank for clear visualization\n• Creates a bar plot using Seaborn:\n  ◦ Player names are shown on the x-axis, prediction errors on the y-axis\n  ◦ Each player's bar is colored distinctly using the 'coolwarm' palette\n• Adds a horizontal dashed line at y=0 to indicate perfect prediction\n• Rotates x-axis labels for readability and sets axis labels and plot title\n• Adjusts the layout to prevent overlap and saves the plot as a PNG file named with the target year (No changes from the previous version)",
                    "low_structured": "• Plots prediction error for a given year\n• Uses player ranking data\n• Saves the plot as an image (No changes from the previous version)",
                    "high_unstructured": "The plot_ranking_predictions function generates a bar plot to visualize the prediction error (PredictedRank minus actual Rank) for each player in a specified year. It first computes the rank error, filters the DataFrame for the given year, and sorts players by their true rank. The function then creates a bar plot with player names on the x-axis and prediction error on the y-axis, adds a horizontal reference line at zero, and customizes the plot's appearance (such as rotating x-axis labels and setting the title). Finally, it saves the plot as a PNG file in the data directory, named according to the year. (No changes from the previous version.)",
                    "medium_unstructured": "The plot_ranking_predictions function visualizes the difference between predicted and actual player ranks for a specified year. It creates a bar plot showing these errors for each player and saves the resulting figure as a PNG file. The plot helps assess ranking prediction performance for that year. (No changes from the previous version.)",
                    "title": "plot_ranking_predictions Function Summary"
                },
                "selectedStructured": "unstructured",
                "summaryMappings": {
                    "medium_structured": [
                        {
                            "summaryComponent": "Calculates prediction error as the difference between predicted and true ranks",
                            "codeSegments": [
                                {
                                    "code": "df[\"RankError\"] = df[\"PredictedRank\"] - df[\"Rank\"]",
                                    "line": 60
                                }
                            ]
                        },
                        {
                            "summaryComponent": "Filters data for the specified year and sorts players by true rank",
                            "codeSegments": [
                                {
                                    "code": "year_df = df[df[\"Year\"] == year].copy()",
                                    "line": 61
                                },
                                {
                                    "code": "year_df.sort_values(\"Rank\", inplace=True)",
                                    "line": 62
                                }
                            ]
                        },
                        {
                            "summaryComponent": "Plots a bar chart of prediction errors for each player",
                            "codeSegments": [
                                {
                                    "code": "sns.barplot(x=\"Name\", y=\"RankError\", data=year_df, hue=\"Name\", palette=\"coolwarm\", dodge=True)",
                                    "line": 65
                                }
                            ]
                        },
                        {
                            "summaryComponent": "Uses player names on the x-axis and error on the y-axis",
                            "codeSegments": [
                                {
                                    "code": "x=\"Name\"",
                                    "line": 65
                                },
                                {
                                    "code": "y=\"RankError\"",
                                    "line": 65
                                }
                            ]
                        },
                        {
                            "summaryComponent": "Saves the plot as a PNG file named for the year",
                            "codeSegments": [
                                {
                                    "code": "plt.savefig(f\"data/ranking_predictions_{year}.png\")",
                                    "line": 71
                                }
                            ]
                        }
                    ],
                    "high_structured": [
                        {
                            "summaryComponent": "Computes the prediction error by subtracting the true rank from the predicted rank for each player",
                            "codeSegments": [
                                {
                                    "code": "df[\"RankError\"] = df[\"PredictedRank\"] - df[\"Rank\"]",
                                    "line": 60
                                }
                            ]
                        },
                        {
                            "summaryComponent": "Filters the DataFrame to include only records from the specified year",
                            "codeSegments": [
                                {
                                    "code": "year_df = df[df[\"Year\"] == year].copy()",
                                    "line": 61
                                }
                            ]
                        },
                        {
                            "summaryComponent": "Makes a copy and sorts players by their true rank for clear visualization",
                            "codeSegments": [
                                {
                                    "code": "year_df = df[df[\"Year\"] == year].copy()",
                                    "line": 61
                                },
                                {
                                    "code": "year_df.sort_values(\"Rank\", inplace=True)",
                                    "line": 62
                                }
                            ]
                        },
                        {
                            "summaryComponent": "Creates a bar plot using Seaborn:",
                            "codeSegments": [
                                {
                                    "code": "sns.barplot(x=\"Name\", y=\"RankError\", data=year_df, hue=\"Name\", palette=\"coolwarm\", dodge=True)",
                                    "line": 65
                                }
                            ]
                        },
                        {
                            "summaryComponent": "Player names are shown on the x-axis, prediction errors on the y-axis",
                            "codeSegments": [
                                {
                                    "code": "sns.barplot(x=\"Name\", y=\"RankError\", data=year_df, hue=\"Name\", palette=\"coolwarm\", dodge=True)",
                                    "line": 65
                                }
                            ]
                        },
                        {
                            "summaryComponent": "Each player's bar is colored distinctly using the 'coolwarm' palette",
                            "codeSegments": [
                                {
                                    "code": "sns.barplot(x=\"Name\", y=\"RankError\", data=year_df, hue=\"Name\", palette=\"coolwarm\", dodge=True)",
                                    "line": 65
                                }
                            ]
                        },
                        {
                            "summaryComponent": "Adds a horizontal dashed line at y=0 to indicate perfect prediction",
                            "codeSegments": [
                                {
                                    "code": "plt.axhline(0, color=\"black\", linestyle=\"--\")",
                                    "line": 66
                                }
                            ]
                        },
                        {
                            "summaryComponent": "Rotates x-axis labels for readability and sets axis labels and plot title",
                            "codeSegments": [
                                {
                                    "code": "plt.xticks(rotation=45, ha=\"right\")",
                                    "line": 67
                                },
                                {
                                    "code": "plt.ylabel(\"Predicted Rank - True Rank\")",
                                    "line": 68
                                },
                                {
                                    "code": "plt.title(f\"MVP Ranking Predictions ({year})\")",
                                    "line": 69
                                }
                            ]
                        },
                        {
                            "summaryComponent": "Adjusts the layout to prevent overlap and saves the plot as a PNG file named with the target year",
                            "codeSegments": [
                                {
                                    "code": "plt.tight_layout()",
                                    "line": 70
                                },
                                {
                                    "code": "plt.savefig(f\"data/ranking_predictions_{year}.png\")",
                                    "line": 71
                                }
                            ]
                        }
                    ],
                    "low_structured": [
                        {
                            "summaryComponent": "Plots prediction error for a given year",
                            "codeSegments": [
                                {
                                    "code": "def plot_ranking_predictions(df, year):",
                                    "line": 52
                                },
                                {
                                    "code": "plt.figure(figsize=(12, 6))",
                                    "line": 64
                                },
                                {
                                    "code": "sns.barplot(x=\"Name\", y=\"RankError\", data=year_df, hue=\"Name\", palette=\"coolwarm\", dodge=True)",
                                    "line": 65
                                },
                                {
                                    "code": "plt.axhline(0, color=\"black\", linestyle=\"--\")",
                                    "line": 66
                                },
                                {
                                    "code": "plt.title(f\"MVP Ranking Predictions ({year})\")",
                                    "line": 69
                                }
                            ]
                        },
                        {
                            "summaryComponent": "Uses player ranking data",
                            "codeSegments": [
                                {
                                    "code": "df[\"RankError\"] = df[\"PredictedRank\"] - df[\"Rank\"]",
                                    "line": 60
                                },
                                {
                                    "code": "year_df = df[df[\"Year\"] == year].copy()",
                                    "line": 61
                                },
                                {
                                    "code": "year_df.sort_values(\"Rank\", inplace=True)",
                                    "line": 62
                                }
                            ]
                        },
                        {
                            "summaryComponent": "Saves the plot as an image",
                            "codeSegments": [
                                {
                                    "code": "plt.savefig(f\"data/ranking_predictions_{year}.png\")",
                                    "line": 71
                                }
                            ]
                        }
                    ],
                    "high_unstructured": [
                        {
                            "summaryComponent": "The plot_ranking_predictions function generates a bar plot to visualize the prediction error (PredictedRank minus actual Rank) for each player in a specified year.",
                            "codeSegments": [
                                {
                                    "code": "def plot_ranking_predictions(df, year):",
                                    "line": 52
                                },
                                {
                                    "code": "plt.figure(figsize=(12, 6))",
                                    "line": 64
                                },
                                {
                                    "code": "sns.barplot(x=\"Name\", y=\"RankError\", data=year_df, hue=\"Name\", palette=\"coolwarm\", dodge=True)",
                                    "line": 65
                                }
                            ]
                        },
                        {
                            "summaryComponent": "It first computes the rank error",
                            "codeSegments": [
                                {
                                    "code": "df[\"RankError\"] = df[\"PredictedRank\"] - df[\"Rank\"]",
                                    "line": 60
                                }
                            ]
                        },
                        {
                            "summaryComponent": "filters the DataFrame for the given year",
                            "codeSegments": [
                                {
                                    "code": "year_df = df[df[\"Year\"] == year].copy()",
                                    "line": 61
                                }
                            ]
                        },
                        {
                            "summaryComponent": "and sorts players by their true rank.",
                            "codeSegments": [
                                {
                                    "code": "year_df.sort_values(\"Rank\", inplace=True)",
                                    "line": 62
                                }
                            ]
                        },
                        {
                            "summaryComponent": "The function then creates a bar plot with player names on the x-axis and prediction error on the y-axis",
                            "codeSegments": [
                                {
                                    "code": "sns.barplot(x=\"Name\", y=\"RankError\", data=year_df, hue=\"Name\", palette=\"coolwarm\", dodge=True)",
                                    "line": 65
                                }
                            ]
                        },
                        {
                            "summaryComponent": "adds a horizontal reference line at zero",
                            "codeSegments": [
                                {
                                    "code": "plt.axhline(0, color=\"black\", linestyle=\"--\")",
                                    "line": 66
                                }
                            ]
                        },
                        {
                            "summaryComponent": "and customizes the plot's appearance (such as rotating x-axis labels and setting the title).",
                            "codeSegments": [
                                {
                                    "code": "plt.xticks(rotation=45, ha=\"right\")",
                                    "line": 67
                                },
                                {
                                    "code": "plt.title(f\"MVP Ranking Predictions ({year})\")",
                                    "line": 69
                                }
                            ]
                        },
                        {
                            "summaryComponent": "Finally, it saves the plot as a PNG file in the data directory, named according to the year.",
                            "codeSegments": [
                                {
                                    "code": "plt.savefig(f\"data/ranking_predictions_{year}.png\")",
                                    "line": 71
                                }
                            ]
                        }
                    ],
                    "medium_unstructured": [
                        {
                            "summaryComponent": "The plot_ranking_predictions function",
                            "codeSegments": [
                                {
                                    "code": "def plot_ranking_predictions(df, year):",
                                    "line": 52
                                }
                            ]
                        },
                        {
                            "summaryComponent": "visualizes the difference between predicted and actual player ranks",
                            "codeSegments": [
                                {
                                    "code": "df[\"RankError\"] = df[\"PredictedRank\"] - df[\"Rank\"]",
                                    "line": 60
                                }
                            ]
                        },
                        {
                            "summaryComponent": "for a specified year",
                            "codeSegments": [
                                {
                                    "code": "year_df = df[df[\"Year\"] == year].copy()",
                                    "line": 61
                                }
                            ]
                        },
                        {
                            "summaryComponent": "It creates a bar plot showing these errors for each player",
                            "codeSegments": [
                                {
                                    "code": "sns.barplot(x=\"Name\", y=\"RankError\", data=year_df, hue=\"Name\", palette=\"coolwarm\", dodge=True)",
                                    "line": 65
                                }
                            ]
                        },
                        {
                            "summaryComponent": "and saves the resulting figure as a PNG file",
                            "codeSegments": [
                                {
                                    "code": "plt.savefig(f\"data/ranking_predictions_{year}.png\")",
                                    "line": 71
                                }
                            ]
                        },
                        {
                            "summaryComponent": "The plot helps assess ranking prediction performance for that year",
                            "codeSegments": [
                                {
                                    "code": "plt.title(f\"MVP Ranking Predictions ({year})\")",
                                    "line": 69
                                }
                            ]
                        }
                    ],
                    "low_unstructured": [
                        {
                            "summaryComponent": "This function",
                            "codeSegments": [
                                {
                                    "code": "def plot_ranking_predictions(df, year):",
                                    "line": 52
                                }
                            ]
                        },
                        {
                            "summaryComponent": "plots the prediction error",
                            "codeSegments": [
                                {
                                    "code": "plt.figure(figsize=(12, 6))",
                                    "line": 64
                                },
                                {
                                    "code": "sns.barplot(x=\"Name\", y=\"RankError\", data=year_df, hue=\"Name\", palette=\"coolwarm\", dodge=True)",
                                    "line": 65
                                }
                            ]
                        },
                        {
                            "summaryComponent": "for player rankings",
                            "codeSegments": [
                                {
                                    "code": "df[\"RankError\"] = df[\"PredictedRank\"] - df[\"Rank\"]",
                                    "line": 60
                                },
                                {
                                    "code": "year_df.sort_values(\"Rank\", inplace=True)",
                                    "line": 62
                                }
                            ]
                        },
                        {
                            "summaryComponent": "in a specified year",
                            "codeSegments": [
                                {
                                    "code": "year_df = df[df[\"Year\"] == year].copy()",
                                    "line": 61
                                }
                            ]
                        }
                    ]
                },
                "editPromptValue": "",
                "editPromptDetailLevel": null,
                "oldSummaryData": {
                    "medium_structured": "• Calculates prediction error as the difference between predicted and true ranks\n• Filters data for the specified year and sorts players by true rank\n• Plots a bar chart of prediction errors for each player\n  ◦ Uses player names on the x-axis and error on the y-axis\n• Saves the plot as a PNG file named for the year",
                    "low_unstructured": "This function plots the prediction error for player rankings in a specified year.",
                    "high_structured": "• Computes the prediction error by subtracting the true rank from the predicted rank for each player\n• Filters the DataFrame to include only records from the specified year\n  ◦ Makes a copy and sorts players by their true rank for clear visualization\n• Creates a bar plot using Seaborn:\n  ◦ Player names are shown on the x-axis, prediction errors on the y-axis\n  ◦ Each player's bar is colored distinctly using the 'coolwarm' palette\n• Adds a horizontal dashed line at y=0 to indicate perfect prediction\n• Rotates x-axis labels for readability and sets axis labels and plot title\n• Adjusts the layout to prevent overlap and saves the plot as a PNG file named with the target year",
                    "low_structured": "• Plots prediction error for a given year\n• Uses player ranking data\n• Saves the plot as an image",
                    "high_unstructured": "The plot_ranking_predictions function generates a bar plot to visualize the prediction error (PredictedRank minus actual Rank) for each player in a specified year. It first computes the rank error, filters the DataFrame for the given year, and sorts players by their true rank. The function then creates a bar plot with player names on the x-axis and prediction error on the y-axis, adds a horizontal reference line at zero, and customizes the plot's appearance (such as rotating x-axis labels and setting the title). Finally, it saves the plot as a PNG file in the data directory, named according to the year.",
                    "medium_unstructured": "The plot_ranking_predictions function visualizes the difference between predicted and actual player ranks for a specified year. It creates a bar plot showing these errors for each player and saves the resulting figure as a PNG file. The plot helps assess ranking prediction performance for that year.",
                    "title": "plot_ranking_predictions Function Summary"
                },
                "lines": [
                    52,
                    71
                ],
                "title": "plot_ranking_predictions Function Summary"
            },
            "section_id": "21428fb2-d6b0-4575-8f96-b84e832bdb50"
        },
        "id": "jfk9V0u7KZrNR2CWsb41"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "timestamp": "2025-08-24 12:00:53.000",
        "data": {
            "structured_type": "unstructured",
            "detail_level": "medium",
            "section_id": "21428fb2-d6b0-4575-8f96-b84e832bdb50"
        },
        "id": "Y10gyBS9CxEFieB44C1B"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "timestamp": "2025-08-24 12:00:53.000",
        "data": {
            "structured_type": "unstructured",
            "detail_level": "medium",
            "mapping_index": 5,
            "section_id": "21428fb2-d6b0-4575-8f96-b84e832bdb50"
        },
        "id": "iPcap3fuDuVdjKUZc3mH"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "timestamp": "2025-08-24 12:00:56.000",
        "data": {
            "structured_type": "unstructured",
            "detail_level": "medium",
            "section_id": "21428fb2-d6b0-4575-8f96-b84e832bdb50"
        },
        "id": "3tCmakoTlQ5wcIQZzWz5"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "timestamp": "2025-08-24 12:00:56.000",
        "data": {
            "structured_type": "unstructured",
            "detail_level": "medium",
            "mapping_index": 2,
            "section_id": "21428fb2-d6b0-4575-8f96-b84e832bdb50"
        },
        "id": "5inYU9tyBTu1d5Hrp44N"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "timestamp": "2025-08-24 12:00:56.000",
        "data": {
            "structured_type": "unstructured",
            "detail_level": "medium",
            "section_id": "21428fb2-d6b0-4575-8f96-b84e832bdb50"
        },
        "id": "GMbt08BeIYE7p1oNqAQX"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "timestamp": "2025-08-24 12:00:56.000",
        "data": {
            "structured_type": "unstructured",
            "detail_level": "medium",
            "section_id": "21428fb2-d6b0-4575-8f96-b84e832bdb50"
        },
        "id": "ULVRxmVFMSmR9GDUnWiA"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "timestamp": "2025-08-24 12:00:56.000",
        "data": {
            "structured_type": "unstructured",
            "detail_level": "medium",
            "mapping_index": 4,
            "section_id": "21428fb2-d6b0-4575-8f96-b84e832bdb50"
        },
        "id": "dLeNsBBMFKA38DV9JIg8"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "timestamp": "2025-08-24 12:00:56.000",
        "data": {
            "structured_type": "unstructured",
            "detail_level": "medium",
            "mapping_index": 3,
            "section_id": "21428fb2-d6b0-4575-8f96-b84e832bdb50"
        },
        "id": "nQ2S2ZkaiiJJOM99TiIz"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "timestamp": "2025-08-24 12:00:56.000",
        "data": {
            "structured_type": "unstructured",
            "detail_level": "medium",
            "mapping_index": 5,
            "section_id": "21428fb2-d6b0-4575-8f96-b84e832bdb50"
        },
        "id": "rCAeEv4Y9RfxKyyH4pNY"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "timestamp": "2025-08-24 12:00:57.000",
        "data": {
            "structured_type": "unstructured",
            "detail_level": "medium",
            "section_id": "21428fb2-d6b0-4575-8f96-b84e832bdb50"
        },
        "id": "1dTXgKRckh2ONdPsMJ3i"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "timestamp": "2025-08-24 12:00:57.000",
        "data": {
            "structured_type": "unstructured",
            "detail_level": "medium",
            "mapping_index": 0,
            "section_id": "21428fb2-d6b0-4575-8f96-b84e832bdb50"
        },
        "id": "kvt9f9mFi0LRwNJN8M9N"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "timestamp": "2025-08-24 12:00:57.000",
        "data": {
            "structured_type": "unstructured",
            "detail_level": "medium",
            "section_id": "21428fb2-d6b0-4575-8f96-b84e832bdb50"
        },
        "id": "sOv0t9H9aB7iCw5OsTTm"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "timestamp": "2025-08-24 12:01:03.000",
        "data": {
            "structured_type": "unstructured",
            "detail_level": "medium",
            "section_id": "21428fb2-d6b0-4575-8f96-b84e832bdb50"
        },
        "id": "Bp9rRmRexeb56IDxyhZS"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "timestamp": "2025-08-24 12:01:03.000",
        "data": {
            "structured_type": "unstructured",
            "detail_level": "medium",
            "mapping_index": 5,
            "section_id": "21428fb2-d6b0-4575-8f96-b84e832bdb50"
        },
        "id": "CmPw8VsE6l9t9Wbju6ks"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "timestamp": "2025-08-24 12:01:03.000",
        "data": {
            "structured_type": "unstructured",
            "detail_level": "medium",
            "mapping_index": 0,
            "section_id": "21428fb2-d6b0-4575-8f96-b84e832bdb50"
        },
        "id": "Jm9uGY8gedJQmxYuI4zB"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "timestamp": "2025-08-24 12:01:03.000",
        "data": {
            "structured_type": "unstructured",
            "detail_level": "medium",
            "section_id": "21428fb2-d6b0-4575-8f96-b84e832bdb50"
        },
        "id": "Qd6wZ4QKtTYcA2oi033c"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "timestamp": "2025-08-24 12:01:03.000",
        "data": {
            "structured_type": "unstructured",
            "detail_level": "medium",
            "mapping_index": 2,
            "section_id": "21428fb2-d6b0-4575-8f96-b84e832bdb50"
        },
        "id": "bM6SdqMPFt7dExnm2D7d"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "timestamp": "2025-08-24 12:01:03.000",
        "data": {
            "structured_type": "unstructured",
            "detail_level": "medium",
            "section_id": "21428fb2-d6b0-4575-8f96-b84e832bdb50"
        },
        "id": "h61uX3pLKu6MSvOHX3cA"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "timestamp": "2025-08-24 12:01:03.000",
        "data": {
            "structured_type": "unstructured",
            "detail_level": "medium",
            "mapping_index": 0,
            "section_id": "21428fb2-d6b0-4575-8f96-b84e832bdb50"
        },
        "id": "iUnwyGbekEasphw2Azqf"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "timestamp": "2025-08-24 12:01:03.000",
        "data": {
            "structured_type": "unstructured",
            "detail_level": "medium",
            "section_id": "21428fb2-d6b0-4575-8f96-b84e832bdb50"
        },
        "id": "oP2eRRIZWRXWNOyo5oFT"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "timestamp": "2025-08-24 12:01:03.000",
        "data": {
            "structured_type": "unstructured",
            "detail_level": "medium",
            "mapping_index": 4,
            "section_id": "21428fb2-d6b0-4575-8f96-b84e832bdb50"
        },
        "id": "q8mS1q6iXdIFYZ7xDe0N"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "timestamp": "2025-08-24 12:01:04.000",
        "data": {
            "structured_type": "unstructured",
            "detail_level": "medium",
            "section_id": "21428fb2-d6b0-4575-8f96-b84e832bdb50"
        },
        "id": "OCEV9Js3AChO4BYeGUFX"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "timestamp": "2025-08-24 12:01:04.000",
        "data": {
            "structured_type": "unstructured",
            "detail_level": "medium",
            "section_id": "21428fb2-d6b0-4575-8f96-b84e832bdb50"
        },
        "id": "Vl0C8XOLrpwvdyu6pYlZ"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "timestamp": "2025-08-24 12:01:04.000",
        "data": {
            "structured_type": "unstructured",
            "detail_level": "medium",
            "mapping_index": 4,
            "section_id": "21428fb2-d6b0-4575-8f96-b84e832bdb50"
        },
        "id": "YcvGHpKl4QH9SqUHh0ZP"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "timestamp": "2025-08-24 12:01:04.000",
        "data": {
            "structured_type": "unstructured",
            "detail_level": "medium",
            "mapping_index": 2,
            "section_id": "21428fb2-d6b0-4575-8f96-b84e832bdb50"
        },
        "id": "nf0sWNAqgTprTgRI2CxZ"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "timestamp": "2025-08-24 12:01:04.000",
        "data": {
            "structured_type": "unstructured",
            "detail_level": "medium",
            "section_id": "21428fb2-d6b0-4575-8f96-b84e832bdb50"
        },
        "id": "uqDtg3bXhlwBrQyKoHyk"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "timestamp": "2025-08-24 12:01:12.000",
        "data": {
            "structured_type": "unstructured",
            "detail_level": "medium",
            "mapping_index": 4,
            "section_id": "21428fb2-d6b0-4575-8f96-b84e832bdb50"
        },
        "id": "DqZT1zRSL4Cln6ssXcG5"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "timestamp": "2025-08-24 12:01:12.000",
        "data": {
            "structured_type": "unstructured",
            "detail_level": "medium",
            "section_id": "21428fb2-d6b0-4575-8f96-b84e832bdb50"
        },
        "id": "VAkUz97n4r4q0i6bYnsb"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "timestamp": "2025-08-24 12:01:12.000",
        "data": {
            "structured_type": "unstructured",
            "detail_level": "medium",
            "mapping_index": 2,
            "section_id": "21428fb2-d6b0-4575-8f96-b84e832bdb50"
        },
        "id": "h9LVgvNx6RXdfbsJQA3E"
    },
    {
        "source": "frontend",
        "event": "change_summary_level",
        "timestamp": "2025-08-24 12:01:13.000",
        "data": {
            "before_structured": "unstructured",
            "before_detail_level": "medium",
            "after_structured": "unstructured",
            "after_detail_level": "high",
            "section_id": "21428fb2-d6b0-4575-8f96-b84e832bdb50"
        },
        "id": "G1cCwSRJ2VbGRpfyKDoX"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "timestamp": "2025-08-24 12:01:13.000",
        "data": {
            "structured_type": "unstructured",
            "detail_level": "medium",
            "section_id": "21428fb2-d6b0-4575-8f96-b84e832bdb50"
        },
        "id": "J5p3Gn34M7nUeA2NV3M4"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "timestamp": "2025-08-24 12:01:13.000",
        "data": {
            "structured_type": "unstructured",
            "detail_level": "medium",
            "section_id": "21428fb2-d6b0-4575-8f96-b84e832bdb50"
        },
        "id": "MDWj2VeBAzsVzARsOKmK"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "timestamp": "2025-08-24 12:01:13.000",
        "data": {
            "structured_type": "unstructured",
            "detail_level": "medium",
            "mapping_index": 0,
            "section_id": "21428fb2-d6b0-4575-8f96-b84e832bdb50"
        },
        "id": "qROxtlcNAwtL1VGaGJYT"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "timestamp": "2025-08-24 12:01:14.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "high",
            "mapping_index": 5,
            "section_id": "21428fb2-d6b0-4575-8f96-b84e832bdb50"
        },
        "id": "6HUIfnbqcTr0HQzFJVj3"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "timestamp": "2025-08-24 12:01:14.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "high",
            "mapping_index": 0,
            "section_id": "21428fb2-d6b0-4575-8f96-b84e832bdb50"
        },
        "id": "9YWSIQ4diZj3Tohp5Y7I"
    },
    {
        "source": "frontend",
        "event": "change_summary_level",
        "timestamp": "2025-08-24 12:01:14.000",
        "data": {
            "before_structured": "unstructured",
            "before_detail_level": "high",
            "after_structured": "structured",
            "after_detail_level": "high",
            "section_id": "21428fb2-d6b0-4575-8f96-b84e832bdb50"
        },
        "id": "Cq7uR0oDy4wjUpFpFvUw"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "timestamp": "2025-08-24 12:01:14.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "high",
            "section_id": "21428fb2-d6b0-4575-8f96-b84e832bdb50"
        },
        "id": "Phz3Ncp2F1ENzr3X9PBu"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "timestamp": "2025-08-24 12:01:14.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "high",
            "section_id": "21428fb2-d6b0-4575-8f96-b84e832bdb50"
        },
        "id": "WV7cpxGZoVgXHTbw9ky3"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "timestamp": "2025-08-24 12:01:14.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "high",
            "mapping_index": 3,
            "section_id": "21428fb2-d6b0-4575-8f96-b84e832bdb50"
        },
        "id": "l8TlVyNYgXmTbuESSXE2"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "timestamp": "2025-08-24 12:01:14.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "high",
            "section_id": "21428fb2-d6b0-4575-8f96-b84e832bdb50"
        },
        "id": "t7LYAciTKYvxyr52XMCd"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "timestamp": "2025-08-24 12:01:14.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "high",
            "mapping_index": 2,
            "section_id": "21428fb2-d6b0-4575-8f96-b84e832bdb50"
        },
        "id": "tNTxEfOGFxBaTxzKqbd1"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "timestamp": "2025-08-24 12:01:32.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "high",
            "mapping_index": 6,
            "section_id": "21428fb2-d6b0-4575-8f96-b84e832bdb50"
        },
        "id": "3ZrlwyzUvz0weU4ikUna"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "timestamp": "2025-08-24 12:01:32.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "high",
            "mapping_index": 7,
            "section_id": "21428fb2-d6b0-4575-8f96-b84e832bdb50"
        },
        "id": "5FsA9gxfPrNi5E2a6LPi"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "timestamp": "2025-08-24 12:01:32.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "high",
            "section_id": "21428fb2-d6b0-4575-8f96-b84e832bdb50"
        },
        "id": "97b5kPghvlpXgh4utZKw"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "timestamp": "2025-08-24 12:01:32.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "high",
            "mapping_index": 4,
            "section_id": "21428fb2-d6b0-4575-8f96-b84e832bdb50"
        },
        "id": "APhYyxZmuyboSNjblk3x"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "timestamp": "2025-08-24 12:01:32.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "high",
            "mapping_index": 8,
            "section_id": "21428fb2-d6b0-4575-8f96-b84e832bdb50"
        },
        "id": "BGV01uViO8jGEQKfTR1g"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "timestamp": "2025-08-24 12:01:32.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "high",
            "mapping_index": 8,
            "section_id": "21428fb2-d6b0-4575-8f96-b84e832bdb50"
        },
        "id": "LAiWb7mxl7CCjl4nvHIN"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "timestamp": "2025-08-24 12:01:32.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "high",
            "section_id": "21428fb2-d6b0-4575-8f96-b84e832bdb50"
        },
        "id": "LicTL8qOvNyNiuFQocbh"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "timestamp": "2025-08-24 12:01:32.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "high",
            "section_id": "21428fb2-d6b0-4575-8f96-b84e832bdb50"
        },
        "id": "PrUyIJ0phrWkzYH3gIzS"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "timestamp": "2025-08-24 12:01:32.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "high",
            "section_id": "21428fb2-d6b0-4575-8f96-b84e832bdb50"
        },
        "id": "QSYvXxQKurYyJRfVreX3"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "timestamp": "2025-08-24 12:01:32.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "high",
            "mapping_index": 7,
            "section_id": "21428fb2-d6b0-4575-8f96-b84e832bdb50"
        },
        "id": "QaUi8LvTpkUtUixW7Ki5"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "timestamp": "2025-08-24 12:01:32.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "high",
            "section_id": "21428fb2-d6b0-4575-8f96-b84e832bdb50"
        },
        "id": "Wf7YkUNBCkOp2vCk3GiZ"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "timestamp": "2025-08-24 12:01:32.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "high",
            "section_id": "21428fb2-d6b0-4575-8f96-b84e832bdb50"
        },
        "id": "mT5YZAnl8PQXvoWrOCms"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "timestamp": "2025-08-24 12:01:32.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "high",
            "section_id": "21428fb2-d6b0-4575-8f96-b84e832bdb50"
        },
        "id": "maFYO7yTtrEtW7rrxZpo"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "timestamp": "2025-08-24 12:01:32.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "high",
            "section_id": "21428fb2-d6b0-4575-8f96-b84e832bdb50"
        },
        "id": "pbdNux1ydV2yFA2q4H3F"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "timestamp": "2025-08-24 12:01:32.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "high",
            "mapping_index": 5,
            "section_id": "21428fb2-d6b0-4575-8f96-b84e832bdb50"
        },
        "id": "sUpFxR8S0YgHlrxE11Hz"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "timestamp": "2025-08-24 12:01:32.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "high",
            "section_id": "21428fb2-d6b0-4575-8f96-b84e832bdb50"
        },
        "id": "ug87efPy5zImCHSxbBDc"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "timestamp": "2025-08-24 12:01:32.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "high",
            "mapping_index": 6,
            "section_id": "21428fb2-d6b0-4575-8f96-b84e832bdb50"
        },
        "id": "x52sGgAeFUBH5SPmYDEP"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "timestamp": "2025-08-24 12:01:33.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "high",
            "mapping_index": 2,
            "section_id": "21428fb2-d6b0-4575-8f96-b84e832bdb50"
        },
        "id": "tmfQ8y5VrGtsdzARyHhH"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "timestamp": "2025-08-24 12:01:34.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "high",
            "section_id": "21428fb2-d6b0-4575-8f96-b84e832bdb50"
        },
        "id": "Vi81YerHpKLSbC470VqY"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "timestamp": "2025-08-24 12:01:35.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "high",
            "mapping_index": 0,
            "section_id": "21428fb2-d6b0-4575-8f96-b84e832bdb50"
        },
        "id": "6v9xYmXBrvWIg75CS3gI"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "timestamp": "2025-08-24 12:01:35.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "high",
            "section_id": "21428fb2-d6b0-4575-8f96-b84e832bdb50"
        },
        "id": "PwJuv21kNfts24LMPYED"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "timestamp": "2025-08-24 12:01:36.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "high",
            "section_id": "21428fb2-d6b0-4575-8f96-b84e832bdb50"
        },
        "id": "6GU8CzVX0KecT6yNXmZs"
    },
    {
        "source": "frontend",
        "event": "click_edit_in_prompt",
        "timestamp": "2025-08-24 12:01:36.000",
        "data": {
            "detail_level": "high",
            "structured": "structured",
            "summary": "• Computes the prediction error by subtracting the true rank from the predicted rank for each player\n• Filters the DataFrame to include only records from the specified year\n  ◦ Makes a copy and sorts players by their true rank for clear visualization\n• Creates a bar plot using Seaborn:\n  ◦ Player names are shown on the x-axis, prediction errors on the y-axis\n  ◦ Each player's bar is colored distinctly using the 'coolwarm' palette\n• Adds a horizontal dashed line at y=0 to indicate perfect prediction\n• Rotates x-axis labels for readability and sets axis labels and plot title\n• Adjusts the layout to prevent overlap and saves the plot as a PNG file named with the target year (No changes from the previous version)",
            "section_id": "21428fb2-d6b0-4575-8f96-b84e832bdb50"
        },
        "id": "W88PahWnGDcLJWrPK0W1"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "timestamp": "2025-08-24 12:01:36.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "high",
            "mapping_index": 0,
            "section_id": "21428fb2-d6b0-4575-8f96-b84e832bdb50"
        },
        "id": "n9hxfcnDjPrHzEdTY1ym"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "timestamp": "2025-08-24 12:01:37.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "high",
            "section_id": "21428fb2-d6b0-4575-8f96-b84e832bdb50"
        },
        "id": "sMomBibS0mWmEDlQrlyn"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "timestamp": "2025-08-24 12:01:37.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "high",
            "mapping_index": 8,
            "section_id": "21428fb2-d6b0-4575-8f96-b84e832bdb50"
        },
        "id": "slgl2Vi610Pc3aUTTWxW"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "timestamp": "2025-08-24 12:01:42.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "high",
            "mapping_index": 7,
            "section_id": "21428fb2-d6b0-4575-8f96-b84e832bdb50"
        },
        "id": "Xd8iuswT5KpQPFv9RMqA"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "timestamp": "2025-08-24 12:01:42.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "high",
            "section_id": "21428fb2-d6b0-4575-8f96-b84e832bdb50"
        },
        "id": "te2JCXdW9oOcPU3rReMf"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "timestamp": "2025-08-24 12:01:46.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "high",
            "section_id": "21428fb2-d6b0-4575-8f96-b84e832bdb50"
        },
        "id": "EB8Vcm6kiDywdm2YXNte"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "timestamp": "2025-08-24 12:01:46.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "high",
            "mapping_index": 6,
            "section_id": "21428fb2-d6b0-4575-8f96-b84e832bdb50"
        },
        "id": "NiCsYY7ND6NvpAKsfQCL"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "timestamp": "2025-08-24 12:01:46.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "high",
            "mapping_index": 4,
            "section_id": "21428fb2-d6b0-4575-8f96-b84e832bdb50"
        },
        "id": "UC2zKojfU0IqFLjxYb0I"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "timestamp": "2025-08-24 12:01:46.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "high",
            "section_id": "21428fb2-d6b0-4575-8f96-b84e832bdb50"
        },
        "id": "gpQLopiNwBhVT45ys8wj"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "timestamp": "2025-08-24 12:01:46.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "high",
            "mapping_index": 5,
            "section_id": "21428fb2-d6b0-4575-8f96-b84e832bdb50"
        },
        "id": "jj4cfNWrYLZ35ZW0xphj"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "timestamp": "2025-08-24 12:01:47.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "high",
            "section_id": "21428fb2-d6b0-4575-8f96-b84e832bdb50"
        },
        "id": "1h0wUqWR178FRqq5nrTF"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "timestamp": "2025-08-24 12:01:47.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "high",
            "section_id": "21428fb2-d6b0-4575-8f96-b84e832bdb50"
        },
        "id": "9BGmEzv2WPiO2jla4iZh"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "timestamp": "2025-08-24 12:01:47.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "high",
            "mapping_index": 8,
            "section_id": "21428fb2-d6b0-4575-8f96-b84e832bdb50"
        },
        "id": "K2C1ZxJf4owJUogUnFQa"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "timestamp": "2025-08-24 12:01:47.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "high",
            "section_id": "21428fb2-d6b0-4575-8f96-b84e832bdb50"
        },
        "id": "P8SApx5cY75MNxgvlTTH"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "timestamp": "2025-08-24 12:01:47.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "high",
            "section_id": "21428fb2-d6b0-4575-8f96-b84e832bdb50"
        },
        "id": "eDs9rqKrDFk7CcmJwsEQ"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "timestamp": "2025-08-24 12:01:47.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "high",
            "mapping_index": 7,
            "section_id": "21428fb2-d6b0-4575-8f96-b84e832bdb50"
        },
        "id": "gDUOjfj9jXkchAoaoIIm"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "timestamp": "2025-08-24 12:01:47.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "high",
            "mapping_index": 8,
            "section_id": "21428fb2-d6b0-4575-8f96-b84e832bdb50"
        },
        "id": "ybpsIVcxlexWimw3EwVk"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "timestamp": "2025-08-24 12:02:07.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "high",
            "mapping_index": 1,
            "section_id": "21428fb2-d6b0-4575-8f96-b84e832bdb50"
        },
        "id": "3Csx6bvkKdsq9LFi7U6g"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "timestamp": "2025-08-24 12:02:07.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "high",
            "mapping_index": 0,
            "section_id": "21428fb2-d6b0-4575-8f96-b84e832bdb50"
        },
        "id": "r6hlu7umtVdJLKXy8KOO"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "timestamp": "2025-08-24 12:02:07.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "high",
            "mapping_index": 2,
            "section_id": "21428fb2-d6b0-4575-8f96-b84e832bdb50"
        },
        "id": "sxsbJqQXVXo3U3pUakCf"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "timestamp": "2025-08-24 12:02:07.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "high",
            "section_id": "21428fb2-d6b0-4575-8f96-b84e832bdb50"
        },
        "id": "z1ApVSNSqEprrHS5qGcL"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "timestamp": "2025-08-24 12:02:07.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "high",
            "section_id": "21428fb2-d6b0-4575-8f96-b84e832bdb50"
        },
        "id": "z9KSxdtPUdsBaJKEZ5ZV"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "timestamp": "2025-08-24 12:02:08.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "high",
            "section_id": "21428fb2-d6b0-4575-8f96-b84e832bdb50"
        },
        "id": "5zS7pt4aEusl1Xk8Xj1v"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "timestamp": "2025-08-24 12:02:08.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "high",
            "mapping_index": 0,
            "section_id": "21428fb2-d6b0-4575-8f96-b84e832bdb50"
        },
        "id": "68lSXDNplovMpfQhitkL"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "timestamp": "2025-08-24 12:02:08.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "high",
            "section_id": "21428fb2-d6b0-4575-8f96-b84e832bdb50"
        },
        "id": "apPjK65Yz8ln7Lwp5RhW"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "timestamp": "2025-08-24 12:02:08.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "high",
            "mapping_index": 0,
            "section_id": "21428fb2-d6b0-4575-8f96-b84e832bdb50"
        },
        "id": "qbHG2sOze9QbdM4kNAUZ"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "timestamp": "2025-08-24 12:02:09.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "high",
            "section_id": "21428fb2-d6b0-4575-8f96-b84e832bdb50"
        },
        "id": "CPJw2rPQXUnGwEy9eLwa"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "timestamp": "2025-08-24 12:02:09.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "high",
            "mapping_index": 2,
            "section_id": "21428fb2-d6b0-4575-8f96-b84e832bdb50"
        },
        "id": "Iu9TpkfegOMT3J9KdU0j"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "timestamp": "2025-08-24 12:02:09.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "high",
            "section_id": "21428fb2-d6b0-4575-8f96-b84e832bdb50"
        },
        "id": "rb8EoTHZsRvntNkTe0B2"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "timestamp": "2025-08-24 12:02:09.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "high",
            "mapping_index": 1,
            "section_id": "21428fb2-d6b0-4575-8f96-b84e832bdb50"
        },
        "id": "xSJuvVpTs4FKWBW8TSak"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "timestamp": "2025-08-24 12:02:10.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "high",
            "mapping_index": 4,
            "section_id": "21428fb2-d6b0-4575-8f96-b84e832bdb50"
        },
        "id": "PTBlIrkBWIuFYkw7L29M"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "timestamp": "2025-08-24 12:02:10.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "high",
            "section_id": "21428fb2-d6b0-4575-8f96-b84e832bdb50"
        },
        "id": "mmYzQDUmff7rIgBQzvYl"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "timestamp": "2025-08-24 12:02:11.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "high",
            "mapping_index": 6,
            "section_id": "21428fb2-d6b0-4575-8f96-b84e832bdb50"
        },
        "id": "7ovKV4lzQqVgt6TfHKi8"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "timestamp": "2025-08-24 12:02:11.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "high",
            "mapping_index": 5,
            "section_id": "21428fb2-d6b0-4575-8f96-b84e832bdb50"
        },
        "id": "rYFsAuV5vVsuhAwaPHM5"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "timestamp": "2025-08-24 12:02:11.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "high",
            "section_id": "21428fb2-d6b0-4575-8f96-b84e832bdb50"
        },
        "id": "t2tYuxpxWHkojwg08MYW"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "timestamp": "2025-08-24 12:02:11.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "high",
            "section_id": "21428fb2-d6b0-4575-8f96-b84e832bdb50"
        },
        "id": "ulkhiIhTXAVQpd5Cothz"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "timestamp": "2025-08-24 12:02:12.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "high",
            "section_id": "21428fb2-d6b0-4575-8f96-b84e832bdb50"
        },
        "id": "nfAJ7hhHuyMMmLH8imdy"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "timestamp": "2025-08-24 12:02:12.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "high",
            "mapping_index": 5,
            "section_id": "21428fb2-d6b0-4575-8f96-b84e832bdb50"
        },
        "id": "xyzeuQamDuKsVoANVOYb"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "timestamp": "2025-08-24 12:02:17.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "high",
            "mapping_index": 6,
            "section_id": "21428fb2-d6b0-4575-8f96-b84e832bdb50"
        },
        "id": "J6LeVLJJgPX2CAewmCPN"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "timestamp": "2025-08-24 12:02:17.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "high",
            "section_id": "21428fb2-d6b0-4575-8f96-b84e832bdb50"
        },
        "id": "W2UPtjYw2XI9oz77U4ib"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "timestamp": "2025-08-24 12:02:18.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "high",
            "section_id": "21428fb2-d6b0-4575-8f96-b84e832bdb50"
        },
        "id": "BsstVNubh8XKyMQc6O01"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "timestamp": "2025-08-24 12:02:18.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "high",
            "mapping_index": 7,
            "section_id": "21428fb2-d6b0-4575-8f96-b84e832bdb50"
        },
        "id": "IakAccX9xelZcY1kUOEH"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "timestamp": "2025-08-24 12:02:19.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "high",
            "section_id": "21428fb2-d6b0-4575-8f96-b84e832bdb50"
        },
        "id": "VLKLn5SKN2PQHV7nH0E1"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "timestamp": "2025-08-24 12:02:19.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "high",
            "mapping_index": 8,
            "section_id": "21428fb2-d6b0-4575-8f96-b84e832bdb50"
        },
        "id": "pQB9j6QIem9cURyzzikr"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "timestamp": "2025-08-24 12:02:20.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "high",
            "section_id": "21428fb2-d6b0-4575-8f96-b84e832bdb50"
        },
        "id": "RcBPD3JyPE8dTb6ByTi9"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "timestamp": "2025-08-24 12:02:29.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "high",
            "section_id": "21428fb2-d6b0-4575-8f96-b84e832bdb50"
        },
        "id": "fUMCGhnQQ9gCeB0laBEd"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "timestamp": "2025-08-24 12:02:29.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "high",
            "mapping_index": 8,
            "section_id": "21428fb2-d6b0-4575-8f96-b84e832bdb50"
        },
        "id": "oNx1mBHDSaITdkUUuXey"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "timestamp": "2025-08-24 12:02:29.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "high",
            "mapping_index": 7,
            "section_id": "21428fb2-d6b0-4575-8f96-b84e832bdb50"
        },
        "id": "wqtpdCVGSGr4o0VbCvLJ"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "timestamp": "2025-08-24 12:02:30.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "high",
            "section_id": "21428fb2-d6b0-4575-8f96-b84e832bdb50"
        },
        "id": "N7S1rN7qISQmrM6RggFr"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "timestamp": "2025-08-24 12:02:30.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "high",
            "mapping_index": 8,
            "section_id": "21428fb2-d6b0-4575-8f96-b84e832bdb50"
        },
        "id": "pTwmTlFFpMhRZJgIDbxu"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "timestamp": "2025-08-24 12:02:30.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "high",
            "section_id": "21428fb2-d6b0-4575-8f96-b84e832bdb50"
        },
        "id": "qqxNtMEBVo6WKbJksDto"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "timestamp": "2025-08-24 12:03:55.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "high",
            "section_id": "21428fb2-d6b0-4575-8f96-b84e832bdb50"
        },
        "id": "2J4VVpfQ1zbVXKFmZPAS"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "timestamp": "2025-08-24 12:03:55.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "high",
            "section_id": "21428fb2-d6b0-4575-8f96-b84e832bdb50"
        },
        "id": "91TrbwBfYbR7vWejr7f5"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "timestamp": "2025-08-24 12:03:55.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "high",
            "section_id": "21428fb2-d6b0-4575-8f96-b84e832bdb50"
        },
        "id": "GelwQCctennx4WJiNjfi"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "timestamp": "2025-08-24 12:03:55.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "high",
            "mapping_index": 7,
            "section_id": "21428fb2-d6b0-4575-8f96-b84e832bdb50"
        },
        "id": "ZucSC49F4DAsZ4Plezo9"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "timestamp": "2025-08-24 12:03:55.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "high",
            "mapping_index": 6,
            "section_id": "21428fb2-d6b0-4575-8f96-b84e832bdb50"
        },
        "id": "jp9HuDDrePSK5Mxh3C22"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "timestamp": "2025-08-24 12:03:55.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "high",
            "mapping_index": 7,
            "section_id": "21428fb2-d6b0-4575-8f96-b84e832bdb50"
        },
        "id": "weyBbNJIEgfYOMva1Z1o"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "timestamp": "2025-08-24 12:03:55.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "high",
            "mapping_index": 8,
            "section_id": "21428fb2-d6b0-4575-8f96-b84e832bdb50"
        },
        "id": "y80tbYMzTEpk0bu2gT4H"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "timestamp": "2025-08-24 12:03:56.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "high",
            "section_id": "21428fb2-d6b0-4575-8f96-b84e832bdb50"
        },
        "id": "3PbCDwbIjp5xFwLIPQji"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "timestamp": "2025-08-24 12:03:56.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "high",
            "mapping_index": 7,
            "section_id": "21428fb2-d6b0-4575-8f96-b84e832bdb50"
        },
        "id": "8hD7Hf4iKaoObjHAu02x"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "timestamp": "2025-08-24 12:03:56.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "high",
            "section_id": "21428fb2-d6b0-4575-8f96-b84e832bdb50"
        },
        "id": "GaMgOFyh7pzLt9HS8Fye"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "timestamp": "2025-08-24 12:03:56.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "high",
            "section_id": "21428fb2-d6b0-4575-8f96-b84e832bdb50"
        },
        "id": "ICC0CUJGGGacyAZCdvZO"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "timestamp": "2025-08-24 12:03:56.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "high",
            "mapping_index": 5,
            "section_id": "21428fb2-d6b0-4575-8f96-b84e832bdb50"
        },
        "id": "NxKuHIUfRhW1CQ7U9g8C"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "timestamp": "2025-08-24 12:03:56.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "high",
            "section_id": "21428fb2-d6b0-4575-8f96-b84e832bdb50"
        },
        "id": "cAnbMKvySa43IFLqD33F"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "timestamp": "2025-08-24 12:03:56.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "high",
            "mapping_index": 8,
            "section_id": "21428fb2-d6b0-4575-8f96-b84e832bdb50"
        },
        "id": "hlStMkTsTrHreWYVdzvq"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "timestamp": "2025-08-24 12:03:56.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "high",
            "mapping_index": 6,
            "section_id": "21428fb2-d6b0-4575-8f96-b84e832bdb50"
        },
        "id": "vP3jRaG9lc1uTKypk9MI"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "timestamp": "2025-08-24 12:03:57.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "high",
            "section_id": "21428fb2-d6b0-4575-8f96-b84e832bdb50"
        },
        "id": "8yraZ3STZDBadk1kvjO8"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "timestamp": "2025-08-24 12:03:57.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "high",
            "section_id": "21428fb2-d6b0-4575-8f96-b84e832bdb50"
        },
        "id": "Jp3clDLGLsnVeAxp0dx3"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "timestamp": "2025-08-24 12:03:57.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "high",
            "mapping_index": 6,
            "section_id": "21428fb2-d6b0-4575-8f96-b84e832bdb50"
        },
        "id": "RtY7BIAqdASJ9XrPIpFz"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "timestamp": "2025-08-24 12:03:57.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "high",
            "mapping_index": 7,
            "section_id": "21428fb2-d6b0-4575-8f96-b84e832bdb50"
        },
        "id": "q2TIG234RaeE87g5vbVj"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "timestamp": "2025-08-24 12:03:58.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "high",
            "section_id": "21428fb2-d6b0-4575-8f96-b84e832bdb50"
        },
        "id": "02NA67Rk7IDD795CWruR"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "timestamp": "2025-08-24 12:03:58.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "high",
            "mapping_index": 8,
            "section_id": "21428fb2-d6b0-4575-8f96-b84e832bdb50"
        },
        "id": "FGdQQh8E5rIxGr3QwTqm"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "timestamp": "2025-08-24 12:03:58.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "high",
            "section_id": "21428fb2-d6b0-4575-8f96-b84e832bdb50"
        },
        "id": "Ii8zKRyDs3A7C1xZlFHC"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "timestamp": "2025-08-24 12:03:58.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "high",
            "mapping_index": 7,
            "section_id": "21428fb2-d6b0-4575-8f96-b84e832bdb50"
        },
        "id": "iKK29OmHz5HEJlWpM98z"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "timestamp": "2025-08-24 12:03:58.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "high",
            "mapping_index": 6,
            "section_id": "21428fb2-d6b0-4575-8f96-b84e832bdb50"
        },
        "id": "jgmxQWZ25T0OcDYDkRy2"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "timestamp": "2025-08-24 12:03:58.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "high",
            "section_id": "21428fb2-d6b0-4575-8f96-b84e832bdb50"
        },
        "id": "lXM6rFryxtWrZOeHCsjz"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "timestamp": "2025-08-24 12:03:58.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "high",
            "section_id": "21428fb2-d6b0-4575-8f96-b84e832bdb50"
        },
        "id": "t7gcemKXm5t7PzuGawqw"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "timestamp": "2025-08-24 12:04:20.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "high",
            "mapping_index": 4,
            "section_id": "21428fb2-d6b0-4575-8f96-b84e832bdb50"
        },
        "id": "1FOTqOzLNt1jn7Bfr95C"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "timestamp": "2025-08-24 12:04:20.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "high",
            "mapping_index": 7,
            "section_id": "21428fb2-d6b0-4575-8f96-b84e832bdb50"
        },
        "id": "3fjmNzrhruzfS2NxT030"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "timestamp": "2025-08-24 12:04:20.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "high",
            "section_id": "21428fb2-d6b0-4575-8f96-b84e832bdb50"
        },
        "id": "4QS20Eu6wV0VcuqcHTnu"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "timestamp": "2025-08-24 12:04:20.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "high",
            "mapping_index": 6,
            "section_id": "21428fb2-d6b0-4575-8f96-b84e832bdb50"
        },
        "id": "BgFwUpFMKUKkaWNI3gLH"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "timestamp": "2025-08-24 12:04:20.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "high",
            "mapping_index": 0,
            "section_id": "21428fb2-d6b0-4575-8f96-b84e832bdb50"
        },
        "id": "F8Sdq5BIFE1ATIyzQRgr"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "timestamp": "2025-08-24 12:04:20.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "high",
            "section_id": "21428fb2-d6b0-4575-8f96-b84e832bdb50"
        },
        "id": "IGP547I3DVec6hn6F1Sg"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "timestamp": "2025-08-24 12:04:20.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "high",
            "section_id": "21428fb2-d6b0-4575-8f96-b84e832bdb50"
        },
        "id": "IPDlqJplVxqVZDQjZzyg"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "timestamp": "2025-08-24 12:04:20.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "high",
            "section_id": "21428fb2-d6b0-4575-8f96-b84e832bdb50"
        },
        "id": "KPGdhNUUiIddCh8LVMPA"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "timestamp": "2025-08-24 12:04:20.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "high",
            "section_id": "21428fb2-d6b0-4575-8f96-b84e832bdb50"
        },
        "id": "NcviFrgcTRNowxxLo991"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "timestamp": "2025-08-24 12:04:20.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "high",
            "mapping_index": 1,
            "section_id": "21428fb2-d6b0-4575-8f96-b84e832bdb50"
        },
        "id": "NqcPqt1VKhEo779vTJEW"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "timestamp": "2025-08-24 12:04:20.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "high",
            "section_id": "21428fb2-d6b0-4575-8f96-b84e832bdb50"
        },
        "id": "R9MxyMONqJsx1dH4BtaG"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "timestamp": "2025-08-24 12:04:20.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "high",
            "mapping_index": 1,
            "section_id": "21428fb2-d6b0-4575-8f96-b84e832bdb50"
        },
        "id": "ROSJpPcf8pbt18ismvJh"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "timestamp": "2025-08-24 12:04:20.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "high",
            "mapping_index": 3,
            "section_id": "21428fb2-d6b0-4575-8f96-b84e832bdb50"
        },
        "id": "SCgFVBwp7gUY7HgakJ9r"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "timestamp": "2025-08-24 12:04:20.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "high",
            "mapping_index": 5,
            "section_id": "21428fb2-d6b0-4575-8f96-b84e832bdb50"
        },
        "id": "Td4ZaudldcGrgA48EXMi"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "timestamp": "2025-08-24 12:04:20.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "high",
            "mapping_index": 8,
            "section_id": "21428fb2-d6b0-4575-8f96-b84e832bdb50"
        },
        "id": "XmDKrG3ErrLYC0u2jpMn"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "timestamp": "2025-08-24 12:04:20.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "high",
            "section_id": "21428fb2-d6b0-4575-8f96-b84e832bdb50"
        },
        "id": "Z4ZLp2ZSzbu434MF3aPz"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "timestamp": "2025-08-24 12:04:20.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "high",
            "section_id": "21428fb2-d6b0-4575-8f96-b84e832bdb50"
        },
        "id": "aDcS48fsl8Fmy7uZH1dI"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "timestamp": "2025-08-24 12:04:20.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "high",
            "mapping_index": 4,
            "section_id": "21428fb2-d6b0-4575-8f96-b84e832bdb50"
        },
        "id": "aLMtQQnyl966Li2LedFg"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "timestamp": "2025-08-24 12:04:20.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "high",
            "mapping_index": 6,
            "section_id": "21428fb2-d6b0-4575-8f96-b84e832bdb50"
        },
        "id": "fqlo0CyRj4jy92SLTuQO"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "timestamp": "2025-08-24 12:04:20.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "high",
            "mapping_index": 2,
            "section_id": "21428fb2-d6b0-4575-8f96-b84e832bdb50"
        },
        "id": "ljzf3htOSIAHVQEOdz6T"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "timestamp": "2025-08-24 12:04:20.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "high",
            "mapping_index": 7,
            "section_id": "21428fb2-d6b0-4575-8f96-b84e832bdb50"
        },
        "id": "nS12CnmM5xmosct5xSPg"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "timestamp": "2025-08-24 12:04:20.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "high",
            "section_id": "21428fb2-d6b0-4575-8f96-b84e832bdb50"
        },
        "id": "w9MyeQcbUUPijYmdiqnd"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "timestamp": "2025-08-24 12:04:20.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "high",
            "section_id": "21428fb2-d6b0-4575-8f96-b84e832bdb50"
        },
        "id": "xXLvelWBbInmfLlXzjUP"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "timestamp": "2025-08-24 12:04:20.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "high",
            "section_id": "21428fb2-d6b0-4575-8f96-b84e832bdb50"
        },
        "id": "yW7Yax1w0ctVuNFXEphG"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "timestamp": "2025-08-24 12:04:20.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "high",
            "section_id": "21428fb2-d6b0-4575-8f96-b84e832bdb50"
        },
        "id": "ziyGAv3etHTj5L0bDZkr"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "timestamp": "2025-08-24 12:04:21.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "high",
            "mapping_index": 8,
            "section_id": "21428fb2-d6b0-4575-8f96-b84e832bdb50"
        },
        "id": "HpcRgEYwaB8TXzVokZv7"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "timestamp": "2025-08-24 12:04:21.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "high",
            "section_id": "21428fb2-d6b0-4575-8f96-b84e832bdb50"
        },
        "id": "PoTmxce4Vn8LOcezYHQ1"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "timestamp": "2025-08-24 12:04:21.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "high",
            "section_id": "21428fb2-d6b0-4575-8f96-b84e832bdb50"
        },
        "id": "VutkskUHukXClYViEjVl"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "timestamp": "2025-08-24 12:04:24.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "high",
            "mapping_index": 4,
            "section_id": "21428fb2-d6b0-4575-8f96-b84e832bdb50"
        },
        "id": "4m2FblStCyVfPnrWdapk"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "timestamp": "2025-08-24 12:04:24.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "high",
            "section_id": "21428fb2-d6b0-4575-8f96-b84e832bdb50"
        },
        "id": "4rQncfmzwsS0Wiq0HVLC"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "timestamp": "2025-08-24 12:04:24.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "high",
            "section_id": "21428fb2-d6b0-4575-8f96-b84e832bdb50"
        },
        "id": "4vrbzaIH7jJurmTO61cO"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "timestamp": "2025-08-24 12:04:24.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "high",
            "section_id": "21428fb2-d6b0-4575-8f96-b84e832bdb50"
        },
        "id": "57UvPNnDIPBAvRbBVPpp"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "timestamp": "2025-08-24 12:04:24.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "high",
            "section_id": "21428fb2-d6b0-4575-8f96-b84e832bdb50"
        },
        "id": "65d0WNoo6F4qaAidGXis"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "timestamp": "2025-08-24 12:04:24.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "high",
            "section_id": "21428fb2-d6b0-4575-8f96-b84e832bdb50"
        },
        "id": "Gv11EcmoN5fSPhCITZQw"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "timestamp": "2025-08-24 12:04:24.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "high",
            "section_id": "21428fb2-d6b0-4575-8f96-b84e832bdb50"
        },
        "id": "IjrV9RkM4kRqI7fKKp5V"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "timestamp": "2025-08-24 12:04:24.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "high",
            "mapping_index": 5,
            "section_id": "21428fb2-d6b0-4575-8f96-b84e832bdb50"
        },
        "id": "QTOL0Ol4Qg2cBE5sgYBw"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "timestamp": "2025-08-24 12:04:24.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "high",
            "section_id": "21428fb2-d6b0-4575-8f96-b84e832bdb50"
        },
        "id": "TP361NQoNhs9lFgNrVny"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "timestamp": "2025-08-24 12:04:24.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "high",
            "mapping_index": 8,
            "section_id": "21428fb2-d6b0-4575-8f96-b84e832bdb50"
        },
        "id": "dz81ukZ3TJTfMeShNCFi"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "timestamp": "2025-08-24 12:04:24.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "high",
            "mapping_index": 3,
            "section_id": "21428fb2-d6b0-4575-8f96-b84e832bdb50"
        },
        "id": "ldxUAUtYcltgFeSPDPik"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "timestamp": "2025-08-24 12:04:24.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "high",
            "mapping_index": 1,
            "section_id": "21428fb2-d6b0-4575-8f96-b84e832bdb50"
        },
        "id": "nmG2yvZJ9MNWRYMRgfHg"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "timestamp": "2025-08-24 12:04:24.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "high",
            "mapping_index": 2,
            "section_id": "21428fb2-d6b0-4575-8f96-b84e832bdb50"
        },
        "id": "o2mzAotQJV3K5AlkSvHX"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "timestamp": "2025-08-24 12:04:24.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "high",
            "section_id": "21428fb2-d6b0-4575-8f96-b84e832bdb50"
        },
        "id": "oaoBrv1udmvJGysoeJys"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "timestamp": "2025-08-24 12:04:24.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "high",
            "mapping_index": 6,
            "section_id": "21428fb2-d6b0-4575-8f96-b84e832bdb50"
        },
        "id": "vkgIS8h13f6VFdop4N7k"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "timestamp": "2025-08-24 12:04:24.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "high",
            "mapping_index": 7,
            "section_id": "21428fb2-d6b0-4575-8f96-b84e832bdb50"
        },
        "id": "wLl4av90oidJswxueWUc"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "timestamp": "2025-08-24 12:04:38.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "high",
            "mapping_index": 0,
            "section_id": "21428fb2-d6b0-4575-8f96-b84e832bdb50"
        },
        "id": "FsaUQWHi8ng0rDesJ8Np"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "timestamp": "2025-08-24 12:04:38.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "high",
            "section_id": "21428fb2-d6b0-4575-8f96-b84e832bdb50"
        },
        "id": "SWJzCrU9uou6uw9Lilta"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "timestamp": "2025-08-24 12:04:38.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "high",
            "mapping_index": 1,
            "section_id": "21428fb2-d6b0-4575-8f96-b84e832bdb50"
        },
        "id": "k4BLTIGNIbwET3UNtFuE"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "timestamp": "2025-08-24 12:04:49.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "high",
            "mapping_index": 2,
            "section_id": "21428fb2-d6b0-4575-8f96-b84e832bdb50"
        },
        "id": "24oQtTjoWNYeoYlRWmla"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "timestamp": "2025-08-24 12:04:49.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "high",
            "mapping_index": 6,
            "section_id": "21428fb2-d6b0-4575-8f96-b84e832bdb50"
        },
        "id": "DF09MaGOwBg2c5u16a2d"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "timestamp": "2025-08-24 12:04:49.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "high",
            "mapping_index": 7,
            "section_id": "21428fb2-d6b0-4575-8f96-b84e832bdb50"
        },
        "id": "FzF5gfPh1UMMqw2ycvhN"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "timestamp": "2025-08-24 12:04:49.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "high",
            "mapping_index": 8,
            "section_id": "21428fb2-d6b0-4575-8f96-b84e832bdb50"
        },
        "id": "JvjUdAbTRsUh5KsJzfPq"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "timestamp": "2025-08-24 12:04:49.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "high",
            "section_id": "21428fb2-d6b0-4575-8f96-b84e832bdb50"
        },
        "id": "RX3CSa6yHSOK3EcCyc47"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "timestamp": "2025-08-24 12:04:49.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "high",
            "section_id": "21428fb2-d6b0-4575-8f96-b84e832bdb50"
        },
        "id": "WGLfsqQujpJtElww2Bd8"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "timestamp": "2025-08-24 12:04:49.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "high",
            "section_id": "21428fb2-d6b0-4575-8f96-b84e832bdb50"
        },
        "id": "assqixFUlnWAyrTuXeXb"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "timestamp": "2025-08-24 12:04:49.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "high",
            "section_id": "21428fb2-d6b0-4575-8f96-b84e832bdb50"
        },
        "id": "dc8oBCvFDv6yYPiqG6e0"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "timestamp": "2025-08-24 12:04:49.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "high",
            "section_id": "21428fb2-d6b0-4575-8f96-b84e832bdb50"
        },
        "id": "fBTeHXelLJXxHyOmNXnp"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "timestamp": "2025-08-24 12:04:49.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "high",
            "mapping_index": 5,
            "section_id": "21428fb2-d6b0-4575-8f96-b84e832bdb50"
        },
        "id": "hG4Y0oTEWrWguHwuCUvv"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "timestamp": "2025-08-24 12:04:49.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "high",
            "section_id": "21428fb2-d6b0-4575-8f96-b84e832bdb50"
        },
        "id": "v7iTYZK8Hg0qo9x0ECLY"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "timestamp": "2025-08-24 12:05:19.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "high",
            "mapping_index": 8,
            "section_id": "21428fb2-d6b0-4575-8f96-b84e832bdb50"
        },
        "id": "tr1VXCTuZNlf8tdsPwf2"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "timestamp": "2025-08-24 12:05:19.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "high",
            "section_id": "21428fb2-d6b0-4575-8f96-b84e832bdb50"
        },
        "id": "urGe2d8lU2tqPpPmjN6k"
    },
    {
        "source": "frontend",
        "event": "apply_instruction_summary",
        "timestamp": "2025-08-24 12:06:19.000",
        "data": {
            "detail_level": "high",
            "structured": "structured",
            "instruction": "The plot should be in grouped format: x-axis's range should be positive numbers, and the true and predicted rank should not be subtracted but they should be put together in the plot",
            "original_summary": "• Computes the prediction error by subtracting the true rank from the predicted rank for each player\n• Filters the DataFrame to include only records from the specified year\n  ◦ Makes a copy and sorts players by their true rank for clear visualization\n• Creates a bar plot using Seaborn:\n  ◦ Player names are shown on the x-axis, prediction errors on the y-axis\n  ◦ Each player's bar is colored distinctly using the 'coolwarm' palette\n• Adds a horizontal dashed line at y=0 to indicate perfect prediction\n• Rotates x-axis labels for readability and sets axis labels and plot title\n• Adjusts the layout to prevent overlap and saves the plot as a PNG file named with the target year (No changes from the previous version)",
            "section_id": "21428fb2-d6b0-4575-8f96-b84e832bdb50"
        },
        "id": "ardU6e6Iw6nSeh5bJ1Rj"
    },
    {
        "source": "backend",
        "event": "apply_instruction_summary",
        "timestamp": "2025-08-24 12:06:21.000",
        "data": {
            "original_code": "def plot_ranking_predictions(df, year):\n    \"\"\"\n    Plot prediction error for a specific year.\n\n    Args:\n        df: DataFrame containing prediction results\n        year: Year to plot prediction errors for\n    \"\"\"\n    df[\"RankError\"] = df[\"PredictedRank\"] - df[\"Rank\"]\n    year_df = df[df[\"Year\"] == year].copy()\n    year_df.sort_values(\"Rank\", inplace=True)\n\n    plt.figure(figsize=(12, 6))\n    sns.barplot(x=\"Name\", y=\"RankError\", data=year_df, hue=\"Name\", palette=\"coolwarm\", dodge=True)\n    plt.axhline(0, color=\"black\", linestyle=\"--\")\n    plt.xticks(rotation=45, ha=\"right\")\n    plt.ylabel(\"Predicted Rank - True Rank\")\n    plt.title(f\"MVP Ranking Predictions ({year})\")\n    plt.tight_layout()\n    plt.savefig(f\"data/ranking_predictions_{year}.png\")",
            "updated_summary": "• Plots both the true rank and predicted rank for each player side by side in a grouped bar format, without computing or displaying their difference  \n• The x-axis displays player names, and the y-axis shows positive rank values for both true and predicted ranks  \n• Filters the DataFrame to include only records from the specified year  \n  ◦ Makes a copy and sorts players by their true rank for clear visualization  \n• Creates a grouped bar plot using Seaborn:  \n  ◦ For each player, both their true rank and predicted rank are shown as separate bars next to each other  \n  ◦ Each bar is colored distinctly using the 'coolwarm' palette  \n• Rotates x-axis labels for readability and sets axis labels and plot title  \n• Adjusts the layout to prevent overlap and saves the plot as a PNG file named with the target year (No changes from the previous version)",
            "instruction": "The plot should be in grouped format: x-axis's range should be positive numbers, and the true and predicted rank should not be subtracted but they should be put together in the plot",
            "original_summary": "• Computes the prediction error by subtracting the true rank from the predicted rank for each player\n• Filters the DataFrame to include only records from the specified year\n  ◦ Makes a copy and sorts players by their true rank for clear visualization\n• Creates a bar plot using Seaborn:\n  ◦ Player names are shown on the x-axis, prediction errors on the y-axis\n  ◦ Each player's bar is colored distinctly using the 'coolwarm' palette\n• Adds a horizontal dashed line at y=0 to indicate perfect prediction\n• Rotates x-axis labels for readability and sets axis labels and plot title\n• Adjusts the layout to prevent overlap and saves the plot as a PNG file named with the target year (No changes from the previous version)"
        },
        "id": "pC8pglrALWT3E7EC2wSE"
    },
    {
        "source": "frontend",
        "event": "commit_modified_summary",
        "timestamp": "2025-08-24 12:06:36.000",
        "data": {
            "detail_level": "high",
            "structured": "structured",
            "edited_summary": "• Plots both the true rank and predicted rank for each player side by side in a grouped bar format, without computing or displaying their difference  \n• The x-axis displays player names, and the y-axis shows positive rank values for both true and predicted ranks  \n• Filters the DataFrame to include only records from the specified year  \n  ◦ Makes a copy and sorts players by their true rank for clear visualization  \n• Creates a grouped bar plot using Seaborn:  \n  ◦ For each player, both their true rank and predicted rank are shown as separate bars next to each other  \n  ◦ Each bar is colored distinctly using the 'coolwarm' palette  \n• Rotates x-axis labels for readability and sets axis labels and plot title  \n• Adjusts the layout to prevent overlap and saves the plot as a PNG file named with the target year (No changes from the previous version)",
            "original_summary": "• Computes the prediction error by subtracting the true rank from the predicted rank for each player\n• Filters the DataFrame to include only records from the specified year\n  ◦ Makes a copy and sorts players by their true rank for clear visualization\n• Creates a bar plot using Seaborn:\n  ◦ Player names are shown on the x-axis, prediction errors on the y-axis\n  ◦ Each player's bar is colored distinctly using the 'coolwarm' palette\n• Adds a horizontal dashed line at y=0 to indicate perfect prediction\n• Rotates x-axis labels for readability and sets axis labels and plot title\n• Adjusts the layout to prevent overlap and saves the plot as a PNG file named with the target year (No changes from the previous version)",
            "section_id": "21428fb2-d6b0-4575-8f96-b84e832bdb50"
        },
        "id": "WVeQqP9b4Ok9EAcPyYkH"
    },
    {
        "source": "backend",
        "event": "modify_summary_mediation",
        "timestamp": "2025-08-24 12:06:39.000",
        "data": {
            "original_code": "def plot_ranking_predictions(df, year):\n    \"\"\"\n    Plot prediction error for a specific year.\n\n    Args:\n        df: DataFrame containing prediction results\n        year: Year to plot prediction errors for\n    \"\"\"\n    df[\"RankError\"] = df[\"PredictedRank\"] - df[\"Rank\"]\n    year_df = df[df[\"Year\"] == year].copy()\n    year_df.sort_values(\"Rank\", inplace=True)\n\n    plt.figure(figsize=(12, 6))\n    sns.barplot(x=\"Name\", y=\"RankError\", data=year_df, hue=\"Name\", palette=\"coolwarm\", dodge=True)\n    plt.axhline(0, color=\"black\", linestyle=\"--\")\n    plt.xticks(rotation=45, ha=\"right\")\n    plt.ylabel(\"Predicted Rank - True Rank\")\n    plt.title(f\"MVP Ranking Predictions ({year})\")\n    plt.tight_layout()\n    plt.savefig(f\"data/ranking_predictions_{year}.png\")",
            "detail_level": "high",
            "edited_summary": "• Plots both the true rank and predicted rank for each player side by side in a grouped bar format, without computing or displaying their difference  \n• The x-axis displays player names, and the y-axis shows positive rank values for both true and predicted ranks  \n• Filters the DataFrame to include only records from the specified year  \n  ◦ Makes a copy and sorts players by their true rank for clear visualization  \n• Creates a grouped bar plot using Seaborn:  \n  ◦ For each player, both their true rank and predicted rank are shown as separate bars next to each other  \n  ◦ Each bar is colored distinctly using the 'coolwarm' palette  \n• Rotates x-axis labels for readability and sets axis labels and plot title  \n• Adjusts the layout to prevent overlap and saves the plot as a PNG file named with the target year (No changes from the previous version)",
            "original_summary": "• Computes the prediction error by subtracting the true rank from the predicted rank for each player\n• Filters the DataFrame to include only records from the specified year\n  ◦ Makes a copy and sorts players by their true rank for clear visualization\n• Creates a bar plot using Seaborn:\n  ◦ Player names are shown on the x-axis, prediction errors on the y-axis\n  ◦ Each player's bar is colored distinctly using the 'coolwarm' palette\n• Adds a horizontal dashed line at y=0 to indicate perfect prediction\n• Rotates x-axis labels for readability and sets axis labels and plot title\n• Adjusts the layout to prevent overlap and saves the plot as a PNG file named with the target year (No changes from the previous version)",
            "updated_code": "def plot_ranking_predictions(df, year):\n    \"\"\"\n    Plot true rank and predicted rank for a specific year in a grouped bar format.\n\n    Args:\n        df: DataFrame containing prediction results\n        year: Year to plot prediction results for\n    \"\"\"\n    year_df = df[df[\"Year\"] == year].copy()\n    year_df.sort_values(\"Rank\", inplace=True)\n\n    # Prepare data for grouped bar plot\n    plot_df = year_df[[\"Name\", \"Rank\", \"PredictedRank\"]].melt(\n        id_vars=\"Name\", value_vars=[\"Rank\", \"PredictedRank\"],\n        var_name=\"Type\", value_name=\"RankValue\"\n    )\n\n    plt.figure(figsize=(12, 6))\n    sns.barplot(\n        x=\"Name\", y=\"RankValue\", hue=\"Type\", data=plot_df,\n        palette=\"coolwarm\", dodge=True\n    )\n    plt.xticks(rotation=45, ha=\"right\")\n    plt.ylabel(\"Rank\")\n    plt.title(f\"MVP True vs Predicted Ranks ({year})\")\n    plt.tight_layout()\n    plt.savefig(f\"data/ranking_predictions_{year}.png\")",
            "structured_type": "structured"
        },
        "id": "L6PDki2NDZYGsh73f2Ts"
    },
    {
        "source": "backend",
        "event": "summarize_modified_code",
        "timestamp": "2025-08-24 12:06:54.000",
        "data": {
            "original_code": "def plot_ranking_predictions(df, year):\n    \"\"\"\n    Plot true rank and predicted rank for a specific year in a grouped bar format.\n\n    Args:\n        df: DataFrame containing prediction results\n        year: Year to plot prediction results for\n    \"\"\"\n    year_df = df[df[\"Year\"] == year].copy()\n    year_df.sort_values(\"Rank\", inplace=True)\n\n    # Prepare data for grouped bar plot\n    plot_df = year_df[[\"Name\", \"Rank\", \"PredictedRank\"]].melt(\n        id_vars=\"Name\", value_vars=[\"Rank\", \"PredictedRank\"],\n        var_name=\"Type\", value_name=\"RankValue\"\n    )\n\n    plt.figure(figsize=(12, 6))\n    sns.barplot(\n        x=\"Name\", y=\"RankValue\", hue=\"Type\", data=plot_df,\n        palette=\"coolwarm\", dodge=True\n    )\n    plt.xticks(rotation=45, ha=\"right\")\n    plt.ylabel(\"Rank\")\n    plt.title(f\"MVP True vs Predicted Ranks ({year})\")\n    plt.tight_layout()\n    plt.savefig(f\"data/ranking_predictions_{year}.png\")",
            "new_summary": {
                "medium_structured": "• Prepares data to show both predicted and true ranks for each player (no longer computes or plots prediction error)\n• Filters data for the specified year and sorts players by true rank\n• Plots a grouped bar chart of true and predicted ranks for each player\n  ◦ Uses player names on the x-axis and rank values on the y-axis, with bars grouped by type (true or predicted)\n• Saves the plot as a PNG file named for the year (now showing grouped bars for true and predicted ranks instead of error bars)",
                "low_unstructured": "This function plots the true and predicted player rankings for a specified year as grouped bars, rather than plotting the prediction error. (The function no longer visualizes prediction error, but instead directly compares true and predicted ranks.)",
                "high_structured": "• Prepares the data by melting true and predicted ranks into a long format for grouped bar plotting (no longer computes prediction error)\n• Filters the DataFrame to include only records from the specified year\n  ◦ Makes a copy and sorts players by their true rank for clear visualization\n• Creates a grouped bar plot using Seaborn:\n  ◦ Player names are shown on the x-axis, rank values on the y-axis\n  ◦ Bars are grouped and colored by 'Rank' and 'PredictedRank' using the 'coolwarm' palette\n• Rotates x-axis labels for readability and sets axis labels and plot title\n• Adjusts the layout to prevent overlap and saves the plot as a PNG file named with the target year (now visualizing grouped bars for true and predicted ranks instead of prediction error bars)",
                "low_structured": "• Plots true and predicted player ranks for a given year as grouped bars (replacing prediction error plot)\n• Uses player ranking data\n• Saves the plot as an image (now showing grouped bars for true and predicted ranks instead of error)",
                "high_unstructured": "The plot_ranking_predictions function now generates a grouped bar plot to visualize both the predicted and actual ranks for each player in a specified year, instead of showing the prediction error (PredictedRank minus actual Rank). It restructures the data to include both rank types, filters the DataFrame for the given year, and sorts players by their true rank. The function then creates a grouped bar plot with player names on the x-axis and rank values on the y-axis, using color to distinguish between true and predicted ranks. The plot's appearance is customized (such as rotating x-axis labels and setting the title), and the figure is saved as a PNG file in the data directory, named according to the year.",
                "medium_unstructured": "The plot_ranking_predictions function now visualizes both the predicted and actual player ranks for a specified year using a grouped bar plot, rather than plotting the prediction error. It creates a bar plot comparing true and predicted ranks for each player and saves the resulting figure as a PNG file. The plot helps assess ranking prediction performance for that year by direct comparison of ranks.",
                "title": "plot_ranking_predictions Function Summary"
            },
            "old_summary": {
                "medium_structured": "• Calculates prediction error as the difference between predicted and true ranks\n• Filters data for the specified year and sorts players by true rank\n• Plots a bar chart of prediction errors for each player\n  ◦ Uses player names on the x-axis and error on the y-axis\n• Saves the plot as a PNG file named for the year (No changes from the previous version)",
                "low_unstructured": "This function plots the prediction error for player rankings in a specified year. (No changes were made to the function.)",
                "high_structured": "• Computes the prediction error by subtracting the true rank from the predicted rank for each player\n• Filters the DataFrame to include only records from the specified year\n  ◦ Makes a copy and sorts players by their true rank for clear visualization\n• Creates a bar plot using Seaborn:\n  ◦ Player names are shown on the x-axis, prediction errors on the y-axis\n  ◦ Each player's bar is colored distinctly using the 'coolwarm' palette\n• Adds a horizontal dashed line at y=0 to indicate perfect prediction\n• Rotates x-axis labels for readability and sets axis labels and plot title\n• Adjusts the layout to prevent overlap and saves the plot as a PNG file named with the target year (No changes from the previous version)",
                "low_structured": "• Plots prediction error for a given year\n• Uses player ranking data\n• Saves the plot as an image (No changes from the previous version)",
                "high_unstructured": "The plot_ranking_predictions function generates a bar plot to visualize the prediction error (PredictedRank minus actual Rank) for each player in a specified year. It first computes the rank error, filters the DataFrame for the given year, and sorts players by their true rank. The function then creates a bar plot with player names on the x-axis and prediction error on the y-axis, adds a horizontal reference line at zero, and customizes the plot's appearance (such as rotating x-axis labels and setting the title). Finally, it saves the plot as a PNG file in the data directory, named according to the year. (No changes from the previous version.)",
                "medium_unstructured": "The plot_ranking_predictions function visualizes the difference between predicted and actual player ranks for a specified year. It creates a bar plot showing these errors for each player and saves the resulting figure as a PNG file. The plot helps assess ranking prediction performance for that year. (No changes from the previous version.)",
                "title": "plot_ranking_predictions Function Summary"
            },
            "new_code": "def plot_ranking_predictions(df, year):\n    \"\"\"\n    Plot true rank and predicted rank for a specific year in a grouped bar format.\n\n    Args:\n        df: DataFrame containing prediction results\n        year: Year to plot prediction results for\n    \"\"\"\n    year_df = df[df[\"Year\"] == year].copy()\n    year_df.sort_values(\"Rank\", inplace=True)\n\n    # Prepare data for grouped bar plot\n    plot_df = year_df[[\"Name\", \"Rank\", \"PredictedRank\"]].melt(\n        id_vars=\"Name\", value_vars=[\"Rank\", \"PredictedRank\"],\n        var_name=\"Type\", value_name=\"RankValue\"\n    )\n\n    plt.figure(figsize=(12, 6))\n    sns.barplot(\n        x=\"Name\", y=\"RankValue\", hue=\"Type\", data=plot_df,\n        palette=\"coolwarm\", dodge=True\n    )\n    plt.xticks(rotation=45, ha=\"right\")\n    plt.ylabel(\"Rank\")\n    plt.title(f\"MVP True vs Predicted Ranks ({year})\")\n    plt.tight_layout()\n    plt.savefig(f\"data/ranking_predictions_{year}.png\")"
        },
        "id": "do9kzlRM2BL94G5sMxjK"
    },
    {
        "source": "backend",
        "event": "map_summary_code",
        "timestamp": "2025-08-24 12:06:56.000",
        "data": {
            "summary": "This function plots the true and predicted player rankings for a specified year as grouped bars, rather than plotting the prediction error. (The function no longer visualizes prediction error, but instead directly compares true and predicted ranks.)",
            "code": "52: def plot_ranking_predictions(df, year):\n53:     \"\"\"\n54:     Plot true rank and predicted rank for a specific year in a grouped bar format.\n55: \n56:     Args:\n57:         df: DataFrame containing prediction results\n58:         year: Year to plot prediction results for\n59:     \"\"\"\n60:     year_df = df[df[\"Year\"] == year].copy()\n61:     year_df.sort_values(\"Rank\", inplace=True)\n62: \n63:     # Prepare data for grouped bar plot\n64:     plot_df = year_df[[\"Name\", \"Rank\", \"PredictedRank\"]].melt(\n65:         id_vars=\"Name\", value_vars=[\"Rank\", \"PredictedRank\"],\n66:         var_name=\"Type\", value_name=\"RankValue\"\n67:     )\n68: \n69:     plt.figure(figsize=(12, 6))\n70:     sns.barplot(\n71:         x=\"Name\", y=\"RankValue\", hue=\"Type\", data=plot_df,\n72:         palette=\"coolwarm\", dodge=True\n73:     )\n74:     plt.xticks(rotation=45, ha=\"right\")\n75:     plt.ylabel(\"Rank\")\n76:     plt.title(f\"MVP True vs Predicted Ranks ({year})\")\n77:     plt.tight_layout()\n78:     plt.savefig(f\"data/ranking_predictions_{year}.png\")",
            "mapping": [
                {
                    "summaryComponent": "plots the true and predicted player rankings",
                    "codeSegments": [
                        {
                            "code": "plot_df = year_df[[\"Name\", \"Rank\", \"PredictedRank\"]].melt(",
                            "line": 64
                        },
                        {
                            "code": "sns.barplot(",
                            "line": 70
                        }
                    ]
                },
                {
                    "summaryComponent": "for a specified year",
                    "codeSegments": [
                        {
                            "code": "year_df = df[df[\"Year\"] == year].copy()",
                            "line": 60
                        }
                    ]
                },
                {
                    "summaryComponent": "as grouped bars",
                    "codeSegments": [
                        {
                            "code": "sns.barplot(",
                            "line": 70
                        },
                        {
                            "code": "dodge=True",
                            "line": 72
                        }
                    ]
                },
                {
                    "summaryComponent": "rather than plotting the prediction error",
                    "codeSegments": [
                        {
                            "code": "# ... directly compares true and predicted ranks.",
                            "line": 55
                        }
                    ]
                },
                {
                    "summaryComponent": "directly compares true and predicted ranks",
                    "codeSegments": [
                        {
                            "code": "plot_df = year_df[[\"Name\", \"Rank\", \"PredictedRank\"]].melt(",
                            "line": 64
                        },
                        {
                            "code": "sns.barplot(",
                            "line": 70
                        }
                    ]
                }
            ]
        },
        "id": "7tQ1Et51Kkk2B1Hv4bF4"
    },
    {
        "source": "backend",
        "event": "map_summary_code",
        "timestamp": "2025-08-24 12:06:56.000",
        "data": {
            "summary": "• Plots true and predicted player ranks for a given year as grouped bars (replacing prediction error plot)\n• Uses player ranking data\n• Saves the plot as an image (now showing grouped bars for true and predicted ranks instead of error)",
            "code": "52: def plot_ranking_predictions(df, year):\n53:     \"\"\"\n54:     Plot true rank and predicted rank for a specific year in a grouped bar format.\n55: \n56:     Args:\n57:         df: DataFrame containing prediction results\n58:         year: Year to plot prediction results for\n59:     \"\"\"\n60:     year_df = df[df[\"Year\"] == year].copy()\n61:     year_df.sort_values(\"Rank\", inplace=True)\n62: \n63:     # Prepare data for grouped bar plot\n64:     plot_df = year_df[[\"Name\", \"Rank\", \"PredictedRank\"]].melt(\n65:         id_vars=\"Name\", value_vars=[\"Rank\", \"PredictedRank\"],\n66:         var_name=\"Type\", value_name=\"RankValue\"\n67:     )\n68: \n69:     plt.figure(figsize=(12, 6))\n70:     sns.barplot(\n71:         x=\"Name\", y=\"RankValue\", hue=\"Type\", data=plot_df,\n72:         palette=\"coolwarm\", dodge=True\n73:     )\n74:     plt.xticks(rotation=45, ha=\"right\")\n75:     plt.ylabel(\"Rank\")\n76:     plt.title(f\"MVP True vs Predicted Ranks ({year})\")\n77:     plt.tight_layout()\n78:     plt.savefig(f\"data/ranking_predictions_{year}.png\")",
            "mapping": [
                {
                    "summaryComponent": "Plots true and predicted player ranks for a given year as grouped bars (replacing prediction error plot)",
                    "codeSegments": [
                        {
                            "code": "def plot_ranking_predictions(df, year):",
                            "line": 52
                        },
                        {
                            "code": "year_df = df[df[\"Year\"] == year].copy()",
                            "line": 60
                        },
                        {
                            "code": "plot_df = year_df[[\"Name\", \"Rank\", \"PredictedRank\"]].melt(",
                            "line": 64
                        },
                        {
                            "code": "sns.barplot(",
                            "line": 70
                        }
                    ]
                },
                {
                    "summaryComponent": "Uses player ranking data",
                    "codeSegments": [
                        {
                            "code": "year_df = df[df[\"Year\"] == year].copy()",
                            "line": 60
                        },
                        {
                            "code": "plot_df = year_df[[\"Name\", \"Rank\", \"PredictedRank\"]].melt(",
                            "line": 64
                        }
                    ]
                },
                {
                    "summaryComponent": "Saves the plot as an image (now showing grouped bars for true and predicted ranks instead of error)",
                    "codeSegments": [
                        {
                            "code": "plt.savefig(f\"data/ranking_predictions_{year}.png\")",
                            "line": 78
                        }
                    ]
                }
            ]
        },
        "id": "tGAmycHx2kRZQvukOJRs"
    },
    {
        "source": "backend",
        "event": "map_summary_code",
        "timestamp": "2025-08-24 12:06:57.000",
        "data": {
            "summary": "• Prepares data to show both predicted and true ranks for each player (no longer computes or plots prediction error)\n• Filters data for the specified year and sorts players by true rank\n• Plots a grouped bar chart of true and predicted ranks for each player\n  ◦ Uses player names on the x-axis and rank values on the y-axis, with bars grouped by type (true or predicted)\n• Saves the plot as a PNG file named for the year (now showing grouped bars for true and predicted ranks instead of error bars)",
            "code": "52: def plot_ranking_predictions(df, year):\n53:     \"\"\"\n54:     Plot true rank and predicted rank for a specific year in a grouped bar format.\n55: \n56:     Args:\n57:         df: DataFrame containing prediction results\n58:         year: Year to plot prediction results for\n59:     \"\"\"\n60:     year_df = df[df[\"Year\"] == year].copy()\n61:     year_df.sort_values(\"Rank\", inplace=True)\n62: \n63:     # Prepare data for grouped bar plot\n64:     plot_df = year_df[[\"Name\", \"Rank\", \"PredictedRank\"]].melt(\n65:         id_vars=\"Name\", value_vars=[\"Rank\", \"PredictedRank\"],\n66:         var_name=\"Type\", value_name=\"RankValue\"\n67:     )\n68: \n69:     plt.figure(figsize=(12, 6))\n70:     sns.barplot(\n71:         x=\"Name\", y=\"RankValue\", hue=\"Type\", data=plot_df,\n72:         palette=\"coolwarm\", dodge=True\n73:     )\n74:     plt.xticks(rotation=45, ha=\"right\")\n75:     plt.ylabel(\"Rank\")\n76:     plt.title(f\"MVP True vs Predicted Ranks ({year})\")\n77:     plt.tight_layout()\n78:     plt.savefig(f\"data/ranking_predictions_{year}.png\")",
            "mapping": [
                {
                    "summaryComponent": "Prepares data to show both predicted and true ranks for each player",
                    "codeSegments": [
                        {
                            "code": "plot_df = year_df[[\"Name\", \"Rank\", \"PredictedRank\"]].melt(",
                            "line": 64
                        },
                        {
                            "code": "id_vars=\"Name\", value_vars=[\"Rank\", \"PredictedRank\"],",
                            "line": 65
                        },
                        {
                            "code": "var_name=\"Type\", value_name=\"RankValue\"",
                            "line": 66
                        }
                    ]
                },
                {
                    "summaryComponent": "(no longer computes or plots prediction error)",
                    "codeSegments": []
                },
                {
                    "summaryComponent": "Filters data for the specified year and sorts players by true rank",
                    "codeSegments": [
                        {
                            "code": "year_df = df[df[\"Year\"] == year].copy()",
                            "line": 60
                        },
                        {
                            "code": "year_df.sort_values(\"Rank\", inplace=True)",
                            "line": 61
                        }
                    ]
                },
                {
                    "summaryComponent": "Plots a grouped bar chart of true and predicted ranks for each player",
                    "codeSegments": [
                        {
                            "code": "sns.barplot(",
                            "line": 70
                        },
                        {
                            "code": "x=\"Name\", y=\"RankValue\", hue=\"Type\", data=plot_df,",
                            "line": 71
                        }
                    ]
                },
                {
                    "summaryComponent": "Uses player names on the x-axis and rank values on the y-axis, with bars grouped by type (true or predicted)",
                    "codeSegments": [
                        {
                            "code": "x=\"Name\", y=\"RankValue\", hue=\"Type\", data=plot_df,",
                            "line": 71
                        }
                    ]
                },
                {
                    "summaryComponent": "Saves the plot as a PNG file named for the year",
                    "codeSegments": [
                        {
                            "code": "plt.savefig(f\"data/ranking_predictions_{year}.png\")",
                            "line": 78
                        }
                    ]
                },
                {
                    "summaryComponent": "(now showing grouped bars for true and predicted ranks instead of error bars)",
                    "codeSegments": []
                }
            ]
        },
        "id": "9ml9TAOz1v9UCTFok0Cj"
    },
    {
        "source": "backend",
        "event": "map_summary_code",
        "timestamp": "2025-08-24 12:06:58.000",
        "data": {
            "summary": "The plot_ranking_predictions function now generates a grouped bar plot to visualize both the predicted and actual ranks for each player in a specified year, instead of showing the prediction error (PredictedRank minus actual Rank). It restructures the data to include both rank types, filters the DataFrame for the given year, and sorts players by their true rank. The function then creates a grouped bar plot with player names on the x-axis and rank values on the y-axis, using color to distinguish between true and predicted ranks. The plot's appearance is customized (such as rotating x-axis labels and setting the title), and the figure is saved as a PNG file in the data directory, named according to the year.",
            "code": "52: def plot_ranking_predictions(df, year):\n53:     \"\"\"\n54:     Plot true rank and predicted rank for a specific year in a grouped bar format.\n55: \n56:     Args:\n57:         df: DataFrame containing prediction results\n58:         year: Year to plot prediction results for\n59:     \"\"\"\n60:     year_df = df[df[\"Year\"] == year].copy()\n61:     year_df.sort_values(\"Rank\", inplace=True)\n62: \n63:     # Prepare data for grouped bar plot\n64:     plot_df = year_df[[\"Name\", \"Rank\", \"PredictedRank\"]].melt(\n65:         id_vars=\"Name\", value_vars=[\"Rank\", \"PredictedRank\"],\n66:         var_name=\"Type\", value_name=\"RankValue\"\n67:     )\n68: \n69:     plt.figure(figsize=(12, 6))\n70:     sns.barplot(\n71:         x=\"Name\", y=\"RankValue\", hue=\"Type\", data=plot_df,\n72:         palette=\"coolwarm\", dodge=True\n73:     )\n74:     plt.xticks(rotation=45, ha=\"right\")\n75:     plt.ylabel(\"Rank\")\n76:     plt.title(f\"MVP True vs Predicted Ranks ({year})\")\n77:     plt.tight_layout()\n78:     plt.savefig(f\"data/ranking_predictions_{year}.png\")",
            "mapping": [
                {
                    "summaryComponent": "The plot_ranking_predictions function now generates a grouped bar plot",
                    "codeSegments": [
                        {
                            "code": "def plot_ranking_predictions(df, year):",
                            "line": 52
                        },
                        {
                            "code": "sns.barplot(",
                            "line": 70
                        }
                    ]
                },
                {
                    "summaryComponent": "to visualize both the predicted and actual ranks for each player in a specified year",
                    "codeSegments": [
                        {
                            "code": "year_df = df[df[\"Year\"] == year].copy()",
                            "line": 60
                        },
                        {
                            "code": "plot_df = year_df[[\"Name\", \"Rank\", \"PredictedRank\"]].melt(",
                            "line": 64
                        }
                    ]
                },
                {
                    "summaryComponent": "instead of showing the prediction error (PredictedRank minus actual Rank)",
                    "codeSegments": [
                        {
                            "code": "\"PredictedRank\"",
                            "line": 65
                        }
                    ]
                },
                {
                    "summaryComponent": "It restructures the data to include both rank types",
                    "codeSegments": [
                        {
                            "code": "plot_df = year_df[[\"Name\", \"Rank\", \"PredictedRank\"]].melt(",
                            "line": 64
                        }
                    ]
                },
                {
                    "summaryComponent": "filters the DataFrame for the given year",
                    "codeSegments": [
                        {
                            "code": "year_df = df[df[\"Year\"] == year].copy()",
                            "line": 60
                        }
                    ]
                },
                {
                    "summaryComponent": "and sorts players by their true rank",
                    "codeSegments": [
                        {
                            "code": "year_df.sort_values(\"Rank\", inplace=True)",
                            "line": 61
                        }
                    ]
                },
                {
                    "summaryComponent": "The function then creates a grouped bar plot with player names on the x-axis and rank values on the y-axis",
                    "codeSegments": [
                        {
                            "code": "sns.barplot(",
                            "line": 70
                        },
                        {
                            "code": "x=\"Name\", y=\"RankValue\", hue=\"Type\", data=plot_df,",
                            "line": 71
                        }
                    ]
                },
                {
                    "summaryComponent": "using color to distinguish between true and predicted ranks",
                    "codeSegments": [
                        {
                            "code": "palette=\"coolwarm\", dodge=True",
                            "line": 72
                        }
                    ]
                },
                {
                    "summaryComponent": "The plot's appearance is customized (such as rotating x-axis labels and setting the title)",
                    "codeSegments": [
                        {
                            "code": "plt.xticks(rotation=45, ha=\"right\")",
                            "line": 74
                        },
                        {
                            "code": "plt.title(f\"MVP True vs Predicted Ranks ({year})\")",
                            "line": 76
                        }
                    ]
                },
                {
                    "summaryComponent": "and the figure is saved as a PNG file in the data directory, named according to the year.",
                    "codeSegments": [
                        {
                            "code": "plt.savefig(f\"data/ranking_predictions_{year}.png\")",
                            "line": 78
                        }
                    ]
                }
            ]
        },
        "id": "AsGZawTJuiYSjmrpQcfw"
    },
    {
        "source": "backend",
        "event": "map_summary_code",
        "timestamp": "2025-08-24 12:06:58.000",
        "data": {
            "summary": "• Prepares the data by melting true and predicted ranks into a long format for grouped bar plotting (no longer computes prediction error)\n• Filters the DataFrame to include only records from the specified year\n  ◦ Makes a copy and sorts players by their true rank for clear visualization\n• Creates a grouped bar plot using Seaborn:\n  ◦ Player names are shown on the x-axis, rank values on the y-axis\n  ◦ Bars are grouped and colored by 'Rank' and 'PredictedRank' using the 'coolwarm' palette\n• Rotates x-axis labels for readability and sets axis labels and plot title\n• Adjusts the layout to prevent overlap and saves the plot as a PNG file named with the target year (now visualizing grouped bars for true and predicted ranks instead of prediction error bars)",
            "code": "52: def plot_ranking_predictions(df, year):\n53:     \"\"\"\n54:     Plot true rank and predicted rank for a specific year in a grouped bar format.\n55: \n56:     Args:\n57:         df: DataFrame containing prediction results\n58:         year: Year to plot prediction results for\n59:     \"\"\"\n60:     year_df = df[df[\"Year\"] == year].copy()\n61:     year_df.sort_values(\"Rank\", inplace=True)\n62: \n63:     # Prepare data for grouped bar plot\n64:     plot_df = year_df[[\"Name\", \"Rank\", \"PredictedRank\"]].melt(\n65:         id_vars=\"Name\", value_vars=[\"Rank\", \"PredictedRank\"],\n66:         var_name=\"Type\", value_name=\"RankValue\"\n67:     )\n68: \n69:     plt.figure(figsize=(12, 6))\n70:     sns.barplot(\n71:         x=\"Name\", y=\"RankValue\", hue=\"Type\", data=plot_df,\n72:         palette=\"coolwarm\", dodge=True\n73:     )\n74:     plt.xticks(rotation=45, ha=\"right\")\n75:     plt.ylabel(\"Rank\")\n76:     plt.title(f\"MVP True vs Predicted Ranks ({year})\")\n77:     plt.tight_layout()\n78:     plt.savefig(f\"data/ranking_predictions_{year}.png\")",
            "mapping": [
                {
                    "summaryComponent": "Prepares the data by melting true and predicted ranks into a long format for grouped bar plotting",
                    "codeSegments": [
                        {
                            "code": "plot_df = year_df[[\"Name\", \"Rank\", \"PredictedRank\"]].melt(",
                            "line": 64
                        },
                        {
                            "code": "    id_vars=\"Name\", value_vars=[\"Rank\", \"PredictedRank\"],",
                            "line": 65
                        },
                        {
                            "code": "    var_name=\"Type\", value_name=\"RankValue\"",
                            "line": 66
                        },
                        {
                            "code": ")",
                            "line": 67
                        }
                    ]
                },
                {
                    "summaryComponent": "Filters the DataFrame to include only records from the specified year",
                    "codeSegments": [
                        {
                            "code": "year_df = df[df[\"Year\"] == year].copy()",
                            "line": 60
                        }
                    ]
                },
                {
                    "summaryComponent": "Makes a copy and sorts players by their true rank for clear visualization",
                    "codeSegments": [
                        {
                            "code": "year_df = df[df[\"Year\"] == year].copy()",
                            "line": 60
                        },
                        {
                            "code": "year_df.sort_values(\"Rank\", inplace=True)",
                            "line": 61
                        }
                    ]
                },
                {
                    "summaryComponent": "Creates a grouped bar plot using Seaborn:",
                    "codeSegments": [
                        {
                            "code": "sns.barplot(",
                            "line": 70
                        },
                        {
                            "code": "    x=\"Name\", y=\"RankValue\", hue=\"Type\", data=plot_df,",
                            "line": 71
                        },
                        {
                            "code": "    palette=\"coolwarm\", dodge=True",
                            "line": 72
                        },
                        {
                            "code": ")",
                            "line": 73
                        }
                    ]
                },
                {
                    "summaryComponent": "Player names are shown on the x-axis, rank values on the y-axis",
                    "codeSegments": [
                        {
                            "code": "x=\"Name\", y=\"RankValue\"",
                            "line": 71
                        }
                    ]
                },
                {
                    "summaryComponent": "Bars are grouped and colored by 'Rank' and 'PredictedRank' using the 'coolwarm' palette",
                    "codeSegments": [
                        {
                            "code": "hue=\"Type\"",
                            "line": 71
                        },
                        {
                            "code": "palette=\"coolwarm\"",
                            "line": 72
                        }
                    ]
                },
                {
                    "summaryComponent": "Rotates x-axis labels for readability and sets axis labels and plot title",
                    "codeSegments": [
                        {
                            "code": "plt.xticks(rotation=45, ha=\"right\")",
                            "line": 74
                        },
                        {
                            "code": "plt.ylabel(\"Rank\")",
                            "line": 75
                        },
                        {
                            "code": "plt.title(f\"MVP True vs Predicted Ranks ({year})\")",
                            "line": 76
                        }
                    ]
                },
                {
                    "summaryComponent": "Adjusts the layout to prevent overlap and saves the plot as a PNG file named with the target year",
                    "codeSegments": [
                        {
                            "code": "plt.tight_layout()",
                            "line": 77
                        },
                        {
                            "code": "plt.savefig(f\"data/ranking_predictions_{year}.png\")",
                            "line": 78
                        }
                    ]
                }
            ]
        },
        "id": "yMsIekqf52bvGXpi7jS3"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "timestamp": "2025-08-24 12:07:16.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "high",
            "section_id": "21428fb2-d6b0-4575-8f96-b84e832bdb50"
        },
        "id": "4gafDRbOLCLIFTZYwwH9"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "timestamp": "2025-08-24 12:07:16.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "high",
            "mapping_index": 0,
            "section_id": "21428fb2-d6b0-4575-8f96-b84e832bdb50"
        },
        "id": "MYRmqL0mVuuWpFQ3DmBR"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "timestamp": "2025-08-24 12:07:16.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "high",
            "section_id": "21428fb2-d6b0-4575-8f96-b84e832bdb50"
        },
        "id": "bCWGTGIeZ9WQFo0eUUjB"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "timestamp": "2025-08-24 12:07:16.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "high",
            "section_id": "21428fb2-d6b0-4575-8f96-b84e832bdb50"
        },
        "id": "gvVsj8gGvv7VYUMBlIQJ"
    },
    {
        "source": "frontend",
        "event": "mapping_unhover",
        "timestamp": "2025-08-24 12:07:16.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "high",
            "section_id": "21428fb2-d6b0-4575-8f96-b84e832bdb50"
        },
        "id": "htEDtl9rg3m4zVHfQa8V"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "timestamp": "2025-08-24 12:07:16.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "high",
            "mapping_index": 3,
            "section_id": "21428fb2-d6b0-4575-8f96-b84e832bdb50"
        },
        "id": "ohKzpOv44R1TvDCeT2Mi"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "timestamp": "2025-08-24 12:07:16.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "high",
            "mapping_index": 1,
            "section_id": "21428fb2-d6b0-4575-8f96-b84e832bdb50"
        },
        "id": "xf2fX3coRUOpeBceVPx0"
    },
    {
        "source": "frontend",
        "event": "mapping_hover",
        "timestamp": "2025-08-24 12:07:16.000",
        "data": {
            "structured_type": "structured",
            "detail_level": "high",
            "mapping_index": 2,
            "section_id": "21428fb2-d6b0-4575-8f96-b84e832bdb50"
        },
        "id": "xgMNIDULad0vL0nyzpuw"
    }
]