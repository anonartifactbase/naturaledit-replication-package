[
  {
    "id": "FD-A",
    "file_path": "FinanceDashboard/frontend/src/StockChart.jsx",
    "old_code": "  const formatDateString = (date) => {\n    return date.split(\"T\")[0];\n  };",
    "old_context": "import React from \"react\";\nimport {\n  LineChart,\n  Line,\n  XAxis,\n  YAxis,\n  Tooltip,\n  Legend,\n  ResponsiveContainer,\n  ReferenceLine,\n} from \"recharts\";\n\nconst StockChart = ({ data }) => {\n  if (!data || !data.data || !data.data.length) return null;\n\n  const company = data.name;\n  const ticker = data.ticker;\n\n  const formatDateString = (date) => {\n    return date.split(\"T\")[0];\n  };\n\n  // Combine labels and values into an array of objects for Recharts\n  const chartData = data.data.map((item) => ({\n    date: item.date,\n    price: item.close,\n  }));\n\n  return (\n    <div style={{ marginTop: \"2rem\" }}>\n      <h3>\n        {company} ({ticker})\n      </h3>\n      <ResponsiveContainer width=\"100%\" height={300}>\n        <LineChart\n          data={chartData}\n          margin={{ top: 10, right: 30, left: 0, bottom: 0 }}\n        >\n          <XAxis dataKey=\"date\" />\n          <YAxis domain={[\"auto\", \"auto\"]} />\n          <Tooltip />\n          <Legend />\n          <Line type=\"monotone\" dataKey=\"price\" stroke=\"#8884d8\" dot={false} />\n        </LineChart>\n      </ResponsiveContainer>\n    </div>\n  );\n};\n\nexport default StockChart;",
    "old_start_line": "19",
    "new_code": "  const formatDateString = (date) => {\n    const options = { month: \"short\" };\n    return new Date(date).toLocaleDateString(\"en-US\", options);\n  };",
    "new_context": "import React from \"react\";\nimport {\n  LineChart,\n  Line,\n  XAxis,\n  YAxis,\n  Tooltip,\n  Legend,\n  ResponsiveContainer,\n  ReferenceLine,\n} from \"recharts\";\n\nconst StockChart = ({ data }) => {\n  if (!data || !data.data || !data.data.length) return null;\n\n  const company = data.name;\n  const ticker = data.ticker;\n\n  const formatDateString = (date) => {\n    const options = { month: \"short\" };\n    return new Date(date).toLocaleDateString(\"en-US\", options);\n  };\n\n  // Combine labels and values into an array of objects for Recharts\n  const chartData = data.data.map((item) => ({\n    date: item.date,\n    price: item.close,\n  }));\n\n  const currentPrice = data.currentPrice;\n\n  return (\n    <div style={{ marginTop: \"2rem\" }}>\n      <h3>\n        {company} ({ticker})\n      </h3>\n      <ResponsiveContainer width=\"100%\" height={300}>\n        <LineChart\n          data={chartData}\n          margin={{ top: 10, right: 30, left: 0, bottom: 0 }}\n        >\n          <XAxis dataKey=\"date\" tickFormatter={formatDateString} />\n          <YAxis domain={[\"auto\", \"auto\"]} />\n          <Tooltip />\n          <Legend />\n          <Line type=\"monotone\" dataKey=\"price\" stroke=\"#8884d8\" dot={false} />\n          <ReferenceLine\n            y={currentPrice}\n            stroke=\"red\"\n            strokeDasharray=\"5 5\"\n          />{\" \"}\n        </LineChart>\n      </ResponsiveContainer>\n    </div>\n  );\n};\n\nexport default StockChart;",
    "new_start_line": "19"
  },
  {
    "id": "FD-B",
    "file_path": "FinanceDashboard/server/index.js",
    "old_code": "app.get(\"/api/stock/:symbol\", async (req, res) => {\n  try {\n    const symbol = req.params.symbol.toUpperCase();\n    const data = await yahooFinance.chart(symbol, {\n      period1: \"2024-01-01\",\n      interval: \"1d\",\n    });\n    const quotes = data.quotes;\n\n    const companyName = data.meta?.shortName || symbol;\n\n    const response = {\n      ticker: symbol,\n      name: companyName,\n      data: quotes.map((q) => ({\n        date: q.date,\n        close: q.close,\n        volume: q.volume,\n      })),\n    };\n\n    console.log(response);\n    res.json(response);\n  } catch (err) {\n    console.error(err);\n    res.status(500).send(\"Error fetching stock data\");\n  }\n});",
    "old_context": "const express = require(\"express\");\nconst cors = require(\"cors\");\nconst yahooFinance = require(\"yahoo-finance2\").default;\n\nconst app = express();\nconst PORT = 3000;\n\napp.use(cors());\napp.use(express.json());\n\napp.get(\"/api/hello\", (req, res) => {\n  res.json({ message: \"Hello from the backend!\" });\n});\n\napp.get(\"/api/stock/:symbol\", async (req, res) => {\n  try {\n    const symbol = req.params.symbol.toUpperCase();\n    const data = await yahooFinance.chart(symbol, {\n      period1: \"2024-01-01\",\n      interval: \"1d\",\n    });\n    const quotes = data.quotes;\n\n    const companyName = data.meta?.shortName || symbol;\n\n    const response = {\n      ticker: symbol,\n      name: companyName,\n      data: quotes.map((q) => ({\n        date: q.date,\n        close: q.close,\n        volume: q.volume,\n      })),\n    };\n\n    console.log(response);\n    res.json(response);\n  } catch (err) {\n    console.error(err);\n    res.status(500).send(\"Error fetching stock data\");\n  }\n});\n\napp.listen(PORT, \"0.0.0.0\", () => {\n  console.log(`Server running on http://localhost:${PORT}`);\n});",
    "old_start_line": "15",
    "new_code": "app.get(\"/api/stock/:symbol\", async (req, res) => {\n  try {\n    const symbol = req.params.symbol.toUpperCase();\n    const data = await yahooFinance.chart(symbol, {\n      period1: \"2024-01-01\",\n      interval: \"1d\",\n    });\n    const quotes = data.quotes;\n\n    const companyName = data.meta?.shortName || symbol;\n    const currentPrice = quotes[quotes.length - 1]?.close || null;\n\n    const response = {\n      ticker: symbol,\n      name: companyName,\n      currentPrice: currentPrice,\n      data: quotes.map((q) => ({\n        date: q.date,\n        close: q.close,\n        volume: q.volume,\n      })),\n    };\n\n    console.log(response);\n    res.json(response);\n  } catch (err) {\n    console.error(err);\n    res.status(500).send(\"Error fetching stock data\");\n  }\n});",
    "new_context": "const express = require(\"express\");\nconst cors = require(\"cors\");\nconst yahooFinance = require(\"yahoo-finance2\").default;\n\nconst app = express();\nconst PORT = 3000;\n\napp.use(cors());\napp.use(express.json());\n\napp.get(\"/api/hello\", (req, res) => {\n  res.json({ message: \"Hello from the backend!\" });\n});\n\napp.get(\"/api/stock/:symbol\", async (req, res) => {\n  try {\n    const symbol = req.params.symbol.toUpperCase();\n    const data = await yahooFinance.chart(symbol, {\n      period1: \"2024-01-01\",\n      interval: \"1d\",\n    });\n    const quotes = data.quotes;\n\n    const companyName = data.meta?.shortName || symbol;\n    const currentPrice = quotes[quotes.length - 1]?.close || null;\n\n    const response = {\n      ticker: symbol,\n      name: companyName,\n      currentPrice: currentPrice,\n      data: quotes.map((q) => ({\n        date: q.date,\n        close: q.close,\n        volume: q.volume,\n      })),\n    };\n\n    console.log(response);\n    res.json(response);\n  } catch (err) {\n    console.error(err);\n    res.status(500).send(\"Error fetching stock data\");\n  }\n});\n\napp.listen(PORT, \"0.0.0.0\", () => {\n  console.log(`Server running on http://localhost:${PORT}`);\n});",
    "new_start_line": "15"
  },
  {
    "id": "FD-C",
    "file_path": "FinanceDashboard/frontend/src/StockChart.jsx",
    "old_code": "        <LineChart\n          data={chartData}\n          margin={{ top: 10, right: 30, left: 0, bottom: 0 }}\n        >\n          <XAxis dataKey=\"date\" />\n          <YAxis domain={[\"auto\", \"auto\"]} />\n          <Tooltip />\n          <Legend />\n          <Line type=\"monotone\" dataKey=\"price\" stroke=\"#8884d8\" dot={false} />\n        </LineChart>",
    "old_context": "import React from \"react\";\nimport {\n  LineChart,\n  Line,\n  XAxis,\n  YAxis,\n  Tooltip,\n  Legend,\n  ResponsiveContainer,\n  ReferenceLine,\n} from \"recharts\";\n\nconst StockChart = ({ data }) => {\n  if (!data || !data.data || !data.data.length) return null;\n\n  const company = data.name;\n  const ticker = data.ticker;\n\n  const formatDateString = (date) => {\n    return date.split(\"T\")[0];\n  };\n\n  // Combine labels and values into an array of objects for Recharts\n  const chartData = data.data.map((item) => ({\n    date: item.date,\n    price: item.close,\n  }));\n\n  return (\n    <div style={{ marginTop: \"2rem\" }}>\n      <h3>\n        {company} ({ticker})\n      </h3>\n      <ResponsiveContainer width=\"100%\" height={300}>\n        <LineChart\n          data={chartData}\n          margin={{ top: 10, right: 30, left: 0, bottom: 0 }}\n        >\n          <XAxis dataKey=\"date\" />\n          <YAxis domain={[\"auto\", \"auto\"]} />\n          <Tooltip />\n          <Legend />\n          <Line type=\"monotone\" dataKey=\"price\" stroke=\"#8884d8\" dot={false} />\n        </LineChart>\n      </ResponsiveContainer>\n    </div>\n  );\n};\n\nexport default StockChart;",
    "old_start_line": "35",
    "new_code": "        <LineChart\n          data={chartData}\n          margin={{ top: 10, right: 30, left: 0, bottom: 0 }}\n        >\n          <XAxis dataKey=\"date\" tickFormatter={formatDateString} />\n          <YAxis domain={[\"auto\", \"auto\"]} />\n          <Tooltip />\n          <Legend />\n          <Line type=\"monotone\" dataKey=\"price\" stroke=\"#8884d8\" dot={false} />\n          <ReferenceLine\n            y={currentPrice}\n            stroke=\"red\"\n            strokeDasharray=\"5 5\"\n          />{\" \"}\n        </LineChart>",
    "new_context": "import React from \"react\";\nimport {\n  LineChart,\n  Line,\n  XAxis,\n  YAxis,\n  Tooltip,\n  Legend,\n  ResponsiveContainer,\n  ReferenceLine,\n} from \"recharts\";\n\nconst StockChart = ({ data }) => {\n  if (!data || !data.data || !data.data.length) return null;\n\n  const company = data.name;\n  const ticker = data.ticker;\n\n  const formatDateString = (date) => {\n    const options = { month: \"short\" };\n    return new Date(date).toLocaleDateString(\"en-US\", options);\n  };\n\n  // Combine labels and values into an array of objects for Recharts\n  const chartData = data.data.map((item) => ({\n    date: item.date,\n    price: item.close,\n  }));\n\n  const currentPrice = data.currentPrice;\n\n  return (\n    <div style={{ marginTop: \"2rem\" }}>\n      <h3>\n        {company} ({ticker})\n      </h3>\n      <ResponsiveContainer width=\"100%\" height={300}>\n        <LineChart\n          data={chartData}\n          margin={{ top: 10, right: 30, left: 0, bottom: 0 }}\n        >\n          <XAxis dataKey=\"date\" tickFormatter={formatDateString} />\n          <YAxis domain={[\"auto\", \"auto\"]} />\n          <Tooltip />\n          <Legend />\n          <Line type=\"monotone\" dataKey=\"price\" stroke=\"#8884d8\" dot={false} />\n          <ReferenceLine\n            y={currentPrice}\n            stroke=\"red\"\n            strokeDasharray=\"5 5\"\n          />{\" \"}\n        </LineChart>\n      </ResponsiveContainer>\n    </div>\n  );\n};\n\nexport default StockChart;",
    "new_start_line": "38"
  },
  {
    "id": "MP-A",
    "file_path": "MVPPredictor/scraper.py",
    "old_code": "def scrape_season_stats(year):\n    base_url_reg = (\n        f\"https://www.basketball-reference.com/leagues/NBA_{year}_per_game.html\"\n    )\n    df_reg = pd.read_html(base_url_reg, header=0)[0]\n    df_reg = df_reg[df_reg[\"Player\"] != \"Player\"]  # remove repeated header rows\n    df_reg[\"Year\"] = year\n\n    df_reg = df_reg[\n        [\"Player\", \"Year\", \"PTS\", \"AST\", \"TRB\", \"FG%\"]\n    ]  # Keep only specified columns\n    df_reg = df_reg.dropna(\n        subset=[\"PTS\", \"AST\", \"TRB\", \"FG%\"]\n    )  # Ensure key stats aren't invalid\n    return df_reg",
    "old_context": "import pandas as pd\nimport os\n\n\ndef scrape_mvp_votes(start_year=2018, end_year=2025):\n    all_votes = []\n    for year in range(start_year, end_year + 1):\n        url = f\"https://www.basketball-reference.com/awards/awards_{year}.html\"\n        tables = pd.read_html(url, header=1)\n        try:\n            mvp_table = tables[0]  # MVP table is the first table\n            mvp_table[\"Year\"] = year\n            all_votes.append(mvp_table)\n        except:\n            print(f\"Could not parse year {year}\")\n\n    df = pd.concat(all_votes)\n    df = df.rename(columns={\"Player\": \"Name\", \"Pts Won\": \"MVP_Points\"})\n    return df[[\"Year\", \"Name\", \"MVP_Points\"]]\n\n\ndef scrape_season_stats(year):\n    base_url_reg = (\n        f\"https://www.basketball-reference.com/leagues/NBA_{year}_per_game.html\"\n    )\n    df_reg = pd.read_html(base_url_reg, header=0)[0]\n    df_reg = df_reg[df_reg[\"Player\"] != \"Player\"]  # remove repeated header rows\n    df_reg[\"Year\"] = year\n\n    df_reg = df_reg[\n        [\"Player\", \"Year\", \"PTS\", \"AST\", \"TRB\", \"FG%\"]\n    ]  # Keep only specified columns\n    df_reg = df_reg.dropna(\n        subset=[\"PTS\", \"AST\", \"TRB\", \"FG%\"]\n    )  # Ensure key stats aren't invalid\n    return df_reg\n\n\ndef scrape_multiple_seasons(start_year=2018, end_year=2025):\n    all_stats = []\n    for year in range(start_year, end_year + 1):\n        df = scrape_season_stats(year)\n        all_stats.append(df)\n    return pd.concat(all_stats)\n\n\nif __name__ == \"__main__\":\n    if not os.path.exists(\"data\"):\n        os.makedirs(\"data\")\n\n    print(\"Scraping MVP votes...\")\n    mvp_df = scrape_mvp_votes()\n    mvp_df.to_csv(\"data/mvp_votes.csv\", index=False)\n\n    print(\"Scraping player stats...\")\n    stats_df = scrape_multiple_seasons()\n    stats_df.to_csv(\"data/season_stats.csv\", index=False)",
    "old_start_line": "22",
    "new_code": "def scrape_season_stats(year):\n    base_url_reg = (\n        f\"https://www.basketball-reference.com/leagues/NBA_{year}_per_game.html\"\n    )\n    base_url_adv = (\n        f\"https://www.basketball-reference.com/leagues/NBA_{year}_advanced.html\"\n    )\n\n    df_reg = pd.read_html(base_url_reg, header=0)[0]\n    df_adv = pd.read_html(base_url_adv, header=0)[0]\n\n    df_reg = df_reg[df_reg[\"Player\"] != \"Player\"]  # remove repeated header rows\n    df_adv = df_adv[df_adv[\"Player\"] != \"Player\"]  # remove repeated header rows\n\n    df_reg[\"Year\"] = year\n    df_adv[\"Year\"] = year\n\n    df_reg = df_reg[[\"Player\", \"Year\", \"PTS\", \"AST\", \"TRB\", \"FG%\"]]\n    df_adv = df_adv[[\"Player\", \"Year\", \"BPM\", \"WS/48\", \"TS%\", \"VORP\", \"WS\", \"PER\"]]\n\n    df_reg = df_reg.dropna(subset=[\"PTS\", \"AST\", \"TRB\", \"FG%\"])\n    df_adv = df_adv.dropna(subset=[\"BPM\", \"WS/48\", \"TS%\", \"VORP\", \"WS\", \"PER\"])\n\n    df_merged = pd.merge(df_reg, df_adv, on=[\"Player\", \"Year\"])\n\n    return df_merged",
    "new_context": "import pandas as pd\nimport os\n\n\ndef scrape_mvp_votes(start_year=2018, end_year=2025):\n    all_votes = []\n    for year in range(start_year, end_year + 1):\n        url = f\"https://www.basketball-reference.com/awards/awards_{year}.html\"\n        tables = pd.read_html(url, header=1)\n        try:\n            mvp_table = tables[0]  # MVP table is the first table\n            mvp_table[\"Year\"] = year\n            all_votes.append(mvp_table)\n        except:\n            print(f\"Could not parse year {year}\")\n\n    df = pd.concat(all_votes)\n    df = df.rename(columns={\"Player\": \"Name\", \"Pts Won\": \"MVP_Points\"})\n    return df[[\"Year\", \"Name\", \"MVP_Points\"]]\n\n\ndef scrape_season_stats(year):\n    base_url_reg = (\n        f\"https://www.basketball-reference.com/leagues/NBA_{year}_per_game.html\"\n    )\n    base_url_adv = (\n        f\"https://www.basketball-reference.com/leagues/NBA_{year}_advanced.html\"\n    )\n\n    df_reg = pd.read_html(base_url_reg, header=0)[0]\n    df_adv = pd.read_html(base_url_adv, header=0)[0]\n\n    df_reg = df_reg[df_reg[\"Player\"] != \"Player\"]  # remove repeated header rows\n    df_adv = df_adv[df_adv[\"Player\"] != \"Player\"]  # remove repeated header rows\n\n    df_reg[\"Year\"] = year\n    df_adv[\"Year\"] = year\n\n    df_reg = df_reg[[\"Player\", \"Year\", \"PTS\", \"AST\", \"TRB\", \"FG%\"]]\n    df_adv = df_adv[[\"Player\", \"Year\", \"BPM\", \"WS/48\", \"TS%\", \"VORP\", \"WS\", \"PER\"]]\n\n    df_reg = df_reg.dropna(subset=[\"PTS\", \"AST\", \"TRB\", \"FG%\"])\n    df_adv = df_adv.dropna(subset=[\"BPM\", \"WS/48\", \"TS%\", \"VORP\", \"WS\", \"PER\"])\n\n    df_merged = pd.merge(df_reg, df_adv, on=[\"Player\", \"Year\"])\n\n    return df_merged\n\n\ndef scrape_multiple_seasons(start_year=2018, end_year=2025):\n    all_stats = []\n    for year in range(start_year, end_year + 1):\n        df = scrape_season_stats(year)\n        all_stats.append(df)\n        time.sleep(0.1)\n    return pd.concat(all_stats)\n\n\nif __name__ == \"__main__\":\n    if not os.path.exists(\"data\"):\n        os.makedirs(\"data\")\n\n    print(\"Scraping MVP votes...\")\n    mvp_df = scrape_mvp_votes()\n    mvp_df.to_csv(\"data/mvp_votes.csv\", index=False)\n\n    print(\"Scraping player stats...\")\n    stats_df = scrape_multiple_seasons()\n    stats_df.to_csv(\"data/season_stats.csv\", index=False)",
    "new_start_line": "22"
  },
  {
    "id": "MP-B",
    "file_path": "MVPPredictor/rank_model.py",
    "old_code": "    # Model\n    model = XGBRanker(\n        objective=\"rank:pairwise\",\n        learning_rate=0.1,\n        n_estimators=100,\n        max_depth=4,\n        random_state=42,\n    )\n\n    print(\"Training XGBoostRanker...\")\n    model.fit(X_train, y_train, group=train_groups)\n\n    # Predict, sort, and evaluate\n    y_pred = model.predict(X_test)\n    df.loc[test_idx, \"PredictedScore\"] = y_pred\n    df.loc[test_idx, \"PredictedRank\"] = (\n        df.loc[test_idx]\n        .groupby(\"Year\")[\"PredictedScore\"]\n        .rank(ascending=False, method=\"first\")\n    )\n\n    ndcg = evaluate_ndcg(y_test.to_numpy(), y_pred, test_groups)\n    print(f\"NDCG Score on test years {test_years.tolist()}: {ndcg:.4f}\")\n\n    # Show results\n    print(df[test_idx][[\"Year\", \"Name\", \"Rank\", \"PredictedScore\", \"PredictedRank\"]])\n    plot_ranking_predictions(df, 2024)\n    plot_ranking_predictions(df, 2025)",
    "old_context": "import pandas as pd\nfrom xgboost import XGBRanker\nfrom sklearn.metrics import ndcg_score\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport seaborn as sns\n\n\ndef load_data(path=\"data/merged_data.csv\"):\n    df = pd.read_csv(path)\n\n    # Features to use\n    feature_cols = [\n        \"PTS\",\n        \"AST\",\n        \"TRB\",\n        \"FG%\",\n        \"BPM\",\n        \"WS/48\",\n        \"TS%\",\n        \"VORP\",\n        \"WS\",\n        \"PER\",\n    ]\n    feature_cols = [\n        col for col in feature_cols if col in df.columns\n    ]  # only keep existing features\n    df = df.dropna(subset=feature_cols + [\"Rank\"])\n\n    # Sort by Year and Rank for consistency\n    df = df.sort_values(by=[\"Year\", \"Rank\"])\n\n    X = df[feature_cols]\n    y = df[\"Rank\"]\n    groups = df.groupby(\"Year\").size().to_numpy()\n\n    return X, y, groups, df\n\n\ndef evaluate_ndcg(y_true, y_pred, group_sizes):\n    scores = []\n    start = 0\n    for size in group_sizes:\n        true_ranks = y_true[start : start + size]\n        true_relevance = (max(true_ranks) + 1) - true_ranks\n        pred_scores = y_pred[start : start + size]\n        scores.append(ndcg_score([true_relevance], [pred_scores]))\n        start += size\n    return np.mean(scores)\n\n\ndef xgboost_ranker(X, y, groups):\n    model = XGBRanker(\n        objective=\"rank:pairwise\",\n        learning_rate=0.1,\n        n_estimators=100,\n        max_depth=6,\n        random_state=42,\n    )\n\n    print(\"Training XGBoostRanker...\")\n    model.fit(X, y, group=groups)\n\n    return model\n\n\ndef plot_ranking_predictions(df, year):\n    \"\"\"\n    Plot prediction error for a specific year.\n\n    Args:\n        df: DataFrame containing prediction results\n        year: Year to plot prediction errors for\n    \"\"\"\n    df[\"RankError\"] = df[\"PredictedRank\"] - df[\"Rank\"]\n    year_df = df[df[\"Year\"] == year].copy()\n    year_df.sort_values(\"Rank\", inplace=True)\n\n    plt.figure(figsize=(12, 6))\n    sns.barplot(x=\"Name\", y=\"RankError\", data=year_df, hue=\"Name\", palette=\"coolwarm\")\n    plt.axhline(0, color=\"black\", linestyle=\"--\")\n    plt.xticks(rotation=45, ha=\"right\")\n    plt.ylabel(\"Predicted Rank - True Rank\")\n    plt.title(f\"MVP Ranking Predictions ({year})\")\n    plt.tight_layout()\n    plt.savefig(f\"data/ranking_predictions_{year}.png\")\n\n\ndef main():\n    X, y, group, df = load_data()\n\n    # Train-test split on years\n    unique_years = df[\"Year\"].unique()\n    train_years, test_years = (\n        unique_years[:-2],  # train: 2015-2023\n        unique_years[-2:],  # test: 2024-2025\n    )\n\n    train_idx = df[\"Year\"].isin(train_years)\n    test_idx = df[\"Year\"].isin(test_years)\n\n    X_train, X_test = X[train_idx], X[test_idx]\n    y_train, y_test = y[train_idx], y[test_idx]\n\n    # Group sizes\n    train_groups = df[train_idx].groupby(\"Year\").size().to_numpy()\n    test_groups = df[test_idx].groupby(\"Year\").size().to_numpy()\n\n    # Model\n    model = XGBRanker(\n        objective=\"rank:pairwise\",\n        learning_rate=0.1,\n        n_estimators=100,\n        max_depth=4,\n        random_state=42,\n    )\n\n    print(\"Training XGBoostRanker...\")\n    model.fit(X_train, y_train, group=train_groups)\n\n    # Predict, sort, and evaluate\n    y_pred = model.predict(X_test)\n    df.loc[test_idx, \"PredictedScore\"] = y_pred\n    df.loc[test_idx, \"PredictedRank\"] = (\n        df.loc[test_idx]\n        .groupby(\"Year\")[\"PredictedScore\"]\n        .rank(ascending=False, method=\"first\")\n    )\n\n    ndcg = evaluate_ndcg(y_test.to_numpy(), y_pred, test_groups)\n    print(f\"NDCG Score on test years {test_years.tolist()}: {ndcg:.4f}\")\n\n    # Show results\n    print(df[test_idx][[\"Year\", \"Name\", \"Rank\", \"PredictedScore\", \"PredictedRank\"]])\n    plot_ranking_predictions(df, 2024)\n    plot_ranking_predictions(df, 2025)\n\n\nif __name__ == \"__main__\":\n    main()",
    "old_start_line": "109",
    "new_code": "    # Model\n    best_ndcg = -1\n    best_n_estimators = 100\n    for n_estimators in [100, 1000, 2000]:\n        model = XGBRanker(\n            objective=\"rank:pairwise\",\n            learning_rate=0.1,\n            n_estimators=n_estimators,\n            max_depth=4,\n            random_state=42,\n        )\n\n        print(f\"Training XGBoostRanker with {n_estimators} estimators...\")\n        model.fit(X_train, y_train, group=train_groups)\n\n        # Predict and evaluate\n        y_pred = model.predict(X_test)\n        ndcg = evaluate_ndcg(y_test.to_numpy(), y_pred, test_groups)\n        print(f\"NDCG Score with {n_estimators} estimators: {ndcg:.4f}\")\n\n        if ndcg > best_ndcg:\n            best_ndcg = ndcg\n            best_n_estimators = n_estimators\n\n    # Retrain with best n_estimators\n    model = XGBRanker(\n        objective=\"rank:pairwise\",\n        learning_rate=0.1,\n        n_estimators=best_n_estimators,\n        max_depth=4,\n        random_state=42,\n    )\n\n    print(f\"Retraining XGBoostRanker with best n_estimators: {best_n_estimators}\")\n    model.fit(X_train, y_train, group=train_groups)\n\n    # Predict, sort, and evaluate\n    y_pred = model.predict(X_test)\n    df.loc[test_idx, \"PredictedScore\"] = y_pred\n    df.loc[test_idx, \"PredictedRank\"] = (\n        df.loc[test_idx]\n        .groupby(\"Year\")[\"PredictedScore\"]\n        .rank(ascending=False, method=\"first\")\n    )\n\n    ndcg = evaluate_ndcg(y_test.to_numpy(), y_pred, test_groups)\n    print(f\"NDCG Score on test years {test_years.tolist()}: {ndcg:.4f}\")\n\n    # Show results\n    print(df[test_idx][[\"Year\", \"Name\", \"Rank\", \"PredictedScore\", \"PredictedRank\"]])\n    plot_ranking_predictions(df, 2024)\n    plot_ranking_predictions(df, 2025)",
    "new_context": "import pandas as pd\nfrom xgboost import XGBRanker\nfrom sklearn.metrics import ndcg_score\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport seaborn as sns\n\n\ndef load_data(path=\"data/merged_data.csv\"):\n    df = pd.read_csv(path)\n\n    # Features to use\n    feature_cols = [\n        \"PTS\",\n        \"AST\",\n        \"TRB\",\n        \"FG%\",\n        \"BPM\",\n        \"WS/48\",\n        \"TS%\",\n        \"VORP\",\n        \"WS\",\n        \"PER\",\n    ]\n    feature_cols = [\n        col for col in feature_cols if col in df.columns\n    ]  # only keep existing features\n    df = df.dropna(subset=feature_cols + [\"Rank\"])\n\n    # Sort by Year and Rank for consistency\n    df = df.sort_values(by=[\"Year\", \"Rank\"])\n\n    X = df[feature_cols]\n    y = df[\"Rank\"]\n    groups = df.groupby(\"Year\").size().to_numpy()\n\n    return X, y, groups, df\n\n\ndef evaluate_ndcg(y_true, y_pred, group_sizes):\n    scores = []\n    start = 0\n    for size in group_sizes:\n        true_ranks = y_true[start : start + size]\n        true_relevance = (max(true_ranks) + 1) - true_ranks\n        pred_scores = y_pred[start : start + size]\n        scores.append(ndcg_score([true_relevance], [pred_scores]))\n        start += size\n    return np.mean(scores)\n\n\ndef xgboost_ranker(X, y, groups):\n    model = XGBRanker(\n        objective=\"rank:pairwise\",\n        learning_rate=0.1,\n        n_estimators=100,\n        max_depth=6,\n        random_state=42,\n    )\n\n    print(\"Training XGBoostRanker...\")\n    model.fit(X, y, group=groups)\n\n    return model\n\n\ndef plot_ranking_predictions(df, year):\n    \"\"\"\n    Display real and predicted ranks side-by-side for comparison.\n\n    Args:\n        df: DataFrame containing prediction results\n        year: Year to plot prediction errors for\n    \"\"\"\n    year_df = df[df[\"Year\"] == year].copy()\n    year_df.sort_values(\"Rank\", inplace=True)\n\n    plt.figure(figsize=(12, 6))\n    width = 0.35  # the width of the bars\n    indices = np.arange(len(year_df))\n\n    plt.bar(\n        indices,\n        year_df[\"Rank\"],\n        width,\n        label=\"True Rank\",\n        color=sns.color_palette(\"coolwarm\", 2)[0],\n    )\n    plt.bar(\n        indices + width,\n        year_df[\"PredictedRank\"],\n        width,\n        label=\"Predicted Rank\",\n        color=sns.color_palette(\"coolwarm\", 2)[1],\n        alpha=0.6,\n    )\n\n    plt.xticks(indices + width / 2, year_df[\"Name\"], rotation=45, ha=\"right\")\n    plt.ylabel(\"Rank\")\n    plt.title(f\"MVP Ranking Predictions ({year})\")\n    plt.legend()\n    plt.tight_layout()\n    plt.savefig(f\"data/ranking_predictions_{year}.png\")\n\n\ndef main():\n    X, y, group, df = load_data()\n\n    # Train-test split on years\n    unique_years = df[\"Year\"].unique()\n    train_years, test_years = (\n        unique_years[:-2],  # train: 2018-2023\n        unique_years[-2:],  # test: 2024-2025\n    )\n\n    train_idx = df[\"Year\"].isin(train_years)\n    test_idx = df[\"Year\"].isin(test_years)\n\n    X_train, X_test = X[train_idx], X[test_idx]\n    y_train, y_test = y[train_idx], y[test_idx]\n\n    # Group sizes\n    train_groups = df[train_idx].groupby(\"Year\").size().to_numpy()\n    test_groups = df[test_idx].groupby(\"Year\").size().to_numpy()\n\n    # Model\n    best_ndcg = -1\n    best_n_estimators = 100\n    for n_estimators in [100, 1000, 2000]:\n        model = XGBRanker(\n            objective=\"rank:pairwise\",\n            learning_rate=0.1,\n            n_estimators=n_estimators,\n            max_depth=4,\n            random_state=42,\n        )\n\n        print(f\"Training XGBoostRanker with {n_estimators} estimators...\")\n        model.fit(X_train, y_train, group=train_groups)\n\n        # Predict and evaluate\n        y_pred = model.predict(X_test)\n        ndcg = evaluate_ndcg(y_test.to_numpy(), y_pred, test_groups)\n        print(f\"NDCG Score with {n_estimators} estimators: {ndcg:.4f}\")\n\n        if ndcg > best_ndcg:\n            best_ndcg = ndcg\n            best_n_estimators = n_estimators\n\n    # Retrain with best n_estimators\n    model = XGBRanker(\n        objective=\"rank:pairwise\",\n        learning_rate=0.1,\n        n_estimators=best_n_estimators,\n        max_depth=4,\n        random_state=42,\n    )\n\n    print(f\"Retraining XGBoostRanker with best n_estimators: {best_n_estimators}\")\n    model.fit(X_train, y_train, group=train_groups)\n\n    # Predict, sort, and evaluate\n    y_pred = model.predict(X_test)\n    df.loc[test_idx, \"PredictedScore\"] = y_pred\n    df.loc[test_idx, \"PredictedRank\"] = (\n        df.loc[test_idx]\n        .groupby(\"Year\")[\"PredictedScore\"]\n        .rank(ascending=False, method=\"first\")\n    )\n\n    ndcg = evaluate_ndcg(y_test.to_numpy(), y_pred, test_groups)\n    print(f\"NDCG Score on test years {test_years.tolist()}: {ndcg:.4f}\")\n\n    # Show results\n    print(df[test_idx][[\"Year\", \"Name\", \"Rank\", \"PredictedScore\", \"PredictedRank\"]])\n    plot_ranking_predictions(df, 2024)\n    plot_ranking_predictions(df, 2025)\n\n\nif __name__ == \"__main__\":\n    main()",
    "new_start_line": "126"
  },
  {
    "id": "MP-C",
    "file_path": "MVPPredictor/rank_model.py",
    "old_code": "def plot_ranking_predictions(df, year):\n    \"\"\"\n    Plot prediction error for a specific year.\n\n    Args:\n        df: DataFrame containing prediction results\n        year: Year to plot prediction errors for\n    \"\"\"\n    df[\"RankError\"] = df[\"PredictedRank\"] - df[\"Rank\"]\n    year_df = df[df[\"Year\"] == year].copy()\n    year_df.sort_values(\"Rank\", inplace=True)\n\n    plt.figure(figsize=(12, 6))\n    sns.barplot(x=\"Name\", y=\"RankError\", data=year_df, hue=\"Name\", palette=\"coolwarm\")\n    plt.axhline(0, color=\"black\", linestyle=\"--\")\n    plt.xticks(rotation=45, ha=\"right\")\n    plt.ylabel(\"Predicted Rank - True Rank\")\n    plt.title(f\"MVP Ranking Predictions ({year})\")\n    plt.tight_layout()\n    plt.savefig(f\"data/ranking_predictions_{year}.png\")",
    "old_context": "import pandas as pd\nfrom xgboost import XGBRanker\nfrom sklearn.metrics import ndcg_score\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport seaborn as sns\n\n\ndef load_data(path=\"data/merged_data.csv\"):\n    df = pd.read_csv(path)\n\n    # Features to use\n    feature_cols = [\n        \"PTS\",\n        \"AST\",\n        \"TRB\",\n        \"FG%\",\n        \"BPM\",\n        \"WS/48\",\n        \"TS%\",\n        \"VORP\",\n        \"WS\",\n        \"PER\",\n    ]\n    feature_cols = [\n        col for col in feature_cols if col in df.columns\n    ]  # only keep existing features\n    df = df.dropna(subset=feature_cols + [\"Rank\"])\n\n    # Sort by Year and Rank for consistency\n    df = df.sort_values(by=[\"Year\", \"Rank\"])\n\n    X = df[feature_cols]\n    y = df[\"Rank\"]\n    groups = df.groupby(\"Year\").size().to_numpy()\n\n    return X, y, groups, df\n\n\ndef evaluate_ndcg(y_true, y_pred, group_sizes):\n    scores = []\n    start = 0\n    for size in group_sizes:\n        true_ranks = y_true[start : start + size]\n        true_relevance = (max(true_ranks) + 1) - true_ranks\n        pred_scores = y_pred[start : start + size]\n        scores.append(ndcg_score([true_relevance], [pred_scores]))\n        start += size\n    return np.mean(scores)\n\n\ndef xgboost_ranker(X, y, groups):\n    model = XGBRanker(\n        objective=\"rank:pairwise\",\n        learning_rate=0.1,\n        n_estimators=100,\n        max_depth=6,\n        random_state=42,\n    )\n\n    print(\"Training XGBoostRanker...\")\n    model.fit(X, y, group=groups)\n\n    return model\n\n\ndef plot_ranking_predictions(df, year):\n    \"\"\"\n    Plot prediction error for a specific year.\n\n    Args:\n        df: DataFrame containing prediction results\n        year: Year to plot prediction errors for\n    \"\"\"\n    df[\"RankError\"] = df[\"PredictedRank\"] - df[\"Rank\"]\n    year_df = df[df[\"Year\"] == year].copy()\n    year_df.sort_values(\"Rank\", inplace=True)\n\n    plt.figure(figsize=(12, 6))\n    sns.barplot(x=\"Name\", y=\"RankError\", data=year_df, hue=\"Name\", palette=\"coolwarm\")\n    plt.axhline(0, color=\"black\", linestyle=\"--\")\n    plt.xticks(rotation=45, ha=\"right\")\n    plt.ylabel(\"Predicted Rank - True Rank\")\n    plt.title(f\"MVP Ranking Predictions ({year})\")\n    plt.tight_layout()\n    plt.savefig(f\"data/ranking_predictions_{year}.png\")\n\n\ndef main():\n    X, y, group, df = load_data()\n\n    # Train-test split on years\n    unique_years = df[\"Year\"].unique()\n    train_years, test_years = (\n        unique_years[:-2],  # train: 2015-2023\n        unique_years[-2:],  # test: 2024-2025\n    )\n\n    train_idx = df[\"Year\"].isin(train_years)\n    test_idx = df[\"Year\"].isin(test_years)\n\n    X_train, X_test = X[train_idx], X[test_idx]\n    y_train, y_test = y[train_idx], y[test_idx]\n\n    # Group sizes\n    train_groups = df[train_idx].groupby(\"Year\").size().to_numpy()\n    test_groups = df[test_idx].groupby(\"Year\").size().to_numpy()\n\n    # Model\n    model = XGBRanker(\n        objective=\"rank:pairwise\",\n        learning_rate=0.1,\n        n_estimators=100,\n        max_depth=4,\n        random_state=42,\n    )\n\n    print(\"Training XGBoostRanker...\")\n    model.fit(X_train, y_train, group=train_groups)\n\n    # Predict, sort, and evaluate\n    y_pred = model.predict(X_test)\n    df.loc[test_idx, \"PredictedScore\"] = y_pred\n    df.loc[test_idx, \"PredictedRank\"] = (\n        df.loc[test_idx]\n        .groupby(\"Year\")[\"PredictedScore\"]\n        .rank(ascending=False, method=\"first\")\n    )\n\n    ndcg = evaluate_ndcg(y_test.to_numpy(), y_pred, test_groups)\n    print(f\"NDCG Score on test years {test_years.tolist()}: {ndcg:.4f}\")\n\n    # Show results\n    print(df[test_idx][[\"Year\", \"Name\", \"Rank\", \"PredictedScore\", \"PredictedRank\"]])\n    plot_ranking_predictions(df, 2024)\n    plot_ranking_predictions(df, 2025)\n\n\nif __name__ == \"__main__\":\n    main()",
    "old_start_line": "67",
    "new_code": "def plot_ranking_predictions(df, year):\n    \"\"\"\n    Display real and predicted ranks side-by-side for comparison.\n\n    Args:\n        df: DataFrame containing prediction results\n        year: Year to plot prediction errors for\n    \"\"\"\n    year_df = df[df[\"Year\"] == year].copy()\n    year_df.sort_values(\"Rank\", inplace=True)\n\n    plt.figure(figsize=(12, 6))\n    width = 0.35  # the width of the bars\n    indices = np.arange(len(year_df))\n\n    plt.bar(\n        indices,\n        year_df[\"Rank\"],\n        width,\n        label=\"True Rank\",\n        color=sns.color_palette(\"coolwarm\", 2)[0],\n    )\n    plt.bar(\n        indices + width,\n        year_df[\"PredictedRank\"],\n        width,\n        label=\"Predicted Rank\",\n        color=sns.color_palette(\"coolwarm\", 2)[1],\n        alpha=0.6,\n    )\n\n    plt.xticks(indices + width / 2, year_df[\"Name\"], rotation=45, ha=\"right\")\n    plt.ylabel(\"Rank\")\n    plt.title(f\"MVP Ranking Predictions ({year})\")\n    plt.legend()\n    plt.tight_layout()\n    plt.savefig(f\"data/ranking_predictions_{year}.png\")",
    "new_context": "import pandas as pd\nfrom xgboost import XGBRanker\nfrom sklearn.metrics import ndcg_score\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport seaborn as sns\n\n\ndef load_data(path=\"data/merged_data.csv\"):\n    df = pd.read_csv(path)\n\n    # Features to use\n    feature_cols = [\n        \"PTS\",\n        \"AST\",\n        \"TRB\",\n        \"FG%\",\n        \"BPM\",\n        \"WS/48\",\n        \"TS%\",\n        \"VORP\",\n        \"WS\",\n        \"PER\",\n    ]\n    feature_cols = [\n        col for col in feature_cols if col in df.columns\n    ]  # only keep existing features\n    df = df.dropna(subset=feature_cols + [\"Rank\"])\n\n    # Sort by Year and Rank for consistency\n    df = df.sort_values(by=[\"Year\", \"Rank\"])\n\n    X = df[feature_cols]\n    y = df[\"Rank\"]\n    groups = df.groupby(\"Year\").size().to_numpy()\n\n    return X, y, groups, df\n\n\ndef evaluate_ndcg(y_true, y_pred, group_sizes):\n    scores = []\n    start = 0\n    for size in group_sizes:\n        true_ranks = y_true[start : start + size]\n        true_relevance = (max(true_ranks) + 1) - true_ranks\n        pred_scores = y_pred[start : start + size]\n        scores.append(ndcg_score([true_relevance], [pred_scores]))\n        start += size\n    return np.mean(scores)\n\n\ndef xgboost_ranker(X, y, groups):\n    model = XGBRanker(\n        objective=\"rank:pairwise\",\n        learning_rate=0.1,\n        n_estimators=100,\n        max_depth=6,\n        random_state=42,\n    )\n\n    print(\"Training XGBoostRanker...\")\n    model.fit(X, y, group=groups)\n\n    return model\n\n\ndef plot_ranking_predictions(df, year):\n    \"\"\"\n    Display real and predicted ranks side-by-side for comparison.\n\n    Args:\n        df: DataFrame containing prediction results\n        year: Year to plot prediction errors for\n    \"\"\"\n    year_df = df[df[\"Year\"] == year].copy()\n    year_df.sort_values(\"Rank\", inplace=True)\n\n    plt.figure(figsize=(12, 6))\n    width = 0.35  # the width of the bars\n    indices = np.arange(len(year_df))\n\n    plt.bar(\n        indices,\n        year_df[\"Rank\"],\n        width,\n        label=\"True Rank\",\n        color=sns.color_palette(\"coolwarm\", 2)[0],\n    )\n    plt.bar(\n        indices + width,\n        year_df[\"PredictedRank\"],\n        width,\n        label=\"Predicted Rank\",\n        color=sns.color_palette(\"coolwarm\", 2)[1],\n        alpha=0.6,\n    )\n\n    plt.xticks(indices + width / 2, year_df[\"Name\"], rotation=45, ha=\"right\")\n    plt.ylabel(\"Rank\")\n    plt.title(f\"MVP Ranking Predictions ({year})\")\n    plt.legend()\n    plt.tight_layout()\n    plt.savefig(f\"data/ranking_predictions_{year}.png\")\n\n\ndef main():\n    X, y, group, df = load_data()\n\n    # Train-test split on years\n    unique_years = df[\"Year\"].unique()\n    train_years, test_years = (\n        unique_years[:-2],  # train: 2018-2023\n        unique_years[-2:],  # test: 2024-2025\n    )\n\n    train_idx = df[\"Year\"].isin(train_years)\n    test_idx = df[\"Year\"].isin(test_years)\n\n    X_train, X_test = X[train_idx], X[test_idx]\n    y_train, y_test = y[train_idx], y[test_idx]\n\n    # Group sizes\n    train_groups = df[train_idx].groupby(\"Year\").size().to_numpy()\n    test_groups = df[test_idx].groupby(\"Year\").size().to_numpy()\n\n    # Model\n    best_ndcg = -1\n    best_n_estimators = 100\n    for n_estimators in [100, 1000, 2000]:\n        model = XGBRanker(\n            objective=\"rank:pairwise\",\n            learning_rate=0.1,\n            n_estimators=n_estimators,\n            max_depth=4,\n            random_state=42,\n        )\n\n        print(f\"Training XGBoostRanker with {n_estimators} estimators...\")\n        model.fit(X_train, y_train, group=train_groups)\n\n        # Predict and evaluate\n        y_pred = model.predict(X_test)\n        ndcg = evaluate_ndcg(y_test.to_numpy(), y_pred, test_groups)\n        print(f\"NDCG Score with {n_estimators} estimators: {ndcg:.4f}\")\n\n        if ndcg > best_ndcg:\n            best_ndcg = ndcg\n            best_n_estimators = n_estimators\n\n    # Retrain with best n_estimators\n    model = XGBRanker(\n        objective=\"rank:pairwise\",\n        learning_rate=0.1,\n        n_estimators=best_n_estimators,\n        max_depth=4,\n        random_state=42,\n    )\n\n    print(f\"Retraining XGBoostRanker with best n_estimators: {best_n_estimators}\")\n    model.fit(X_train, y_train, group=train_groups)\n\n    # Predict, sort, and evaluate\n    y_pred = model.predict(X_test)\n    df.loc[test_idx, \"PredictedScore\"] = y_pred\n    df.loc[test_idx, \"PredictedRank\"] = (\n        df.loc[test_idx]\n        .groupby(\"Year\")[\"PredictedScore\"]\n        .rank(ascending=False, method=\"first\")\n    )\n\n    ndcg = evaluate_ndcg(y_test.to_numpy(), y_pred, test_groups)\n    print(f\"NDCG Score on test years {test_years.tolist()}: {ndcg:.4f}\")\n\n    # Show results\n    print(df[test_idx][[\"Year\", \"Name\", \"Rank\", \"PredictedScore\", \"PredictedRank\"]])\n    plot_ranking_predictions(df, 2024)\n    plot_ranking_predictions(df, 2025)\n\n\nif __name__ == \"__main__\":\n    main()",
    "new_start_line": "67"
  }
]