[
  {
    "task_id": "FD-A",
    "metadata": {
      "file_context": "FinanceDashboard/frontend/src/StockChart.jsx",
      "processing_timestamp": 81984.438895296
    },
    "old_code": {
      "code": "const formatDateString = (date) => {\n    return date.split(\"T\")[0];\n  };",
      "summary": {
        "title": "formatDateString Function",
        "low_unstructured": "This function extracts the date part from a date-time string.",
        "low_structured": "• Extracts date from a date-time string\n• Removes the time component",
        "medium_unstructured": "The formatDateString function takes a date-time string and returns only the date portion. It does this by splitting the string at the 'T' character and returning the first segment. This is useful for formatting ISO date strings.",
        "medium_structured": "• Accepts a date-time string as input\n• Splits the string at the 'T' character\n• Returns the date portion before the 'T'\n  ◦ Omits the time information",
        "high_unstructured": "The formatDateString function is designed to process a string representing a date and time in ISO format. It splits the input string at the 'T' character, which separates the date from the time, and returns the first segment, effectively extracting just the date. This approach assumes the input is in a standard format like 'YYYY-MM-DDTHH:MM:SS'. The function is useful for displaying or processing dates without their associated time components.",
        "high_structured": "• Processes a date-time string input\n• Splits the string using the 'T' character as a delimiter\n  ◦ Assumes input is in ISO format (e.g., 'YYYY-MM-DDTHH:MM:SS')\n• Extracts and returns the segment before the 'T'\n  ◦ This segment represents the date only\n• Effectively removes the time component from the input\n• Useful for formatting or displaying dates without time information"
      },
      "mappings": {
        "low_unstructured": [
          {
            "summaryComponent": "This function",
            "codeSegments": [
              {
                "code": "const formatDateString = (date) => {",
                "line": 1
              }
            ]
          },
          {
            "summaryComponent": "extracts the date part",
            "codeSegments": [
              {
                "code": "date.split(\"T\")[0]",
                "line": 2
              }
            ]
          },
          {
            "summaryComponent": "from a date-time string",
            "codeSegments": [
              {
                "code": "(date)",
                "line": 1
              }
            ]
          }
        ],
        "low_structured": [
          {
            "summaryComponent": "Extracts date from a date-time string",
            "codeSegments": [
              {
                "code": "const formatDateString = (date) => {",
                "line": 1
              },
              {
                "code": "date.split(\"T\")[0];",
                "line": 2
              }
            ]
          },
          {
            "summaryComponent": "Removes the time component",
            "codeSegments": [
              {
                "code": "date.split(\"T\")[0];",
                "line": 2
              }
            ]
          }
        ],
        "medium_unstructured": [
          {
            "summaryComponent": "The formatDateString function",
            "codeSegments": [
              {
                "code": "const formatDateString = (date) => {",
                "line": 1
              }
            ]
          },
          {
            "summaryComponent": "takes a date-time string",
            "codeSegments": [
              {
                "code": "(date)",
                "line": 1
              }
            ]
          },
          {
            "summaryComponent": "returns only the date portion",
            "codeSegments": [
              {
                "code": "return date.split(\"T\")[0];",
                "line": 2
              }
            ]
          },
          {
            "summaryComponent": "splitting the string at the 'T' character",
            "codeSegments": [
              {
                "code": "date.split(\"T\")",
                "line": 2
              }
            ]
          },
          {
            "summaryComponent": "returning the first segment",
            "codeSegments": [
              {
                "code": "[0]",
                "line": 2
              }
            ]
          },
          {
            "summaryComponent": "formatting ISO date strings",
            "codeSegments": [
              {
                "code": "date.split(\"T\")[0];",
                "line": 2
              }
            ]
          }
        ],
        "medium_structured": [
          {
            "summaryComponent": "Accepts a date-time string as input",
            "codeSegments": [
              {
                "code": "const formatDateString = (date) => {",
                "line": 1
              }
            ]
          },
          {
            "summaryComponent": "Splits the string at the 'T' character",
            "codeSegments": [
              {
                "code": "date.split(\"T\")",
                "line": 2
              }
            ]
          },
          {
            "summaryComponent": "Returns the date portion before the 'T'",
            "codeSegments": [
              {
                "code": "return date.split(\"T\")[0];",
                "line": 2
              }
            ]
          },
          {
            "summaryComponent": "Omits the time information",
            "codeSegments": [
              {
                "code": "date.split(\"T\")[0]",
                "line": 2
              }
            ]
          }
        ],
        "high_unstructured": [
          {
            "summaryComponent": "The formatDateString function",
            "codeSegments": [
              {
                "code": "const formatDateString = (date) => {",
                "line": 1
              }
            ]
          },
          {
            "summaryComponent": "is designed to process a string representing a date and time in ISO format",
            "codeSegments": [
              {
                "code": "(date)",
                "line": 1
              }
            ]
          },
          {
            "summaryComponent": "It splits the input string at the 'T' character",
            "codeSegments": [
              {
                "code": "date.split(\"T\")",
                "line": 2
              }
            ]
          },
          {
            "summaryComponent": "which separates the date from the time",
            "codeSegments": [
              {
                "code": "date.split(\"T\")",
                "line": 2
              }
            ]
          },
          {
            "summaryComponent": "and returns the first segment",
            "codeSegments": [
              {
                "code": "date.split(\"T\")[0]",
                "line": 2
              }
            ]
          },
          {
            "summaryComponent": "effectively extracting just the date",
            "codeSegments": [
              {
                "code": "date.split(\"T\")[0]",
                "line": 2
              }
            ]
          },
          {
            "summaryComponent": "This approach assumes the input is in a standard format like 'YYYY-MM-DDTHH:MM:SS'",
            "codeSegments": [
              {
                "code": "date.split(\"T\")",
                "line": 2
              }
            ]
          },
          {
            "summaryComponent": "The function is useful for displaying or processing dates without their associated time components",
            "codeSegments": [
              {
                "code": "return date.split(\"T\")[0];",
                "line": 2
              }
            ]
          }
        ],
        "high_structured": [
          {
            "summaryComponent": "Processes a date-time string input",
            "codeSegments": [
              {
                "code": "const formatDateString = (date) => {",
                "line": 1
              }
            ]
          },
          {
            "summaryComponent": "Splits the string using the 'T' character as a delimiter",
            "codeSegments": [
              {
                "code": "date.split(\"T\")",
                "line": 2
              }
            ]
          },
          {
            "summaryComponent": "Assumes input is in ISO format (e.g., 'YYYY-MM-DDTHH:MM:SS')",
            "codeSegments": [
              {
                "code": "date.split(\"T\")",
                "line": 2
              }
            ]
          },
          {
            "summaryComponent": "Extracts and returns the segment before the 'T'",
            "codeSegments": [
              {
                "code": "return date.split(\"T\")[0];",
                "line": 2
              }
            ]
          },
          {
            "summaryComponent": "This segment represents the date only",
            "codeSegments": [
              {
                "code": "date.split(\"T\")[0]",
                "line": 2
              }
            ]
          },
          {
            "summaryComponent": "Effectively removes the time component from the input",
            "codeSegments": [
              {
                "code": "date.split(\"T\")[0]",
                "line": 2
              }
            ]
          },
          {
            "summaryComponent": "Useful for formatting or displaying dates without time information",
            "codeSegments": [
              {
                "code": "const formatDateString = (date) => {",
                "line": 1
              }
            ]
          }
        ]
      }
    },
    "new_code": {
      "code": "const formatDateString = (date) => {\n    const options = { month: \"short\" };\n    return new Date(date).toLocaleDateString(\"en-US\", options);\n  };",
      "summary": {
        "title": "formatDateString Function (Updated to Format Month)",
        "low_unstructured": "This function now converts a date-time string to a formatted month abbreviation.",
        "low_structured": "• Converts a date-time string to a Date object\n• Formats and returns the month as a short abbreviation",
        "medium_unstructured": "The formatDateString function now takes a date-time string, creates a Date object from it, and returns the month portion formatted as a short abbreviation (e.g., 'Jan', 'Feb') using toLocaleDateString with appropriate options. This replaces the previous behavior of extracting the date portion before the 'T'.",
        "medium_structured": "• Accepts a date-time string as input\n• Converts the string to a Date object\n• Formats the date using toLocaleDateString with the 'month: short' option\n  ◦ Returns the abbreviated month name (e.g., 'Jan')\n• No longer splits the string at the 'T' or returns the date portion before the 'T'",
        "high_unstructured": "The formatDateString function has been updated to process a string representing a date and time by first converting it into a Date object, then formatting and returning only the month as a short abbreviation (such as 'Jan' for January) using toLocaleDateString with the 'en-US' locale and the 'month: short' option. This replaces the previous approach of splitting the string at the 'T' character and extracting the date segment, and is now useful for displaying just the month name from a date-time input.",
        "high_structured": "• Processes a date-time string input\n• Converts the input string into a Date object\n• Formats the Date object using toLocaleDateString with 'en-US' locale and 'month: short' option\n  ◦ Returns only the abbreviated month name (e.g., 'Jan')\n• No longer splits the string at the 'T' character or extracts the date segment\n• Useful for formatting or displaying the month abbreviation from a date-time string"
      },
      "mappings": {
        "low_unstructured": [
          {
            "summaryComponent": "This function",
            "codeSegments": [
              {
                "code": "const formatDateString = (date) => {",
                "line": 1
              }
            ]
          },
          {
            "summaryComponent": "now converts a date-time string",
            "codeSegments": [
              {
                "code": "new Date(date)",
                "line": 3
              }
            ]
          },
          {
            "summaryComponent": "to a formatted month abbreviation",
            "codeSegments": [
              {
                "code": "const options = { month: \"short\" };",
                "line": 2
              },
              {
                "code": ".toLocaleDateString(\"en-US\", options)",
                "line": 3
              }
            ]
          }
        ],
        "low_structured": [
          {
            "summaryComponent": "Converts a date-time string to a Date object",
            "codeSegments": [
              {
                "code": "new Date(date)",
                "line": 3
              }
            ]
          },
          {
            "summaryComponent": "Formats and returns the month as a short abbreviation",
            "codeSegments": [
              {
                "code": "const options = { month: \"short\" };",
                "line": 2
              },
              {
                "code": "toLocaleDateString(\"en-US\", options)",
                "line": 3
              }
            ]
          }
        ],
        "medium_unstructured": [
          {
            "summaryComponent": "The formatDateString function",
            "codeSegments": [
              {
                "code": "const formatDateString = (date) => {",
                "line": 1
              }
            ]
          },
          {
            "summaryComponent": "now takes a date-time string",
            "codeSegments": [
              {
                "code": "(date)",
                "line": 1
              }
            ]
          },
          {
            "summaryComponent": "creates a Date object from it",
            "codeSegments": [
              {
                "code": "new Date(date)",
                "line": 3
              }
            ]
          },
          {
            "summaryComponent": "returns the month portion formatted as a short abbreviation (e.g., 'Jan', 'Feb')",
            "codeSegments": [
              {
                "code": "const options = { month: \"short\" };",
                "line": 2
              },
              {
                "code": "return new Date(date).toLocaleDateString(\"en-US\", options);",
                "line": 3
              }
            ]
          },
          {
            "summaryComponent": "using toLocaleDateString with appropriate options",
            "codeSegments": [
              {
                "code": "toLocaleDateString(\"en-US\", options)",
                "line": 3
              }
            ]
          }
        ],
        "medium_structured": [
          {
            "summaryComponent": "Accepts a date-time string as input",
            "codeSegments": [
              {
                "code": "const formatDateString = (date) => {",
                "line": 1
              }
            ]
          },
          {
            "summaryComponent": "Converts the string to a Date object",
            "codeSegments": [
              {
                "code": "new Date(date)",
                "line": 3
              }
            ]
          },
          {
            "summaryComponent": "Formats the date using toLocaleDateString with the 'month: short' option",
            "codeSegments": [
              {
                "code": "toLocaleDateString(\"en-US\", options)",
                "line": 3
              },
              {
                "code": "const options = { month: \"short\" };",
                "line": 2
              }
            ]
          },
          {
            "summaryComponent": "Returns the abbreviated month name (e.g., 'Jan')",
            "codeSegments": [
              {
                "code": "month: \"short\"",
                "line": 2
              }
            ]
          }
        ],
        "high_unstructured": [
          {
            "summaryComponent": "The formatDateString function",
            "codeSegments": [
              {
                "code": "const formatDateString = (date) => {",
                "line": 1
              }
            ]
          },
          {
            "summaryComponent": "has been updated to process a string representing a date and time",
            "codeSegments": [
              {
                "code": "(date)",
                "line": 1
              }
            ]
          },
          {
            "summaryComponent": "by first converting it into a Date object",
            "codeSegments": [
              {
                "code": "new Date(date)",
                "line": 3
              }
            ]
          },
          {
            "summaryComponent": "then formatting and returning only the month as a short abbreviation",
            "codeSegments": [
              {
                "code": "const options = { month: \"short\" };",
                "line": 2
              }
            ]
          },
          {
            "summaryComponent": "(such as 'Jan' for January)",
            "codeSegments": [
              {
                "code": "month: \"short\"",
                "line": 2
              }
            ]
          },
          {
            "summaryComponent": "using toLocaleDateString with the 'en-US' locale",
            "codeSegments": [
              {
                "code": "toLocaleDateString(\"en-US\", options)",
                "line": 3
              }
            ]
          },
          {
            "summaryComponent": "and the 'month: short' option",
            "codeSegments": [
              {
                "code": "month: \"short\"",
                "line": 2
              }
            ]
          },
          {
            "summaryComponent": "and is now useful for displaying just the month name from a date-time input.",
            "codeSegments": [
              {
                "code": "toLocaleDateString(\"en-US\", options)",
                "line": 3
              }
            ]
          }
        ],
        "high_structured": [
          {
            "summaryComponent": "Processes a date-time string input",
            "codeSegments": [
              {
                "code": "const formatDateString = (date) => {",
                "line": 1
              }
            ]
          },
          {
            "summaryComponent": "Converts the input string into a Date object",
            "codeSegments": [
              {
                "code": "new Date(date)",
                "line": 3
              }
            ]
          },
          {
            "summaryComponent": "Formats the Date object using toLocaleDateString with 'en-US' locale and 'month: short' option",
            "codeSegments": [
              {
                "code": "toLocaleDateString(\"en-US\", options)",
                "line": 3
              }
            ]
          },
          {
            "summaryComponent": "Returns only the abbreviated month name (e.g., 'Jan')",
            "codeSegments": [
              {
                "code": "const options = { month: \"short\" };",
                "line": 2
              }
            ]
          },
          {
            "summaryComponent": "Useful for formatting or displaying the month abbreviation from a date-time string",
            "codeSegments": [
              {
                "code": "return new Date(date).toLocaleDateString(\"en-US\", options);",
                "line": 3
              }
            ]
          }
        ]
      }
    }
  },
  {
    "task_id": "FD-B",
    "metadata": {
      "file_context": "FinanceDashboard/server/index.js",
      "processing_timestamp": 82075.777388507
    },
    "old_code": {
      "code": "app.get(\"/api/stock/:symbol\", async (req, res) => {\n  try {\n    const symbol = req.params.symbol.toUpperCase();\n    const data = await yahooFinance.chart(symbol, {\n      period1: \"2024-01-01\",\n      interval: \"1d\",\n    });\n    const quotes = data.quotes;\n\n    const companyName = data.meta?.shortName || symbol;\n\n    const response = {\n      ticker: symbol,\n      name: companyName,\n      data: quotes.map((q) => ({\n        date: q.date,\n        close: q.close,\n        volume: q.volume,\n      })),\n    };\n\n    console.log(response);\n    res.json(response);\n  } catch (err) {\n    console.error(err);\n    res.status(500).send(\"Error fetching stock data\");\n  }\n});",
      "summary": {
        "title": "Express Route for Fetching Stock Data by Symbol",
        "low_unstructured": "This code defines an API endpoint that retrieves and returns stock data for a given symbol.",
        "low_structured": "• Defines a GET endpoint for stock data\n• Fetches and returns stock information for a given symbol",
        "medium_unstructured": "The code sets up an Express GET endpoint at '/api/stock/:symbol' that fetches daily stock data for a specified symbol using the yahooFinance API. It processes the data to extract date, close price, and volume, and returns this information in JSON format. If an error occurs, it logs the error and sends a 500 response.",
        "medium_structured": "• Sets up a GET endpoint at '/api/stock/:symbol'\n• Fetches daily stock data for the given symbol from yahooFinance\n• Processes and formats the data to include:\n  ◦ Date\n  ◦ Closing price\n  ◦ Volume\n• Returns the formatted data as a JSON response\n• Handles errors by logging and sending a 500 status",
        "high_unstructured": "This code defines an asynchronous Express route handler for GET requests to '/api/stock/:symbol', where it retrieves historical daily stock data for the specified symbol from the yahooFinance API, starting from January 1, 2024. The symbol is converted to uppercase, and the response includes the ticker, company name (if available), and an array of objects each containing the date, close price, and volume for each day. The response is logged to the console before being sent as JSON. In case of any errors during data retrieval or processing, the error is logged and a 500 error message is returned to the client.",
        "high_structured": "• Defines an asynchronous GET endpoint at '/api/stock/:symbol'\n• Retrieves the stock symbol from the URL and converts it to uppercase\n• Fetches historical daily stock data from yahooFinance starting from 2024-01-01\n• Extracts and formats the response:\n  ◦ Includes the ticker symbol and company name (from API metadata or symbol fallback)\n  ◦ Maps each quote to an object with:\n    ◦ date\n    ◦ close price\n    ◦ volume\n• Logs the formatted response to the console\n• Sends the response as JSON to the client\n• Handles errors by logging them and returning a 500 status with an error message"
      },
      "mappings": {
        "low_unstructured": [
          {
            "summaryComponent": "defines an API endpoint",
            "codeSegments": [
              {
                "code": "app.get(\"/api/stock/:symbol\", async (req, res) => {",
                "line": 1
              }
            ]
          },
          {
            "summaryComponent": "retrieves and returns stock data",
            "codeSegments": [
              {
                "code": "const data = await yahooFinance.chart(symbol, {",
                "line": 4
              },
              {
                "code": "res.json(response);",
                "line": 23
              }
            ]
          },
          {
            "summaryComponent": "for a given symbol",
            "codeSegments": [
              {
                "code": "const symbol = req.params.symbol.toUpperCase();",
                "line": 3
              }
            ]
          }
        ],
        "low_structured": [
          {
            "summaryComponent": "Defines a GET endpoint for stock data",
            "codeSegments": [
              {
                "code": "app.get(\"/api/stock/:symbol\", async (req, res) => {",
                "line": 1
              }
            ]
          },
          {
            "summaryComponent": "Fetches and returns stock information for a given symbol",
            "codeSegments": [
              {
                "code": "const symbol = req.params.symbol.toUpperCase();",
                "line": 3
              },
              {
                "code": "const data = await yahooFinance.chart(symbol, {",
                "line": 4
              },
              {
                "code": "res.json(response);",
                "line": 23
              }
            ]
          }
        ],
        "medium_unstructured": [
          {
            "summaryComponent": "sets up an Express GET endpoint at '/api/stock/:symbol'",
            "codeSegments": [
              {
                "code": "app.get(\"/api/stock/:symbol\", async (req, res) => {",
                "line": 1
              }
            ]
          },
          {
            "summaryComponent": "fetches daily stock data for a specified symbol using the yahooFinance API",
            "codeSegments": [
              {
                "code": "const symbol = req.params.symbol.toUpperCase();",
                "line": 3
              },
              {
                "code": "const data = await yahooFinance.chart(symbol, {",
                "line": 4
              },
              {
                "code": "interval: \"1d\",",
                "line": 6
              }
            ]
          },
          {
            "summaryComponent": "processes the data to extract date, close price, and volume",
            "codeSegments": [
              {
                "code": "data.quotes;",
                "line": 8
              },
              {
                "code": "data: quotes.map((q) => ({",
                "line": 15
              },
              {
                "code": "date: q.date,",
                "line": 16
              },
              {
                "code": "close: q.close,",
                "line": 17
              },
              {
                "code": "volume: q.volume,",
                "line": 18
              }
            ]
          },
          {
            "summaryComponent": "returns this information in JSON format",
            "codeSegments": [
              {
                "code": "res.json(response);",
                "line": 23
              }
            ]
          },
          {
            "summaryComponent": "If an error occurs",
            "codeSegments": [
              {
                "code": "catch (err) {",
                "line": 24
              }
            ]
          },
          {
            "summaryComponent": "it logs the error",
            "codeSegments": [
              {
                "code": "console.error(err);",
                "line": 25
              }
            ]
          },
          {
            "summaryComponent": "sends a 500 response",
            "codeSegments": [
              {
                "code": "res.status(500).send(\"Error fetching stock data\");",
                "line": 26
              }
            ]
          }
        ],
        "medium_structured": [
          {
            "summaryComponent": "Sets up a GET endpoint at '/api/stock/:symbol'",
            "codeSegments": [
              {
                "code": "app.get(\"/api/stock/:symbol\", async (req, res) => {",
                "line": 1
              }
            ]
          },
          {
            "summaryComponent": "Fetches daily stock data for the given symbol from yahooFinance",
            "codeSegments": [
              {
                "code": "const data = await yahooFinance.chart(symbol, {",
                "line": 4
              },
              {
                "code": "period1: \"2024-01-01\",",
                "line": 5
              },
              {
                "code": "interval: \"1d\",",
                "line": 6
              }
            ]
          },
          {
            "summaryComponent": "Processes and formats the data to include:",
            "codeSegments": [
              {
                "code": "const response = {",
                "line": 12
              }
            ]
          },
          {
            "summaryComponent": "Date",
            "codeSegments": [
              {
                "code": "date: q.date,",
                "line": 16
              }
            ]
          },
          {
            "summaryComponent": "Closing price",
            "codeSegments": [
              {
                "code": "close: q.close,",
                "line": 17
              }
            ]
          },
          {
            "summaryComponent": "Volume",
            "codeSegments": [
              {
                "code": "volume: q.volume,",
                "line": 18
              }
            ]
          },
          {
            "summaryComponent": "Returns the formatted data as a JSON response",
            "codeSegments": [
              {
                "code": "res.json(response);",
                "line": 23
              }
            ]
          },
          {
            "summaryComponent": "Handles errors by logging and sending a 500 status",
            "codeSegments": [
              {
                "code": "console.error(err);",
                "line": 25
              },
              {
                "code": "res.status(500).send(\"Error fetching stock data\");",
                "line": 26
              }
            ]
          }
        ],
        "high_unstructured": [
          {
            "summaryComponent": "an asynchronous Express route handler for GET requests to '/api/stock/:symbol'",
            "codeSegments": [
              {
                "code": "app.get(\"/api/stock/:symbol\", async (req, res) => {",
                "line": 1
              }
            ]
          },
          {
            "summaryComponent": "retrieves historical daily stock data for the specified symbol from the yahooFinance API",
            "codeSegments": [
              {
                "code": "const data = await yahooFinance.chart(symbol, {",
                "line": 4
              },
              {
                "code": "interval: \"1d\",",
                "line": 6
              }
            ]
          },
          {
            "summaryComponent": "starting from January 1, 2024",
            "codeSegments": [
              {
                "code": "period1: \"2024-01-01\",",
                "line": 5
              }
            ]
          },
          {
            "summaryComponent": "The symbol is converted to uppercase",
            "codeSegments": [
              {
                "code": "const symbol = req.params.symbol.toUpperCase();",
                "line": 3
              }
            ]
          },
          {
            "summaryComponent": "the response includes the ticker",
            "codeSegments": [
              {
                "code": "ticker: symbol,",
                "line": 13
              }
            ]
          },
          {
            "summaryComponent": "company name (if available)",
            "codeSegments": [
              {
                "code": "const companyName = data.meta?.shortName || symbol;",
                "line": 10
              },
              {
                "code": "name: companyName,",
                "line": 14
              }
            ]
          },
          {
            "summaryComponent": "an array of objects each containing the date, close price, and volume for each day",
            "codeSegments": [
              {
                "code": "data: quotes.map((q) => ({",
                "line": 15
              },
              {
                "code": "date: q.date,",
                "line": 16
              },
              {
                "code": "close: q.close,",
                "line": 17
              },
              {
                "code": "volume: q.volume,",
                "line": 18
              }
            ]
          },
          {
            "summaryComponent": "The response is logged to the console before being sent as JSON",
            "codeSegments": [
              {
                "code": "console.log(response);",
                "line": 22
              },
              {
                "code": "res.json(response);",
                "line": 23
              }
            ]
          },
          {
            "summaryComponent": "In case of any errors during data retrieval or processing, the error is logged",
            "codeSegments": [
              {
                "code": "catch (err) {",
                "line": 24
              },
              {
                "code": "console.error(err);",
                "line": 25
              }
            ]
          },
          {
            "summaryComponent": "a 500 error message is returned to the client",
            "codeSegments": [
              {
                "code": "res.status(500).send(\"Error fetching stock data\");",
                "line": 26
              }
            ]
          }
        ],
        "high_structured": [
          {
            "summaryComponent": "Defines an asynchronous GET endpoint at '/api/stock/:symbol'",
            "codeSegments": [
              {
                "code": "app.get(\"/api/stock/:symbol\", async (req, res) => {",
                "line": 1
              }
            ]
          },
          {
            "summaryComponent": "Retrieves the stock symbol from the URL and converts it to uppercase",
            "codeSegments": [
              {
                "code": "const symbol = req.params.symbol.toUpperCase();",
                "line": 3
              }
            ]
          },
          {
            "summaryComponent": "Fetches historical daily stock data from yahooFinance starting from 2024-01-01",
            "codeSegments": [
              {
                "code": "const data = await yahooFinance.chart(symbol, {",
                "line": 4
              },
              {
                "code": "period1: \"2024-01-01\",",
                "line": 5
              },
              {
                "code": "interval: \"1d\",",
                "line": 6
              }
            ]
          },
          {
            "summaryComponent": "Extracts and formats the response:",
            "codeSegments": [
              {
                "code": "const response = {",
                "line": 12
              }
            ]
          },
          {
            "summaryComponent": "Includes the ticker symbol and company name (from API metadata or symbol fallback)",
            "codeSegments": [
              {
                "code": "ticker: symbol,",
                "line": 13
              },
              {
                "code": "name: companyName,",
                "line": 14
              },
              {
                "code": "const companyName = data.meta?.shortName || symbol;",
                "line": 10
              }
            ]
          },
          {
            "summaryComponent": "Maps each quote to an object with:",
            "codeSegments": [
              {
                "code": "data: quotes.map((q) => ({",
                "line": 15
              }
            ]
          },
          {
            "summaryComponent": "date",
            "codeSegments": [
              {
                "code": "date: q.date,",
                "line": 16
              }
            ]
          },
          {
            "summaryComponent": "close price",
            "codeSegments": [
              {
                "code": "close: q.close,",
                "line": 17
              }
            ]
          },
          {
            "summaryComponent": "volume",
            "codeSegments": [
              {
                "code": "volume: q.volume,",
                "line": 18
              }
            ]
          },
          {
            "summaryComponent": "Logs the formatted response to the console",
            "codeSegments": [
              {
                "code": "console.log(response);",
                "line": 22
              }
            ]
          },
          {
            "summaryComponent": "Sends the response as JSON to the client",
            "codeSegments": [
              {
                "code": "res.json(response);",
                "line": 23
              }
            ]
          },
          {
            "summaryComponent": "Handles errors by logging them and returning a 500 status with an error message",
            "codeSegments": [
              {
                "code": "console.error(err);",
                "line": 25
              },
              {
                "code": "res.status(500).send(\"Error fetching stock data\");",
                "line": 26
              }
            ]
          }
        ]
      }
    },
    "new_code": {
      "code": "app.get(\"/api/stock/:symbol\", async (req, res) => {\n  try {\n    const symbol = req.params.symbol.toUpperCase();\n    const data = await yahooFinance.chart(symbol, {\n      period1: \"2024-01-01\",\n      interval: \"1d\",\n    });\n    const quotes = data.quotes;\n\n    const companyName = data.meta?.shortName || symbol;\n    const currentPrice = quotes[quotes.length - 1]?.close || null;\n\n    const response = {\n      ticker: symbol,\n      name: companyName,\n      currentPrice: currentPrice,\n      data: quotes.map((q) => ({\n        date: q.date,\n        close: q.close,\n        volume: q.volume,\n      })),\n    };\n\n    console.log(response);\n    res.json(response);\n  } catch (err) {\n    console.error(err);\n    res.status(500).send(\"Error fetching stock data\");\n  }\n});",
      "summary": {
        "title": "Express Route for Fetching Stock Data by Symbol with Current Price",
        "low_unstructured": "This code defines an API endpoint that retrieves and returns stock data for a given symbol, now also including the current price in the response.",
        "low_structured": "• Defines a GET endpoint for stock data\n• Fetches and returns stock information for a given symbol, including the current price",
        "medium_unstructured": "The code sets up an Express GET endpoint at '/api/stock/:symbol' that fetches daily stock data for a specified symbol using the yahooFinance API. It processes the data to extract date, close price, and volume, and now also includes the current price (latest close) in the JSON response. If an error occurs, it logs the error and sends a 500 response.",
        "medium_structured": "• Sets up a GET endpoint at '/api/stock/:symbol'\n• Fetches daily stock data for the given symbol from yahooFinance\n• Processes and formats the data to include:\n  ◦ Date\n  ◦ Closing price\n  ◦ Volume\n  ◦ Current price (latest close) added to the response\n• Returns the formatted data as a JSON response\n• Handles errors by logging and sending a 500 status",
        "high_unstructured": "This code defines an asynchronous Express route handler for GET requests to '/api/stock/:symbol', where it retrieves historical daily stock data for the specified symbol from the yahooFinance API, starting from January 1, 2024. The symbol is converted to uppercase, and the response now includes the ticker, company name (if available), the current price (latest close), and an array of objects each containing the date, close price, and volume for each day. The response is logged to the console before being sent as JSON. In case of any errors during data retrieval or processing, the error is logged and a 500 error message is returned to the client.",
        "high_structured": "• Defines an asynchronous GET endpoint at '/api/stock/:symbol'\n• Retrieves the stock symbol from the URL and converts it to uppercase\n• Fetches historical daily stock data from yahooFinance starting from 2024-01-01\n• Extracts and formats the response:\n  ◦ Includes the ticker symbol and company name (from API metadata or symbol fallback)\n  ◦ Adds the current price (latest close) to the response\n  ◦ Maps each quote to an object with:\n    ◦ date\n    ◦ close price\n    ◦ volume\n• Logs the formatted response to the console\n• Sends the response as JSON to the client\n• Handles errors by logging them and returning a 500 status with an error message"
      },
      "mappings": {
        "low_unstructured": [
          {
            "summaryComponent": "defines an API endpoint",
            "codeSegments": [
              {
                "code": "app.get(\"/api/stock/:symbol\", async (req, res) => {",
                "line": 1
              }
            ]
          },
          {
            "summaryComponent": "retrieves and returns stock data",
            "codeSegments": [
              {
                "code": "const data = await yahooFinance.chart(symbol, {",
                "line": 4
              },
              {
                "code": "res.json(response);",
                "line": 25
              }
            ]
          },
          {
            "summaryComponent": "for a given symbol",
            "codeSegments": [
              {
                "code": "const symbol = req.params.symbol.toUpperCase();",
                "line": 3
              }
            ]
          },
          {
            "summaryComponent": "now also including the current price in the response",
            "codeSegments": [
              {
                "code": "const currentPrice = quotes[quotes.length - 1]?.close || null;",
                "line": 11
              },
              {
                "code": "currentPrice: currentPrice,",
                "line": 16
              }
            ]
          }
        ],
        "low_structured": [
          {
            "summaryComponent": "Defines a GET endpoint for stock data",
            "codeSegments": [
              {
                "code": "app.get(\"/api/stock/:symbol\", async (req, res) => {",
                "line": 1
              }
            ]
          },
          {
            "summaryComponent": "Fetches and returns stock information for a given symbol, including the current price",
            "codeSegments": [
              {
                "code": "const symbol = req.params.symbol.toUpperCase();",
                "line": 3
              },
              {
                "code": "const data = await yahooFinance.chart(symbol, {",
                "line": 4
              },
              {
                "code": "const currentPrice = quotes[quotes.length - 1]?.close || null;",
                "line": 11
              },
              {
                "code": "res.json(response);",
                "line": 25
              }
            ]
          }
        ],
        "medium_unstructured": [
          {
            "summaryComponent": "sets up an Express GET endpoint at '/api/stock/:symbol'",
            "codeSegments": [
              {
                "code": "app.get(\"/api/stock/:symbol\", async (req, res) => {",
                "line": 1
              }
            ]
          },
          {
            "summaryComponent": "fetches daily stock data for a specified symbol using the yahooFinance API",
            "codeSegments": [
              {
                "code": "const symbol = req.params.symbol.toUpperCase();",
                "line": 3
              },
              {
                "code": "const data = await yahooFinance.chart(symbol, {",
                "line": 4
              },
              {
                "code": "period1: \"2024-01-01\",",
                "line": 5
              },
              {
                "code": "interval: \"1d\",",
                "line": 6
              }
            ]
          },
          {
            "summaryComponent": "processes the data to extract date, close price, and volume",
            "codeSegments": [
              {
                "code": "data.quotes;",
                "line": 8
              },
              {
                "code": "data: quotes.map((q) => ({",
                "line": 17
              },
              {
                "code": "date: q.date,",
                "line": 18
              },
              {
                "code": "close: q.close,",
                "line": 19
              },
              {
                "code": "volume: q.volume,",
                "line": 20
              }
            ]
          },
          {
            "summaryComponent": "now also includes the current price (latest close) in the JSON response",
            "codeSegments": [
              {
                "code": "const currentPrice = quotes[quotes.length - 1]?.close || null;",
                "line": 11
              },
              {
                "code": "currentPrice: currentPrice,",
                "line": 16
              }
            ]
          },
          {
            "summaryComponent": "in the JSON response",
            "codeSegments": [
              {
                "code": "res.json(response);",
                "line": 25
              }
            ]
          },
          {
            "summaryComponent": "If an error occurs",
            "codeSegments": [
              {
                "code": "catch (err) {",
                "line": 26
              }
            ]
          },
          {
            "summaryComponent": "it logs the error",
            "codeSegments": [
              {
                "code": "console.error(err);",
                "line": 27
              }
            ]
          },
          {
            "summaryComponent": "and sends a 500 response",
            "codeSegments": [
              {
                "code": "res.status(500).send(\"Error fetching stock data\");",
                "line": 28
              }
            ]
          }
        ],
        "medium_structured": [
          {
            "summaryComponent": "Sets up a GET endpoint at '/api/stock/:symbol'",
            "codeSegments": [
              {
                "code": "app.get(\"/api/stock/:symbol\", async (req, res) => {",
                "line": 1
              }
            ]
          },
          {
            "summaryComponent": "Fetches daily stock data for the given symbol from yahooFinance",
            "codeSegments": [
              {
                "code": "const data = await yahooFinance.chart(symbol, {",
                "line": 4
              },
              {
                "code": "interval: \"1d\",",
                "line": 6
              }
            ]
          },
          {
            "summaryComponent": "Processes and formats the data to include:",
            "codeSegments": [
              {
                "code": "const response = {",
                "line": 13
              }
            ]
          },
          {
            "summaryComponent": "Date",
            "codeSegments": [
              {
                "code": "date: q.date,",
                "line": 18
              }
            ]
          },
          {
            "summaryComponent": "Closing price",
            "codeSegments": [
              {
                "code": "close: q.close,",
                "line": 19
              }
            ]
          },
          {
            "summaryComponent": "Volume",
            "codeSegments": [
              {
                "code": "volume: q.volume,",
                "line": 20
              }
            ]
          },
          {
            "summaryComponent": "Current price (latest close) added to the response",
            "codeSegments": [
              {
                "code": "const currentPrice = quotes[quotes.length - 1]?.close || null;",
                "line": 11
              },
              {
                "code": "currentPrice: currentPrice,",
                "line": 16
              }
            ]
          },
          {
            "summaryComponent": "Returns the formatted data as a JSON response",
            "codeSegments": [
              {
                "code": "res.json(response);",
                "line": 25
              }
            ]
          },
          {
            "summaryComponent": "Handles errors by logging and sending a 500 status",
            "codeSegments": [
              {
                "code": "console.error(err);",
                "line": 27
              },
              {
                "code": "res.status(500).send(\"Error fetching stock data\");",
                "line": 28
              }
            ]
          }
        ],
        "high_unstructured": [
          {
            "summaryComponent": "an asynchronous Express route handler for GET requests to '/api/stock/:symbol'",
            "codeSegments": [
              {
                "code": "app.get(\"/api/stock/:symbol\", async (req, res) => {",
                "line": 1
              }
            ]
          },
          {
            "summaryComponent": "retrieves historical daily stock data for the specified symbol from the yahooFinance API",
            "codeSegments": [
              {
                "code": "const data = await yahooFinance.chart(symbol, {",
                "line": 4
              },
              {
                "code": "interval: \"1d\",",
                "line": 6
              }
            ]
          },
          {
            "summaryComponent": "starting from January 1, 2024",
            "codeSegments": [
              {
                "code": "period1: \"2024-01-01\",",
                "line": 5
              }
            ]
          },
          {
            "summaryComponent": "The symbol is converted to uppercase",
            "codeSegments": [
              {
                "code": "const symbol = req.params.symbol.toUpperCase();",
                "line": 3
              }
            ]
          },
          {
            "summaryComponent": "the response now includes the ticker",
            "codeSegments": [
              {
                "code": "ticker: symbol,",
                "line": 14
              }
            ]
          },
          {
            "summaryComponent": "company name (if available)",
            "codeSegments": [
              {
                "code": "const companyName = data.meta?.shortName || symbol;",
                "line": 10
              },
              {
                "code": "name: companyName,",
                "line": 15
              }
            ]
          },
          {
            "summaryComponent": "the current price (latest close)",
            "codeSegments": [
              {
                "code": "const currentPrice = quotes[quotes.length - 1]?.close || null;",
                "line": 11
              },
              {
                "code": "currentPrice: currentPrice,",
                "line": 16
              }
            ]
          },
          {
            "summaryComponent": "an array of objects each containing the date, close price, and volume for each day",
            "codeSegments": [
              {
                "code": "data: quotes.map((q) => ({",
                "line": 17
              },
              {
                "code": "date: q.date,",
                "line": 18
              },
              {
                "code": "close: q.close,",
                "line": 19
              },
              {
                "code": "volume: q.volume,",
                "line": 20
              }
            ]
          },
          {
            "summaryComponent": "The response is logged to the console before being sent as JSON",
            "codeSegments": [
              {
                "code": "console.log(response);",
                "line": 24
              },
              {
                "code": "res.json(response);",
                "line": 25
              }
            ]
          },
          {
            "summaryComponent": "In case of any errors during data retrieval or processing, the error is logged and a 500 error message is returned to the client",
            "codeSegments": [
              {
                "code": "catch (err) {",
                "line": 26
              },
              {
                "code": "console.error(err);",
                "line": 27
              },
              {
                "code": "res.status(500).send(\"Error fetching stock data\");",
                "line": 28
              }
            ]
          }
        ],
        "high_structured": [
          {
            "summaryComponent": "Defines an asynchronous GET endpoint at '/api/stock/:symbol'",
            "codeSegments": [
              {
                "code": "app.get(\"/api/stock/:symbol\", async (req, res) => {",
                "line": 1
              }
            ]
          },
          {
            "summaryComponent": "Retrieves the stock symbol from the URL and converts it to uppercase",
            "codeSegments": [
              {
                "code": "const symbol = req.params.symbol.toUpperCase();",
                "line": 3
              }
            ]
          },
          {
            "summaryComponent": "Fetches historical daily stock data from yahooFinance starting from 2024-01-01",
            "codeSegments": [
              {
                "code": "const data = await yahooFinance.chart(symbol, {",
                "line": 4
              },
              {
                "code": "period1: \"2024-01-01\",",
                "line": 5
              },
              {
                "code": "interval: \"1d\",",
                "line": 6
              }
            ]
          },
          {
            "summaryComponent": "Includes the ticker symbol and company name (from API metadata or symbol fallback)",
            "codeSegments": [
              {
                "code": "ticker: symbol,",
                "line": 14
              },
              {
                "code": "name: companyName,",
                "line": 15
              },
              {
                "code": "const companyName = data.meta?.shortName || symbol;",
                "line": 10
              }
            ]
          },
          {
            "summaryComponent": "Adds the current price (latest close) to the response",
            "codeSegments": [
              {
                "code": "const currentPrice = quotes[quotes.length - 1]?.close || null;",
                "line": 11
              },
              {
                "code": "currentPrice: currentPrice,",
                "line": 16
              }
            ]
          },
          {
            "summaryComponent": "Maps each quote to an object with:",
            "codeSegments": [
              {
                "code": "data: quotes.map((q) => ({",
                "line": 17
              }
            ]
          },
          {
            "summaryComponent": "date",
            "codeSegments": [
              {
                "code": "date: q.date,",
                "line": 18
              }
            ]
          },
          {
            "summaryComponent": "close price",
            "codeSegments": [
              {
                "code": "close: q.close,",
                "line": 19
              }
            ]
          },
          {
            "summaryComponent": "volume",
            "codeSegments": [
              {
                "code": "volume: q.volume,",
                "line": 20
              }
            ]
          },
          {
            "summaryComponent": "Logs the formatted response to the console",
            "codeSegments": [
              {
                "code": "console.log(response);",
                "line": 24
              }
            ]
          },
          {
            "summaryComponent": "Sends the response as JSON to the client",
            "codeSegments": [
              {
                "code": "res.json(response);",
                "line": 25
              }
            ]
          },
          {
            "summaryComponent": "Handles errors by logging them and returning a 500 status with an error message",
            "codeSegments": [
              {
                "code": "console.error(err);",
                "line": 27
              },
              {
                "code": "res.status(500).send(\"Error fetching stock data\");",
                "line": 28
              }
            ]
          }
        ]
      }
    }
  },
  {
    "task_id": "FD-C",
    "metadata": {
      "file_context": "FinanceDashboard/frontend/src/StockChart.jsx",
      "processing_timestamp": 82136.401656831
    },
    "old_code": {
      "code": "<LineChart\n          data={chartData}\n          margin={{ top: 10, right: 30, left: 0, bottom: 0 }}\n        >\n          <XAxis dataKey=\"date\" />\n          <YAxis domain={[\"auto\", \"auto\"]} />\n          <Tooltip />\n          <Legend />\n          <Line type=\"monotone\" dataKey=\"price\" stroke=\"#8884d8\" dot={false} />\n        </LineChart>",
      "summary": {
        "title": "LineChart Component Rendering Stock Price Data",
        "low_unstructured": "This code renders a line chart displaying price data over time.",
        "low_structured": "• Renders a line chart\n• Shows data over time\n• Displays price information",
        "medium_unstructured": "The code creates a line chart using the provided chartData, plotting price against date. It includes axes, a tooltip, and a legend for better readability. The chart uses a monotone line without dots for each data point.",
        "medium_structured": "• Renders a LineChart with chartData\n• Configures XAxis to use 'date' and YAxis with automatic scaling\n• Adds Tooltip and Legend components\n• Plots a monotone line for 'price' without dots",
        "high_unstructured": "This snippet renders a LineChart that visualizes price data over time using the provided chartData. The XAxis is set to display dates, while the YAxis automatically adjusts its domain based on the data. Additional features include a Tooltip for interactive data inspection and a Legend for identifying the data series. The price is plotted as a smooth monotone line with a specific color, and data point dots are omitted for a cleaner look.",
        "high_structured": "• Renders a LineChart component with custom margins\n• Sets up axes:\n  ◦ XAxis displays 'date' from the data\n  ◦ YAxis automatically scales based on data range\n• Includes interactive features:\n  ◦ Tooltip for displaying detailed data on hover\n  ◦ Legend for identifying the charted data series\n• Plots a monotone line for the 'price' dataKey\n  ◦ Uses stroke color '#8884d8'\n  ◦ Disables dots on individual data points for a smoother appearance"
      },
      "mappings": {
        "low_unstructured": [
          {
            "summaryComponent": "renders a line chart",
            "codeSegments": [
              {
                "code": "<LineChart",
                "line": 1
              },
              {
                "code": "</LineChart>",
                "line": 10
              }
            ]
          },
          {
            "summaryComponent": "displaying price data",
            "codeSegments": [
              {
                "code": "<Line type=\"monotone\" dataKey=\"price\" stroke=\"#8884d8\" dot={false} />",
                "line": 9
              }
            ]
          },
          {
            "summaryComponent": "over time",
            "codeSegments": [
              {
                "code": "<XAxis dataKey=\"date\" />",
                "line": 5
              }
            ]
          }
        ],
        "low_structured": [
          {
            "summaryComponent": "Renders a line chart",
            "codeSegments": [
              {
                "code": "<LineChart",
                "line": 1
              },
              {
                "code": "</LineChart>",
                "line": 10
              }
            ]
          },
          {
            "summaryComponent": "Shows data over time",
            "codeSegments": [
              {
                "code": "<XAxis dataKey=\"date\" />",
                "line": 5
              }
            ]
          },
          {
            "summaryComponent": "Displays price information",
            "codeSegments": [
              {
                "code": "<Line type=\"monotone\" dataKey=\"price\" stroke=\"#8884d8\" dot={false} />",
                "line": 9
              }
            ]
          }
        ],
        "medium_unstructured": [
          {
            "summaryComponent": "creates a line chart",
            "codeSegments": [
              {
                "code": "<LineChart",
                "line": 1
              },
              {
                "code": "</LineChart>",
                "line": 10
              }
            ]
          },
          {
            "summaryComponent": "using the provided chartData",
            "codeSegments": [
              {
                "code": "data={chartData}",
                "line": 2
              }
            ]
          },
          {
            "summaryComponent": "plotting price against date",
            "codeSegments": [
              {
                "code": "<XAxis dataKey=\"date\" />",
                "line": 5
              },
              {
                "code": "<Line type=\"monotone\" dataKey=\"price\" stroke=\"#8884d8\" dot={false} />",
                "line": 9
              }
            ]
          },
          {
            "summaryComponent": "includes axes",
            "codeSegments": [
              {
                "code": "<XAxis dataKey=\"date\" />",
                "line": 5
              },
              {
                "code": "<YAxis domain={[\"auto\", \"auto\"]} />",
                "line": 6
              }
            ]
          },
          {
            "summaryComponent": "a tooltip",
            "codeSegments": [
              {
                "code": "<Tooltip />",
                "line": 7
              }
            ]
          },
          {
            "summaryComponent": "and a legend",
            "codeSegments": [
              {
                "code": "<Legend />",
                "line": 8
              }
            ]
          },
          {
            "summaryComponent": "for better readability",
            "codeSegments": [
              {
                "code": "<Tooltip />",
                "line": 7
              },
              {
                "code": "<Legend />",
                "line": 8
              }
            ]
          },
          {
            "summaryComponent": "uses a monotone line",
            "codeSegments": [
              {
                "code": "type=\"monotone\"",
                "line": 9
              }
            ]
          },
          {
            "summaryComponent": "without dots for each data point",
            "codeSegments": [
              {
                "code": "dot={false}",
                "line": 9
              }
            ]
          }
        ],
        "medium_structured": [
          {
            "summaryComponent": "Renders a LineChart with chartData",
            "codeSegments": [
              {
                "code": "<LineChart",
                "line": 1
              },
              {
                "code": "data={chartData}",
                "line": 2
              }
            ]
          },
          {
            "summaryComponent": "Configures XAxis to use 'date' and YAxis with automatic scaling",
            "codeSegments": [
              {
                "code": "<XAxis dataKey=\"date\" />",
                "line": 5
              },
              {
                "code": "<YAxis domain={[\"auto\", \"auto\"]} />",
                "line": 6
              }
            ]
          },
          {
            "summaryComponent": "Adds Tooltip and Legend components",
            "codeSegments": [
              {
                "code": "<Tooltip />",
                "line": 7
              },
              {
                "code": "<Legend />",
                "line": 8
              }
            ]
          },
          {
            "summaryComponent": "Plots a monotone line for 'price' without dots",
            "codeSegments": [
              {
                "code": "<Line type=\"monotone\" dataKey=\"price\" stroke=\"#8884d8\" dot={false} />",
                "line": 9
              }
            ]
          }
        ],
        "high_unstructured": [
          {
            "summaryComponent": "renders a LineChart",
            "codeSegments": [
              {
                "code": "<LineChart",
                "line": 1
              },
              {
                "code": "</LineChart>",
                "line": 10
              }
            ]
          },
          {
            "summaryComponent": "visualizes price data over time",
            "codeSegments": [
              {
                "code": "<Line type=\"monotone\" dataKey=\"price\" stroke=\"#8884d8\" dot={false} />",
                "line": 9
              }
            ]
          },
          {
            "summaryComponent": "using the provided chartData",
            "codeSegments": [
              {
                "code": "data={chartData}",
                "line": 2
              }
            ]
          },
          {
            "summaryComponent": "The XAxis is set to display dates",
            "codeSegments": [
              {
                "code": "<XAxis dataKey=\"date\" />",
                "line": 5
              }
            ]
          },
          {
            "summaryComponent": "the YAxis automatically adjusts its domain based on the data",
            "codeSegments": [
              {
                "code": "<YAxis domain={[\"auto\", \"auto\"]} />",
                "line": 6
              }
            ]
          },
          {
            "summaryComponent": "a Tooltip for interactive data inspection",
            "codeSegments": [
              {
                "code": "<Tooltip />",
                "line": 7
              }
            ]
          },
          {
            "summaryComponent": "a Legend for identifying the data series",
            "codeSegments": [
              {
                "code": "<Legend />",
                "line": 8
              }
            ]
          },
          {
            "summaryComponent": "The price is plotted as a smooth monotone line",
            "codeSegments": [
              {
                "code": "<Line type=\"monotone\" dataKey=\"price\" stroke=\"#8884d8\" dot={false} />",
                "line": 9
              }
            ]
          },
          {
            "summaryComponent": "with a specific color",
            "codeSegments": [
              {
                "code": "stroke=\"#8884d8\"",
                "line": 9
              }
            ]
          },
          {
            "summaryComponent": "data point dots are omitted for a cleaner look",
            "codeSegments": [
              {
                "code": "dot={false}",
                "line": 9
              }
            ]
          }
        ],
        "high_structured": [
          {
            "summaryComponent": "Renders a LineChart component with custom margins",
            "codeSegments": [
              {
                "code": "<LineChart",
                "line": 1
              },
              {
                "code": "margin={{ top: 10, right: 30, left: 0, bottom: 0 }}",
                "line": 3
              }
            ]
          },
          {
            "summaryComponent": "XAxis displays 'date' from the data",
            "codeSegments": [
              {
                "code": "<XAxis dataKey=\"date\" />",
                "line": 5
              }
            ]
          },
          {
            "summaryComponent": "YAxis automatically scales based on data range",
            "codeSegments": [
              {
                "code": "<YAxis domain={[\"auto\", \"auto\"]} />",
                "line": 6
              }
            ]
          },
          {
            "summaryComponent": "Tooltip for displaying detailed data on hover",
            "codeSegments": [
              {
                "code": "<Tooltip />",
                "line": 7
              }
            ]
          },
          {
            "summaryComponent": "Legend for identifying the charted data series",
            "codeSegments": [
              {
                "code": "<Legend />",
                "line": 8
              }
            ]
          },
          {
            "summaryComponent": "Plots a monotone line for the 'price' dataKey",
            "codeSegments": [
              {
                "code": "<Line type=\"monotone\" dataKey=\"price\" stroke=\"#8884d8\" dot={false} />",
                "line": 9
              }
            ]
          },
          {
            "summaryComponent": "Uses stroke color '#8884d8'",
            "codeSegments": [
              {
                "code": "stroke=\"#8884d8\"",
                "line": 9
              }
            ]
          },
          {
            "summaryComponent": "Disables dots on individual data points for a smoother appearance",
            "codeSegments": [
              {
                "code": "dot={false}",
                "line": 9
              }
            ]
          }
        ]
      }
    },
    "new_code": {
      "code": "<LineChart\n          data={chartData}\n          margin={{ top: 10, right: 30, left: 0, bottom: 0 }}\n        >\n          <XAxis dataKey=\"date\" tickFormatter={formatDateString} />\n          <YAxis domain={[\"auto\", \"auto\"]} />\n          <Tooltip />\n          <Legend />\n          <Line type=\"monotone\" dataKey=\"price\" stroke=\"#8884d8\" dot={false} />\n          <ReferenceLine\n            y={currentPrice}\n            stroke=\"red\"\n            strokeDasharray=\"5 5\"\n          />{\" \"}\n        </LineChart>",
      "summary": {
        "title": "LineChart Component Rendering Stock Price Data with Date Formatting and Reference Line",
        "low_unstructured": "This code renders a line chart displaying price data over time, now formatting the date labels and adding a reference line at the current price.",
        "low_structured": "• Renders a line chart\n• Shows data over time\n• Displays price information\n• Formats date labels on the X axis\n• Adds a reference line at the current price",
        "medium_unstructured": "The code creates a line chart using the provided chartData, plotting price against date. It includes axes, a tooltip, and a legend for better readability. The chart uses a monotone line without dots for each data point. The XAxis now formats date labels using formatDateString, and a red dashed reference line is added at the current price.",
        "medium_structured": "• Renders a LineChart with chartData\n• Configures XAxis to use 'date' with formatted labels via formatDateString and YAxis with automatic scaling\n• Adds Tooltip and Legend components\n• Plots a monotone line for 'price' without dots\n• Adds a red dashed ReferenceLine at the current price",
        "high_unstructured": "This snippet renders a LineChart that visualizes price data over time using the provided chartData. The XAxis is set to display dates, now formatting the labels with formatDateString, while the YAxis automatically adjusts its domain based on the data. Additional features include a Tooltip for interactive data inspection and a Legend for identifying the data series. The price is plotted as a smooth monotone line with a specific color, and data point dots are omitted for a cleaner look. A red dashed ReferenceLine is now drawn at the current price for visual emphasis.",
        "high_structured": "• Renders a LineChart component with custom margins\n• Sets up axes:\n  ◦ XAxis displays 'date' from the data, now formatting labels with formatDateString\n  ◦ YAxis automatically scales based on data range\n• Includes interactive features:\n  ◦ Tooltip for displaying detailed data on hover\n  ◦ Legend for identifying the charted data series\n• Plots a monotone line for the 'price' dataKey\n  ◦ Uses stroke color '#8884d8'\n  ◦ Disables dots on individual data points for a smoother appearance\n• Adds a red dashed ReferenceLine at the current price"
      },
      "mappings": {
        "low_unstructured": [
          {
            "summaryComponent": "renders a line chart",
            "codeSegments": [
              {
                "code": "<LineChart",
                "line": 1
              },
              {
                "code": "</LineChart>",
                "line": 15
              }
            ]
          },
          {
            "summaryComponent": "displaying price data over time",
            "codeSegments": [
              {
                "code": "data={chartData}",
                "line": 2
              },
              {
                "code": "<XAxis dataKey=\"date\" tickFormatter={formatDateString} />",
                "line": 5
              },
              {
                "code": "<Line type=\"monotone\" dataKey=\"price\" stroke=\"#8884d8\" dot={false} />",
                "line": 9
              }
            ]
          },
          {
            "summaryComponent": "formatting the date labels",
            "codeSegments": [
              {
                "code": "tickFormatter={formatDateString}",
                "line": 5
              }
            ]
          },
          {
            "summaryComponent": "adding a reference line at the current price",
            "codeSegments": [
              {
                "code": "<ReferenceLine",
                "line": 10
              },
              {
                "code": "y={currentPrice}",
                "line": 11
              }
            ]
          }
        ],
        "low_structured": [
          {
            "summaryComponent": "Renders a line chart",
            "codeSegments": [
              {
                "code": "<LineChart",
                "line": 1
              },
              {
                "code": "</LineChart>",
                "line": 15
              }
            ]
          },
          {
            "summaryComponent": "Shows data over time",
            "codeSegments": [
              {
                "code": "data={chartData}",
                "line": 2
              },
              {
                "code": "<XAxis dataKey=\"date\" tickFormatter={formatDateString} />",
                "line": 5
              }
            ]
          },
          {
            "summaryComponent": "Displays price information",
            "codeSegments": [
              {
                "code": "<Line type=\"monotone\" dataKey=\"price\" stroke=\"#8884d8\" dot={false} />",
                "line": 9
              }
            ]
          },
          {
            "summaryComponent": "Formats date labels on the X axis",
            "codeSegments": [
              {
                "code": "tickFormatter={formatDateString}",
                "line": 5
              }
            ]
          },
          {
            "summaryComponent": "Adds a reference line at the current price",
            "codeSegments": [
              {
                "code": "<ReferenceLine",
                "line": 10
              },
              {
                "code": "y={currentPrice}",
                "line": 11
              }
            ]
          }
        ],
        "medium_unstructured": [
          {
            "summaryComponent": "creates a line chart",
            "codeSegments": [
              {
                "code": "<LineChart",
                "line": 1
              },
              {
                "code": "</LineChart>",
                "line": 15
              }
            ]
          },
          {
            "summaryComponent": "using the provided chartData",
            "codeSegments": [
              {
                "code": "data={chartData}",
                "line": 2
              }
            ]
          },
          {
            "summaryComponent": "plotting price against date",
            "codeSegments": [
              {
                "code": "<XAxis dataKey=\"date\" tickFormatter={formatDateString} />",
                "line": 5
              },
              {
                "code": "<Line type=\"monotone\" dataKey=\"price\" stroke=\"#8884d8\" dot={false} />",
                "line": 9
              }
            ]
          },
          {
            "summaryComponent": "includes axes",
            "codeSegments": [
              {
                "code": "<XAxis dataKey=\"date\" tickFormatter={formatDateString} />",
                "line": 5
              },
              {
                "code": "<YAxis domain={[\"auto\", \"auto\"]} />",
                "line": 6
              }
            ]
          },
          {
            "summaryComponent": "a tooltip",
            "codeSegments": [
              {
                "code": "<Tooltip />",
                "line": 7
              }
            ]
          },
          {
            "summaryComponent": "and a legend",
            "codeSegments": [
              {
                "code": "<Legend />",
                "line": 8
              }
            ]
          },
          {
            "summaryComponent": "for better readability",
            "codeSegments": [
              {
                "code": "<Tooltip />",
                "line": 7
              },
              {
                "code": "<Legend />",
                "line": 8
              }
            ]
          },
          {
            "summaryComponent": "uses a monotone line without dots for each data point",
            "codeSegments": [
              {
                "code": "<Line type=\"monotone\" dataKey=\"price\" stroke=\"#8884d8\" dot={false} />",
                "line": 9
              }
            ]
          },
          {
            "summaryComponent": "XAxis now formats date labels using formatDateString",
            "codeSegments": [
              {
                "code": "tickFormatter={formatDateString}",
                "line": 5
              }
            ]
          },
          {
            "summaryComponent": "a red dashed reference line is added at the current price",
            "codeSegments": [
              {
                "code": "<ReferenceLine",
                "line": 10
              },
              {
                "code": "y={currentPrice}",
                "line": 11
              },
              {
                "code": "stroke=\"red\"",
                "line": 12
              },
              {
                "code": "strokeDasharray=\"5 5\"",
                "line": 13
              }
            ]
          }
        ],
        "medium_structured": [
          {
            "summaryComponent": "Renders a LineChart with chartData",
            "codeSegments": [
              {
                "code": "<LineChart",
                "line": 1
              },
              {
                "code": "data={chartData}",
                "line": 2
              }
            ]
          },
          {
            "summaryComponent": "Configures XAxis to use 'date' with formatted labels via formatDateString and YAxis with automatic scaling",
            "codeSegments": [
              {
                "code": "<XAxis dataKey=\"date\" tickFormatter={formatDateString} />",
                "line": 5
              },
              {
                "code": "<YAxis domain={[\"auto\", \"auto\"]} />",
                "line": 6
              }
            ]
          },
          {
            "summaryComponent": "Adds Tooltip and Legend components",
            "codeSegments": [
              {
                "code": "<Tooltip />",
                "line": 7
              },
              {
                "code": "<Legend />",
                "line": 8
              }
            ]
          },
          {
            "summaryComponent": "Plots a monotone line for 'price' without dots",
            "codeSegments": [
              {
                "code": "<Line type=\"monotone\" dataKey=\"price\" stroke=\"#8884d8\" dot={false} />",
                "line": 9
              }
            ]
          },
          {
            "summaryComponent": "Adds a red dashed ReferenceLine at the current price",
            "codeSegments": [
              {
                "code": "<ReferenceLine",
                "line": 10
              },
              {
                "code": "y={currentPrice}",
                "line": 11
              },
              {
                "code": "stroke=\"red\"",
                "line": 12
              },
              {
                "code": "strokeDasharray=\"5 5\"",
                "line": 13
              }
            ]
          }
        ],
        "high_unstructured": [
          {
            "summaryComponent": "renders a LineChart",
            "codeSegments": [
              {
                "code": "<LineChart",
                "line": 1
              },
              {
                "code": "</LineChart>",
                "line": 15
              }
            ]
          },
          {
            "summaryComponent": "visualizes price data over time",
            "codeSegments": [
              {
                "code": "<Line type=\"monotone\" dataKey=\"price\" stroke=\"#8884d8\" dot={false} />",
                "line": 9
              }
            ]
          },
          {
            "summaryComponent": "using the provided chartData",
            "codeSegments": [
              {
                "code": "data={chartData}",
                "line": 2
              }
            ]
          },
          {
            "summaryComponent": "XAxis is set to display dates",
            "codeSegments": [
              {
                "code": "<XAxis dataKey=\"date\" tickFormatter={formatDateString} />",
                "line": 5
              }
            ]
          },
          {
            "summaryComponent": "formatting the labels with formatDateString",
            "codeSegments": [
              {
                "code": "tickFormatter={formatDateString}",
                "line": 5
              }
            ]
          },
          {
            "summaryComponent": "YAxis automatically adjusts its domain based on the data",
            "codeSegments": [
              {
                "code": "<YAxis domain={[\"auto\", \"auto\"]} />",
                "line": 6
              }
            ]
          },
          {
            "summaryComponent": "Tooltip for interactive data inspection",
            "codeSegments": [
              {
                "code": "<Tooltip />",
                "line": 7
              }
            ]
          },
          {
            "summaryComponent": "Legend for identifying the data series",
            "codeSegments": [
              {
                "code": "<Legend />",
                "line": 8
              }
            ]
          },
          {
            "summaryComponent": "price is plotted as a smooth monotone line with a specific color",
            "codeSegments": [
              {
                "code": "<Line type=\"monotone\" dataKey=\"price\" stroke=\"#8884d8\" dot={false} />",
                "line": 9
              }
            ]
          },
          {
            "summaryComponent": "data point dots are omitted for a cleaner look",
            "codeSegments": [
              {
                "code": "dot={false}",
                "line": 9
              }
            ]
          },
          {
            "summaryComponent": "A red dashed ReferenceLine is now drawn at the current price for visual emphasis",
            "codeSegments": [
              {
                "code": "<ReferenceLine",
                "line": 10
              },
              {
                "code": "y={currentPrice}",
                "line": 11
              },
              {
                "code": "stroke=\"red\"",
                "line": 12
              },
              {
                "code": "strokeDasharray=\"5 5\"",
                "line": 13
              }
            ]
          }
        ],
        "high_structured": [
          {
            "summaryComponent": "Renders a LineChart component with custom margins",
            "codeSegments": [
              {
                "code": "<LineChart",
                "line": 1
              },
              {
                "code": "margin={{ top: 10, right: 30, left: 0, bottom: 0 }}",
                "line": 3
              }
            ]
          },
          {
            "summaryComponent": "XAxis displays 'date' from the data, now formatting labels with formatDateString",
            "codeSegments": [
              {
                "code": "<XAxis dataKey=\"date\" tickFormatter={formatDateString} />",
                "line": 5
              }
            ]
          },
          {
            "summaryComponent": "YAxis automatically scales based on data range",
            "codeSegments": [
              {
                "code": "<YAxis domain={[\"auto\", \"auto\"]} />",
                "line": 6
              }
            ]
          },
          {
            "summaryComponent": "Tooltip for displaying detailed data on hover",
            "codeSegments": [
              {
                "code": "<Tooltip />",
                "line": 7
              }
            ]
          },
          {
            "summaryComponent": "Legend for identifying the charted data series",
            "codeSegments": [
              {
                "code": "<Legend />",
                "line": 8
              }
            ]
          },
          {
            "summaryComponent": "Plots a monotone line for the 'price' dataKey",
            "codeSegments": [
              {
                "code": "<Line type=\"monotone\" dataKey=\"price\" stroke=\"#8884d8\" dot={false} />",
                "line": 9
              }
            ]
          },
          {
            "summaryComponent": "Uses stroke color '#8884d8'",
            "codeSegments": [
              {
                "code": "stroke=\"#8884d8\"",
                "line": 9
              }
            ]
          },
          {
            "summaryComponent": "Disables dots on individual data points for a smoother appearance",
            "codeSegments": [
              {
                "code": "dot={false}",
                "line": 9
              }
            ]
          },
          {
            "summaryComponent": "Adds a red dashed ReferenceLine at the current price",
            "codeSegments": [
              {
                "code": "<ReferenceLine",
                "line": 10
              },
              {
                "code": "y={currentPrice}",
                "line": 11
              },
              {
                "code": "stroke=\"red\"",
                "line": 12
              },
              {
                "code": "strokeDasharray=\"5 5\"",
                "line": 13
              }
            ]
          }
        ]
      }
    }
  },
  {
    "task_id": "MP-A",
    "metadata": {
      "file_context": "MVPPredictor/scraper.py",
      "processing_timestamp": 82211.960758266
    },
    "old_code": {
      "code": "def scrape_season_stats(year):\n    base_url_reg = (\n        f\"https://www.basketball-reference.com/leagues/NBA_{year}_per_game.html\"\n    )\n    df_reg = pd.read_html(base_url_reg, header=0)[0]\n    df_reg = df_reg[df_reg[\"Player\"] != \"Player\"]  # remove repeated header rows\n    df_reg[\"Year\"] = year\n\n    df_reg = df_reg[\n        [\"Player\", \"Year\", \"PTS\", \"AST\", \"TRB\", \"FG%\"]\n    ]  # Keep only specified columns\n    df_reg = df_reg.dropna(\n        subset=[\"PTS\", \"AST\", \"TRB\", \"FG%\"]\n    )  # Ensure key stats aren't invalid\n    return df_reg",
      "summary": {
        "title": "Function to Scrape and Clean NBA Season Player Stats",
        "low_unstructured": "This function retrieves and processes NBA player statistics for a given season from Basketball Reference.",
        "low_structured": "• Fetches NBA season stats from a website\n• Cleans and filters the data\n• Returns selected player statistics",
        "medium_unstructured": "The function downloads per-game NBA player statistics for a specified year from Basketball Reference. It cleans the data by removing repeated header rows, adds a 'Year' column, selects key statistical columns, and drops rows with missing values in those columns. The final cleaned DataFrame is then returned.",
        "medium_structured": "• Downloads NBA per-game stats for a given year from Basketball Reference\n• Cleans data by removing repeated header rows\n• Adds a 'Year' column to the DataFrame\n• Selects only 'Player', 'Year', 'PTS', 'AST', 'TRB', and 'FG%' columns\n• Drops rows with missing values in key stats",
        "high_unstructured": "This function, scrape_season_stats, fetches NBA per-game player statistics for a specified year from Basketball Reference using pandas' read_html. It removes any repeated header rows that may appear within the data, adds a 'Year' column to indicate the season, and filters the DataFrame to retain only the 'Player', 'Year', 'PTS', 'AST', 'TRB', and 'FG%' columns. To ensure data integrity, it drops any rows where these key statistical fields are missing. The function ultimately returns a clean DataFrame containing essential player stats for the given NBA season.",
        "high_structured": "• Fetches NBA per-game player statistics for a specified year from Basketball Reference\n• Cleans the raw data\n  ◦ Removes repeated header rows that may be present in the table\n  ◦ Adds a 'Year' column to each row for context\n• Filters the DataFrame to keep only relevant columns\n  ◦ Retains 'Player', 'Year', 'PTS', 'AST', 'TRB', and 'FG%'\n• Ensures data quality by dropping rows with missing values in key stats\n  ◦ Only rows with valid 'PTS', 'AST', 'TRB', and 'FG%' are kept\n• Returns the cleaned and filtered DataFrame with essential player statistics for the season"
      },
      "mappings": {
        "low_unstructured": [
          {
            "summaryComponent": "retrieves",
            "codeSegments": [
              {
                "code": "df_reg = pd.read_html(base_url_reg, header=0)[0]",
                "line": 5
              }
            ]
          },
          {
            "summaryComponent": "processes",
            "codeSegments": [
              {
                "code": "df_reg = df_reg[df_reg[\"Player\"] != \"Player\"]  # remove repeated header rows",
                "line": 6
              },
              {
                "code": "df_reg[\"Year\"] = year",
                "line": 7
              },
              {
                "code": "df_reg = df_reg[\n    [\"Player\", \"Year\", \"PTS\", \"AST\", \"TRB\", \"FG%\"]\n]",
                "line": 9
              },
              {
                "code": "df_reg = df_reg.dropna(\n    subset=[\"PTS\", \"AST\", \"TRB\", \"FG%\"]\n)",
                "line": 12
              }
            ]
          },
          {
            "summaryComponent": "NBA player statistics",
            "codeSegments": [
              {
                "code": "df_reg = pd.read_html(base_url_reg, header=0)[0]",
                "line": 5
              },
              {
                "code": "[\"Player\", \"Year\", \"PTS\", \"AST\", \"TRB\", \"FG%\"]",
                "line": 10
              }
            ]
          },
          {
            "summaryComponent": "for a given season",
            "codeSegments": [
              {
                "code": "def scrape_season_stats(year):",
                "line": 1
              },
              {
                "code": "f\"https://www.basketball-reference.com/leagues/NBA_{year}_per_game.html\"",
                "line": 3
              }
            ]
          },
          {
            "summaryComponent": "from Basketball Reference",
            "codeSegments": [
              {
                "code": "f\"https://www.basketball-reference.com/leagues/NBA_{year}_per_game.html\"",
                "line": 3
              }
            ]
          }
        ],
        "low_structured": [
          {
            "summaryComponent": "Fetches NBA season stats from a website",
            "codeSegments": [
              {
                "code": "base_url_reg = (\n    f\"https://www.basketball-reference.com/leagues/NBA_{year}_per_game.html\"\n)",
                "line": 2
              },
              {
                "code": "df_reg = pd.read_html(base_url_reg, header=0)[0]",
                "line": 5
              }
            ]
          },
          {
            "summaryComponent": "Cleans and filters the data",
            "codeSegments": [
              {
                "code": "df_reg = df_reg[df_reg[\"Player\"] != \"Player\"]  # remove repeated header rows",
                "line": 6
              },
              {
                "code": "df_reg[\"Year\"] = year",
                "line": 7
              },
              {
                "code": "df_reg = df_reg[\n    [\"Player\", \"Year\", \"PTS\", \"AST\", \"TRB\", \"FG%\"]\n]",
                "line": 9
              },
              {
                "code": "df_reg = df_reg.dropna(\n    subset=[\"PTS\", \"AST\", \"TRB\", \"FG%\"]\n)",
                "line": 12
              }
            ]
          },
          {
            "summaryComponent": "Returns selected player statistics",
            "codeSegments": [
              {
                "code": "return df_reg",
                "line": 15
              }
            ]
          }
        ],
        "medium_unstructured": [
          {
            "summaryComponent": "downloads per-game NBA player statistics for a specified year from Basketball Reference",
            "codeSegments": [
              {
                "code": "base_url_reg = (\n    f\"https://www.basketball-reference.com/leagues/NBA_{year}_per_game.html\"\n)",
                "line": 2
              },
              {
                "code": "df_reg = pd.read_html(base_url_reg, header=0)[0]",
                "line": 5
              }
            ]
          },
          {
            "summaryComponent": "cleans the data by removing repeated header rows",
            "codeSegments": [
              {
                "code": "df_reg = df_reg[df_reg[\"Player\"] != \"Player\"]  # remove repeated header rows",
                "line": 6
              }
            ]
          },
          {
            "summaryComponent": "adds a 'Year' column",
            "codeSegments": [
              {
                "code": "df_reg[\"Year\"] = year",
                "line": 7
              }
            ]
          },
          {
            "summaryComponent": "selects key statistical columns",
            "codeSegments": [
              {
                "code": "df_reg = df_reg[\n    [\"Player\", \"Year\", \"PTS\", \"AST\", \"TRB\", \"FG%\"]\n]",
                "line": 9
              }
            ]
          },
          {
            "summaryComponent": "drops rows with missing values in those columns",
            "codeSegments": [
              {
                "code": "df_reg = df_reg.dropna(\n    subset=[\"PTS\", \"AST\", \"TRB\", \"FG%\"]\n)",
                "line": 12
              }
            ]
          },
          {
            "summaryComponent": "The final cleaned DataFrame is then returned",
            "codeSegments": [
              {
                "code": "return df_reg",
                "line": 15
              }
            ]
          }
        ],
        "medium_structured": [
          {
            "summaryComponent": "Downloads NBA per-game stats for a given year from Basketball Reference",
            "codeSegments": [
              {
                "code": "base_url_reg = (\n    f\"https://www.basketball-reference.com/leagues/NBA_{year}_per_game.html\"\n)",
                "line": 2
              },
              {
                "code": "df_reg = pd.read_html(base_url_reg, header=0)[0]",
                "line": 5
              }
            ]
          },
          {
            "summaryComponent": "Cleans data by removing repeated header rows",
            "codeSegments": [
              {
                "code": "df_reg = df_reg[df_reg[\"Player\"] != \"Player\"]  # remove repeated header rows",
                "line": 6
              }
            ]
          },
          {
            "summaryComponent": "Adds a 'Year' column to the DataFrame",
            "codeSegments": [
              {
                "code": "df_reg[\"Year\"] = year",
                "line": 7
              }
            ]
          },
          {
            "summaryComponent": "Selects only 'Player', 'Year', 'PTS', 'AST', 'TRB', and 'FG%' columns",
            "codeSegments": [
              {
                "code": "df_reg = df_reg[\n    [\"Player\", \"Year\", \"PTS\", \"AST\", \"TRB\", \"FG%\"]\n]",
                "line": 9
              }
            ]
          },
          {
            "summaryComponent": "Drops rows with missing values in key stats",
            "codeSegments": [
              {
                "code": "df_reg = df_reg.dropna(\n    subset=[\"PTS\", \"AST\", \"TRB\", \"FG%\"]\n)",
                "line": 12
              }
            ]
          }
        ],
        "high_unstructured": [
          {
            "summaryComponent": "scrape_season_stats",
            "codeSegments": [
              {
                "code": "def scrape_season_stats(year):",
                "line": 1
              }
            ]
          },
          {
            "summaryComponent": "fetches NBA per-game player statistics for a specified year from Basketball Reference",
            "codeSegments": [
              {
                "code": "f\"https://www.basketball-reference.com/leagues/NBA_{year}_per_game.html\"",
                "line": 3
              },
              {
                "code": "df_reg = pd.read_html(base_url_reg, header=0)[0]",
                "line": 5
              }
            ]
          },
          {
            "summaryComponent": "using pandas' read_html",
            "codeSegments": [
              {
                "code": "pd.read_html(base_url_reg, header=0)[0]",
                "line": 5
              }
            ]
          },
          {
            "summaryComponent": "removes any repeated header rows that may appear within the data",
            "codeSegments": [
              {
                "code": "df_reg = df_reg[df_reg[\"Player\"] != \"Player\"]  # remove repeated header rows",
                "line": 6
              }
            ]
          },
          {
            "summaryComponent": "adds a 'Year' column to indicate the season",
            "codeSegments": [
              {
                "code": "df_reg[\"Year\"] = year",
                "line": 7
              }
            ]
          },
          {
            "summaryComponent": "filters the DataFrame to retain only the 'Player', 'Year', 'PTS', 'AST', 'TRB', and 'FG%' columns",
            "codeSegments": [
              {
                "code": "df_reg = df_reg[",
                "line": 9
              },
              {
                "code": "    [\"Player\", \"Year\", \"PTS\", \"AST\", \"TRB\", \"FG%\"]",
                "line": 10
              },
              {
                "code": "]  # Keep only specified columns",
                "line": 11
              }
            ]
          },
          {
            "summaryComponent": "it drops any rows where these key statistical fields are missing",
            "codeSegments": [
              {
                "code": "df_reg = df_reg.dropna(",
                "line": 12
              },
              {
                "code": "    subset=[\"PTS\", \"AST\", \"TRB\", \"FG%\"]",
                "line": 13
              },
              {
                "code": ")  # Ensure key stats aren't invalid",
                "line": 14
              }
            ]
          },
          {
            "summaryComponent": "returns a clean DataFrame containing essential player stats for the given NBA season",
            "codeSegments": [
              {
                "code": "return df_reg",
                "line": 15
              }
            ]
          }
        ],
        "high_structured": [
          {
            "summaryComponent": "Fetches NBA per-game player statistics for a specified year from Basketball Reference",
            "codeSegments": [
              {
                "code": "base_url_reg = (\n    f\"https://www.basketball-reference.com/leagues/NBA_{year}_per_game.html\"\n)",
                "line": 2
              },
              {
                "code": "df_reg = pd.read_html(base_url_reg, header=0)[0]",
                "line": 5
              }
            ]
          },
          {
            "summaryComponent": "Cleans the raw data",
            "codeSegments": [
              {
                "code": "df_reg = df_reg[df_reg[\"Player\"] != \"Player\"]  # remove repeated header rows",
                "line": 6
              },
              {
                "code": "df_reg[\"Year\"] = year",
                "line": 7
              }
            ]
          },
          {
            "summaryComponent": "Removes repeated header rows that may be present in the table",
            "codeSegments": [
              {
                "code": "df_reg = df_reg[df_reg[\"Player\"] != \"Player\"]  # remove repeated header rows",
                "line": 6
              }
            ]
          },
          {
            "summaryComponent": "Adds a 'Year' column to each row for context",
            "codeSegments": [
              {
                "code": "df_reg[\"Year\"] = year",
                "line": 7
              }
            ]
          },
          {
            "summaryComponent": "Filters the DataFrame to keep only relevant columns",
            "codeSegments": [
              {
                "code": "df_reg = df_reg[\n    [\"Player\", \"Year\", \"PTS\", \"AST\", \"TRB\", \"FG%\"]\n]",
                "line": 9
              }
            ]
          },
          {
            "summaryComponent": "Retains 'Player', 'Year', 'PTS', 'AST', 'TRB', and 'FG%'",
            "codeSegments": [
              {
                "code": "[\"Player\", \"Year\", \"PTS\", \"AST\", \"TRB\", \"FG%\"]",
                "line": 10
              }
            ]
          },
          {
            "summaryComponent": "Ensures data quality by dropping rows with missing values in key stats",
            "codeSegments": [
              {
                "code": "df_reg = df_reg.dropna(\n    subset=[\"PTS\", \"AST\", \"TRB\", \"FG%\"]\n)",
                "line": 12
              }
            ]
          },
          {
            "summaryComponent": "Only rows with valid 'PTS', 'AST', 'TRB', and 'FG%' are kept",
            "codeSegments": [
              {
                "code": "subset=[\"PTS\", \"AST\", \"TRB\", \"FG%\"]",
                "line": 13
              }
            ]
          },
          {
            "summaryComponent": "Returns the cleaned and filtered DataFrame with essential player statistics for the season",
            "codeSegments": [
              {
                "code": "return df_reg",
                "line": 15
              }
            ]
          }
        ]
      }
    },
    "new_code": {
      "code": "def scrape_season_stats(year):\n    base_url_reg = (\n        f\"https://www.basketball-reference.com/leagues/NBA_{year}_per_game.html\"\n    )\n    base_url_adv = (\n        f\"https://www.basketball-reference.com/leagues/NBA_{year}_advanced.html\"\n    )\n\n    df_reg = pd.read_html(base_url_reg, header=0)[0]\n    df_adv = pd.read_html(base_url_adv, header=0)[0]\n\n    df_reg = df_reg[df_reg[\"Player\"] != \"Player\"]  # remove repeated header rows\n    df_adv = df_adv[df_adv[\"Player\"] != \"Player\"]  # remove repeated header rows\n\n    df_reg[\"Year\"] = year\n    df_adv[\"Year\"] = year\n\n    df_reg = df_reg[[\"Player\", \"Year\", \"PTS\", \"AST\", \"TRB\", \"FG%\"]]\n    df_adv = df_adv[[\"Player\", \"Year\", \"BPM\", \"WS/48\", \"TS%\", \"VORP\", \"WS\", \"PER\"]]\n\n    df_reg = df_reg.dropna(subset=[\"PTS\", \"AST\", \"TRB\", \"FG%\"])\n    df_adv = df_adv.dropna(subset=[\"BPM\", \"WS/48\", \"TS%\", \"VORP\", \"WS\", \"PER\"])\n\n    df_merged = pd.merge(df_reg, df_adv, on=[\"Player\", \"Year\"])\n\n    return df_merged",
      "summary": {
        "title": "Function to Scrape, Clean, and Merge NBA Season Player Stats (Per-Game and Advanced)",
        "low_unstructured": "This function now retrieves, processes, and merges both per-game and advanced NBA player statistics for a given season from Basketball Reference.",
        "low_structured": "• Fetches NBA season stats from two websites (per-game and advanced)\n• Cleans and filters both datasets\n• Merges the cleaned per-game and advanced stats\n• Returns selected and combined player statistics",
        "medium_unstructured": "The function downloads both per-game and advanced NBA player statistics for a specified year from Basketball Reference. It cleans each dataset by removing repeated header rows, adds a 'Year' column to both, selects key statistical columns from each, and drops rows with missing values in those columns. The cleaned per-game and advanced DataFrames are then merged on 'Player' and 'Year', and the final combined DataFrame is returned.",
        "medium_structured": "• Downloads NBA per-game and advanced stats for a given year from Basketball Reference\n• Cleans both datasets by removing repeated header rows\n• Adds a 'Year' column to each DataFrame\n• Selects only relevant columns from each dataset:\n  ◦ Per-game: 'Player', 'Year', 'PTS', 'AST', 'TRB', 'FG%'\n  ◦ Advanced: 'Player', 'Year', 'BPM', 'WS/48', 'TS%', 'VORP', 'WS', 'PER'\n• Drops rows with missing values in key stats for both datasets\n• Merges the cleaned per-game and advanced DataFrames on 'Player' and 'Year'\n• Returns the combined DataFrame with essential player statistics for the season",
        "high_unstructured": "This function, scrape_season_stats, now fetches both NBA per-game and advanced player statistics for a specified year from Basketball Reference using pandas' read_html. It removes any repeated header rows that may appear within each dataset, adds a 'Year' column to both, and filters each DataFrame to retain only the relevant columns: 'Player', 'Year', 'PTS', 'AST', 'TRB', and 'FG%' for per-game stats, and 'Player', 'Year', 'BPM', 'WS/48', 'TS%', 'VORP', 'WS', and 'PER' for advanced stats. To ensure data integrity, it drops any rows where these key statistical fields are missing in either dataset. The function then merges the cleaned per-game and advanced DataFrames on 'Player' and 'Year', ultimately returning a single DataFrame containing combined essential player stats for the given NBA season.",
        "high_structured": "• Fetches both NBA per-game and advanced player statistics for a specified year from Basketball Reference\n• Cleans the raw data in both datasets\n  ◦ Removes repeated header rows that may be present in each table\n  ◦ Adds a 'Year' column to each row for context in both DataFrames\n• Filters each DataFrame to keep only relevant columns\n  ◦ Per-game: Retains 'Player', 'Year', 'PTS', 'AST', 'TRB', and 'FG%'\n  ◦ Advanced: Retains 'Player', 'Year', 'BPM', 'WS/48', 'TS%', 'VORP', 'WS', and 'PER'\n• Ensures data quality by dropping rows with missing values in key stats for both datasets\n  ◦ Only rows with valid per-game and advanced stats are kept\n• Merges the cleaned per-game and advanced DataFrames on 'Player' and 'Year'\n• Returns the cleaned, merged DataFrame with comprehensive player statistics for the season"
      },
      "mappings": {
        "low_unstructured": [
          {
            "summaryComponent": "retrieves",
            "codeSegments": [
              {
                "code": "df_reg = pd.read_html(base_url_reg, header=0)[0]",
                "line": 9
              },
              {
                "code": "df_adv = pd.read_html(base_url_adv, header=0)[0]",
                "line": 10
              }
            ]
          },
          {
            "summaryComponent": "processes",
            "codeSegments": [
              {
                "code": "df_reg = df_reg[df_reg[\"Player\"] != \"Player\"]  # remove repeated header rows",
                "line": 12
              },
              {
                "code": "df_adv = df_adv[df_adv[\"Player\"] != \"Player\"]  # remove repeated header rows",
                "line": 13
              },
              {
                "code": "df_reg[\"Year\"] = year",
                "line": 15
              },
              {
                "code": "df_adv[\"Year\"] = year",
                "line": 16
              },
              {
                "code": "df_reg = df_reg[[\"Player\", \"Year\", \"PTS\", \"AST\", \"TRB\", \"FG%\"]]",
                "line": 18
              },
              {
                "code": "df_adv = df_adv[[\"Player\", \"Year\", \"BPM\", \"WS/48\", \"TS%\", \"VORP\", \"WS\", \"PER\"]]",
                "line": 19
              },
              {
                "code": "df_reg = df_reg.dropna(subset=[\"PTS\", \"AST\", \"TRB\", \"FG%\"])",
                "line": 21
              },
              {
                "code": "df_adv = df_adv.dropna(subset=[\"BPM\", \"WS/48\", \"TS%\", \"VORP\", \"WS\", \"PER\"])",
                "line": 22
              }
            ]
          },
          {
            "summaryComponent": "merges",
            "codeSegments": [
              {
                "code": "df_merged = pd.merge(df_reg, df_adv, on=[\"Player\", \"Year\"])",
                "line": 24
              }
            ]
          },
          {
            "summaryComponent": "both per-game and advanced NBA player statistics",
            "codeSegments": [
              {
                "code": "df_reg = pd.read_html(base_url_reg, header=0)[0]",
                "line": 9
              },
              {
                "code": "df_adv = pd.read_html(base_url_adv, header=0)[0]",
                "line": 10
              }
            ]
          },
          {
            "summaryComponent": "for a given season",
            "codeSegments": [
              {
                "code": "def scrape_season_stats(year):",
                "line": 1
              },
              {
                "code": "f\"https://www.basketball-reference.com/leagues/NBA_{year}_per_game.html\"",
                "line": 3
              },
              {
                "code": "f\"https://www.basketball-reference.com/leagues/NBA_{year}_advanced.html\"",
                "line": 6
              }
            ]
          },
          {
            "summaryComponent": "from Basketball Reference",
            "codeSegments": [
              {
                "code": "f\"https://www.basketball-reference.com/leagues/NBA_{year}_per_game.html\"",
                "line": 3
              },
              {
                "code": "f\"https://www.basketball-reference.com/leagues/NBA_{year}_advanced.html\"",
                "line": 6
              }
            ]
          }
        ],
        "low_structured": [
          {
            "summaryComponent": "Fetches NBA season stats from two websites (per-game and advanced)",
            "codeSegments": [
              {
                "code": "df_reg = pd.read_html(base_url_reg, header=0)[0]",
                "line": 9
              },
              {
                "code": "df_adv = pd.read_html(base_url_adv, header=0)[0]",
                "line": 10
              }
            ]
          },
          {
            "summaryComponent": "Cleans and filters both datasets",
            "codeSegments": [
              {
                "code": "df_reg = df_reg[df_reg[\"Player\"] != \"Player\"]  # remove repeated header rows",
                "line": 12
              },
              {
                "code": "df_adv = df_adv[df_adv[\"Player\"] != \"Player\"]  # remove repeated header rows",
                "line": 13
              },
              {
                "code": "df_reg = df_reg.dropna(subset=[\"PTS\", \"AST\", \"TRB\", \"FG%\"])",
                "line": 21
              },
              {
                "code": "df_adv = df_adv.dropna(subset=[\"BPM\", \"WS/48\", \"TS%\", \"VORP\", \"WS\", \"PER\"])",
                "line": 22
              }
            ]
          },
          {
            "summaryComponent": "Merges the cleaned per-game and advanced stats",
            "codeSegments": [
              {
                "code": "df_merged = pd.merge(df_reg, df_adv, on=[\"Player\", \"Year\"])",
                "line": 24
              }
            ]
          },
          {
            "summaryComponent": "Returns selected and combined player statistics",
            "codeSegments": [
              {
                "code": "return df_merged",
                "line": 26
              }
            ]
          }
        ],
        "medium_unstructured": [
          {
            "summaryComponent": "downloads both per-game and advanced NBA player statistics for a specified year from Basketball Reference",
            "codeSegments": [
              {
                "code": "df_reg = pd.read_html(base_url_reg, header=0)[0]",
                "line": 9
              },
              {
                "code": "df_adv = pd.read_html(base_url_adv, header=0)[0]",
                "line": 10
              }
            ]
          },
          {
            "summaryComponent": "cleans each dataset by removing repeated header rows",
            "codeSegments": [
              {
                "code": "df_reg = df_reg[df_reg[\"Player\"] != \"Player\"]  # remove repeated header rows",
                "line": 12
              },
              {
                "code": "df_adv = df_adv[df_adv[\"Player\"] != \"Player\"]  # remove repeated header rows",
                "line": 13
              }
            ]
          },
          {
            "summaryComponent": "adds a 'Year' column to both",
            "codeSegments": [
              {
                "code": "df_reg[\"Year\"] = year",
                "line": 15
              },
              {
                "code": "df_adv[\"Year\"] = year",
                "line": 16
              }
            ]
          },
          {
            "summaryComponent": "selects key statistical columns from each",
            "codeSegments": [
              {
                "code": "df_reg = df_reg[[\"Player\", \"Year\", \"PTS\", \"AST\", \"TRB\", \"FG%\"]]",
                "line": 18
              },
              {
                "code": "df_adv = df_adv[[\"Player\", \"Year\", \"BPM\", \"WS/48\", \"TS%\", \"VORP\", \"WS\", \"PER\"]]",
                "line": 19
              }
            ]
          },
          {
            "summaryComponent": "drops rows with missing values in those columns",
            "codeSegments": [
              {
                "code": "df_reg = df_reg.dropna(subset=[\"PTS\", \"AST\", \"TRB\", \"FG%\"])",
                "line": 21
              },
              {
                "code": "df_adv = df_adv.dropna(subset=[\"BPM\", \"WS/48\", \"TS%\", \"VORP\", \"WS\", \"PER\"])",
                "line": 22
              }
            ]
          },
          {
            "summaryComponent": "The cleaned per-game and advanced DataFrames are then merged on 'Player' and 'Year'",
            "codeSegments": [
              {
                "code": "df_merged = pd.merge(df_reg, df_adv, on=[\"Player\", \"Year\"])",
                "line": 24
              }
            ]
          },
          {
            "summaryComponent": "the final combined DataFrame is returned",
            "codeSegments": [
              {
                "code": "return df_merged",
                "line": 26
              }
            ]
          }
        ],
        "medium_structured": [
          {
            "summaryComponent": "Downloads NBA per-game and advanced stats for a given year from Basketball Reference",
            "codeSegments": [
              {
                "code": "base_url_reg = (\n    f\"https://www.basketball-reference.com/leagues/NBA_{year}_per_game.html\"\n)",
                "line": 2
              },
              {
                "code": "base_url_adv = (\n    f\"https://www.basketball-reference.com/leagues/NBA_{year}_advanced.html\"\n)",
                "line": 5
              },
              {
                "code": "df_reg = pd.read_html(base_url_reg, header=0)[0]",
                "line": 9
              },
              {
                "code": "df_adv = pd.read_html(base_url_adv, header=0)[0]",
                "line": 10
              }
            ]
          },
          {
            "summaryComponent": "Cleans both datasets by removing repeated header rows",
            "codeSegments": [
              {
                "code": "df_reg = df_reg[df_reg[\"Player\"] != \"Player\"]  # remove repeated header rows",
                "line": 12
              },
              {
                "code": "df_adv = df_adv[df_adv[\"Player\"] != \"Player\"]  # remove repeated header rows",
                "line": 13
              }
            ]
          },
          {
            "summaryComponent": "Adds a 'Year' column to each DataFrame",
            "codeSegments": [
              {
                "code": "df_reg[\"Year\"] = year",
                "line": 15
              },
              {
                "code": "df_adv[\"Year\"] = year",
                "line": 16
              }
            ]
          },
          {
            "summaryComponent": "Selects only relevant columns from each dataset:",
            "codeSegments": [
              {
                "code": "df_reg = df_reg[[\"Player\", \"Year\", \"PTS\", \"AST\", \"TRB\", \"FG%\"]]",
                "line": 18
              },
              {
                "code": "df_adv = df_adv[[\"Player\", \"Year\", \"BPM\", \"WS/48\", \"TS%\", \"VORP\", \"WS\", \"PER\"]]",
                "line": 19
              }
            ]
          },
          {
            "summaryComponent": "Per-game: 'Player', 'Year', 'PTS', 'AST', 'TRB', 'FG%'",
            "codeSegments": [
              {
                "code": "df_reg = df_reg[[\"Player\", \"Year\", \"PTS\", \"AST\", \"TRB\", \"FG%\"]]",
                "line": 18
              }
            ]
          },
          {
            "summaryComponent": "Advanced: 'Player', 'Year', 'BPM', 'WS/48', 'TS%', 'VORP', 'WS', 'PER'",
            "codeSegments": [
              {
                "code": "df_adv = df_adv[[\"Player\", \"Year\", \"BPM\", \"WS/48\", \"TS%\", \"VORP\", \"WS\", \"PER\"]]",
                "line": 19
              }
            ]
          },
          {
            "summaryComponent": "Drops rows with missing values in key stats for both datasets",
            "codeSegments": [
              {
                "code": "df_reg = df_reg.dropna(subset=[\"PTS\", \"AST\", \"TRB\", \"FG%\"])",
                "line": 21
              },
              {
                "code": "df_adv = df_adv.dropna(subset=[\"BPM\", \"WS/48\", \"TS%\", \"VORP\", \"WS\", \"PER\"])",
                "line": 22
              }
            ]
          },
          {
            "summaryComponent": "Merges the cleaned per-game and advanced DataFrames on 'Player' and 'Year'",
            "codeSegments": [
              {
                "code": "df_merged = pd.merge(df_reg, df_adv, on=[\"Player\", \"Year\"])",
                "line": 24
              }
            ]
          },
          {
            "summaryComponent": "Returns the combined DataFrame with essential player statistics for the season",
            "codeSegments": [
              {
                "code": "return df_merged",
                "line": 26
              }
            ]
          }
        ],
        "high_unstructured": [
          {
            "summaryComponent": "scrape_season_stats",
            "codeSegments": [
              {
                "code": "def scrape_season_stats(year):",
                "line": 1
              }
            ]
          },
          {
            "summaryComponent": "fetches both NBA per-game and advanced player statistics for a specified year from Basketball Reference using pandas' read_html",
            "codeSegments": [
              {
                "code": "base_url_reg = (\n    f\"https://www.basketball-reference.com/leagues/NBA_{year}_per_game.html\"\n)",
                "line": 2
              },
              {
                "code": "base_url_adv = (\n    f\"https://www.basketball-reference.com/leagues/NBA_{year}_advanced.html\"\n)",
                "line": 5
              },
              {
                "code": "df_reg = pd.read_html(base_url_reg, header=0)[0]",
                "line": 9
              },
              {
                "code": "df_adv = pd.read_html(base_url_adv, header=0)[0]",
                "line": 10
              }
            ]
          },
          {
            "summaryComponent": "removes any repeated header rows that may appear within each dataset",
            "codeSegments": [
              {
                "code": "df_reg = df_reg[df_reg[\"Player\"] != \"Player\"]  # remove repeated header rows",
                "line": 12
              },
              {
                "code": "df_adv = df_adv[df_adv[\"Player\"] != \"Player\"]  # remove repeated header rows",
                "line": 13
              }
            ]
          },
          {
            "summaryComponent": "adds a 'Year' column to both",
            "codeSegments": [
              {
                "code": "df_reg[\"Year\"] = year",
                "line": 15
              },
              {
                "code": "df_adv[\"Year\"] = year",
                "line": 16
              }
            ]
          },
          {
            "summaryComponent": "filters each DataFrame to retain only the relevant columns: 'Player', 'Year', 'PTS', 'AST', 'TRB', and 'FG%' for per-game stats, and 'Player', 'Year', 'BPM', 'WS/48', 'TS%', 'VORP', 'WS', and 'PER' for advanced stats",
            "codeSegments": [
              {
                "code": "df_reg = df_reg[[\"Player\", \"Year\", \"PTS\", \"AST\", \"TRB\", \"FG%\"]]",
                "line": 18
              },
              {
                "code": "df_adv = df_adv[[\"Player\", \"Year\", \"BPM\", \"WS/48\", \"TS%\", \"VORP\", \"WS\", \"PER\"]]",
                "line": 19
              }
            ]
          },
          {
            "summaryComponent": "drops any rows where these key statistical fields are missing in either dataset",
            "codeSegments": [
              {
                "code": "df_reg = df_reg.dropna(subset=[\"PTS\", \"AST\", \"TRB\", \"FG%\"])",
                "line": 21
              },
              {
                "code": "df_adv = df_adv.dropna(subset=[\"BPM\", \"WS/48\", \"TS%\", \"VORP\", \"WS\", \"PER\"])",
                "line": 22
              }
            ]
          },
          {
            "summaryComponent": "merges the cleaned per-game and advanced DataFrames on 'Player' and 'Year'",
            "codeSegments": [
              {
                "code": "df_merged = pd.merge(df_reg, df_adv, on=[\"Player\", \"Year\"])",
                "line": 24
              }
            ]
          },
          {
            "summaryComponent": "returning a single DataFrame containing combined essential player stats for the given NBA season",
            "codeSegments": [
              {
                "code": "return df_merged",
                "line": 26
              }
            ]
          }
        ],
        "high_structured": [
          {
            "summaryComponent": "Fetches both NBA per-game and advanced player statistics for a specified year from Basketball Reference",
            "codeSegments": [
              {
                "code": "base_url_reg = (\n    f\"https://www.basketball-reference.com/leagues/NBA_{year}_per_game.html\"\n)",
                "line": 2
              },
              {
                "code": "base_url_adv = (\n    f\"https://www.basketball-reference.com/leagues/NBA_{year}_advanced.html\"\n)",
                "line": 5
              },
              {
                "code": "df_reg = pd.read_html(base_url_reg, header=0)[0]",
                "line": 9
              },
              {
                "code": "df_adv = pd.read_html(base_url_adv, header=0)[0]",
                "line": 10
              }
            ]
          },
          {
            "summaryComponent": "Cleans the raw data in both datasets",
            "codeSegments": [
              {
                "code": "df_reg = df_reg[df_reg[\"Player\"] != \"Player\"]  # remove repeated header rows",
                "line": 12
              },
              {
                "code": "df_adv = df_adv[df_adv[\"Player\"] != \"Player\"]  # remove repeated header rows",
                "line": 13
              },
              {
                "code": "df_reg[\"Year\"] = year",
                "line": 15
              },
              {
                "code": "df_adv[\"Year\"] = year",
                "line": 16
              }
            ]
          },
          {
            "summaryComponent": "Removes repeated header rows that may be present in each table",
            "codeSegments": [
              {
                "code": "df_reg = df_reg[df_reg[\"Player\"] != \"Player\"]  # remove repeated header rows",
                "line": 12
              },
              {
                "code": "df_adv = df_adv[df_adv[\"Player\"] != \"Player\"]  # remove repeated header rows",
                "line": 13
              }
            ]
          },
          {
            "summaryComponent": "Adds a 'Year' column to each row for context in both DataFrames",
            "codeSegments": [
              {
                "code": "df_reg[\"Year\"] = year",
                "line": 15
              },
              {
                "code": "df_adv[\"Year\"] = year",
                "line": 16
              }
            ]
          },
          {
            "summaryComponent": "Filters each DataFrame to keep only relevant columns",
            "codeSegments": [
              {
                "code": "df_reg = df_reg[[\"Player\", \"Year\", \"PTS\", \"AST\", \"TRB\", \"FG%\"]]",
                "line": 18
              },
              {
                "code": "df_adv = df_adv[[\"Player\", \"Year\", \"BPM\", \"WS/48\", \"TS%\", \"VORP\", \"WS\", \"PER\"]]",
                "line": 19
              }
            ]
          },
          {
            "summaryComponent": "Per-game: Retains 'Player', 'Year', 'PTS', 'AST', 'TRB', and 'FG%'",
            "codeSegments": [
              {
                "code": "df_reg = df_reg[[\"Player\", \"Year\", \"PTS\", \"AST\", \"TRB\", \"FG%\"]]",
                "line": 18
              }
            ]
          },
          {
            "summaryComponent": "Advanced: Retains 'Player', 'Year', 'BPM', 'WS/48', 'TS%', 'VORP', 'WS', and 'PER'",
            "codeSegments": [
              {
                "code": "df_adv = df_adv[[\"Player\", \"Year\", \"BPM\", \"WS/48\", \"TS%\", \"VORP\", \"WS\", \"PER\"]]",
                "line": 19
              }
            ]
          },
          {
            "summaryComponent": "Ensures data quality by dropping rows with missing values in key stats for both datasets",
            "codeSegments": [
              {
                "code": "df_reg = df_reg.dropna(subset=[\"PTS\", \"AST\", \"TRB\", \"FG%\"])",
                "line": 21
              },
              {
                "code": "df_adv = df_adv.dropna(subset=[\"BPM\", \"WS/48\", \"TS%\", \"VORP\", \"WS\", \"PER\"])",
                "line": 22
              }
            ]
          },
          {
            "summaryComponent": "Only rows with valid per-game and advanced stats are kept",
            "codeSegments": [
              {
                "code": "df_reg = df_reg.dropna(subset=[\"PTS\", \"AST\", \"TRB\", \"FG%\"])",
                "line": 21
              },
              {
                "code": "df_adv = df_adv.dropna(subset=[\"BPM\", \"WS/48\", \"TS%\", \"VORP\", \"WS\", \"PER\"])",
                "line": 22
              }
            ]
          },
          {
            "summaryComponent": "Merges the cleaned per-game and advanced DataFrames on 'Player' and 'Year'",
            "codeSegments": [
              {
                "code": "df_merged = pd.merge(df_reg, df_adv, on=[\"Player\", \"Year\"])",
                "line": 24
              }
            ]
          },
          {
            "summaryComponent": "Returns the cleaned, merged DataFrame with comprehensive player statistics for the season",
            "codeSegments": [
              {
                "code": "return df_merged",
                "line": 26
              }
            ]
          }
        ]
      }
    }
  },
  {
    "task_id": "MP-B",
    "metadata": {
      "file_context": "MVPPredictor/rank_model.py",
      "processing_timestamp": 82295.619972114
    },
    "old_code": {
      "code": "# Model\n    model = XGBRanker(\n        objective=\"rank:pairwise\",\n        learning_rate=0.1,\n        n_estimators=100,\n        max_depth=4,\n        random_state=42,\n    )\n\n    print(\"Training XGBoostRanker...\")\n    model.fit(X_train, y_train, group=train_groups)\n\n    # Predict, sort, and evaluate\n    y_pred = model.predict(X_test)\n    df.loc[test_idx, \"PredictedScore\"] = y_pred\n    df.loc[test_idx, \"PredictedRank\"] = (\n        df.loc[test_idx]\n        .groupby(\"Year\")[\"PredictedScore\"]\n        .rank(ascending=False, method=\"first\")\n    )\n\n    ndcg = evaluate_ndcg(y_test.to_numpy(), y_pred, test_groups)\n    print(f\"NDCG Score on test years {test_years.tolist()}: {ndcg:.4f}\")\n\n    # Show results\n    print(df[test_idx][[\"Year\", \"Name\", \"Rank\", \"PredictedScore\", \"PredictedRank\"]])\n    plot_ranking_predictions(df, 2024)\n    plot_ranking_predictions(df, 2025)",
      "summary": {
        "title": "XGBoost Ranker Training, Prediction, and Evaluation Workflow",
        "low_unstructured": "This code trains an XGBoost ranker, predicts rankings, evaluates them using NDCG, and visualizes the results.",
        "low_structured": "• Trains an XGBoost ranking model\n• Predicts and evaluates rankings\n• Visualizes prediction results",
        "medium_unstructured": "The code initializes and trains an XGBoost ranker model on training data grouped for ranking tasks. It then predicts scores on test data, assigns predicted ranks, evaluates performance using the NDCG metric, and prints results. Finally, it visualizes the ranking predictions for the years 2024 and 2025.",
        "medium_structured": "• Initializes and trains an XGBoost ranker with specified hyperparameters\n• Predicts scores for the test set and assigns predicted ranks by year\n• Evaluates model performance using the NDCG metric\n• Displays prediction results and visualizes rankings for selected years",
        "high_unstructured": "This code snippet sets up and trains an XGBRanker model with specific hyperparameters such as pairwise ranking objective, learning rate, and tree depth, using grouped training data. After training, it predicts scores for the test set, updates the DataFrame with predicted scores and ranks (grouped by year), and evaluates the model's ranking quality using the NDCG metric. The code then prints out the test set results, including actual and predicted ranks, and visualizes the ranking predictions for the years 2024 and 2025. This workflow enables both quantitative and qualitative assessment of the model's ranking performance.",
        "high_structured": "• Initializes an XGBRanker with:\n  ◦ Pairwise ranking objective\n  ◦ Learning rate of 0.1\n  ◦ 100 estimators and max depth of 4\n  ◦ Fixed random seed for reproducibility\n• Trains the model on grouped training data\n• Predicts ranking scores for the test set\n• Updates the DataFrame with:\n  ◦ Predicted scores\n  ◦ Predicted ranks, calculated per year using groupby and rank\n• Evaluates ranking performance using the NDCG metric\n• Prints test set results, showing year, name, true rank, predicted score, and predicted rank\n• Visualizes ranking predictions for the years 2024 and 2025 using plotting functions"
      },
      "mappings": {
        "low_unstructured": [
          {
            "summaryComponent": "trains an XGBoost ranker",
            "codeSegments": [
              {
                "code": "model = XGBRanker(",
                "line": 2
              },
              {
                "code": "model.fit(X_train, y_train, group=train_groups)",
                "line": 11
              }
            ]
          },
          {
            "summaryComponent": "predicts rankings",
            "codeSegments": [
              {
                "code": "y_pred = model.predict(X_test)",
                "line": 14
              },
              {
                "code": "df.loc[test_idx, \"PredictedScore\"] = y_pred",
                "line": 15
              },
              {
                "code": "df.loc[test_idx, \"PredictedRank\"] = (",
                "line": 16
              },
              {
                "code": "df.loc[test_idx]\n    .groupby(\"Year\")[\"PredictedScore\"]\n    .rank(ascending=False, method=\"first\")",
                "line": 17
              }
            ]
          },
          {
            "summaryComponent": "evaluates them using NDCG",
            "codeSegments": [
              {
                "code": "ndcg = evaluate_ndcg(y_test.to_numpy(), y_pred, test_groups)",
                "line": 22
              },
              {
                "code": "print(f\"NDCG Score on test years {test_years.tolist()}: {ndcg:.4f}\")",
                "line": 23
              }
            ]
          },
          {
            "summaryComponent": "visualizes the results",
            "codeSegments": [
              {
                "code": "print(df[test_idx][[\"Year\", \"Name\", \"Rank\", \"PredictedScore\", \"PredictedRank\"]])",
                "line": 26
              },
              {
                "code": "plot_ranking_predictions(df, 2024)",
                "line": 27
              },
              {
                "code": "plot_ranking_predictions(df, 2025)",
                "line": 28
              }
            ]
          }
        ],
        "low_structured": [
          {
            "summaryComponent": "Trains an XGBoost ranking model",
            "codeSegments": [
              {
                "code": "model = XGBRanker(",
                "line": 2
              },
              {
                "code": "model.fit(X_train, y_train, group=train_groups)",
                "line": 11
              }
            ]
          },
          {
            "summaryComponent": "Predicts and evaluates rankings",
            "codeSegments": [
              {
                "code": "y_pred = model.predict(X_test)",
                "line": 14
              },
              {
                "code": "df.loc[test_idx, \"PredictedScore\"] = y_pred",
                "line": 15
              },
              {
                "code": "df.loc[test_idx, \"PredictedRank\"] = (",
                "line": 16
              },
              {
                "code": "ndcg = evaluate_ndcg(y_test.to_numpy(), y_pred, test_groups)",
                "line": 22
              }
            ]
          },
          {
            "summaryComponent": "Visualizes prediction results",
            "codeSegments": [
              {
                "code": "plot_ranking_predictions(df, 2024)",
                "line": 27
              },
              {
                "code": "plot_ranking_predictions(df, 2025)",
                "line": 28
              }
            ]
          }
        ],
        "medium_unstructured": [
          {
            "summaryComponent": "initializes and trains an XGBoost ranker model",
            "codeSegments": [
              {
                "code": "model = XGBRanker(",
                "line": 2
              },
              {
                "code": "model.fit(X_train, y_train, group=train_groups)",
                "line": 11
              }
            ]
          },
          {
            "summaryComponent": "on training data grouped for ranking tasks",
            "codeSegments": [
              {
                "code": "model.fit(X_train, y_train, group=train_groups)",
                "line": 11
              }
            ]
          },
          {
            "summaryComponent": "predicts scores on test data",
            "codeSegments": [
              {
                "code": "y_pred = model.predict(X_test)",
                "line": 14
              }
            ]
          },
          {
            "summaryComponent": "assigns predicted ranks",
            "codeSegments": [
              {
                "code": "df.loc[test_idx, \"PredictedRank\"] = (",
                "line": 16
              },
              {
                "code": "    .groupby(\"Year\")[\"PredictedScore\"]",
                "line": 18
              },
              {
                "code": "    .rank(ascending=False, method=\"first\")",
                "line": 19
              }
            ]
          },
          {
            "summaryComponent": "evaluates performance using the NDCG metric",
            "codeSegments": [
              {
                "code": "ndcg = evaluate_ndcg(y_test.to_numpy(), y_pred, test_groups)",
                "line": 22
              }
            ]
          },
          {
            "summaryComponent": "prints results",
            "codeSegments": [
              {
                "code": "print(df[test_idx][[\"Year\", \"Name\", \"Rank\", \"PredictedScore\", \"PredictedRank\"]])",
                "line": 26
              }
            ]
          },
          {
            "summaryComponent": "visualizes the ranking predictions for the years 2024 and 2025",
            "codeSegments": [
              {
                "code": "plot_ranking_predictions(df, 2024)",
                "line": 27
              },
              {
                "code": "plot_ranking_predictions(df, 2025)",
                "line": 28
              }
            ]
          }
        ],
        "medium_structured": [
          {
            "summaryComponent": "Initializes and trains an XGBoost ranker with specified hyperparameters",
            "codeSegments": [
              {
                "code": "model = XGBRanker(",
                "line": 2
              },
              {
                "code": "objective=\"rank:pairwise\",",
                "line": 3
              },
              {
                "code": "learning_rate=0.1,",
                "line": 4
              },
              {
                "code": "n_estimators=100,",
                "line": 5
              },
              {
                "code": "max_depth=4,",
                "line": 6
              },
              {
                "code": "random_state=42,",
                "line": 7
              },
              {
                "code": "model.fit(X_train, y_train, group=train_groups)",
                "line": 11
              }
            ]
          },
          {
            "summaryComponent": "Predicts scores for the test set and assigns predicted ranks by year",
            "codeSegments": [
              {
                "code": "y_pred = model.predict(X_test)",
                "line": 14
              },
              {
                "code": "df.loc[test_idx, \"PredictedScore\"] = y_pred",
                "line": 15
              },
              {
                "code": "df.loc[test_idx, \"PredictedRank\"] = (",
                "line": 16
              },
              {
                "code": "df.loc[test_idx]",
                "line": 17
              },
              {
                "code": ".groupby(\"Year\")[\"PredictedScore\"]",
                "line": 18
              },
              {
                "code": ".rank(ascending=False, method=\"first\")",
                "line": 19
              }
            ]
          },
          {
            "summaryComponent": "Evaluates model performance using the NDCG metric",
            "codeSegments": [
              {
                "code": "ndcg = evaluate_ndcg(y_test.to_numpy(), y_pred, test_groups)",
                "line": 22
              },
              {
                "code": "print(f\"NDCG Score on test years {test_years.tolist()}: {ndcg:.4f}\")",
                "line": 23
              }
            ]
          },
          {
            "summaryComponent": "Displays prediction results and visualizes rankings for selected years",
            "codeSegments": [
              {
                "code": "print(df[test_idx][[\"Year\", \"Name\", \"Rank\", \"PredictedScore\", \"PredictedRank\"]])",
                "line": 26
              },
              {
                "code": "plot_ranking_predictions(df, 2024)",
                "line": 27
              },
              {
                "code": "plot_ranking_predictions(df, 2025)",
                "line": 28
              }
            ]
          }
        ],
        "high_unstructured": [
          {
            "summaryComponent": "sets up and trains an XGBRanker model",
            "codeSegments": [
              {
                "code": "model = XGBRanker(",
                "line": 2
              },
              {
                "code": "model.fit(X_train, y_train, group=train_groups)",
                "line": 11
              }
            ]
          },
          {
            "summaryComponent": "with specific hyperparameters such as pairwise ranking objective, learning rate, and tree depth",
            "codeSegments": [
              {
                "code": "objective=\"rank:pairwise\",",
                "line": 3
              },
              {
                "code": "learning_rate=0.1,",
                "line": 4
              },
              {
                "code": "max_depth=4,",
                "line": 6
              }
            ]
          },
          {
            "summaryComponent": "using grouped training data",
            "codeSegments": [
              {
                "code": "model.fit(X_train, y_train, group=train_groups)",
                "line": 11
              }
            ]
          },
          {
            "summaryComponent": "predicts scores for the test set",
            "codeSegments": [
              {
                "code": "y_pred = model.predict(X_test)",
                "line": 14
              }
            ]
          },
          {
            "summaryComponent": "updates the DataFrame with predicted scores and ranks (grouped by year)",
            "codeSegments": [
              {
                "code": "df.loc[test_idx, \"PredictedScore\"] = y_pred",
                "line": 15
              },
              {
                "code": "df.loc[test_idx, \"PredictedRank\"] = (",
                "line": 16
              },
              {
                "code": "df.loc[test_idx]\n    .groupby(\"Year\")[\"PredictedScore\"]\n    .rank(ascending=False, method=\"first\")",
                "line": 17
              }
            ]
          },
          {
            "summaryComponent": "evaluates the model's ranking quality using the NDCG metric",
            "codeSegments": [
              {
                "code": "ndcg = evaluate_ndcg(y_test.to_numpy(), y_pred, test_groups)",
                "line": 22
              }
            ]
          },
          {
            "summaryComponent": "prints out the test set results, including actual and predicted ranks",
            "codeSegments": [
              {
                "code": "print(df[test_idx][[\"Year\", \"Name\", \"Rank\", \"PredictedScore\", \"PredictedRank\"]])",
                "line": 26
              }
            ]
          },
          {
            "summaryComponent": "visualizes the ranking predictions for the years 2024 and 2025",
            "codeSegments": [
              {
                "code": "plot_ranking_predictions(df, 2024)",
                "line": 27
              },
              {
                "code": "plot_ranking_predictions(df, 2025)",
                "line": 28
              }
            ]
          },
          {
            "summaryComponent": "enables both quantitative and qualitative assessment of the model's ranking performance",
            "codeSegments": [
              {
                "code": "ndcg = evaluate_ndcg(y_test.to_numpy(), y_pred, test_groups)",
                "line": 22
              },
              {
                "code": "plot_ranking_predictions(df, 2024)",
                "line": 27
              },
              {
                "code": "plot_ranking_predictions(df, 2025)",
                "line": 28
              }
            ]
          }
        ],
        "high_structured": [
          {
            "summaryComponent": "Initializes an XGBRanker with:",
            "codeSegments": [
              {
                "code": "model = XGBRanker(",
                "line": 2
              }
            ]
          },
          {
            "summaryComponent": "Pairwise ranking objective",
            "codeSegments": [
              {
                "code": "objective=\"rank:pairwise\",",
                "line": 3
              }
            ]
          },
          {
            "summaryComponent": "Learning rate of 0.1",
            "codeSegments": [
              {
                "code": "learning_rate=0.1,",
                "line": 4
              }
            ]
          },
          {
            "summaryComponent": "100 estimators and max depth of 4",
            "codeSegments": [
              {
                "code": "n_estimators=100,",
                "line": 5
              },
              {
                "code": "max_depth=4,",
                "line": 6
              }
            ]
          },
          {
            "summaryComponent": "Fixed random seed for reproducibility",
            "codeSegments": [
              {
                "code": "random_state=42,",
                "line": 7
              }
            ]
          },
          {
            "summaryComponent": "Trains the model on grouped training data",
            "codeSegments": [
              {
                "code": "model.fit(X_train, y_train, group=train_groups)",
                "line": 11
              }
            ]
          },
          {
            "summaryComponent": "Predicts ranking scores for the test set",
            "codeSegments": [
              {
                "code": "y_pred = model.predict(X_test)",
                "line": 14
              }
            ]
          },
          {
            "summaryComponent": "Updates the DataFrame with:",
            "codeSegments": [
              {
                "code": "df.loc[test_idx, \"PredictedScore\"] = y_pred",
                "line": 15
              }
            ]
          },
          {
            "summaryComponent": "Predicted scores",
            "codeSegments": [
              {
                "code": "df.loc[test_idx, \"PredictedScore\"] = y_pred",
                "line": 15
              }
            ]
          },
          {
            "summaryComponent": "Predicted ranks, calculated per year using groupby and rank",
            "codeSegments": [
              {
                "code": "df.loc[test_idx, \"PredictedRank\"] = (",
                "line": 16
              },
              {
                "code": "df.loc[test_idx]\n    .groupby(\"Year\")[\"PredictedScore\"]\n    .rank(ascending=False, method=\"first\")",
                "line": 17
              }
            ]
          },
          {
            "summaryComponent": "Evaluates ranking performance using the NDCG metric",
            "codeSegments": [
              {
                "code": "ndcg = evaluate_ndcg(y_test.to_numpy(), y_pred, test_groups)",
                "line": 22
              }
            ]
          },
          {
            "summaryComponent": "Prints test set results, showing year, name, true rank, predicted score, and predicted rank",
            "codeSegments": [
              {
                "code": "print(df[test_idx][[\"Year\", \"Name\", \"Rank\", \"PredictedScore\", \"PredictedRank\"]])",
                "line": 26
              }
            ]
          },
          {
            "summaryComponent": "Visualizes ranking predictions for the years 2024 and 2025 using plotting functions",
            "codeSegments": [
              {
                "code": "plot_ranking_predictions(df, 2024)",
                "line": 27
              },
              {
                "code": "plot_ranking_predictions(df, 2025)",
                "line": 28
              }
            ]
          }
        ]
      }
    },
    "new_code": {
      "code": "# Model\n    best_ndcg = -1\n    best_n_estimators = 100\n    for n_estimators in [100, 1000, 2000]:\n        model = XGBRanker(\n            objective=\"rank:pairwise\",\n            learning_rate=0.1,\n            n_estimators=n_estimators,\n            max_depth=4,\n            random_state=42,\n        )\n\n        print(f\"Training XGBoostRanker with {n_estimators} estimators...\")\n        model.fit(X_train, y_train, group=train_groups)\n\n        # Predict and evaluate\n        y_pred = model.predict(X_test)\n        ndcg = evaluate_ndcg(y_test.to_numpy(), y_pred, test_groups)\n        print(f\"NDCG Score with {n_estimators} estimators: {ndcg:.4f}\")\n\n        if ndcg > best_ndcg:\n            best_ndcg = ndcg\n            best_n_estimators = n_estimators\n\n    # Retrain with best n_estimators\n    model = XGBRanker(\n        objective=\"rank:pairwise\",\n        learning_rate=0.1,\n        n_estimators=best_n_estimators,\n        max_depth=4,\n        random_state=42,\n    )\n\n    print(f\"Retraining XGBoostRanker with best n_estimators: {best_n_estimators}\")\n    model.fit(X_train, y_train, group=train_groups)\n\n    # Predict, sort, and evaluate\n    y_pred = model.predict(X_test)\n    df.loc[test_idx, \"PredictedScore\"] = y_pred\n    df.loc[test_idx, \"PredictedRank\"] = (\n        df.loc[test_idx]\n        .groupby(\"Year\")[\"PredictedScore\"]\n        .rank(ascending=False, method=\"first\")\n    )\n\n    ndcg = evaluate_ndcg(y_test.to_numpy(), y_pred, test_groups)\n    print(f\"NDCG Score on test years {test_years.tolist()}: {ndcg:.4f}\")\n\n    # Show results\n    print(df[test_idx][[\"Year\", \"Name\", \"Rank\", \"PredictedScore\", \"PredictedRank\"]])\n    plot_ranking_predictions(df, 2024)\n    plot_ranking_predictions(df, 2025)",
      "summary": {
        "title": "XGBoost Ranker Training with n_estimators Selection, Prediction, and Evaluation Workflow",
        "low_unstructured": "This code now includes a loop to select the best number of estimators for the XGBoost ranker based on NDCG, retrains the model with this optimal value, predicts rankings, evaluates them using NDCG, and visualizes the results.",
        "low_structured": "• Selects the best number of estimators for the XGBoost ranking model using NDCG\n• Retrains the model with the optimal n_estimators\n• Predicts and evaluates rankings\n• Visualizes prediction results",
        "medium_unstructured": "The code now iterates over multiple values for n_estimators, training and evaluating an XGBoost ranker model on each, and selects the value that yields the best NDCG score. It then retrains the model with this optimal n_estimators, predicts scores on test data, assigns predicted ranks, evaluates performance using the NDCG metric, and prints results. Finally, it visualizes the ranking predictions for the years 2024 and 2025.",
        "medium_structured": "• Iterates over several n_estimators values, training and evaluating an XGBoost ranker for each\n• Selects the n_estimators value with the highest NDCG score\n• Retrains the XGBoost ranker with the optimal n_estimators\n• Predicts scores for the test set and assigns predicted ranks by year\n• Evaluates model performance using the NDCG metric\n• Displays prediction results and visualizes rankings for selected years",
        "high_unstructured": "This code snippet now includes a model selection step: it loops through several n_estimators values (100, 1000, 2000), training and evaluating an XGBRanker on each using the NDCG metric, and selects the n_estimators value that yields the highest NDCG. The model is then retrained with this optimal n_estimators. After retraining, it predicts scores for the test set, updates the DataFrame with predicted scores and ranks (grouped by year), and evaluates the model's ranking quality using the NDCG metric. The code then prints out the test set results, including actual and predicted ranks, and visualizes the ranking predictions for the years 2024 and 2025. This workflow now enables both hyperparameter tuning for n_estimators and quantitative and qualitative assessment of the model's ranking performance.",
        "high_structured": "• Iterates through multiple n_estimators values (100, 1000, 2000), training and evaluating an XGBRanker for each\n  ◦ Uses the NDCG metric to assess performance for each n_estimators value\n  ◦ Selects the n_estimators value with the highest NDCG\n• Retrains an XGBRanker with:\n  ◦ Pairwise ranking objective\n  ◦ Learning rate of 0.1\n  ◦ Optimal n_estimators found in the previous step\n  ◦ Max depth of 4\n  ◦ Fixed random seed for reproducibility\n• Trains the model on grouped training data\n• Predicts ranking scores for the test set\n• Updates the DataFrame with:\n  ◦ Predicted scores\n  ◦ Predicted ranks, calculated per year using groupby and rank\n• Evaluates ranking performance using the NDCG metric\n• Prints test set results, showing year, name, true rank, predicted score, and predicted rank\n• Visualizes ranking predictions for the years 2024 and 2025 using plotting functions"
      },
      "mappings": {
        "low_unstructured": [
          {
            "summaryComponent": "includes a loop to select the best number of estimators",
            "codeSegments": [
              {
                "code": "for n_estimators in [100, 1000, 2000]:",
                "line": 4
              },
              {
                "code": "if ndcg > best_ndcg:",
                "line": 21
              },
              {
                "code": "best_ndcg = ndcg",
                "line": 22
              },
              {
                "code": "best_n_estimators = n_estimators",
                "line": 23
              }
            ]
          },
          {
            "summaryComponent": "for the XGBoost ranker",
            "codeSegments": [
              {
                "code": "model = XGBRanker(",
                "line": 5
              },
              {
                "code": "model = XGBRanker(",
                "line": 26
              }
            ]
          },
          {
            "summaryComponent": "based on NDCG",
            "codeSegments": [
              {
                "code": "ndcg = evaluate_ndcg(y_test.to_numpy(), y_pred, test_groups)",
                "line": 18
              },
              {
                "code": "if ndcg > best_ndcg:",
                "line": 21
              }
            ]
          },
          {
            "summaryComponent": "retrains the model with this optimal value",
            "codeSegments": [
              {
                "code": "# Retrain with best n_estimators",
                "line": 25
              },
              {
                "code": "model = XGBRanker(",
                "line": 26
              },
              {
                "code": "n_estimators=best_n_estimators,",
                "line": 29
              },
              {
                "code": "model.fit(X_train, y_train, group=train_groups)",
                "line": 35
              }
            ]
          },
          {
            "summaryComponent": "predicts rankings",
            "codeSegments": [
              {
                "code": "y_pred = model.predict(X_test)",
                "line": 38
              },
              {
                "code": "df.loc[test_idx, \"PredictedScore\"] = y_pred",
                "line": 39
              },
              {
                "code": "df.loc[test_idx, \"PredictedRank\"] = (",
                "line": 40
              }
            ]
          },
          {
            "summaryComponent": "evaluates them using NDCG",
            "codeSegments": [
              {
                "code": "ndcg = evaluate_ndcg(y_test.to_numpy(), y_pred, test_groups)",
                "line": 46
              },
              {
                "code": "print(f\"NDCG Score on test years {test_years.tolist()}: {ndcg:.4f}\")",
                "line": 47
              }
            ]
          },
          {
            "summaryComponent": "visualizes the results",
            "codeSegments": [
              {
                "code": "print(df[test_idx][[\"Year\", \"Name\", \"Rank\", \"PredictedScore\", \"PredictedRank\"]])",
                "line": 50
              },
              {
                "code": "plot_ranking_predictions(df, 2024)",
                "line": 51
              },
              {
                "code": "plot_ranking_predictions(df, 2025)",
                "line": 52
              }
            ]
          }
        ],
        "low_structured": [
          {
            "summaryComponent": "Selects the best number of estimators for the XGBoost ranking model using NDCG",
            "codeSegments": [
              {
                "code": "for n_estimators in [100, 1000, 2000]:",
                "line": 4
              },
              {
                "code": "model = XGBRanker(",
                "line": 5
              },
              {
                "code": "ndcg = evaluate_ndcg(y_test.to_numpy(), y_pred, test_groups)",
                "line": 18
              },
              {
                "code": "if ndcg > best_ndcg:",
                "line": 21
              },
              {
                "code": "best_ndcg = ndcg",
                "line": 22
              },
              {
                "code": "best_n_estimators = n_estimators",
                "line": 23
              }
            ]
          },
          {
            "summaryComponent": "Retrains the model with the optimal n_estimators",
            "codeSegments": [
              {
                "code": "model = XGBRanker(",
                "line": 26
              },
              {
                "code": "n_estimators=best_n_estimators,",
                "line": 29
              },
              {
                "code": "model.fit(X_train, y_train, group=train_groups)",
                "line": 35
              }
            ]
          },
          {
            "summaryComponent": "Predicts and evaluates rankings",
            "codeSegments": [
              {
                "code": "y_pred = model.predict(X_test)",
                "line": 38
              },
              {
                "code": "ndcg = evaluate_ndcg(y_test.to_numpy(), y_pred, test_groups)",
                "line": 46
              }
            ]
          },
          {
            "summaryComponent": "Visualizes prediction results",
            "codeSegments": [
              {
                "code": "plot_ranking_predictions(df, 2024)",
                "line": 51
              },
              {
                "code": "plot_ranking_predictions(df, 2025)",
                "line": 52
              }
            ]
          }
        ],
        "medium_unstructured": [
          {
            "summaryComponent": "iterates over multiple values for n_estimators",
            "codeSegments": [
              {
                "code": "for n_estimators in [100, 1000, 2000]:",
                "line": 4
              }
            ]
          },
          {
            "summaryComponent": "training and evaluating an XGBoost ranker model on each",
            "codeSegments": [
              {
                "code": "model = XGBRanker(",
                "line": 5
              },
              {
                "code": "model.fit(X_train, y_train, group=train_groups)",
                "line": 14
              },
              {
                "code": "y_pred = model.predict(X_test)",
                "line": 17
              },
              {
                "code": "ndcg = evaluate_ndcg(y_test.to_numpy(), y_pred, test_groups)",
                "line": 18
              }
            ]
          },
          {
            "summaryComponent": "selects the value that yields the best NDCG score",
            "codeSegments": [
              {
                "code": "if ndcg > best_ndcg:",
                "line": 21
              },
              {
                "code": "best_ndcg = ndcg",
                "line": 22
              },
              {
                "code": "best_n_estimators = n_estimators",
                "line": 23
              }
            ]
          },
          {
            "summaryComponent": "retrains the model with this optimal n_estimators",
            "codeSegments": [
              {
                "code": "model = XGBRanker(",
                "line": 26
              },
              {
                "code": "n_estimators=best_n_estimators,",
                "line": 29
              },
              {
                "code": "model.fit(X_train, y_train, group=train_groups)",
                "line": 35
              }
            ]
          },
          {
            "summaryComponent": "predicts scores on test data",
            "codeSegments": [
              {
                "code": "y_pred = model.predict(X_test)",
                "line": 38
              },
              {
                "code": "df.loc[test_idx, \"PredictedScore\"] = y_pred",
                "line": 39
              }
            ]
          },
          {
            "summaryComponent": "assigns predicted ranks",
            "codeSegments": [
              {
                "code": "df.loc[test_idx, \"PredictedRank\"] = (",
                "line": 40
              },
              {
                "code": "df.loc[test_idx]\n        .groupby(\"Year\")[\"PredictedScore\"]\n        .rank(ascending=False, method=\"first\")",
                "line": 41
              }
            ]
          },
          {
            "summaryComponent": "evaluates performance using the NDCG metric",
            "codeSegments": [
              {
                "code": "ndcg = evaluate_ndcg(y_test.to_numpy(), y_pred, test_groups)",
                "line": 46
              }
            ]
          },
          {
            "summaryComponent": "prints results",
            "codeSegments": [
              {
                "code": "print(df[test_idx][[\"Year\", \"Name\", \"Rank\", \"PredictedScore\", \"PredictedRank\"]])",
                "line": 50
              }
            ]
          },
          {
            "summaryComponent": "visualizes the ranking predictions for the years 2024 and 2025",
            "codeSegments": [
              {
                "code": "plot_ranking_predictions(df, 2024)",
                "line": 51
              },
              {
                "code": "plot_ranking_predictions(df, 2025)",
                "line": 52
              }
            ]
          }
        ],
        "medium_structured": [
          {
            "summaryComponent": "Iterates over several n_estimators values, training and evaluating an XGBoost ranker for each",
            "codeSegments": [
              {
                "code": "for n_estimators in [100, 1000, 2000]:",
                "line": 4
              },
              {
                "code": "model = XGBRanker(",
                "line": 5
              },
              {
                "code": "model.fit(X_train, y_train, group=train_groups)",
                "line": 14
              },
              {
                "code": "y_pred = model.predict(X_test)",
                "line": 17
              },
              {
                "code": "ndcg = evaluate_ndcg(y_test.to_numpy(), y_pred, test_groups)",
                "line": 18
              }
            ]
          },
          {
            "summaryComponent": "Selects the n_estimators value with the highest NDCG score",
            "codeSegments": [
              {
                "code": "if ndcg > best_ndcg:",
                "line": 21
              },
              {
                "code": "best_ndcg = ndcg",
                "line": 22
              },
              {
                "code": "best_n_estimators = n_estimators",
                "line": 23
              }
            ]
          },
          {
            "summaryComponent": "Retrains the XGBoost ranker with the optimal n_estimators",
            "codeSegments": [
              {
                "code": "model = XGBRanker(",
                "line": 26
              },
              {
                "code": "n_estimators=best_n_estimators,",
                "line": 29
              },
              {
                "code": "model.fit(X_train, y_train, group=train_groups)",
                "line": 35
              }
            ]
          },
          {
            "summaryComponent": "Predicts scores for the test set and assigns predicted ranks by year",
            "codeSegments": [
              {
                "code": "y_pred = model.predict(X_test)",
                "line": 38
              },
              {
                "code": "df.loc[test_idx, \"PredictedScore\"] = y_pred",
                "line": 39
              },
              {
                "code": "df.loc[test_idx, \"PredictedRank\"] = (",
                "line": 40
              },
              {
                "code": "df.loc[test_idx]\n        .groupby(\"Year\")[\"PredictedScore\"]\n        .rank(ascending=False, method=\"first\")",
                "line": 41
              }
            ]
          },
          {
            "summaryComponent": "Evaluates model performance using the NDCG metric",
            "codeSegments": [
              {
                "code": "ndcg = evaluate_ndcg(y_test.to_numpy(), y_pred, test_groups)",
                "line": 46
              },
              {
                "code": "print(f\"NDCG Score on test years {test_years.tolist()}: {ndcg:.4f}\")",
                "line": 47
              }
            ]
          },
          {
            "summaryComponent": "Displays prediction results and visualizes rankings for selected years",
            "codeSegments": [
              {
                "code": "print(df[test_idx][[\"Year\", \"Name\", \"Rank\", \"PredictedScore\", \"PredictedRank\"]])",
                "line": 50
              },
              {
                "code": "plot_ranking_predictions(df, 2024)",
                "line": 51
              },
              {
                "code": "plot_ranking_predictions(df, 2025)",
                "line": 52
              }
            ]
          }
        ],
        "high_unstructured": [
          {
            "summaryComponent": "includes a model selection step",
            "codeSegments": [
              {
                "code": "for n_estimators in [100, 1000, 2000]:",
                "line": 4
              }
            ]
          },
          {
            "summaryComponent": "it loops through several n_estimators values (100, 1000, 2000)",
            "codeSegments": [
              {
                "code": "for n_estimators in [100, 1000, 2000]:",
                "line": 4
              }
            ]
          },
          {
            "summaryComponent": "training and evaluating an XGBRanker on each using the NDCG metric",
            "codeSegments": [
              {
                "code": "model = XGBRanker(",
                "line": 5
              },
              {
                "code": "model.fit(X_train, y_train, group=train_groups)",
                "line": 14
              },
              {
                "code": "ndcg = evaluate_ndcg(y_test.to_numpy(), y_pred, test_groups)",
                "line": 18
              }
            ]
          },
          {
            "summaryComponent": "selects the n_estimators value that yields the highest NDCG",
            "codeSegments": [
              {
                "code": "if ndcg > best_ndcg:",
                "line": 21
              },
              {
                "code": "best_ndcg = ndcg",
                "line": 22
              },
              {
                "code": "best_n_estimators = n_estimators",
                "line": 23
              }
            ]
          },
          {
            "summaryComponent": "The model is then retrained with this optimal n_estimators",
            "codeSegments": [
              {
                "code": "model = XGBRanker(",
                "line": 26
              },
              {
                "code": "n_estimators=best_n_estimators,",
                "line": 29
              },
              {
                "code": "model.fit(X_train, y_train, group=train_groups)",
                "line": 35
              }
            ]
          },
          {
            "summaryComponent": "After retraining, it predicts scores for the test set",
            "codeSegments": [
              {
                "code": "y_pred = model.predict(X_test)",
                "line": 38
              }
            ]
          },
          {
            "summaryComponent": "updates the DataFrame with predicted scores and ranks (grouped by year)",
            "codeSegments": [
              {
                "code": "df.loc[test_idx, \"PredictedScore\"] = y_pred",
                "line": 39
              },
              {
                "code": "df.loc[test_idx, \"PredictedRank\"] = (",
                "line": 40
              },
              {
                "code": ".groupby(\"Year\")[\"PredictedScore\"]",
                "line": 42
              }
            ]
          },
          {
            "summaryComponent": "evaluates the model's ranking quality using the NDCG metric",
            "codeSegments": [
              {
                "code": "ndcg = evaluate_ndcg(y_test.to_numpy(), y_pred, test_groups)",
                "line": 46
              }
            ]
          },
          {
            "summaryComponent": "prints out the test set results, including actual and predicted ranks",
            "codeSegments": [
              {
                "code": "print(df[test_idx][[\"Year\", \"Name\", \"Rank\", \"PredictedScore\", \"PredictedRank\"]])",
                "line": 50
              }
            ]
          },
          {
            "summaryComponent": "visualizes the ranking predictions for the years 2024 and 2025",
            "codeSegments": [
              {
                "code": "plot_ranking_predictions(df, 2024)",
                "line": 51
              },
              {
                "code": "plot_ranking_predictions(df, 2025)",
                "line": 52
              }
            ]
          }
        ],
        "high_structured": [
          {
            "summaryComponent": "Iterates through multiple n_estimators values (100, 1000, 2000), training and evaluating an XGBRanker for each",
            "codeSegments": [
              {
                "code": "for n_estimators in [100, 1000, 2000]:",
                "line": 4
              },
              {
                "code": "model = XGBRanker(",
                "line": 5
              },
              {
                "code": "model.fit(X_train, y_train, group=train_groups)",
                "line": 14
              }
            ]
          },
          {
            "summaryComponent": "Uses the NDCG metric to assess performance for each n_estimators value",
            "codeSegments": [
              {
                "code": "ndcg = evaluate_ndcg(y_test.to_numpy(), y_pred, test_groups)",
                "line": 18
              }
            ]
          },
          {
            "summaryComponent": "Selects the n_estimators value with the highest NDCG",
            "codeSegments": [
              {
                "code": "if ndcg > best_ndcg:",
                "line": 21
              },
              {
                "code": "best_ndcg = ndcg",
                "line": 22
              },
              {
                "code": "best_n_estimators = n_estimators",
                "line": 23
              }
            ]
          },
          {
            "summaryComponent": "Retrains an XGBRanker with:",
            "codeSegments": [
              {
                "code": "model = XGBRanker(",
                "line": 26
              }
            ]
          },
          {
            "summaryComponent": "Pairwise ranking objective",
            "codeSegments": [
              {
                "code": "objective=\"rank:pairwise\",",
                "line": 27
              }
            ]
          },
          {
            "summaryComponent": "Learning rate of 0.1",
            "codeSegments": [
              {
                "code": "learning_rate=0.1,",
                "line": 28
              }
            ]
          },
          {
            "summaryComponent": "Optimal n_estimators found in the previous step",
            "codeSegments": [
              {
                "code": "n_estimators=best_n_estimators,",
                "line": 29
              }
            ]
          },
          {
            "summaryComponent": "Max depth of 4",
            "codeSegments": [
              {
                "code": "max_depth=4,",
                "line": 30
              }
            ]
          },
          {
            "summaryComponent": "Fixed random seed for reproducibility",
            "codeSegments": [
              {
                "code": "random_state=42,",
                "line": 31
              }
            ]
          },
          {
            "summaryComponent": "Trains the model on grouped training data",
            "codeSegments": [
              {
                "code": "model.fit(X_train, y_train, group=train_groups)",
                "line": 35
              }
            ]
          },
          {
            "summaryComponent": "Predicts ranking scores for the test set",
            "codeSegments": [
              {
                "code": "y_pred = model.predict(X_test)",
                "line": 38
              }
            ]
          },
          {
            "summaryComponent": "Updates the DataFrame with:",
            "codeSegments": [
              {
                "code": "df.loc[test_idx, \"PredictedScore\"] = y_pred",
                "line": 39
              }
            ]
          },
          {
            "summaryComponent": "Predicted scores",
            "codeSegments": [
              {
                "code": "df.loc[test_idx, \"PredictedScore\"] = y_pred",
                "line": 39
              }
            ]
          },
          {
            "summaryComponent": "Predicted ranks, calculated per year using groupby and rank",
            "codeSegments": [
              {
                "code": "df.loc[test_idx, \"PredictedRank\"] = (",
                "line": 40
              },
              {
                "code": ".groupby(\"Year\")[\"PredictedScore\"]",
                "line": 42
              },
              {
                "code": ".rank(ascending=False, method=\"first\")",
                "line": 43
              }
            ]
          },
          {
            "summaryComponent": "Evaluates ranking performance using the NDCG metric",
            "codeSegments": [
              {
                "code": "ndcg = evaluate_ndcg(y_test.to_numpy(), y_pred, test_groups)",
                "line": 46
              }
            ]
          },
          {
            "summaryComponent": "Prints test set results, showing year, name, true rank, predicted score, and predicted rank",
            "codeSegments": [
              {
                "code": "print(df[test_idx][[\"Year\", \"Name\", \"Rank\", \"PredictedScore\", \"PredictedRank\"]])",
                "line": 50
              }
            ]
          },
          {
            "summaryComponent": "Visualizes ranking predictions for the years 2024 and 2025 using plotting functions",
            "codeSegments": [
              {
                "code": "plot_ranking_predictions(df, 2024)",
                "line": 51
              },
              {
                "code": "plot_ranking_predictions(df, 2025)",
                "line": 52
              }
            ]
          }
        ]
      }
    }
  },
  {
    "task_id": "MP-C",
    "metadata": {
      "file_context": "MVPPredictor/rank_model.py",
      "processing_timestamp": 82376.455585759
    },
    "old_code": {
      "code": "def plot_ranking_predictions(df, year):\n    \"\"\"\n    Plot prediction error for a specific year.\n\n    Args:\n        df: DataFrame containing prediction results\n        year: Year to plot prediction errors for\n    \"\"\"\n    df[\"RankError\"] = df[\"PredictedRank\"] - df[\"Rank\"]\n    year_df = df[df[\"Year\"] == year].copy()\n    year_df.sort_values(\"Rank\", inplace=True)\n\n    plt.figure(figsize=(12, 6))\n    sns.barplot(x=\"Name\", y=\"RankError\", data=year_df, hue=\"Name\", palette=\"coolwarm\")\n    plt.axhline(0, color=\"black\", linestyle=\"--\")\n    plt.xticks(rotation=45, ha=\"right\")\n    plt.ylabel(\"Predicted Rank - True Rank\")\n    plt.title(f\"MVP Ranking Predictions ({year})\")\n    plt.tight_layout()\n    plt.savefig(f\"data/ranking_predictions_{year}.png\")",
      "summary": {
        "title": "plot_ranking_predictions Function Summary",
        "low_unstructured": "This function visualizes the prediction error of MVP rankings for a given year using a bar plot.",
        "low_structured": "• Plots MVP ranking prediction errors for a specific year.\n• Saves the resulting bar chart as a PNG file.",
        "medium_unstructured": "The function calculates the difference between predicted and actual ranks for MVP candidates in a specified year. It then creates and saves a bar plot visualizing these errors for each candidate. The plot is customized with labels, a horizontal reference line, and rotated x-axis labels.",
        "medium_structured": "• Computes the error between predicted and actual ranks for each candidate.\n• Filters data to only include entries from the specified year.\n• Creates a bar plot showing the ranking errors by candidate.\n  ◦ Customizes the plot with labels and a reference line at zero.\n• Saves the plot as a PNG file named for the year.",
        "high_unstructured": "This function first computes the ranking error by subtracting the true rank from the predicted rank for each entry in the DataFrame. It then filters the data to only include records from the specified year and sorts them by true rank. Using seaborn and matplotlib, it generates a bar plot of the ranking errors for each candidate, with color coding by name, a horizontal line at zero, and rotated x-axis labels for readability. The plot is given a descriptive title and y-axis label, is tightly laid out, and is saved as a PNG file in the data directory with the year in the filename.",
        "high_structured": "• Calculates the ranking error for each entry as PredictedRank minus Rank.\n• Filters the DataFrame to only include data for the specified year.\n• Sorts the filtered data by true rank for ordered plotting.\n• Generates a bar plot of ranking errors:\n  ◦ X-axis: Candidate names (rotated for readability)\n  ◦ Y-axis: Rank error (PredictedRank - True Rank)\n  ◦ Colors bars by candidate name using a coolwarm palette\n  ◦ Adds a horizontal dashed line at zero for reference\n• Sets plot labels and title to clarify the visualization.\n• Adjusts layout to prevent overlap and saves the plot as a PNG file named with the year."
      },
      "mappings": {
        "low_unstructured": [
          {
            "summaryComponent": "This function",
            "codeSegments": [
              {
                "code": "def plot_ranking_predictions(df, year):",
                "line": 1
              }
            ]
          },
          {
            "summaryComponent": "visualizes the prediction error",
            "codeSegments": [
              {
                "code": "df[\"RankError\"] = df[\"PredictedRank\"] - df[\"Rank\"]",
                "line": 9
              },
              {
                "code": "sns.barplot(x=\"Name\", y=\"RankError\", data=year_df, hue=\"Name\", palette=\"coolwarm\")",
                "line": 14
              }
            ]
          },
          {
            "summaryComponent": "of MVP rankings",
            "codeSegments": [
              {
                "code": "plt.title(f\"MVP Ranking Predictions ({year})\")",
                "line": 18
              }
            ]
          },
          {
            "summaryComponent": "for a given year",
            "codeSegments": [
              {
                "code": "year_df = df[df[\"Year\"] == year].copy()",
                "line": 10
              },
              {
                "code": "plt.title(f\"MVP Ranking Predictions ({year})\")",
                "line": 18
              },
              {
                "code": "plt.savefig(f\"data/ranking_predictions_{year}.png\")",
                "line": 20
              }
            ]
          },
          {
            "summaryComponent": "using a bar plot",
            "codeSegments": [
              {
                "code": "sns.barplot(x=\"Name\", y=\"RankError\", data=year_df, hue=\"Name\", palette=\"coolwarm\")",
                "line": 14
              }
            ]
          }
        ],
        "low_structured": [
          {
            "summaryComponent": "Plots MVP ranking prediction errors for a specific year.",
            "codeSegments": [
              {
                "code": "def plot_ranking_predictions(df, year):",
                "line": 1
              },
              {
                "code": "df[\"RankError\"] = df[\"PredictedRank\"] - df[\"Rank\"]",
                "line": 9
              },
              {
                "code": "year_df = df[df[\"Year\"] == year].copy()",
                "line": 10
              },
              {
                "code": "sns.barplot(x=\"Name\", y=\"RankError\", data=year_df, hue=\"Name\", palette=\"coolwarm\")",
                "line": 14
              }
            ]
          },
          {
            "summaryComponent": "Saves the resulting bar chart as a PNG file.",
            "codeSegments": [
              {
                "code": "plt.savefig(f\"data/ranking_predictions_{year}.png\")",
                "line": 20
              }
            ]
          }
        ],
        "medium_unstructured": [
          {
            "summaryComponent": "calculates the difference between predicted and actual ranks",
            "codeSegments": [
              {
                "code": "df[\"RankError\"] = df[\"PredictedRank\"] - df[\"Rank\"]",
                "line": 9
              }
            ]
          },
          {
            "summaryComponent": "for MVP candidates",
            "codeSegments": [
              {
                "code": "x=\"Name\"",
                "line": 14
              }
            ]
          },
          {
            "summaryComponent": "in a specified year",
            "codeSegments": [
              {
                "code": "year_df = df[df[\"Year\"] == year].copy()",
                "line": 10
              }
            ]
          },
          {
            "summaryComponent": "creates and saves a bar plot",
            "codeSegments": [
              {
                "code": "sns.barplot(x=\"Name\", y=\"RankError\", data=year_df, hue=\"Name\", palette=\"coolwarm\")",
                "line": 14
              },
              {
                "code": "plt.savefig(f\"data/ranking_predictions_{year}.png\")",
                "line": 20
              }
            ]
          },
          {
            "summaryComponent": "visualizing these errors for each candidate",
            "codeSegments": [
              {
                "code": "y=\"RankError\"",
                "line": 14
              }
            ]
          },
          {
            "summaryComponent": "The plot is customized with labels",
            "codeSegments": [
              {
                "code": "plt.ylabel(\"Predicted Rank - True Rank\")",
                "line": 17
              },
              {
                "code": "plt.title(f\"MVP Ranking Predictions ({year})\")",
                "line": 18
              }
            ]
          },
          {
            "summaryComponent": "a horizontal reference line",
            "codeSegments": [
              {
                "code": "plt.axhline(0, color=\"black\", linestyle=\"--\")",
                "line": 15
              }
            ]
          },
          {
            "summaryComponent": "rotated x-axis labels",
            "codeSegments": [
              {
                "code": "plt.xticks(rotation=45, ha=\"right\")",
                "line": 16
              }
            ]
          }
        ],
        "medium_structured": [
          {
            "summaryComponent": "Computes the error between predicted and actual ranks for each candidate.",
            "codeSegments": [
              {
                "code": "df[\"RankError\"] = df[\"PredictedRank\"] - df[\"Rank\"]",
                "line": 9
              }
            ]
          },
          {
            "summaryComponent": "Filters data to only include entries from the specified year.",
            "codeSegments": [
              {
                "code": "year_df = df[df[\"Year\"] == year].copy()",
                "line": 10
              }
            ]
          },
          {
            "summaryComponent": "Creates a bar plot showing the ranking errors by candidate.",
            "codeSegments": [
              {
                "code": "sns.barplot(x=\"Name\", y=\"RankError\", data=year_df, hue=\"Name\", palette=\"coolwarm\")",
                "line": 14
              }
            ]
          },
          {
            "summaryComponent": "Customizes the plot with labels and a reference line at zero.",
            "codeSegments": [
              {
                "code": "plt.axhline(0, color=\"black\", linestyle=\"--\")",
                "line": 15
              },
              {
                "code": "plt.xticks(rotation=45, ha=\"right\")",
                "line": 16
              },
              {
                "code": "plt.ylabel(\"Predicted Rank - True Rank\")",
                "line": 17
              },
              {
                "code": "plt.title(f\"MVP Ranking Predictions ({year})\")",
                "line": 18
              }
            ]
          },
          {
            "summaryComponent": "Saves the plot as a PNG file named for the year.",
            "codeSegments": [
              {
                "code": "plt.savefig(f\"data/ranking_predictions_{year}.png\")",
                "line": 20
              }
            ]
          }
        ],
        "high_unstructured": [
          {
            "summaryComponent": "computes the ranking error by subtracting the true rank from the predicted rank for each entry in the DataFrame",
            "codeSegments": [
              {
                "code": "df[\"RankError\"] = df[\"PredictedRank\"] - df[\"Rank\"]",
                "line": 9
              }
            ]
          },
          {
            "summaryComponent": "filters the data to only include records from the specified year",
            "codeSegments": [
              {
                "code": "year_df = df[df[\"Year\"] == year].copy()",
                "line": 10
              }
            ]
          },
          {
            "summaryComponent": "sorts them by true rank",
            "codeSegments": [
              {
                "code": "year_df.sort_values(\"Rank\", inplace=True)",
                "line": 11
              }
            ]
          },
          {
            "summaryComponent": "generates a bar plot of the ranking errors for each candidate",
            "codeSegments": [
              {
                "code": "sns.barplot(x=\"Name\", y=\"RankError\", data=year_df, hue=\"Name\", palette=\"coolwarm\")",
                "line": 14
              }
            ]
          },
          {
            "summaryComponent": "with color coding by name",
            "codeSegments": [
              {
                "code": "hue=\"Name\"",
                "line": 14
              },
              {
                "code": "palette=\"coolwarm\"",
                "line": 14
              }
            ]
          },
          {
            "summaryComponent": "a horizontal line at zero",
            "codeSegments": [
              {
                "code": "plt.axhline(0, color=\"black\", linestyle=\"--\")",
                "line": 15
              }
            ]
          },
          {
            "summaryComponent": "rotated x-axis labels for readability",
            "codeSegments": [
              {
                "code": "plt.xticks(rotation=45, ha=\"right\")",
                "line": 16
              }
            ]
          },
          {
            "summaryComponent": "The plot is given a descriptive title",
            "codeSegments": [
              {
                "code": "plt.title(f\"MVP Ranking Predictions ({year})\")",
                "line": 18
              }
            ]
          },
          {
            "summaryComponent": "and y-axis label",
            "codeSegments": [
              {
                "code": "plt.ylabel(\"Predicted Rank - True Rank\")",
                "line": 17
              }
            ]
          },
          {
            "summaryComponent": "is tightly laid out, and is saved as a PNG file in the data directory with the year in the filename",
            "codeSegments": [
              {
                "code": "plt.tight_layout()",
                "line": 19
              },
              {
                "code": "plt.savefig(f\"data/ranking_predictions_{year}.png\")",
                "line": 20
              }
            ]
          }
        ],
        "high_structured": [
          {
            "summaryComponent": "Calculates the ranking error for each entry as PredictedRank minus Rank.",
            "codeSegments": [
              {
                "code": "df[\"RankError\"] = df[\"PredictedRank\"] - df[\"Rank\"]",
                "line": 9
              }
            ]
          },
          {
            "summaryComponent": "Filters the DataFrame to only include data for the specified year.",
            "codeSegments": [
              {
                "code": "year_df = df[df[\"Year\"] == year].copy()",
                "line": 10
              }
            ]
          },
          {
            "summaryComponent": "Sorts the filtered data by true rank for ordered plotting.",
            "codeSegments": [
              {
                "code": "year_df.sort_values(\"Rank\", inplace=True)",
                "line": 11
              }
            ]
          },
          {
            "summaryComponent": "Generates a bar plot of ranking errors:",
            "codeSegments": [
              {
                "code": "sns.barplot(x=\"Name\", y=\"RankError\", data=year_df, hue=\"Name\", palette=\"coolwarm\")",
                "line": 14
              }
            ]
          },
          {
            "summaryComponent": "X-axis: Candidate names (rotated for readability)",
            "codeSegments": [
              {
                "code": "sns.barplot(x=\"Name\", y=\"RankError\", data=year_df, hue=\"Name\", palette=\"coolwarm\")",
                "line": 14
              },
              {
                "code": "plt.xticks(rotation=45, ha=\"right\")",
                "line": 16
              }
            ]
          },
          {
            "summaryComponent": "Y-axis: Rank error (PredictedRank - True Rank)",
            "codeSegments": [
              {
                "code": "sns.barplot(x=\"Name\", y=\"RankError\", data=year_df, hue=\"Name\", palette=\"coolwarm\")",
                "line": 14
              },
              {
                "code": "plt.ylabel(\"Predicted Rank - True Rank\")",
                "line": 17
              }
            ]
          },
          {
            "summaryComponent": "Colors bars by candidate name using a coolwarm palette",
            "codeSegments": [
              {
                "code": "sns.barplot(x=\"Name\", y=\"RankError\", data=year_df, hue=\"Name\", palette=\"coolwarm\")",
                "line": 14
              }
            ]
          },
          {
            "summaryComponent": "Adds a horizontal dashed line at zero for reference",
            "codeSegments": [
              {
                "code": "plt.axhline(0, color=\"black\", linestyle=\"--\")",
                "line": 15
              }
            ]
          },
          {
            "summaryComponent": "Sets plot labels and title to clarify the visualization.",
            "codeSegments": [
              {
                "code": "plt.ylabel(\"Predicted Rank - True Rank\")",
                "line": 17
              },
              {
                "code": "plt.title(f\"MVP Ranking Predictions ({year})\")",
                "line": 18
              }
            ]
          },
          {
            "summaryComponent": "Adjusts layout to prevent overlap and saves the plot as a PNG file named with the year.",
            "codeSegments": [
              {
                "code": "plt.tight_layout()",
                "line": 19
              },
              {
                "code": "plt.savefig(f\"data/ranking_predictions_{year}.png\")",
                "line": 20
              }
            ]
          }
        ]
      }
    },
    "new_code": {
      "code": "def plot_ranking_predictions(df, year):\n    \"\"\"\n    Display real and predicted ranks side-by-side for comparison.\n\n    Args:\n        df: DataFrame containing prediction results\n        year: Year to plot prediction errors for\n    \"\"\"\n    year_df = df[df[\"Year\"] == year].copy()\n    year_df.sort_values(\"Rank\", inplace=True)\n\n    plt.figure(figsize=(12, 6))\n    width = 0.35  # the width of the bars\n    indices = np.arange(len(year_df))\n\n    plt.bar(\n        indices,\n        year_df[\"Rank\"],\n        width,\n        label=\"True Rank\",\n        color=sns.color_palette(\"coolwarm\", 2)[0],\n    )\n    plt.bar(\n        indices + width,\n        year_df[\"PredictedRank\"],\n        width,\n        label=\"Predicted Rank\",\n        color=sns.color_palette(\"coolwarm\", 2)[1],\n        alpha=0.6,\n    )\n\n    plt.xticks(indices + width / 2, year_df[\"Name\"], rotation=45, ha=\"right\")\n    plt.ylabel(\"Rank\")\n    plt.title(f\"MVP Ranking Predictions ({year})\")\n    plt.legend()\n    plt.tight_layout()\n    plt.savefig(f\"data/ranking_predictions_{year}.png\")",
      "summary": {
        "title": "plot_ranking_predictions Function Summary",
        "low_unstructured": "This function visualizes the true and predicted MVP ranks side-by-side for a given year using a grouped bar plot, replacing the previous visualization of prediction errors.",
        "low_structured": "• Plots true and predicted MVP ranks side-by-side for a specific year using grouped bars.\n• Saves the resulting bar chart as a PNG file.",
        "medium_unstructured": "The function filters the DataFrame for MVP candidates in a specified year, then creates and saves a grouped bar plot comparing true and predicted ranks for each candidate. Unlike before, it no longer visualizes ranking errors but instead displays both rank values directly, with customized labels, a legend, and rotated x-axis labels.",
        "medium_structured": "• Filters data to only include entries from the specified year.\n• Sorts the filtered data by true rank for ordered plotting.\n• Creates a grouped bar plot showing both true and predicted ranks for each candidate.\n  ◦ Customizes the plot with labels, a legend, and rotated x-axis labels for readability.\n• Saves the plot as a PNG file named for the year.",
        "high_unstructured": "This function filters the DataFrame to only include records from the specified year and sorts them by true rank. It then generates a grouped bar plot for each candidate, displaying both the true rank and predicted rank side-by-side using distinct colors from a coolwarm palette and partial transparency for the predicted rank. The plot includes a legend, rotated x-axis labels for candidate names, descriptive title and y-axis label, and is tightly laid out before being saved as a PNG file in the data directory with the year in the filename. Unlike the previous version, it no longer computes or visualizes ranking errors, focusing instead on direct rank comparison.",
        "high_structured": "• Filters the DataFrame to only include data for the specified year.\n• Sorts the filtered data by true rank for ordered plotting.\n• Generates a grouped bar plot for each candidate:\n  ◦ X-axis: Candidate names (rotated for readability)\n  ◦ Two bars per candidate: one for true rank, one for predicted rank, using distinct colors and partial transparency\n  ◦ Includes a legend to distinguish true and predicted ranks\n• Sets plot labels and title to clarify the visualization.\n• Adjusts layout to prevent overlap and saves the plot as a PNG file named with the year.\n• No longer calculates or plots ranking errors; instead, directly compares true and predicted ranks."
      },
      "mappings": {
        "low_unstructured": [
          {
            "summaryComponent": "This function visualizes",
            "codeSegments": [
              {
                "code": "def plot_ranking_predictions(df, year):",
                "line": 1
              }
            ]
          },
          {
            "summaryComponent": "the true and predicted MVP ranks",
            "codeSegments": [
              {
                "code": "year_df[\"Rank\"]",
                "line": 18
              },
              {
                "code": "year_df[\"PredictedRank\"]",
                "line": 25
              }
            ]
          },
          {
            "summaryComponent": "side-by-side",
            "codeSegments": [
              {
                "code": "plt.bar(",
                "line": 16
              },
              {
                "code": "plt.bar(",
                "line": 23
              }
            ]
          },
          {
            "summaryComponent": "for a given year",
            "codeSegments": [
              {
                "code": "year_df = df[df[\"Year\"] == year].copy()",
                "line": 9
              }
            ]
          },
          {
            "summaryComponent": "using a grouped bar plot",
            "codeSegments": [
              {
                "code": "plt.bar(",
                "line": 16
              },
              {
                "code": "plt.bar(",
                "line": 23
              }
            ]
          },
          {
            "summaryComponent": "replacing the previous visualization of prediction errors",
            "codeSegments": [
              {
                "code": "plt.title(f\"MVP Ranking Predictions ({year})\")",
                "line": 34
              }
            ]
          }
        ],
        "low_structured": [
          {
            "summaryComponent": "Plots true and predicted MVP ranks side-by-side for a specific year using grouped bars.",
            "codeSegments": [
              {
                "code": "plt.bar(",
                "line": 16
              },
              {
                "code": "indices,",
                "line": 17
              },
              {
                "code": "year_df[\"Rank\"],",
                "line": 18
              },
              {
                "code": "width,",
                "line": 19
              },
              {
                "code": "label=\"True Rank\",",
                "line": 20
              },
              {
                "code": "color=sns.color_palette(\"coolwarm\", 2)[0],",
                "line": 21
              },
              {
                "code": ")",
                "line": 22
              },
              {
                "code": "plt.bar(",
                "line": 23
              },
              {
                "code": "indices + width,",
                "line": 24
              },
              {
                "code": "year_df[\"PredictedRank\"],",
                "line": 25
              },
              {
                "code": "width,",
                "line": 26
              },
              {
                "code": "label=\"Predicted Rank\",",
                "line": 27
              },
              {
                "code": "color=sns.color_palette(\"coolwarm\", 2)[1],",
                "line": 28
              },
              {
                "code": ")",
                "line": 30
              }
            ]
          },
          {
            "summaryComponent": "Saves the resulting bar chart as a PNG file.",
            "codeSegments": [
              {
                "code": "plt.savefig(f\"data/ranking_predictions_{year}.png\")",
                "line": 37
              }
            ]
          }
        ],
        "medium_unstructured": [
          {
            "summaryComponent": "filters the DataFrame for MVP candidates in a specified year",
            "codeSegments": [
              {
                "code": "year_df = df[df[\"Year\"] == year].copy()",
                "line": 9
              }
            ]
          },
          {
            "summaryComponent": "creates and saves a grouped bar plot",
            "codeSegments": [
              {
                "code": "plt.figure(figsize=(12, 6))",
                "line": 12
              },
              {
                "code": "plt.bar(",
                "line": 16
              },
              {
                "code": "plt.bar(",
                "line": 23
              },
              {
                "code": "plt.savefig(f\"data/ranking_predictions_{year}.png\")",
                "line": 37
              }
            ]
          },
          {
            "summaryComponent": "comparing true and predicted ranks for each candidate",
            "codeSegments": [
              {
                "code": "plt.bar(",
                "line": 16
              },
              {
                "code": "year_df[\"Rank\"]",
                "line": 18
              },
              {
                "code": "plt.bar(",
                "line": 23
              },
              {
                "code": "year_df[\"PredictedRank\"]",
                "line": 25
              }
            ]
          },
          {
            "summaryComponent": "displays both rank values directly",
            "codeSegments": [
              {
                "code": "year_df[\"Rank\"]",
                "line": 18
              },
              {
                "code": "year_df[\"PredictedRank\"]",
                "line": 25
              }
            ]
          },
          {
            "summaryComponent": "customized labels",
            "codeSegments": [
              {
                "code": "plt.ylabel(\"Rank\")",
                "line": 33
              },
              {
                "code": "plt.title(f\"MVP Ranking Predictions ({year})\")",
                "line": 34
              }
            ]
          },
          {
            "summaryComponent": "a legend",
            "codeSegments": [
              {
                "code": "plt.legend()",
                "line": 35
              }
            ]
          },
          {
            "summaryComponent": "rotated x-axis labels",
            "codeSegments": [
              {
                "code": "plt.xticks(indices + width / 2, year_df[\"Name\"], rotation=45, ha=\"right\")",
                "line": 32
              }
            ]
          }
        ],
        "medium_structured": [
          {
            "summaryComponent": "Filters data to only include entries from the specified year.",
            "codeSegments": [
              {
                "code": "year_df = df[df[\"Year\"] == year].copy()",
                "line": 9
              }
            ]
          },
          {
            "summaryComponent": "Sorts the filtered data by true rank for ordered plotting.",
            "codeSegments": [
              {
                "code": "year_df.sort_values(\"Rank\", inplace=True)",
                "line": 10
              }
            ]
          },
          {
            "summaryComponent": "Creates a grouped bar plot showing both true and predicted ranks for each candidate.",
            "codeSegments": [
              {
                "code": "plt.bar(",
                "line": 16
              },
              {
                "code": "indices,",
                "line": 17
              },
              {
                "code": "year_df[\"Rank\"],",
                "line": 18
              },
              {
                "code": "width,",
                "line": 19
              },
              {
                "code": "label=\"True Rank\",",
                "line": 20
              },
              {
                "code": "color=sns.color_palette(\"coolwarm\", 2)[0],",
                "line": 21
              },
              {
                "code": ")",
                "line": 22
              },
              {
                "code": "plt.bar(",
                "line": 23
              },
              {
                "code": "indices + width,",
                "line": 24
              },
              {
                "code": "year_df[\"PredictedRank\"],",
                "line": 25
              },
              {
                "code": "width,",
                "line": 26
              },
              {
                "code": "label=\"Predicted Rank\",",
                "line": 27
              },
              {
                "code": "color=sns.color_palette(\"coolwarm\", 2)[1],",
                "line": 28
              },
              {
                "code": "alpha=0.6,",
                "line": 29
              },
              {
                "code": ")",
                "line": 30
              }
            ]
          },
          {
            "summaryComponent": "Customizes the plot with labels, a legend, and rotated x-axis labels for readability.",
            "codeSegments": [
              {
                "code": "plt.xticks(indices + width / 2, year_df[\"Name\"], rotation=45, ha=\"right\")",
                "line": 32
              },
              {
                "code": "plt.ylabel(\"Rank\")",
                "line": 33
              },
              {
                "code": "plt.title(f\"MVP Ranking Predictions ({year})\")",
                "line": 34
              },
              {
                "code": "plt.legend()",
                "line": 35
              }
            ]
          },
          {
            "summaryComponent": "Saves the plot as a PNG file named for the year.",
            "codeSegments": [
              {
                "code": "plt.savefig(f\"data/ranking_predictions_{year}.png\")",
                "line": 37
              }
            ]
          }
        ],
        "high_unstructured": [
          {
            "summaryComponent": "filters the DataFrame to only include records from the specified year",
            "codeSegments": [
              {
                "code": "year_df = df[df[\"Year\"] == year].copy()",
                "line": 9
              }
            ]
          },
          {
            "summaryComponent": "sorts them by true rank",
            "codeSegments": [
              {
                "code": "year_df.sort_values(\"Rank\", inplace=True)",
                "line": 10
              }
            ]
          },
          {
            "summaryComponent": "generates a grouped bar plot for each candidate",
            "codeSegments": [
              {
                "code": "plt.bar(",
                "line": 16
              },
              {
                "code": "plt.bar(",
                "line": 23
              }
            ]
          },
          {
            "summaryComponent": "displaying both the true rank and predicted rank side-by-side",
            "codeSegments": [
              {
                "code": "year_df[\"Rank\"]",
                "line": 18
              },
              {
                "code": "year_df[\"PredictedRank\"]",
                "line": 25
              }
            ]
          },
          {
            "summaryComponent": "using distinct colors from a coolwarm palette",
            "codeSegments": [
              {
                "code": "color=sns.color_palette(\"coolwarm\", 2)[0]",
                "line": 21
              },
              {
                "code": "color=sns.color_palette(\"coolwarm\", 2)[1]",
                "line": 28
              }
            ]
          },
          {
            "summaryComponent": "partial transparency for the predicted rank",
            "codeSegments": [
              {
                "code": "alpha=0.6",
                "line": 29
              }
            ]
          },
          {
            "summaryComponent": "plot includes a legend",
            "codeSegments": [
              {
                "code": "plt.legend()",
                "line": 35
              }
            ]
          },
          {
            "summaryComponent": "rotated x-axis labels for candidate names",
            "codeSegments": [
              {
                "code": "plt.xticks(indices + width / 2, year_df[\"Name\"], rotation=45, ha=\"right\")",
                "line": 32
              }
            ]
          },
          {
            "summaryComponent": "descriptive title and y-axis label",
            "codeSegments": [
              {
                "code": "plt.ylabel(\"Rank\")",
                "line": 33
              },
              {
                "code": "plt.title(f\"MVP Ranking Predictions ({year})\")",
                "line": 34
              }
            ]
          },
          {
            "summaryComponent": "tightly laid out before being saved as a PNG file in the data directory with the year in the filename",
            "codeSegments": [
              {
                "code": "plt.tight_layout()",
                "line": 36
              },
              {
                "code": "plt.savefig(f\"data/ranking_predictions_{year}.png\")",
                "line": 37
              }
            ]
          }
        ],
        "high_structured": [
          {
            "summaryComponent": "Filters the DataFrame to only include data for the specified year.",
            "codeSegments": [
              {
                "code": "year_df = df[df[\"Year\"] == year].copy()",
                "line": 9
              }
            ]
          },
          {
            "summaryComponent": "Sorts the filtered data by true rank for ordered plotting.",
            "codeSegments": [
              {
                "code": "year_df.sort_values(\"Rank\", inplace=True)",
                "line": 10
              }
            ]
          },
          {
            "summaryComponent": "Generates a grouped bar plot for each candidate:",
            "codeSegments": [
              {
                "code": "plt.bar(",
                "line": 16
              },
              {
                "code": "plt.bar(",
                "line": 23
              }
            ]
          },
          {
            "summaryComponent": "X-axis: Candidate names (rotated for readability)",
            "codeSegments": [
              {
                "code": "plt.xticks(indices + width / 2, year_df[\"Name\"], rotation=45, ha=\"right\")",
                "line": 32
              }
            ]
          },
          {
            "summaryComponent": "Two bars per candidate: one for true rank, one for predicted rank, using distinct colors and partial transparency",
            "codeSegments": [
              {
                "code": "plt.bar(",
                "line": 16
              },
              {
                "code": "plt.bar(",
                "line": 23
              },
              {
                "code": "color=sns.color_palette(\"coolwarm\", 2)[0],",
                "line": 21
              },
              {
                "code": "color=sns.color_palette(\"coolwarm\", 2)[1],",
                "line": 28
              },
              {
                "code": "alpha=0.6,",
                "line": 29
              }
            ]
          },
          {
            "summaryComponent": "Includes a legend to distinguish true and predicted ranks",
            "codeSegments": [
              {
                "code": "plt.legend()",
                "line": 35
              }
            ]
          },
          {
            "summaryComponent": "Sets plot labels and title to clarify the visualization.",
            "codeSegments": [
              {
                "code": "plt.ylabel(\"Rank\")",
                "line": 33
              },
              {
                "code": "plt.title(f\"MVP Ranking Predictions ({year})\")",
                "line": 34
              }
            ]
          },
          {
            "summaryComponent": "Adjusts layout to prevent overlap and saves the plot as a PNG file named with the year.",
            "codeSegments": [
              {
                "code": "plt.tight_layout()",
                "line": 36
              },
              {
                "code": "plt.savefig(f\"data/ranking_predictions_{year}.png\")",
                "line": 37
              }
            ]
          },
          {
            "summaryComponent": "No longer calculates or plots ranking errors; instead, directly compares true and predicted ranks.",
            "codeSegments": [
              {
                "code": "plt.bar(",
                "line": 16
              },
              {
                "code": "plt.bar(",
                "line": 23
              }
            ]
          }
        ]
      }
    }
  }
]